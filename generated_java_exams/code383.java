/*
 * Exam Question #383
 * Generated on: 2025-05-11 23:03:05
 * Generated by: Account 5
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Restaurant Order Management System
 * 
 * **Scenario:**
 * 
 * You are tasked with developing a simplified order management system for a small restaurant. The system needs to handle customer orders, process them in the order they were received, and display the current state of pending orders.
 * 
 * **Requirements:**
 * 
 * 1.  **Data Structures:**
 *     *   Maintain a list of available menu items.
 *     *   Maintain a queue of customer orders awaiting preparation/serving.
 * 2.  **Functionality:**
 *     *   Display the menu to the user.
 *     *   Allow a customer order to be placed. An order consists of one or more menu items with specified quantities. The system should validate that selected items exist and quantities are positive.
 *     *   Allow the next order in the queue to be served (removed from the queue).
 *     *   Allow viewing all pending orders in the queue without removing them.
 *     *   Provide a simple command-line interface (CLI) for user interaction.
 * 3.  **Required Java Components:** Your solution *must* explicitly use and demonstrate understanding of the following:
 *     *   `java.util.Queue`
 *     *   `java.util.ArrayList`
 *     *   `java.util.List` (as the type for menu items)
 *     *   `java.util.Scanner` for all user input.
 *     *   `switch` statement for handling different user commands/menu options.
 *     *   `System.err` for printing error messages (e.g., invalid input, attempting to serve from an empty queue).
 *     *   `System.out` for printing normal output (menu, order details, success messages).
 *     *   Class-wide exception handling using `try-catch` blocks, specifically for handling potential input parsing errors (e.g., `NumberFormatException`).
 * 4.  **Best Practices:**
 *     *   Use proper encapsulation for classes representing menu items and orders.
 *     *   Use meaningful variable and method names.
 *     *   Include appropriate comments to explain complex logic.
 *     *   Implement input validation.
 *     *   Ensure proper error handling using `try-catch` and `System.err`.
 *     *   Structure the code logically into appropriate classes.
 * 
 * **Implementation Details:**
 * 
 * *   Create a `MenuItem` class (or similar) with properties like name and price.
 * *   Create an `Order` class (or similar) that can hold a list of selected `MenuItem`s and their quantities. Assign a unique ID to each order.
 * *   Create a main class (e.g., `RestaurantOrderSystem`) that contains the menu list and the order queue. This class should handle the user interaction loop.
 * *   Initialize the menu with a few sample items within the main class.
 * *   The user interface should present options like "View Menu", "Place Order", "Serve Next Order", "View Order Queue", "Exit".
 * 
 * **Expected Output:**
 * 
 * The program should run interactively.
 * *   Displaying the menu should list items with indices.
 * *   Placing an order should prompt for item indices and quantities, validate input, calculate a total (optional but recommended), and confirm the order is placed.
 * *   Serving an order should indicate which order ID is served and its contents/total.
 * *   Viewing the queue should list pending order IDs and potentially brief details.
 * *   Invalid user input (menu choice, item index, quantity) or actions (serving from empty queue) should result in an informative message printed to `System.err`.
 * *   Valid operations and information should be printed to `System.out`.
 * 
 * **Example Interaction Flow:**
 * 
 * ```
 * Welcome to the Restaurant Order System!
 * Menu:
 * 1. Burger ($9.99)
 * 2. Fries ($3.49)
 * 3. Drink ($1.99)
 * 
 * Options:
 * 1. View Menu
 * 2. Place Order
 * 3. Serve Next Order
 * 4. View Order Queue
 * 5. Exit
 * Enter your choice: 1
 * Menu:
 * 1. Burger ($9.99)
 * 2. Fries ($3.49)
 * 3. Drink ($1.99)
 * 
 * Options:
 * 1. View Menu
 * ... (menu options repeated)
 * Enter your choice: 2
 * --- Place New Order ---
 * Enter item number (0 to finish): 1
 * Enter quantity: 2
 * Added 2 x Burger
 * 
 * Enter item number (0 to finish): 3
 * Enter quantity: 1
 * Added 1 x Drink
 * 
 * Enter item number (0 to finish): 0
 * Order #1 placed. Total: $21.97
 * 
 * Options:
 * ... (menu options repeated)
 * Enter your choice: 4
 * --- Pending Orders ---
 * Order #1 (2 items)
 * 
 * Options:
 * ... (menu options repeated)
 * Enter your choice: 3
 * Serving Order #1...
 * Items: 2 x Burger, 1 x Drink
 * Total: $21.97
 * 
 * Options:
 * ... (menu options repeated)
 * Enter your choice: 4
 * --- Pending Orders ---
 * Queue is empty.
 * 
 * Options:
 * ... (menu options repeated)
 * Enter your choice: 3
 * Error: The order queue is empty. Cannot serve.
 * 
 * Options:
 * ... (menu options repeated)
 * Enter your choice: 6
 * Error: Invalid choice. Please enter a number between 1 and 5.
 * 
 * Options:
 * ... (menu options repeated)
 * Enter your choice: 5
 * Exiting system. Goodbye!
 * ```
 * 
 * Your task is to write the complete Java code for this system.
 *
 * EXPLANATION:
 * This solution implements a basic Restaurant Order Management System, demonstrating the required Java concepts and best practices.
 * 
 * 1.  **Scenario Implementation:**
 *     *   `MenuItem` class encapsulates the data for a single menu item (name and price).
 *     *   `Order` class encapsulates the data for a customer order. It contains a list (`ArrayList`) of `OrderItem` objects (an inner class holding a `MenuItem` and quantity) and a unique `orderId`. The `nextOrderId` static variable ensures unique IDs.
 *     *   `RestaurantOrderSystem` class manages the overall system state: the list of available menu items (`menuItems`) and the queue of pending orders (`orderQueue`).
 * 
 * 2.  **Required Java Components:**
 *     *   `java.util.Queue`: The `orderQueue` is declared as a `Queue<Order>` and initialized with `new LinkedList<>()`. `LinkedList` is a common implementation of `Queue` that provides efficient adding (`offer`) and removing (`poll`) from the ends. The `serveNextOrder` method uses `poll()` to retrieve and remove the next order, adhering to the FIFO principle. The `viewOrderQueue` method iterates over the queue using an enhanced for loop, which does not remove elements.
 *     *   `java.util.ArrayList`: Used to initialize and store the `menuItems`. It provides dynamic resizing and easy access by index. It's also used internally within the `Order` class to store the list of `OrderItem`s for that specific order.
 *     *   `java.util.List`: The `menuItems` variable is declared with the interface type `List<MenuItem>`, demonstrating good practice by programming to the interface rather than the specific implementation (`ArrayList`).
 *     *   `java.util.Scanner`: An instance `scanner` is used throughout the `RestaurantOrderSystem` class to read user input from `System.in`.
 *     *   `switch` statement: The `run()` method uses a `switch` statement based on the user's integer choice to direct the program flow to the appropriate method (`displayMenu`, `placeOrder`, `serveNextOrder`, `viewOrderQueue`, or exit).
 *     *   `System.err`: Used in `placeOrder` for invalid item/quantity input, in `serveNextOrder` when the queue is empty, and in `run` for invalid main menu choices. These messages are directed to the standard error stream, typically displayed in red in IDEs, distinguishing them from normal output.
 *     *   `System.out`: Used for all normal program output, including welcome messages, the menu display, confirmation messages for placing/serving orders, and viewing the queue contents.
 *     *   `try-catch` blocks: Implemented in the `run()` method to catch `NumberFormatException` when parsing the main menu choice, and within the `placeOrder()` method to catch `NumberFormatException` when parsing item numbers and quantities. This provides robust handling of non-numeric user input. The `catch` blocks print an error message to `System.err` and allow the program to continue.
 * 
 * 3.  **Best Practices:**
 *     *   **Encapsulation:** `MenuItem` and `Order` classes have private fields and public getter methods. The `OrderItem` inner class is private to `Order`.
 *     *   **Meaningful Names:** Variables like `menuItems`, `orderQueue`, `placeOrder`, `serveNextOrder`, `itemIndex`, `quantity` are descriptive.
 *     *   **Comments:** Comments are used to explain the purpose of classes, methods, and specific code blocks.
 *     *   **Input Validation:** The `placeOrder` method checks if the entered item number corresponds to a valid menu index and if the quantity is positive. The `run` method implicitly validates the main menu choice within the `switch` and its `default` case.
 *     *   **Error Handling:** `try-catch` handles format errors. Business logic errors (empty queue, invalid menu index) are handled with `if` conditions and `System.err`.
 *     *   **Clean Structure:** The code is divided into logical classes, each with a single responsibility (`MenuItem` for data, `Order` for order structure, `RestaurantOrderSystem` for system logic and UI). Methods are small and focused. Reading input as `String` and then parsing within a `try-catch` is a robust way to handle potential `InputMismatchException` or `NumberFormatException` compared to directly using `scanner.nextInt()`.
 * 
 * The `run` method orchestrates the main application loop, displaying options and processing user input via the `switch` statement. The `placeOrder` method handles the complex logic of gathering multiple items for a single order before adding it to the queue. `serveNextOrder` and `viewOrderQueue` demonstrate the core `Queue` operations (`poll` and iteration).
 * 
 * This solution effectively integrates the required components into a functional, well-structured, and error-tolerant program that simulates a real-world scenario.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.text.DecimalFormat; // For formatting currency

// Class representing a single menu item
class MenuItem {
    private String name;
    private double price;

    public MenuItem(String name, double price) {
        this.name = name;
        this.price = price;
    }

    public String getName() {
        return name;
    }

    public double getPrice() {
        return price;
    }

    @Override
    public String toString() {
        DecimalFormat df = new DecimalFormat("#.00");
        return name + " ($" + df.format(price) + ")";
    }
}

// Class representing a customer order
class Order {
    private static int nextOrderId = 1; // Static counter for unique IDs
    private int orderId;
    private List<OrderItem> items; // List of items in this specific order

    // Inner class to hold item and quantity for an order
    private static class OrderItem {
        MenuItem item;
        int quantity;

        OrderItem(MenuItem item, int quantity) {
            this.item = item;
            this.quantity = quantity;
        }

        double getTotalPrice() {
            return item.getPrice() * quantity;
        }

        @Override
        public String toString() {
            return quantity + " x " + item.getName();
        }
    }

    public Order() {
        this.orderId = nextOrderId++;
        this.items = new ArrayList<>(); // Use ArrayList for the order's items
    }

    public int getOrderId() {
        return orderId;
    }

    public void addItem(MenuItem item, int quantity) {
        if (item != null && quantity > 0) {
            this.items.add(new OrderItem(item, quantity));
        } else {
            System.err.println("Error: Cannot add null item or non-positive quantity to order.");
        }
    }

    public double calculateTotal() {
        double total = 0;
        for (OrderItem orderItem : items) {
            total += orderItem.getTotalPrice();
        }
        return total;
    }

    public List<OrderItem> getItems() {
        return items;
    }

    @Override
    public String toString() {
        DecimalFormat df = new DecimalFormat("#.00");
        StringBuilder sb = new StringBuilder();
        sb.append("Order #").append(orderId).append(" (Total: $").append(df.format(calculateTotal())).append(")\n");
        for (OrderItem item : items) {
            sb.append("  - ").append(item).append("\n");
        }
        return sb.toString();
    }
}

// Main class for the Restaurant Order Management System
public class RestaurantOrderSystem {
    private List<MenuItem> menuItems; // Use List interface, implemented by ArrayList
    private Queue<Order> orderQueue; // Use Queue interface, implemented by LinkedList
    private Scanner scanner;

    public RestaurantOrderSystem() {
        // Initialize menu using ArrayList
        menuItems = new ArrayList<>();
        menuItems.add(new MenuItem("Burger", 9.99));
        menuItems.add(new MenuItem("Fries", 3.49));
        menuItems.add(new MenuItem("Drink", 1.99));
        menuItems.add(new MenuItem("Pizza Slice", 4.50));
        menuItems.add(new MenuItem("Salad", 7.80));


        // Initialize order queue using LinkedList (common Queue implementation)
        orderQueue = new LinkedList<>();

        // Initialize scanner for user input
        scanner = new Scanner(System.in);
    }

    // Method to display the menu
    private void displayMenu() {
        System.out.println("\n--- Menu ---");
        if (menuItems.isEmpty()) {
            System.out.println("Menu is currently empty.");
        } else {
            for (int i = 0; i < menuItems.size(); i++) {
                System.out.println((i + 1) + ". " + menuItems.get(i));
            }
        }
        System.out.println("------------");
    }

    // Method to handle placing a new order
    private void placeOrder() {
        displayMenu();
        Order currentOrder = new Order();
        System.out.println("\n--- Place New Order ---");
        System.out.println("Enter item number to add to order (0 to finish):");

        while (true) {
            System.out.print("Item number: ");
            String itemInput = scanner.nextLine(); // Read input as String for better error handling

            int itemIndex = -1;
            try {
                itemIndex = Integer.parseInt(itemInput);
            } catch (NumberFormatException e) {
                System.err.println("Error: Invalid input. Please enter a number.");
                continue; // Ask for item number again
            }

            if (itemIndex == 0) {
                break; // Finish order if user enters 0
            }

            // Adjust for 0-based indexing
            int menuListIndex = itemIndex - 1;

            // Validate item index
            if (menuListIndex < 0 || menuListIndex >= menuItems.size()) {
                System.err.println("Error: Invalid item number. Please select from the menu.");
                continue; // Ask for item number again
            }

            MenuItem selectedItem = menuItems.get(menuListIndex);

            System.out.print("Enter quantity: ");
            String quantityInput = scanner.nextLine(); // Read quantity as String

            int quantity = -1;
            try {
                quantity = Integer.parseInt(quantityInput);
            } catch (NumberFormatException e) {
                 System.err.println("Error: Invalid quantity. Please enter a number.");
                 continue; // Ask for item number again
            }

            // Validate quantity
            if (quantity <= 0) {
                System.err.println("Error: Quantity must be positive.");
                continue; // Ask for item number again
            }

            currentOrder.addItem(selectedItem, quantity);
            System.out.println("Added " + quantity + " x " + selectedItem.getName() + " to order.");
        }

        // Add order to queue if it's not empty
        if (!currentOrder.getItems().isEmpty()) {
            orderQueue.offer(currentOrder); // Add order to the end of the queue
            System.out.println("Order #" + currentOrder.getOrderId() + " placed. Total: $" + new DecimalFormat("#.00").format(currentOrder.calculateTotal()));
        } else {
            System.out.println("No items added. Order cancelled.");
        }
    }

    // Method to serve the next order in the queue
    private void serveNextOrder() {
        System.out.println("\n--- Serving Next Order ---");
        Order servedOrder = orderQueue.poll(); // Remove and return the head of the queue

        if (servedOrder == null) {
            System.err.println("Error: The order queue is empty. Cannot serve.");
        } else {
            System.out.println("Serving " + servedOrder); // Order's toString() provides details
            System.out.println("Order #" + servedOrder.getOrderId() + " served.");
        }
    }

    // Method to view all pending orders in the queue
    private void viewOrderQueue() {
        System.out.println("\n--- Pending Orders ---");
        if (orderQueue.isEmpty()) {
            System.out.println("Queue is empty.");
        } else {
            // Iterate through the queue without removing elements
            int position = 1;
            for (Order order : orderQueue) {
                System.out.println("Position " + position + ": Order #" + order.getOrderId() + " (" + order.getItems().size() + " items)");
                // Optionally print more details: System.out.println(order);
                position++;
            }
        }
        System.out.println("--------------------");
    }

    // Method to display the main options menu
    private void displayOptions() {
        System.out.println("\nOptions:");
        System.out.println("1. View Menu");
        System.out.println("2. Place Order");
        System.out.println("3. Serve Next Order");
        System.out.println("4. View Order Queue");
        System.out.println("5. Exit");
        System.out.print("Enter your choice: ");
    }

    // Main method to run the system
    public void run() {
        System.out.println("Welcome to the Restaurant Order System!");

        boolean running = true;
        while (running) {
            displayOptions();
            String choiceInput = scanner.nextLine(); // Read choice as String

            int choice = -1;
            try {
                choice = Integer.parseInt(choiceInput);
            } catch (NumberFormatException e) {
                System.err.println("Error: Invalid choice. Please enter a number.");
                continue; // Skip the switch and show options again
            }

            // Use a switch statement for flow control
            switch (choice) {
                case 1:
                    displayMenu();
                    break;
                case 2:
                    placeOrder();
                    break;
                case 3:
                    serveNextOrder();
                    break;
                case 4:
                    viewOrderQueue();
                    break;
                case 5:
                    running = false; // Set flag to exit loop
                    System.out.println("Exiting system. Goodbye!");
                    break;
                default:
                    // Handle invalid menu choices
                    System.err.println("Error: Invalid choice. Please enter a number between 1 and 5.");
                    break;
            }
        }

        // Close the scanner when exiting
        scanner.close();
    }

    // Entry point of the application
    public static void main(String[] args) {
        RestaurantOrderSystem system = new RestaurantOrderSystem();
        system.run();
    }
}
