/*
 * Exam Question #651
 * Generated on: 2025-05-12 16:20:12
 * Generated by: Account 5
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Simple Task Management System
 * 
 * **Scenario:**
 * 
 * You are required to develop a command-line application for a simple task management system. This system will help a user keep track of tasks that are pending and those that have been completed. New tasks are added to a processing queue, and tasks are processed in the order they were added. Completed tasks are moved to a separate archive list.
 * 
 * **Requirements:**
 * 
 * 1.  **Task Representation:** Create a class named `Task` to represent a single task. Each `Task` object must have:
 *     *   A unique integer ID.
 *     *   A string description.
 *     *   A status (e.g., `PENDING`, `COMPLETED`). Use an `enum` or simple strings for status.
 *     *   Implement appropriate constructor(s), getters for its properties, and a method to mark the task as completed.
 *     *   Override the `toString()` method for easy printing.
 * 
 * 2.  **Task Management Logic:** Create a class named `TaskManager` responsible for managing the collection of tasks. This class must:
 *     *   Internally maintain a collection of **pending tasks** using a `java.util.Queue`.
 *     *   Internally maintain a collection of **completed tasks** using a `java.util.ArrayList`.
 *     *   Provide a public method `addTask(String description)` that creates a new `Task` and adds it to the pending queue. Validate that the description is not empty.
 *     *   Provide a public method `processNextTask()` that removes the task at the front of the pending queue, marks it as completed, and adds it to the completed task list. Handle the case where the pending queue is empty.
 *     *   Provide a method `viewPendingTasks()` that iterates and prints the details of all tasks currently in the pending queue without removing them.
 *     *   Provide a public method `getCompletedTasks()` that returns the list of completed tasks. This method **must** return the list using the `java.util.List` interface type.
 * 
 * 3.  **User Interface:** Implement the main application logic in a class with a `main` method. This class should:
 *     *   Use `java.util.Scanner` to read user input from the console.
 *     *   Present a menu of options to the user:
 *         1.  Add New Task
 *         2.  Process Next Task
 *         3.  View Pending Tasks
 *         4.  View Completed Tasks
 *         5.  Exit
 *     *   Use a `switch` statement to handle the user's choice.
 *     *   Loop until the user chooses to exit.
 * 
 * 4.  **Input/Output & Error Handling:**
 *     *   Use `System.out` for displaying the menu, prompts, task lists, and success messages.
 *     *   Use `System.err` for displaying error messages (e.g., invalid menu choice, attempting to process a task when the queue is empty, invalid task description).
 *     *   Implement class-wide exception handling using `try-catch` blocks. A single `try-catch` block around the main command processing loop is sufficient to catch unexpected runtime errors. Handle specific anticipated errors (like invalid input or empty queue) within the `switch` cases or `TaskManager` methods, reporting them to `System.err`.
 * 
 * 5.  **Best Practices:**
 *     *   Apply proper encapsulation (private fields, public methods).
 *     *   Use meaningful names for classes, variables, and methods.
 *     *   Include brief comments where necessary to explain logic.
 *     *   Ensure basic input validation (e.g., task description not empty, menu choice is a number).
 *     *   Structure your code into logical classes.
 * 
 * **Expected Interaction:**
 * 
 * The program should display a menu, accept a number input, perform the corresponding action, and display results or errors. Adding tasks fills the pending queue. Processing moves tasks from pending to completed. Viewing options show the current state of the tasks in each collection.
 * 
 * Example Flow:
 * ```
 * Task Management Menu:
 * 1. Add New Task
 * 2. Process Next Task
 * 3. View Pending Tasks
 * 4. View Completed Tasks
 * 5. Exit
 * Enter your choice: 1
 * Enter task description: Buy groceries
 * Added task: Buy groceries
 * 
 * Task Management Menu:
 * ...
 * Enter your choice: 1
 * Enter task description: Pay bills
 * Added task: Pay bills
 * 
 * Task Management Menu:
 * ...
 * Enter your choice: 3
 * --- Pending Tasks ---
 * Task ID: 1, Description: "Buy groceries", Status: PENDING
 * Task ID: 2, Description: "Pay bills", Status: PENDING
 * --------------------
 * 
 * Task Management Menu:
 * ...
 * Enter your choice: 2
 * Processed task: Buy groceries
 * 
 * Task Management Menu:
 * ...
 * Enter your choice: 3
 * --- Pending Tasks ---
 * Task ID: 2, Description: "Pay bills", Status: PENDING
 * --------------------
 * 
 * Task Management Menu:
 * ...
 * Enter your choice: 4
 * --- Completed Tasks ---
 * Task ID: 1, Description: "Buy groceries", Status: COMPLETED
 * ----------------------
 * 
 * Task Management Menu:
 * ...
 * Enter your choice: 2
 * Processed task: Pay bills
 * 
 * Task Management Menu:
 * ...
 * Enter your choice: 2
 * Error: No tasks in the pending queue to process. // This goes to System.err
 * 
 * Task Management Menu:
 * ...
 * Enter your choice: 6
 * Error: Invalid choice. Please enter a number between 1 and 5. // This goes to System.err
 * 
 * Task Management Menu:
 * ...
 * Enter your choice: exit // Or any non-numeric input
 * Error: Invalid choice. Please enter a number between 1 and 5. // This goes to System.err
 * 
 * Task Management Menu:
 * ...
 * Enter your choice: 5
 * Exiting Task Management System. Goodbye!
 * Scanner closed.
 * ```
 * 
 * Your solution should be a single `.java` file containing all necessary classes.
 * 
 * ```java
 * // Your code will go here
 * ```
 *
 * EXPLANATION:
 * The provided solution implements a simple command-line task management system as required, demonstrating the practical use of various core Java concepts and collections.
 * 
 * 1.  **Task Class:**
 *     *   The `Task` class encapsulates the data for a single task (`id`, `description`, `status`).
 *     *   It uses an `enum Status` for clarity and type safety regarding task status.
 *     *   An `AtomicInteger` is used to generate unique IDs for tasks, a common pattern for thread-safe ID generation (though a simple static int would suffice in this single-threaded context).
 *     *   The constructor includes basic input validation, throwing an `IllegalArgumentException` if the description is null or empty. This promotes data integrity.
 *     *   A `markCompleted()` method provides a controlled way to change the task's status.
 *     *   `toString()` is overridden for convenient printing of task details.
 *     *   Fields are `private`, and access is via public getters, adhering to encapsulation principles.
 * 
 * 2.  **TaskManager Class:**
 *     *   This class manages the collections of tasks.
 *     *   `pendingTasks` is declared as a `Queue<Task>` and initialized with a `LinkedList`. `LinkedList` is chosen because it implements the `Queue` interface and is efficient for adding/removing elements from the ends, which is typical queue behavior. The `offer()` method is used for adding to the queue, and `poll()` is used for retrieving and removing the head.
 *     *   `completedTasks` is declared as a `List<Task>` and initialized with an `ArrayList`. `ArrayList` is suitable for storing completed tasks where random access or iteration is common, and queue-like operations are no longer needed.
 *     *   The `addTask()` method demonstrates adding to the `Queue`. It relies on the `Task` constructor for description validation.
 *     *   The `processNextTask()` method demonstrates removing from the `Queue` (`poll()`) and adding to the `List` (`add()`). It checks if the queue is empty using the `null` return value of `poll()` and reports the error using `System.err`, as required.
 *     *   `viewPendingTasks()` iterates over the `Queue` using `forEach` (which doesn't remove elements) to display pending tasks using `System.out`.
 *     *   `getCompletedTasks()` returns the internal `ArrayList` instance but is cast to the `List` interface type, fulfilling the requirement to use the `List` interface.
 * 
 * 3.  **TaskApp (Main Class):**
 *     *   The `main` method orchestrates the application flow.
 *     *   A `Scanner` object is created to read input from `System.in`.
 *     *   A `while` loop keeps the application running until the user chooses to exit.
 *     *   The menu is displayed using `System.out`.
 *     *   User input is read using `scanner.nextLine()`.
 *     *   A nested `try-catch` handles potential `NumberFormatException` if the user enters non-numeric input for the menu choice. The `choice` variable defaults to `-1` in this case.
 *     *   A `switch` statement is used to direct the program flow based on the user's numeric choice. This directly addresses the `switch` requirement.
 *     *   Each case calls the appropriate method on the `TaskManager` instance.
 *     *   Case 1 (`addTask`) includes a `try-catch` specifically for `IllegalArgumentException` thrown by the `Task` constructor due to invalid input, reporting the error message to `System.err`.
 *     *   The `default` case of the `switch` handles invalid menu choices (including non-numeric input caught by the inner `try-catch`) and reports the error to `System.err`.
 *     *   Requirement for `System.out` is met by printing the menu, prompts, success messages, and task lists.
 *     *   Requirement for `System.err` is met by printing specific error conditions like invalid input or an empty queue during processing.
 *     *   The entire `while` loop is wrapped in an outer `try-catch(Exception e)`. This serves as the "class-wide" exception handling, catching any unexpected runtime exceptions that might occur anywhere within the loop and printing a generic error message to `System.err` before the program potentially terminates.
 *     *   A `finally` block ensures the `Scanner` resource is closed, preventing resource leaks.
 * 
 * **Best Practices:**
 * *   **Encapsulation:** Achieved by making fields private and providing public methods for interaction (`Task` and `TaskManager` classes).
 * *   **Meaningful Names:** Class names (`Task`, `TaskManager`, `TaskApp`), variable names (`pendingTasks`, `completedTasks`, `description`, `choice`), and method names (`addTask`, `processNextTask`, `viewPendingTasks`, `getCompletedTasks`) are descriptive.
 * *   **Comments:** Javadoc-style comments explain the purpose of classes and methods, and inline comments clarify specific parts of the logic.
 * *   **Input Validation:** Basic validation for task description is performed in the `Task` constructor, and invalid menu input is handled in the `TaskApp` `switch`.
 * *   **Error Handling:** Specific anticipated errors are handled and reported using `System.err`. A general `try-catch` handles unexpected errors.
 * *   **Clean Code Structure:** The code is divided into three logical classes (`Task`, `TaskManager`, `TaskApp`), separating concerns (data representation, business logic, user interface).
 * 
 * This solution effectively integrates all required Java components (`Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.err`, `System.out`, `try-catch`) within a practical, structured application, demonstrating core Java programming skills and best practices.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.concurrent.atomic.AtomicInteger; // Used for unique task IDs

// Represents a single task with ID, description, and status.
class Task {
    private static final AtomicInteger idCounter = new AtomicInteger(0); // Ensures unique IDs
    private int id;
    private String description;
    private Status status;

    // Enum for task status
    public enum Status {
        PENDING, COMPLETED
    }

    /**
     * Constructs a new Task.
     * @param description The description of the task.
     * @throws IllegalArgumentException if the description is null or empty.
     */
    public Task(String description) {
        // Input validation: description cannot be empty
        if (description == null || description.trim().isEmpty()) {
            throw new IllegalArgumentException("Task description cannot be empty.");
        }
        this.id = idCounter.incrementAndGet(); // Assign unique ID
        this.description = description.trim();
        this.status = Status.PENDING; // New tasks are always pending
    }

    // --- Getters ---
    public int getId() {
        return id;
    }

    public String getDescription() {
        return description;
    }

    public Status getStatus() {
        return status;
    }

    /**
     * Marks the task as completed.
     */
    public void markCompleted() {
        this.status = Status.COMPLETED;
    }

    /**
     * Provides a string representation of the task.
     */
    @Override
    public String toString() {
        return "Task ID: " + id + ", Description: \"" + description + "\", Status: " + status;
    }
}

// Manages collections of pending and completed tasks.
class TaskManager {
    // Requirement: Use java.util.Queue for pending tasks
    private Queue<Task> pendingTasks;
    // Requirement: Use java.util.ArrayList for completed tasks
    private List<Task> completedTasks; // Declared as List, initialized as ArrayList

    /**
     * Constructs a new TaskManager.
     * Initializes the pending queue (using LinkedList) and completed list (using ArrayList).
     */
    public TaskManager() {
        this.pendingTasks = new LinkedList<>(); // LinkedList implements Queue
        this.completedTasks = new ArrayList<>(); // ArrayList implements List
    }

    /**
     * Adds a new task to the pending queue.
     * The Task constructor handles description validation.
     * @param description The description for the new task.
     * @throws IllegalArgumentException if the description is invalid (propagated from Task constructor).
     */
    public void addTask(String description) {
        // Task constructor throws IllegalArgumentException for invalid description
        Task newTask = new Task(description);
        pendingTasks.offer(newTask); // offer() is standard for adding to Queue
        System.out.println("Added task: " + newTask.getDescription()); // Use System.out for success message
    }

    /**
     * Processes the next task in the pending queue.
     * Removes it, marks it completed, and moves it to the completed list.
     * Reports an error to System.err if the queue is empty.
     */
    public void processNextTask() {
        Task nextTask = pendingTasks.poll(); // poll() retrieves and removes the head, returns null if empty
        if (nextTask == null) {
            // Requirement: Use System.err for error messages
            System.err.println("Error: No tasks in the pending queue to process.");
            return; // Exit method if queue was empty
        }
        nextTask.markCompleted();
        completedTasks.add(nextTask);
        System.out.println("Processed task: " + nextTask.getDescription()); // Use System.out for success message
    }

    /**
     * Views all tasks currently in the pending queue without removing them.
     * Prints task details to System.out.
     */
    public void viewPendingTasks() {
        if (pendingTasks.isEmpty()) {
            System.out.println("No pending tasks."); // Use System.out
            return;
        }
        System.out.println("--- Pending Tasks ---"); // Use System.out
        // Iterating over a Queue using forEach does not remove elements
        pendingTasks.forEach(System.out::println); // Uses Task.toString() and System.out
        System.out.println("--------------------"); // Use System.out
    }

    /**
     * Gets the list of completed tasks.
     * Requirement: Return the list using the List interface.
     * @return A List containing all completed tasks.
     */
    public List<Task> getCompletedTasks() {
        // Return the internal ArrayList reference cast to the List interface
        return completedTasks;
    }
}

// Main application class containing the user interface and program flow.
public class TaskApp {

    // Menu string constant
    private static final String MENU =
            "\nTask Management Menu:\n" +
            "1. Add New Task\n" +
            "2. Process Next Task\n" +
            "3. View Pending Tasks\n" +
            "4. View Completed Tasks\n" +
            "5. Exit\n" +
            "Enter your choice: ";

    public static void main(String[] args) {
        TaskManager taskManager = new TaskManager();
        // Requirement: Use Scanner for user input
        Scanner scanner = new Scanner(System.in);
        boolean running = true;

        // Requirement: Implement class-wide exception handling with try-catch
        // This outer try-catch catches any unexpected runtime exceptions
        try {
            while (running) {
                System.out.print(MENU); // Requirement: Use System.out for menu/prompts
                String input = scanner.nextLine();
                int choice = -1; // Default to -1 for invalid numeric input

                try {
                    // Attempt to parse input as an integer
                    choice = Integer.parseInt(input);
                } catch (NumberFormatException e) {
                    // If parsing fails, choice remains -1, which the switch default handles.
                    // No specific action needed here, error message is in switch default.
                }

                // Requirement: Use switch statement for flow control
                switch (choice) {
                    case 1: // Add New Task
                        System.out.print("Enter task description: "); // Use System.out
                        String description = scanner.nextLine();
                        try {
                            // TaskManager.addTask validates description and might throw exception
                            taskManager.addTask(description);
                        } catch (IllegalArgumentException e) {
                            // Requirement: Use System.err for error messages (input validation error)
                            System.err.println("Error adding task: " + e.getMessage());
                        }
                        break;

                    case 2: // Process Next Task
                        // TaskManager.processNextTask handles empty queue and prints error to System.err
                        taskManager.processNextTask();
                        break;

                    case 3: // View Pending Tasks
                        // TaskManager.viewPendingTasks prints to System.out
                        taskManager.viewPendingTasks();
                        break;

                    case 4: // View Completed Tasks
                        // Requirement: Use List interface for returned list
                        List<Task> completed = taskManager.getCompletedTasks();
                        if (completed.isEmpty()) {
                            System.out.println("No completed tasks."); // Use System.out
                        } else {
                            System.out.println("--- Completed Tasks ---"); // Use System.out
                            // Iterate and print completed tasks
                            completed.forEach(System.out::println); // Uses Task.toString() and System.out
                            System.out.println("----------------------"); // Use System.out
                        }
                        break;

                    case 5: // Exit
                        System.out.println("Exiting Task Management System. Goodbye!"); // Use System.out
                        running = false; // End the loop
                        break;

                    default: // Invalid command
                        // Requirement: Use System.err for error messages (invalid choice)
                        System.err.println("Error: Invalid choice. Please enter a number between 1 and 5.");
                        break;
                }
            }
        } catch (Exception e) {
            // Catch any other unexpected exceptions during execution
            // Requirement: Use System.err for unexpected system errors
            System.err.println("An unexpected system error occurred: " + e.getMessage());
            // e.printStackTrace(); // Uncomment for detailed debugging stack trace
        } finally {
            // Ensure the scanner resource is closed when the program ends
            scanner.close();
            // Optional: Indicate resource cleanup
            System.out.println("Scanner closed.");
        }
    }
}
