/*
 * Exam Question #267
 * Generated on: 2025-05-11 22:47:05
 * Generated by: Account 2
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Customer Service Request Processing System
 * 
 * **Objective:** Design and implement a simplified Customer Service Request Processing System in Java. The system should manage incoming service requests, allow agents to process them in order, and keep track of completed requests.
 * 
 * **Requirements:**
 * 
 * 1.  **Service Request:** Create a class `ServiceRequest` to represent a customer request. It should have the following attributes:
 *     *   `id` (int): A unique identifier for the request.
 *     *   `description` (String): A brief description of the request.
 *     *   `status` (enum or String): Represents the current status (e.g., "PENDING", "COMPLETED").
 *     *   Include a constructor, getters for all attributes, and a method to update the status to "COMPLETED".
 * 
 * 2.  **Request Processing System:** Create a class `RequestProcessingSystem` that manages the requests. It must contain:
 *     *   A `Queue` to hold pending `ServiceRequest` objects (requests waiting to be processed).
 *     *   A `List` to hold completed `ServiceRequest` objects.
 *     *   An `ArrayList` must be used as the concrete implementation for the `List` storing completed requests.
 *     *   A `Scanner` object to read user input from the console.
 *     *   Methods for the following operations:
 *         *   `addRequest()`: Prompts the user for a request description, creates a new `ServiceRequest` with a unique ID (e.g., using a simple counter), and adds it to the pending queue.
 *         *   `processNextRequest()`: Takes the next request from the pending queue, updates its status to "COMPLETED", and moves it to the list of completed requests. If the queue is empty, it should report an error.
 *         *   `viewPendingRequests()`: Displays all requests currently in the pending queue.
 *         *   `viewCompletedRequests()`: Displays all requests in the completed list.
 *         *   `run()`: The main method that provides a menu-driven interface for the user to interact with the system. This method should contain the main application loop.
 * 
 * 3.  **User Interface (`run` method):**
 *     *   Present a menu with options: Add Request, Process Next Request, View Pending, View Completed, Exit.
 *     *   Read the user's choice using the `Scanner`.
 *     *   Use a `switch` statement to handle the different menu options.
 *     *   Include input validation for the menu choice.
 * 
 * 4.  **Error Handling & Output:**
 *     *   Use `System.out` for displaying the menu, request details, and success messages.
 *     *   Use `System.err` for displaying error messages (e.g., invalid menu choice, attempting to process from an empty queue, empty request description).
 *     *   Implement class-wide exception handling using `try-catch` blocks within the `run` method to gracefully handle potential issues during user input or processing. Catch at least `java.util.InputMismatchException` for invalid integer input.
 * 
 * 5.  **Best Practices:**
 *     *   Apply proper encapsulation (private fields, public methods).
 *     *   Use meaningful variable and method names.
 *     *   Add comments to explain key parts of the code.
 *     *   Ensure proper input validation (e.g., non-empty request description, valid menu choice).
 * 
 * **Expected Output:**
 * 
 * The system should run interactively, displaying a menu. Based on user input, it should perform the requested operation and provide appropriate feedback or error messages.
 * 
 * Example Interaction Flow:
 * 
 * ```
 * --- Service Request System Menu ---
 * 1. Add New Request
 * 2. Process Next Request
 * 3. View Pending Requests
 * 4. View Completed Requests
 * 5. Exit
 * Enter your choice: 1
 * Enter request description: Fix internet connection
 * Request added with ID: 1
 * 
 * --- Service Request System Menu ---
 * 1. Add New Request
 * 2. Process Next Request
 * 3. View Pending Requests
 * 4. View Completed Requests
 * 5. Exit
 * Enter your choice: 1
 * Enter request description: Software installation help
 * Request added with ID: 2
 * 
 * --- Service Request System Menu ---
 * 1. Add New Request
 * 2. Process Next Request
 * 3. View Pending Requests
 * 4. View Completed Requests
 * 5. Exit
 * Enter your choice: 3
 * --- Pending Requests ---
 * ID: 1, Description: Fix internet connection, Status: PENDING
 * ID: 2, Description: Software installation help, Status: PENDING
 * 
 * --- Service Request System Menu ---
 * 1. Add New Request
 * 2. Process Next Request
 * 3. View Pending Requests
 * 4. View Completed Requests
 * 5. Exit
 * Enter your choice: 2
 * Processing request ID: 1
 * Request ID 1 completed.
 * 
 * --- Service Request System Menu ---
 * 1. Add New Request
 * 2. Process Next Request
 * 3. View Pending Requests
 * 4. View Completed Requests
 * 5. Exit
 * Enter your choice: 3
 * --- Pending Requests ---
 * ID: 2, Description: Software installation help, Status: PENDING
 * 
 * --- Service Request System Menu ---
 * 1. Add New Request
 * 2. Process Next Request
 * 3. View Pending Requests
 * 4. View Completed Requests
 * 5. Exit
 * Enter your choice: 4
 * --- Completed Requests ---
 * ID: 1, Description: Fix internet connection, Status: COMPLETED
 * 
 * --- Service Request System Menu ---
 * 1. Add New Request
 * 2. Process Next Request
 * 3. View Pending Requests
 * 4. View Completed Requests
 * 5. Exit
 * Enter your choice: 6
 * Error: Invalid choice. Please enter a number between 1 and 5.
 * 
 * --- Service Request System Menu ---
 * 1. Add New Request
 * 2. Process Next Request
 * 3. View Pending Requests
 * 4. View Completed Requests
 * 5. Exit
 * Enter your choice: 5
 * Exiting system.
 * ```
 * 
 * **Constraint:** You must use ALL the Java components listed in the requirements section (`Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.err`, `System.out`, `try-catch`).
 *
 * EXPLANATION:
 * This solution implements a simple Customer Service Request Processing System demonstrating the required Java concepts.
 * 
 * 1.  **`ServiceRequest` Class:** This class encapsulates the data for a single request (`id`, `description`, `status`). It follows encapsulation principles with private fields and public getter methods. The `complete()` method provides a controlled way to change the status. The `toString()` method provides a convenient string representation for printing.
 * 
 * 2.  **`RequestProcessingSystem` Class:**
 *     *   **`Queue<ServiceRequest> pendingRequests`**: A `Queue` is used here because requests are processed in the order they are received (FIFO - First-In, First-Out). `LinkedList` is a common and suitable implementation for a `Queue`.
 *     *   **`List<ServiceRequest> completedRequests`**: A `List` is used for completed requests as their order after processing might not be strictly relevant, but we need to store and iterate through them. The variable is declared using the `List` interface, and an `ArrayList` is used for its concrete implementation, satisfying both requirements (`List` interface and `ArrayList` usage). `ArrayList` provides efficient storage and retrieval by index, though iteration is sufficient here.
 *     *   **`Scanner scanner`**: Used to read input from `System.in`.
 *     *   **`requestIdCounter`**: A simple counter to generate unique IDs for new requests.
 *     *   **`addRequest()`**: Reads the description, performs basic input validation (checks if description is empty), creates a `ServiceRequest` object, and adds it to the `pendingRequests` queue using `add()`. `System.err` is used for the validation error.
 *     *   **`processNextRequest()`**: Checks if the `pendingRequests` queue is empty. If so, it prints an error using `System.err`. Otherwise, it uses `poll()` to remove and retrieve the head of the queue, updates its status using the `complete()` method, and adds it to the `completedRequests` list using `add()`. `System.out` is used for success messages.
 *     *   **`viewPendingRequests()` / `viewCompletedRequests()`**: These methods iterate through the respective collections (`Queue` and `List`) and print the details of each request using the `toString()` method of `ServiceRequest`. `System.out` is used for all output.
 *     *   **`displayMenu()`**: A helper method to print the menu options using `System.out`.
 *     *   **`run()`**: This is the core method containing the application's main loop.
 *         *   It displays the menu.
 *         *   It reads the user's integer choice using `scanner.nextInt()`. A nested `try-catch` block specifically handles `InputMismatchException` if the user enters non-integer input, printing an error to `System.err` and consuming the invalid input using `scanner.nextLine()` to prevent an infinite loop.
 *         *   A `switch` statement is used to direct the program flow based on the valid integer choice, calling the appropriate methods (`addRequest`, `processNextRequest`, etc.).
 *         *   The `default` case of the `switch` handles invalid integer choices, printing an error to `System.err`.
 *         *   A larger, class-wide `try-catch` block wraps the entire `while` loop within the `run` method. This catches any *other* unexpected `Exception` that might occur during the system's execution, printing an error to `System.err` and a stack trace for debugging.
 *         *   A `finally` block is used to ensure the `scanner` is closed when the `run` method finishes (either by exiting the loop or catching an exception).
 * 
 * 3.  **Required Components Usage:**
 *     *   `Queue`: Used for `pendingRequests` (implemented with `LinkedList`).
 *     *   `ArrayList`: Used as the concrete implementation for `completedRequests`.
 *     *   `List`: Used as the type declaration for the `completedRequests` variable.
 *     *   `Scanner`: Used for reading user input in `run` and `addRequest`.
 *     *   `switch`: Used in `run` to handle menu options.
 *     *   `System.err`: Used for error messages (invalid input, empty description, empty queue, unexpected exceptions).
 *     *   `System.out`: Used for normal output (menu, prompts, request details, success messages, exit message).
 *     *   `try-catch`: Used in `run` for both specific input validation (`InputMismatchException`) and a general catch-all for unexpected exceptions.
 * 
 * 4.  **Best Practices:**
 *     *   **Encapsulation:** `ServiceRequest` fields are private with public getters. `RequestProcessingSystem` fields are private.
 *     *   **Naming:** Variable and method names are descriptive (e.g., `pendingRequests`, `processNextRequest`, `requestIdCounter`).
 *     *   **Comments:** Explanations are provided for classes, fields, and key methods.
 *     *   **Input Validation:** Checks for empty description and valid menu integer choice are included.
 *     *   **Error Handling:** Specific errors use `System.err`, `try-catch` handles exceptions, and edge cases like processing an empty queue are checked.
 *     *   **Clean Structure:** Code is organized into logical classes and methods.
 * 
 * This solution effectively integrates all the required Java components within a practical scenario, demonstrating understanding of data structures, object-oriented principles, input/output, control flow, and exception handling.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.InputMismatchException;

// Represents a single customer service request
class ServiceRequest {
    private int id;
    private String description;
    private String status; // Using String for simplicity, enum is also a valid choice

    // Constructor
    public ServiceRequest(int id, String description) {
        this.id = id;
        this.description = description;
        this.status = "PENDING"; // Initial status
    }

    // Getters
    public int getId() {
        return id;
    }

    public String getDescription() {
        return description;
    }

    public String getStatus() {
        return status;
    }

    // Method to update status to COMPLETED
    public void complete() {
        this.status = "COMPLETED";
    }

    @Override
    public String toString() {
        return "ID: " + id + ", Description: " + description + ", Status: " + status;
    }
}

// Manages the queue of pending requests and list of completed requests
public class RequestProcessingSystem {

    // Queue to hold requests waiting to be processed
    private Queue<ServiceRequest> pendingRequests;

    // List to hold requests that have been completed
    // Using List interface, implemented by ArrayList
    private List<ServiceRequest> completedRequests;

    // Scanner for user input
    private Scanner scanner;

    // Counter for generating unique request IDs
    private int requestIdCounter;

    // Constructor
    public RequestProcessingSystem() {
        // Use LinkedList as a concrete implementation for Queue
        this.pendingRequests = new LinkedList<>();
        // Use ArrayList as a concrete implementation for List
        this.completedRequests = new ArrayList<>();
        this.scanner = new Scanner(System.in);
        this.requestIdCounter = 0; // Start ID counter at 0 or 1
    }

    // Adds a new service request to the pending queue
    public void addRequest() {
        System.out.print("Enter request description: ");
        String description = scanner.nextLine().trim(); // Read description and trim whitespace

        if (description.isEmpty()) {
            System.err.println("Error: Request description cannot be empty.");
            return; // Exit method if description is empty
        }

        // Increment counter and create new request
        requestIdCounter++;
        ServiceRequest newRequest = new ServiceRequest(requestIdCounter, description);
        pendingRequests.add(newRequest); // Add to the queue
        System.out.println("Request added with ID: " + newRequest.getId());
    }

    // Processes the next request from the pending queue
    public void processNextRequest() {
        // Check if the queue is empty
        if (pendingRequests.isEmpty()) {
            System.err.println("Error: No pending requests to process.");
            return; // Exit method if queue is empty
        }

        // Get the next request from the front of the queue
        ServiceRequest requestToProcess = pendingRequests.poll(); // Removes and returns the head

        System.out.println("Processing request ID: " + requestToProcess.getId());

        // Update status and move to completed list
        requestToProcess.complete();
        completedRequests.add(requestToProcess); // Add to the list

        System.out.println("Request ID " + requestToProcess.getId() + " completed.");
    }

    // Displays all requests currently in the pending queue
    public void viewPendingRequests() {
        System.out.println("--- Pending Requests ---");
        if (pendingRequests.isEmpty()) {
            System.out.println("No pending requests.");
        } else {
            // Iterate through the queue without removing elements
            for (ServiceRequest request : pendingRequests) {
                System.out.println(request);
            }
        }
    }

    // Displays all requests in the completed list
    public void viewCompletedRequests() {
        System.out.println("--- Completed Requests ---");
        if (completedRequests.isEmpty()) {
            System.out.println("No completed requests.");
        } else {
            // Iterate through the list
            for (ServiceRequest request : completedRequests) {
                System.out.println(request);
            }
        }
    }

    // Displays the main menu
    private void displayMenu() {
        System.out.println("\n--- Service Request System Menu ---");
        System.out.println("1. Add New Request");
        System.out.println("2. Process Next Request");
        System.out.println("3. View Pending Requests");
        System.out.println("4. View Completed Requests");
        System.out.println("5. Exit");
        System.out.print("Enter your choice: ");
    }

    // Main method to run the system
    public void run() {
        boolean running = true;

        // Class-wide exception handling for the main loop
        try {
            while (running) {
                displayMenu();
                int choice = -1; // Default invalid choice

                // Input handling for menu choice
                try {
                    choice = scanner.nextInt();
                    scanner.nextLine(); // Consume the newline character left by nextInt()
                } catch (InputMismatchException e) {
                    System.err.println("Error: Invalid input. Please enter a number.");
                    scanner.nextLine(); // Consume the invalid input to prevent infinite loop
                    continue; // Skip the rest of the loop and show menu again
                }

                // Switch statement for flow control based on user choice
                switch (choice) {
                    case 1:
                        addRequest();
                        break;
                    case 2:
                        processNextRequest();
                        break;
                    case 3:
                        viewPendingRequests();
                        break;
                    case 4:
                        viewCompletedRequests();
                        break;
                    case 5:
                        running = false; // Set flag to exit loop
                        System.out.println("Exiting system.");
                        break;
                    default:
                        // Handle invalid choices
                        System.err.println("Error: Invalid choice. Please enter a number between 1 and 5.");
                }
            }
        } catch (Exception e) {
            // Catch any unexpected exceptions during the main loop execution
            System.err.println("An unexpected error occurred: " + e.getMessage());
            e.printStackTrace(); // Print stack trace for debugging
        } finally {
            // Ensure the scanner is closed when the system exits
            scanner.close();
            System.out.println("Scanner closed.");
        }
    }

    // Main method to start the application
    public static void main(String[] args) {
        RequestProcessingSystem system = new RequestProcessingSystem();
        system.run(); // Start the system's main loop
    }
}
