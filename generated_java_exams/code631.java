/*
 * Exam Question #631
 * Generated on: 2025-05-12 16:17:19
 * Generated by: Account 5
 * 
 * QUESTION:
 * Design and implement a simple command-line Print Job Manager application in Java. This application should simulate managing print jobs by allowing users to add jobs to a queue, process the next job, view the waiting queue, and view a history of processed jobs.
 * 
 * Your solution must demonstrate a strong understanding of fundamental and intermediate Java concepts by incorporating ALL of the following components:
 * 
 * 1.  `java.util.Queue`: To manage the print jobs waiting to be processed, ensuring First-In, First-Out (FIFO) order.
 * 2.  `java.util.ArrayList`: As a concrete implementation to store the history of print jobs that have been successfully processed.
 * 3.  `java.util.List`: Use this interface type when declaring the variable that holds the processed history.
 * 4.  `java.util.Scanner`: To read user input from the console for menu choices and job details.
 * 5.  `switch` statement: To control the flow of the main application loop based on the user's menu selection.
 * 6.  `System.err`: To output error messages (e.g., invalid input, operations on an empty queue).
 * 7.  `System.out`: To output normal messages (e.g., menu prompts, job details, status updates).
 * 8.  Class-wide exception handling: Use `try-catch` blocks to handle potential runtime errors gracefully, specifically around user input and critical operations within the main application loop.
 * 
 * **Application Functionality Requirements:**
 * 
 * *   **Add Print Job:** Prompt the user for a file name and page count. Create a `PrintJob` object (you will need to define a class for this) and add it to the print queue. Implement input validation: the file name cannot be empty, and the page count must be a positive integer. Use `System.err` to report validation errors.
 * *   **Process Next Job:** Remove the job at the front of the queue, simulate processing it (e.g., by printing its details), and then add it to the processed history list. If the print queue is empty when this option is chosen, display a message using `System.out` indicating that there are no jobs to process.
 * *   **View Print Queue:** Display the details of all jobs currently waiting in the queue, maintaining their order. If the queue is empty, display a message using `System.out`.
 * *   **View Processed History:** Display the details of all jobs that have been processed and moved to the history list. If the history is empty, display a message using `System.out`.
 * *   **Exit:** Terminate the application gracefully.
 * 
 * **Technical Requirements & Best Practices:**
 * 
 * *   Create a main class (e.g., `PrintManager`) to encapsulate the print management logic.
 * *   Define a nested class (e.g., `PrintJob`) to represent a single print job. This class should have private fields for a unique job ID (auto-generated), file name, and page count, with public getter methods. Ensure proper encapsulation.
 * *   Use meaningful variable and method names throughout your code.
 * *   Include comments where necessary to explain the purpose of classes, methods, or complex logic.
 * *   Implement robust error handling for user input (e.g., non-numeric input for choices or page count) using `try-catch` and `System.err`.
 * *   Ensure your `Scanner` resource is closed properly when the application exits.
 * *   Structure your code cleanly with separate methods for each distinct functionality (adding, processing, viewing queue, viewing history).
 * 
 * **Expected Output:**
 * 
 * The application should present a clear menu of options to the user. Based on the user's valid choice, it should perform the corresponding action and display relevant information or error messages to the console using `System.out` for normal output and `System.err` for errors. Invalid inputs or attempts to perform actions on empty collections should be handled gracefully with informative messages.
 * 
 * An example interaction might involve adding several jobs, processing one, viewing the queue, viewing history, attempting to process when empty, and finally exiting. Your output should match the described functionality and use of `System.out` and `System.err`.
 * 
 * ```
 * --- Print Job Manager ---
 * 
 * Choose an action:
 * 1. Add Print Job
 * 2. Process Next Job
 * 3. View Print Queue
 * 4. View Processed History
 * 5. Exit
 * Enter choice: <user input>
 * ... (application response)
 * ```
 * (Followed by subsequent menu prompts until the user chooses 'Exit')
 * ```
 * Exiting Print Job Manager. Goodbye!
 * Scanner closed.
 * ```
 * 
 * Consider edge cases like empty queue/history and invalid user input (non-numeric, out of range, empty strings).
 *
 * EXPLANATION:
 * This solution implements the `PrintManager` application as required, demonstrating the use of all specified Java components and adhering to best practices.
 * 
 * 1.  **`PrintJob` Inner Class:** A `private static` nested class `PrintJob` is defined to model a print job. It includes `private` fields (`jobId`, `fileName`, `pageCount`) and `public` getter methods, showcasing proper encapsulation. A static counter `nextJobId` ensures each job gets a unique ID.
 * 2.  **`PrintManager` Class Fields:**
 *     *   `private Queue<PrintJob> printQueue;`: Declared using the `Queue` interface, it is initialized with a `LinkedList` implementation (`new LinkedList<>()`). `LinkedList` is a common choice for a Queue as it provides efficient additions and removals from both ends.
 *     *   `private List<PrintJob> processedHistory;`: Declared using the `List` interface, it is initialized with an `ArrayList` implementation (`new ArrayList<>()`). `ArrayList` is suitable for storing processed jobs where indexed access or iteration is needed.
 *     *   `private Scanner scanner;`: Used to read input from `System.in`.
 * 3.  **`Scanner` and Input Handling:** The `Scanner` is initialized in the constructor. Input reading methods like `nextLine()` and `nextInt()` are used. Crucially, `scanner.nextLine()` is called after `scanner.nextInt()` to consume the leftover newline character, preventing issues in subsequent `nextLine()` calls.
 * 4.  **`switch` Statement:** The `runManager` method contains the main application loop. A `switch` statement is used to process the integer choice entered by the user, directing the program flow to the appropriate method (`addJob`, `processNextJob`, etc.).
 * 5.  **`System.out` and `System.err`:** `System.out.println()` is used for displaying menus, prompts, successful operations, and status messages (like empty queue/history). `System.err.println()` is strictly used for error messages, such as invalid input during job creation or non-numeric menu choices.
 * 6.  **Exception Handling:**
 *     *   A `try-catch(InputMismatchException e)` block is specifically used around `scanner.nextInt()` calls (both for the menu choice and page count) to catch cases where the user enters non-numeric input. An informative error message is printed to `System.err`, and the invalid input is consumed using `scanner.nextLine()` to prevent an infinite loop.
 *     *   A larger `try-catch(Exception e)` block wraps the entire `while(running)` loop in `runManager`. This serves as a class-wide handler for any unexpected exceptions that might occur during the program's execution, printing a general error message to `System.err`.
 *     *   A `finally` block is used after the main `try-catch` in `runManager` to ensure that the `scanner` resource is closed regardless of whether the program exits normally or due to an unexpected exception.
 * 7.  **Method Implementation:**
 *     *   `addJob()`: Handles user input for file name and page count, performs validation (empty file name, non-positive page count) using `if` statements and `System.err`, and uses `printQueue.offer()` to add a new `PrintJob` to the queue.
 *     *   `processNextJob()`: Checks if the queue is empty (`printQueue.isEmpty()`). If not, it uses `printQueue.poll()` to retrieve and remove the head of the queue and `processedHistory.add()` to add it to the history list.
 *     *   `viewQueue()`: Iterates through the `printQueue` using a for-each loop to display jobs without removing them. Checks for emptiness.
 *     *   `viewHistory()`: Iterates through the `processedHistory` list using a standard for loop and indexed access (`get(i)`) to display processed jobs. Checks for emptiness.
 * 8.  **Best Practices:**
 *     *   Encapsulation is applied in the `PrintJob` class.
 *     *   Variable and method names are descriptive (`printQueue`, `processNextJob`, `pageCount`).
 *     *   Comments explain key parts of the code.
 *     *   Input validation and error handling are implemented using `if`, `try-catch`, `System.err`, and `System.out`.
 *     *   The code is structured into logical methods within the `PrintManager` class.
 *     *   Interfaces (`List`, `Queue`) are used for variable declarations, promoting flexibility.
 * 
 * This solution effectively integrates the required components into a functional application, demonstrating core Java programming skills, object-oriented design principles, and robust error handling.
 */

import java.util.Queue;
import java.util.LinkedList; // Concrete implementation for Queue
import java.util.List;
import java.util.ArrayList; // Concrete implementation for List
import java.util.Scanner;
import java.util.InputMismatchException; // Exception for non-numeric input

/**
 * Manages print jobs using a queue for waiting jobs and a list for processed jobs.
 * Demonstrates usage of Queue, List, ArrayList, Scanner, switch, System.out/err,
 * and exception handling.
 */
public class PrintManager {

    /**
     * Represents a single print job with unique ID, file name, and page count.
     */
    private static class PrintJob {
        private static int nextJobId = 1; // Static counter for unique IDs
        private int jobId;
        private String fileName;
        private int pageCount;

        /**
         * Constructs a new PrintJob.
         * @param fileName The name of the file to print.
         * @param pageCount The number of pages in the file.
         */
        public PrintJob(String fileName, int pageCount) {
            this.jobId = nextJobId++; // Assign unique ID and increment counter
            this.fileName = fileName;
            this.pageCount = pageCount;
        }

        // --- Getters (Encapsulation) ---
        public int getJobId() {
            return jobId;
        }

        public String getFileName() {
            return fileName;
        }

        public int getPageCount() {
            return pageCount;
        }

        /**
         * Provides a string representation of the PrintJob.
         */
        @Override
        public String toString() {
            return "Job [ID=" + jobId + ", File='" + fileName + "', Pages=" + pageCount + "]";
        }
    }

    // --- Class Fields ---
    private Queue<PrintJob> printQueue;
    private List<PrintJob> processedHistory; // Using List interface type
    private Scanner scanner;

    /**
     * Constructs a new PrintManager, initializing the queue, history list, and scanner.
     */
    public PrintManager() {
        // Initialize Queue with LinkedList implementation
        this.printQueue = new LinkedList<>();
        // Initialize List with ArrayList implementation
        this.processedHistory = new ArrayList<>();
        this.scanner = new Scanner(System.in);
    }

    /**
     * Prompts user for job details, validates input, and adds a new job to the queue.
     */
    public void addJob() {
        System.out.println("\n--- Add New Print Job ---");
        System.out.print("Enter file name: ");
        // Read the entire line for file name
        String fileName = scanner.nextLine();

        // Input validation for file name
        if (fileName == null || fileName.trim().isEmpty()) {
            System.err.println("Error: File name cannot be empty.");
            return; // Exit method if validation fails
        }

        System.out.print("Enter page count: ");
        int pageCount = -1; // Default to an invalid value
        try {
            // Read integer input for page count
            pageCount = scanner.nextInt();
            // Consume the remaining newline character left by nextInt()
            scanner.nextLine();
        } catch (InputMismatchException e) {
            // Handle non-integer input for page count
            System.err.println("Error: Invalid input for page count. Please enter a number.");
            // Consume the invalid input from the scanner to prevent infinite loops
            scanner.nextLine();
            return; // Exit method if input is invalid
        }

        // Input validation for page count value
        if (pageCount <= 0) {
            System.err.println("Error: Page count must be positive.");
            return; // Exit method if validation fails
        }

        // Create and add the new job to the queue
        PrintJob newJob = new PrintJob(fileName.trim(), pageCount);
        printQueue.offer(newJob); // offer() is preferred for capacity-constrained queues, but works fine here. Returns true/false.
        System.out.println("Job added to queue: " + newJob);
    }

    /**
     * Processes the next job in the queue (FIFO) and moves it to history.
     */
    public void processNextJob() {
        System.out.println("\n--- Processing Next Job ---");
        // Check if the queue is empty before attempting to process
        if (printQueue.isEmpty()) {
            System.out.println("Print queue is empty. Nothing to process.");
            return; // Exit method if queue is empty
        }

        // Retrieve and remove the head of the queue
        PrintJob jobToProcess = printQueue.poll(); // poll() returns null if queue is empty, but we checked already

        // This check is technically redundant due to the isEmpty() check above,
        // but demonstrates how poll() behaves.
        if (jobToProcess != null) {
            System.out.println("Processing job: " + jobToProcess);
            // Simulate processing time (optional, not required by prompt)
            // Thread.sleep(1000);
            processedHistory.add(jobToProcess); // Add processed job to history list
            System.out.println("Job " + jobToProcess.getJobId() + " finished and moved to history.");
        }
    }

    /**
     * Displays all jobs currently waiting in the print queue.
     */
    public void viewQueue() {
        System.out.println("\n--- Current Print Queue ---");
        // Check if the queue is empty
        if (printQueue.isEmpty()) {
            System.out.println("The print queue is empty.");
        } else {
            System.out.println("Jobs waiting (" + printQueue.size() + "):");
            // Iterate over the queue elements without removing them
            int index = 1;
            for (PrintJob job : printQueue) {
                System.out.println(index++ + ". " + job);
            }
        }
    }

    /**
     * Displays all jobs that have been processed and are in the history list.
     */
    public void viewHistory() {
        System.out.println("\n--- Processed Job History ---");
        // Check if the history list is empty
        if (processedHistory.isEmpty()) {
            System.out.println("No jobs have been processed yet.");
        } else {
            System.out.println("Processed jobs (" + processedHistory.size() + "):");
            // Iterate over the list elements
            for (int i = 0; i < processedHistory.size(); i++) {
                System.out.println((i + 1) + ". " + processedHistory.get(i));
            }
        }
    }

    /**
     * Runs the main application loop, presenting menu options and handling user input.
     * Includes class-wide exception handling.
     */
    public void runManager() {
        System.out.println("--- Print Job Manager ---");
        boolean running = true;

        // Class-wide try-catch block to handle unexpected exceptions during the main loop
        try {
            while (running) {
                System.out.println("\nChoose an action:");
                System.out.println("1. Add Print Job");
                System.out.println("2. Process Next Job");
                System.out.println("3. View Print Queue");
                System.out.println("4. View Processed History");
                System.out.println("5. Exit");
                System.out.print("Enter choice: ");

                int choice = -1; // Default invalid choice
                try {
                    // Read user's menu choice
                    choice = scanner.nextInt();
                    // Consume the newline character left by nextInt()
                    scanner.nextLine();
                } catch (InputMismatchException e) {
                    // Handle non-integer input for menu choice
                    System.err.println("Invalid input. Please enter a number between 1 and 5.");
                    // Consume the invalid input to prevent infinite loop
                    scanner.nextLine();
                    continue; // Skip the rest of the loop iteration and show menu again
                }

                // Use switch statement for flow control based on user choice
                switch (choice) {
                    case 1:
                        addJob(); // Call method to add a job
                        break;
                    case 2:
                        processNextJob(); // Call method to process next job
                        break;
                    case 3:
                        viewQueue(); // Call method to view queue
                        break;
                    case 4:
                        viewHistory(); // Call method to view history
                        break;
                    case 5:
                        System.out.println("Exiting Print Job Manager. Goodbye!");
                        running = false; // Set running flag to false to exit loop
                        break;
                    default:
                        // Handle choices outside the expected range
                        System.out.println("Invalid choice. Please enter a number between 1 and 5.");
                }
            }
        } catch (Exception e) {
            // Catch any other unexpected exceptions that might occur
            System.err.println("An unexpected error occurred during operation: " + e.getMessage());
            // Optionally print stack trace for debugging during development/testing
            // e.printStackTrace();
        } finally {
            // Ensure the scanner is closed when the application finishes or crashes
            if (scanner != null) {
                scanner.close();
                System.out.println("Scanner closed.");
            }
        }
    }

    /**
     * The main method to start the PrintManager application.
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        PrintManager manager = new PrintManager();
        manager.runManager(); // Start the main application loop
    }
}
