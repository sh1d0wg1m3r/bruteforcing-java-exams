/*
 * Exam Question #795
 * Generated on: 2025-05-12 16:41:48
 * Generated by: Account 4
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Event Management System - Service Request Handler
 * 
 * **Scenario:**
 * 
 * You are tasked with building a simple console-based application for managing attendees and their service requests at a small event. Attendees register beforehand and might have various requests during the event (e.g., needing assistance, asking a question, reporting an issue). Staff members process these requests in the order they are received.
 * 
 * **Task:**
 * 
 * Implement a Java console application that simulates this process. Your application should allow users (representing event staff) to perform the following actions:
 * 
 * 1.  **Add New Attendee:** Register a new attendee by name.
 * 2.  **View All Attendees:** Display the list of all registered attendees.
 * 3.  **Submit Service Request:** An existing attendee can submit a service request with details. The system should verify the attendee exists before adding the request.
 * 4.  **Process Next Request:** A staff member processes the oldest pending service request.
 * 5.  **View Pending Requests:** Display all service requests currently waiting to be processed.
 * 6.  **Exit:** Terminate the application.
 * 
 * **Technical Requirements:**
 * 
 * Your solution **must** use and demonstrate the proper usage of **ALL** of the following Java components:
 * 
 * *   `java.util.Queue`: To manage service requests in a First-In, First-Out (FIFO) manner.
 * *   `java.util.ArrayList`: To store the list of attendees.
 * *   `java.util.List`: Declare your attendee collection using the `List` interface type.
 * *   `java.util.Scanner`: To read user input from the console (menu choices, attendee names, request details).
 * *   `switch` statement: To control the main application flow based on the user's menu selection.
 * *   `System.err`: To output error messages (e.g., invalid input, attendee not found, no pending requests).
 * *   `System.out`: To output normal messages (menu, prompts, success messages, lists, processed requests).
 * *   Class-wide exception handling with `try-catch` blocks: Implement robust error handling, particularly around user input processing and potential issues during operations (e.g., unexpected input types). A general `try-catch` around the main processing loop is acceptable for catching unexpected runtime issues, in addition to specific input validation.
 * 
 * **Best Practices Requirements:**
 * 
 * *   **Encapsulation:** Use private fields for data storage (`attendees`, `requests`, `scanner`) and public methods for operations.
 * *   **Meaningful Names:** Use descriptive names for classes, methods, variables, and constants.
 * *   **Comments & Documentation:** Include Javadoc comments for classes and methods, and inline comments for complex logic if necessary.
 * *   **Input Validation:** Validate user input where appropriate (e.g., ensuring attendee name or request details are not empty, checking if an attendee exists before adding a request, handling non-integer input for menu choices).
 * *   **Error Handling:** Gracefully handle errors using `try-catch` and appropriate output (`System.err`).
 * *   **Clean Code Structure:** Organize your code logically into appropriate classes and methods.
 * 
 * **Expected Output:**
 * 
 * The application should present a clear menu to the user. Based on the user's input (an integer choice), it should perform the corresponding action. Output should be informative, guiding the user and confirming actions or reporting errors clearly using `System.out` and `System.err` as specified.
 * 
 * **Example Interaction Flow:**
 * 
 * ```
 * --- Event Management Menu ---
 * 1. Add New Attendee
 * 2. View All Attendees
 * 3. Submit Service Request
 * 4. Process Next Request
 * 5. View Pending Requests
 * 6. Exit
 * Enter your choice: 1
 * Enter attendee name: Alice
 * Attendee 'Alice' registered successfully.
 * 
 * --- Event Management Menu ---
 * ...
 * Enter your choice: 1
 * Enter attendee name: Bob
 * Attendee 'Bob' registered successfully.
 * 
 * --- Event Management Menu ---
 * ...
 * Enter your choice: 2
 * --- Registered Attendees ---
 * 1. Alice
 * 2. Bob
 * ----------------------------
 * 
 * --- Event Management Menu ---
 * ...
 * Enter your choice: 3
 * Enter attendee name: Charlie
 * Error: Attendee 'Charlie' not found. Cannot submit request. (Output to System.err)
 * 
 * --- Event Management Menu ---
 * ...
 * Enter your choice: 3
 * Enter attendee name: Alice
 * Enter service request details: Need help finding my seat
 * Request submitted for Alice: "Need help finding my seat"
 * 
 * --- Event Management Menu ---
 * ...
 * Enter your choice: 3
 * Enter attendee name: Bob
 * Enter service request details: Question about wifi
 * Request submitted for Bob: "Question about wifi"
 * 
 * --- Event Management Menu ---
 * ...
 * Enter your choice: 5
 * --- Pending Service Requests ---
 * 1. [Alice] Need help finding my seat
 * 2. [Bob] Question about wifi
 * --------------------------------
 * 
 * --- Event Management Menu ---
 * ...
 * Enter your choice: 4
 * Processing request: [Alice] Need help finding my seat
 * Request processed successfully.
 * 
 * --- Event Management Menu ---
 * ...
 * Enter your choice: 5
 * --- Pending Service Requests ---
 * 1. [Bob] Question about wifi
 * --------------------------------
 * 
 * --- Event Management Menu ---
 * ...
 * Enter your choice: 4
 * Processing request: [Bob] Question about wifi
 * Request processed successfully.
 * 
 * --- Event Management Menu ---
 * ...
 * Enter your choice: 4
 * Error: No pending service requests to process. (Output to System.err)
 * 
 * --- Event Management Menu ---
 * ...
 * Enter your choice: 7
 * Error: Invalid menu choice. Please try again. (Output to System.err)
 * 
 * --- Event Management Menu ---
 * ...
 * Enter your choice: 6
 * Exiting Event Management System.
 * ```
 * 
 * Implement the complete Java code for this application.
 *
 * EXPLANATION:
 * This solution implements the Event Management System as required, demonstrating the use of all specified Java components and adhering to best practices.
 * 
 * 1.  **Class Structure:**
 *     *   `Attendee` class: Simple class to hold attendee name. Encapsulates the name with a private field and a public getter. `toString()` is overridden for easy printing.
 *     *   `ServiceRequest` class: Holds the attendee's name (as a String for simplicity) and the request details. Encapsulates data with private fields and public getters. `toString()` is overridden for formatted output.
 *     *   `EventManager` class: This is the main class orchestrating the application. It holds the collections (`attendees` and `requests`) and the `Scanner`.
 * 
 * 2.  **Data Structures:**
 *     *   `private List<Attendee> attendees;`: An `ArrayList` is used to store `Attendee` objects. It's declared as a `List` interface type, which is good practice as it allows flexibility to change the underlying implementation later if needed (e.g., to a `LinkedList`) without altering the code that uses the list interface methods. `ArrayList` is suitable here as we primarily add and iterate, and occasionally search (`findAttendee`).
 *     *   `private Queue<ServiceRequest> requests;`: A `LinkedList` is used to implement the `Queue` interface to store `ServiceRequest` objects. `Queue` is perfect for service requests because they are processed in the order they are received (FIFO). `LinkedList` is a common implementation of `Queue` in Java.
 * 
 * 3.  **User Input (`Scanner`) and Main Loop (`switch`, `try-catch`):**
 *     *   A `Scanner` object (`scanner`) is created to read input from `System.in`.
 *     *   The `run()` method contains the main application loop (`while (choice != 6)`).
 *     *   Inside the loop, `displayMenu()` is called, and the user's input is read using `scanner.nextLine()`. Reading the whole line avoids common pitfalls with `scanner.nextInt()` and newline characters.
 *     *   `Integer.parseInt()` is used to convert the input string to an integer. This conversion is wrapped in a `try-catch (NumberFormatException e)` block to handle cases where the user enters non-numeric input, printing an error to `System.err`.
 *     *   A `switch` statement is used to direct the program flow based on the parsed integer choice, calling the appropriate private methods (`addAttendee`, `viewAttendees`, etc.).
 *     *   The `default` case in the `switch` handles valid integer inputs that don't match any menu option, printing an error to `System.err`.
 *     *   A general `try-catch (Exception e)` block wraps the core logic inside the `while` loop. This demonstrates class-wide exception handling, catching any unexpected runtime errors that might occur during execution within the loop and printing an error to `System.err`.
 * 
 * 4.  **Operations and Method Implementation:**
 *     *   `addAttendee()`: Prompts for a name, reads input, validates it's not empty, creates an `Attendee` object, and adds it to the `attendees` `ArrayList`. Includes optional duplicate check. Uses `System.out` for success/prompts and `System.err` for validation errors.
 *     *   `viewAttendees()`: Checks if the list is empty. If not, it iterates through the `attendees` list and prints each attendee using the `toString()` method, formatted with numbers. Uses `System.out`.
 *     *   `findAttendee()`: A helper method to search the `attendees` list by name (case-insensitive). Returns the `Attendee` object or `null`.
 *     *   `addServiceRequest()`: Prompts for attendee name and request details. It calls `findAttendee` to verify the attendee exists. If not found, it prints an error to `System.err`. If found, it validates the details are not empty, creates a `ServiceRequest` object, and adds it to the `requests` `Queue` using `offer()`. Uses `System.out` for success/prompts and `System.err` for validation/attendee not found errors.
 *     *   `processNextRequest()`: Uses `requests.poll()` to retrieve and remove the head of the queue (the oldest request). It checks if the result is `null` (meaning the queue was empty) and prints an error to `System.err` if so. Otherwise, it prints the processed request details using `System.out`.
 *     *   `viewPendingRequests()`: Checks if the queue is empty. If not, it iterates through the `requests` `Queue` using an enhanced for loop. This iterates over the elements *without* removing them, fulfilling the requirement to view *pending* requests. Prints each request using `System.out`.
 *     *   `closeScanner()`: A method to close the `Scanner` resource, called after the main loop finishes, to prevent resource leaks.
 * 
 * 5.  **Best Practices:**
 *     *   **Encapsulation:** All collection fields (`attendees`, `requests`) and the `scanner` are `private`. Operations are exposed through `public` or `private` methods as appropriate.
 *     *   **Meaningful Names:** Class names (`Attendee`, `ServiceRequest`, `EventManager`), method names (`addAttendee`, `processNextRequest`, `viewPendingRequests`), and variable names (`attendees`, `requests`, `choice`, `name`, `details`) are descriptive.
 *     *   **Comments:** Javadoc comments explain the purpose of classes, methods, and parameters. Inline comments explain specific implementation details where needed.
 *     *   **Input Validation:** Checks for empty names/details and attendee existence are performed *before* creating objects or adding to collections, preventing invalid data. `NumberFormatException` is caught for menu input.
 *     *   **Error Handling:** `System.err` is used specifically for error messages (validation failures, invalid input, operational errors like empty queue). `try-catch` blocks handle potential exceptions.
 *     *   **Clean Code:** The code is organized into logical methods, each responsible for a single task. The `run` method provides the main control flow.
 * 
 * This solution effectively integrates the required Java components within a practical scenario, demonstrating understanding of data structures, control flow, input/output, exception handling, and object-oriented principles.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.InputMismatchException; // Although using nextLine avoids this, good to be aware

/**
 * Represents an attendee at the event.
 */
class Attendee {
    private String name;

    /**
     * Constructs a new Attendee.
     * @param name The name of the attendee.
     */
    public Attendee(String name) {
        this.name = name;
    }

    /**
     * Gets the name of the attendee.
     * @return The attendee's name.
     */
    public String getName() {
        return name;
    }

    /**
     * Provides a string representation of the Attendee.
     * @return The attendee's name.
     */
    @Override
    public String toString() {
        return name;
    }
}

/**
 * Represents a service request made by an attendee.
 */
class ServiceRequest {
    private String attendeeName; // Store name for simplicity in this example
    private String details;

    /**
     * Constructs a new ServiceRequest.
     * @param attendeeName The name of the attendee making the request.
     * @param details The details of the request.
     */
    public ServiceRequest(String attendeeName, String details) {
        this.attendeeName = attendeeName;
        this.details = details;
    }

    /**
     * Gets the name of the attendee who made the request.
     * @return The attendee's name.
     */
    public String getAttendeeName() {
        return attendeeName;
    }

    /**
     * Gets the details of the request.
     * @return The request details.
     */
    public String getDetails() {
        return details;
    }

    /**
     * Provides a string representation of the ServiceRequest.
     * @return A formatted string showing the attendee and request details.
     */
    @Override
    public String toString() {
        return "[" + attendeeName + "] " + details;
    }
}

/**
 * Manages event attendees and their service requests.
 */
public class EventManager {

    private List<Attendee> attendees; // Use List interface type
    private Queue<ServiceRequest> requests; // Use Queue interface type
    private Scanner scanner;

    /**
     * Constructs a new EventManager, initializing collections and scanner.
     */
    public EventManager() {
        attendees = new ArrayList<>(); // Use ArrayList implementation
        requests = new LinkedList<>(); // Use LinkedList implementation for Queue
        scanner = new Scanner(System.in);
    }

    /**
     * Displays the main menu options to the user.
     */
    private void displayMenu() {
        System.out.println("\n--- Event Management Menu ---");
        System.out.println("1. Add New Attendee");
        System.out.println("2. View All Attendees");
        System.out.println("3. Submit Service Request");
        System.out.println("4. Process Next Request");
        System.out.println("5. View Pending Requests");
        System.out.println("6. Exit");
        System.out.print("Enter your choice: ");
    }

    /**
     * Runs the main application loop, handling user input and actions.
     */
    public void run() {
        int choice = -1; // Initialize with a value that won't match any case
        while (choice != 6) {
            displayMenu();
            try {
                // Read the entire line to avoid issues with nextInt and newline
                String input = scanner.nextLine();
                choice = Integer.parseInt(input); // Attempt to parse as integer

                // Use switch statement for main flow control
                switch (choice) {
                    case 1:
                        addAttendee();
                        break;
                    case 2:
                        viewAttendees();
                        break;
                    case 3:
                        addServiceRequest();
                        break;
                    case 4:
                        processNextRequest();
                        break;
                    case 5:
                        viewPendingRequests();
                        break;
                    case 6:
                        System.out.println("Exiting Event Management System.");
                        break;
                    default:
                        // Handle invalid integer input
                        System.err.println("Error: Invalid menu choice. Please enter a number between 1 and 6.");
                        break;
                }
            } catch (NumberFormatException e) {
                // Handle non-integer input gracefully
                System.err.println("Error: Invalid input. Please enter a number.");
            } catch (Exception e) {
                // Class-wide catch for any unexpected runtime errors
                System.err.println("An unexpected error occurred: " + e.getMessage());
                // e.printStackTrace(); // Uncomment for debugging
            }
        }
        closeScanner(); // Ensure scanner is closed on exit
    }

    /**
     * Adds a new attendee to the system based on user input.
     */
    private void addAttendee() {
        System.out.print("Enter attendee name: ");
        String name = scanner.nextLine().trim(); // Use trim() to remove leading/trailing whitespace

        if (name.isEmpty()) {
            System.err.println("Error: Attendee name cannot be empty.");
            return;
        }

        // Optional: Check for duplicate names (not strictly required by prompt, but good practice)
        for (Attendee attendee : attendees) {
            if (attendee.getName().equalsIgnoreCase(name)) {
                System.err.println("Error: Attendee '" + name + "' already exists.");
                return;
            }
        }

        Attendee newAttendee = new Attendee(name);
        attendees.add(newAttendee);
        System.out.println("Attendee '" + name + "' registered successfully.");
    }

    /**
     * Displays the list of all registered attendees.
     */
    private void viewAttendees() {
        if (attendees.isEmpty()) {
            System.out.println("No attendees registered yet.");
            return;
        }

        System.out.println("--- Registered Attendees ---");
        for (int i = 0; i < attendees.size(); i++) {
            System.out.println((i + 1) + ". " + attendees.get(i)); // Uses Attendee's toString()
        }
        System.out.println("----------------------------");
    }

    /**
     * Finds an attendee by name (case-insensitive search).
     * @param name The name to search for.
     * @return The Attendee object if found, otherwise null.
     */
    private Attendee findAttendee(String name) {
        for (Attendee attendee : attendees) {
            if (attendee.getName().equalsIgnoreCase(name.trim())) {
                return attendee;
            }
        }
        return null;
    }

    /**
     * Submits a new service request from an existing attendee.
     */
    private void addServiceRequest() {
        System.out.print("Enter attendee name for the request: ");
        String attendeeName = scanner.nextLine().trim();

        Attendee attendee = findAttendee(attendeeName);

        if (attendee == null) {
            System.err.println("Error: Attendee '" + attendeeName + "' not found. Cannot submit request.");
            return;
        }

        System.out.print("Enter service request details: ");
        String details = scanner.nextLine().trim();

        if (details.isEmpty()) {
            System.err.println("Error: Request details cannot be empty.");
            return;
        }

        ServiceRequest request = new ServiceRequest(attendee.getName(), details);
        requests.offer(request); // Add to the end of the queue
        System.out.println("Request submitted for " + attendee.getName() + ": \"" + details + "\"");
    }

    /**
     * Processes the next pending service request from the queue.
     */
    private void processNextRequest() {
        ServiceRequest nextRequest = requests.poll(); // Retrieve and remove the head of the queue

        if (nextRequest == null) {
            System.err.println("Error: No pending service requests to process.");
        } else {
            System.out.println("Processing request: " + nextRequest); // Uses ServiceRequest's toString()
            System.out.println("Request processed successfully.");
            // In a real system, processing logic would go here
        }
    }

    /**
     * Displays all pending service requests in the queue without removing them.
     */
    private void viewPendingRequests() {
        if (requests.isEmpty()) {
            System.out.println("No pending service requests.");
            return;
        }

        System.out.println("--- Pending Service Requests ---");
        // Iterate through the queue without removing elements
        int count = 1;
        for (ServiceRequest request : requests) {
            System.out.println(count++ + ". " + request); // Uses ServiceRequest's toString()
        }
        System.out.println("--------------------------------");
    }

    /**
     * Closes the scanner resource.
     */
    private void closeScanner() {
        if (scanner != null) {
            scanner.close();
        }
    }

    /**
     * Main method to start the application.
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        EventManager manager = new EventManager();
        manager.run();
    }
}
