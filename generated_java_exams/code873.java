/*
 * Exam Question #873
 * Generated on: 2025-05-12 16:53:22
 * Generated by: Account 1
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Technical Support Ticket Dispatch System
 * 
 * **Objective:** Design and implement a simplified technical support ticket dispatch system. The system should manage incoming support tickets and assign them to available technicians.
 * 
 * **Scenario:** Incoming support requests are added to a queue. Available technicians are managed in a list. When a dispatch operation occurs, the system should take the next pending ticket from the queue and assign it to the first available technician in the list.
 * 
 * **Requirements:**
 * 
 * 1.  **Classes:**
 *     *   `Ticket`: Represents a support ticket. Should have a unique ID (integer), a description (String), and a status (e.g., PENDING, ASSIGNED, RESOLVED). Use an enum for status is recommended but not strictly required if constants are used.
 *     *   `Technician`: Represents a support technician. Should have a unique ID (integer), a name (String), and a status (e.g., AVAILABLE, BUSY). Use an enum or constants for status.
 *     *   `TicketDispatchSystem`: Manages the collection of tickets and technicians and handles the dispatch logic.
 *     *   A main class (e.g., `SupportSystemApp`) containing the `main` method to run the application and handle user interaction.
 * 
 * 2.  **Data Structures:**
 *     *   Use `java.util.Queue<Ticket>` to store pending tickets.
 *     *   Use `java.util.ArrayList<Technician>` to store technicians, declaring the variable using the `java.util.List` interface type (`List<Technician>`).
 * 
 * 3.  **Functionality (Menu-driven):** The main application should present a menu to the user with the following options:
 *     *   1. Add New Ticket: Prompt user for description, create a new `Ticket` with status PENDING, and add it to the queue.
 *     *   2. Dispatch Next Ticket: Attempt to take the next ticket from the queue and assign it to the first AVAILABLE technician in the list. Update both ticket and technician statuses.
 *     *   3. List Pending Tickets: Display all tickets currently in the queue.
 *     *   4. List Technicians: Display all technicians and their current status.
 *     *   5. Exit: Terminate the application.
 * 
 * 4.  **Input/Output:**
 *     *   Use `java.util.Scanner` to read user input from the console.
 *     *   Use `System.out` for menu display, prompts, and normal output (listing tickets/technicians, success messages).
 *     *   Use `System.err` to display error messages (e.g., invalid menu choice, invalid input format, queue is empty when trying to dispatch, no available technicians).
 * 
 * 5.  **Control Flow:**
 *     *   Use a `switch` statement to handle the user's menu selection.
 *     *   Use a loop to keep the menu running until the user chooses to exit.
 * 
 * 6.  **Exception Handling:**
 *     *   Implement class-wide exception handling using `try-catch` blocks in the main application loop to gracefully handle potential runtime errors, especially related to user input (e.g., non-integer input when an integer is expected).
 *     *   Handle specific error conditions within the dispatch logic (e.g., no pending tickets, no available technicians) and report them using `System.err`.
 * 
 * 7.  **Best Practices:**
 *     *   Implement proper encapsulation (private fields, public methods) in your classes.
 *     *   Use meaningful variable and method names.
 *     *   Add comments and documentation (Javadoc or inline) where appropriate.
 *     *   Perform basic input validation (e.g., checking if input is an integer when required).
 *     *   Ensure clean code structure.
 * 
 * **Initial State:** The system should start with an empty ticket queue and a predefined list of at least 3 technicians (e.g., Technician 1, Technician 2, Technician 3), all initially AVAILABLE.
 * 
 * **Expected Output:**
 * *   Clear menu prompts.
 * *   Informative messages on successful operations (e.g., "Ticket added.", "Ticket [ID] assigned to Technician [Name].").
 * *   Formatted lists of pending tickets and technicians with their statuses.
 * *   Specific error messages using `System.err` when operations fail (e.g., "Error: Invalid input. Please enter a number.", "Error: No pending tickets to dispatch.", "Error: No available technicians.").
 * *   Graceful exit.
 * 
 * **Evaluation:** Your solution will be evaluated based on correctness, adherence to all requirements (especially the use of the specified components), code quality, error handling robustness, and clarity.
 *
 * EXPLANATION:
 * This solution implements a simplified technical support ticket dispatch system demonstrating the required Java concepts and best practices.
 * 
 * 1.  **Class Structure:**
 *     *   `Ticket` and `Technician` classes encapsulate the data and state for individual tickets and technicians using private fields (`id`, `description`, `status`, `name`). Getters provide read access. Setters are used internally by the `TicketDispatchSystem` to manage status and assignments. `AtomicInteger` is used to generate simple unique IDs, avoiding potential issues in multi-threaded environments (though this specific app is single-threaded, it's a good practice).
 *     *   `TicketDispatchSystem` acts as the central manager. It holds the data structures (`pendingTickets` queue and `technicians` list) and contains the core logic for adding tickets, dispatching, and listing.
 *     *   `SupportSystemApp` contains the `main` method, handles user interaction via the menu, and orchestrates calls to the `TicketDispatchSystem`.
 * 
 * 2.  **Data Structures (`Queue`, `ArrayList`, `List`):**
 *     *   `Queue<Ticket> pendingTickets = new LinkedList<>();`: A `LinkedList` is used as a concrete implementation of the `Queue` interface. This is suitable because tickets are processed in a FIFO (First-In, First-Out) manner. `offer()` is used to add elements and `poll()` to remove them from the front.
 *     *   `List<Technician> technicians = new ArrayList<>();`: An `ArrayList` is used as a concrete implementation of the `List` interface to store the technicians. `ArrayList` is a good choice for managing a dynamic list where elements might be accessed by index or iterated over. The variable is declared using the `List` interface type (`List<Technician>`) which promotes good practice by programming to the interface rather than the specific implementation.
 * 
 * 3.  **User Input (`Scanner`):**
 *     *   A single `Scanner` instance is created in `main` to read user input from `System.in`.
 *     *   `scanner.nextLine()` is used consistently to read entire lines, which helps avoid common pitfalls when mixing `nextInt()` or `nextDouble()` with `nextLine()`. Input parsing (e.g., to `int`) is done separately.
 * 
 * 4.  **Control Flow (`Switch`, Loop):**
 *     *   A `while(running)` loop keeps the application running until the user chooses to exit.
 *     *   A `switch` statement is used within the loop to direct execution based on the integer choice read from the user. This provides a clear and structured way to handle the menu options.
 * 
 * 5.  **Input/Output (`System.out`, `System.err`):**
 *     *   `System.out.println()` is used for displaying the menu, prompts, success messages, and formatted lists of tickets and technicians.
 *     *   `System.err.println()` is specifically used for printing error messages, making them visually distinct (often appearing in red in many consoles/IDEs) and directing them to the standard error stream. This includes invalid menu choices, empty queue/no technician errors during dispatch, and input format errors.
 * 
 * 6.  **Exception Handling (`try-catch`):**
 *     *   A `try-catch (Exception e)` block wraps the main `while` loop in the `main` method. This serves as a top-level, "class-wide" handler to catch any unexpected exceptions that might occur during the program's execution and print a general error message before exiting.
 *     *   A specific `try-catch (NumberFormatException e)` block is nested *inside* the loop around the `Integer.parseInt(scanner.nextLine())` call. This handles the specific case where the user enters non-numeric input for the menu choice, providing a more informative error message (`System.err`) and preventing the program from crashing due to this common input error.
 *     *   Error conditions within the `TicketDispatchSystem` methods (like trying to dispatch from an empty queue or when no technicians are available) are checked explicitly with `if` statements, and error messages are printed using `System.err`. While these could potentially throw custom exceptions, using `System.err` directly within the method is acceptable for this problem's scope and meets the requirement of reporting errors via `System.err`.
 * 
 * 7.  **Best Practices:**
 *     *   **Encapsulation:** Fields in `Ticket` and `Technician` are `private`, and access/modification is controlled via public or package-private methods. The `TicketDispatchSystem`'s internal data structures are also private.
 *     *   **Naming:** Variable names (`pendingTickets`, `availableTech`), method names (`addNewTicket`, `dispatchNextTicket`, `findAvailableTechnician`), and class names are descriptive.
 *     *   **Comments:** Basic comments explain the purpose of classes, methods, and key code sections. Javadoc-style comments are used for public methods.
 *     *   **Input Validation:** Basic validation checks if the ticket description is empty and handles `NumberFormatException` for menu input.
 *     *   **Clean Code:** The code is organized into logical classes, methods are reasonably sized, and the main loop is clean due to the use of the `switch` statement and separate methods in `TicketDispatchSystem`. The `finally` block ensures the `Scanner` is closed, releasing system resources.
 * 
 * This solution effectively integrates all the required Java components to build a functional, albeit simple, simulation of a real-world dispatch system, demonstrating key object-oriented principles and error handling techniques.
 */

import java.util.LinkedList;
import java.util.Queue;
import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;
import java.util.concurrent.atomic.AtomicInteger; // For generating unique IDs

// Enum for Ticket Status
enum TicketStatus {
    PENDING, ASSIGNED, RESOLVED // RESOLVED is not strictly required by menu but good practice
}

// Enum for Technician Status
enum TechnicianStatus {
    AVAILABLE, BUSY
}

// Represents a support ticket
class Ticket {
    private static final AtomicInteger idCounter = new AtomicInteger(0);
    private final int id;
    private String description;
    private TicketStatus status;
    private Technician assignedTechnician; // To link assigned technician

    public Ticket(String description) {
        this.id = idCounter.incrementAndGet();
        this.description = description;
        this.status = TicketStatus.PENDING;
        this.assignedTechnician = null;
    }

    // Getters
    public int getId() {
        return id;
    }

    public String getDescription() {
        return description;
    }

    public TicketStatus getStatus() {
        return status;
    }

    public Technician getAssignedTechnician() {
        return assignedTechnician;
    }

    // Setters (package-private or public as needed by TicketDispatchSystem)
    void setStatus(TicketStatus status) {
        this.status = status;
    }

    void setAssignedTechnician(Technician assignedTechnician) {
        this.assignedTechnician = assignedTechnician;
    }

    @Override
    public String toString() {
        String assigned = (assignedTechnician != null) ? " (Assigned to Tech " + assignedTechnician.getId() + ")" : "";
        return "Ticket [ID=" + id + ", Status=" + status + ", Description='" + description + "'" + assigned + "]";
    }
}

// Represents a support technician
class Technician {
    private static final AtomicInteger idCounter = new AtomicInteger(0);
    private final int id;
    private String name;
    private TechnicianStatus status;

    public Technician(String name) {
        this.id = idCounter.incrementAndGet();
        this.name = name;
        this.status = TechnicianStatus.AVAILABLE;
    }

    // Getters
    public int getId() {
        return id;
    }

    public String getName() {
        return name;
    }

    public TechnicianStatus getStatus() {
        return status;
    }

    // Setter (package-private or public as needed by TicketDispatchSystem)
    void setStatus(TechnicianStatus status) {
        this.status = status;
    }

    @Override
    public String toString() {
        return "Technician [ID=" + id + ", Name='" + name + "', Status=" + status + "]";
    }
}

// Manages tickets and technicians, handles dispatch logic
class TicketDispatchSystem {
    private Queue<Ticket> pendingTickets;
    private List<Technician> technicians; // Declared using List interface

    public TicketDispatchSystem() {
        // Use LinkedList as an implementation of Queue
        this.pendingTickets = new LinkedList<>();
        // Use ArrayList as an implementation of List
        this.technicians = new ArrayList<>();

        // Initialize with some technicians
        technicians.add(new Technician("Alice"));
        technicians.add(new Technician("Bob"));
        technicians.add(new Technician("Charlie"));
    }

    /**
     * Adds a new ticket to the pending queue.
     * @param description The description of the ticket.
     */
    public void addNewTicket(String description) {
        Ticket newTicket = new Ticket(description);
        pendingTickets.offer(newTicket); // offer is preferred over add for queues
        System.out.println("System: Ticket " + newTicket.getId() + " added to queue.");
    }

    /**
     * Dispatches the next pending ticket to an available technician.
     */
    public void dispatchNextTicket() {
        if (pendingTickets.isEmpty()) {
            System.err.println("System Error: No pending tickets to dispatch.");
            return;
        }

        Technician availableTech = findAvailableTechnician();

        if (availableTech == null) {
            System.err.println("System Error: No available technicians to assign the ticket.");
            return;
        }

        // Poll the next ticket from the queue
        Ticket nextTicket = pendingTickets.poll();

        // Assign ticket to technician
        nextTicket.setStatus(TicketStatus.ASSIGNED);
        nextTicket.setAssignedTechnician(availableTech);

        // Set technician status to busy
        availableTech.setStatus(TechnicianStatus.BUSY);

        System.out.println("System: Ticket " + nextTicket.getId() + " assigned to Technician " + availableTech.getName() + " (ID: " + availableTech.getId() + ").");
    }

    /**
     * Finds the first available technician.
     * @return An available Technician object, or null if none are available.
     */
    private Technician findAvailableTechnician() {
        for (Technician tech : technicians) {
            if (tech.getStatus() == TechnicianStatus.AVAILABLE) {
                return tech;
            }
        }
        return null; // No available technician found
    }

    /**
     * Lists all tickets currently in the pending queue.
     */
    public void listPendingTickets() {
        if (pendingTickets.isEmpty()) {
            System.out.println("System: No tickets currently pending.");
            return;
        }
        System.out.println("--- Pending Tickets ---");
        // Iterate through the queue without removing elements
        for (Ticket ticket : pendingTickets) {
            System.out.println(ticket);
        }
        System.out.println("-----------------------");
    }

    /**
     * Lists all technicians and their current status.
     */
    public void listTechnicians() {
        if (technicians.isEmpty()) {
            System.out.println("System: No technicians registered.");
            return;
        }
        System.out.println("--- Technicians ---");
        for (Technician tech : technicians) {
            System.out.println(tech);
        }
        System.out.println("-------------------");
    }
}

// Main application class
public class SupportSystemApp {

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        TicketDispatchSystem dispatchSystem = new TicketDispatchSystem();
        boolean running = true;

        System.out.println("--- Technical Support Ticket Dispatch System ---");

        // Class-wide exception handling for the main application loop
        try {
            while (running) {
                printMenu();
                System.out.print("Enter your choice: ");

                // Use a nested try-catch for input parsing
                try {
                    int choice = Integer.parseInt(scanner.nextLine()); // Read entire line to avoid issues with nextInt/nextLine mix

                    // Switch statement for menu selection
                    switch (choice) {
                        case 1:
                            System.out.print("Enter ticket description: ");
                            String description = scanner.nextLine();
                            if (description == null || description.trim().isEmpty()) {
                                System.err.println("Error: Ticket description cannot be empty.");
                            } else {
                                dispatchSystem.addNewTicket(description.trim());
                            }
                            break;
                        case 2:
                            dispatchSystem.dispatchNextTicket();
                            break;
                        case 3:
                            dispatchSystem.listPendingTickets();
                            break;
                        case 4:
                            dispatchSystem.listTechnicians();
                            break;
                        case 5:
                            System.out.println("System: Exiting application. Goodbye!");
                            running = false;
                            break;
                        default:
                            System.err.println("Error: Invalid choice. Please enter a number between 1 and 5.");
                            break;
                    }
                } catch (NumberFormatException e) {
                    // Catch specific error for invalid number format input
                    System.err.println("Error: Invalid input format. Please enter a number corresponding to the menu option.");
                }
                System.out.println(); // Add a newline for better readability between actions
            }
        } catch (Exception e) {
            // Catch any unexpected exceptions during the main loop
            System.err.println("An unexpected error occurred: " + e.getMessage());
            // e.printStackTrace(); // Optional: for debugging purposes
        } finally {
            // Ensure the scanner is closed when the application exits
            scanner.close();
            System.out.println("Scanner closed.");
        }
    }

    /**
     * Prints the main menu options to the console.
     */
    private static void printMenu() {
        System.out.println("Menu:");
        System.out.println("1. Add New Ticket");
        System.out.println("2. Dispatch Next Ticket");
        System.out.println("3. List Pending Tickets");
        System.out.println("4. List Technicians");
        System.out.println("5. Exit");
    }
}
