/*
 * Exam Question #931
 * Generated on: 2025-05-12 17:01:18
 * Generated by: Account 2
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Help Desk Ticket Management System
 * 
 * **Objective:** Implement a command-line application for managing support tickets as they move through different stages. This task requires demonstrating proficiency in using various Java collection types, handling user input, implementing control flow, and managing exceptions effectively.
 * 
 * **Scenario:** You are developing a simple Help Desk system. Tickets are initially submitted, then picked up by a technician, and finally resolved. The system needs to track tickets in these different states.
 * 
 * **Requirements:**
 * 
 * 1.  **`Ticket` Class:**
 *     *   Create a `public class Ticket`.
 *     *   Include `private` fields: `ticketId` (an integer, auto-generated starting from 1 for each new ticket), `description` (String), and `status` (using an `enum` called `TicketStatus` with values `NEW`, `IN_PROGRESS`, `RESOLVED`).
 *     *   Provide a constructor that takes only the `description` and initializes the ticket with a new ID and `NEW` status.
 *     *   Include public getter methods for all fields (`getTicketId`, `getDescription`, `getStatus`).
 *     *   Include a public method `setStatus(TicketStatus status)` to change the ticket's status.
 *     *   Override the `toString()` method to provide a user-friendly representation of the ticket (e.g., "Ticket [ID=1, Desc='Printer not working', Status=NEW]").
 * 
 * 2.  **`TicketStatus` Enum:**
 *     *   Create a `public enum TicketStatus` with the values `NEW`, `IN_PROGRESS`, `RESOLVED`.
 * 
 * 3.  **`HelpDeskSystem` Class:**
 *     *   Create a `public class HelpDeskSystem` which will contain the main application logic.
 *     *   Declare `private` fields to manage tickets using the specified collections:
 *         *   A `java.util.Queue<Ticket>` for new tickets. Use a suitable implementation like `java.util.LinkedList`.
 *         *   A `java.util.List<Ticket>` for tickets currently being worked on. Use `java.util.ArrayList` as the implementation.
 *         *   A `java.util.List<Ticket>` for resolved tickets. Use `java.util.ArrayList` as the implementation.
 *     *   Declare a `private` field for `java.util.Scanner` to handle user input.
 *     *   In the constructor, initialize these collection fields and the `Scanner`.
 * 
 * 4.  **Core Functionality Methods:**
 *     *   Implement a `public void addTicket()` method. It should prompt the user for a ticket description, create a new `Ticket` object, and add it to the new tickets `Queue`. Validate that the description is not empty.
 *     *   Implement a `public void viewTickets()` method. It should display the contents of the new tickets `Queue`, the in-progress `List`, and the resolved tickets `List`. For each collection, print its name, size, and list each ticket within it using its `toString()` representation.
 *     *   Implement a `public void pickUpTicket()` method. It should prompt the user for a ticket ID. Find the ticket with that ID in the new tickets `Queue`, remove it from the queue, update its status to `IN_PROGRESS`, and add it to the in-progress `List`. Handle cases where the new tickets queue is empty or the specified ID is not found in the new queue.
 *     *   Implement a `public void resolveTicket()` method. It should prompt the user for a ticket ID. Find the ticket with that ID in the in-progress `List`, remove it from the list, update its status to `RESOLVED`, and add it to the resolved tickets `List`. Handle cases where the in-progress list is empty or the specified ID is not found in the in-progress list.
 * 
 * 5.  **Menu and Main Loop:**
 *     *   Implement a `private void displayMenu()` method to show the available options to the user.
 *     *   Implement a `public void run()` method that contains the main application loop. This method should repeatedly:
 *         *   Display the menu.
 *         *   Read the user's choice using `Scanner`.
 *         *   Use a `switch` statement to execute the corresponding functionality method (`addTicket`, `viewTickets`, `pickUpTicket`, `resolveTicket`) or exit the application.
 *         *   The loop should continue until the user chooses the 'Exit' option.
 * 
 * 6.  **Exception Handling:**
 *     *   Implement custom exception classes (e.g., `TicketNotFoundException`, `InvalidOperationException`) to represent specific error conditions like a ticket ID not being found in the expected collection or attempting an operation on an empty collection.
 *     *   Use `try-catch` blocks within the `run()` method and/or the operational methods (`pickUpTicket`, `resolveTicket`) to handle potential exceptions, including `java.util.InputMismatchException` for invalid numeric input and your custom exceptions.
 *     *   Ensure that `System.err.println()` is used exclusively for printing error messages.
 *     *   Ensure that `System.out.println()` is used for all other output (menu, prompts, successful operations, ticket lists).
 *     *   Include a broad `try-catch` block within the `run()` method that covers the main loop or significant operational logic to demonstrate class-wide exception handling, in addition to specific handlers for known exceptions.
 * 
 * 7.  **Best Practices:**
 *     *   Ensure all fields are private and accessed via public methods (encapsulation).
 *     *   Use meaningful names for classes, methods, variables, and enum constants.
 *     *   Include comments where necessary to explain complex logic (e.g., how to find/remove an item from the Queue by ID).
 *     *   Validate user input where appropriate (e.g., non-empty description, valid menu choice, numeric input).
 *     *   Close the `Scanner` resource when the application exits.
 * 
 * 8.  **Required Components Checklist:** Ensure your solution explicitly uses:
 *     *   `java.util.Queue`
 *     *   `java.util.ArrayList`
 *     *   `java.util.List`
 *     *   `java.util.Scanner`
 *     *   `switch` statement
 *     *   `System.err`
 *     *   `System.out`
 *     *   `try-catch` blocks (including class-wide coverage as described in point 6)
 * 
 * **Expected Output:** The program should present a clear menu, respond to user input by performing the requested actions, display the state of the ticket queues/lists, and print informative messages (successes to `System.out`, errors to `System.err`).
 * 
 * **Grading:** Your solution will be evaluated based on correctness, adherence to all requirements (especially the use of mandated components), proper exception handling, input validation, code structure, and adherence to best practices.
 *
 * EXPLANATION:
 * The provided solution implements a simple Help Desk Ticket Management System, fulfilling all the specified requirements and demonstrating the practical use of advanced Java concepts.
 * 
 * **Key Components and Concepts Demonstrated:**
 * 
 * 1.  **`Queue` (`java.util.Queue`)**: The `newTicketsQueue` is implemented using `java.util.LinkedList`, which is a common `Queue` implementation. It correctly uses `offer()` to add elements and `poll()` to remove elements from the head during the `pickUpTicket` operation. Iteration is used in `viewTickets` to display queue elements without removing them. The `pickUpTicket` method specifically demonstrates the challenge of removing a non-head element from a `Queue` by iterating and temporarily storing other elements.
 * 
 * 2.  **`ArrayList` (`java.util.ArrayList`)**: `ArrayList` is used as the concrete implementation for the `inProgressTicketsList` and `resolvedTicketsList`. This showcases the use of a dynamic array-based list for storing and managing collections of objects where efficient random access and iteration are needed.
 * 
 * 3.  **`List` interface (`java.util.List`)**: The `inProgressTicketsList` and `resolvedTicketsList` are declared using the `List` interface (`List<Ticket>`). This adheres to the principle of programming to interfaces rather than concrete implementations, providing flexibility.
 * 
 * 4.  **`Scanner` (`java.util.Scanner`)**: A `Scanner` object is used to read user input from `System.in` for menu choices, ticket descriptions, and ticket IDs. The code correctly handles potential issues when mixing `nextInt()` or similar methods with `nextLine()` by consuming the leftover newline character.
 * 
 * 5.  **`switch` statement**: A `switch` statement is used in the `run()` method to direct the program flow based on the user's integer input from the main menu, providing a clear and structured way to handle different commands.
 * 
 * 6.  **`System.err`**: `System.err.println()` is used exclusively for printing error messages, such as invalid input, ticket not found, or attempting an operation on an empty collection. This differentiates error output from normal program output (`System.out`).
 * 
 * 7.  **`System.out`**: `System.out.println()` is used for all standard output, including the menu, prompts for input, confirmation messages for successful operations, and the formatted display of tickets in the `viewTickets` method.
 * 
 * 8.  **`try-catch` blocks (Class-wide Exception Handling)**:
 *     *   Specific `try-catch` blocks are used around `scanner.nextInt()` calls in `run()`, `pickUpTicket()`, and `resolveTicket()` to catch `InputMismatchException` when the user enters non-numeric input.
 *     *   Specific `try-catch` blocks are used within the `switch` cases in `run()` to catch the custom exceptions (`TicketNotFoundException`, `InvalidOperationException`) thrown by the `pickUpTicket()` and `resolveTicket()` methods. This allows the program to handle expected operational errors gracefully by printing an informative message to `System.err`.
 *     *   A broader `try-catch(Exception e)` block wraps the main `do-while` loop inside the `run()` method. This serves as a "class-wide" catch-all handler for any unexpected exceptions that might occur and weren't specifically handled, preventing the program from crashing immediately and providing some level of robustness. A `finally` block ensures the `Scanner` is closed regardless of how the `try` block exits.
 * 
 * 9.  **Creative and Practical Scenario**: The Help Desk Ticket System is a practical, relatable scenario that naturally maps ticket states to different collection types.
 * 
 * 10. **Best Practices**:
 *     *   **Encapsulation**: The `Ticket` class fields are private with public getters and a controlled setter for status. `HelpDeskSystem` fields are also private.
 *     *   **Meaningful Names**: Variables (`newTicketsQueue`, `ticketToPickUp`), methods (`addTicket`, `pickUpTicket`), enum values (`NEW`, `IN_PROGRESS`), and custom exceptions are clearly named.
 *     *   **Comments**: Comments are included to explain the purpose of classes, methods, and particularly the less intuitive logic like removing an item from the queue by ID.
 *     *   **Input Validation**: Checks are performed for empty ticket descriptions and using `try-catch` for numeric input validation. Operations like picking up or resolving tickets first check if the relevant collections are empty.
 *     *   **Proper Error Handling**: Custom exceptions provide specific error context, `System.err` is used for errors, and exceptions are caught and reported.
 *     *   **Clean Code Structure**: The code is organized into logical classes (`Ticket`, `HelpDeskSystem`) and methods, improving readability and maintainability.
 * 
 * This solution effectively integrates all the required Java components into a functional application, demonstrating a solid understanding of core Java programming concepts and best practices.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.InputMismatchException;
import java.util.Iterator;

// Enum for Ticket Status
enum TicketStatus {
    NEW, IN_PROGRESS, RESOLVED
}

// Custom Exception for when a ticket is not found
class TicketNotFoundException extends Exception {
    public TicketNotFoundException(String message) {
        super(message);
    }
}

// Custom Exception for invalid operations (e.g., operating on an empty queue/list)
class InvalidOperationException extends Exception {
    public InvalidOperationException(String message) {
        super(message);
    }
}

// Ticket class
class Ticket {
    private static int nextId = 1; // Auto-generated ID counter
    private int ticketId;
    private String description;
    private TicketStatus status;

    // Constructor
    public Ticket(String description) {
        this.ticketId = nextId++; // Assign unique ID and increment counter
        this.description = description;
        this.status = TicketStatus.NEW; // New tickets start with NEW status
    }

    // Getters
    public int getTicketId() {
        return ticketId;
    }

    public String getDescription() {
        return description;
    }

    public TicketStatus getStatus() {
        return status;
    }

    // Setter for status
    public void setStatus(TicketStatus status) {
        this.status = status;
    }

    // toString method for easy printing
    @Override
    public String toString() {
        return "Ticket [ID=" + ticketId + ", Desc='" + description + "', Status=" + status + "]";
    }
}

// Main Help Desk System class
public class HelpDeskSystem {
    // Required collections
    private Queue<Ticket> newTicketsQueue;
    private List<Ticket> inProgressTicketsList; // Using List interface
    private List<Ticket> resolvedTicketsList;   // Using List interface

    private Scanner scanner; // Required for user input

    // Constructor
    public HelpDeskSystem() {
        newTicketsQueue = new LinkedList<>(); // LinkedList implements Queue
        inProgressTicketsList = new ArrayList<>(); // ArrayList implements List
        resolvedTicketsList = new ArrayList<>(); // ArrayList implements List
        scanner = new Scanner(System.in);
    }

    // Method to add a new ticket
    public void addTicket() {
        System.out.println("\n--- Add New Ticket ---");
        System.out.print("Enter ticket description: ");

        // Consume the newline character left by previous nextInt() or similar
        // This is crucial when mixing nextInt/nextDouble with nextLine
        scanner.nextLine();

        String description = scanner.nextLine().trim(); // Read the full line and trim whitespace

        // Input validation: Check if description is empty
        if (description.isEmpty()) {
            System.err.println("Error: Ticket description cannot be empty.");
            return; // Exit the method if validation fails
        }

        Ticket newTicket = new Ticket(description);
        newTicketsQueue.offer(newTicket); // Add to the end of the queue
        System.out.println("Ticket added successfully: " + newTicket.toString());
    }

    // Method to view all tickets by status
    public void viewTickets() {
        System.out.println("\n--- Current Tickets ---");

        // Display New Tickets Queue
        System.out.println("\nNew Tickets Queue (" + newTicketsQueue.size() + "):");
        if (newTicketsQueue.isEmpty()) {
            System.out.println("  No new tickets.");
        } else {
            // Iterate through the queue without removing elements
            for (Ticket ticket : newTicketsQueue) {
                System.out.println("  " + ticket.toString());
            }
        }

        // Display In Progress Tickets List
        System.out.println("\nIn Progress Tickets (" + inProgressTicketsList.size() + "):");
        if (inProgressTicketsList.isEmpty()) {
            System.out.println("  No tickets in progress.");
        } else {
            for (Ticket ticket : inProgressTicketsList) {
                System.out.println("  " + ticket.toString());
            }
        }

        // Display Resolved Tickets List
        System.out.println("\nResolved Tickets (" + resolvedTicketsList.size() + "):");
        if (resolvedTicketsList.isEmpty()) {
            System.out.println("  No resolved tickets.");
        } else {
            for (Ticket ticket : resolvedTicketsList) {
                System.out.println("  " + ticket.toString());
            }
        }
    }

    // Method for a technician to pick up a ticket from the new queue
    // Throws custom exceptions for specific error conditions
    public void pickUpTicket() throws TicketNotFoundException, InvalidOperationException {
        System.out.println("\n--- Pick Up Ticket ---");

        // Input validation: Check if the queue is empty before asking for ID
        if (newTicketsQueue.isEmpty()) {
            throw new InvalidOperationException("No new tickets available to pick up.");
        }

        System.out.print("Enter the ID of the ticket to pick up: ");
        int ticketId;

        // Try-catch for reading integer input
        try {
            ticketId = scanner.nextInt();
        } catch (InputMismatchException e) {
            // Consume the invalid input line to prevent infinite loop
            scanner.nextLine();
            // Throw a custom exception indicating invalid input format
            throw new InvalidOperationException("Invalid input. Please enter a number for the ticket ID.");
        } finally {
             // Always consume the newline character left by nextInt()
             scanner.nextLine();
        }

        // Find and remove the ticket from the newTicketsQueue
        // Queues do not support efficient searching or removal by arbitrary element.
        // The most straightforward way using Queue methods (poll/offer) is to
        // iterate by polling and temporarily storing elements in a new queue.
        Ticket ticketToPickUp = null;
        Queue<Ticket> tempQueue = new LinkedList<>();
        boolean found = false;

        // Poll elements one by one from the original queue
        while (!newTicketsQueue.isEmpty()) {
            Ticket currentTicket = newTicketsQueue.poll(); // Remove from head
            if (currentTicket.getTicketId() == ticketId) {
                ticketToPickUp = currentTicket; // Found the ticket
                found = true;
                // Do NOT re-add to tempQueue, it's being removed from the queue
            } else {
                tempQueue.offer(currentTicket); // Re-add to temp queue if it's not the one we want
            }
        }

        // Restore the original queue with the elements that were not picked up
        while (!tempQueue.isEmpty()) {
            newTicketsQueue.offer(tempQueue.poll());
        }

        // If ticket was not found after checking all elements in the original queue
        if (!found) {
            throw new TicketNotFoundException("Ticket with ID " + ticketId + " not found in the new tickets queue.");
        }

        // If found, update status and move to in-progress list
        ticketToPickUp.setStatus(TicketStatus.IN_PROGRESS);
        inProgressTicketsList.add(ticketToPickUp); // Add to the in-progress list
        System.out.println("Ticket ID " + ticketId + " moved to In Progress.");
    }

    // Method for a technician to resolve a ticket from the in-progress list
    // Throws custom exceptions for specific error conditions
    public void resolveTicket() throws TicketNotFoundException, InvalidOperationException {
        System.out.println("\n--- Resolve Ticket ---");

        // Input validation: Check if the list is empty before asking for ID
        if (inProgressTicketsList.isEmpty()) {
            throw new InvalidOperationException("No tickets currently in progress to resolve.");
        }

        System.out.print("Enter the ID of the ticket to resolve: ");
        int ticketId;

         // Try-catch for reading integer input
         try {
            ticketId = scanner.nextInt();
        } catch (InputMismatchException e) {
             // Consume the invalid input line
            scanner.nextLine();
             // Throw a custom exception indicating invalid input format
            throw new InvalidOperationException("Invalid input. Please enter a number for the ticket ID.");
        } finally {
             // Always consume the newline character left by nextInt()
             scanner.nextLine();
        }

        // Find and remove the ticket from the inProgressTicketsList
        Ticket ticketToResolve = null;
        // Using an Iterator is the safe way to remove elements while iterating over a List
        Iterator<Ticket> iterator = inProgressTicketsList.iterator();
        while (iterator.hasNext()) {
            Ticket ticket = iterator.next();
            if (ticket.getTicketId() == ticketId) {
                ticketToResolve = ticket;
                iterator.remove(); // Remove the current element from the list
                break; // Ticket found and removed, exit loop
            }
        }

        // If ticket was not found in the in-progress list
        if (ticketToResolve == null) {
            throw new TicketNotFoundException("Ticket with ID " + ticketId + " not found in the in progress list.");
        }

        // If found, update status and move to resolved list
        ticketToResolve.setStatus(TicketStatus.RESOLVED);
        resolvedTicketsList.add(ticketToResolve); // Add to the resolved list
        System.out.println("Ticket ID " + ticketId + " moved to Resolved.");
    }

    // Display the main menu
    private void displayMenu() {
        System.out.println("\n--- Help Desk Menu ---");
        System.out.println("1. Add New Ticket");
        System.out.println("2. View All Tickets");
        System.out.println("3. Pick Up Ticket (from New)");
        System.out.println("4. Resolve Ticket (from In Progress)");
        System.out.println("0. Exit");
        System.out.println("----------------------");
    }

    // Main application loop
    public void run() {
        int choice = -1; // Initialize choice to a non-exit value

        // Class-wide try-catch wrapping the main operational loop
        // This catches any unexpected exceptions not handled by specific blocks
        // within the switch cases or method calls.
        try {
            do {
                displayMenu();
                System.out.print("Enter your choice: ");

                // Try-catch specifically for reading the menu choice integer
                try {
                    choice = scanner.nextInt();
                    // No scanner.nextLine() here, it's handled by the methods that read subsequent input,
                    // or by the catch block if nextInt fails.

                    // Use switch statement for flow control based on user choice
                    switch (choice) {
                        case 1:
                            addTicket();
                            break;
                        case 2:
                            viewTickets();
                            break;
                        case 3:
                            // Specific try-catch for pickUpTicket exceptions
                            try {
                                pickUpTicket();
                            } catch (TicketNotFoundException | InvalidOperationException e) {
                                System.err.println("Operation failed: " + e.getMessage());
                            }
                            break;
                        case 4:
                            // Specific try-catch for resolveTicket exceptions
                            try {
                                resolveTicket();
                            } catch (TicketNotFoundException | InvalidOperationException e) {
                                System.err.println("Operation failed: " + e.getMessage());
                            }
                            break;
                        case 0:
                            System.out.println("Exiting Help Desk System. Goodbye!");
                            break;
                        default:
                            // Handle invalid menu numbers
                            System.err.println("Invalid choice. Please enter a number between 0 and 4.");
                    }
                } catch (InputMismatchException e) {
                    // Handle non-integer input for the menu choice
                    System.err.println("Invalid input. Please enter a number.");
                    scanner.nextLine(); // Consume the invalid input line
                    choice = -1; // Reset choice to ensure the loop continues
                }

            } while (choice != 0); // Loop continues until user chooses 0

        } catch (Exception e) {
            // This broad catch block handles any exceptions that weren't caught
            // by the specific handlers inside the loop.
            System.err.println("An unexpected fatal error occurred:");
            e.printStackTrace(); // Print stack trace for debugging
            // Depending on the application, you might exit here or attempt recovery.
            // For this exam, simply reporting it is sufficient.
        } finally {
             // Ensure scanner is closed when the application finishes (exits the loop or crashes)
             if (scanner != null) {
                 scanner.close();
                 System.out.println("Scanner closed."); // Optional: confirmation message
             }
        }
    }

    // Main method to start the application
    public static void main(String[] args) {
        HelpDeskSystem system = new HelpDeskSystem();
        system.run(); // Start the main application loop
    }
}
