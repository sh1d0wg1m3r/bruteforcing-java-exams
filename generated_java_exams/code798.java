/*
 * Exam Question #798
 * Generated on: 2025-05-12 16:42:16
 * Generated by: Account 1
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Simple Task Management System
 * 
 * **Problem Description:**
 * 
 * You are tasked with building a simple command-line application for managing tasks. The system should allow users to add new tasks, complete the oldest pending task, and view lists of both pending and completed tasks.
 * 
 * **Requirements:**
 * 
 * Implement a Java program that fulfills the following requirements:
 * 
 * 1.  **Task Representation:** Create a class named `Task` to represent individual tasks. Each task should have a unique integer ID, a description (String), and a status (String, either "Pending" or "Completed"). Use proper encapsulation (private fields, public getters, and a method to mark the task as completed).
 * 2.  **Task Management:** Create a class named `TaskManager` that will manage the collections of tasks.
 *     *   It must use a `java.util.Queue` (specifically, a `LinkedList` implementation) to store tasks that are currently pending. Tasks should be completed in the order they were added (FIFO - First-In, First-Out).
 *     *   It must use a `java.util.ArrayList` to store tasks that have been completed.
 *     *   Use the `java.util.List` interface when declaring variables or returning collections where appropriate (e.g., in methods that return lists of tasks).
 *     *   Implement methods to add a new task to the pending queue, complete the next task from the pending queue (moving it to the completed list), and retrieve lists of pending and completed tasks.
 * 3.  **User Interface:** Implement a command-line interface in the `TaskManager` class's `main` method or a dedicated `run` method.
 *     *   Use `java.util.Scanner` to read user input from the console.
 *     *   Present a menu of options to the user.
 *     *   Use a `switch` statement to process the user's choice based on the menu options.
 * 4.  **Output:**
 *     *   Display the menu, task lists, and success messages (e.g., "Task added", "Completed task") using `System.out`.
 *     *   Display error messages (e.g., invalid input, no tasks to complete, empty description) using `System.err`.
 * 5.  **Error Handling:**
 *     *   Implement exception handling using `try-catch` blocks.
 *     *   Handle cases where the user enters non-integer input for the menu choice (`NumberFormatException`).
 *     *   Handle cases where the user tries to complete a task when the pending queue is empty.
 *     *   Handle cases where a task description is invalid (e.g., empty or null).
 * 6.  **Best Practices:**
 *     *   Use meaningful variable and method names.
 *     *   Include appropriate comments and documentation (e.g., Javadoc for classes and methods).
 *     *   Ensure input validation is performed where necessary (e.g., non-empty task description, valid menu choice).
 *     *   Structure the code clearly with separate classes for `Task` and `TaskManager`.
 * 
 * **Commands:**
 * 
 * The application should support the following commands via the menu:
 * *   `1`: Add Task (Prompts the user for a task description)
 * *   `2`: Complete Next Task (Completes the task at the front of the pending queue)
 * *   `3`: List All Tasks (Displays pending tasks and then completed tasks)
 * *   `0`: Exit (Terminates the application)
 * 
 * **Expected Output:**
 * 
 * The program should display a menu and respond to user input. Examples:
 * 
 * ```
 * --- Task Manager Menu ---
 * 1. Add Task
 * 2. Complete Next Task
 * 3. List All Tasks
 * 0. Exit
 * Enter your choice: 1
 * Enter task description: Write report
 * 
 * Task added: Write report
 * 
 * --- Task Manager Menu ---
 * ...
 * Enter your choice: 1
 * Enter task description: Review code
 * 
 * Task added: Review code
 * 
 * --- Task Manager Menu ---
 * ...
 * Enter your choice: 3
 * 
 * --- Pending Tasks ---
 * ID: 1, Description: "Write report", Status: Pending
 * ID: 2, Description: "Review code", Status: Pending
 * 
 * --- Completed Tasks ---
 * No completed tasks.
 * 
 * --- Task Manager Menu ---
 * ...
 * Enter your choice: 2
 * 
 * Completed task: Write report
 * 
 * --- Task Manager Menu ---
 * ...
 * Enter your choice: 3
 * 
 * --- Pending Tasks ---
 * ID: 2, Description: "Review code", Status: Pending
 * 
 * --- Completed Tasks ---
 * ID: 1, Description: "Write report", Status: Completed
 * 
 * --- Task Manager Menu ---
 * ...
 * Enter your choice: 2
 * 
 * Completed task: Review code
 * 
 * --- Task Manager Menu ---
 * ...
 * Enter your choice: 2
 * Error: No pending tasks to complete.
 * 
 * --- Task Manager Menu ---
 * ...
 * Enter your choice: invalid
 * Error: Invalid input. Please enter a number.
 * 
 * --- Task Manager Menu ---
 * ...
 * Enter your choice: 5
 * Error: Invalid choice. Please enter a number from the menu.
 * 
 * --- Task Manager Menu ---
 * ...
 * Enter your choice: 0
 * 
 * Exiting Task Manager. Goodbye!
 * ```
 * 
 * Your solution should provide the complete Java code for this application.
 *
 * EXPLANATION:
 * The solution implements a simple command-line Task Management System as requested, demonstrating the practical use of all specified Java components and adhering to best practices.
 * 
 * **Class Structure:**
 * 1.  **`Task` Class:** This class is a simple Plain Old Java Object (POJO) representing a single task. It encapsulates the task's `id`, `description`, and `status` as private fields, accessible via public getter methods. The `markAsCompleted()` method demonstrates changing the object's state. The constructor includes basic input validation for the description, throwing an `IllegalArgumentException` if it's null or empty. The `toString()` method provides a user-friendly representation for printing.
 * 2.  **`TaskManager` Class:** This is the core class that manages the collections of tasks and handles user interaction.
 *     *   It contains two main data structures: a `Queue<Task>` named `pendingTasksQueue` (implemented using `LinkedList`) for tasks awaiting completion, and a `List<Task>` named `completedTasksList` (implemented using `ArrayList`) for tasks that are finished.
 *     *   An `AtomicInteger` (`nextTaskId`) is used to generate unique sequential IDs for new tasks, which is a robust way to handle ID generation.
 *     *   Methods like `addTask()`, `completeNextTask()`, `getPendingTasks()`, and `getCompletedTasks()` manage the task collections and their states.
 *     *   The `run()` method contains the main application loop, handling the user interface logic.
 *     *   The `main()` method simply creates a `TaskManager` instance and calls its `run()` method to start the application.
 * 
 * **Usage of Required Components:**
 * *   **`Queue` (`java.util.Queue`)**: The `pendingTasksQueue` is declared as a `Queue` and instantiated as a `LinkedList`. This correctly models the requirement to process tasks in a FIFO manner (`completeNextTask` uses `poll()`).
 * *   **`ArrayList` (`java.util.ArrayList`)**: The `completedTasksList` is instantiated as an `ArrayList`. This is suitable for storing completed tasks where order of completion is maintained and elements can be listed easily.
 * *   **`List interface` (`java.util.List`)**: The `completedTasksList` is declared using the `List` interface type (`List<Task> completedTasksList`). Methods like `getPendingTasks()` and `getCompletedTasks()` also return `List<Task>`, promoting abstraction and allowing flexibility if the underlying implementation (`ArrayList`, `LinkedList`, etc.) needed to change in the future without affecting code that uses these methods. Copies (`new ArrayList<>(...)`) are returned to protect the internal collections from external modification.
 * *   **`Scanner` (`java.util.Scanner`)**: A `Scanner` object is used in the `run()` method to read user input from `System.in`.
 * *   **`Switch statement`**: A `switch` statement in the `run()` method is used to control the program flow based on the user's integer input, directing execution to the appropriate task management logic (add, complete, list, exit).
 * *   **`System.err`**: Used specifically for printing error messages, such as invalid menu input (`NumberFormatException`), invalid task description (`IllegalArgumentException`), or attempting to complete a task when the queue is empty. This separates error output from normal program output.
 * *   **`System.out`**: Used for all standard output, including the menu, prompts for input, success messages (task added, task completed), and listing the tasks.
 * *   **`Class-wide exception handling with try-catch blocks`**: The `run()` method wraps the main input processing and switch statement within a `try-catch` block. This handles `NumberFormatException` for invalid menu input. A general `catch (Exception e)` is included for robustness against other unexpected runtime errors. Additionally, a specific `try-catch` block is used around the `addTask` call within the switch to catch and report `IllegalArgumentException` thrown by the `Task` constructor if the description is invalid.
 * 
 * **Best Practices and Error Handling:**
 * *   **Encapsulation:** `Task` and `TaskManager` both have private fields and public methods to access/modify state, ensuring data integrity.
 * *   **Meaningful Names:** Variable names (`pendingTasksQueue`, `completedTasksList`, `nextTaskId`), method names (`addTask`, `completeNextTask`, `displayMenu`, `run`), and class names (`Task`, `TaskManager`) are descriptive.
 * *   **Comments and Documentation:** Javadoc comments are included for classes and methods, explaining their purpose, parameters, and return values. Inline comments explain specific implementation details or logic.
 * *   **Input Validation:** Input for the menu choice is validated using `Integer.parseInt` within a `try-catch` for `NumberFormatException`. Task description is validated in the `Task` constructor. The `completeNextTask` method explicitly checks if the `pendingTasksQueue` is empty before attempting to poll.
 * *   **Error Handling:** Specific error conditions (invalid input format, empty queue, invalid description) are checked and reported using `System.err`. The `try-catch` blocks ensure that the program doesn't crash due to common input errors or unexpected issues.
 * *   **Clean Code Structure:** The separation of concerns into `Task` and `TaskManager` classes makes the code modular and easier to understand. The `run` method encapsulates the main application logic loop.
 * 
 * This solution effectively combines the required Java components within a practical scenario, demonstrating good object-oriented design, collection usage, user interaction handling, and robust error management suitable for an advanced programming exam.
 */

import java.util.Queue;
import java.util.LinkedList;
import java.util.List;
import java.util.ArrayList;
import java.util.Scanner;
import java.util.concurrent.atomic.AtomicInteger; // For generating unique IDs

// --- Task Class ---
/**
 * Represents a single task in the system.
 * Demonstrates encapsulation and basic object state management.
 */
class Task { // Using default access for single-file solution
    private int id;
    private String description;
    private String status; // "Pending" or "Completed"

    private static final String STATUS_PENDING = "Pending";
    private static final String STATUS_COMPLETED = "Completed";

    /**
     * Constructs a new Task.
     * @param id The unique identifier for the task.
     * @param description A brief description of the task.
     * @throws IllegalArgumentException if description is null or empty.
     */
    public Task(int id, String description) {
        // Input validation for description
        if (description == null || description.trim().isEmpty()) {
            throw new IllegalArgumentException("Task description cannot be empty.");
        }
        this.id = id;
        this.description = description.trim();
        this.status = STATUS_PENDING; // Tasks start as pending
    }

    // --- Getters ---
    public int getId() {
        return id;
    }

    public String getDescription() {
        return description;
    }

    public String getStatus() {
        return status;
    }

    /**
     * Marks the task as completed.
     * Demonstrates state change within an object.
     */
    public void markAsCompleted() {
        this.status = STATUS_COMPLETED;
    }

    /**
     * Provides a string representation of the task.
     * @return Formatted string including ID, description, and status.
     */
    @Override
    public String toString() {
        // Using String.format for structured output
        return String.format("ID: %d, Description: \"%s\", Status: %s",
                             id, description, status);
    }
}

// --- TaskManager Class ---
/**
 * Manages a collection of tasks, separating pending and completed items.
 * Acts as the main application logic controller.
 * Demonstrates usage of Queue, List, ArrayList, Scanner, Switch,
 * System.out, System.err, and try-catch for exception handling.
 */
public class TaskManager { // Kept public as it contains the main method

    // Using LinkedList as a Queue implementation for FIFO behavior for pending tasks
    private Queue<Task> pendingTasksQueue;

    // Using ArrayList to store completed tasks, using List interface type
    private List<Task> completedTasksList;

    // Using AtomicInteger for generating unique task IDs, starting from 1.
    // Provides a simple, thread-safe way to get sequential IDs.
    private AtomicInteger nextTaskId;

    /**
     * Constructs a new TaskManager.
     * Initializes the task collections and the task ID counter.
     */
    public TaskManager() {
        this.pendingTasksQueue = new LinkedList<>(); // Queue implementation
        this.completedTasksList = new ArrayList<>(); // List implementation
        this.nextTaskId = new AtomicInteger(1); // Start IDs from 1
    }

    /**
     * Adds a new task to the pending queue.
     * A unique ID is automatically generated.
     * @param description The description of the task.
     * @throws IllegalArgumentException if description is null or empty (delegated to Task constructor).
     * Uses System.out for success message.
     */
    public void addTask(String description) {
        // Task constructor handles description validation, can throw IllegalArgumentException
        Task newTask = new Task(nextTaskId.getAndIncrement(), description);
        pendingTasksQueue.offer(newTask); // offer is preferred for queues, returns false on failure (unlikely for LinkedList)
        System.out.println(System.lineSeparator() + "Task added: " + newTask.getDescription()); // Normal output
    }

    /**
     * Completes the next task from the pending queue (FIFO).
     * Removes the task from the pending queue, marks it as completed,
     * and adds it to the completed tasks list.
     * Prints an error to System.err if the pending queue is empty.
     * Uses System.out for success message.
     */
    public void completeNextTask() {
        // Error handling: Check if queue is empty BEFORE attempting to poll
        if (pendingTasksQueue.isEmpty()) {
            System.err.println(System.lineSeparator() + "Error: No pending tasks to complete."); // Error output
            return; // Exit method gracefully if no tasks
        }

        // Retrieve and remove the head of the queue using poll()
        Task completedTask = pendingTasksQueue.poll();

        // Defensive check (poll returns null if empty, though we checked)
        if (completedTask != null) {
            completedTask.markAsCompleted(); // Change task state
            completedTasksList.add(completedTask); // Add to the completed list
            System.out.println(System.lineSeparator() + "Completed task: " + completedTask.getDescription()); // Normal output
        } else {
             // Should not happen with the isEmpty() check, but good practice
             System.err.println(System.lineSeparator() + "Unexpected error: Failed to retrieve task from queue."); // Error output
        }
    }

    /**
     * Gets a list view of all pending tasks currently in the queue.
     * Returns a copy to prevent external modification of the internal queue structure.
     * @return A new ArrayList containing elements from the pending queue, returned as a List.
     */
    public List<Task> getPendingTasks() {
        // Return a new ArrayList containing elements from the queue
        // This provides a List interface view and protects the internal Queue implementation.
        return new ArrayList<>(pendingTasksQueue); // Returns List, populated from Queue
    }

     /**
     * Gets a list of all completed tasks.
     * Returns a copy to prevent external modification of the internal list.
     * @return A new ArrayList containing completed tasks, returned as a List.
     */
    public List<Task> getCompletedTasks() {
        // Return a copy to prevent external modification of the internal list
        return new ArrayList<>(completedTasksList); // Returns List, populated from ArrayList
    }

    /**
     * Displays the main menu options to the user.
     * Uses System.out for displaying the menu.
     */
    private void displayMenu() {
        System.out.println(System.lineSeparator() + "--- Task Manager Menu ---"); // Normal output
        System.out.println("1. Add Task");
        System.out.println("2. Complete Next Task");
        System.out.println("3. List All Tasks");
        System.out.println("0. Exit");
        System.out.print("Enter your choice: "); // Normal output, prompt on the same line
    }

    /**
     * Runs the main application loop, handling user interaction.
     * Demonstrates Scanner for input, Switch for control flow,
     * and Try-Catch for class-wide exception handling (input parsing, general errors).
     */
    public void run() {
        Scanner scanner = new Scanner(System.in); // Scanner for user input
        boolean running = true;

        // Main application loop continues until 'running' is set to false
        while (running) {
            displayMenu();
            String inputLine = scanner.nextLine();
            int choice = -1; // Default to an invalid choice

            // Class-wide exception handling for potential errors during input processing
            try {
                // Input validation: Attempt to parse input string as an integer
                choice = Integer.parseInt(inputLine);

                // Control flow based on user input using a switch statement
                switch (choice) {
                    case 1: // Add Task
                        System.out.print("Enter task description: "); // Normal output prompt
                        String description = scanner.nextLine();
                        // Specific try-catch for potential validation error from addTask/Task constructor
                        try {
                            addTask(description);
                        } catch (IllegalArgumentException e) {
                            System.err.println(System.lineSeparator() + "Error adding task: " + e.getMessage()); // Error output
                        }
                        break; // Exit switch case 1

                    case 2: // Complete Next Task
                        completeNextTask(); // This method handles its own System.out/System.err
                        break; // Exit switch case 2

                    case 3: // List All Tasks
                        System.out.println(System.lineSeparator() + "--- Pending Tasks ---"); // Normal output header
                        List<Task> pending = getPendingTasks(); // Retrieve pending tasks as a List
                        if (pending.isEmpty()) {
                            System.out.println("No pending tasks."); // Normal output
                        } else {
                            // Iterate and print each pending task using its toString() method
                            for (Task task : pending) {
                                System.out.println(task); // Normal output
                            }
                        }

                        System.out.println(System.lineSeparator() + "--- Completed Tasks ---"); // Normal output header
                        List<Task> completed = getCompletedTasks(); // Retrieve completed tasks as a List
                        if (completed.isEmpty()) {
                            System.out.println("No completed tasks."); // Normal output
                        } else {
                             // Iterate and print each completed task using its toString() method
                             for (Task task : completed) {
                                System.out.println(task); // Normal output
                            }
                        }
                        break; // Exit switch case 3

                    case 0: // Exit
                        System.out.println(System.lineSeparator() + "Exiting Task Manager. Goodbye!"); // Normal output
                        running = false; // Set flag to terminate the loop
                        break; // Exit switch case 0

                    default: // Handle integer inputs that are not valid menu options
                        System.err.println(System.lineSeparator() + "Error: Invalid choice. Please enter a number from the menu."); // Error output
                        break; // Exit default case
                }

            } catch (NumberFormatException e) {
                // Catch if the input string cannot be parsed into an integer
                System.err.println(System.lineSeparator() + "Error: Invalid input. Please enter a number."); // Error output
            } catch (Exception e) {
                // Generic catch-all for any other unexpected runtime exceptions
                // This provides a layer of robustness to prevent the application from crashing.
                System.err.println(System.lineSeparator() + "An unexpected error occurred: " + e.getMessage()); // Error output
                // e.printStackTrace(System.err); // Optional: Uncomment for detailed debugging output to error stream
            }
        }

        scanner.close(); // Close the scanner to release system resources
    }

    /**
     * Main method to start the Task Manager application.
     * This is the entry point of the program.
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        TaskManager manager = new TaskManager();
        manager.run(); // Start the main application loop
    }
}
