/*
 * Exam Question #268
 * Generated on: 2025-05-11 22:47:16
 * Generated by: Account 1
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Event Management System with Waitlist
 * 
 * **Problem Description:**
 * 
 * You are tasked with developing a simple Event Management System for a small venue with limited capacity. The system should allow users to register attendees, manage a waiting list when the event is full, and process individuals from the waiting list as spots become available.
 * 
 * Your program must be interactive, using console input and output. It should be robust, handling various scenarios including invalid input and the event being at capacity.
 * 
 * **Requirements:**
 * 
 * 1.  **Data Structures:**
 *     *   Maintain a list of registered attendees. Use the `List` interface and an `ArrayList` implementation.
 *     *   Maintain a waiting list for people who couldn't register because the event was full. Use the `Queue` interface.
 *     *   Define a fixed maximum capacity for the event.
 * 
 * 2.  **Functionality:**
 *     *   **Add Attendee:** Allow a user to enter a name. If the event is not full, add the name to the registered attendees list. If the event is full, add the name to the waiting list. Provide appropriate messages (`System.out` for success, `System.err` for failure/waitlist addition).
 *     *   **Process Waitlist:** Allow a user to trigger processing one person from the waiting list. If the waiting list is not empty and there is available capacity, move the first person from the waiting list to the registered attendees list. If the waitlist is empty or the event is still full, provide an error message (`System.err`).
 *     *   **View Attendees:** Display the list of all registered attendees.
 *     *   **View Waiting List:** Display the list of people currently on the waiting list.
 *     *   **View Status:** Display the current number of registered attendees, the number of people on the waiting list, and the remaining available capacity.
 *     *   **Exit:** Terminate the program.
 * 
 * 3.  **User Interface:**
 *     *   Present a menu of options (Add Attendee, Process Waitlist, View Attendees, View Waiting List, View Status, Exit).
 *     *   Use `Scanner` to read the user's menu choice and attendee names.
 *     *   Use a `switch` statement to handle the different menu options.
 * 
 * 4.  **Error Handling & Validation:**
 *     *   Implement input validation to ensure the user enters valid integers for menu choices. Handle non-integer input gracefully using `try-catch`. This should be handled in a way that allows the program to continue.
 *     *   Handle cases where the user tries to add an attendee with an empty name.
 *     *   Use `System.err` to print error messages (e.g., invalid menu choice, event sold out, waitlist empty, invalid name).
 *     *   Use `System.out` for all normal output (menu, lists, status, success messages).
 *     *   Implement appropriate `try-catch` blocks for potential exceptions, particularly around input operations, demonstrating class-wide (or method-level within the main execution flow) exception handling.
 * 
 * 5.  **Code Structure & Best Practices:**
 *     *   Create a separate class (e.g., `EventManager`) to encapsulate the event data (capacity, attendees, waitlist) and the core logic (adding, processing, viewing).
 *     *   Use private fields and public methods for encapsulation.
 *     *   Use meaningful variable and method names.
 *     *   Include comments to explain complex parts of the code.
 * 
 * **Event Capacity:** Set the maximum capacity to a small number, like 5, for testing purposes.
 * 
 * **Expected Output:**
 * 
 * The program should display a menu, prompt for input, and provide output based on the chosen action. Error messages should be clearly distinguishable using `System.err`. Lists should be displayed in a readable format.
 * 
 * *Example Interaction Snippet:*
 * 
 * ```
 * --- Event Management Menu ---
 * 1. Add Attendee
 * 2. Process Waitlist
 * 3. View Attendees
 * 4. View Waiting List
 * 5. View Status
 * 6. Exit
 * Enter your choice: 1
 * Enter attendee name: Alice
 * Alice registered successfully!
 * Enter your choice: 1
 * Enter attendee name: Bob
 * Bob registered successfully!
 * Enter your choice: 5
 * --- Event Status ---
 * Registered Attendees: 2
 * Waiting List Size: 0
 * Available Capacity: 3
 * Enter your choice: 1
 * Enter attendee name: Charlie
 * Charlie registered successfully!
 * Enter your choice: 1
 * Enter attendee name: David
 * David registered successfully!
 * Enter your choice: 1
 * Enter attendee name: Eve
 * Eve registered successfully!
 * Enter your choice: 5
 * --- Event Status ---
 * Registered Attendees: 5
 * Waiting List Size: 0
 * Available Capacity: 0
 * Enter your choice: 1
 * Enter attendee name: Frank
 * Event is full. Frank added to waiting list.
 * Enter your choice: 5
 * --- Event Status ---
 * Registered Attendees: 5
 * Waiting List Size: 1
 * Available Capacity: 0
 * Enter your choice: 3
 * --- Registered Attendees ---
 * Alice
 * Bob
 * Charlie
 * David
 * Eve
 * Enter your choice: 4
 * --- Waiting List ---
 * Frank
 * Enter your choice: 2
 * Processing waitlist...
 * Frank moved from waitlist to registered attendees.
 * Enter your choice: 5
 * --- Event Status ---
 * Registered Attendees: 6
 * Waiting List Size: 0
 * Available Capacity: -1 (Note: Capacity check should prevent exceeding initial capacity, this is just an example if capacity logic was flawed. Correct logic should prevent this.)
 * ```
 * *(Self-correction: The example output shows capacity going negative. The actual implementation must correctly prevent adding beyond capacity from the waitlist processing unless capacity *increased*. The prompt implies processing from waitlist happens when spots *open up*. Let's assume for this problem, processing waitlist means filling a spot that became available, perhaps implicitly by someone cancelling or just by triggering the move when capacity > 0. The simplest interpretation for the exam is: if current attendees < initial capacity AND waitlist is not empty, move one. Let's adjust the example expectation slightly to reflect this simpler logic.)*
 * 
 * *Revised Example Interaction Snippet:*
 * 
 * ```
 * ... (previous successful additions up to capacity 5)
 * Enter your choice: 5
 * --- Event Status ---
 * Registered Attendees: 5
 * Waiting List Size: 0
 * Available Capacity: 0
 * Enter your choice: 1
 * Enter attendee name: Frank
 * Event is full. Frank added to waiting list.
 * Enter your choice: 5
 * --- Event Status ---
 * Registered Attendees: 5
 * Waiting List Size: 1
 * Available Capacity: 0
 * Enter your choice: 2
 * Processing waitlist...
 * Error: Cannot process waitlist. Event is still full or waitlist is empty.
 * Enter your choice: 6
 * Exiting Event Management System.
 * ```
 * *(This revised example better reflects the likely implementation where waitlist processing only happens if capacity allows, which it won't if the event is already full. A more complex version might involve cancellations creating space, but for an exam, this simplified flow is sufficient.)*
 * 
 * **Evaluation:**
 * 
 * Your solution will be evaluated based on:
 * *   Correct usage of `Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.err`, `System.out`, and `try-catch`.
 * *   Correct implementation of the required functionality (adding, processing waitlist, viewing, status).
 * *   Robustness through input validation and error handling.
 * *   Adherence to best practices (encapsulation, naming, comments, clean structure).
 * *   Meeting all specified requirements.
 *
 * EXPLANATION:
 * This solution implements the Event Management System as described in the problem, demonstrating the required Java concepts.
 * 
 * 1.  **`EventManager` Class:**
 *     *   Encapsulates the event's state (`capacity`, `attendees`, `waitingList`) using `private` fields.
 *     *   The `attendees` list is declared as `List<String>` and initialized with `new ArrayList<>()`. This demonstrates programming to the interface (`List`) while using a concrete implementation (`ArrayList`). `ArrayList` is suitable here because we primarily add, iterate, and access elements by index (implicitly during iteration).
 *     *   The `waitingList` is declared as `Queue<String>` and initialized with `new LinkedList<>()`. `LinkedList` is a common implementation for `Queue` as it provides efficient additions and removals from both ends, which is suitable for queue operations (`offer` and `poll`).
 *     *   Public methods (`addAttendee`, `processWaitlist`, `getAttendees`, etc.) provide controlled access to the event data and logic, adhering to encapsulation principles.
 *     *   `addAttendee` checks capacity and adds to the appropriate list/queue. It also includes input validation for the name, throwing an `IllegalArgumentException` if the name is empty.
 *     *   `processWaitlist` uses `waitingList.poll()` to retrieve and remove the head of the queue and `attendees.add()` to add it to the list, but only if there's capacity and the waitlist isn't empty.
 *     *   Helper methods like `getTotalAttendees`, `getWaitlistSize`, and `getAvailableCapacity` provide useful status information.
 * 
 * 2.  **`EventSystem` Class (Main Application):**
 *     *   Contains the `main` method, the entry point of the program.
 *     *   Creates a `Scanner` for reading user input and an `EventManager` instance.
 *     *   The main program logic runs inside a `while(running)` loop.
 *     *   **`try-catch` for Input Handling:** A `try-catch (InputMismatchException e)` block is placed around `scanner.nextInt()` within the loop. This specifically catches non-integer input, prints an error message to `System.err`, consumes the invalid input using `scanner.next()`, and uses `continue` to restart the loop, prompting the user again without crashing. The `finally` block ensures `scanner.nextLine()` is always called to consume the newline, preventing issues in subsequent `scanner.nextLine()` calls. This demonstrates handling specific exceptions related to input.
 *     *   **Class-wide `try-catch`:** The entire `while` loop is wrapped in a broader `try-catch (Exception e)` block. While the input handling is more specific, this outer block serves as an example of a higher-level handler that would catch any *other* unexpected runtime exceptions occurring within the main execution flow, preventing the program from abruptly terminating and providing a general error message via `System.err`. For this specific simple program, `InputMismatchException` is the most likely, but this structure shows the principle of layered exception handling.
 *     *   **`switch` Statement:** The program uses a `switch` statement on the user's valid integer choice to direct execution to the corresponding functionality (add, process, view, status, exit).
 *     *   **`System.out` and `System.err`:** `System.out.println` is used for displaying the menu, success messages, lists, and status information. `System.err.println` is specifically used for printing error conditions, such as invalid input, the event being full when adding, the waitlist being empty when processing, or an empty name being entered.
 *     *   **Input Validation:** Checks for empty attendee names are performed in the `addAttendee` method of the `EventManager`.
 *     *   **Scanner Closing:** The `scanner.close()` method is called in the `finally` block of the outer `try-catch` to ensure the scanner resource is released when the program finishes (either by exiting the loop or due to an unexpected exception).
 * 
 * This solution effectively integrates all the required components within a practical scenario, showcasing proper object-oriented design, data structure usage, input handling, and error management.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.InputMismatchException;

// Class to manage the event data and logic
class EventManager {
    private int capacity;
    private List<String> attendees;
    private Queue<String> waitingList;

    public EventManager(int capacity) {
        if (capacity <= 0) {
            // Although not explicitly required to throw, good practice to validate constructor input
            // For this exam, we assume valid capacity is passed from main.
            System.err.println("Warning: Event capacity should be positive.");
            this.capacity = 1; // Default to 1 if invalid
        } else {
            this.capacity = capacity;
        }
        this.attendees = new ArrayList<>(); // Use ArrayList for registered attendees
        this.waitingList = new LinkedList<>(); // Use LinkedList for Queue implementation
    }

    /**
     * Attempts to add an attendee. Adds to attendees list if capacity available,
     * otherwise adds to waiting list.
     * @param name The name of the attendee.
     * @return true if added to attendees, false if added to waiting list.
     * @throws IllegalArgumentException if name is empty or null.
     */
    public boolean addAttendee(String name) {
        if (name == null || name.trim().isEmpty()) {
            throw new IllegalArgumentException("Attendee name cannot be empty.");
        }
        String trimmedName = name.trim();

        if (attendees.size() < capacity) {
            attendees.add(trimmedName);
            return true; // Added to attendees
        } else {
            waitingList.offer(trimmedName); // Add to the end of the queue
            return false; // Added to waiting list
        }
    }

    /**
     * Attempts to move one person from the waiting list to the attendees list
     * if there is available capacity.
     * @return true if a person was moved, false otherwise (waitlist empty or event full).
     */
    public boolean processWaitlist() {
        if (waitingList.isEmpty()) {
            return false; // Waitlist is empty
        }

        if (attendees.size() < capacity) {
            String nextAttendee = waitingList.poll(); // Remove from the front of the queue
            if (nextAttendee != null) { // poll() can return null if queue was empty (check defensive)
                attendees.add(nextAttendee);
                return true; // Person moved
            }
        }
        return false; // Event is full or waitlist poll failed unexpectedly
    }

    /**
     * Gets the list of registered attendees.
     * @return A List of attendee names.
     */
    public List<String> getAttendees() {
        return attendees; // Return the internal list (for simplicity in exam)
    }

    /**
     * Gets the list of people on the waiting list.
     * @return A Queue of waiting attendee names.
     */
    public Queue<String> getWaitingList() {
        return waitingList; // Return the internal queue (for simplicity in exam)
    }

    /**
     * Gets the number of currently registered attendees.
     * @return The number of attendees.
     */
    public int getTotalAttendees() {
        return attendees.size();
    }

    /**
     * Gets the number of people on the waiting list.
     * @return The size of the waiting list.
     */
    public int getWaitlistSize() {
        return waitingList.size();
    }

    /**
     * Gets the remaining available capacity for the event.
     * @return The number of available spots. Can be negative if capacity was somehow exceeded
     * (though logic should prevent this).
     */
    public int getAvailableCapacity() {
        return capacity - attendees.size();
    }

    /**
     * Gets the maximum capacity of the event.
     * @return The event capacity.
     */
    public int getCapacity() {
        return capacity;
    }
}

// Main application class
public class EventSystem {

    private static final int EVENT_CAPACITY = 5; // Fixed capacity for the event

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        EventManager eventManager = new EventManager(EVENT_CAPACITY);
        boolean running = true;

        // Class-wide exception handling example for input within the main loop
        // This try-catch structure encapsulates the main program logic that relies on scanner input
        // More specific try-catches are used where appropriate (e.g., around scanner.nextInt())
        try {
            while (running) {
                printMenu();
                int choice = -1; // Default to invalid choice

                System.out.print("Enter your choice: ");
                try {
                    choice = scanner.nextInt();
                } catch (InputMismatchException e) {
                    System.err.println("Invalid input. Please enter a number.");
                    scanner.next(); // Consume the invalid input to prevent infinite loop
                    continue; // Skip to the next iteration
                } finally {
                     scanner.nextLine(); // Consume the newline character left by nextInt()
                }

                switch (choice) {
                    case 1: // Add Attendee
                        System.out.print("Enter attendee name: ");
                        String name = scanner.nextLine();
                        try {
                            boolean addedToAttendees = eventManager.addAttendee(name);
                            if (addedToAttendees) {
                                System.out.println(name.trim() + " registered successfully!");
                            } else {
                                System.err.println("Event is full. " + name.trim() + " added to waiting list.");
                            }
                        } catch (IllegalArgumentException e) {
                            System.err.println("Error: " + e.getMessage());
                        }
                        break;

                    case 2: // Process Waitlist
                        System.out.println("Processing waitlist...");
                        boolean processed = eventManager.processWaitlist();
                        if (processed) {
                            System.out.println("One person moved from waitlist to registered attendees.");
                        } else {
                            System.err.println("Error: Cannot process waitlist. Event is still full or waitlist is empty.");
                        }
                        break;

                    case 3: // View Attendees
                        List<String> attendees = eventManager.getAttendees();
                        System.out.println("--- Registered Attendees (" + attendees.size() + "/" + eventManager.getCapacity() + ") ---");
                        if (attendees.isEmpty()) {
                            System.out.println("No attendees registered yet.");
                        } else {
                            for (int i = 0; i < attendees.size(); i++) {
                                System.out.println((i + 1) + ". " + attendees.get(i));
                            }
                        }
                        break;

                    case 4: // View Waiting List
                        Queue<String> waitingList = eventManager.getWaitingList();
                        System.out.println("--- Waiting List (" + waitingList.size() + " people) ---");
                        if (waitingList.isEmpty()) {
                            System.out.println("Waiting list is empty.");
                        } else {
                            // Iterate without removing elements
                            int i = 0;
                            for (String waitingName : waitingList) {
                                System.out.println((i + 1) + ". " + waitingName);
                                i++;
                            }
                        }
                        break;

                    case 5: // View Status
                        System.out.println("--- Event Status ---");
                        System.out.println("Registered Attendees: " + eventManager.getTotalAttendees());
                        System.out.println("Waiting List Size: " + eventManager.getWaitlistSize());
                        System.out.println("Available Capacity: " + eventManager.getAvailableCapacity());
                        break;

                    case 6: // Exit
                        running = false;
                        System.out.println("Exiting Event Management System.");
                        break;

                    default:
                        System.err.println("Invalid choice. Please enter a number between 1 and 6.");
                }
                System.out.println(); // Add a newline for better readability between actions
            }
        } catch (Exception e) {
            // This catch block handles any other unexpected exceptions that might occur
            // within the main loop's execution, acting as a broader handler.
            System.err.println("An unexpected error occurred: " + e.getMessage());
            e.printStackTrace(); // Print stack trace for debugging
        } finally {
            scanner.close(); // Close the scanner when the program exits
        }
    }

    private static void printMenu() {
        System.out.println("--- Event Management Menu ---");
        System.out.println("1. Add Attendee");
        System.out.println("2. Process Waitlist");
        System.out.println("3. View Attendees");
        System.out.println("4. View Waiting List");
        System.out.println("5. View Status");
        System.out.println("6. Exit");
    }
}
