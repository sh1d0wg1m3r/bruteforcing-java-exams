/*
 * Exam Question #867
 * Generated on: 2025-05-12 16:52:36
 * Generated by: Account 2
 * 
 * QUESTION:
 * **Complex Java Programming Task: Help Desk Ticket Management System**
 * 
 * **Scenario:**
 * You are tasked with building a simple command-line based Help Desk Ticket Management System. This system will manage support tickets, allowing users to submit new issues, process existing ones, and view the status of tickets.
 * 
 * **Objective:**
 * Implement a Java program that simulates this Help Desk system, demonstrating your understanding of core Java collections, control flow, input/output, and exception handling.
 * 
 * **Requirements:**
 * 
 * 1.  **Ticket Representation:**
 *     *   Create a public class named `Ticket`.
 *     *   It must have two private fields: `int id` (for a unique ticket identifier) and `String description` (for the issue details).
 *     *   Include a public constructor `Ticket(int id, String description)` to initialize these fields.
 *     *   Provide public getter methods `getId()` and `getDescription()`.
 *     *   Override the `toString()` method to return a formatted string representing the ticket (e.g., "Ticket [ID=X, Description='Y']").
 * 
 * 2.  **System Management:**
 *     *   Create a public class named `HelpDeskSystem`.
 *     *   This class must manage the tickets using the following collections:
 *         *   A `java.util.Queue<Ticket>` named `pendingTickets` to store tickets waiting to be processed. Tickets should be processed in First-In-First-Out (FIFO) order.
 *         *   A `java.util.List<Ticket>` named `completedTickets` to store tickets that have been processed. This list should be implemented using `java.util.ArrayList`.
 *     *   Include a private field `int nextTicketId` initialized to 1, used to assign unique IDs to new tickets.
 *     *   Implement the following public methods within `HelpDeskSystem`:
 *         *   `submitTicket(String description)`: Creates a new `Ticket` with the next available ID, adds it to the `pendingTickets` queue, and increments `nextTicketId`. It must validate that the description is not null or empty/whitespace.
 *         *   `processNextTicket()`: Removes the ticket at the front of the `pendingTickets` queue and adds it to the `completedTickets` list. It should return the processed `Ticket` object, or `null` if the pending queue is empty.
 *         *   `listPendingTickets()`: Prints details of all tickets currently in the `pendingTickets` queue to `System.out`. Indicate if the queue is empty.
 *         *   `listCompletedTickets()`: Prints details of all tickets in the `completedTickets` list to `System.out`. Indicate if the list is empty.
 * 
 * 3.  **User Interface & Control Flow:**
 *     *   Implement a public method `run()` within `HelpDeskSystem` (or a separate main class) that provides the command-line interface.
 *     *   Use a `java.util.Scanner` to read user input from `System.in`.
 *     *   Display a menu with the following options:
 *         1.  Submit New Ticket
 *         2.  Process Next Ticket
 *         3.  List Pending Tickets
 *         4.  List Completed Tickets
 *         5.  Exit
 *     *   Use a `switch` statement to handle the user's selected command.
 *     *   The interface should run in a loop until the user chooses the Exit option.
 * 
 * 4.  **Input/Output and Error Handling:**
 *     *   Use `System.out` for displaying the menu, prompts, successful operation messages, and ticket lists.
 *     *   Use `System.err` for *all* error messages, including:
 *         *   Invalid command input (non-numeric or out of range).
 *         *   Error when submitting a ticket with an empty description.
 *         *   Error when attempting to process a ticket from an empty pending queue.
 *     *   Implement exception handling:
 *         *   Use a `try-catch` block around reading the user's command to handle `java.util.InputMismatchException` if the user enters non-numeric input. Ensure the scanner is cleared in this case to prevent an infinite loop.
 *         *   Implement **class-wide exception handling** by wrapping the main application loop within the `run()` method (or the main method) in a `try-catch(Exception e)` block. If any unexpected exception occurs that is not handled by specific catches, print a general error message including the exception's message to `System.err`.
 *         *   Ensure the `Scanner` resource is closed properly when the application exits.
 * 
 * 5.  **Best Practices:**
 *     *   Adhere to proper encapsulation (private fields, public methods).
 *     *   Use meaningful names for classes, variables, and methods.
 *     *   Include appropriate comments (especially Javadoc for classes and methods) explaining the code.
 *     *   Validate user input as specified.
 * 
 * **Expected Output Format:**
 * The program should interact with the user via the console, displaying menus and messages clearly using `System.out` for normal flow and `System.err` for errors, following the example flow provided in the thought process.
 * 
 * **Challenge:**
 * The challenge lies in correctly integrating the required Java components (`Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.err`, `System.out`, `try-catch`), managing the state of tickets moving between collections, implementing robust input validation and error handling (including the class-wide catch), all within a clean and well-structured program.
 *
 * EXPLANATION:
 * The provided solution implements the Help Desk Ticket Management System as described in the exam question, fulfilling all requirements and demonstrating the specified Java concepts and best practices.
 * 
 * **Key Concepts Demonstrated:**
 * 
 * 1.  **Object-Oriented Programming:** The system is structured around two classes: `Ticket` (representing a data entity) and `HelpDeskSystem` (representing the system logic and state). Encapsulation is used with private fields and public getters/methods.
 * 2.  **Java Collections Framework:**
 *     *   `java.util.Queue`: The `pendingTickets` field is declared as a `Queue` and implemented using `java.util.LinkedList`. This correctly models the requirement for tickets to be processed in FIFO order. Methods like `offer()` (to add) and `poll()` (to remove from the head) are used.
 *     *   `java.util.List`: The `completedTickets` field is declared using the `List` interface type.
 *     *   `java.util.ArrayList`: The `completedTickets` list is specifically implemented using `java.util.ArrayList`, demonstrating the use of a concrete implementation class via its interface. Methods like `add()` and iteration are used.
 * 3.  **Input/Output:** `java.util.Scanner` is used to read user input from the console (`System.in`). `System.out` is used for all standard output (menu, prompts, success messages, lists), while `System.err` is exclusively used for printing error messages, as required.
 * 4.  **Control Flow:**
 *     *   A `while` loop in the `run()` method keeps the application running until the exit condition is met.
 *     *   A `switch` statement is effectively used to dispatch control based on the user's numeric command input, providing a clean structure for handling menu options.
 * 5.  **Exception Handling:**
 *     *   **Specific Catch:** An inner `try-catch(InputMismatchException e)` block is used within the main loop to specifically handle cases where the user enters non-integer input when a number is expected for the command. It includes `scanner.nextLine()` to consume the invalid input and prevent an infinite loop.
 *     *   **Operational Error Handling:** The `processNextTicket()` method returns `null` if the queue is empty. The `run()` method checks for this `null` return value and prints an informative error message to `System.err`, fulfilling the requirement to handle the empty queue case gracefully using `System.err`. The `submitTicket` method validates the description and prints an error to `System.err` if invalid.
 *     *   **General/Class-Wide Catch:** An outer `try-catch(Exception e)` block wraps the entire `while` loop in the `run()` method. This serves as a class-wide handler for any unexpected exceptions that might occur during the program's execution and are not caught by more specific handlers. It prints a general error message to `System.err`.
 *     *   **Resource Management:** A `finally` block ensures that the `Scanner` object is closed properly when the `run()` method finishes, releasing the system resource.
 * 6.  **Best Practices:**
 *     *   **Encapsulation:** Fields in `Ticket` and `HelpDeskSystem` are private, accessed or modified via public methods.
 *     *   **Naming Conventions:** Meaningful names like `pendingTickets`, `processNextTicket`, `listCompletedTickets`, `nextTicketId` are used, improving code readability.
 *     *   **Comments:** Javadoc comments are included for classes and methods, explaining their purpose, parameters, and return values. Inline comments clarify specific logic points.
 *     *   **Input Validation:** The `submitTicket` method explicitly checks if the provided description is empty or null before creating a ticket.
 *     *   **Clean Structure:** The code is organized into logical classes (`Ticket` and `HelpDeskSystem`), and the `run()` method encapsulates the main application logic and user interaction loop.
 * 
 * This solution effectively demonstrates the required Java components and programming practices within a practical, albeit simplified, real-world scenario, providing a solid basis for evaluation in an exam setting.
 */

import java.util.Queue;
import java.util.LinkedList;
import java.util.List;
import java.util.ArrayList;
import java.util.Scanner;
import java.util.InputMismatchException;

/**
 * Represents a single help desk support ticket.
 */
class Ticket {
    private int id;
    private String description;

    /**
     * Constructs a new Ticket.
     *
     * @param id The unique identifier for the ticket.
     * @param description The description of the issue.
     */
    public Ticket(int id, String description) {
        this.id = id;
        this.description = description;
    }

    /**
     * Gets the ticket ID.
     *
     * @return The ticket ID.
     */
    public int getId() {
        return id;
    }

    /**
     * Gets the ticket description.
     *
     * @return The ticket description.
     */
    public String getDescription() {
        return description;
    }

    /**
     * Returns a string representation of the Ticket.
     *
     * @return A formatted string for the ticket.
     */
    @Override
    public String toString() {
        return "Ticket [ID=" + id + ", Description='" + description + "']";
    }
}

/**
 * Manages the collection of pending and completed help desk tickets.
 */
public class HelpDeskSystem {
    // Queue to hold tickets waiting to be processed (FIFO)
    private Queue<Ticket> pendingTickets;
    // List to hold tickets that have been completed
    private List<Ticket> completedTickets;
    // Counter for assigning unique ticket IDs
    private int nextTicketId;

    /**
     * Constructs a new HelpDeskSystem, initializing collections and the ticket ID counter.
     */
    public HelpDeskSystem() {
        // LinkedList implements the Queue interface
        this.pendingTickets = new LinkedList<>();
        // ArrayList implements the List interface
        this.completedTickets = new ArrayList<>();
        this.nextTicketId = 1;
    }

    /**
     * Submits a new ticket to the system.
     * Validates that the description is not empty.
     *
     * @param description The description of the new ticket.
     */
    public void submitTicket(String description) {
        if (description == null || description.trim().isEmpty()) {
            // Use System.err for validation errors
            System.err.println("Error: Ticket description cannot be empty.");
            return;
        }
        // Create a new ticket and add it to the pending queue
        Ticket newTicket = new Ticket(nextTicketId++, description.trim());
        pendingTickets.offer(newTicket); // offer is a Queue method to add an element
        System.out.println("Ticket submitted: " + newTicket); // Use System.out for success messages
    }

    /**
     * Processes the next available ticket from the pending queue.
     * Moves the ticket from the pending queue to the completed list.
     *
     * @return The processed Ticket, or null if the pending queue is empty.
     */
    public Ticket processNextTicket() {
        // Check if the queue is empty before attempting to poll
        if (pendingTickets.isEmpty()) {
            // Return null to indicate no ticket was processed
            return null;
        }
        // poll() retrieves and removes the head of the queue
        Ticket processedTicket = pendingTickets.poll();
        // Add the processed ticket to the completed list
        completedTickets.add(processedTicket);
        return processedTicket;
    }

    /**
     * Displays all tickets currently in the pending queue.
     */
    public void listPendingTickets() {
        System.out.println("\n--- Pending Tickets ---"); // Use System.out for normal output
        if (pendingTickets.isEmpty()) {
            System.out.println("No pending tickets.");
        } else {
            // Iterate through the queue without removing elements
            int count = 1;
            for (Ticket ticket : pendingTickets) {
                System.out.println(count++ + ". " + ticket);
            }
        }
        System.out.println("----------------------");
    }

    /**
     * Displays all tickets in the completed list.
     */
    public void listCompletedTickets() {
        System.out.println("\n--- Completed Tickets ---"); // Use System.out for normal output
        if (completedTickets.isEmpty()) {
            System.out.println("No completed tickets.");
        } else {
            // Iterate through the list
            int count = 1;
            for (Ticket ticket : completedTickets) {
                System.out.println(count++ + ". " + ticket);
            }
        }
        System.out.println("------------------------");
    }

    /**
     * Prints the main menu options to the console.
     */
    private void printMenu() {
        System.out.println("\n--- Help Desk Menu ---");
        System.out.println("1. Submit New Ticket");
        System.out.println("2. Process Next Ticket");
        System.out.println("3. List Pending Tickets");
        System.out.println("4. List Completed Tickets");
        System.out.println("5. Exit");
        System.out.println("----------------------");
    }

    /**
     * Runs the main application loop, handling user interaction and commands.
     * Includes input validation and exception handling.
     */
    public void run() {
        Scanner scanner = new Scanner(System.in);
        boolean running = true;

        // Class-wide exception handling for the main application loop
        try {
            while (running) {
                printMenu();
                System.out.print("Enter command: "); // Use System.out for prompts

                try {
                    // Attempt to read the command as an integer
                    int command = scanner.nextInt();
                    scanner.nextLine(); // Consume the rest of the line (the newline character)

                    // Use a switch statement for command processing
                    switch (command) {
                        case 1: // Submit Ticket
                            System.out.print("Enter ticket description: ");
                            String description = scanner.nextLine();
                            submitTicket(description); // Call the method to submit
                            break;
                        case 2: // Process Next Ticket
                            System.out.println("Attempting to process next ticket...");
                            Ticket processed = processNextTicket(); // Call the method to process
                            if (processed != null) {
                                System.out.println("Processed ticket: " + processed); // Success message
                            } else {
                                // Use System.err for operational errors (like empty queue)
                                System.err.println("Error: No pending tickets to process.");
                            }
                            break;
                        case 3: // List Pending Tickets
                            listPendingTickets(); // Call the method to list pending
                            break;
                        case 4: // List Completed Tickets
                            listCompletedTickets(); // Call the method to list completed
                            break;
                        case 5: // Exit
                            System.out.println("Exiting Help Desk System. Goodbye!");
                            running = false; // Set flag to exit the loop
                            break;
                        default:
                            // Use System.err for invalid command input
                            System.err.println("Error: Invalid command. Please enter a number between 1 and 5.");
                    }
                } catch (InputMismatchException e) {
                    // Handle non-integer input for the command
                    System.err.println("Error: Invalid input. Please enter a number.");
                    scanner.nextLine(); // IMPORTANT: Consume the invalid input to prevent infinite loop
                } catch (Exception e) {
                     // Catch any other unexpected exceptions that occur during a command's execution
                    System.err.println("An unexpected error occurred during command processing: " + e.getMessage());
                    // e.printStackTrace(); // Uncomment for debugging if needed
                }
            }
        } catch (Exception mainLoopException) {
            // This catch block handles any exceptions that escape the inner try-catch,
            // providing a class-wide handling mechanism for critical errors.
            System.err.println("An unexpected critical error occurred in the main loop: " + mainLoopException.getMessage());
            mainLoopException.printStackTrace(); // Print stack trace for critical errors
        } finally {
            // Ensure the scanner is closed regardless of how the loop exits
            if (scanner != null) {
                scanner.close();
                System.out.println("Scanner closed. System shutdown complete.");
            }
        }
    }

    /**
     * Main method to start the Help Desk System application.
     *
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        HelpDeskSystem system = new HelpDeskSystem();
        system.run(); // Start the application loop
    }
}
