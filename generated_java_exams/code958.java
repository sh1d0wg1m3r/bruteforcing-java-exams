/*
 * Exam Question #958
 * Generated on: 2025-05-12 17:05:13
 * Generated by: Account 3
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Warehouse Inventory Processor
 * 
 * **Scenario:**
 * 
 * You are tasked with developing a simple command-line application to simulate a basic warehouse inventory system. The system needs to manage incoming shipments of items and track the current inventory in the warehouse. Items arrive in shipments and are placed in a processing queue. A warehouse worker then processes items one by one from the queue, adding them to the main inventory.
 * 
 * **Your Task:**
 * 
 * Create a Java program called `WarehouseSystem` that fulfills the following requirements:
 * 
 * 1.  **Represent Items:**
 *     *   Create a class `ShipmentItem` with private fields for `name` (String) and `quantity` (int). Include a constructor and public getter methods.
 *     *   Create a class `InventoryItem` with private fields for a unique `inventoryId` (int), `name` (String), and `quantity` (int). The `inventoryId` should be automatically generated (e.g., using a static counter) when an `InventoryItem` is created. Include a constructor and public getter methods.
 * 
 * 2.  **Warehouse System Class (`WarehouseSystem`):**
 *     *   This class will contain the main logic.
 *     *   Declare a private `java.util.Queue<ShipmentItem>` to hold incoming items waiting for processing. Use a concrete implementation like `java.util.LinkedList`.
 *     *   Declare a private `java.util.List<InventoryItem>` to hold the items currently in the main inventory. Use a concrete implementation like `java.util.ArrayList`.
 *     *   Declare a private `java.util.Scanner` for user input.
 *     *   Implement a constructor to initialize the queue, list, and scanner.
 *     *   Implement a public method `addShipmentItem(ShipmentItem item)` that adds the given item to the incoming shipment queue. Print a confirmation message to `System.out`.
 *     *   Implement a public method `processNextShipment()` that takes the next item from the front of the incoming shipment queue. If an item is retrieved:
 *         *   Convert the `ShipmentItem` to an `InventoryItem` (generating a new unique ID).
 *         *   Add the newly created `InventoryItem` to the inventory list.
 *         *   Print a success message including the processed item's details to `System.out`.
 *         *   If the queue is empty, print an error message to `System.err`.
 *     *   Implement a public method `viewInventory()` that iterates through the inventory list and prints the details of each `InventoryItem` to `System.out`. If the inventory is empty, print a message indicating that to `System.out`.
 *     *   Implement a public method `run()` that contains the main application loop. This method should:
 *         *   Display a menu with options: "Add New Shipment Item", "Process Next Incoming Shipment", "View Current Inventory", "Exit".
 *         *   Use a `java.util.Scanner` to read the user's menu choice.
 *         *   Use a `switch` statement to handle the different menu options.
 *         *   For "Add New Shipment Item", prompt the user for the item's name and quantity. **Validate that the quantity is a positive integer.** If input is invalid (non-numeric or not positive), print an error to `System.err` and re-prompt or handle gracefully.
 *         *   Call the appropriate methods (`addShipmentItem`, `processNextShipment`, `viewInventory`) based on the user's choice.
 *         *   Handle the "Exit" option to terminate the loop and close the `Scanner`.
 *         *   Include **class-wide exception handling** using a `try-catch` block around the main application loop (`while` loop in `run()`) to catch potential unexpected runtime exceptions (e.g., `InputMismatchException` if the user enters text when a number is expected for the menu choice). Print a generic error message to `System.err` in the catch block. Ensure the `Scanner` is closed when the application exits (e.g., in a `finally` block or after the loop).
 * 
 * 3.  **Main Method:**
 *     *   Create a `main` method in the `WarehouseSystem` class that creates an instance of `WarehouseSystem` and calls its `run()` method to start the application.
 * 
 * **Constraints & Best Practices:**
 * 
 * *   Adhere strictly to the use of `java.util.Queue`, `java.util.ArrayList`, `java.util.List`, `java.util.Scanner`, `switch`, `System.err`, `System.out`, and `try-catch` as specified.
 * *   Use meaningful variable and method names.
 * *   Implement proper encapsulation (private fields, public getters/methods).
 * *   Add comments or simple documentation where necessary to explain logic.
 * *   Ensure input validation for numerical inputs (menu choice, quantity) and handle errors gracefully using `System.err`.
 * *   Print all normal output (menu, confirmations, inventory listings) to `System.out`.
 * *   Print all error messages (invalid input, empty queue) to `System.err`.
 * 
 * **Expected Output:**
 * 
 * The program should present a menu, allow users to add shipments (which go into a queue), process items from the queue into inventory, view the current inventory, and exit. Error messages should be distinct and printed to the error stream.
 * 
 * ```
 * --- Warehouse System Menu ---
 * 1. Add New Shipment Item
 * 2. Process Next Incoming Shipment
 * 3. View Current Inventory
 * 4. Exit
 * Enter your choice: <user input>
 * 
 * ... (program output based on choice, using System.out or System.err)
 * ```
 * 
 * If user enters non-numeric for choice:
 * `Invalid input. Please enter a number.` (on System.err)
 * `--- Warehouse System Menu --- ...`
 * 
 * If user enters non-numeric for quantity:
 * `Invalid input. Please enter a number for quantity.` (on System.err)
 * `Enter item quantity: ...`
 * 
 * If user enters <= 0 for quantity:
 * `Quantity must be a positive number.` (on System.err)
 * `Enter item quantity: ...`
 * 
 * If processing empty queue:
 * `Error: No incoming shipments to process.` (on System.err)
 * 
 * If unexpected exception in main loop:
 * `An unexpected error occurred: <error message>` (on System.err)
 * `<stack trace>` (on System.err)
 *
 * EXPLANATION:
 * This solution implements a `WarehouseSystem` that simulates processing incoming shipments and managing inventory, utilizing all the required Java components and adhering to best practices.
 * 
 * 1.  **`ShipmentItem` and `InventoryItem` Classes:** These simple classes represent the data structures needed. `ShipmentItem` holds temporary data from a shipment, while `InventoryItem` represents a processed item in the main inventory with a unique ID generated using a static counter (`nextInventoryId`). Encapsulation is used with private fields and public getters. `toString()` methods are overridden for easy printing.
 * 
 * 2.  **`WarehouseSystem` Class:**
 *     *   **Fields:**
 *         *   `incomingShipments`: A `Queue<ShipmentItem>` (implemented by `LinkedList`) holds items waiting to be moved into inventory. The Queue's FIFO (First-In, First-Out) nature is ideal for processing items in the order they arrive.
 *         *   `inventory`: A `List<InventoryItem>` (implemented by `ArrayList`) holds the items currently in stock. `ArrayList` provides dynamic resizing and easy iteration/access.
 *         *   `scanner`: A `Scanner` object is used throughout the `run()` method to get user input from the console.
 *     *   **Constructor:** Initializes the `LinkedList`, `ArrayList`, and `Scanner`.
 *     *   **`addShipmentItem(ShipmentItem item)`:** Demonstrates adding an element to the `Queue` using the `offer()` method, which is the standard way to add to a queue.
 *     *   **`processNextShipment()`:** Demonstrates removing and retrieving the head of the `Queue` using the `poll()` method. It checks if the queue is empty (`poll()` returns `null`) before processing. It then creates an `InventoryItem` from the `ShipmentItem` and adds it to the `List` (`inventory.add()`). Error messages for an empty queue are printed to `System.err`.
 *     *   **`viewInventory()`:** Demonstrates iterating through the `List` to display its contents. It checks if the list is empty and prints appropriate output to `System.out`.
 *     *   **`run()` Method:** This is the core of the application:
 *         *   It contains the main `while` loop that keeps the application running until the user chooses to exit.
 *         *   **Class-wide Exception Handling:** The entire `while` loop (and the `scanner.close()` in `finally`) is wrapped in a `try-catch(Exception e)` block. This fulfills the requirement for class-wide handling, catching any unexpected runtime errors that might occur within the main application flow and printing them to `System.err`.
 *         *   **Menu and `switch`:** The `displayMenu()` method prints options to `System.out`. The `switch` statement is used to direct execution based on the user's integer choice read by the `Scanner`.
 *         *   **Input Validation (`Scanner` and `try-catch`):**
 *             *   Reading the menu choice and quantity uses `scanner.nextInt()`. This method can throw an `InputMismatchException` if the user enters non-numeric input. A `try-catch(InputMismatchException e)` block is specifically used around these calls to catch this error.
 *             *   Inside the catch block for `InputMismatchException`, an error message is printed to `System.err`, and `scanner.next()` (or `scanner.nextLine()`) is crucial to consume the invalid input token from the scanner's buffer, preventing an infinite loop.
 *             *   After reading an integer with `nextInt()`, `scanner.nextLine()` is called to consume the leftover newline character, which would otherwise interfere with subsequent `scanner.nextLine()` calls (used for reading the item name).
 *             *   Additional validation ensures the quantity is a positive integer (`quantity <= 0`), printing an error to `System.err` if not.
 *         *   **`System.out` vs. `System.err`:** All normal program output (menu, confirmations, inventory) goes to `System.out`. All error messages (invalid input, empty queue, unexpected exceptions) go to `System.err`.
 *         *   **`finally` Block:** A `finally` block is used after the main `try-catch` to ensure that the `Scanner` is closed regardless of whether the `while` loop completes normally (user exits) or an unexpected exception occurs.
 * 
 * 3.  **`main` Method:** This standard entry point simply creates an instance of `WarehouseSystem` and calls its `run()` method to start the application.
 * 
 * This solution effectively demonstrates the practical use of Queues for managing waiting tasks, Lists for storing collections of objects, Scanner for user interaction, Switch for control flow, distinct output streams for normal and error messages, and robust error handling using `try-catch` blocks, including specific input validation and a general handler for the main application loop.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.InputMismatchException; // Specific exception for non-numeric input

// Represents an item as it arrives in a shipment
class ShipmentItem {
    private String name;
    private int quantity;

    /**
     * Constructs a new ShipmentItem.
     * @param name The name of the item.
     * @param quantity The quantity of the item.
     */
    public ShipmentItem(String name, int quantity) {
        this.name = name;
        this.quantity = quantity;
    }

    // Getters
    public String getName() {
        return name;
    }

    public int getQuantity() {
        return quantity;
    }

    @Override
    public String toString() {
        return "ShipmentItem [Name=" + name + ", Quantity=" + quantity + "]";
    }
}

// Represents an item stored in the main inventory
class InventoryItem {
    private static int nextInventoryId = 1001; // Simple static counter for unique IDs
    private int inventoryId;
    private String name;
    private int quantity;

    /**
     * Constructs a new InventoryItem, assigning a unique ID.
     * @param name The name of the item.
     * @param quantity The quantity of the item.
     */
    public InventoryItem(String name, int quantity) {
        this.inventoryId = nextInventoryId++; // Assign ID and increment counter
        this.name = name;
        this.quantity = quantity;
    }

    // Getters
    public int getInventoryId() {
        return inventoryId;
    }

    public String getName() {
        return name;
    }

    public int getQuantity() {
        return quantity;
    }

    @Override
    public String toString() {
        return "InventoryItem [ID=" + inventoryId + ", Name=" + name + ", Quantity=" + quantity + "]";
    }
}

// Main class for the warehouse management system
public class WarehouseSystem {
    // Queue to hold incoming shipment items waiting to be processed
    private Queue<ShipmentItem> incomingShipments;
    // List to hold items currently in the main inventory
    private List<InventoryItem> inventory;
    // Scanner for reading user input
    private Scanner scanner;

    /**
     * Constructs a new WarehouseSystem, initializing the queue, list, and scanner.
     */
    public WarehouseSystem() {
        // LinkedList is a common implementation of the Queue interface
        this.incomingShipments = new LinkedList<>();
        // ArrayList is a common implementation of the List interface
        this.inventory = new ArrayList<>();
        this.scanner = new Scanner(System.in);
    }

    /**
     * Adds a new shipment item to the incoming queue.
     * @param item The ShipmentItem to add.
     */
    public void addShipmentItem(ShipmentItem item) {
        incomingShipments.offer(item); // offer() is generally preferred over add() for queues
        System.out.println("Shipment item added to queue: " + item);
    }

    /**
     * Processes the next item from the incoming shipment queue,
     * converting it to an InventoryItem and adding it to inventory.
     * Prints success messages to System.out or error messages to System.err.
     */
    public void processNextShipment() {
        // poll() retrieves and removes the head of the queue, returns null if empty
        ShipmentItem item = incomingShipments.poll();

        if (item == null) {
            System.err.println("Error: No incoming shipments to process.");
        } else {
            // Create an InventoryItem from the ShipmentItem details
            InventoryItem inventoryItem = new InventoryItem(item.getName(), item.getQuantity());
            // Add the new InventoryItem to the inventory list
            inventory.add(inventoryItem);
            System.out.println("Processed shipment and added to inventory: " + inventoryItem);
        }
    }

    /**
     * Displays all items currently in the warehouse inventory.
     * Prints output to System.out.
     */
    public void viewInventory() {
        if (inventory.isEmpty()) {
            System.out.println("Inventory is currently empty.");
        } else {
            System.out.println("\n--- Current Inventory ---");
            // Iterate through the inventory list and print each item
            for (InventoryItem item : inventory) {
                System.out.println(item);
            }
            System.out.println("-------------------------");
        }
    }

    /**
     * Displays the main menu options to the user.
     * Prints output to System.out.
     */
    private void displayMenu() {
        System.out.println("\n--- Warehouse System Menu ---");
        System.out.println("1. Add New Shipment Item");
        System.out.println("2. Process Next Incoming Shipment");
        System.out.println("3. View Current Inventory");
        System.out.println("4. Exit");
        System.out.print("Enter your choice: ");
    }

    /**
     * Runs the main application loop, handling user interaction and menu navigation.
     * Includes class-wide exception handling for robustness.
     */
    public void run() {
        boolean running = true;

        // Class-wide exception handling block around the main operational loop
        try {
            while (running) {
                displayMenu();
                int choice = -1;

                // Input validation loop for menu choice
                try {
                    choice = scanner.nextInt();
                } catch (InputMismatchException e) {
                    System.err.println("Invalid input. Please enter a number.");
                    scanner.next(); // Consume the invalid token from the scanner buffer
                    continue; // Skip the rest of this loop iteration and show menu again
                }

                // Consume the newline character left by scanner.nextInt()
                scanner.nextLine();

                // Use a switch statement to handle different menu options
                switch (choice) {
                    case 1:
                        // --- Add New Shipment Item ---
                        System.out.print("Enter item name: ");
                        String name = scanner.nextLine();
                        int quantity = -1;
                        boolean validQuantity = false;

                        // Input validation loop for quantity
                        while (!validQuantity) {
                            System.out.print("Enter item quantity: ");
                            try {
                                quantity = scanner.nextInt();
                                if (quantity <= 0) {
                                    System.err.println("Quantity must be a positive number.");
                                } else {
                                    validQuantity = true; // Quantity is valid, exit loop
                                }
                            } catch (InputMismatchException e) {
                                System.err.println("Invalid input. Please enter a number for quantity.");
                                scanner.next(); // Consume the invalid token
                            } finally {
                                // Consume the newline character left by nextInt()
                                // This is needed whether nextInt() succeeded or failed
                                if (scanner.hasNextLine()) {
                                    scanner.nextLine();
                                }
                            }
                        }

                        // Create and add the new shipment item
                        ShipmentItem newItem = new ShipmentItem(name, quantity);
                        addShipmentItem(newItem);
                        break;

                    case 2:
                        // --- Process Next Incoming Shipment ---
                        processNextShipment();
                        break;

                    case 3:
                        // --- View Current Inventory ---
                        viewInventory();
                        break;

                    case 4:
                        // --- Exit ---
                        System.out.println("Exiting Warehouse System. Goodbye!");
                        running = false; // Set flag to exit the main loop
                        break;

                    default:
                        // --- Invalid Choice ---
                        System.err.println("Invalid choice. Please enter a number between 1 and 4.");
                        break;
                }
            }
        } catch (Exception e) {
            // Generic catch block for any unexpected exceptions during the main loop execution
            System.err.println("An unexpected error occurred: " + e.getMessage());
            e.printStackTrace(System.err); // Print stack trace to the error stream for debugging
        } finally {
            // Ensure the scanner is closed when the application finishes or encounters a critical error
            if (scanner != null) {
                scanner.close();
                // Optional: confirmation message
                // System.out.println("Scanner closed.");
            }
        }
    }

    /**
     * Main method to start the WarehouseSystem application.
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        WarehouseSystem system = new WarehouseSystem();
        system.run(); // Start the main application loop
    }
}
