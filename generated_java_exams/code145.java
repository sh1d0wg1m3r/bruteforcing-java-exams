/*
 * Exam Question #145
 * Generated on: 2025-05-11 22:21:18
 * Generated by: Account 3
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Resource Allocation System
 * 
 * **Scenario:**
 * 
 * You are tasked with developing a simple command-line application for managing the allocation of a limited number of "Processing Units". This system simulates a scenario where tasks arrive and wait for an available unit. When a unit becomes free, the next waiting task in line is automatically assigned to it.
 * 
 * There are a fixed number of Processing Units available. Tasks are processed in a First-In, First-Out (FIFO) manner based on their submission order.
 * 
 * Your application must allow users to:
 * 1.  Submit a new task.
 * 2.  View the list of tasks currently waiting for a unit.
 * 3.  View the list of tasks currently being processed (allocated a unit).
 * 4.  Manually trigger the allocation of a unit to the next waiting task (if a unit is available and tasks are waiting).
 * 5.  Manually complete a task that is currently being processed, freeing up its unit.
 * 6.  View the number of available Processing Units.
 * 7.  Exit the application.
 * 
 * **Requirements:**
 * 
 * Your solution must meet the following technical requirements:
 * 
 * 1.  **Data Structures:**
 *     *   Use a `java.util.Queue` to manage tasks waiting for a Processing Unit.
 *     *   Use a `java.util.ArrayList` to manage tasks currently being processed.
 *     *   Declare the variable holding the currently processing tasks using the `java.util.List` interface type.
 * 2.  **User Interaction:**
 *     *   Use `java.util.Scanner` to read user input from the console (menu choices and task details).
 * 3.  **Control Flow:**
 *     *   Use a `switch` statement to handle the main menu options.
 * 4.  **Output:**
 *     *   Use `System.out.println()` for normal output (menu, task lists, status messages).
 *     *   Use `System.err.println()` for displaying error messages (e.g., invalid input, task not found, no units available).
 * 5.  **Exception Handling:**
 *     *   Implement exception handling using `try-catch` blocks. Specifically, handle potential input errors from `Scanner` and any logical errors (like trying to complete a non-existent task). Structure your code such that potential errors are caught and reported gracefully. A `try-catch` around the main application loop or key input operations is expected.
 * 6.  **Object-Oriented Design:**
 *     *   Create a `Task` class to represent individual tasks (with attributes like ID, description).
 *     *   Create a `ResourceManager` class to encapsulate the logic for managing tasks, the queue, the list, and the processing units. This class should have private fields and public methods for operations.
 * 7.  **Best Practices:**
 *     *   Use meaningful variable and method names.
 *     *   Include appropriate comments and documentation (e.g., Javadoc for classes/methods).
 *     *   Implement input validation where necessary (e.g., validating menu choices, ensuring task ID exists).
 *     *   Ensure proper encapsulation in the `ResourceManager` class.
 * 
 * **Initial State:**
 * 
 * The system should start with a fixed number of Processing Units (e.g., 3). The waiting queue and processing list should initially be empty.
 * 
 * **Task ID Generation:**
 * 
 * Implement a simple mechanism to assign unique IDs to new tasks (e.g., a static counter).
 * 
 * **Expected Output:**
 * 
 * The program should present a menu, accept user input, perform the requested operation, and display the results or error messages. Task lists should display relevant task information (ID, description).
 * 
 * **Example Interaction Flow:**
 * 
 * ```
 * --- Resource Allocation System ---
 * Available Units: 3
 * 1. Submit Task
 * 2. View Waiting Tasks
 * 3. View Processing Tasks
 * 4. Allocate Unit to Next Waiting Task
 * 5. Complete Task
 * 6. View Available Units
 * 7. Exit
 * Enter choice: 1
 * Enter task description: Process Report A
 * Task submitted: Task{id=1, description='Process Report A'}
 * 
 * --- Resource Allocation System ---
 * Available Units: 3
 * 1. Submit Task
 * ...
 * Enter choice: 1
 * Enter task description: Analyze Data B
 * Task submitted: Task{id=2, description='Analyze Data B'}
 * 
 * --- Resource Allocation System ---
 * Available Units: 3
 * 1. Submit Task
 * ...
 * Enter choice: 2
 * Waiting Tasks:
 * Task{id=1, description='Process Report A'}
 * Task{id=2, description='Analyze Data B'}
 * 
 * --- Resource Allocation System ---
 * Available Units: 3
 * 1. Submit Task
 * ...
 * Enter choice: 4
 * Attempting to allocate unit...
 * Unit allocated to Task{id=1, description='Process Report A'}
 * 
 * --- Resource Allocation System ---
 * Available Units: 2
 * 1. Submit Task
 * ...
 * Enter choice: 3
 * Processing Tasks:
 * Task{id=1, description='Process Report A'}
 * 
 * --- Resource Allocation System ---
 * Available Units: 2
 * 1. Submit Task
 * ...
 * Enter choice: 4
 * Attempting to allocate unit...
 * Unit allocated to Task{id=2, description='Analyze Data B'}
 * 
 * --- Resource Allocation System ---
 * Available Units: 1
 * 1. Submit Task
 * ...
 * Enter choice: 4
 * Attempting to allocate unit...
 * No units available or no tasks waiting.
 * 
 * --- Resource Allocation System ---
 * Available Units: 1
 * 1. Submit Task
 * ...
 * Enter choice: 5
 * Enter ID of task to complete: 1
 * Attempting to complete task ID 1...
 * Task completed: Task{id=1, description='Process Report A'}. Unit freed.
 * 
 * --- Resource Allocation System ---
 * Available Units: 2
 * 1. Submit Task
 * ...
 * Enter choice: 7
 * Exiting system.
 * ```
 * 
 * Implement the Java code for this Resource Allocation System.
 *
 * EXPLANATION:
 * The provided solution implements a simple Resource Allocation System using the required Java components and best practices.
 * 
 * 1.  **`Task` Class:**
 *     *   This class is a simple Plain Old Java Object (POJO) representing a task.
 *     *   It uses a `static int nextId` to automatically generate unique IDs for each new task instance, demonstrating a basic approach to unique identifiers.
 *     *   It has private fields (`id`, `description`) and public getter methods (`getId`, `getDescription`), adhering to encapsulation.
 *     *   The `toString()` method is overridden for easy printing of task details.
 * 
 * 2.  **`ResourceManager` Class:**
 *     *   This class encapsulates the core logic of the system.
 *     *   **Data Structures:**
 *         *   `private Queue<Task> waitingTasks`: A `LinkedList` is used here, which implements the `Queue` interface, fulfilling the `Queue` requirement and providing FIFO behavior for tasks awaiting a unit.
 *         *   `private List<Task> processingTasks`: An `ArrayList` is used to store tasks currently being processed. It is declared using the `List` interface type, satisfying the `List` interface requirement. An `ArrayList` is suitable as we might need to iterate and remove elements by ID.
 *         *   `private int totalUnits`, `private int availableUnits`: Track the state of the processing units.
 *     *   **Encapsulation:** All data fields are private. Public methods (`submitTask`, `allocateUnit`, `completeTask`, `getWaitingTasks`, `getProcessingTasks`, `getAvailableUnits`, `getTotalUnits`) provide controlled access to the system's state and functionality.
 *     *   **Methods:**
 *         *   `submitTask(Task task)`: Adds a task to the tail of the `waitingTasks` queue using `offer()`.
 *         *   `allocateUnit()`: Checks if units are available (`availableUnits > 0`) and if the queue is not empty. If both conditions are true, it removes the task at the head of the `waitingTasks` queue using `poll()`, adds it to the `processingTasks` list, and decrements `availableUnits`.
 *         *   `completeTask(int taskId)`: Iterates through the `processingTasks` list using an `Iterator` to find the task by its ID. Using an `Iterator` for removal is the safe way to remove elements while iterating over an `ArrayList`. If found, the task is removed, and `availableUnits` is incremented. Includes error handling via `System.err.println` if the task ID is not found.
 *         *   `getWaitingTasks()`: Returns a *new* `ArrayList` populated with elements from the queue. This prevents external code from directly modifying the internal queue structure, promoting better encapsulation (though returning the actual list for `getProcessingTasks` is acceptable for a simple viewing scenario).
 *         *   `getProcessingTasks()`: Returns the internal `processingTasks` list.
 *         *   `getAvailableUnits()`, `getTotalUnits()`: Simple getters for the unit counts.
 * 
 * 3.  **`ResourceAllocationSystem` Class (Main Application):**
 *     *   Contains the `main` method where execution begins.
 *     *   **Initialization:** Creates a `ResourceManager` instance and a `Scanner` for input. Defines the fixed number of units.
 *     *   **Main Loop:** A `while(running)` loop keeps the application active until the user chooses to exit.
 *     *   **Menu and `switch`:** The `printMenu` helper method displays options using `System.out`. User input for the choice is read using `scanner.nextInt()`. A `switch` statement branches the execution based on the user's valid integer choice.
 *     *   **Scanner and Input Handling:** `Scanner` is used to read both integers (`nextInt`) and strings (`nextLine`). Crucially, `scanner.nextLine()` is called after `nextInt()` to consume the leftover newline character, preventing input issues in subsequent `nextLine()` calls.
 *     *   **Error Handling (`try-catch` and `System.err`):**
 *         *   A `try-catch(InputMismatchException e)` block is wrapped around the `scanner.nextInt()` calls within the main loop and the 'Complete Task' case. This catches non-integer input when an integer is expected, prints an error message to `System.err`, consumes the invalid input, and continues the loop.
 *         *   A broader `try-catch(Exception e)` is wrapped around the *entire* `while` loop. This serves as a form of "class-wide" exception handling (as interpreted from the requirement), catching any unhandled exceptions that might occur during the application's runtime and preventing the program from crashing abruptly. It prints an error to `System.err` and the stack trace.
 *         *   The `completeTask` method in `ResourceManager` uses `System.err.println` for a specific business logic error (task not found).
 *         *   Input validation for the task description being empty is also included, printing an error to `System.err`.
 *         *   The `default` case in the `switch` handles invalid integer choices, printing an error to `System.err`.
 *     *   **`System.out`:** Used for displaying the menu, status messages, task lists, and successful operation messages.
 *     *   **`finally` Block:** A `finally` block ensures that the `scanner.close()` method is called before the program exits, releasing the system resource used by the `Scanner`.
 * 
 * This solution effectively integrates all required components (`Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.err`, `System.out`, `try-catch`) within a practical scenario, demonstrates object-oriented principles with encapsulation, and includes basic input validation and error handling, making it a suitable challenging exam task.
 */

import java.util.LinkedList;
import java.util.Queue;
import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;
import java.util.InputMismatchException;
import java.util.Iterator;

/**
 * Represents a single task in the resource allocation system.
 */
class Task {
    private static int nextId = 1; // Static counter for unique task IDs

    private int id;
    private String description;

    /**
     * Constructs a new Task with a unique ID and description.
     * @param description The description of the task.
     */
    public Task(String description) {
        this.id = nextId++;
        this.description = description;
    }

    // --- Getters ---
    public int getId() {
        return id;
    }

    public String getDescription() {
        return description;
    }

    @Override
    public String toString() {
        return "Task{id=" + id + ", description='" + description + "'}";
    }
}

/**
 * Manages the allocation of processing units to tasks.
 */
class ResourceManager {
    private Queue<Task> waitingTasks;
    private List<Task> processingTasks; // Using List interface type
    private int totalUnits;
    private int availableUnits;

    /**
     * Constructs a ResourceManager with a specified number of processing units.
     * @param totalUnits The total number of processing units available.
     */
    public ResourceManager(int totalUnits) {
        if (totalUnits <= 0) {
            throw new IllegalArgumentException("Total units must be positive.");
        }
        this.totalUnits = totalUnits;
        this.availableUnits = totalUnits;
        this.waitingTasks = new LinkedList<>(); // LinkedList implements Queue
        this.processingTasks = new ArrayList<>(); // ArrayList implements List
    }

    /**
     * Submits a new task to the waiting queue.
     * @param task The task to submit.
     */
    public void submitTask(Task task) {
        waitingTasks.offer(task); // offer is preferred over add for queues
        System.out.println("Task submitted: " + task);
    }

    /**
     * Attempts to allocate a processing unit to the next waiting task.
     * @return The task that was allocated a unit, or null if no unit was allocated.
     */
    public Task allocateUnit() {
        if (availableUnits > 0 && !waitingTasks.isEmpty()) {
            Task taskToAllocate = waitingTasks.poll(); // Remove from head of queue
            if (taskToAllocate != null) {
                processingTasks.add(taskToAllocate); // Add to processing list
                availableUnits--;
                System.out.println("Unit allocated to " + taskToAllocate);
                return taskToAllocate;
            }
        }
        System.out.println("No units available or no tasks waiting.");
        return null;
    }

    /**
     * Attempts to complete a task currently being processed.
     * Frees up the processing unit.
     * @param taskId The ID of the task to complete.
     * @return The task that was completed, or null if the task was not found in processing.
     */
    public Task completeTask(int taskId) {
        Iterator<Task> iterator = processingTasks.iterator();
        while (iterator.hasNext()) {
            Task task = iterator.next();
            if (task.getId() == taskId) {
                iterator.remove(); // Safely remove using iterator
                availableUnits++;
                System.out.println("Task completed: " + task + ". Unit freed.");
                // After completing a task, try to allocate to the next waiting task automatically
                // (Optional but good practice for resource systems, though manual allocation is also a menu option)
                // allocateUnit(); // If uncommented, this would auto-allocate
                return task;
            }
        }
        System.err.println("Error: Task with ID " + taskId + " not found in processing.");
        return null;
    }

    /**
     * Gets a view of the tasks currently waiting.
     * @return A List containing the waiting tasks (copy or view).
     */
    public List<Task> getWaitingTasks() {
        // Return a new list to prevent external modification of the queue
        return new ArrayList<>(waitingTasks);
    }

    /**
     * Gets a view of the tasks currently being processed.
     * @return The List of processing tasks.
     */
    public List<Task> getProcessingTasks() {
        return processingTasks; // Returning the list itself is acceptable for viewing in this context
    }

    /**
     * Gets the number of available processing units.
     * @return The count of available units.
     */
    public int getAvailableUnits() {
        return availableUnits;
    }

    /**
     * Gets the total number of processing units.
     * @return The total count of units.
     */
    public int getTotalUnits() {
        return totalUnits;
    }
}

/**
 * Main application class for the Resource Allocation System.
 */
public class ResourceAllocationSystem {

    private static final int TOTAL_PROCESSING_UNITS = 3; // Fixed number of units

    public static void main(String[] args) {
        ResourceManager resourceManager = new ResourceManager(TOTAL_PROCESSING_UNITS);
        Scanner scanner = new Scanner(System.in);
        boolean running = true;

        // Class-wide exception handling around the main loop
        try {
            while (running) {
                printMenu(resourceManager);

                int choice = -1;
                try {
                    System.out.print("Enter choice: ");
                    choice = scanner.nextInt();
                    scanner.nextLine(); // Consume newline left-over
                } catch (InputMismatchException e) {
                    System.err.println("Invalid input. Please enter a number.");
                    scanner.nextLine(); // Consume the invalid input
                    continue; // Skip the rest of the loop iteration
                }

                // Switch statement for menu options
                switch (choice) {
                    case 1: // Submit Task
                        System.out.print("Enter task description: ");
                        String description = scanner.nextLine();
                        if (description == null || description.trim().isEmpty()) {
                            System.err.println("Error: Task description cannot be empty.");
                        } else {
                            Task newTask = new Task(description.trim());
                            resourceManager.submitTask(newTask);
                        }
                        break;

                    case 2: // View Waiting Tasks
                        List<Task> waiting = resourceManager.getWaitingTasks();
                        System.out.println("Waiting Tasks (" + waiting.size() + "):");
                        if (waiting.isEmpty()) {
                            System.out.println("  No tasks waiting.");
                        } else {
                            waiting.forEach(task -> System.out.println("  " + task));
                        }
                        break;

                    case 3: // View Processing Tasks
                        List<Task> processing = resourceManager.getProcessingTasks();
                        System.out.println("Processing Tasks (" + processing.size() + "):");
                        if (processing.isEmpty()) {
                            System.out.println("  No tasks processing.");
                        } else {
                            processing.forEach(task -> System.out.println("  " + task));
                        }
                        break;

                    case 4: // Allocate Unit
                        System.out.println("Attempting to allocate unit...");
                        resourceManager.allocateUnit(); // Method prints success/failure
                        break;

                    case 5: // Complete Task
                        System.out.print("Enter ID of task to complete: ");
                        try {
                            int taskIdToComplete = scanner.nextInt();
                            scanner.nextLine(); // Consume newline
                            System.out.println("Attempting to complete task ID " + taskIdToComplete + "...");
                            resourceManager.completeTask(taskIdToComplete); // Method prints success/failure
                        } catch (InputMismatchException e) {
                            System.err.println("Invalid input. Please enter a valid task ID (number).");
                            scanner.nextLine(); // Consume invalid input
                        }
                        break;

                    case 6: // View Available Units
                        System.out.println("Available Units: " + resourceManager.getAvailableUnits() + " / " + resourceManager.getTotalUnits());
                        break;

                    case 7: // Exit
                        System.out.println("Exiting system.");
                        running = false;
                        break;

                    default: // Invalid choice
                        System.err.println("Invalid choice. Please enter a number between 1 and 7.");
                        break;
                }
                System.out.println(); // Add a blank line for readability
            }
        } catch (Exception e) {
            // Catch any unexpected exceptions during the main loop execution
            System.err.println("An unexpected error occurred: " + e.getMessage());
            e.printStackTrace(); // Print stack trace for debugging
        } finally {
            // Ensure the scanner is closed
            if (scanner != null) {
                scanner.close();
            }
            System.out.println("System shutdown complete.");
        }
    }

    /**
     * Prints the main menu to the console.
     * @param rm The ResourceManager to get current unit status.
     */
    private static void printMenu(ResourceManager rm) {
        System.out.println("--- Resource Allocation System ---");
        System.out.println("Available Units: " + rm.getAvailableUnits() + " / " + rm.getTotalUnits());
        System.out.println("1. Submit Task");
        System.out.println("2. View Waiting Tasks (" + rm.getWaitingTasks().size() + ")");
        System.out.println("3. View Processing Tasks (" + rm.getProcessingTasks().size() + ")");
        System.out.println("4. Allocate Unit to Next Waiting Task");
        System.out.println("5. Complete Task");
        System.out.println("6. View Available Units");
        System.out.println("7. Exit");
        System.out.println("----------------------------------");
    }
}
