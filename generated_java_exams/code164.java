/*
 * Exam Question #164
 * Generated on: 2025-05-11 22:24:39
 * Generated by: Account 1
 * 
 * QUESTION:
 * ```
 * ## Java Programming Exam Task: Advanced Task Management System
 * 
 * This exam task requires you to build a simple command-line Task Management System. The system should allow users to add tasks, process the next pending task, and view all tasks. This exercise is designed to test your understanding and application of core Java data structures, control flow, and exception handling.
 * 
 * You must implement two main classes:
 * 1.  `Task`: Represents a single task with properties like ID, description, priority, and status.
 * 2.  `TaskManager`: Manages collections of tasks and provides the system's core functionalities.
 * 
 * **Requirements:**
 * 
 * 1.  **`Task` Class:**
 *     *   Must have private fields: `taskId` (int), `description` (String), `priority` (String, e.g., "HIGH", "MEDIUM", "LOW"), and `status` (String, e.g., "PENDING", "PROCESSING", "COMPLETED", "FAILED").
 *     *   Provide a constructor to create a new task (initially with status "PENDING"). Task IDs should be automatically generated sequentially by the `TaskManager`.
 *     *   Include public getter methods for all fields.
 *     *   Include a public setter method for the `status` field.
 *     *   Override the `toString()` method to provide a clear representation of the task.
 * 
 * 2.  **`TaskManager` Class:**
 *     *   Must manage tasks using the following private fields:
 *         *   A `Queue<Task>` to hold tasks that are waiting to be processed (`pendingTasks`).
 *         *   A `List<Task>` (instantiated as `ArrayList<Task>`) to store *all* tasks ever created, regardless of their status (`allTasks`).
 *         *   An integer counter to generate unique task IDs (`nextTaskId`).
 *     *   Implement the following public methods:
 *         *   `addTask(String description, String priority)`: Creates a new `Task` object with a unique ID, adds it to both `allTasks` and `pendingTasks`. Must validate the provided `priority` string (only "HIGH", "MEDIUM", "LOW" are allowed, case-insensitive). Throw an `IllegalArgumentException` if validation fails or if the description is empty.
 *         *   `processNextTask()`: Removes the next task from the `pendingTasks` queue. If successful, simulate processing (print a message) and update the status of this task to "COMPLETED" within the `allTasks` list. If the `pendingTasks` queue is empty, print an error message to `System.err`.
 *         *   `viewAllTasks()`: Prints the details of all tasks currently stored in the `allTasks` list. Print a message if the list is empty.
 *     *   Implement a `run()` method that contains the main application loop:
 *         *   Display a menu of options (Add Task, Process Task, View All Tasks, Exit).
 *         *   Use `java.util.Scanner` to read user input for menu choices and task details.
 *         *   Use a `switch` statement to handle the user's menu choice.
 *         *   Implement robust exception handling using `try-catch` blocks to manage potential issues like invalid input (e.g., non-integer input for menu choice) or errors from method calls (like `IllegalArgumentException` from `addTask`).
 *         *   Use `System.out` for displaying the menu, prompts, successful operations, and task details.
 *         *   Use `System.err` for printing all error messages (e.g., invalid menu choice, invalid task priority, empty queue, invalid input type).
 *         *   The loop should continue until the user chooses to exit.
 * 
 * **Technical Constraints (MUST USE ALL):**
 * 
 * *   `java.util.Queue`
 * *   `java.util.ArrayList`
 * *   `java.util.List` interface (declare a variable of type `List`)
 * *   `java.util.Scanner`
 * *   `switch` statement
 * *   `System.err`
 * *   `System.out`
 * *   Class-wide exception handling with `try-catch` blocks (at least one significant try-catch block covering main logic, and potentially others for specific operations).
 * 
 * **Best Practices:**
 * 
 * *   Apply proper encapsulation (private fields, public methods).
 * *   Use meaningful variable and method names.
 * *   Include appropriate comments explaining key logic.
 * *   Implement input validation where necessary.
 * *   Ensure proper error handling using the specified streams and exception mechanisms.
 * *   Maintain a clean code structure.
 * 
 * **Expected Output:**
 * 
 * The program should interact with the user via the console, presenting a menu, accepting input, and displaying results or error messages as described above. An example interaction might look like this:
 * 
 * ```
 * Task Management System
 * 1. Add New Task
 * 2. Process Next Task
 * 3. View All Tasks
 * 0. Exit
 * Enter your choice: 1
 * Enter task description: Write exam question
 * Enter task priority (HIGH, MEDIUM, LOW): HIGH
 * Task added successfully.
 * 
 * Task Management System
 * 1. Add New Task
 * 2. Process Next Task
 * 3. View All Tasks
 * 0. Exit
 * Enter your choice: 1
 * Enter task description: Grade papers
 * Enter task priority (HIGH, MEDIUM, LOW): medium
 * Task added successfully.
 * 
 * Task Management System
 * 1. Add New Task
 * 2. Process Next Task
 * 3. View All Tasks
 * 0. Exit
 * Enter your choice: 2
 * Processing Task: Write exam question
 * Task ID 1 marked as COMPLETED.
 * 
 * Task Management System
 * 1. Add New Task
 * 2. Process Next Task
 * 3. View All Tasks
 * 0. Exit
 * Enter your choice: 3
 * --- All Tasks ---
 * Task{ID=1, Desc='Write exam question', Priority=HIGH, Status=COMPLETED}
 * Task{ID=2, Desc='Grade papers', Priority=MEDIUM, Status=PENDING}
 * -----------------
 * 
 * Task Management System
 * 1. Add New Task
 * 2. Process Next Task
 * 3. View All Tasks
 * 0. Exit
 * Enter your choice: 5
 * Invalid choice. Please try again.
 * 
 * Task Management System
 * 1. Add New Task
 * 2. Process Next Task
 * 3. View All Tasks
 * 0. Exit
 * Enter your choice: 1
 * Enter task description:
 * Enter task priority (HIGH, MEDIUM, LOW): LOW
 * Error adding task: Task description cannot be empty.
 * 
 * Task Management System
 * 1. Add New Task
 * 2. Process Next Task
 * 3. View All Tasks
 * 0. Exit
 * Enter your choice: exit
 * Invalid input. Please enter a number.
 * 
 * Task Management System
 * 1. Add New Task
 * 2. Process Next Task
 * 3. View All Tasks
 * 0. Exit
 * Enter your choice: 0
 * Exiting Task Management System.
 * ```
 * 
 * Your solution should be a single Java file containing the `Task` (can be a static nested class within `TaskManager` for simplicity) and `TaskManager` classes, including a `main` method to start the application.
 * ```
 *
 * EXPLANATION:
 * ```
 * The provided solution implements a simple Task Management System demonstrating the required Java concepts and best practices.
 * 
 * **Key Components and Their Usage:**
 * 
 * 1.  **`java.util.Queue` (`pendingTasks`):**
 *     *   Used to store tasks that are waiting to be processed in a First-In, First-Out (FIFO) manner.
 *     *   Implemented using `java.util.LinkedList`, which is a common `Queue` implementation.
 *     *   `offer(task)` is used in `addTask` to add a new task to the end of the queue.
 *     *   `poll()` is used in `processNextTask` to retrieve and remove the task at the front of the queue.
 * 
 * 2.  **`java.util.List` (`allTasks`) and `java.util.ArrayList`:**
 *     *   `allTasks` is declared as `List<Task>` to adhere to the requirement of using the `List` interface.
 *     *   It is instantiated as `new ArrayList<>()`, which is a concrete implementation of `List` providing dynamic array capabilities.
 *     *   Used to store *all* tasks created by the system, regardless of their current status. This allows viewing a complete history or list of tasks.
 *     *   `add(task)` is used in `addTask` to add a new task to this list.
 *     *   Iterating through this list is done in `viewAllTasks` to display all tasks and in `processNextTask` to find the processed task and update its status.
 * 
 * 3.  **`java.util.Scanner`:**
 *     *   Used in the `run()` method to read user input from the console for menu choices and task details (description and priority).
 *     *   `nextInt()` is used to read the integer menu choice.
 *     *   `nextLine()` is used to read string inputs (description, priority) and to consume the newline character after reading an integer.
 * 
 * 4.  **`switch` Statement:**
 *     *   Used in the `run()` method to control the program flow based on the user's integer menu choice. Each `case` corresponds to a different action (Add Task, Process Task, View All Tasks, Exit). The `default` case handles invalid integer inputs.
 * 
 * 5.  **`System.err`:**
 *     *   Used specifically for outputting error messages. This includes:
 *         *   Invalid menu choices (`default` case in `switch`).
 *         *   Errors during task creation (e.g., empty description, invalid priority) caught by the nested `try-catch` around `addTask`.
 *         *   Attempting to process a task when the `pendingTasks` queue is empty (`processNextTask` method).
 *         *   General input errors caught by `InputMismatchException`.
 *         *   Any other unexpected errors caught by the broader `Exception` catch block.
 * 
 * 6.  **`System.out`:**
 *     *   Used for normal program output, including:
 *         *   Displaying the main menu (`printMenu`).
 *         *   Prompting the user for input.
 *         *   Confirming successful operations (e.g., "Task added successfully.").
 *         *   Displaying the list of all tasks (`viewAllTasks`).
 *         *   Messages related to successful task processing (`processNextTask`).
 *         *   The exit message.
 * 
 * 7.  **Class-wide Exception Handling (`try-catch`):**
 *     *   A main `try-catch` block is wrapped around the core logic within the `while` loop in the `run()` method. This block catches potential exceptions that might occur during input reading (`InputMismatchException`) or from called methods.
 *     *   A nested `try-catch` block is used specifically around the `addTask` call within the `switch` statement's case 1. This catches the `IllegalArgumentException` thrown by `addTask` if the input validation fails, allowing the system to report the specific error without crashing.
 *     *   Catching `InputMismatchException` separately is crucial for handling non-integer input gracefully and preventing an infinite loop by consuming the invalid input.
 *     *   A general `catch (Exception e)` is included as a fallback for any other unexpected runtime errors within the loop, demonstrating a robust handling approach.
 * 
 * **Best Practices Demonstrated:**
 * 
 * *   **Encapsulation:** Fields in both `Task` and `TaskManager` classes are declared as `private`, with public getter and setter methods (or methods like `addTask`, `processNextTask` that manage the state).
 * *   **Meaningful Names:** Variables (`pendingTasks`, `allTasks`, `nextTaskId`, `description`, `priority`) and methods (`addTask`, `processNextTask`, `viewAllTasks`, `run`, `printMenu`) have names that clearly indicate their purpose.
 * *   **Comments:** Javadoc-style comments are used to explain the purpose of classes, methods, and key parameters. Inline comments clarify specific logic blocks.
 * *   **Input Validation:** The `addTask` method explicitly checks if the description is empty and if the priority string is one of the allowed values, throwing an `IllegalArgumentException` if validation fails. The `run` method handles `InputMismatchException` for numerical input.
 * *   **Error Handling:** Multiple levels of error handling are implemented using `try-catch` for exceptions and conditional checks (`pendingTasks.poll() == null`) combined with distinct output streams (`System.err` for errors, `System.out` for normal messages).
 * *   **Clean Code Structure:** The logic is separated into two classes (`Task` and `TaskManager`) with clear responsibilities. The `run` method acts as the controller, orchestrating interactions between the user input, task management logic, and output. The `Task` class is defined as a `static nested class` within `TaskManager` for convenience in a single-file solution, which is acceptable for exam tasks.
 * 
 * This solution effectively integrates the required components to simulate a practical scenario, demonstrating advanced understanding of Java collection types, control flow, and exception handling.
 * ```
 */

import java.util.ArrayList;
import java.util.LinkedList; // LinkedList is a common Queue implementation
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.InputMismatchException; // Specific Scanner exception

/**
 * Main class for the Task Management System.
 * Contains the TaskManager logic and the main application loop.
 */
public class TaskManager {

    // --- Task Class ---
    /**
     * Represents a single task in the system.
     */
    private static class Task {
        private int taskId;
        private String description;
        private String priority; // HIGH, MEDIUM, LOW
        private String status;   // PENDING, PROCESSING, COMPLETED, FAILED

        /**
         * Constructs a new Task.
         * @param taskId The unique ID for the task.
         * @param description A brief description of the task.
         * @param priority The priority of the task (HIGH, MEDIUM, LOW).
         * @param status The initial status of the task.
         */
        public Task(int taskId, String description, String priority, String status) {
            this.taskId = taskId;
            this.description = description;
            this.priority = priority;
            this.status = status;
        }

        // --- Getters ---
        public int getTaskId() {
            return taskId;
        }

        public String getDescription() {
            return description;
        }

        public String getPriority() {
            return priority;
        }

        public String getStatus() {
            return status;
        }

        // --- Setter ---
        /**
         * Sets the status of the task.
         * @param status The new status.
         */
        public void setStatus(String status) {
            this.status = status;
        }

        /**
         * Provides a string representation of the Task object.
         * @return Formatted string describing the task.
         */
        @Override
        public String toString() {
            return String.format("Task{ID=%d, Desc='%s', Priority=%s, Status=%s}",
                                 taskId, description, priority, status);
        }
    }
    // --- End of Task Class ---


    // --- TaskManager Fields ---
    private Queue<Task> pendingTasks; // Queue for tasks waiting to be processed
    private List<Task> allTasks;      // List to hold all tasks created
    private int nextTaskId;           // Counter for generating unique task IDs
    // --- End of TaskManager Fields ---


    /**
     * Constructs a new TaskManager, initializing task collections and ID counter.
     */
    public TaskManager() {
        // Instantiate Queue using LinkedList
        this.pendingTasks = new LinkedList<>();
        // Instantiate List using ArrayList
        this.allTasks = new ArrayList<>();
        this.nextTaskId = 1; // Start task IDs from 1
    }

    /**
     * Adds a new task to the system.
     * Creates a Task object, assigns a unique ID, and adds it to both
     * the list of all tasks and the queue of pending tasks.
     *
     * @param description The task description.
     * @param priority    The task priority (HIGH, MEDIUM, LOW - case-insensitive).
     * @throws IllegalArgumentException if the description is empty or priority is invalid.
     */
    public void addTask(String description, String priority) throws IllegalArgumentException {
        if (description == null || description.trim().isEmpty()) {
            throw new IllegalArgumentException("Task description cannot be empty.");
        }

        String upperPriority = priority != null ? priority.trim().toUpperCase() : "";
        if (!upperPriority.equals("HIGH") && !upperPriority.equals("MEDIUM") && !upperPriority.equals("LOW")) {
             throw new IllegalArgumentException("Invalid priority: '" + priority + "'. Valid priorities are HIGH, MEDIUM, LOW.");
        }

        // Create the new task with the next available ID and PENDING status
        Task newTask = new Task(nextTaskId++, description.trim(), upperPriority, "PENDING");

        allTasks.add(newTask);      // Add to the list of all tasks
        pendingTasks.offer(newTask); // Add to the end of the pending queue

        // System.out.println("Debug: Added Task ID " + newTask.getTaskId() + " to allTasks and pendingTasks.");
    }

    /**
     * Processes the next task from the pending queue.
     * Removes the task from the queue and updates its status in the allTasks list.
     * Prints a message indicating processing or an error if the queue is empty.
     */
    public void processNextTask() {
        // Retrieve and remove the head of the queue
        Task taskToProcess = pendingTasks.poll();

        if (taskToProcess == null) {
            // Use System.err for error message when queue is empty
            System.err.println("No tasks in the pending queue to process.");
        } else {
            // Use System.out for normal processing message
            System.out.println("Processing Task: " + taskToProcess.getDescription());

            // Find the task in the allTasks list and update its status
            // Iterating through allTasks is necessary here to update the status
            // of the task object that is stored in the list.
            boolean foundAndUpdated = false;
            for (Task task : allTasks) {
                if (task.getTaskId() == taskToProcess.getTaskId()) {
                    task.setStatus("COMPLETED"); // Update status
                    System.out.println("Task ID " + task.getTaskId() + " marked as COMPLETED.");
                    foundAndUpdated = true;
                    break; // Task found and updated, exit loop
                }
            }
            // Optional: Add error handling if task wasn't found in allTasks (shouldn't happen with current logic)
            if (!foundAndUpdated) {
                 System.err.println("Internal Error: Processed task ID " + taskToProcess.getTaskId() + " not found in allTasks list.");
            }
        }
    }

    /**
     * Prints details of all tasks managed by the system.
     * Iterates through the allTasks list and prints each task's details.
     */
    public void viewAllTasks() {
        if (allTasks.isEmpty()) {
            System.out.println("No tasks have been created yet.");
        } else {
            System.out.println("--- All Tasks ---");
            // Iterate through the List of all tasks
            for (Task task : allTasks) {
                System.out.println(task); // Uses Task's toString() method
            }
            System.out.println("-----------------");
        }
    }

    /**
     * Prints the main menu options to System.out.
     */
    private void printMenu() {
        System.out.println("\nTask Management System");
        System.out.println("1. Add New Task");
        System.out.println("2. Process Next Task");
        System.out.println("3. View All Tasks");
        System.out.println("0. Exit");
    }

    /**
     * Runs the main application loop.
     * Handles user input, calls TaskManager methods based on choices,
     * and manages exceptions. This method demonstrates class-wide try-catch.
     */
    public void run() {
        Scanner scanner = new Scanner(System.in);
        int choice = -1;

        // Main application loop continues until user chooses to exit (choice 0)
        while (choice != 0) {
            printMenu();
            System.out.print("Enter your choice: ");

            // Use try-catch block for class-wide exception handling,
            // covering input reading and potential errors from method calls.
            try {
                // Attempt to read integer input for choice
                choice = scanner.nextInt();
                scanner.nextLine(); // Consume the newline character left by nextInt()

                // Use switch statement for flow control based on user choice
                switch (choice) {
                    case 1: // Add Task
                        System.out.print("Enter task description: ");
                        String description = scanner.nextLine();
                        System.out.print("Enter task priority (HIGH, MEDIUM, LOW): ");
                        String priority = scanner.nextLine(); // Read priority as string

                        // Use a nested try-catch specifically for addTask's potential exception
                        try {
                            addTask(description, priority); // This method throws IllegalArgumentException
                            System.out.println("Task added successfully."); // Use System.out for success
                        } catch (IllegalArgumentException e) {
                            // Use System.err for validation errors from addTask
                            System.err.println("Error adding task: " + e.getMessage());
                        }
                        break;

                    case 2: // Process Next Task
                        // processNextTask handles its own error message (System.err) if queue is empty
                        processNextTask();
                        break;

                    case 3: // View All Tasks
                        viewAllTasks(); // viewAllTasks uses System.out
                        break;

                    case 0: // Exit
                        System.out.println("Exiting Task Management System."); // Use System.out for exit message
                        break;

                    default:
                        // Use System.err for invalid menu choices
                        System.err.println("Invalid choice. Please try again.");
                }

            } catch (InputMismatchException e) {
                // Catch specific exception for non-integer input
                System.err.println("Invalid input. Please enter a number.");
                scanner.nextLine(); // IMPORTANT: Consume the invalid input to prevent infinite loop
                choice = -1; // Reset choice or keep it non-zero to continue loop
            } catch (Exception e) {
                // Catch any other unexpected exceptions during the loop iteration
                System.err.println("An unexpected error occurred: " + e.getMessage());
                // Optional: e.printStackTrace(System.err); // For detailed debugging
            }
            // Add a newline for better readability between interactions
            System.out.println();
        }

        scanner.close(); // Close the scanner when the application exits
    }

    /**
     * Main method to start the Task Management System.
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        TaskManager manager = new TaskManager();
        manager.run(); // Start the main application loop
    }
}
