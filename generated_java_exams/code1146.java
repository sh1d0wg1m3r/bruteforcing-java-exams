/*
 * Exam Question #1146
 * Generated on: 2025-05-12 17:31:12
 * Generated by: Account 1
 * 
 * QUESTION:
 * **Advanced Java Programming Exam Task: Production Line Simulation**
 * 
 * **Scenario:**
 * 
 * You are tasked with creating a simplified simulation of a production line. The system manages tasks that are waiting to be processed, processes them one by one in the order they arrive, and keeps track of completed tasks. The simulation should be interactive, allowing a user to add new tasks, process the next task in the queue, and view the status of tasks.
 * 
 * **Requirements:**
 * 
 * 1.  **Task Class:** Create a class named `Task`.
 *     *   It should have private fields: `taskId` (an integer, automatically generated and unique for each task), `description` (a String), and `status` (an enumeration type, e.g., `PENDING`, `PROCESSING`, `COMPLETED`).
 *     *   Implement a constructor that takes the description and initializes the task with a unique ID and `PENDING` status. Use a static counter or similar mechanism for unique IDs.
 *     *   Include getter methods for all fields.
 *     *   Include a setter method for the `status`.
 *     *   Override the `toString()` method to provide a useful string representation of a task.
 *     *   Add validation in the constructor to ensure the description is not null or empty; throw an `IllegalArgumentException` if it is.
 * 
 * 2.  **ProductionLineManager Class:** Create a class named `ProductionLineManager`.
 *     *   It should manage two collections: a `Queue<Task>` for tasks waiting to be processed, and a `List<Task>` (specifically using `ArrayList<Task>`) for tasks that have been completed. Declare these using the interface types (`Queue` and `List`).
 *     *   Implement a constructor to initialize these collections.
 *     *   Implement a method `addTask(String description)`: Creates a new `Task` object and adds it to the pending queue. Handle potential `IllegalArgumentException` from the `Task` constructor and report the error using `System.err`. Use `System.out` to confirm successful addition.
 *     *   Implement a method `processNextTask()`: Retrieves and removes the next task from the pending queue, changes its status to `COMPLETED`, and adds it to the completed tasks list. If the pending queue is empty, print an error message using `System.err`. Use `System.out` to report which task was processed.
 *     *   Implement a method `viewPendingTasks()`: Displays the details of all tasks currently in the pending queue using `System.out`. Indicate if the queue is empty.
 *     *   Implement a method `viewCompletedTasks()`: Displays the details of all tasks in the completed tasks list using `System.out`. Indicate if the list is empty.
 * 
 * 3.  **ProductionLineSimulator Class:** Create a class named `ProductionLineSimulator` with a `main` method.
 *     *   This class will contain the main application logic and user interface.
 *     *   Use `java.util.Scanner` to read user input from the console.
 *     *   Create an instance of `ProductionLineManager`.
 *     *   Implement a menu-driven loop that allows the user to choose from the following options:
 *         1.  Add New Task
 *         2.  Process Next Task
 *         3.  View Pending Tasks
 *         4.  View Completed Tasks
 *         5.  Exit
 *     *   Use a `switch` statement to handle the user's menu choice.
 *     *   Display the menu and read the user's choice in each iteration of the loop.
 *     *   Handle `InputMismatchException` if the user enters non-integer input for the menu choice, printing an error using `System.err` and allowing them to try again.
 *     *   Implement **class-wide exception handling** by wrapping the main application loop (`while(true)`) in a `try-catch(Exception e)` block in the `main` method. This block should catch any unexpected runtime exceptions and print an error message using `System.err` before the program potentially terminates. Ensure the `Scanner` is closed in a `finally` block.
 *     *   Use `System.out` for displaying the menu, prompts, and task lists.
 *     *   Use `System.err` for all error messages (invalid input, operational errors like processing an empty queue, unexpected exceptions).
 * 
 * 4.  **Best Practices:**
 *     *   Adhere to principles of encapsulation (private fields, public methods).
 *     *   Use meaningful names for variables, methods, and classes.
 *     *   Include appropriate comments and documentation (e.g., Javadoc for methods).
 *     *   Implement input validation where necessary (e.g., task description).
 *     *   Implement proper error handling using `try-catch`, `System.err`, and conditional checks.
 *     *   Structure the code clearly across the different classes.
 * 
 * **Expected Output Example:**
 * 
 * ```
 * --- Production Line Simulation ---
 * 
 * Select an action:
 * 1. Add New Task
 * 2. Process Next Task
 * 3. View Pending Tasks
 * 4. View Completed Tasks
 * 5. Exit
 * Enter your choice: 1
 * Enter task description: Build component A
 * Added Task #1: Build component A [PENDING]
 * 
 * Select an action:
 * 1. Add New Task
 * 2. Process Next Task
 * 3. View Pending Tasks
 * 4. View Completed Tasks
 * 5. Exit
 * Enter your choice: 1
 * Enter task description: Assemble unit
 * Added Task #2: Assemble unit [PENDING]
 * 
 * Select an action:
 * 1. Add New Task
 * 2. Process Next Task
 * 3. View Pending Tasks
 * 4. View Completed Tasks
 * 5. Exit
 * Enter your choice: 3
 * 
 * --- Pending Tasks ---
 * 1. Task #1: Build component A [PENDING]
 * 2. Task #2: Assemble unit [PENDING]
 * ---------------------
 * 
 * 
 * Select an action:
 * 1. Add New Task
 * 2. Process Next Task
 * 3. View Pending Tasks
 * 4. View Completed Tasks
 * 5. Exit
 * Enter your choice: 2
 * Processed and completed Task #1: Build component A [COMPLETED]
 * 
 * Select an action:
 * 1. Add New Task
 * 2. Process Next Task
 * 3. View Pending Tasks
 * 4. View Completed Tasks
 * 5. Exit
 * Enter your choice: 4
 * 
 * --- Completed Tasks ---
 * 1. Task #1: Build component A [COMPLETED]
 * -----------------------
 * 
 * Select an action:
 * 1. Add New Task
 * 2. Process Next Task
 * 3. View Pending Tasks
 * 4. View Completed Tasks
 * 5. Exit
 * Enter your choice: 2
 * Processed and completed Task #2: Assemble unit [COMPLETED]
 * 
 * Select an action:
 * 1. Add New Task
 * 2. Process Next Task
 * 3. View Pending Tasks
 * 4. View Completed Tasks
 * 5. Exit
 * Enter your choice: 2
 * Error: No pending tasks to process.
 * 
 * Select an action:
 * 1. Add New Task
 * 2. Process Next Task
 * 3. View Pending Tasks
 * 4. View Completed Tasks
 * 5. Exit
 * Enter your choice: abc
 * Invalid input. Please enter a number.
 * 
 * Select an action:
 * 1. Add New Task
 * 2. Process Next Task
 * 3. View Pending Tasks
 * 4. View Completed Tasks
 * 5. Exit
 * Enter your choice: 5
 * Exiting simulator. Goodbye!
 * ```
 * *(Note: Actual task IDs may vary based on implementation, but should be sequential starting from 1)*
 * 
 * **Evaluation:**
 * 
 * Your solution will be evaluated based on:
 * *   Correct implementation and usage of all required Java components (`Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.err`, `System.out`, `try-catch`).
 * *   Adherence to object-oriented principles (encapsulation).
 * *   Correct implementation of the production line logic (task flow).
 * *   Robust error handling and input validation.
 * *   Code clarity, readability, and adherence to best practices.
 *
 * EXPLANATION:
 * This solution implements a simple Production Line Simulation system demonstrating the required Java concepts and best practices.
 * 
 * 1.  **`Task` Class:** Represents a single work item. It includes a unique `taskId` (generated using `AtomicInteger` for thread-safety, although not strictly necessary in this single-threaded example, it's a good practice), a `description`, and a `TaskStatus` enum (`PENDING`, `PROCESSING`, `COMPLETED`). The constructor validates the description, throwing an `IllegalArgumentException` if invalid. Getters and a status setter provide controlled access to its state, adhering to encapsulation. The `toString()` method provides a user-friendly representation.
 * 
 * 2.  **`ProductionLineManager` Class:** Acts as the core logic handler.
 *     *   It uses a `java.util.Queue<Task>` (implemented by `java.util.LinkedList`) named `pendingTasks` to store tasks waiting for processing. The Queue's FIFO nature correctly simulates a production line where tasks are processed in the order they arrive.
 *     *   It uses a `java.util.List<Task>` (implemented by `java.util.ArrayList`) named `completedTasks` to store tasks that have finished processing. The List provides a dynamic array structure suitable for storing and iterating over completed items.
 *     *   `addTask(String description)`: Creates a `Task` object and adds it to the `pendingTasks` queue using `offer()`. It includes a `try-catch` block to handle the `IllegalArgumentException` potentially thrown by the `Task` constructor if the description is invalid, reporting the error via `System.err`.
 *     *   `processNextTask()`: Checks if the `pendingTasks` queue is empty. If so, it prints an error to `System.err`. Otherwise, it uses `poll()` to retrieve and remove the next task from the head of the queue, updates its status to `COMPLETED`, and adds it to the `completedTasks` list. Success messages are printed to `System.out`.
 *     *   `viewPendingTasks()` and `viewCompletedTasks()`: Iterate through the respective collections (`pendingTasks` and `completedTasks`) to print the details of each task using `System.out`. They also handle the case where a collection is empty. Iterating over the `Queue` is done using an enhanced for loop, which does not remove elements.
 * 
 * 3.  **`ProductionLineSimulator` Class:** Contains the `main` method and the user interaction loop.
 *     *   It uses `java.util.Scanner` to read user input for menu choices and task descriptions.
 *     *   A `while(true)` loop drives the simulation until the user chooses to exit.
 *     *   A `switch` statement directs the program flow based on the user's numeric input, calling the appropriate methods in the `ProductionLineManager`.
 *     *   Input validation for the menu choice is handled using a specific `try-catch(InputMismatchException e)` block around `scanner.nextInt()`. If the input is not an integer, an error is printed to `System.err`, the invalid input is consumed (`scanner.nextLine()`), and `continue` is used to restart the loop, prompting the user again.
 *     *   **Class-wide exception handling** is implemented by wrapping the entire `while(true)` loop within a `try-catch(Exception e)` block. This catches any unexpected `RuntimeException` or other `Exception` that might occur within the loop, preventing the program from crashing abruptly. It prints a generic error message to `System.err` and the stack trace (commented out by default but useful for debugging).
 *     *   A `finally` block ensures that the `Scanner` resource is closed properly, even if an exception occurs.
 *     *   `System.out` is used for displaying the menu, user prompts, task lists, and success messages.
 *     *   `System.err` is strictly used for printing error messages, as required.
 * 
 * 4.  **Best Practices:** The code demonstrates encapsulation by keeping data fields private and providing public methods for interaction. Meaningful names are used for classes, variables, methods, and enum constants. Basic Javadoc comments are included for methods. Input validation is performed for task descriptions and menu choices. Error conditions like an empty queue are explicitly checked and reported using `System.err`. The code is structured logically into three classes, each with a specific responsibility.
 * 
 * This solution effectively integrates all the required Java components within a practical scenario, showcasing understanding of collections, basic object-oriented design, user input handling, and robust error management.
 */

import java.util.Queue;
import java.util.LinkedList; // Common Queue implementation
import java.util.List;
import java.util.ArrayList;
import java.util.Scanner;
import java.util.InputMismatchException;
import java.util.concurrent.atomic.AtomicInteger; // For unique task IDs

// Represents a single task in the production line
class Task {
    // Static counter to generate unique task IDs
    private static final AtomicInteger idCounter = new AtomicInteger(0);

    private final int taskId;
    private String description;
    private TaskStatus status;

    // Enumeration for task status
    public enum TaskStatus {
        PENDING, PROCESSING, COMPLETED
    }

    /**
     * Constructs a new Task with a description.
     * Automatically assigns a unique ID and sets status to PENDING.
     * @param description The description of the task.
     * @throws IllegalArgumentException if the description is null or empty.
     */
    public Task(String description) {
        if (description == null || description.trim().isEmpty()) {
            throw new IllegalArgumentException("Task description cannot be null or empty.");
        }
        this.taskId = idCounter.incrementAndGet(); // Get next unique ID
        this.description = description.trim();
        this.status = TaskStatus.PENDING;
    }

    // --- Getters ---
    public int getTaskId() {
        return taskId;
    }

    public String getDescription() {
        return description;
    }

    public TaskStatus getStatus() {
        return status;
    }

    // --- Setter (primarily for status updates) ---
    public void setStatus(TaskStatus status) {
        this.status = status;
    }

    /**
     * Provides a string representation of the Task.
     * @return A formatted string including task ID, description, and status.
     */
    @Override
    public String toString() {
        return String.format("Task #%d: %s [%s]", taskId, description, status);
    }
}

// Manages the queue of pending tasks and the list of completed tasks
class ProductionLineManager {
    // Queue for tasks waiting to be processed (FIFO)
    private Queue<Task> pendingTasks;
    // List for tasks that have been completed
    private List<Task> completedTasks;

    /**
     * Constructs a ProductionLineManager, initializing task collections.
     */
    public ProductionLineManager() {
        // LinkedList is a common implementation of Queue
        this.pendingTasks = new LinkedList<>();
        // ArrayList is a common implementation of List
        this.completedTasks = new ArrayList<>();
    }

    /**
     * Adds a new task to the pending queue.
     * @param description The description of the task.
     */
    public void addTask(String description) {
        try {
            // Create a new Task object; constructor handles description validation
            Task newTask = new Task(description);
            // Add the task to the end of the pending queue
            pendingTasks.offer(newTask); // offer is generally preferred over add for queues
            System.out.println("Added " + newTask);
        } catch (IllegalArgumentException e) {
            // Catch validation errors from Task constructor and report using System.err
            System.err.println("Error adding task: " + e.getMessage());
        }
    }

    /**
     * Processes the next task from the pending queue.
     * Removes the task from the queue, updates its status, and moves it to the completed list.
     */
    public void processNextTask() {
        // Check if the pending queue is empty before attempting to process
        if (pendingTasks.isEmpty()) {
            System.err.println("Error: No pending tasks to process.");
            return; // Exit the method if queue is empty
        }

        // Retrieve and remove the head of the queue (the next task to process)
        Task taskToProcess = pendingTasks.poll();

        // Although poll returns null if queue is empty, we already checked.
        // This check is mostly for safety or if logic were more complex.
        if (taskToProcess != null) {
            // Update the task status to COMPLETED
            taskToProcess.setStatus(Task.TaskStatus.COMPLETED);
            // Add the processed task to the completed list
            completedTasks.add(taskToProcess);
            System.out.println("Processed and completed " + taskToProcess);
        }
    }

    /**
     * Displays all tasks currently in the pending queue.
     */
    public void viewPendingTasks() {
        System.out.println("\n--- Pending Tasks ---");
        // Check if the pending queue is empty
        if (pendingTasks.isEmpty()) {
            System.out.println("No tasks are pending.");
        } else {
            // Iterate through the queue without removing elements to display them
            int i = 1;
            for (Task task : pendingTasks) {
                System.out.println(i++ + ". " + task);
            }
        }
        System.out.println("---------------------\n");
    }

    /**
     * Displays all tasks that have been completed.
     */
    public void viewCompletedTasks() {
        System.out.println("\n--- Completed Tasks ---");
        // Check if the completed list is empty
        if (completedTasks.isEmpty()) {
            System.out.println("No tasks have been completed yet.");
        } else {
            // Iterate through the list to display completed tasks
            int i = 1;
            for (Task task : completedTasks) {
                System.out.println(i++ + ". " + task);
            }
        }
        System.out.println("-----------------------\n");
    }
}

// Main class to run the production line simulation
public class ProductionLineSimulator {

    public static void main(String[] args) {
        // Use Scanner for reading input from the console
        Scanner scanner = new Scanner(System.in);
        // Create an instance of the manager
        ProductionLineManager manager = new ProductionLineManager();

        System.out.println("--- Production Line Simulation ---");

        // Class-wide exception handling: Wrap the main simulation loop in a try-catch
        try {
            // Main application loop
            while (true) {
                printMenu(); // Display menu options
                System.out.print("Enter your choice: ");

                int choice;
                try {
                    // Attempt to read integer input for menu choice
                    choice = scanner.nextInt();
                    scanner.nextLine(); // Consume the newline character left by nextInt()
                } catch (InputMismatchException e) {
                    // Handle cases where the user enters non-integer input
                    System.err.println("Invalid input. Please enter a number.");
                    scanner.nextLine(); // Consume the invalid input to prevent infinite loop
                    continue; // Skip the rest of the loop iteration and show menu again
                }

                // Use a switch statement to handle different menu options
                switch (choice) {
                    case 1:
                        // Add New Task
                        System.out.print("Enter task description: ");
                        String description = scanner.nextLine();
                        manager.addTask(description); // Call manager method to add task
                        break;
                    case 2:
                        // Process Next Task
                        manager.processNextTask(); // Call manager method to process task
                        break;
                    case 3:
                        // View Pending Tasks
                        manager.viewPendingTasks(); // Call manager method to view pending
                        break;
                    case 4:
                        // View Completed Tasks
                        manager.viewCompletedTasks(); // Call manager method to view completed
                        break;
                    case 5:
                        // Exit the simulator
                        System.out.println("Exiting simulator. Goodbye!");
                        return; // Terminate the main method and program
                    default:
                        // Handle invalid menu choices (numbers outside 1-5)
                        System.err.println("Invalid choice. Please enter a number between 1 and 5.");
                }
            }
        } catch (Exception e) {
            // This broad catch block handles any other unexpected runtime exceptions
            System.err.println("An unexpected error occurred during simulation: " + e.getMessage());
            // Optionally print stack trace for debugging purposes
            // e.printStackTrace();
        } finally {
            // The finally block ensures the scanner is closed regardless of whether
            // the loop exits normally or due to an exception.
            if (scanner != null) {
                scanner.close();
            }
        }
    }

    /**
     * Prints the main menu options to the console.
     */
    private static void printMenu() {
        System.out.println("\nSelect an action:");
        System.out.println("1. Add New Task");
        System.out.println("2. Process Next Task");
        System.out.println("3. View Pending Tasks");
        System.out.println("4. View Completed Tasks");
        System.out.println("5. Exit");
    }
}
