/*
 * Exam Question #950
 * Generated on: 2025-05-12 17:04:15
 * Generated by: Account 1
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Priority Task Management System
 * 
 * **Objective:** Design and implement a console-based Task Management System that prioritizes tasks and demonstrates proficiency in using core Java data structures and control flow mechanisms.
 * 
 * **Scenario:** You are building a simple system for managing tasks for a small team. Tasks have different priority levels, and the system must ensure that higher priority tasks are addressed before lower priority ones.
 * 
 * **Requirements:**
 * 
 * 1.  **Task Representation:** Create a `Task` class with attributes:
 *     *   A unique integer ID (automatically assigned).
 *     *   A String description.
 *     *   A priority level (e.g., HIGH, MEDIUM, LOW). Use an `enum` for priority.
 *     *   A boolean indicating if the task is completed.
 *     *   Include appropriate getters and a method to mark the task as completed.
 * 
 * 2.  **Task Management Logic:** Create a `TaskManager` class responsible for managing tasks. It should:
 *     *   Maintain separate collections for pending tasks based on their priority.
 *     *   Maintain a collection for completed tasks.
 *     *   Provide methods for:
 *         *   Adding a new task with a description and priority. The task should be added to the appropriate pending collection.
 *         *   Processing the next task: This method should identify the highest priority pending task (High > Medium > Low). If multiple tasks have the same highest priority, process the one added earliest (FIFO). The processed task should be marked as completed and moved to the completed collection. If no tasks are pending, report it.
 *         *   Listing all pending tasks: Display tasks grouped by priority (High, then Medium, then Low).
 *         *   Listing all completed tasks.
 * 
 * 3.  **User Interface:** Create a main application class (e.g., `TaskManagerApp`) with a `main` method that provides a command-line interface:
 *     *   Present a menu to the user with options: Add Task, Process Next Task, List Pending Tasks, List Completed Tasks, Exit.
 *     *   Use `java.util.Scanner` to read user input (menu choice, task details).
 *     *   Use a `switch` statement to handle the user's menu choice.
 * 
 * 4.  **Required Java Components:** Your solution MUST explicitly use ALL of the following:
 *     *   `java.util.Queue` (at least one instance, used for pending tasks)
 *     *   `java.util.ArrayList` (at least one instance)
 *     *   `java.util.List` interface (at least one collection must be declared using this interface type)
 *     *   `java.util.Scanner`
 *     *   `switch` statement
 *     *   `System.err` (exclusively for error messages)
 *     *   `System.out` (for all normal output, including menu, prompts, success messages, task listings)
 *     *   Class-wide exception handling with `try-catch` blocks (Implement robust error handling, particularly for user input like non-integer entries or invalid choices, using `try-catch`. A `try-catch` block should wrap the main application loop or a significant portion of its logic to handle potential unexpected runtime errors gracefully).
 * 
 * 5.  **Best Practices:**
 *     *   Apply proper encapsulation (private fields, public methods) in your classes.
 *     *   Use meaningful names for variables, methods, and classes.
 *     *   Include appropriate comments and basic documentation (e.g., Javadoc-style comments for classes/methods).
 *     *   Implement input validation to handle incorrect data types (e.g., non-numeric input for choices) and out-of-range values.
 *     *   Provide clear and informative error messages using `System.err`.
 *     *   Structure your code logically using separate classes.
 * 
 * **Expected Output:**
 * The program should interact with the user via the console, displaying a menu and responding to commands. Error messages must appear on `System.err`, while all other output (menu, prompts, task details) must use `System.out`. The interaction should resemble the example flow provided in the problem description.
 *
 * EXPLANATION:
 * This solution implements a simple Priority Task Management System using multiple classes and demonstrating the required Java concepts.
 * 
 * 1.  **`Task` Class:**
 *     *   Represents a single task with an automatically generated unique ID (`nextId` static counter).
 *     *   Uses an `enum Priority` for clarity and type safety.
 *     *   Includes standard getters and a `markCompleted()` method.
 *     *   `toString()` provides a convenient string representation for printing.
 *     *   Uses `Objects.requireNonNull` for basic constructor validation, a good practice.
 * 
 * 2.  **`TaskManager` Class:**
 *     *   Uses three `java.util.Queue<Task>` instances (`highPriorityQueue`, `mediumPriorityQueue`, `lowPriorityQueue`) to store pending tasks. `java.util.LinkedList` is used as the concrete implementation because it implements the `Queue` interface and is suitable for FIFO operations.
 *     *   Uses a `java.util.List<Task>` instance (`completedTasksList`) to store completed tasks. `java.util.ArrayList` is used as the concrete implementation, fulfilling the requirement to use both `ArrayList` and declare a collection using the `List` interface type.
 *     *   `addTask()`: Creates a new `Task` object and uses a `switch` statement based on priority to add it to the correct queue using the `offer()` method.
 *     *   `processNextTask()`: Checks the queues in strict priority order (High -> Medium -> Low). It uses `poll()` to retrieve and *remove* the head of the first non-empty queue. If a task is retrieved, it's marked completed and added to the `completedTasksList`. It returns the processed task or `null` if no tasks were pending.
 *     *   `listPendingTasks()`: Iterates through each priority queue (without removing elements) and prints the tasks.
 *     *   `listCompletedTasks()`: Iterates through the `completedTasksList` and prints completed tasks.
 * 
 * 3.  **`TaskManagerApp` Class:**
 *     *   Contains the `main` method, which serves as the application's entry point and command-line interface.
 *     *   A `java.util.Scanner` is used to read user input.
 *     *   A `while(running)` loop keeps the application active until the user chooses to exit.
 *     *   A `printMenu()` helper method displays the options using `System.out`.
 *     *   A `switch` statement handles the user's valid menu choice, directing the flow to the appropriate `TaskManager` method or the exit logic.
 *     *   **Error Handling (`try-catch` and `System.err`):**
 *         *   Specific `try-catch(InputMismatchException e)` blocks are used around `scanner.nextInt()` calls (for menu choice and priority choice) to catch non-integer input. When caught, an error message is printed to `System.err`, the invalid input is consumed using `scanner.nextLine()`, and the loop continues.
 *         *   Input validation checks (`choice < 1 || choice > 5`, `description.trim().isEmpty()`, invalid priority number) are performed, printing error messages to `System.err` for invalid inputs.
 *         *   The result of `manager.processNextTask()` is checked. If `null` (meaning no tasks were available), an error message is printed to `System.err`.
 *         *   A broad `try { ... } catch (Exception e) { ... }` block wraps the main `while` loop. This provides "class-wide" exception handling, catching any unexpected runtime errors that might occur anywhere within the application's main execution flow (not specifically handled by inner catches). This ensures the program doesn't crash unexpectedly, printing an error to `System.err` and the stack trace before the `finally` block executes.
 *         *   A `finally` block is used to ensure the `Scanner` resource is closed properly, releasing system resources, regardless of whether the loop finishes normally or an exception occurs.
 *     *   All normal messages, prompts, and task listings are printed using `System.out`.
 * 
 * This solution effectively integrates the required Java components within a practical scenario, demonstrating object-oriented design, data structure usage, control flow, and robust error handling.
 */

package com.exam.taskmanager;

import java.util.ArrayList;
import java.util.InputMismatchException;
import java.util.LinkedList;
import java.util.List;
import java.util.Objects;
import java.util.Queue;
import java.util.Scanner;

// --- Task Class ---

/**
 * Represents a single task with a unique ID, description, priority, and completion status.
 */
class Task {
    // Static counter to generate unique IDs for each task
    private static int nextId = 1;

    private int id;
    private String description;
    private Priority priority;
    private boolean isCompleted;

    /**
     * Constructs a new Task.
     *
     * @param description The description of the task. Must not be null or empty.
     * @param priority    The priority level of the task. Must not be null.
     * @throws NullPointerException If description or priority is null.
     */
    public Task(String description, Priority priority) {
        // Use Objects.requireNonNull for null validation - good practice
        this.description = Objects.requireNonNull(description, "Task description cannot be null");
        this.priority = Objects.requireNonNull(priority, "Task priority cannot be null");
        this.id = nextId++; // Assign unique ID and increment counter
        this.isCompleted = false; // Task is initially not completed
    }

    // --- Getters ---

    public int getId() {
        return id;
    }

    public String getDescription() {
        return description;
    }

    public Priority getPriority() {
        return priority;
    }

    public boolean isCompleted() {
        return isCompleted;
    }

    /**
     * Marks the task as completed.
     */
    public void markCompleted() {
        this.isCompleted = true;
    }

    /**
     * Provides a string representation of the Task.
     *
     * @return Formatted string containing task details.
     */
    @Override
    public String toString() {
        return String.format("Task ID: %d, Description: %s, Priority: %s, Status: %s",
                             id, description, priority, isCompleted ? "Completed" : "Pending");
    }

    /**
     * Enum to define task priority levels.
     */
    public enum Priority {
        HIGH, MEDIUM, LOW
    }
}

// --- TaskManager Class ---

/**
 * Manages a collection of tasks, organized by priority queues for pending tasks
 * and an ArrayList for completed tasks.
 */
class TaskManager {
    // Queues for pending tasks, separated by priority.
    // LinkedList is used as it implements the Queue interface and is efficient for FIFO operations.
    private Queue<Task> highPriorityQueue = new LinkedList<>();
    private Queue<Task> mediumPriorityQueue = new LinkedList<>();
    private Queue<Task> lowPriorityQueue = new LinkedList<>();

    // List for completed tasks.
    // Declared using the List interface type, implemented by ArrayList.
    private List<Task> completedTasksList = new ArrayList<>();

    /**
     * Adds a new task to the appropriate priority queue based on its priority.
     * Prints a confirmation message to System.out.
     *
     * @param description The description of the task.
     * @param priority    The priority of the task.
     */
    public void addTask(String description, Task.Priority priority) {
        Task newTask = new Task(description, priority); // Task ID is assigned in the constructor
        switch (priority) {
            case HIGH:
                highPriorityQueue.offer(newTask); // offer is preferred over add in queues
                break;
            case MEDIUM:
                mediumPriorityQueue.offer(newTask);
                break;
            case LOW:
                lowPriorityQueue.offer(newTask);
                break;
            default:
                // This case should ideally not be reached if Priority enum is used correctly
                System.err.println("Internal Error: Unknown priority encountered for task " + newTask.getId());
                break;
        }
        System.out.println("Task added: " + newTask.getDescription() + " (Priority: " + newTask.getPriority() + ")");
    }

    /**
     * Processes the next available task based on priority (High > Medium > Low).
     * Within the same priority, tasks are processed FIFO.
     * The processed task is marked as completed and moved to the completed list.
     * Prints a success message to System.out if a task is processed.
     * Returns the processed task or null if no tasks are available.
     *
     * @return The completed Task, or null if no tasks are available in any queue.
     */
    public Task processNextTask() {
        Task taskToProcess = null;

        // Check queues in priority order (High first, then Medium, then Low)
        // poll() retrieves and removes the head of the queue, returning null if the queue is empty.
        if (!highPriorityQueue.isEmpty()) {
            taskToProcess = highPriorityQueue.poll();
        } else if (!mediumPriorityQueue.isEmpty()) {
            taskToProcess = mediumPriorityQueue.poll();
        } else if (!lowPriorityQueue.isEmpty()) {
            taskToProcess = lowPriorityQueue.poll();
        }

        // If a task was found and retrieved from a queue
        if (taskToProcess != null) {
            taskToProcess.markCompleted(); // Mark the task as completed
            completedTasksList.add(taskToProcess); // Add the task to the list of completed tasks
            System.out.println("Processed task: " + taskToProcess.getDescription() + " (ID: " + taskToProcess.getId() + ")");
        }
        // If taskToProcess is null, it means no tasks were available in any queue.
        // The caller is responsible for printing an error message in this case.

        return taskToProcess;
    }

    /**
     * Lists all pending tasks currently in the priority queues.
     * Tasks are listed grouped by priority: High first, then Medium, then Low.
     * Prints output to System.out.
     */
    public void listPendingTasks() {
        System.out.println("\n--- Pending Tasks ---");
        boolean foundPending = false; // Flag to check if any pending task was found

        // List High Priority tasks
        if (!highPriorityQueue.isEmpty()) {
            System.out.println("  High Priority:");
            // Iterate over the queue without removing elements
            for (Task task : highPriorityQueue) {
                System.out.println("    " + task);
                foundPending = true;
            }
        } else {
             System.out.println("  No high priority tasks.");
        }

        // List Medium Priority tasks
        if (!mediumPriorityQueue.isEmpty()) {
            System.out.println("  Medium Priority:");
            for (Task task : mediumPriorityQueue) {
                System.out.println("    " + task);
                foundPending = true;
            }
        } else {
             System.out.println("  No medium priority tasks.");
        }

        // List Low Priority tasks
        if (!lowPriorityQueue.isEmpty()) {
            System.out.println("  Low Priority:");
            for (Task task : lowPriorityQueue) {
                System.out.println("    " + task);
                foundPending = true;
            }
        } else {
             System.out.println("  No low priority tasks.");
        }

        // Optional: A summary line if no tasks at all were found.
        // if (!foundPending) {
        //     System.out.println("  No pending tasks in total.");
        // }
        System.out.println("---------------------\n");
    }

    /**
     * Lists all completed tasks stored in the completed tasks list.
     * Prints output to System.out.
     */
    public void listCompletedTasks() {
        System.out.println("\n--- Completed Tasks ---");
        if (completedTasksList.isEmpty()) {
            System.out.println("  No completed tasks.");
        } else {
            // Iterate over the List of completed tasks
            for (Task task : completedTasksList) {
                System.out.println("  " + task);
            }
        }
        System.out.println("-----------------------\n");
    }
}

// --- Main Application Class ---

/**
 * Main application class for the Task Management System.
 * Provides a command-line interface for interacting with the TaskManager.
 * Demonstrates usage of Scanner, switch, Queue, List, ArrayList, System.out, System.err, and try-catch.
 */
public class TaskManagerApp {

    public static void main(String[] args) {
        TaskManager manager = new TaskManager();
        Scanner scanner = null; // Declare scanner outside try for finally block access
        boolean running = true;

        System.out.println("--- Task Management System ---");

        // Class-wide exception handling wrapping the main application logic.
        // This catches any unexpected exceptions that might occur during execution
        // and ensures the application exits gracefully after reporting the error.
        try {
            scanner = new Scanner(System.in); // Initialize scanner inside try

            while (running) {
                printMenu(); // Display the menu options
                int choice = -1; // Variable to store user's menu choice

                // --- Input Reading and Validation with try-catch ---
                try {
                    System.out.print("Enter your choice: ");
                    choice = scanner.nextInt(); // Read the integer choice
                    scanner.nextLine(); // Consume the leftover newline character

                    // Validate the choice range immediately
                    if (choice < 1 || choice > 5) {
                         System.err.println("Invalid choice. Please enter a number between 1 and 5.");
                         continue; // Skip the rest of the loop body and show the menu again
                    }

                } catch (InputMismatchException e) {
                    // Handles cases where the user enters non-integer input for the menu choice
                    System.err.println("Invalid input. Please enter a number.");
                    scanner.nextLine(); // Consume the invalid input to prevent an infinite loop
                    continue; // Skip the rest of the loop body and show the menu again
                } catch (Exception e) {
                    // Catch any other unexpected errors during the menu input reading process
                    System.err.println("An error occurred while reading input: " + e.getMessage());
                    e.printStackTrace(); // Print stack trace for debugging
                    continue; // Or consider breaking the loop if input is critical
                }

                // --- Switch statement to handle validated menu choice ---
                switch (choice) {
                    case 1: // Add New Task
                        System.out.print("Enter task description: ");
                        String description = scanner.nextLine();

                        // Basic input validation for description
                        if (description == null || description.trim().isEmpty()) {
                            System.err.println("Task description cannot be empty. Task not added.");
                            break; // Exit this switch case
                        }

                        System.out.println("Select priority:");
                        System.out.println("  1. HIGH");
                        System.out.println("  2. MEDIUM");
                        System.out.println("  3. LOW");
                        System.out.print("Enter priority choice (1-3): ");

                        Task.Priority priority = null;
                        // Specific try-catch for reading and validating priority input
                        try {
                            int priorityChoice = scanner.nextInt();
                            scanner.nextLine(); // Consume newline

                            switch (priorityChoice) {
                                case 1:
                                    priority = Task.Priority.HIGH;
                                    break;
                                case 2:
                                    priority = Task.Priority.MEDIUM;
                                    break;
                                case 3:
                                    priority = Task.Priority.LOW;
                                    break;
                                default:
                                    System.err.println("Invalid priority choice. Please enter 1, 2, or 3. Task not added.");
                                    // 'priority' remains null, so the task won't be added below
                                    break; // Exit the inner switch
                            }

                            // Only add task if a valid priority was successfully determined
                            if (priority != null) {
                                manager.addTask(description, priority);
                            }

                        } catch (InputMismatchException e) {
                            // Handle non-integer input for priority choice
                            System.err.println("Invalid input for priority. Please enter a number (1-3). Task not added.");
                            scanner.nextLine(); // Consume invalid input
                        } catch (Exception e) {
                             // Catch any other unexpected errors during priority reading
                            System.err.println("An error occurred while reading priority: " + e.getMessage());
                            e.printStackTrace(); // Print stack trace for debugging
                        }
                        break; // Exit the outer switch case (case 1)

                    case 2: // Process Next Task
                        Task processedTask = manager.processNextTask();
                        // Check the return value to see if a task was processed
                        if (processedTask == null) {
                            System.err.println("No tasks available to process.");
                        }
                        // Success message is printed inside TaskManager's processNextTask method
                        break; // Exit the switch case

                    case 3: // List Pending Tasks
                        manager.listPendingTasks();
                        break; // Exit the switch case

                    case 4: // List Completed Tasks
                        manager.listCompletedTasks();
                        break; // Exit the switch case

                    case 5: // Exit
                        System.out.println("Exiting Task Management System. Goodbye!");
                        running = false; // Set flag to terminate the main loop
                        break; // Exit the switch case

                    // The default case for the switch is implicitly handled by the initial choice validation
                    // (if choice < 1 || choice > 5) check before the switch.
                }
            }
        } catch (Exception e) {
            // This is the "class-wide" catch block. It handles any exceptions
            // that were not specifically caught by the inner try-catch blocks
            // or in the called methods. It prevents the program from crashing
            // due to unforeseen errors during the main execution flow.
            System.err.println("\n!!! An unexpected critical error occurred. The system is shutting down. !!!");
            System.err.println("Error details: " + e.getMessage());
            e.printStackTrace(); // Print stack trace for debugging the unexpected error
        } finally {
            // The finally block is guaranteed to execute whether the try block finishes normally
            // or an exception is caught. It's used here to ensure the Scanner resource is closed,
            // releasing the system resources it holds.
            if (scanner != null) {
                scanner.close();
            }
            System.out.println("--- System Shut Down Complete ---");
        }
    }

    /**
     * Prints the main menu options to the console using System.out.
     */
    private static void printMenu() {
        System.out.println("\n--- Menu ---");
        System.out.println("1. Add New Task");
        System.out.println("2. Process Next Task");
        System.out.println("3. List Pending Tasks");
        System.out.println("4. List Completed Tasks");
        System.out.println("5. Exit");
        System.out.println("------------");
    }
}
