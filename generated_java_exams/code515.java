/*
 * Exam Question #515
 * Generated on: 2025-05-11 23:22:40
 * Generated by: Account 4
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Task Management System
 * 
 * **Objective:** Implement a simple console-based Task Management System that allows users to add, process, and view tasks. This task requires demonstrating proficiency in using core Java collections, input handling, control flow, and exception handling.
 * 
 * **Requirements:**
 * 
 * 1.  **Task Representation:** Create a class named `Task` with appropriate private fields to store task details (e.g., a description) and a public method to mark the task as completed. Include a constructor and necessary getter methods.
 * 2.  **Data Structures:**
 *     *   Use a `java.util.Queue<Task>` to store tasks that are pending processing. Tasks should be processed in the order they were added (FIFO).
 *     *   Use a `java.util.ArrayList<Task>` (declared using the `java.util.List` interface) to store tasks that have been completed.
 * 3.  **User Interaction:**
 *     *   Use `java.util.Scanner` to read user input from the console.
 *     *   Present a menu of options to the user:
 *         1.  Add New Task
 *         2.  Process Next Task
 *         3.  View Pending Tasks
 *         4.  View Completed Tasks
 *         5.  Exit
 * 4.  **Control Flow:** Use a `switch` statement to handle the user's menu selection. The system should loop, displaying the menu and processing input until the user chooses to exit.
 * 5.  **Output:**
 *     *   Use `System.out` for displaying the menu, successful operations, and task lists.
 *     *   Use `System.err` to print error messages (e.g., invalid input, attempting to process a task when the queue is empty).
 * 6.  **Error Handling:**
 *     *   Implement robust input validation. Handle cases where the user enters non-integer input for the menu choice or provides an empty task description.
 *     *   Implement class-wide exception handling using a `try-catch` block around the main application loop to catch unexpected errors and prevent the program from crashing abruptly.
 * 7.  **Best Practices:**
 *     *   Apply proper encapsulation for the `Task` class fields.
 *     *   Use meaningful variable and method names.
 *     *   Include appropriate comments to explain complex parts of the code.
 *     *   Structure the code logically within classes and methods.
 * 
 * **Instructions:**
 * 
 * Write the complete Java code for the Task Management System. Ensure it compiles and runs correctly from a `main` method. Your solution should clearly demonstrate the usage of all specified Java components and adhere to the best practices listed.
 * 
 * **Expected Output Structure (Examples):**
 * 
 * ```
 * --- Task Management Menu ---
 * 1. Add New Task
 * 2. Process Next Task
 * 3. View Pending Tasks
 * 4. View Completed Tasks
 * 5. Exit
 * Enter your choice: 1
 * Enter task description: Learn Java Collections
 * Task added successfully.
 * 
 * --- Task Management Menu ---
 * ...
 * Enter your choice: 3
 * Pending Tasks:
 * - Learn Java Collections
 * 
 * --- Task Management Menu ---
 * ...
 * Enter your choice: 2
 * Processing task: Learn Java Collections
 * Task marked as completed.
 * 
 * --- Task Management Menu ---
 * ...
 * Enter your choice: 3
 * Pending Tasks:
 * (Queue is empty)
 * 
 * --- Task Management Menu ---
 * ...
 * Enter your choice: 4
 * Completed Tasks:
 * - Learn Java Collections (Completed)
 * 
 * --- Task Management Menu ---
 * ...
 * Enter your choice: 99
 * Error: Invalid menu choice. Please enter a number between 1 and 5.
 * 
 * --- Task Management Menu ---
 * ...
 * Enter your choice: 2
 * Error: No pending tasks to process.
 * 
 * --- Task Management Menu ---
 * ...
 * Enter your choice: 5
 * Exiting Task Management System.
 * ```
 * 
 * *(Note: The exact output formatting for task lists can vary, but should clearly distinguish pending and completed tasks.)*
 *
 * EXPLANATION:
 * The solution implements a simple console-based Task Management System as required by the exam task. It effectively utilizes the specified Java components and adheres to best practices.
 * 
 * 1.  **`Task` Class:** This class encapsulates the data and behavior of a single task. It has a `private String description` and a `private boolean isCompleted` field, demonstrating encapsulation. The constructor validates the description, throwing an `IllegalArgumentException` if it's empty. `markCompleted()` modifies the internal state. `toString()` provides a convenient representation for printing.
 * 
 * 2.  **Data Structures:**
 *     *   A `java.util.Queue<Task>` named `taskQueue` is used for pending tasks. `LinkedList` is chosen as a concrete implementation of the `Queue` interface, suitable for FIFO operations. `offer()` is used for adding (non-blocking), and `poll()` is used for retrieving and removing the head (returns `null` if empty).
 *     *   A `java.util.ArrayList<Task>` named `completedTasks` is used for completed tasks. It is declared using the `java.util.List` interface (`List<Task> completedTasks = new ArrayList<>();`), demonstrating polymorphism and coding to the interface.
 * 
 * 3.  **`TaskProcessor` Class:** This class contains the main application logic.
 *     *   It holds instances of the `taskQueue`, `completedTasks`, and `scanner`.
 *     *   `displayMenu()` is a helper method for printing the options.
 *     *   `addTask()` reads a task description from the user, creates a `Task` object, and adds it to the `taskQueue` using `offer()`. It includes input validation for the description using a `try-catch` block around the `Task` constructor call.
 *     *   `processNextTask()` uses `poll()` to get the next task from the `taskQueue`. If a task is retrieved (`poll()` doesn't return `null`), it marks the task as completed using `nextTask.markCompleted()` and adds it to the `completedTasks` list. If the queue is empty, it prints an error to `System.err`.
 *     *   `viewPendingTasks()` and `viewCompletedTasks()` iterate through the respective collections (`taskQueue` and `completedTasks`) and print the task details. `taskQueue.forEach()` is used to iterate without removing elements.
 *     *   `main()` is the entry point, creating a `TaskProcessor` instance and calling its `run()` method.
 * 
 * 4.  **`Scanner` and Input Handling:** `java.util.Scanner` is used to read user input. Reading the integer choice (`scanner.nextInt()`) and then consuming the rest of the line (`scanner.nextLine()`) is crucial to handle mixed input types correctly in subsequent reads. A `try-catch(InputMismatchException)` block is specifically used around `scanner.nextInt()` to handle cases where the user enters non-numeric input for the menu choice, preventing a crash and allowing the loop to continue.
 * 
 * 5.  **`switch` Statement:** The `run()` method uses a `switch` statement based on the user's integer choice (`choice`) to direct the program flow to the appropriate method (`addTask`, `processNextTask`, etc.). A `default` case handles invalid integer choices.
 * 
 * 6.  **`System.out` and `System.err`:** `System.out.println()` is used for normal output like the menu, success messages, and task lists. `System.err.println()` is strictly used for printing error messages, such as invalid input or operational errors (e.g., trying to process from an empty queue), making errors visually distinct in the console output.
 * 
 * 7.  **Exception Handling (`try-catch`):**
 *     *   A specific `try-catch(InputMismatchException)` block handles invalid integer input for the menu choice.
 *     *   A `try-catch(IllegalArgumentException)` block is used within `addTask()` to handle the validation of the task description performed by the `Task` constructor.
 *     *   A broad `try-catch(Exception e)` block is wrapped around the entire `while(running)` loop in the `run()` method. This serves as a class-wide exception handler, catching any unexpected runtime exceptions that might occur during the program's execution and printing an error message and stack trace to `System.err`, ensuring the program terminates gracefully rather than crashing abruptly.
 *     *   A `finally` block is used to ensure the `Scanner` is closed, releasing system resources.
 * 
 * 8.  **Best Practices:** The code demonstrates encapsulation in the `Task` class, uses meaningful names (`taskQueue`, `completedTasks`, `processNextTask`), includes comments explaining the purpose of classes and methods, and structures the application logic cleanly within the `TaskProcessor` class. Using `List` interface for `completedTasks` shows good design principle.
 * 
 * This solution effectively integrates all required components into a functional, robust, and well-structured application, demonstrating an advanced understanding of core Java concepts.
 */

import java.util.Queue;
import java.util.LinkedList; // LinkedList implements Queue
import java.util.List;
import java.util.ArrayList;
import java.util.Scanner;
import java.util.InputMismatchException;

// Represents a single task
class Task {
    private String description;
    private boolean isCompleted;

    // Constructor
    public Task(String description) {
        if (description == null || description.trim().isEmpty()) {
            throw new IllegalArgumentException("Task description cannot be empty.");
        }
        this.description = description.trim();
        this.isCompleted = false;
    }

    // Getter for description
    public String getDescription() {
        return description;
    }

    // Getter for completion status
    public boolean isCompleted() {
        return isCompleted;
    }

    // Method to mark task as completed
    public void markCompleted() {
        this.isCompleted = true;
    }

    // String representation of the task
    @Override
    public String toString() {
        return description + (isCompleted ? " (Completed)" : "");
    }
}

// Manages the collection of tasks
public class TaskProcessor {
    private Queue<Task> taskQueue; // Queue for pending tasks
    private List<Task> completedTasks; // List for completed tasks
    private Scanner scanner; // Scanner for user input

    // Constructor
    public TaskProcessor() {
        this.taskQueue = new LinkedList<>(); // LinkedList implements Queue
        this.completedTasks = new ArrayList<>(); // ArrayList implements List
        this.scanner = new Scanner(System.in);
    }

    // Displays the main menu to the user
    private void displayMenu() {
        System.out.println("\n--- Task Management Menu ---");
        System.out.println("1. Add New Task");
        System.out.println("2. Process Next Task");
        System.out.println("3. View Pending Tasks");
        System.out.println("4. View Completed Tasks");
        System.out.println("5. Exit");
        System.out.print("Enter your choice: ");
    }

    // Adds a new task to the pending queue
    private void addTask() {
        System.out.print("Enter task description: ");
        String description = scanner.nextLine();
        try {
            Task newTask = new Task(description);
            taskQueue.offer(newTask); // offer is preferred over add for queues
            System.out.println("Task added successfully.");
        } catch (IllegalArgumentException e) {
            System.err.println("Error: " + e.getMessage());
        }
    }

    // Processes the next task in the queue
    private void processNextTask() {
        Task nextTask = taskQueue.poll(); // poll retrieves and removes the head
        if (nextTask != null) {
            System.out.println("Processing task: " + nextTask.getDescription());
            nextTask.markCompleted();
            completedTasks.add(nextTask);
            System.out.println("Task marked as completed.");
        } else {
            System.err.println("Error: No pending tasks to process.");
        }
    }

    // Displays all tasks currently in the pending queue
    private void viewPendingTasks() {
        System.out.println("\nPending Tasks:");
        if (taskQueue.isEmpty()) {
            System.out.println("(Queue is empty)");
        } else {
            // Iterate through the queue without removing elements
            taskQueue.forEach(task -> System.out.println("- " + task.getDescription()));
        }
    }

    // Displays all tasks in the completed list
    private void viewCompletedTasks() {
        System.out.println("\nCompleted Tasks:");
        if (completedTasks.isEmpty()) {
            System.out.println("(No tasks completed yet)");
        } else {
            completedTasks.forEach(task -> System.out.println("- " + task.toString())); // toString shows completed status
        }
    }

    // Main method to run the Task Processor application
    public static void main(String[] args) {
        TaskProcessor processor = new TaskProcessor();
        processor.run();
    }

    // The main application loop
    public void run() {
        boolean running = true;
        // Class-wide try-catch block for general exception handling
        try {
            while (running) {
                displayMenu();
                int choice = -1;
                try {
                    // Read integer choice, handle non-integer input
                    choice = scanner.nextInt();
                } catch (InputMismatchException e) {
                    System.err.println("Error: Invalid input. Please enter a number.");
                    scanner.next(); // Consume the invalid input to prevent infinite loop
                    continue; // Skip the rest of the loop iteration
                } finally {
                    // Consume the rest of the line after reading the integer
                    // This is crucial to prevent issues with subsequent nextLine() calls
                    scanner.nextLine();
                }

                // Use switch statement for menu options
                switch (choice) {
                    case 1:
                        addTask();
                        break;
                    case 2:
                        processNextTask();
                        break;
                    case 3:
                        viewPendingTasks();
                        break;
                    case 4:
                        viewCompletedTasks();
                        break;
                    case 5:
                        running = false;
                        System.out.println("Exiting Task Management System.");
                        break;
                    default:
                        System.err.println("Error: Invalid menu choice. Please enter a number between 1 and 5.");
                }
            }
        } catch (Exception e) {
            // Catch any unexpected exception during runtime
            System.err.println("\nAn unexpected error occurred:");
            e.printStackTrace(System.err); // Print stack trace to System.err
        } finally {
            // Ensure the scanner is closed
            if (scanner != null) {
                scanner.close();
            }
        }
    }
}
