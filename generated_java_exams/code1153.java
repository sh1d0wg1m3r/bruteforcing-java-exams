/*
 * Exam Question #1153
 * Generated on: 2025-05-12 17:32:08
 * Generated by: Account 4
 * 
 * QUESTION:
 * **Advanced Java Programming Exam Task: Manufacturing Order Processing System Simulation**
 * 
 * **Problem Description:**
 * 
 * You are tasked with developing a simplified simulation of a manufacturing order processing system. The system should manage incoming orders, place them in a queue for processing, simulate processing the next available order, and keep track of completed orders.
 * 
 * Your solution must demonstrate proficiency in using core Java data structures, input/output, control flow, and exception handling.
 * 
 * **Requirements:**
 * 
 * 1.  **Order Representation:** Create a class `Order` with the following attributes:
 *     *   `orderId` (int): A unique identifier for the order.
 *     *   `description` (String): A brief description of the order (e.g., "Manufacture Widgets", "Assemble Gadgets").
 *     *   `status` (OrderStatus enum): An enum `OrderStatus` with values `PENDING`, `PROCESSING`, `COMPLETED`.
 *     *   Include appropriate private fields, a constructor, and public getter methods.
 *     *   Include a method `updateStatus(OrderStatus newStatus)` to change the order's status.
 *     *   Override the `toString()` method for easy display of order information.
 * 
 * 2.  **System Class:** Create a class `ManufacturingSimulator` that manages the order processing.
 *     *   It must use a `java.util.Queue<Order>` to hold orders waiting to be processed.
 *     *   It must use a `java.util.ArrayList<Order>` to store completed orders.
 *     *   It must use a `java.util.Scanner` to read user input from the console.
 *     *   It must have methods for the following operations, accessible via a command-line menu:
 *         *   **Add New Order:** Prompts the user for an order description and adds a new `Order` object with `PENDING` status to the processing queue. Generate a simple auto-incrementing `orderId`.
 *         *   **Process Next Order:** Takes the next order from the head of the processing queue. If successful, it updates the order's status to `COMPLETED` and moves it to the list of completed orders. If the queue is empty, it should report an error.
 *         *   **View Processing Queue:** Displays all orders currently in the processing queue.
 *         *   **View Completed Orders:** Displays all orders that have been completed.
 *         *   **Exit:** Terminates the program.
 *     *   Use a `switch` statement in the main loop to handle the different user menu selections.
 * 
 * 3.  **Input Handling:**
 *     *   Use `Scanner` to read user input for menu choices and order descriptions.
 *     *   Implement input validation for menu choices (ensure it's an integer within the valid range).
 *     *   Handle potential `java.util.InputMismatchException` if the user enters non-integer input when an integer is expected.
 * 
 * 4.  **Error Handling & Output:**
 *     *   Use `System.out` for displaying the menu, successful operation messages, and lists of orders.
 *     *   Use `System.err` to display error messages (e.g., invalid input, attempting to process from an empty queue).
 *     *   Implement class-wide exception handling using `try-catch` blocks. A good place is around the main input reading loop or within methods that perform operations that could fail (like reading input or polling from an empty queue, although `poll()` handles empty queues gracefully by returning `null`, you still need to check the result). Ensure exceptions like `InputMismatchException` are caught and handled gracefully.
 * 
 * 5.  **Best Practices:**
 *     *   Adhere to encapsulation principles (private fields, public methods).
 *     *   Use meaningful variable and method names.
 *     *   Include appropriate comments and documentation (e.g., Javadoc for classes and methods).
 *     *   Ensure the code is well-structured and readable.
 *     *   Utilize the `List` interface where appropriate (e.g., returning the completed orders list).
 * 
 * **Expected Output:**
 * 
 * The program should present a menu to the user. Based on the user's input, it should perform the requested action, display relevant information using `System.out`, or display error messages using `System.err`.
 * 
 * Example interaction flow:
 * 
 * ```
 * --- Manufacturing Simulator Menu ---
 * 1. Add New Order
 * 2. Process Next Order
 * 3. View Processing Queue
 * 4. View Completed Orders
 * 5. Exit
 * Enter your choice: 1
 * Enter order description: Manufacture Part A
 * Order 'Manufacture Part A' added with ID 1.
 * 
 * --- Manufacturing Simulator Menu ---
 * 1. Add New Order
 * 2. Process Next Order
 * 3. View Processing Queue
 * 4. View Completed Orders
 * 5. Exit
 * Enter your choice: 1
 * Enter order description: Assemble Product B
 * Order 'Assemble Product B' added with ID 2.
 * 
 * --- Manufacturing Simulator Menu ---
 * 1. Add New Order
 * 2. Process Next Order
 * 3. View Processing Queue
 * 4. View Completed Orders
 * 5. Exit
 * Enter your choice: 3
 * --- Processing Queue ---
 * Order ID: 1, Description: Manufacture Part A, Status: PENDING
 * Order ID: 2, Description: Assemble Product B, Status: PENDING
 * ------------------------
 * 
 * --- Manufacturing Simulator Menu ---
 * 1. Add New Order
 * 2. Process Next Order
 * 3. View Processing Queue
 * 4. View Completed Orders
 * 5. Exit
 * Enter your choice: 2
 * Processing order ID 1...
 * Order ID 1 completed.
 * 
 * --- Manufacturing Simulator Menu ---
 * 1. Add New Order
 * 2. Process Next Order
 * 3. View Processing Queue
 * 4. View Completed Orders
 * 5. Exit
 * Enter your choice: 3
 * --- Processing Queue ---
 * Order ID: 2, Description: Assemble Product B, Status: PENDING
 * ------------------------
 * 
 * --- Manufacturing Simulator Menu ---
 * 1. Add New Order
 * 2. Process Next Order
 * 3. View Processing Queue
 * 4. View Completed Orders
 * 5. Exit
 * Enter your choice: 4
 * --- Completed Orders ---
 * Order ID: 1, Description: Manufacture Part A, Status: COMPLETED
 * ------------------------
 * 
 * --- Manufacturing Simulator Menu ---
 * 1. Add New Order
 * 2. Process Next Order
 * 3. View Processing Queue
 * 4. View Completed Orders
 * 5. Exit
 * Enter your choice: 6
 * Error: Invalid menu choice. Please enter a number between 1 and 5.
 * 
 * --- Manufacturing Simulator Menu ---
 * 1. Add New Order
 * 2. Process Next Order
 * 3. View Processing Queue
 * 4. View Completed Orders
 * 5. Exit
 * Enter your choice: abc
 * Error: Invalid input. Please enter a number.
 * 
 * --- Manufacturing Simulator Menu ---
 * 1. Add New Order
 * 2. Process Next Order
 * 3. View Processing Queue
 * 4. View Completed Orders
 * 5. Exit
 * Enter your choice: 2
 * Processing next order...
 * Order ID 2 completed.
 * 
 * --- Manufacturing Simulator Menu ---
 * 1. Add New Order
 * 2. Process Next Order
 * 3. View Processing Queue
 * 4. View Completed Orders
 * 5. Exit
 * Enter your choice: 2
 * Processing next order...
 * Error: Processing queue is empty. No orders to process.
 * 
 * --- Manufacturing Simulator Menu ---
 * 1. Add New Order
 * 2. Process Next Order
 * 3. View Processing Queue
 * 4. View Completed Orders
 * 5. Exit
 * Enter your choice: 5
 * Exiting Manufacturing Simulator.
 * ```
 * 
 * Your code should be complete and runnable.
 *
 * EXPLANATION:
 * This solution implements a `ManufacturingSimulator` that manages `Order` objects using a `Queue` for pending tasks and a `List` (implemented by `ArrayList`) for completed tasks.
 * 
 * 1.  **`OrderStatus` Enum:** Defines the possible states an order can be in, providing type safety and readability compared to using raw strings or integers for status.
 * 2.  **`Order` Class:** Encapsulates the data for a single order (`orderId`, `description`, `status`). It uses private fields and public getters, demonstrating encapsulation. The `updateStatus` method allows controlled modification of the status. The `toString()` method provides a convenient way to display order details.
 * 3.  **`ManufacturingSimulator` Class:**
 *     *   **Data Structures:**
 *         *   `waitingOrders`: A `Queue<Order>` is used (specifically a `LinkedList`, which implements `Queue`). This is ideal for the processing queue because it naturally supports FIFO (First-In, First-Out) behavior using `offer()` to add to the tail and `poll()` to remove from the head.
 *         *   `completedOrders`: A `List<Order>` is used (specifically an `ArrayList`, which implements `List`). An `ArrayList` is suitable here as we primarily need to store completed orders and potentially iterate through them, and random access (which `ArrayList` provides efficiently) might be useful in more complex versions, though not strictly required by this problem. Using the `List` interface for the variable `completedOrders` is good practice as it allows flexibility to change the underlying implementation (e.g., to `LinkedList`) later without affecting code that interacts with `completedOrders` only via `List` methods.
 *     *   **`Scanner`:** An instance of `Scanner` is used to read input from `System.in`. It's initialized once and closed in the `finally` block of the `run` method to ensure resources are released.
 *     *   **`nextOrderId`:** A simple integer counter is used to generate unique IDs for new orders, demonstrating a basic state management pattern within the class.
 *     *   **`run()` Method:** This is the main control loop. It repeatedly displays the menu, reads user input, and uses a `switch` statement to delegate to the appropriate method based on the user's choice.
 *     *   **`try-catch` Blocks:**
 *         *   A main `try-catch(Exception e)` block wraps the entire `while` loop in `run()`. This provides class-wide exception handling, catching any unexpected runtime errors that might occur during the simulation and printing an error message and stack trace using `System.err`.
 *         *   A nested `try-catch(InputMismatchException e)` is used specifically around `scanner.nextInt()` to catch cases where the user enters non-integer input when the menu choice is expected. It prints an error message to `System.err` and consumes the invalid input using `scanner.nextLine()` to prevent an infinite loop.
 *     *   **`switch` Statement:** Used effectively in the `run()` method to direct program flow based on the user's menu selection. The `default` case handles invalid integer inputs.
 *     *   **Operation Methods (`addOrder`, `processNextOrder`, `viewQueue`, `viewCompleted`):**
 *         *   `addOrder`: Prompts for description, creates a new `Order` with the next ID and `PENDING` status, and adds it to the `waitingOrders` queue using `offer()`. Includes basic input validation for the description.
 *         *   `processNextOrder`: Uses `waitingOrders.poll()` to get and remove the head of the queue. It checks if `poll()` returned `null` (indicating an empty queue) and prints an error to `System.err` if so. Otherwise, it updates the order's status and adds it to the `completedOrders` list.
 *         *   `viewQueue`: Iterates through the `waitingOrders` queue to display its contents without removing elements. Checks for emptiness. Output goes to `System.out`.
 *         *   `viewCompleted`: Iterates through the `completedOrders` list to display its contents. Checks for emptiness. Output goes to `System.out`.
 *     *   **`displayMenu()`:** A simple helper method to print the menu options to `System.out`.
 * 4.  **`main` Method:** Creates an instance of `ManufacturingSimulator` and calls its `run()` method to start the simulation.
 * 
 * This solution successfully integrates all required components (`Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.err`, `System.out`, `try-catch`) within a practical simulation, demonstrating encapsulation, proper error handling, input validation, and clear code structure, fulfilling the requirements of a challenging exam task.
 */

import java.util.ArrayList;
import java.util.LinkedList; // LinkedList implements Queue
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.InputMismatchException;

// Enum for Order Status
enum OrderStatus {
    PENDING, PROCESSING, COMPLETED
}

// Represents a manufacturing order
class Order {
    private int orderId;
    private String description;
    private OrderStatus status;

    /**
     * Constructs a new Order.
     * @param orderId The unique ID for the order.
     * @param description The description of the order.
     */
    public Order(int orderId, String description) {
        this.orderId = orderId;
        this.description = description;
        this.status = OrderStatus.PENDING; // New orders start as PENDING
    }

    // --- Getters ---
    public int getOrderId() {
        return orderId;
    }

    public String getDescription() {
        return description;
    }

    public OrderStatus getStatus() {
        return status;
    }

    /**
     * Updates the status of the order.
     * @param newStatus The new status to set.
     */
    public void updateStatus(OrderStatus newStatus) {
        this.status = newStatus;
    }

    /**
     * Provides a string representation of the Order.
     * @return A formatted string describing the order.
     */
    @Override
    public String toString() {
        return String.format("Order ID: %d, Description: %s, Status: %s",
                             orderId, description, status);
    }
}

// Simulates the manufacturing order processing system
public class ManufacturingSimulator {

    private Queue<Order> waitingOrders;
    private List<Order> completedOrders; // Using List interface, implemented by ArrayList
    private Scanner scanner;
    private int nextOrderId; // Counter for unique order IDs

    /**
     * Constructs a new ManufacturingSimulator.
     */
    public ManufacturingSimulator() {
        this.waitingOrders = new LinkedList<>(); // LinkedList implements Queue
        this.completedOrders = new ArrayList<>(); // ArrayList implements List
        this.scanner = new Scanner(System.in);
        this.nextOrderId = 1; // Start order IDs from 1
    }

    /**
     * Displays the main menu to the user.
     */
    private void displayMenu() {
        System.out.println("\n--- Manufacturing Simulator Menu ---");
        System.out.println("1. Add New Order");
        System.out.println("2. Process Next Order");
        System.out.println("3. View Processing Queue");
        System.out.println("4. View Completed Orders");
        System.out.println("5. Exit");
        System.out.print("Enter your choice: ");
    }

    /**
     * Runs the main simulation loop.
     * Handles user input and dispatches operations.
     */
    public void run() {
        boolean running = true;
        // Class-wide exception handling for the main loop
        try {
            while (running) {
                displayMenu();
                int choice = -1;
                try {
                    choice = scanner.nextInt();
                    // Consume the newline character left by nextInt()
                    scanner.nextLine();
                } catch (InputMismatchException e) {
                    System.err.println("Error: Invalid input. Please enter a number.");
                    scanner.nextLine(); // Consume the invalid input to prevent infinite loop
                    continue; // Skip to the next iteration
                }

                // Using switch statement for flow control
                switch (choice) {
                    case 1:
                        addOrder();
                        break;
                    case 2:
                        processNextOrder();
                        break;
                    case 3:
                        viewQueue();
                        break;
                    case 4:
                        viewCompleted();
                        break;
                    case 5:
                        running = false;
                        System.out.println("Exiting Manufacturing Simulator.");
                        break;
                    default:
                        System.err.println("Error: Invalid menu choice. Please enter a number between 1 and 5.");
                }
            }
        } catch (Exception e) {
            // Catch any unexpected exceptions during the simulation
            System.err.println("An unexpected error occurred: " + e.getMessage());
            e.printStackTrace(); // Print stack trace for debugging
        } finally {
            // Ensure scanner is closed
            if (scanner != null) {
                scanner.close();
            }
        }
    }

    /**
     * Adds a new order to the processing queue.
     */
    private void addOrder() {
        System.out.print("Enter order description: ");
        String description = scanner.nextLine();

        if (description == null || description.trim().isEmpty()) {
            System.err.println("Error: Order description cannot be empty.");
            return; // Do not add the order
        }

        Order newOrder = new Order(nextOrderId++, description.trim());
        waitingOrders.offer(newOrder); // offer is generally preferred over add for queues
        System.out.println("Order '" + description.trim() + "' added with ID " + newOrder.getOrderId() + ".");
    }

    /**
     * Processes the next order from the queue.
     */
    private void processNextOrder() {
        System.out.println("Processing next order...");
        Order orderToProcess = waitingOrders.poll(); // poll retrieves and removes the head, returns null if empty

        if (orderToProcess == null) {
            System.err.println("Error: Processing queue is empty. No orders to process.");
        } else {
            // Simulate processing by updating status and moving to completed
            orderToProcess.updateStatus(OrderStatus.COMPLETED);
            completedOrders.add(orderToProcess);
            System.out.println("Order ID " + orderToProcess.getOrderId() + " completed.");
        }
    }

    /**
     * Displays the orders currently in the processing queue.
     */
    private void viewQueue() {
        System.out.println("--- Processing Queue ---");
        if (waitingOrders.isEmpty()) {
            System.out.println("The processing queue is empty.");
        } else {
            // Iterate over the queue without removing elements
            for (Order order : waitingOrders) {
                System.out.println(order);
            }
        }
        System.out.println("------------------------");
    }

    /**
     * Displays the orders that have been completed.
     */
    private void viewCompleted() {
        System.out.println("--- Completed Orders ---");
        if (completedOrders.isEmpty()) {
            System.out.println("No orders have been completed yet.");
        } else {
            // Using the List interface variable completedOrders
            for (Order order : completedOrders) {
                System.out.println(order);
            }
        }
        System.out.println("------------------------");
    }

    /**
     * Main method to start the simulation.
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        ManufacturingSimulator simulator = new ManufacturingSimulator();
        simulator.run();
    }
}
