/*
 * Exam Question #1075
 * Generated on: 2025-05-12 17:21:31
 * Generated by: Account 5
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Urgent Task Dispatcher
 * 
 * **Problem Description:**
 * 
 * Design and implement a command-line application in Java called "Urgent Task Dispatcher". This system will simulate a simple workflow where tasks are added to a queue for processing and, once processed, are moved to a list of completed tasks. The application should provide a menu-driven interface for user interaction.
 * 
 * **Requirements:**
 * 
 * 1.  **Task Representation:**
 *     *   Create a public class `Task`.
 *     *   It must have a private `String` field named `description` to store the task details.
 *     *   It must have a constructor `Task(String description)` to initialize the task.
 *     *   It must have a public getter method `getDescription()` that returns the task description.
 *     *   Override the `toString()` method to return the task description, facilitating easy printing.
 * 
 * 2.  **Task Dispatcher Logic:**
 *     *   Create a public class `TaskDispatcher`.
 *     *   It must have a private field `pendingTasks` of type `java.util.Queue<Task>`. Use `java.util.LinkedList` as the concrete implementation.
 *     *   It must have a private field `completedTasks` of type `java.util.List<Task>`. Use `java.util.ArrayList` as the concrete implementation.
 *     *   Implement a public method `addTask(String description)`:
 *         *   Takes a `String description` as input.
 *         *   Perform basic input validation: if the description is `null` or empty (including whitespace), print an error message to `System.err` and do not add the task.
 *         *   Otherwise, create a new `Task` object and add it to the `pendingTasks` queue.
 *         *   Print a confirmation message to `System.out` indicating the task was added.
 *     *   Implement a public method `processNextTask()`:
 *         *   Removes the next task from the front of the `pendingTasks` queue.
 *         *   If a task was successfully retrieved, add it to the `completedTasks` list and print a message to `System.out` indicating which task was processed.
 *         *   If the `pendingTasks` queue was empty, print a message to `System.out` indicating that there are no pending tasks.
 *     *   Implement a public method `viewPendingTasks()`:
 *         *   Prints a header "--- Pending Tasks ---" to `System.out`.
 *         *   Iterate through the `pendingTasks` queue (without removing elements) and print each task's description to `System.out`, numbered sequentially.
 *         *   If the queue is empty, print "No pending tasks." to `System.out`.
 *         *   Print a footer "---------------------" to `System.out`.
 *     *   Implement a public method `viewCompletedTasks()`:
 *         *   Prints a header "--- Completed Tasks ---" to `System.out`.
 *         *   Iterate through the `completedTasks` list and print each task's description to `System.out`, numbered sequentially.
 *         *   If the list is empty, print "No completed tasks." to `System.out`.
 *         *   Print a footer "---------------------" to `System.out`.
 * 
 * 3.  **User Interface and Application Entry Point:**
 *     *   Create a public class `TaskDispatcherApp` with a `public static void main(String[] args)` method.
 *     *   Inside `main`, create an instance of `TaskDispatcher`.
 *     *   Use `java.util.Scanner` to read user input from the console.
 *     *   Implement a loop that continuously displays the following menu and prompts for user input:
 *         ```
 *         Choose an action:
 *         1. Add New Task
 *         2. Process Next Task
 *         3. View Pending Tasks
 *         4. View Completed Tasks
 *         5. Exit
 *         Enter option:
 *         ```
 *     *   Use a `switch` statement based on the user's integer input to call the appropriate `TaskDispatcher` method or exit the application.
 *     *   Display the menu and standard application messages using `System.out`.
 *     *   Display error messages (e.g., for invalid menu options, invalid task descriptions) using `System.err`.
 *     *   Implement class-wide exception handling using a `try-catch` block around the main interaction loop to gracefully handle unexpected runtime errors during execution.
 *     *   Specifically handle `java.util.InputMismatchException` when reading the menu choice. If caught, print an error message to `System.err` and consume the invalid input line from the `Scanner` to prevent an infinite loop.
 *     *   Ensure the `Scanner` resource is properly closed using a `finally` block after the main loop or in the exception handling.
 * 
 * 4.  **Best Practices:**
 *     *   Apply proper encapsulation (private fields, public methods).
 *     *   Use meaningful variable and method names.
 *     *   Include appropriate comments and documentation (e.g., Javadoc for methods).
 *     *   Perform input validation as specified.
 *     *   Implement proper error handling as specified.
 *     *   Structure your code clearly into separate classes for different concerns.
 * 
 * **Expected Output:**
 * 
 * Your program should produce output similar to the example interaction flow provided in the problem description, demonstrating successful task management, viewing, processing, and graceful handling of invalid input or empty queues.
 * 
 * Your solution must use `java.util.Queue`, `java.util.ArrayList`, `java.util.List`, `java.util.Scanner`, `switch`, `System.err`, `System.out`, and class-wide `try-catch`.
 *
 * EXPLANATION:
 * This solution implements the Urgent Task Dispatcher application as required, demonstrating the use of all specified Java components and adhering to best practices.
 * 
 * 1.  **`Task` Class:** This is a simple Plain Old Java Object (POJO) representing a task. It encapsulates the `description` field as `private` and provides a public getter. The `toString()` override makes printing `Task` objects straightforward.
 * 
 * 2.  **`TaskDispatcher` Class:** This class holds the core logic for managing tasks.
 *     *   `private Queue<Task> pendingTasks;`: Declared using the `Queue` interface, initialized with `LinkedList`. This structure is perfect for representing a waiting line where tasks are processed in First-In, First-Out (FIFO) order, which is typical for queueing systems.
 *     *   `private List<Task> completedTasks;`: Declared using the `List` interface, initialized with `ArrayList`. An `ArrayList` is suitable here because we need to store a dynamic collection of completed tasks and potentially iterate over them multiple times. The `List` interface provides a common contract.
 *     *   `addTask(String description)`: Uses `pendingTasks.offer()` to add a task. `offer()` is preferred over `add()` in queues as it returns `false` if the queue is full (though `LinkedList` doesn't have a fixed capacity, it's good practice). Basic validation ensures non-empty descriptions. Error messages go to `System.err`, success messages to `System.out`.
 *     *   `processNextTask()`: Uses `pendingTasks.poll()` to retrieve and remove the head of the queue. `poll()` returns `null` if the queue is empty, allowing graceful handling of this condition. Processed tasks are added to the `completedTasks` `ArrayList`. Status messages are printed to `System.out`.
 *     *   `viewPendingTasks()` and `viewCompletedTasks()`: These methods iterate through the respective collections (`Queue` and `List`) using enhanced for loops and print the task descriptions. They check for emptiness to display appropriate messages. Output goes to `System.out`.
 * 
 * 3.  **`TaskDispatcherApp` Class (`main` method):** This class provides the command-line interface.
 *     *   `Scanner scanner = new Scanner(System.in);`: Used to read input from the standard input stream.
 *     *   `while(running)` loop: Keeps the application running until the user chooses to exit.
 *     *   Menu Display: Options are printed using `System.out`.
 *     *   Input Reading & `InputMismatchException` Handling: The code attempts to read an integer using `scanner.nextInt()`. This is wrapped in a `try-catch(InputMismatchException e)` block. If the user enters non-integer input, this specific exception is caught, an error is printed to `System.err`, `scanner.nextLine()` is called to consume the invalid input line (preventing an infinite loop), and `continue` restarts the loop iteration, showing the menu again.
 *     *   `switch (choice)`: Controls the program flow based on the valid integer input. Each case corresponds to a menu option, calling the relevant method in the `TaskDispatcher`. The `default` case handles integer inputs that are not valid menu options, printing an error to `System.err`.
 *     *   Class-Wide `try-catch(Exception e)`: An outer `try-catch` block wraps the main `while` loop. This provides a safety net to catch any unexpected `Exception` that might occur during the execution of the loop, printing a generic error message to `System.err` and preventing the program from crashing abruptly.
 *     *   `finally` block: The `scanner.close()` method is called in a `finally` block. This ensures that the `Scanner` resource is properly released whether the loop finishes normally (user exits) or an unexpected exception is caught, which is crucial for resource management.
 * 
 * **Best Practices Demonstrated:**
 * 
 * *   **Encapsulation:** Fields in `Task` and `TaskDispatcher` are `private`, accessed via public methods.
 * *   **Meaningful Names:** Variables (`pendingTasks`, `completedTasks`, `description`, `choice`) and methods (`addTask`, `processNextTask`, `viewPendingTasks`, `viewCompletedTasks`) are clearly named.
 * *   **Comments and Documentation:** Javadoc comments explain the purpose of classes and methods. Inline comments clarify specific logic points.
 * *   **Input Validation:** Basic validation for task description emptiness is performed.
 * *   **Proper Error Handling:** Specific handling for `InputMismatchException` and a general catch for other exceptions, using `System.err` for error output. Handling of empty queues/lists is included.
 * *   **Clean Code Structure:** The logic is separated into three classes (`Task`, `TaskDispatcher`, `TaskDispatcherApp`) with clear responsibilities.
 * 
 * This solution effectively uses the required Java components in a practical scenario while demonstrating robust error handling and good coding practices suitable for evaluating advanced Java understanding.
 */

import java.util.ArrayList;
import java.util.LinkedList; // LinkedList implements Queue
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.InputMismatchException;

/**
 * Represents a simple task with a description.
 */
class Task {
    private String description;

    /**
     * Constructs a new Task with the given description.
     * @param description The description of the task.
     */
    public Task(String description) {
        this.description = description;
    }

    /**
     * Gets the description of the task.
     * @return The task description.
     */
    public String getDescription() {
        return description;
    }

    /**
     * Returns the task description as its string representation.
     * @return The task description.
     */
    @Override
    public String toString() {
        return description;
    }
}

/**
 * Manages a queue of pending tasks and a list of completed tasks.
 */
class TaskDispatcher {
    // Queue to hold tasks waiting to be processed (FIFO order)
    private Queue<Task> pendingTasks;
    // List to hold tasks that have been processed
    private List<Task> completedTasks;

    /**
     * Constructs a new TaskDispatcher, initializing the task queues and lists.
     */
    public TaskDispatcher() {
        // Use LinkedList as a concrete implementation of Queue
        pendingTasks = new LinkedList<>();
        // Use ArrayList as a concrete implementation of List
        completedTasks = new ArrayList<>();
    }

    /**
     * Adds a new task to the pending queue.
     * Performs basic validation on the description.
     * @param description The description of the task.
     */
    public void addTask(String description) {
        // Input validation for task description
        if (description == null || description.trim().isEmpty()) {
            System.err.println("Error: Task description cannot be empty.");
            return; // Do not add the task if description is invalid
        }
        Task newTask = new Task(description.trim()); // Trim whitespace
        pendingTasks.offer(newTask); // offer() is generally preferred over add() for queues
        System.out.println("Task added: \"" + description.trim() + "\""); // Print confirmation
    }

    /**
     * Processes the next task in the pending queue.
     * Moves the task from pending to completed.
     * Prints status messages to System.out.
     */
    public void processNextTask() {
        // poll() retrieves and removes the head of the queue, returns null if empty
        Task nextTask = pendingTasks.poll();
        if (nextTask != null) {
            completedTasks.add(nextTask); // Add the processed task to the completed list
            System.out.println("Processed task: \"" + nextTask.getDescription() + "\"");
        } else {
            // Message when the queue is empty
            System.out.println("No pending tasks to process.");
        }
    }

    /**
     * Displays all tasks currently in the pending queue.
     * Iterates without removing elements.
     * Prints to System.out.
     */
    public void viewPendingTasks() {
        System.out.println("\n--- Pending Tasks ---");
        if (pendingTasks.isEmpty()) {
            System.out.println("No pending tasks.");
        } else {
            // Iterate through the queue using a for-each loop
            int index = 1;
            for (Task task : pendingTasks) {
                System.out.println(index++ + ". " + task.getDescription());
            }
        }
        System.out.println("---------------------\n");
    }

    /**
     * Displays all tasks that have been completed.
     * Prints to System.out.
     */
    public void viewCompletedTasks() {
        System.out.println("\n--- Completed Tasks ---");
        if (completedTasks.isEmpty()) {
            System.out.println("No completed tasks.");
        } else {
            // Iterate through the list
            int index = 1;
            for (Task task : completedTasks) {
                System.out.println(index++ + ". " + task.getDescription());
            }
        }
        System.out.println("---------------------\n");
    }
}

/**
 * Main application class for the Urgent Task Dispatcher.
 * Handles user interaction via the command line.
 */
public class TaskDispatcherApp {

    public static void main(String[] args) {
        // Create an instance of the TaskDispatcher
        TaskDispatcher dispatcher = new TaskDispatcher();
        // Create a Scanner for reading user input
        Scanner scanner = new Scanner(System.in);
        boolean running = true; // Flag to control the main loop

        System.out.println("--- Task Dispatcher System ---");

        // Class-wide exception handling using try-catch for the main interaction loop
        try {
            while (running) {
                // Display the menu to the user
                System.out.println("\nChoose an action:");
                System.out.println("1. Add New Task");
                System.out.println("2. Process Next Task");
                System.out.println("3. View Pending Tasks");
                System.out.println("4. View Completed Tasks");
                System.out.println("5. Exit");
                System.out.print("Enter option: ");

                int choice = -1; // Variable to store user's menu choice

                // Specific try-catch block for handling Scanner input errors
                try {
                    choice = scanner.nextInt();
                    // Consume the newline character left by nextInt() to prevent issues with nextLine()
                    scanner.nextLine();
                } catch (InputMismatchException e) {
                    // Handle non-integer input gracefully
                    System.err.println("Invalid input. Please enter a number.");
                    // Consume the invalid input line to prevent an infinite loop
                    scanner.nextLine();
                    continue; // Skip the rest of the loop iteration and show menu again
                }

                // Use a switch statement to handle different menu options
                switch (choice) {
                    case 1:
                        // Add New Task
                        System.out.print("Enter task description: ");
                        String description = scanner.nextLine();
                        dispatcher.addTask(description); // Call the dispatcher method
                        break;
                    case 2:
                        // Process Next Task
                        dispatcher.processNextTask(); // Call the dispatcher method
                        break;
                    case 3:
                        // View Pending Tasks
                        dispatcher.viewPendingTasks(); // Call the dispatcher method
                        break;
                    case 4:
                        // View Completed Tasks
                        dispatcher.viewCompletedTasks(); // Call the dispatcher method
                        break;
                    case 5:
                        // Exit the application
                        System.out.println("Exiting Task Dispatcher. Goodbye!");
                        running = false; // Set flag to exit the loop
                        break;
                    default:
                        // Handle invalid menu option numbers
                        System.err.println("Invalid option. Please enter a number between 1 and 5.");
                }
            }
        } catch (Exception e) {
            // Catch any other unexpected exceptions that might occur in the main loop
            System.err.println("An unexpected error occurred: " + e.getMessage());
            // Optionally print the stack trace for debugging:
            // e.printStackTrace();
        } finally {
            // Ensure the Scanner resource is closed regardless of whether an exception occurred
            scanner.close();
            System.out.println("Scanner closed."); // Indicate resource cleanup
        }
    }
}
