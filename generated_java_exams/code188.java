/*
 * Exam Question #188
 * Generated on: 2025-05-11 22:28:31
 * Generated by: Account 4
 * 
 * QUESTION:
 * ## Advanced Java Programming Exam Task: Task Management System
 * 
 * **Scenario:**
 * 
 * You are tasked with developing a command-line application for a small team to manage their tasks. The application should allow users to add new tasks, process the next task that is waiting, and view lists of pending and completed tasks. The system needs to prioritize tasks based on their arrival time (First-In, First-Out) for processing.
 * 
 * **Requirements:**
 * 
 * Implement a Java application that fulfills the following requirements:
 * 
 * 1.  **Task Representation:** Create a separate class named `Task` to represent a single task. This class should encapsulate the task's details (at a minimum, a `String` description). Ensure proper encapsulation by using private fields and public methods (constructor, getter). Include basic validation in the constructor (e.g., description cannot be null or empty).
 * 
 * 2.  **Task Storage:**
 *     *   Use `java.util.Queue` to store tasks that are pending (waiting to be processed). The queue should maintain tasks in a FIFO order.
 *     *   Use `java.util.ArrayList` to store tasks that have been completed.
 *     *   Declare the collection holding completed tasks using the `java.util.List` interface type.
 * 
 * 3.  **User Interface:** Implement a simple command-line interface using `java.util.Scanner` to interact with the user. The application should present a menu with options and read user input.
 * 
 * 4.  **Functionality:**
 *     *   **Add Task:** Prompt the user for a task description and add a new `Task` object to the pending tasks queue.
 *     *   **Process Next Task:** Remove the next task from the pending queue (FIFO) and add it to the completed tasks list. If the pending queue is empty, display an appropriate error message.
 *     *   **List Pending Tasks:** Display all tasks currently in the pending queue without removing them.
 *     *   **List Completed Tasks:** Display all tasks currently in the completed tasks list.
 *     *   **Exit:** Terminate the application.
 * 
 * 5.  **Control Flow:** Use a `switch` statement to handle the different menu choices selected by the user.
 * 
 * 6.  **Output:**
 *     *   Use `System.out` for displaying the menu, prompts, task lists, and success messages (e.g., task added, task processed, exit message).
 *     *   Use `System.err` to print error messages (e.g., invalid menu choice, attempting to process an empty queue, validation errors).
 * 
 * 7.  **Exception Handling:** Implement robust exception handling:
 *     *   Use `try-catch` blocks to handle potential errors. Include class-wide exception handling wrapping the main application logic to catch unexpected runtime errors.
 *     *   Specifically handle `NumberFormatException` if the user enters non-numeric input for the menu choice.
 *     *   Handle potential validation errors from the `Task` constructor.
 * 
 * 8.  **Best Practices:** Adhere to Java best practices, including:
 *     *   Meaningful variable and method names.
 *     *   Appropriate comments and Javadoc documentation.
 *     *   Input validation where necessary (e.g., task description, menu choice).
 *     *   Clean and readable code structure.
 *     *   Ensure resources like `Scanner` are closed properly.
 * 
 * **Expected Output:**
 * 
 * Your application should behave similarly to the following interaction example:
 * 
 * ```
 * --- Task Manager Menu ---
 * 1. Add New Task
 * 2. Process Next Task
 * 3. List Pending Tasks
 * 4. List Completed Tasks
 * 5. Exit
 * Enter your choice: 1
 * Enter task description: Write report
 * Task added: "Write report"
 * 
 * --- Task Manager Menu ---
 * 1. Add New Task
 * 2. Process Next Task
 * 3. List Pending Tasks
 * 4. List Completed Tasks
 * 5. Exit
 * Enter your choice: 1
 * Enter task description: Prepare presentation
 * Task added: "Prepare presentation"
 * 
 * --- Task Manager Menu ---
 * 1. Add New Task
 * 2. Process Next Task
 * 3. List Pending Tasks
 * 4. List Completed Tasks
 * 5. Exit
 * Enter your choice: 3
 * 
 * --- Pending Tasks ---
 * 1. Write report
 * 2. Prepare presentation
 * --------------------
 * 
 * --- Task Manager Menu ---
 * 1. Add New Task
 * 2. Process Next Task
 * 3. List Pending Tasks
 * 4. List Completed Tasks
 * 5. Exit
 * Enter your choice: 2
 * Processed task: "Write report"
 * 
 * --- Task Manager Menu ---
 * 1. Add New Task
 * 2. Process Next Task
 * 3. List Pending Tasks
 * 4. List Completed Tasks
 * 5. Exit
 * Enter your choice: 3
 * 
 * --- Pending Tasks ---
 * 1. Prepare presentation
 * --------------------
 * 
 * --- Task Manager Menu ---
 * 1. Add New Task
 * 2. Process Next Task
 * 3. List Pending Tasks
 * 4. List Completed Tasks
 * 5. Exit
 * Enter your choice: 4
 * 
 * --- Completed Tasks ---
 * 1. Write report
 * --------------------
 * 
 * --- Task Manager Menu ---
 * 1. Add New Task
 * 2. Process Next Task
 * 3. List Pending Tasks
 * 4. List Completed Tasks
 * 5. Exit
 * Enter your choice: 2
 * Processed task: "Prepare presentation"
 * 
 * --- Task Manager Menu ---
 * 1. Add New Task
 * 2. Process Next Task
 * 3. List Pending Tasks
 * 4. List Completed Tasks
 * 5. Exit
 * Enter your choice: 2
 * No pending tasks to process.
 * 
 * --- Task Manager Menu ---
 * 1. Add New Task
 * 2. Process Next Task
 * 3. List Pending Tasks
 * 4. List Completed Tasks
 * 5. Exit
 * Enter your choice: abc
 * Invalid input. Please enter a number.
 * 
 * --- Task Manager Menu ---
 * 1. Add New Task
 * 2. Process Next Task
 * 3. List Pending Tasks
 * 4. List Completed Tasks
 * 5. Exit
 * Enter your choice: 1
 * Enter task description:
 * Task description cannot be empty.
 * 
 * --- Task Manager Menu ---
 * 1. Add New Task
 * 2. Process Next Task
 * 3. List Pending Tasks
 * 4. List Completed Tasks
 * 5. Exit
 * Enter your choice: 5
 * Exiting Task Manager. Goodbye!
 * Scanner closed.
 * ```
 * 
 * Your solution should consist of two Java files: `Task.java` and `TaskManagerApp.java`.
 *
 * EXPLANATION:
 * The solution provides a simple command-line task management system that demonstrates the required Java concepts.
 * 
 * 1.  **`Task` Class:** The `Task.java` file defines a simple class to represent a task. It has a private `description` field, a constructor that validates the description (ensuring it's not null or empty) and throws an `IllegalArgumentException` if invalid, and a public getter method. The `toString()` method is overridden for easy printing of the task description. This adheres to encapsulation principles.
 * 
 * 2.  **`TaskManagerApp` Class:** The main application logic resides in `TaskManagerApp.java`.
 *     *   **Collections:** It uses a `Queue<Task>` named `pendingTasks` (implemented with `LinkedList`) to store tasks waiting for processing. `Queue` naturally provides the FIFO behavior required. It uses a `List<Task>` named `completedTasks` (implemented with `ArrayList`) to store tasks that have been processed. The use of the `List` interface type for `completedTasks` fulfills that specific requirement.
 *     *   **Scanner and Menu:** A `Scanner` is used to read user input from `System.in`. The `displayMenu` method shows the available options.
 *     *   **`run()` Method and `try-catch`:** The core application loop is in the `run()` method. This method is wrapped in a large `try-catch(Exception mainException)` block, fulfilling the requirement for class-wide exception handling. This outer block catches any unhandled exceptions that might occur during the application's lifetime and prints a critical error message to `System.err`. A `finally` block ensures the `Scanner` is closed. Inside the main `while` loop, there's an inner `try-catch` block specifically to handle exceptions that might occur during a single iteration of processing user input and executing a command. This block catches `NumberFormatException` for invalid integer input, `IllegalArgumentException` (which can be thrown by the `Task` constructor), and a general `Exception` for any other unexpected issues during an operation. This layered approach provides both specific handling for expected errors and general robustness.
 *     *   **`switch` Statement:** The `switch` statement is used within the inner `try` block to direct execution based on the user's valid integer choice, calling the appropriate private methods (`addTask`, `processNextTask`, etc.). The `default` case handles integer inputs that are outside the valid range (1-5).
 *     *   **`System.out` vs. `System.err`:** `System.out.println` is used for normal program output like the menu, prompts, success messages, and task lists. `System.err.println` is strictly used for error messages, such as invalid input, attempting an action on an empty collection, or reporting exceptions.
 *     *   **Functionality Methods:**
 *         *   `addTask()`: Prompts for description, validates it, creates a `Task` object, and adds it to `pendingTasks` using `offer()`.
 *         *   `processNextTask()`: Checks if `pendingTasks` is empty using `isEmpty()`. If not empty, it removes the head of the queue using `poll()` and adds it to the `completedTasks` list using `add()`. An error message is printed to `System.err` if the queue is empty.
 *         *   `listPendingTasks()`: Iterates through the `pendingTasks` queue using an enhanced for loop (which uses the queue's iterator) and prints each task's description. It does not remove elements from the queue. Prints a message if the queue is empty.
 *         *   `listCompletedTasks()`: Iterates through the `completedTasks` list using an enhanced for loop and prints each task's description. Prints a message if the list is empty.
 *     *   **Best Practices:** Private fields and methods (where appropriate), meaningful names (`pendingTasks`, `processNextTask`), Javadoc comments, input validation (empty description check, `NumberFormatException` handling), and proper resource closing (`scanner.close()` in `finally`) are implemented.
 * 
 * This solution effectively integrates all the required Java components into a cohesive, practical application while demonstrating good programming practices and robust error handling.
 */

// Task.java
package com.exam.taskmanager; // Example package structure

/**
 * Represents a simple task with a description.
 */
public class Task {
    private String description;

    /**
     * Constructs a new Task.
     * Validates that the description is not null or empty.
     * @param description The description of the task.
     * @throws IllegalArgumentException if the description is null or empty.
     */
    public Task(String description) {
        // Input validation within constructor
        if (description == null || description.trim().isEmpty()) {
            throw new IllegalArgumentException("Task description cannot be null or empty.");
        }
        this.description = description.trim(); // Trim leading/trailing whitespace
    }

    /**
     * Gets the description of the task.
     * @return The task description.
     */
    public String getDescription() {
        return description;
    }

    /**
     * Returns a string representation of the task, which is its description.
     * @return The task description string.
     */
    @Override
    public String toString() {
        return description;
    }
}
```

```java
// TaskManagerApp.java
package com.exam.taskmanager; // Example package structure

import java.util.Queue;
import java.util.LinkedList; // A common Queue implementation
import java.util.List;
import java.util.ArrayList; // A common List implementation
import java.util.Scanner;
import java.util.InputMismatchException; // Useful for scanner errors, though NumberFormatException is caught here

/**
 * A simple command-line Task Management application.
 * Manages pending tasks in a Queue (FIFO) and completed tasks in a List.
 * Demonstrates use of Queue, List, ArrayList, Scanner, switch,
 * System.out, System.err, and exception handling.
 */
public class TaskManagerApp {

    // Private fields for encapsulation
    private Queue<Task> pendingTasks;
    private List<Task> completedTasks; // Declared using the List interface
    private Scanner scanner;

    /**
     * Constructs a new TaskManagerApp, initializing collections and scanner.
     */
    public TaskManagerApp() {
        // Initialize pending tasks queue using LinkedList for FIFO behavior
        this.pendingTasks = new LinkedList<>();
        // Initialize completed tasks list using ArrayList
        this.completedTasks = new ArrayList<>();
        // Initialize scanner for reading input from console
        this.scanner = new Scanner(System.in);
    }

    /**
     * Displays the application menu options to the console.
     */
    private void displayMenu() {
        System.out.println("\n--- Task Manager Menu ---");
        System.out.println("1. Add New Task");
        System.out.println("2. Process Next Task");
        System.out.println("3. List Pending Tasks");
        System.out.println("4. List Completed Tasks");
        System.out.println("5. Exit");
        System.out.print("Enter your choice: ");
    }

    /**
     * Runs the main application loop, handling user interaction and operations.
     * Includes class-wide and operation-specific exception handling.
     */
    public void run() {
        boolean running = true;

        // Class-wide try-catch block to handle any unexpected exceptions
        // that might occur during the application's execution.
        try {
            while (running) {
                displayMenu();

                // Inner try-catch for handling input parsing and operation-specific errors
                try {
                    String input = scanner.nextLine();
                    int choice = Integer.parseInt(input); // Potential NumberFormatException

                    // Use switch statement for menu navigation
                    switch (choice) {
                        case 1:
                            addTask();
                            break;
                        case 2:
                            processNextTask();
                            break;
                        case 3:
                            listPendingTasks();
                            break;
                        case 4:
                            listCompletedTasks();
                            break;
                        case 5:
                            System.out.println("Exiting Task Manager. Goodbye!");
                            running = false; // Set flag to exit the loop
                            break;
                        default:
                            // Use System.err for invalid user input
                            System.err.println("Invalid choice. Please enter a number between 1 and 5.");
                    }
                } catch (NumberFormatException e) {
                    // Handle cases where the user input is not a valid integer
                    System.err.println("Invalid input. Please enter a number.");
                } catch (IllegalArgumentException e) {
                    // Handle specific exceptions like empty task description from Task constructor
                    System.err.println("Error: " + e.getMessage());
                } catch (Exception e) {
                    // Catch any other unexpected exceptions during a specific operation cycle
                     System.err.println("An unexpected error occurred during operation: " + e.getMessage());
                     // For exam purposes, printing message might be sufficient. In real apps, log or print stack trace.
                     // e.printStackTrace(System.err);
                }
            }
        } catch (Exception mainException) {
            // This catch handles any critical errors not caught by the inner block,
            // potentially leading to application termination.
            System.err.println("\nA critical error occurred during application execution:");
            mainException.printStackTrace(System.err); // Print stack trace for critical errors
        } finally {
            // Ensure the scanner resource is closed when the application finishes or crashes
            if (scanner != null) {
                scanner.close();
                // System.out.println("Scanner resource closed."); // Optional confirmation
            }
        }
    }

    /**
     * Prompts user for task description and adds a new task to the pending queue.
     * Handles potential IllegalArgumentException from Task constructor.
     */
    private void addTask() {
        System.out.print("Enter task description: ");
        String description = scanner.nextLine();

        // Basic validation before creating Task object
        if (description == null || description.trim().isEmpty()) {
             System.err.println("Task description cannot be empty.");
             return; // Exit method if validation fails
        }

        try {
            Task newTask = new Task(description); // Task constructor validates description
            pendingTasks.offer(newTask); // offer() is a Queue method to add element
            System.out.println("Task added: \"" + newTask.getDescription() + "\"");
        } catch (IllegalArgumentException e) {
             // This specific catch is here for clarity, though the inner catch in run() also handles it.
             System.err.println("Error creating task: " + e.getMessage());
        }
    }

    /**
     * Processes the next task from the pending queue (FIFO) and moves it
     * to the completed tasks list. Displays error if queue is empty.
     */
    private void processNextTask() {
        // Check if the queue is empty before attempting to poll
        if (pendingTasks.isEmpty()) {
            // Use System.err for error message
            System.err.println("No pending tasks to process.");
            return;
        }

        Task processedTask = pendingTasks.poll(); // poll() retrieves and removes the head of the queue
        completedTasks.add(processedTask); // add() is a List method to add element

        System.out.println("Processed task: \"" + processedTask.getDescription() + "\"");
    }

    /**
     * Lists all tasks currently in the pending queue without removing them.
     */
    private void listPendingTasks() {
        if (pendingTasks.isEmpty()) {
            System.out.println("No pending tasks.");
            return;
        }

        System.out.println("\n--- Pending Tasks ---");
        // Iterate through the queue using enhanced for loop (uses iterator)
        int index = 1;
        for (Task task : pendingTasks) {
            System.out.println(index++ + ". " + task.getDescription());
        }
        System.out.println("--------------------");
    }

    /**
     * Lists all tasks currently in the completed tasks list.
     */
    private void listCompletedTasks() {
        if (completedTasks.isEmpty()) {
            System.out.println("No completed tasks.");
            return;
        }

        System.out.println("\n--- Completed Tasks ---");
        // Iterate through the list using enhanced for loop
        int index = 1;
        for (Task task : completedTasks) {
            System.out.println(index++ + ". " + task.getDescription());
        }
        System.out.println("--------------------");
    }

    /**
     * Main method to start the application.
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        TaskManagerApp app = new TaskManagerApp();
        app.run(); // Start the main application loop
    }
}
