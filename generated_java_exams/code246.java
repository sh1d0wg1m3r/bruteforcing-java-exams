/*
 * Exam Question #246
 * Generated on: 2025-05-11 22:38:38
 * Generated by: Account 2
 * 
 * QUESTION:
 * ## Advanced Java Programming Exam Task: Task Processing System
 * 
 * **Scenario:**
 * 
 * You are tasked with building a simple command-line application that simulates a task processing system. The system should manage tasks that are submitted, queued for processing, and then moved to a list of completed tasks.
 * 
 * **Requirements:**
 * 
 * 1.  **Task Management:**
 *     *   Create a `Task` class with private fields for `id` (auto-generated integer), `description` (String), and `status` (String, e.g., "Pending", "Completed"). Include a constructor and appropriate public getter methods. Add a method to mark the task as completed. Override `toString()` for easy printing.
 * 2.  **System Core:**
 *     *   Create a `TaskProcessingSystem` class.
 *     *   It must use a `java.util.Queue<Task>` to store tasks that are waiting to be processed (pending tasks). Use a `LinkedList` as the concrete implementation.
 *     *   It must use a `java.util.List<Task>` to store tasks that have been completed. Use an `ArrayList` as the concrete implementation. Declare the field using the `List` interface type.
 *     *   Implement methods:
 *         *   `addTask()`: Prompts the user for a task description, creates a `Task` object, and adds it to the pending queue.
 *         *   `processNextTask()`: Takes the next task from the pending queue (if any), marks it as completed, and moves it to the completed tasks list.
 *         *   `viewPendingTasks()`: Displays all tasks currently in the pending queue without removing them.
 *         *   `viewCompletedTasks()`: Displays all tasks in the completed tasks list.
 * 3.  **User Interface:**
 *     *   Use `java.util.Scanner` to read user input from the console.
 *     *   Implement a simple menu-driven interface in the `main` method of `TaskProcessingSystem`. The menu should offer options to add a task, process the next task, view pending tasks, view completed tasks, and exit.
 *     *   Use a `switch` statement to handle the user's menu choice.
 * 4.  **Output and Error Handling:**
 *     *   Use `System.out` for displaying the menu, prompts, task details, success messages, and lists of tasks.
 *     *   Use `System.err` for displaying error messages, specifically for:
 *         *   Invalid menu input (non-integer).
 *         *   Invalid menu choice (integer out of range).
 *         *   Empty task description when adding a task.
 *     *   Implement class-wide exception handling using `try-catch` block(s) in the `main` method to gracefully handle potential runtime errors, particularly those related to input and unexpected issues during the system's execution loop. Ensure the `Scanner` is closed properly using a `finally` block or try-with-resources (though try-with-resources with Scanner on System.in can be tricky, a `finally` block is safer for this exam context).
 * 5.  **Best Practices:**
 *     *   Follow proper encapsulation principles (private fields, public methods).
 *     *   Use meaningful variable and method names.
 *     *   Include appropriate comments explaining key parts of the code.
 *     *   Implement input validation where necessary (e.g., non-empty description, valid menu choice).
 *     *   Handle edge cases like attempting to process a task when the pending queue is empty or viewing lists when they are empty.
 * 
 * **Expected Program Flow:**
 * 
 * The program should start, display a menu, and repeatedly ask for user input until the user chooses to exit. Each menu option should perform the corresponding action, displaying appropriate output or error messages.
 * 
 * **Example Interaction (Partial):**
 * 
 * ```
 * Task Processing System Menu:
 * 1. Add New Task
 * 2. Process Next Task
 * 3. View Pending Tasks
 * 4. View Completed Tasks
 * 5. Exit
 * Enter your choice: 1
 * Enter task description: Write exam question
 * Task added: Write exam question
 * 
 * Task Processing System Menu:
 * ...
 * Enter your choice: 1
 * Enter task description: Grade exams
 * Task added: Grade exams
 * 
 * Task Processing System Menu:
 * ...
 * Enter your choice: 3
 * 
 * --- Pending Tasks ---
 * 1. Task [ID=1, Description='Write exam question', Status=Pending]
 * 2. Task [ID=2, Description='Grade exams', Status=Pending]
 * ---------------------
 * 
 * Task Processing System Menu:
 * ...
 * Enter your choice: 2
 * Processing task: Write exam question...
 * Task ID 1 completed.
 * 
 * Task Processing System Menu:
 * ...
 * Enter your choice: 3
 * 
 * --- Pending Tasks ---
 * 1. Task [ID=2, Description='Grade exams', Status=Pending]
 * ---------------------
 * 
 * Task Processing System Menu:
 * ...
 * Enter your choice: 4
 * 
 * --- Completed Tasks ---
 * 1. Task [ID=1, Description='Write exam question', Status=Completed]
 * -----------------------
 * 
 * Task Processing System Menu:
 * ...
 * Enter your choice: process
 * Invalid input. Please enter a number.
 * 
 * Task Processing System Menu:
 * ...
 * Enter your choice: 6
 * Invalid choice. Please enter a number between 1 and 5.
 * 
 * Task Processing System Menu:
 * ...
 * Enter your choice: 1
 * Enter task description:
 * Error: Task description cannot be empty.
 * 
 * Task Processing System Menu:
 * ...
 * Enter your choice: 2
 * Processing task: Grade exams...
 * Task ID 2 completed.
 * 
 * Task Processing System Menu:
 * ...
 * Enter your choice: 2
 * No tasks pending to process.
 * 
 * Task Processing System Menu:
 * ...
 * Enter your choice: 5
 * Exiting Task Processing System. Goodbye!
 * ```
 * 
 * Your solution should provide the complete Java code for the `Task` and `TaskProcessingSystem` classes.
 *
 * EXPLANATION:
 * The provided solution implements a simple command-line Task Processing System, fulfilling all the requirements of the exam task.
 * 
 * 1.  **Task Class:** The `Task` class encapsulates task data (ID, description, status) with private fields and public getters, demonstrating encapsulation. The static `nextId` ensures unique IDs for each task. The `markComplete()` method modifies the internal status, and `toString()` provides a convenient representation.
 * 
 * 2.  **System Core (`TaskProcessingSystem`):**
 *     *   `Queue<Task> pendingTasks`: A `LinkedList` is used here to implement the `Queue` interface. This correctly models the "pending" state where tasks are processed in First-In, First-Out (FIFO) order. `offer()` is used to add tasks, and `poll()` is used to remove and retrieve the next task for processing. Iteration for viewing pending tasks uses an enhanced for loop, which traverses the queue without removing elements.
 *     *   `List<Task> completedTasks`: An `ArrayList` is used here to implement the `List` interface. This stores tasks once they are completed. `ArrayList` allows easy addition (`add()`) and iteration, and accessing elements by index (`get()`) is demonstrated in `viewCompletedTasks()`. The `List` interface is used for the field declaration, promoting good practice by coding to the interface.
 *     *   Methods like `addTask()`, `processNextTask()`, `viewPendingTasks()`, and `viewCompletedTasks()` implement the core logic, interacting with the `Queue` and `List` appropriately.
 * 
 * 3.  **User Interface:**
 *     *   A `Scanner` object is used in the `main` method (and passed implicitly via the `system` object) to read user input from `System.in`.
 *     *   The `main` method contains a `while` loop that keeps the system running until the user chooses to exit.
 *     *   A `displayMenu()` method is used to show the available options.
 *     *   A `switch` statement is used to direct the program flow based on the integer input received from the user, calling the relevant methods.
 * 
 * 4.  **Output and Error Handling:**
 *     *   `System.out.println()` is used for all normal output: displaying the menu, prompts, confirmation messages for adding/completing tasks, and listing the pending and completed tasks.
 *     *   `System.err.println()` is specifically used for error messages related to invalid user input: when the input is not an integer (`InputMismatchException` caught), when the integer choice is outside the valid range (default case in `switch`), and when the task description is empty (input validation in `addTask`). This differentiates error messages from normal application output.
 *     *   **Class-wide Exception Handling:** A `try-catch` block wraps the main `while` loop in the `main` method. This provides a top-level handler for unexpected exceptions that might occur anywhere within the application's main execution flow. A specific `catch (InputMismatchException e)` is included *inside* the loop to handle non-integer input gracefully, ensuring the scanner state is reset (`scanner.nextLine()`) to prevent an infinite loop. A general `catch (Exception e)` is used around the loop to catch any other potential runtime errors, demonstrating a broader handling scope. The `finally` block ensures that the `scanner` resource is closed when the main `try` block is exited, whether normally or due to an exception.
 * 
 * 5.  **Best Practices:**
 *     *   Encapsulation is followed with private fields and public methods.
 *     *   Variable and method names are descriptive (e.g., `pendingTasks`, `processNextTask`, `viewCompletedTasks`).
 *     *   Basic comments explain the purpose of classes and key methods/sections.
 *     *   Input validation is performed for the task description (checking for empty string) and menu choice (handling non-integer input and range validation).
 *     *   Edge cases like attempting to process a task when the queue is empty are handled gracefully with informative messages rather than crashing.
 * 
 * This solution effectively integrates the required Java components within a functional, well-structured, and robust command-line application, demonstrating an advanced understanding of Java concepts and best practices.
 */

import java.util.Queue;
import java.util.LinkedList;
import java.util.List;
import java.util.ArrayList;
import java.util.Scanner;
import java.util.InputMismatchException;

/**
 * Represents a single task in the processing system.
 */
class Task {
    private static int nextId = 1; // Static counter for auto-generating task IDs
    private int id;
    private String description;
    private String status; // e.g., "Pending", "Completed"

    /**
     * Constructs a new Task with a given description.
     * ID is auto-generated, and status is initially "Pending".
     * @param description The description of the task.
     */
    public Task(String description) {
        this.id = nextId++; // Assign ID and increment counter
        this.description = description;
        this.status = "Pending";
    }

    // --- Getters ---
    public int getId() {
        return id;
    }

    public String getDescription() {
        return description;
    }

    public String getStatus() {
        return status;
    }

    /**
     * Marks the task's status as "Completed".
     */
    public void markComplete() {
        this.status = "Completed";
    }

    /**
     * Provides a string representation of the Task.
     * @return A formatted string including ID, Description, and Status.
     */
    @Override
    public String toString() {
        return "Task [ID=" + id + ", Description='" + description + "', Status=" + status + "]";
    }
}

/**
 * Manages the flow of tasks through pending and completed states.
 */
public class TaskProcessingSystem {

    // Queue to hold tasks waiting to be processed (FIFO)
    private Queue<Task> pendingTasks;
    // List to hold tasks that have been completed
    private List<Task> completedTasks;
    // Scanner for reading user input
    private Scanner scanner;

    /**
     * Constructs a new TaskProcessingSystem, initializing the data structures.
     */
    public TaskProcessingSystem() {
        // Use LinkedList as a Queue implementation for pending tasks
        this.pendingTasks = new LinkedList<>();
        // Use ArrayList as a List implementation for completed tasks
        this.completedTasks = new ArrayList<>();
        this.scanner = new Scanner(System.in);
    }

    /**
     * Prompts the user for a task description and adds a new task to the pending queue.
     * Validates that the description is not empty.
     */
    public void addTask() {
        System.out.print("Enter task description: ");
        // Read the entire line for the description
        String description = scanner.nextLine().trim();

        // Input validation: Check if description is empty
        if (description.isEmpty()) {
            System.err.println("Error: Task description cannot be empty.");
            return; // Exit the method if validation fails
        }

        Task newTask = new Task(description);
        // offer() is preferred for queues as it handles capacity restrictions (not relevant here but good practice)
        pendingTasks.offer(newTask);
        System.out.println("Task added: '" + newTask.getDescription() + "' with ID " + newTask.getId());
    }

    /**
     * Processes the next task from the pending queue.
     * If the queue is not empty, removes the head task, marks it complete,
     * and adds it to the completed tasks list.
     */
    public void processNextTask() {
        // Check if there are tasks to process
        if (pendingTasks.isEmpty()) {
            System.out.println("No tasks pending to process.");
            return; // Exit if queue is empty
        }

        // poll() removes and returns the head of the queue, returns null if empty
        Task taskToProcess = pendingTasks.poll();

        // This check is technically redundant due to isEmpty() check, but robust
        if (taskToProcess != null) {
            System.out.println("Processing task: '" + taskToProcess.getDescription() + "'...");
            taskToProcess.markComplete(); // Update task status
            completedTasks.add(taskToProcess); // Move to completed list
            System.out.println("Task ID " + taskToProcess.getId() + " completed.");
        }
    }

    /**
     * Displays all tasks currently in the pending queue.
     */
    public void viewPendingTasks() {
        System.out.println("\n--- Pending Tasks ---");
        if (pendingTasks.isEmpty()) {
            System.out.println("No tasks are currently pending.");
        } else {
            // Iterate through the queue elements without removing them
            int index = 1;
            for (Task task : pendingTasks) {
                System.out.println(index++ + ". " + task);
            }
        }
        System.out.println("---------------------\n");
    }

    /**
     * Displays all tasks currently in the completed tasks list.
     */
    public void viewCompletedTasks() {
        System.out.println("\n--- Completed Tasks ---");
        if (completedTasks.isEmpty()) {
            System.out.println("No tasks have been completed yet.");
        } else {
            // Iterate through the list elements
            for (int i = 0; i < completedTasks.size(); i++) {
                Task task = completedTasks.get(i); // Access element by index
                System.out.println((i + 1) + ". " + task);
            }
        }
        System.out.println("-----------------------\n");
    }

    /**
     * Displays the main menu options to the user.
     */
    private void displayMenu() {
        System.out.println("Task Processing System Menu:");
        System.out.println("1. Add New Task");
        System.out.println("2. Process Next Task");
        System.out.println("3. View Pending Tasks");
        System.out.println("4. View Completed Tasks");
        System.out.println("5. Exit");
        System.out.print("Enter your choice: ");
    }

    /**
     * The main entry point for the Task Processing System application.
     * Contains the main loop, menu handling, and class-wide exception handling.
     */
    public static void main(String[] args) {
        TaskProcessingSystem system = new TaskProcessingSystem();
        boolean running = true;

        // Class-wide exception handling using a try-catch block
        // This catches unexpected errors during the main execution loop.
        try {
            while (running) {
                system.displayMenu();
                int choice = -1; // Default invalid choice

                // --- Input Validation and Handling for Menu Choice ---
                try {
                    // Attempt to read an integer
                    choice = system.scanner.nextInt();
                    // Consume the newline character left over by nextInt()
                    system.scanner.nextLine();
                } catch (InputMismatchException e) {
                    // Handle cases where the input is not an integer
                    System.err.println("Invalid input. Please enter a number.");
                    // Consume the invalid input to prevent an infinite loop
                    system.scanner.nextLine();
                    continue; // Skip the rest of the loop iteration and show the menu again
                }
                // --- End Input Validation ---

                // --- Switch statement for flow control based on valid integer input ---
                switch (choice) {
                    case 1:
                        system.addTask(); // Call method to add a task
                        break;
                    case 2:
                        system.processNextTask(); // Call method to process the next task
                        break;
                    case 3:
                        system.viewPendingTasks(); // Call method to view pending tasks
                        break;
                    case 4:
                        system.viewCompletedTasks(); // Call method to view completed tasks
                        break;
                    case 5:
                        System.out.println("Exiting Task Processing System. Goodbye!");
                        running = false; // Set running to false to exit the loop
                        break;
                    default:
                        // Handle integer inputs that are outside the valid range (1-5)
                        System.err.println("Invalid choice. Please enter a number between 1 and 5.");
                        break;
                }
                // --- End Switch ---
            }
        } catch (Exception e) {
            // Catch any other unexpected exceptions that might occur
            System.err.println("An unexpected error occurred: " + e.getMessage());
            // Print the stack trace for debugging purposes
            e.printStackTrace();
        } finally {
            // Ensure the scanner resource is closed regardless of whether an exception occurred
            if (system.scanner != null) {
                system.scanner.close();
                System.out.println("Scanner closed."); // Optional: confirm closure
            }
        }
    }
}
