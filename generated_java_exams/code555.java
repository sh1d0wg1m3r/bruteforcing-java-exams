/*
 * Exam Question #555
 * Generated on: 2025-05-11 23:28:45
 * Generated by: Account 1
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Package Delivery Hub Management System
 * 
 * **Scenario:**
 * 
 * You are tasked with developing a simplified Package Delivery Hub Management system. The system should allow managing packages, organizing them into delivery routes, and simulating the processing of deliveries for each route.
 * 
 * **Requirements:**
 * 
 * 1.  **Classes:**
 *     *   `Package`: Represents a single package with attributes:
 *         *   `packageId` (String): Unique identifier.
 *         *   `destinationRouteId` (String): The ID of the delivery route this package belongs to.
 *         *   `status` (String): Current status (e.g., "PENDING", "IN_TRANSIT", "DELIVERED"). Should default to "PENDING".
 *         *   Provide a constructor, getters, and a method to update the status. Include a `toString()` method for easy printing.
 *     *   `DeliveryRoute`: Represents a delivery route with attributes:
 *         *   `routeId` (String): Unique identifier for the route.
 *         *   `packagesToDeliver` (Queue<Package>): A queue holding packages assigned to this route, waiting to be delivered. Packages should be processed in a First-In, First-Out (FIFO) manner.
 *         *   Provide a constructor, a getter for `routeId`, a method `addPackage(Package packageToAdd)` to add a package to the queue, and a method `processNextPackage()` which removes and returns the next package from the queue (or returns `null` if the queue is empty). Include a method to view (but not remove) packages currently in the queue.
 *     *   `DeliveryHub`: The main class managing the hub operations.
 *         *   It should maintain a list of all packages received (`List<Package>`).
 *         *   It should maintain a list of all defined delivery routes (`List<DeliveryRoute>`).
 *         *   It should interact with the user via the console.
 * 
 * 2.  **Functionality (via User Input Menu):**
 *     *   **Add Package:** Prompt the user for a package ID and destination route ID. Create a `Package` object and add it to the central list of all packages. Find the corresponding `DeliveryRoute`. If the route exists, add the package to its queue. If the route does not exist, create a new `DeliveryRoute`, add it to the list of routes, and then add the package to its queue.
 *     *   **View All Packages:** Display details of all packages in the system, including their current status.
 *     *   **View Route Queue:** Prompt the user for a route ID. Display the packages currently waiting in the queue for that specific route, without removing them from the queue.
 *     *   **Process Next Delivery (for a Route):** Prompt the user for a route ID. Find the route. If the route exists and its queue is not empty, remove the next package from the queue using the `processNextPackage()` method. Update the status of this package in the central list of all packages to "DELIVERED". Report which package was processed. If the queue is empty or the route is not found, report this to the user.
 *     *   **Exit:** Terminate the program.
 * 
 * 3.  **Implementation Constraints & Best Practices:**
 *     *   Use `java.util.Queue` (specifically `java.util.LinkedList` as a common implementation) for the `packagesToDeliver` in `DeliveryRoute`.
 *     *   Use `java.util.ArrayList` for the central list of all packages and the list of delivery routes. Declare variables using the `java.util.List` interface.
 *     *   Use `java.util.Scanner` to read user input from the console.
 *     *   Use a `switch` statement in the main loop of `DeliveryHub` to handle different user menu choices.
 *     *   Use `System.out.println()` for normal output (menus, package details, success messages).
 *     *   Use `System.err.println()` for error messages (invalid input, route not found, etc.).
 *     *   Implement class-wide exception handling in the `DeliveryHub`'s main loop using a `try-catch` block to gracefully handle unexpected runtime errors (e.g., `InputMismatchException`, `NumberFormatException` if you were parsing numbers, or general `Exception`).
 *     *   Apply proper encapsulation (private fields, public methods).
 *     *   Use meaningful variable and method names.
 *     *   Include appropriate comments and basic documentation (e.g., Javadoc for classes/methods).
 *     *   Include basic input validation (e.g., checking if input strings are empty for IDs).
 * 
 * **Expected Output:**
 * 
 * The system should present a menu to the user. Based on user input, it should perform the requested action, printing relevant information to `System.out` and error messages to `System.err`.
 * 
 * **Example Interaction Flow:**
 * 
 * ```
 * --- Delivery Hub Menu ---
 * 1. Add Package
 * 2. View All Packages
 * 3. View Route Queue
 * 4. Process Next Delivery for Route
 * 5. Exit
 * Enter your choice: 1
 * Enter Package ID: P001
 * Enter Destination Route ID: R1
 * Package P001 added to route R1.
 * 
 * --- Delivery Hub Menu ---
 * 1. Add Package
 * 2. View All Packages
 * 3. View Route Queue
 * 4. Process Next Delivery for Route
 * 5. Exit
 * Enter your choice: 1
 * Enter Package ID: P002
 * Enter Destination Route ID: R2
 * Package P002 added to route R2.
 * 
 * --- Delivery Hub Menu ---
 * ... (add more packages)
 * 
 * --- Delivery Hub Menu ---
 * ...
 * Enter your choice: 2
 * All Packages:
 * Package ID: P001, Route: R1, Status: PENDING
 * Package ID: P002, Route: R2, Status: PENDING
 * ...
 * 
 * --- Delivery Hub Menu ---
 * ...
 * Enter your choice: 3
 * Enter Route ID to view queue: R1
 * Packages in Queue for Route R1:
 * Package ID: P001, Route: R1, Status: PENDING
 * 
 * --- Delivery Hub Menu ---
 * ...
 * Enter your choice: 4
 * Enter Route ID to process delivery: R1
 * Processed package P001 from route R1. Status updated to DELIVERED.
 * 
 * --- Delivery Hub Menu ---
 * ...
 * Enter your choice: 2
 * All Packages:
 * Package ID: P001, Route: R1, Status: DELIVERED
 * Package ID: P002, Route: R2, Status: PENDING
 * ...
 * 
 * --- Delivery Hub Menu ---
 * ...
 * Enter your choice: 5
 * Exiting Delivery Hub System.
 * ```
 * 
 * Your task is to implement the Java code for this system, adhering to all specified requirements and best practices.
 *
 * EXPLANATION:
 * This solution implements the Package Delivery Hub Management system according to the requirements, demonstrating the use of all specified Java components and adhering to best practices.
 * 
 * 1.  **Class Structure:**
 *     *   `Package`: Encapsulates package data (`id`, `routeId`, `status`). Private fields and public getters/setters ensure encapsulation. The `toString()` method provides a convenient way to display package information.
 *     *   `DeliveryRoute`: Encapsulates route data (`routeId`) and manages a `Queue` of packages (`packagesToDeliver`). `addPackage` adds to the queue, `processNextPackage` removes from the queue (FIFO), and `viewPackagesInQueue` iterates through the queue without removal using an `Iterator`.
 *     *   `DeliveryHub`: The main orchestrator class. It holds the global lists of `allPackages` (`List<Package>`) and `allRoutes` (`List<DeliveryRoute>`). It contains the main application logic, user interaction loop, and delegates tasks to the other classes.
 * 
 * 2.  **Data Structures (`Queue`, `ArrayList`, `List`):**
 *     *   `Queue<Package> packagesToDeliver`: Used within each `DeliveryRoute` to manage packages waiting for delivery in the order they were added. `LinkedList` is used as the concrete implementation of the `Queue` interface. `offer()` is used for adding and `poll()` for removing, which are standard `Queue` operations handling potential capacity issues (though `LinkedList` is unbounded).
 *     *   `List<Package> allPackages`: An `ArrayList` is used to store a central record of *all* packages ever added to the system. This allows viewing all packages regardless of their current status or whether they are still in a route queue.
 *     *   `List<DeliveryRoute> allRoutes`: An `ArrayList` is used to store all created delivery routes.
 *     *   Variables like `allPackages` and `allRoutes` are declared using the `List` interface, promoting good practice by programming to interfaces.
 * 
 * 3.  **User Input (`Scanner`):**
 *     *   A `Scanner` object (`scanner`) is used in the `DeliveryHub` class to read input from `System.in`. It's initialized once and closed when the application exits. Reading input as lines (`nextLine()`) is generally safer than reading numbers directly when mixing with line-based input, helping to avoid common `Scanner` pitfalls.
 * 
 * 4.  **Control Flow (`Switch`):**
 *     *   The `run()` method in `DeliveryHub` uses a `switch` statement based on the user's menu choice to direct execution to the appropriate method (`addPackage`, `viewAllPackages`, etc.).
 * 
 * 5.  **Output (`System.out`, `System.err`):**
 *     *   `System.out.println()` is used for displaying the menu, success messages, and lists of packages/routes.
 *     *   `System.err.println()` is used specifically for error messages, such as invalid input, route not found, or other operational errors.
 * 
 * 6.  **Exception Handling (`try-catch`):**
 *     *   A `try-catch` block is wrapped around the core logic inside the `DeliveryHub.run()` loop. This provides class-wide exception handling, catching potential `NumberFormatException` if the user enters non-numeric input for the menu choice, or other unexpected `Exception` types that might occur during operation. Error messages are printed to `System.err`.
 *     *   Specific `IllegalArgumentException` is caught in `addPackage` for validation errors from `Package` or `DeliveryRoute` constructors.
 * 
 * 7.  **Best Practices:**
 *     *   **Encapsulation:** Fields in `Package` and `DeliveryRoute` are `private` with public methods for access and modification.
 *     *   **Meaningful Names:** Class, method, and variable names are descriptive (e.g., `packagesToDeliver`, `processNextPackage`, `findRouteById`).
 *     *   **Comments/Documentation:** Basic Javadoc comments explain the purpose of classes and key methods. Inline comments clarify specific logic points.
 *     *   **Input Validation:** Basic checks are performed for empty input strings for IDs.
 *     *   **Error Handling:** Specific error conditions (route not found, queue empty, invalid menu choice) are checked and reported using `System.err`. The main `try-catch` provides a safety net for unexpected errors.
 *     *   **Clean Code:** The logic is broken down into smaller, focused methods (`addPackage`, `viewAllPackages`, etc.) within the `DeliveryHub` class. Helper methods like `findRouteById` and `findPackageById` improve readability and avoid code duplication.
 * 
 * This solution effectively integrates the required components into a functional system that simulates a practical scenario, demonstrating a solid understanding of core and intermediate Java concepts.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.Iterator; // Needed to view queue without removing

/**
 * Represents a single package in the delivery system.
 */
class Package {
    private String packageId;
    private String destinationRouteId;
    private String status; // e.g., "PENDING", "IN_TRANSIT", "DELIVERED"

    /**
     * Constructs a new Package.
     *
     * @param packageId The unique ID of the package.
     * @param destinationRouteId The ID of the route this package is destined for.
     */
    public Package(String packageId, String destinationRouteId) {
        if (packageId == null || packageId.trim().isEmpty()) {
            throw new IllegalArgumentException("Package ID cannot be null or empty.");
        }
        if (destinationRouteId == null || destinationRouteId.trim().isEmpty()) {
            throw new IllegalArgumentException("Destination Route ID cannot be null or empty.");
        }
        this.packageId = packageId.trim();
        this.destinationRouteId = destinationRouteId.trim();
        this.status = "PENDING"; // Default status
    }

    // Getters
    public String getPackageId() {
        return packageId;
    }

    public String getDestinationRouteId() {
        return destinationRouteId;
    }

    public String getStatus() {
        return status;
    }

    /**
     * Updates the status of the package.
     *
     * @param status The new status.
     */
    public void setStatus(String status) {
        if (status == null || status.trim().isEmpty()) {
             System.err.println("Warning: Attempted to set package status to null or empty.");
             return;
        }
        this.status = status.trim();
    }

    @Override
    public String toString() {
        return String.format("Package ID: %s, Route: %s, Status: %s",
                             packageId, destinationRouteId, status);
    }
}

/**
 * Represents a delivery route with a queue of packages to be delivered.
 */
class DeliveryRoute {
    private String routeId;
    private Queue<Package> packagesToDeliver; // Queue of packages for this route

    /**
     * Constructs a new DeliveryRoute.
     *
     * @param routeId The unique ID of the route.
     */
    public DeliveryRoute(String routeId) {
        if (routeId == null || routeId.trim().isEmpty()) {
             throw new IllegalArgumentException("Route ID cannot be null or empty.");
        }
        this.routeId = routeId.trim();
        this.packagesToDeliver = new LinkedList<>(); // Use LinkedList as a Queue implementation
    }

    // Getter
    public String getRouteId() {
        return routeId;
    }

    /**
     * Adds a package to the end of the delivery queue for this route.
     *
     * @param packageToAdd The package to add.
     */
    public void addPackage(Package packageToAdd) {
        if (packageToAdd != null) {
            this.packagesToDeliver.offer(packageToAdd); // offer is preferred over add for capacity-constrained queues, though LinkedList is not capacity-constrained. Good practice.
        } else {
            System.err.println("Attempted to add a null package to route " + routeId);
        }
    }

    /**
     * Removes and returns the package at the front of the queue.
     *
     * @return The next package to be delivered, or null if the queue is empty.
     */
    public Package processNextPackage() {
        return this.packagesToDeliver.poll(); // poll returns null if queue is empty
    }

    /**
     * Displays the packages currently in the queue without removing them.
     */
    public void viewPackagesInQueue() {
        if (packagesToDeliver.isEmpty()) {
            System.out.println("Queue for Route " + routeId + " is empty.");
            return;
        }
        System.out.println("Packages in Queue for Route " + routeId + ":");
        // Use iterator to view elements without removing
        Iterator<Package> iterator = packagesToDeliver.iterator();
        while (iterator.hasNext()) {
            System.out.println(iterator.next());
        }
    }

    /**
     * Checks if the route queue is empty.
     * @return true if the queue is empty, false otherwise.
     */
    public boolean isQueueEmpty() {
        return packagesToDeliver.isEmpty();
    }
}

/**
 * Manages the overall Delivery Hub operations.
 */
public class DeliveryHub {
    // Use List interface for flexibility, implement with ArrayList
    private List<Package> allPackages;
    private List<DeliveryRoute> allRoutes;
    private Scanner scanner;

    /**
     * Constructs a new DeliveryHub.
     */
    public DeliveryHub() {
        this.allPackages = new ArrayList<>();
        this.allRoutes = new ArrayList<>();
        this.scanner = new Scanner(System.in);
    }

    /**
     * Finds a DeliveryRoute by its ID.
     *
     * @param routeId The ID of the route to find.
     * @return The DeliveryRoute object if found, null otherwise.
     */
    private DeliveryRoute findRouteById(String routeId) {
        if (routeId == null || routeId.trim().isEmpty()) {
            return null; // Cannot find route with empty ID
        }
        for (DeliveryRoute route : allRoutes) {
            if (route.getRouteId().equalsIgnoreCase(routeId.trim())) {
                return route;
            }
        }
        return null; // Route not found
    }

    /**
     * Finds a Package by its ID in the central list.
     *
     * @param packageId The ID of the package to find.
     * @return The Package object if found, null otherwise.
     */
    private Package findPackageById(String packageId) {
        if (packageId == null || packageId.trim().isEmpty()) {
            return null; // Cannot find package with empty ID
        }
         for (Package pkg : allPackages) {
            if (pkg.getPackageId().equalsIgnoreCase(packageId.trim())) {
                return pkg;
            }
        }
        return null; // Package not found
    }


    /**
     * Handles the process of adding a new package.
     */
    private void addPackage() {
        System.out.print("Enter Package ID: ");
        String packageId = scanner.nextLine();
        System.out.print("Enter Destination Route ID: ");
        String routeId = scanner.nextLine();

        if (packageId.trim().isEmpty() || routeId.trim().isEmpty()) {
            System.err.println("Error: Package ID and Route ID cannot be empty.");
            return;
        }

        // Check if package ID already exists (simple check)
        if (findPackageById(packageId) != null) {
             System.err.println("Error: Package with ID '" + packageId + "' already exists.");
             return;
        }

        try {
            // Create the package
            Package newPackage = new Package(packageId, routeId);
            allPackages.add(newPackage); // Add to central list

            // Find or create the route
            DeliveryRoute targetRoute = findRouteById(routeId);
            if (targetRoute == null) {
                System.out.println("Route '" + routeId + "' not found. Creating new route.");
                targetRoute = new DeliveryRoute(routeId);
                allRoutes.add(targetRoute); // Add new route to list
            }

            // Add package to the route's queue
            targetRoute.addPackage(newPackage);
            System.out.println("Package " + packageId + " added to route " + routeId + ".");

        } catch (IllegalArgumentException e) {
             System.err.println("Input Error: " + e.getMessage());
        } catch (Exception e) {
             System.err.println("An unexpected error occurred while adding package: " + e.getMessage());
             // Optionally log the exception details e.printStackTrace();
        }
    }

    /**
     * Displays details of all packages in the system.
     */
    private void viewAllPackages() {
        if (allPackages.isEmpty()) {
            System.out.println("No packages in the system.");
            return;
        }
        System.out.println("--- All Packages ---");
        for (Package pkg : allPackages) {
            System.out.println(pkg);
        }
        System.out.println("--------------------");
    }

    /**
     * Displays packages in the queue for a specific route.
     */
    private void viewRouteQueue() {
        System.out.print("Enter Route ID to view queue: ");
        String routeId = scanner.nextLine();

        if (routeId.trim().isEmpty()) {
            System.err.println("Error: Route ID cannot be empty.");
            return;
        }

        DeliveryRoute route = findRouteById(routeId);
        if (route == null) {
            System.err.println("Error: Route '" + routeId + "' not found.");
        } else {
            route.viewPackagesInQueue();
        }
    }

    /**
     * Processes the next package for delivery on a specific route.
     */
    private void processRouteDelivery() {
        System.out.print("Enter Route ID to process delivery: ");
        String routeId = scanner.nextLine();

         if (routeId.trim().isEmpty()) {
            System.err.println("Error: Route ID cannot be empty.");
            return;
        }

        DeliveryRoute route = findRouteById(routeId);
        if (route == null) {
            System.err.println("Error: Route '" + routeId + "' not found.");
            return;
        }

        Package processedPackage = route.processNextPackage(); // Get package from queue

        if (processedPackage != null) {
            // Update status in the central list
            Package pkgInList = findPackageById(processedPackage.getPackageId());
            if (pkgInList != null) {
                 pkgInList.setStatus("DELIVERED"); // Update status
                 System.out.println("Processed package " + processedPackage.getPackageId() + " from route " + routeId + ". Status updated to DELIVERED.");
            } else {
                 // This case should ideally not happen if logic is correct, but good for robustness
                 System.err.println("Warning: Processed package " + processedPackage.getPackageId() + " from queue but could not find it in the main package list.");
            }
        } else {
            System.out.println("Queue for Route " + routeId + " is empty. No packages to process.");
        }
    }

    /**
     * Displays the main menu.
     */
    private void displayMenu() {
        System.out.println("\n--- Delivery Hub Menu ---");
        System.out.println("1. Add Package");
        System.out.println("2. View All Packages");
        System.out.println("3. View Route Queue");
        System.out.println("4. Process Next Delivery for Route");
        System.out.println("5. Exit");
        System.out.print("Enter your choice: ");
    }

    /**
     * Runs the main application loop.
     */
    public void run() {
        int choice = -1;
        while (choice != 5) {
            displayMenu();
            try {
                // Read choice as a line first to handle non-integer input gracefully
                String choiceStr = scanner.nextLine();
                choice = Integer.parseInt(choiceStr); // Attempt to parse

                switch (choice) {
                    case 1:
                        addPackage();
                        break;
                    case 2:
                        viewAllPackages();
                        break;
                    case 3:
                        viewRouteQueue();
                        break;
                    case 4:
                        processRouteDelivery();
                        break;
                    case 5:
                        System.out.println("Exiting Delivery Hub System.");
                        break;
                    default:
                        System.err.println("Invalid choice. Please enter a number between 1 and 5.");
                }
            } catch (NumberFormatException e) {
                 System.err.println("Invalid input. Please enter a number.");
                 choice = -1; // Reset choice to stay in loop
            } catch (Exception e) {
                // Catch any other unexpected runtime exceptions
                System.err.println("An unexpected error occurred: " + e.getMessage());
                // e.printStackTrace(); // Uncomment for debugging
            }
        }
        scanner.close(); // Close the scanner when exiting
    }

    /**
     * Main method to start the application.
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        DeliveryHub hub = new DeliveryHub();
        hub.run();
    }
}
