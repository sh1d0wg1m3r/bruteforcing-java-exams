/*
 * Exam Question #1158
 * Generated on: 2025-05-12 17:32:53
 * Generated by: Account 4
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Software Build Process Simulator
 * 
 * **Scenario:**
 * 
 * You are tasked with creating a simplified simulation of a software build process manager. This system manages tasks that need to be executed as part of a software build. Tasks are added to a pending queue, processed one by one, and then moved to a list of completed or failed tasks.
 * 
 * **Requirements:**
 * 
 * Implement a Java program that simulates this process. Your solution must adhere to the following:
 * 
 * 1.  **Core Components:**
 *     *   Use `java.util.Queue` to represent the queue of pending build tasks.
 *     *   Use `java.util.ArrayList` to store the history of processed tasks (both successful and failed).
 *     *   Declare variables that hold the list of processed tasks using the `java.util.List` interface.
 *     *   Use `java.util.Scanner` to accept user commands and task details from the console.
 *     *   Utilize a `switch` statement for controlling the flow based on user commands or task types.
 *     *   Print error messages specifically to `System.err`.
 *     *   Print all normal output (menus, prompts, status, success messages) to `System.out`.
 *     *   Implement exception handling using `try-catch` blocks. This should include handling potential input issues and demonstrating how the application catches and reports errors during its operation. Consider placing a general catch in the main command loop and specific catches where appropriate (e.g., input parsing).
 * 
 * 2.  **Functionality:**
 *     *   The program should present a menu of actions to the user: "add task", "process next task", "view status", "exit".
 *     *   **Add Task:** Prompt the user for task details (ID, description, type). Task types should be limited (e.g., "COMPILE", "TEST", "DEPLOY"). Add the new task to the pending queue. Validate that the task type entered is valid; if not, print an error to `System.err` and do not add the task.
 *     *   **Process Next Task:** Take the next task from the pending queue. If the queue is empty, inform the user. Simulate processing the task:
 *         *   Change its status (e.g., from PENDING to PROCESSING).
 *         *   Use a `switch` statement on the task type to simulate different processing logic. For example, "COMPILE" might have a chance of failure, "TEST" might have a different chance of failure, and "DEPLOY" might always succeed.
 *         *   After simulated processing, change the task status to `COMPLETED` or `FAILED`.
 *         *   Move the task from the pending queue to the processed tasks list.
 *         *   Report the outcome (success or failure) to `System.out` (success) or `System.err` (failure).
 *     *   **View Status:** Display the current tasks in the pending queue and the tasks in the processed list, including their status.
 *     *   **Exit:** Terminate the program.
 * 
 * 3.  **Object-Oriented Design & Best Practices:**
 *     *   Create a `Task` class to represent a build task with properties like ID, description, type, and status. Use proper encapsulation (private fields, public getters/setters where necessary).
 *     *   Use an `enum` for task types (e.g., `TaskType`) and task statuses (e.g., `TaskStatus`).
 *     *   Create a `BuildProcessManager` class to manage the queue and list, and contain the logic for adding, processing, and displaying tasks.
 *     *   Use meaningful variable and method names.
 *     *   Include appropriate comments (including Javadoc for classes/methods) to explain the code.
 *     *   Implement input validation (e.g., for task type).
 * 
 * **Expected Output Structure:**
 * 
 * The program should interact with the user via the console. Example interaction flow:
 * 
 * ```
 * Build Process Simulator Menu:
 * 1. Add Task
 * 2. Process Next Task
 * 3. View Status
 * 4. Exit
 * Enter command (1-4): 1
 * Enter Task ID: task1
 * Enter Description: Compile source code
 * Enter Task Type (COMPILE, TEST, DEPLOY): COMPILE
 * Task 'task1' added to pending queue.
 * 
 * Build Process Simulator Menu:
 * 1. Add Task
 * 2. Process Next Task
 * 3. View Status
 * 4. Exit
 * Enter command (1-4): 3
 * --- Pending Tasks ---
 * Task ID: task1, Description: Compile source code, Type: COMPILE, Status: PENDING
 * --- Processed Tasks ---
 * (Empty)
 * 
 * Build Process Simulator Menu:
 * 1. Add Task
 * 2. Process Next Task
 * 3. View Status
 * 4. Exit
 * Enter command (1-4): 2
 * Processing task 'task1'...
 * Simulating COMPILE...
 * Task 'task1' completed successfully.
 * 
 * Build Process Simulator Menu:
 * 1. Add Task
 * 2. Process Next Task
 * 3. View Status
 * 4. Exit
 * Enter command (1-4): 3
 * --- Pending Tasks ---
 * (Empty)
 * --- Processed Tasks ---
 * Task ID: task1, Description: Compile source code, Type: COMPILE, Status: COMPLETED
 * 
 * Build Process Simulator Menu:
 * 1. Add Task
 * 2. Process Next Task
 * 3. View Status
 * 4. Exit
 * Enter command (1-4): 1
 * Enter Task ID: task2
 * Enter Description: Run unit tests
 * Enter Task Type (COMPILE, TEST, DEPLOY): TEST
 * Task 'task2' added to pending queue.
 * 
 * Build Process Simulator Menu:
 * 1. Add Task
 * 2. Process Next Task
 * 3. View Status
 * 4. Exit
 * Enter command (1-4): 2
 * Processing task 'task2'...
 * Simulating TEST...
 * Task 'task2' failed: Test failures detected.
 * (Error message printed to System.err)
 * 
 * Build Process Simulator Menu:
 * 1. Add Task
 * 2. Process Next Task
 * 3. View Status
 * 4. Exit
 * Enter command (1-4): 3
 * --- Pending Tasks ---
 * (Empty)
 * --- Processed Tasks ---
 * Task ID: task1, Description: Compile source code, Type: COMPILE, Status: COMPLETED
 * Task ID: task2, Description: Run unit tests, Type: TEST, Status: FAILED
 * 
 * Build Process Simulator Menu:
 * 1. Add Task
 * 2. Process Next Task
 * 3. View Status
 * 4. Exit
 * Enter command (1-4): 4
 * Exiting simulator.
 * ```
 * *(Note: Simulated failures can be implemented using random chance)*
 * 
 * This task requires you to integrate multiple core Java data structures and control flow mechanisms in a practical, object-oriented application, demonstrating your understanding of managing state, handling input, and dealing with potential errors.
 *
 * EXPLANATION:
 * This solution implements a simplified build process simulator demonstrating the required Java concepts and best practices.
 * 
 * **Core Components Usage:**
 * 
 * 1.  **`Queue` (`java.util.Queue`):** The `pendingTasks` field in `BuildProcessManager` is declared as a `Queue<Task>` and initialized with a `LinkedList<>`. This correctly uses the `Queue` interface, leveraging the FIFO (First-In, First-Out) behavior of a linked list implementation, which is suitable for managing tasks waiting in a queue. `offer()` is used for adding tasks and `poll()` for removing and retrieving the next task.
 * 2.  **`ArrayList` (`java.util.ArrayList`):** The `processedTasks` field in `BuildProcessManager` is initialized with `new ArrayList<>()`. This provides a dynamic array to store the history of tasks after they have been processed.
 * 3.  **`List interface` (`java.util.List`):** The `processedTasks` field is declared using the `List<Task>` interface (`private List<Task> processedTasks;`), even though it's implemented as an `ArrayList`. This is a best practice (programming to the interface) as it allows for easier switching to a different `List` implementation later if needed, without changing the code that uses the `processedTasks` variable.
 * 4.  **`Scanner` (`java.util.Scanner`):** Used in the `main` method of `BuildSimulatorApp` to read user input for commands and task details from `System.in`. It's closed in a `finally` block to ensure resources are released.
 * 5.  **`Switch statement`:**
 *     *   In the `main` method, a `switch` is used to handle the different user commands (1-4).
 *     *   In the `processNextTask` method, a `switch` is used on the `TaskType` enum to simulate different processing logic and success/failure conditions for `COMPILE`, `TEST`, and `DEPLOY` tasks.
 * 6.  **`System.err`:** Used exclusively for printing error messages, such as invalid user input (e.g., invalid task type, non-numeric command) or simulated task processing failures.
 * 7.  **`System.out`:** Used for all normal output, including the menu, prompts, success messages, task status display, and confirmation messages (like a task being added).
 * 8.  **Class-wide `try-catch` blocks:**
 *     *   The `main` method wraps the entire command processing loop in a `try-catch` block to catch any unexpected `Exception` that might propagate up, preventing the program from crashing and printing an error to `System.err`.
 *     *   Specific `try-catch` blocks are used within `main` for parsing the user's command choice (`Integer.parseInt`) to handle `NumberFormatException`.
 *     *   Specific `try-catch` blocks are used within `addTask` to catch `IllegalArgumentException` from the `Task` constructor and a general `Exception` for other potential issues.
 *     *   Specific `try-catch` blocks are used within `processNextTask` to catch `InterruptedException` during the simulated sleep and a general `Exception` for other potential issues during processing simulation. The `finally` block ensures the task is added to the processed list even if an exception occurs during processing.
 * 
 * **Object-Oriented Design & Best Practices:**
 * 
 * *   **Encapsulation:** The `Task` class has private fields (`taskId`, `description`, `type`, `status`) and provides public getter methods to access them. A specific setter (`setStatus`) is provided as the status is intended to change during processing.
 * *   **Enums:** `TaskType` and `TaskStatus` enums are used to define a fixed set of valid values for task types and statuses, improving code readability and preventing invalid states. The `TaskType.fromString` method provides a safe way to convert user string input into the enum.
 * *   **Meaningful Names:** Class names (`Task`, `BuildProcessManager`, `BuildSimulatorApp`), method names (`addTask`, `processNextTask`, `displayStatus`, `printMenu`), and variable names are descriptive and indicate their purpose.
 * *   **Comments and Documentation:** Javadoc comments are provided for classes and methods explaining their purpose, parameters, and return values. Inline comments explain specific logic points (like the random failure simulation or why `offer` is used).
 * *   **Input Validation:** The `addTask` method explicitly checks if the provided task type string is valid using `TaskType.fromString` before creating the `Task` object. The `Task` constructor also validates its inputs. The main loop validates if the command input is a valid integer.
 * *   **Error Handling:** Errors are reported to `System.err`. Specific exceptions are caught where possible (`NumberFormatException`, `IllegalArgumentException`, `InterruptedException`), and general `Exception` catches are included for robustness against unexpected issues. Stack traces are printed for unexpected errors to aid debugging.
 * *   **Clean Code Structure:** The code is organized into logical classes (`Task`, `BuildProcessManager`, `BuildSimulatorApp`) with clear responsibilities. The main application logic is separated from the build process management logic.
 * 
 * The solution effectively integrates the required components into a functional simulation, demonstrating proper data structure usage, control flow, object-oriented design, and robust error handling in a practical scenario.
 */

import java.util.Queue;
import java.util.LinkedList;
import java.util.List;
import java.util.ArrayList;
import java.util.Scanner;
import java.util.concurrent.TimeUnit; // For simulating processing time
import java.util.Random; // For simulating failures

// Enum for Task Types
enum TaskType {
    COMPILE,
    TEST,
    DEPLOY;

    /**
     * Converts a string to a TaskType enum, case-insensitively.
     * Returns null if the string does not match any TaskType.
     * @param typeString The string to convert.
     * @return The corresponding TaskType or null.
     */
    public static TaskType fromString(String typeString) {
        if (typeString == null) {
            return null;
        }
        try {
            return TaskType.valueOf(typeString.toUpperCase());
        } catch (IllegalArgumentException e) {
            return null; // Not a valid TaskType string
        }
    }
}

// Enum for Task Status
enum TaskStatus {
    PENDING,
    PROCESSING,
    COMPLETED,
    FAILED
}

/**
 * Represents a single build task in the simulation.
 */
class Task {
    private String taskId;
    private String description;
    private TaskType type;
    private TaskStatus status;

    /**
     * Constructs a new Task.
     * @param taskId The unique identifier for the task.
     * @param description A brief description of the task.
     * @param type The type of the task (COMPILE, TEST, DEPLOY).
     */
    public Task(String taskId, String description, TaskType type) {
        if (taskId == null || taskId.trim().isEmpty()) {
            throw new IllegalArgumentException("Task ID cannot be null or empty.");
        }
         if (description == null || description.trim().isEmpty()) {
            throw new IllegalArgumentException("Description cannot be null or empty.");
        }
         if (type == null) {
             throw new IllegalArgumentException("Task type cannot be null.");
         }

        this.taskId = taskId;
        this.description = description;
        this.type = type;
        this.status = TaskStatus.PENDING; // Tasks start as pending
    }

    // --- Getters ---
    public String getTaskId() {
        return taskId;
    }

    public String getDescription() {
        return description;
    }

    public TaskType getType() {
        return type;
    }

    public TaskStatus getStatus() {
        return status;
    }

    // --- Setter for status (used during processing) ---
    public void setStatus(TaskStatus status) {
        this.status = status;
    }

    /**
     * Provides a string representation of the Task.
     */
    @Override
    public String toString() {
        return String.format("Task ID: %s, Description: %s, Type: %s, Status: %s",
                             taskId, description, type, status);
    }
}

/**
 * Manages the build process, including the pending task queue and processed task history.
 */
class BuildProcessManager {
    private Queue<Task> pendingTasks;
    private List<Task> processedTasks;
    private Random random; // For simulating random failures

    /**
     * Constructs a new BuildProcessManager.
     * Initializes the pending task queue and the processed task list.
     */
    public BuildProcessManager() {
        // Requirement: Use Queue (specifically LinkedList implementing Queue)
        this.pendingTasks = new LinkedList<>();
        // Requirement: Use List interface and ArrayList implementation
        this.processedTasks = new ArrayList<>();
        this.random = new Random();
    }

    /**
     * Adds a new task to the pending queue.
     * Validates the input task type string.
     * @param taskId The ID of the task.
     * @param description The description of the task.
     * @param typeString The string representation of the task type.
     */
    public void addTask(String taskId, String description, String typeString) {
        // Input validation for type string
        TaskType type = TaskType.fromString(typeString);

        if (type == null) {
            // Requirement: Use System.err for error messages
            System.err.println("Error: Invalid task type provided: " + typeString +
                               ". Valid types are: " + java.util.Arrays.toString(TaskType.values()));
            return; // Do not add the task
        }

        try {
            Task newTask = new Task(taskId, description, type);
            pendingTasks.offer(newTask); // offer() is preferred over add() as it returns false on failure (though unlikely with LinkedList)
            // Requirement: Use System.out for normal output
            System.out.println("Task '" + taskId + "' added to pending queue.");
        } catch (IllegalArgumentException e) {
             // Requirement: Use System.err for error messages (for Task constructor validation errors)
            System.err.println("Error creating task: " + e.getMessage());
        } catch (Exception e) {
            // General catch for unexpected errors during task creation/adding
             System.err.println("An unexpected error occurred while adding task: " + e.getMessage());
             e.printStackTrace(); // Print stack trace for debugging unexpected errors
        }
    }

    /**
     * Processes the next task from the pending queue.
     * Simulates processing based on task type and moves the task to the processed list.
     */
    public void processNextTask() {
        Task taskToProcess = pendingTasks.poll(); // Retrieve and remove the head of the queue

        if (taskToProcess == null) {
            System.out.println("No tasks pending to process.");
            return;
        }

        try {
            taskToProcess.setStatus(TaskStatus.PROCESSING);
            System.out.println("Processing task '" + taskToProcess.getTaskId() + "'...");

            // Simulate processing time
            TimeUnit.MILLISECONDS.sleep(500);

            // Requirement: Use switch statement for flow control based on task type
            switch (taskToProcess.getType()) {
                case COMPILE:
                    System.out.println("Simulating COMPILE...");
                    if (random.nextDouble() < 0.1) { // 10% chance of failure
                        taskToProcess.setStatus(TaskStatus.FAILED);
                        System.err.println("Task '" + taskToProcess.getTaskId() + "' failed: Compilation errors detected.");
                    } else {
                        taskToProcess.setStatus(TaskStatus.COMPLETED);
                        System.out.println("Task '" + taskToProcess.getTaskId() + "' completed successfully.");
                    }
                    break;

                case TEST:
                    System.out.println("Simulating TEST...");
                     if (random.nextDouble() < 0.05) { // 5% chance of failure
                        taskToProcess.setStatus(TaskStatus.FAILED);
                        System.err.println("Task '" + taskToProcess.getTaskId() + "' failed: Test failures detected.");
                    } else {
                        taskToProcess.setStatus(TaskStatus.COMPLETED);
                        System.out.println("Task '" + taskToProcess.getTaskId() + "' completed successfully.");
                    }
                    break;

                case DEPLOY:
                    System.out.println("Simulating DEPLOY...");
                    // Deploy always succeeds in this simulation
                    taskToProcess.setStatus(TaskStatus.COMPLETED);
                    System.out.println("Task '" + taskToProcess.getTaskId() + "' completed successfully.");
                    break;

                default:
                    // Should not happen with enum, but good practice for robustness
                    taskToProcess.setStatus(TaskStatus.FAILED);
                    System.err.println("Task '" + taskToProcess.getTaskId() + "' failed: Unknown task type.");
                    break;
            }

        } catch (InterruptedException e) {
            // Handle interruption during sleep
            taskToProcess.setStatus(TaskStatus.FAILED);
            System.err.println("Task '" + taskToProcess.getTaskId() + "' processing interrupted: " + e.getMessage());
            Thread.currentThread().interrupt(); // Restore the interrupted status
        } catch (Exception e) {
            // Requirement: Class-wide exception handling with try-catch blocks
            // Catch any other unexpected errors during processing
            taskToProcess.setStatus(TaskStatus.FAILED);
             System.err.println("An unexpected error occurred while processing task '" + taskToProcess.getTaskId() + "': " + e.getMessage());
             e.printStackTrace(); // Print stack trace for debugging unexpected errors
        } finally {
            // Ensure the task is moved to the processed list regardless of outcome
            processedTasks.add(taskToProcess);
        }
    }

    /**
     * Displays the current status of pending and processed tasks.
     */
    public void displayStatus() {
        System.out.println("\n--- Pending Tasks ---");
        if (pendingTasks.isEmpty()) {
            System.out.println("(Empty)");
        } else {
            // pendingTasks is a Queue, which is Iterable
            for (Task task : pendingTasks) {
                System.out.println(task);
            }
        }

        System.out.println("\n--- Processed Tasks ---");
        if (processedTasks.isEmpty()) {
            System.out.println("(Empty)");
        } else {
            // processedTasks is a List (ArrayList)
            for (Task task : processedTasks) {
                System.out.println(task);
            }
        }
         System.out.println("-----------------------\n");
    }
}

/**
 * Main application class for the Build Process Simulator.
 * Handles user interaction and orchestrates the BuildProcessManager.
 */
public class BuildSimulatorApp {

    public static void main(String[] args) {
        // Requirement: Use Scanner for user input
        Scanner scanner = new Scanner(System.in);
        BuildProcessManager manager = new BuildProcessManager();
        boolean running = true;

        // Requirement: Class-wide exception handling with try-catch blocks
        // Wrap the main application loop in a try-catch for robustness
        try {
            while (running) {
                printMenu();

                // Requirement: Use try-catch blocks for input handling
                int choice = -1;
                try {
                    System.out.print("Enter command (1-4): ");
                    String input = scanner.nextLine();
                    choice = Integer.parseInt(input);
                } catch (NumberFormatException e) {
                    // Requirement: Use System.err for error messages
                    System.err.println("Invalid input. Please enter a number (1-4).");
                    continue; // Skip to the next loop iteration
                } catch (Exception e) {
                     System.err.println("An unexpected error occurred while reading input: " + e.getMessage());
                     e.printStackTrace();
                     continue;
                }


                // Requirement: Use switch statement for flow control based on command
                switch (choice) {
                    case 1:
                        // Add Task
                        System.out.print("Enter Task ID: ");
                        String taskId = scanner.nextLine();
                        System.out.print("Enter Description: ");
                        String description = scanner.nextLine();
                        System.out.print("Enter Task Type (COMPILE, TEST, DEPLOY): ");
                        String typeString = scanner.nextLine();
                        manager.addTask(taskId, description, typeString);
                        break;

                    case 2:
                        // Process Next Task
                        manager.processNextTask();
                        break;

                    case 3:
                        // View Status
                        manager.displayStatus();
                        break;

                    case 4:
                        // Exit
                        System.out.println("Exiting simulator.");
                        running = false;
                        break;

                    default:
                        // Requirement: Use System.err for error messages
                        System.err.println("Invalid command. Please enter a number between 1 and 4.");
                        break;
                }
            }
        } catch (Exception e) {
            // Catch any unexpected exceptions from the main loop
            System.err.println("An unhandled exception occurred in the main application loop: " + e.getMessage());
            e.printStackTrace(); // Print stack trace for debugging
        } finally {
             // Ensure the scanner is closed when the application exits
            if (scanner != null) {
                scanner.close();
            }
        }
    }

    /**
     * Prints the main menu options to the console.
     */
    private static void printMenu() {
        System.out.println("\nBuild Process Simulator Menu:");
        System.out.println("1. Add Task");
        System.out.println("2. Process Next Task");
        System.out.println("3. View Status");
        System.out.println("4. Exit");
    }
}
