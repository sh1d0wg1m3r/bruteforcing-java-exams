/*
 * Exam Question #1028
 * Generated on: 2025-05-12 17:14:52
 * Generated by: Account 2
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Server Task Management System
 * 
 * **Objective:** Design and implement a command-line application to simulate a simple server task management system. The system manages a queue of incoming tasks and a fixed pool of servers used to process these tasks.
 * 
 * **Scenario:**
 * You have a limited number of servers available to process client requests (tasks). Incoming tasks are placed in a waiting queue. When a server becomes available, the next task from the queue is assigned to it for processing.
 * 
 * **Requirements:**
 * 
 * 1.  **Implement the System:** Create a Java program that simulates this scenario.
 * 2.  **Core Functionality:** The system must support the following operations via a command-line menu:
 *     *   **Add New Task:** Prompt the user for a Task ID (an integer) and a brief description (a string). Add this task to the waiting queue. Task IDs must be positive integers.
 *     *   **Process Next Task:** Take the next task from the waiting queue. Find the first available server. If both a task is available in the queue AND a server is available, assign the task to the server, mark the server as 'Busy', simulate processing (print a message), and then mark the server as 'Available' again.
 *     *   **View Task Queue:** Display the Task ID and description of all tasks currently waiting in the queue, in the order they will be processed.
 *     *   **View Server Status:** Display the status (Available or Busy) of each server in the system.
 *     *   **Exit:** Terminate the application.
 * 3.  **Required Java Components:** Your solution **must** utilize **ALL** of the following:
 *     *   `java.util.Queue` (for the waiting tasks)
 *     *   `java.util.ArrayList` (for managing the collection of servers)
 *     *   `java.util.List` interface (use `List` as the type when declaring the server collection)
 *     *   `java.util.Scanner` (for reading user input)
 *     *   `switch` statement (for handling menu options)
 *     *   `System.err` (for displaying error messages, e.g., invalid input, queue empty, no servers available)
 *     *   `System.out` (for displaying the menu, prompts, success messages, and status)
 *     *   Class-wide exception handling using `try-catch` blocks (to handle potential runtime errors, especially related to user input parsing).
 * 4.  **Best Practices:**
 *     *   Implement proper encapsulation (private fields, public methods).
 *     *   Use meaningful variable and method names.
 *     *   Include appropriate comments and documentation (e.g., Javadoc for classes/methods).
 *     *   Perform input validation (e.g., ensuring Task ID is a positive integer, menu choice is valid).
 *     *   Implement proper error handling as described above.
 *     *   Structure your code clearly into logical classes (`Task`, `Server`, `ServerTaskSystem`, and a main class for the application loop).
 * 5.  **System Configuration:** Assume a fixed number of servers (e.g., 3 servers).
 * 
 * **Input Format:**
 * The program should present a menu like this:
 * ```
 * Server Task Management System
 * 1. Add New Task
 * 2. Process Next Task
 * 3. View Task Queue
 * 4. View Server Status
 * 5. Exit
 * Enter your choice:
 * ```
 * Depending on the choice, the program will prompt for additional input (Task ID, Description).
 * 
 * **Output Format:**
 * *   Menu and prompts should be clear (`System.out`).
 * *   Success messages (e.g., "Task added.", "Task processed.") should be informative (`System.out`).
 * *   Status displays should clearly list queue contents or server status (`System.out`).
 * *   Error messages (e.g., "Invalid input.", "Queue is empty.", "No servers available.") must be printed using `System.err`.
 * 
 * **Evaluation:**
 * Your solution will be evaluated on:
 * *   Correct implementation of all core functionalities.
 * *   Proper and effective use of all required Java components.
 * *   Adherence to best practices (encapsulation, naming, comments, clean structure).
 * *   Robust input validation and error handling.
 * *   Correct use of `System.out` and `System.err`.
 * 
 * **Good luck!**
 *
 * EXPLANATION:
 * This solution implements the Server Task Management System as requested, demonstrating the use of all required Java components and best practices.
 * 
 * 1.  **Class Structure:** The code is organized into four classes:
 *     *   `ServerStatus` (enum): Defines the possible states of a server (`Available`, `Busy`).
 *     *   `Task`: Represents a single task with an ID and description. It follows encapsulation principles with private fields and public getters. `toString()` provides a convenient representation.
 *     *   `Server`: Represents a server with an ID and status. It also uses encapsulation and includes a setter for updating the status. `toString()` provides a status representation.
 *     *   `ServerTaskSystem`: This is the core logic class. It holds the `Queue` of waiting tasks and the `List` of servers. It contains methods for adding tasks, processing tasks, viewing the queue, and viewing server status.
 *     *   `ServerTaskManagerApp`: Contains the `main` method, handles user interaction, displays the menu, reads input using `Scanner`, uses a `switch` statement for menu navigation, and manages the main application loop.
 * 
 * 2.  **Required Component Usage:**
 *     *   `java.util.Queue`: The `taskQueue` is declared as `Queue<Task>` and instantiated as `LinkedList<>`, which is a common implementation of the `Queue` interface providing FIFO behavior (`add` for adding, `poll` for removing from the head).
 *     *   `java.util.ArrayList`: The `servers` collection is instantiated as `ArrayList<Server>`.
 *     *   `java.util.List` interface: The `servers` collection is declared using the `List<Server>` interface type, demonstrating programming to the interface.
 *     *   `java.util.Scanner`: Used in the `main` method to read user input from the console. `nextLine()` is used to read entire lines, which is generally safer when mixing string and potential integer inputs.
 *     *   `switch` statement: Used in the `main` method to dispatch actions based on the user's menu choice.
 *     *   `System.err`: Used for printing error messages, such as invalid input formats, the queue being empty when processing is attempted, or no servers being available.
 *     *   `System.out`: Used for printing the menu, prompts, success messages, and the current status of the queue and servers.
 *     *   Class-wide exception handling (`try-catch`): A large `try-catch` block wraps the main application loop in the `main` method to catch unexpected runtime exceptions. More specific `try-catch` blocks are used within the loop (e.g., when parsing user input for the menu choice or Task ID) to handle expected format errors (`NumberFormatException`).
 * 
 * 3.  **Best Practices:**
 *     *   **Encapsulation:** Fields in `Task`, `Server`, and `ServerTaskSystem` are `private`, accessed via public methods (getters, setters, functional methods).
 *     *   **Meaningful Names:** Class names (`Task`, `Server`, `ServerTaskSystem`), variable names (`taskQueue`, `servers`, `availableServer`, `taskToProcess`), and method names (`addTask`, `processNextTask`, `viewTaskQueue`, `viewServerStatus`) are descriptive.
 *     *   **Comments/Documentation:** Javadoc comments are provided for classes and key methods explaining their purpose, parameters, and return values.
 *     *   **Input Validation:** Input for menu choice and Task ID is read as a string and then parsed. A `try-catch(NumberFormatException)` handles cases where the input is not a valid integer. An explicit check (`taskId <= 0`) ensures the Task ID is positive.
 *     *   **Error Handling:** Specific error conditions (empty queue, no available servers) are checked *before* attempting operations that would fail, and informative messages are printed to `System.err`. Input parsing errors are caught using `try-catch`.
 *     *   **Clean Code Structure:** The logic is divided into classes with clear responsibilities. The `main` method focuses on the user interface loop and calling methods on the `ServerTaskSystem` object.
 * 
 * 4.  **Logic Implementation:**
 *     *   The `ServerTaskSystem` constructor initializes the `LinkedList` for the queue and the `ArrayList` for servers, creating the specified number of server objects.
 *     *   `addTask` simply uses `taskQueue.add()`.
 *     *   `processNextTask` checks for an empty queue first (`taskQueue.isEmpty()`). Then, it iterates through the `servers` `List` to find the first `Available` server. If either check fails, an error is printed to `System.err`. If successful, it uses `taskQueue.poll()` to get and remove the task from the queue, updates the server status, prints simulation messages, and finally resets the server status to `Available`.
 *     *   `viewTaskQueue` iterates through the `taskQueue` (using its iterator provided by the enhanced for loop) to print tasks without removing them.
 *     *   `viewServerStatus` iterates through the `servers` `List` to print each server's status.
 *     *   The `main` method contains the loop, menu display, input reading, validation, and the `switch` statement to direct execution based on user input. The `finally` block ensures the `Scanner` is closed.
 * 
 * This solution effectively integrates the required components to solve the simulated problem, adhering to best practices and including necessary error handling, making it a challenging yet solvable exam task.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.InputMismatchException; // Though using nextLine and parseInt is safer

// Enum for Server Status
enum ServerStatus {
    Available, Busy
}

// Represents a Task
class Task {
    private int id;
    private String description;

    /**
     * Constructs a new Task.
     * @param id The unique identifier for the task.
     * @param description A brief description of the task.
     */
    public Task(int id, String description) {
        this.id = id;
        this.description = description;
    }

    // Getters
    public int getId() {
        return id;
    }

    public String getDescription() {
        return description;
    }

    /**
     * Returns a string representation of the Task.
     * @return String representation.
     */
    @Override
    public String toString() {
        return "Task [ID=" + id + ", Desc='" + description + "']";
    }
}

// Represents a Server
class Server {
    private int id;
    private ServerStatus status;

    /**
     * Constructs a new Server.
     * @param id The unique identifier for the server.
     */
    public Server(int id) {
        this.id = id;
        this.status = ServerStatus.Available; // Servers start as available
    }

    // Getters
    public int getId() {
        return id;
    }

    public ServerStatus getStatus() {
        return status;
    }

    // Setter for status
    public void setStatus(ServerStatus status) {
        this.status = status;
    }

    /**
     * Returns a string representation of the Server status.
     * @return String representation.
     */
    @Override
    public String toString() {
        return "Server " + id + " [" + status + "]";
    }
}

// Manages the task queue and servers
class ServerTaskSystem {
    private Queue<Task> taskQueue;
    private List<Server> servers;
    private final int numberOfServers;

    /**
     * Constructs the ServerTaskSystem.
     * Initializes the task queue and the specified number of servers.
     * @param numberOfServers The total number of servers in the system.
     */
    public ServerTaskSystem(int numberOfServers) {
        this.numberOfServers = numberOfServers;
        this.taskQueue = new LinkedList<>(); // LinkedList implements Queue
        this.servers = new ArrayList<>(); // ArrayList implements List
        initializeServers();
    }

    /**
     * Initializes the servers list.
     */
    private void initializeServers() {
        for (int i = 1; i <= numberOfServers; i++) {
            servers.add(new Server(i));
        }
    }

    /**
     * Adds a new task to the waiting queue.
     * @param task The task to add.
     */
    public void addTask(Task task) {
        taskQueue.add(task);
        System.out.println("Task " + task.getId() + " added to the queue.");
    }

    /**
     * Attempts to process the next task in the queue using an available server.
     */
    public void processNextTask() {
        // Check if queue is empty
        if (taskQueue.isEmpty()) {
            System.err.println("Error: Task queue is empty. No tasks to process.");
            return;
        }

        // Find an available server
        Server availableServer = null;
        for (Server server : servers) { // Iterate through the List of servers
            if (server.getStatus() == ServerStatus.Available) {
                availableServer = server;
                break; // Found one, exit loop
            }
        }

        // Check if a server was found
        if (availableServer == null) {
            System.err.println("Error: No servers are currently available to process tasks.");
            return;
        }

        // Process the task
        Task taskToProcess = taskQueue.poll(); // Remove task from the head of the queue
        if (taskToProcess != null) { // Should not be null based on isEmpty check, but good practice
            availableServer.setStatus(ServerStatus.Busy);
            System.out.println("Processing " + taskToProcess + " on " + availableServer.toString().replace("[Busy]", "").trim() + "..."); // Show server ID only
            // Simulate processing...
            try {
                 Thread.sleep(500); // Simulate work takes time
            } catch (InterruptedException e) {
                 Thread.currentThread().interrupt(); // Restore interrupt status
                 System.err.println("Processing interrupted.");
            }
            availableServer.setStatus(ServerStatus.Available);
            System.out.println("Finished processing Task " + taskToProcess.getId() + ". " + availableServer.toString().replace("[Available]", "").trim() + " is now available.");
        }
    }

    /**
     * Displays all tasks currently in the waiting queue.
     */
    public void viewTaskQueue() {
        if (taskQueue.isEmpty()) {
            System.out.println("Task queue is empty.");
            return;
        }
        System.out.println("--- Task Queue ---");
        int index = 1;
        // Iterate through the queue without removing elements
        for (Task task : taskQueue) { // Iterating over the Queue
            System.out.println(index++ + ". " + task);
        }
        System.out.println("------------------");
    }

    /**
     * Displays the current status of all servers.
     */
    public void viewServerStatus() {
        System.out.println("--- Server Status ---");
        for (Server server : servers) { // Iterate through the List of servers
            System.out.println(server);
        }
        System.out.println("---------------------");
    }
}

// Main class for the application entry point and user interaction loop
public class ServerTaskManagerApp {

    public static void main(String[] args) {
        final int NUM_SERVERS = 3; // Fixed number of servers
        ServerTaskSystem system = new ServerTaskSystem(NUM_SERVERS);
        Scanner scanner = new Scanner(System.in);
        boolean running = true;

        // Class-wide exception handling for the main application loop
        try {
            while (running) {
                printMenu();

                String choiceStr = scanner.nextLine();
                int choice = 0;

                // Input validation for menu choice
                try {
                    choice = Integer.parseInt(choiceStr);
                } catch (NumberFormatException e) {
                    System.err.println("Invalid input. Please enter a number.");
                    continue; // Skip to next iteration
                }

                // Use switch statement for menu handling
                switch (choice) {
                    case 1: // Add New Task
                        System.out.print("Enter Task ID (positive integer): ");
                        String taskIdStr = scanner.nextLine();
                        System.out.print("Enter Task Description: ");
                        String taskDesc = scanner.nextLine();

                        try {
                            int taskId = Integer.parseInt(taskIdStr);
                            if (taskId <= 0) {
                                System.err.println("Error: Task ID must be a positive integer.");
                            } else {
                                Task newTask = new Task(taskId, taskDesc);
                                system.addTask(newTask);
                            }
                        } catch (NumberFormatException e) {
                            System.err.println("Error: Invalid Task ID format. Please enter an integer.");
                        }
                        break;

                    case 2: // Process Next Task
                        system.processNextTask();
                        break;

                    case 3: // View Task Queue
                        system.viewTaskQueue();
                        break;

                    case 4: // View Server Status
                        system.viewServerStatus();
                        break;

                    case 5: // Exit
                        System.out.println("Exiting Server Task Management System. Goodbye!");
                        running = false;
                        break;

                    default: // Invalid menu choice
                        System.err.println("Invalid choice. Please enter a number between 1 and 5.");
                }
                System.out.println(); // Add a newline for readability
            }
        } catch (Exception e) {
            // Catch any unexpected exceptions during the main loop
            System.err.println("An unexpected error occurred: " + e.getMessage());
            e.printStackTrace(); // Print stack trace for debugging
        } finally {
            // Ensure the scanner is closed
            if (scanner != null) {
                scanner.close();
            }
        }
    }

    /**
     * Prints the main menu options to the console.
     */
    private static void printMenu() {
        System.out.println("--- Server Task Management System ---");
        System.out.println("1. Add New Task");
        System.out.println("2. Process Next Task");
        System.out.println("3. View Task Queue");
        System.out.println("4. View Server Status");
        System.out.println("5. Exit");
        System.out.print("Enter your choice: ");
    }
}
