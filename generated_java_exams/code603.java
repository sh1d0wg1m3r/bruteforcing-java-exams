/*
 * Exam Question #603
 * Generated on: 2025-05-12 16:13:38
 * Generated by: Account 4
 * 
 * QUESTION:
 * ## Advanced Java Programming Exam: Print Job Scheduler Simulation
 * 
 * **Problem Description:**
 * 
 * Design and implement a command-line based Print Job Scheduler simulation. This system will manage print jobs submitted by users, queue them for processing, and maintain a record of completed jobs.
 * 
 * The simulation should allow users to:
 * 1.  Add a new print job (specifying file name and number of pages).
 * 2.  Process the next job waiting in the queue (simulating printing).
 * 3.  View the list of jobs currently waiting in the print queue.
 * 4.  View the list of jobs that have been completed.
 * 5.  Exit the application.
 * 
 * **Requirements:**
 * 
 * Your solution must adhere to the following technical and best practice requirements:
 * 
 * 1.  **Data Structures:**
 *     *   Use a `java.util.Queue` to manage print jobs waiting to be processed (First-In, First-Out).
 *     *   Use a `java.util.ArrayList` to store completed print jobs.
 *     *   Declare the variable holding the completed jobs using the `java.util.List` interface type.
 * 2.  **Input/Output:**
 *     *   Use `java.util.Scanner` to read user input from the console.
 *     *   Use `System.out` for displaying menus, prompts, and normal output (e.g., job details, confirmation messages).
 *     *   Use `System.err` for displaying error messages (e.g., invalid input, queue empty).
 * 3.  **Control Flow:**
 *     *   Use a `switch` statement to handle the user's menu choices.
 * 4.  **Error Handling:**
 *     *   Implement input validation for user-provided data (e.g., number of pages must be positive). Report validation errors using `System.err`.
 *     *   Implement class-wide exception handling using a `try-catch` block around the main application loop to catch unexpected runtime errors.
 * 5.  **Object-Oriented Design:**
 *     *   Create a `PrintJob` class to represent individual print jobs. This class should have private fields (e.g., job ID, file name, pages, status) and public methods (constructor, getters, maybe a method to update status).
 *     *   Create a main `PrintScheduler` class that encapsulates the queue, completed jobs list, and the application logic. Its fields should be private.
 *     *   Use meaningful variable and method names.
 *     *   Include appropriate comments and documentation (e.g., Javadoc-style comments for classes and methods).
 * 6.  **General:**
 *     *   The application should run in a loop until the user chooses to exit.
 *     *   Handle the case where the user tries to process a job when the queue is empty.
 * 
 * **Expected Output:**
 * 
 * The program should display a menu and respond to user input. Examples:
 * 
 * ```
 * --- Print Job Scheduler Simulation ---
 * 
 * Print Scheduler Menu:
 * 1. Add New Print Job
 * 2. Process Next Job
 * 3. View Print Queue
 * 4. View Completed Jobs
 * 5. Exit
 * Enter your choice: 1
 * 
 * --- Add New Print Job ---
 * Enter file name: report.pdf
 * Enter number of pages: 15
 * Job added: Job ID: 1, File: 'report.pdf', Pages: 15, Status: Pending
 * 
 * Print Scheduler Menu:
 * ... (menu repeats)
 * Enter your choice: 1
 * 
 * --- Add New Print Job ---
 * Enter file name: presentation.pptx
 * Enter number of pages: 50
 * Job added: Job ID: 2, File: 'presentation.pptx', Pages: 50, Status: Pending
 * 
 * Print Scheduler Menu:
 * ... (menu repeats)
 * Enter your choice: 3
 * 
 * --- Current Print Queue ---
 * Jobs waiting (2):
 * 1. Job ID: 1, File: 'report.pdf', Pages: 15, Status: Pending
 * 2. Job ID: 2, File: 'presentation.pptx', Pages: 50, Status: Pending
 * 
 * Print Scheduler Menu:
 * ... (menu repeats)
 * Enter your choice: 2
 * 
 * --- Processing Next Job ---
 * Processing job: Job ID: 1, File: 'report.pdf', Pages: 15, Status: Pending
 * Job completed: 1
 * 
 * Print Scheduler Menu:
 * ... (menu repeats)
 * Enter your choice: 4
 * 
 * --- Completed Print Jobs ---
 * Completed jobs (1):
 * - Job ID: 1, File: 'report.pdf', Pages: 15, Status: Completed
 * 
 * Print Scheduler Menu:
 * ... (menu repeats)
 * Enter your choice: 6
 * Invalid choice. Please enter a number between 1 and 5.
 * 
 * Print Scheduler Menu:
 * ... (menu repeats)
 * Enter your choice: 1
 * 
 * --- Add New Print Job ---
 * Enter file name: image.jpg
 * Enter number of pages: -5
 * Error: Number of pages must be positive.
 * Enter number of pages: abc
 * Error: Invalid input. Please enter a number for pages.
 * Enter number of pages: 1
 * Job added: Job ID: 3, File: 'image.jpg', Pages: 1, Status: Pending
 * 
 * Print Scheduler Menu:
 * ... (menu repeats)
 * Enter your choice: 5
 * Exiting Print Scheduler. Goodbye!
 * Scheduler shutdown complete.
 * ```
 * 
 * **Instructions:**
 * 
 * Write the complete Java code for the `PrintScheduler` class (including the `PrintJob` inner class or separate class) and the `main` method to run the simulation. Ensure all specified requirements are met.
 *
 * EXPLANATION:
 * The provided solution implements a command-line Print Job Scheduler simulation, fulfilling all the specified requirements and demonstrating advanced Java concepts.
 * 
 * **Key Concepts Demonstrated:**
 * 
 * 1.  **Object-Oriented Programming:**
 *     *   A `PrintJob` class encapsulates the data and state of a single print job (ID, file name, pages, status). It uses private fields and public getters, adhering to encapsulation principles.
 *     *   The `PrintScheduler` class manages the collection of `PrintJob` objects and the application logic. It also uses private fields (`printQueue`, `completedJobs`, `jobCounter`, `scanner`) and public methods for interaction (`addJob`, `processNextJob`, `displayQueue`, `displayCompletedJobs`, `run`), maintaining encapsulation.
 * 
 * 2.  **Collections Framework (`java.util`):**
 *     *   `Queue<PrintJob>`: A `LinkedList` instance is used to implement the `printQueue`. The `Queue` interface is used for the variable type, promoting good practice. This correctly models the FIFO (First-In, First-Out) nature of a print queue, where jobs are processed in the order they are added. `add()` is used to enqueue jobs, and `poll()` is used to dequeue the next job for processing.
 *     *   `List<PrintJob>`: An `ArrayList` instance is used to store `completedJobs`. The variable is declared using the `List` interface type, demonstrating polymorphism. `ArrayList` provides a dynamic, ordered collection suitable for storing completed items and iterating over them. `add()` is used to add completed jobs to the list.
 * 
 * 3.  **Input Handling (`java.util.Scanner`):**
 *     *   A `Scanner` object is used to read user input from `System.in`.
 *     *   `scanner.nextLine()` is used to read entire lines, which helps avoid issues with leftover newline characters when mixing `nextLine()` with other `next()` methods.
 *     *   Input validation is performed when adding a job (pages must be positive) and when parsing the menu choice.
 * 
 * 4.  **Control Flow (`switch` statement):**
 *     *   A `switch` statement in the `run()` method efficiently handles the different menu options selected by the user, directing the program flow to the appropriate method (`addJob`, `processNextJob`, etc.).
 * 
 * 5.  **Error Handling (`try-catch`, `System.err`):**
 *     *   **Input Validation Errors:** `NumberFormatException` is caught when parsing user input for pages and menu choices. If parsing fails or validation rules (like positive pages) are violated, an informative error message is printed to `System.err`.
 *     *   **Application-wide Errors:** A large `try-catch(Exception e)` block surrounds the main `while` loop in the `run()` method. This serves as a class-wide handler for unexpected runtime exceptions that might occur anywhere within the loop's execution, preventing the program from crashing abruptly. It prints an error message and the stack trace to `System.err`.
 *     *   **Specific Operational Errors:** The `processNextJob()` method explicitly checks if the queue is empty (`printQueue.poll()` returns `null`) and prints a user-friendly message to `System.out` in that specific, expected scenario, rather than throwing an error or printing to `System.err`.
 *     *   `finally` block: Used to ensure the `Scanner` resource is closed when the main loop terminates, whether normally or due to an exception.
 * 
 * 6.  **Best Practices:**
 *     *   **Naming:** Variables (`printQueue`, `completedJobs`, `jobCounter`, `fileName`, `pages`), methods (`addJob`, `processNextJob`, `displayQueue`, `displayCompletedJobs`, `run`, `displayMenu`), and classes (`PrintJob`, `PrintScheduler`) have clear, descriptive names.
 *     *   **Comments/Documentation:** Javadoc-style comments explain the purpose of classes, methods, and parameters. Inline comments clarify specific logic points (like the sentinel value for pages or the simulation of processing).
 *     *   **Code Structure:** Logic is divided into well-defined methods, each responsible for a specific task, making the code modular and easier to understand and maintain. The `displayMenu` method is private as it's an internal helper.
 *     *   **Resource Management:** The `Scanner` is closed in a `finally` block.
 * 
 * This solution effectively integrates the required Java components within a practical scenario, demonstrating robust error handling, proper object-oriented design, and adherence to common Java best practices.
 */

import java.util.Queue;
import java.util.LinkedList; // A common Queue implementation
import java.util.List;
import java.util.ArrayList; // A common List implementation
import java.util.Scanner;
import java.util.InputMismatchException;

/**
 * Represents a single print job with details and status.
 */
class PrintJob {
    private int id;
    private String fileName;
    private int pages;
    private String status; // e.g., "Pending", "Processing", "Completed"

    /**
     * Constructs a new PrintJob.
     *
     * @param id The unique identifier for the job.
     * @param fileName The name of the file to print.
     * @param pages The number of pages in the file.
     */
    public PrintJob(int id, String fileName, int pages) {
        this.id = id;
        this.fileName = fileName;
        this.pages = pages;
        this.status = "Pending"; // Initial status
    }

    // --- Getters ---
    public int getId() {
        return id;
    }

    public String getFileName() {
        return fileName;
    }

    public int getPages() {
        return pages;
    }

    public String getStatus() {
        return status;
    }

    // --- Setter for Status ---
    /**
     * Sets the status of the print job.
     * @param status The new status (e.g., "Processing", "Completed").
     */
    public void setStatus(String status) {
        this.status = status;
    }

    /**
     * Provides a string representation of the PrintJob.
     * @return A formatted string describing the job.
     */
    @Override
    public String toString() {
        return "Job ID: " + id + ", File: '" + fileName + "', Pages: " + pages + ", Status: " + status;
    }
}

/**
 * Simulates a Print Job Scheduler managing a queue of pending jobs
 * and a list of completed jobs.
 */
public class PrintScheduler {
    private Queue<PrintJob> printQueue;
    private List<PrintJob> completedJobs; // Declared as List interface
    private int jobCounter; // To generate unique IDs for print jobs
    private Scanner scanner; // For reading user input

    /**
     * Constructs a new PrintScheduler.
     * Initializes the queue, completed jobs list, and job counter.
     */
    public PrintScheduler() {
        this.printQueue = new LinkedList<>(); // LinkedList implements Queue
        this.completedJobs = new ArrayList<>(); // ArrayList implements List
        this.jobCounter = 0;
        this.scanner = new Scanner(System.in);
    }

    /**
     * Adds a new print job based on user input.
     * Validates input for the number of pages.
     */
    public void addJob() {
        System.out.println("\n--- Add New Print Job ---");
        System.out.print("Enter file name: ");
        String fileName = scanner.nextLine();

        int pages = -1; // Sentinel value for invalid input
        boolean validInput = false;
        while (!validInput) {
            System.out.print("Enter number of pages: ");
            try {
                pages = Integer.parseInt(scanner.nextLine());
                if (pages <= 0) {
                    System.err.println("Error: Number of pages must be positive.");
                } else {
                    validInput = true; // Input is valid
                }
            } catch (NumberFormatException e) {
                System.err.println("Error: Invalid input. Please enter a number for pages.");
            }
        }

        jobCounter++; // Increment counter for unique ID
        PrintJob newJob = new PrintJob(jobCounter, fileName, pages);
        printQueue.add(newJob); // Add the new job to the end of the queue
        System.out.println("Job added: " + newJob);
    }

    /**
     * Processes the next job at the front of the print queue.
     * Removes the job from the queue and adds it to the completed list.
     */
    public void processNextJob() {
        System.out.println("\n--- Processing Next Job ---");
        PrintJob jobToProcess = printQueue.poll(); // Retrieves and removes the head of the queue

        if (jobToProcess == null) {
            System.out.println("No jobs in the queue to process.");
        } else {
            System.out.println("Processing job: " + jobToProcess);
            jobToProcess.setStatus("Processing"); // Simulate processing state

            // Simulate work being done (in a real app, this would be the printing logic)
            // For this simulation, we immediately mark it as completed.
            jobToProcess.setStatus("Completed");

            completedJobs.add(jobToProcess); // Add the processed job to the completed list
            System.out.println("Job completed: " + jobToProcess.getId());
        }
    }

    /**
     * Displays the current print queue without removing elements.
     */
    public void displayQueue() {
        System.out.println("\n--- Current Print Queue ---");
        if (printQueue.isEmpty()) {
            System.out.println("The print queue is empty.");
        } else {
            System.out.println("Jobs waiting (" + printQueue.size() + "):");
            // Iterate through the queue using a for-each loop
            int index = 1;
            for (PrintJob job : printQueue) {
                System.out.println(index++ + ". " + job);
            }
        }
    }

    /**
     * Displays the list of completed print jobs.
     */
    public void displayCompletedJobs() {
        System.out.println("\n--- Completed Print Jobs ---");
        if (completedJobs.isEmpty()) {
            System.out.println("No jobs have been completed yet.");
        } else {
            System.out.println("Completed jobs (" + completedJobs.size() + "):");
            // Iterate through the list
            for (PrintJob job : completedJobs) {
                System.out.println("- " + job);
            }
        }
    }

    /**
     * Displays the main menu options to the user.
     */
    private void displayMenu() {
        System.out.println("\nPrint Scheduler Menu:");
        System.out.println("1. Add New Print Job");
        System.out.println("2. Process Next Job");
        System.out.println("3. View Print Queue");
        System.out.println("4. View Completed Jobs");
        System.out.println("5. Exit");
        System.out.print("Enter your choice: ");
    }

    /**
     * Runs the main application loop, handling user input and menu choices.
     * Includes class-wide exception handling.
     */
    public void run() {
        System.out.println("--- Print Job Scheduler Simulation ---");
        boolean running = true;

        // Class-wide exception handling for the main application loop
        try {
            while (running) {
                displayMenu();
                String choiceInput = scanner.nextLine(); // Read input as line first

                int choice = -1; // Default to an invalid choice
                try {
                     choice = Integer.parseInt(choiceInput); // Attempt to parse as integer
                } catch (NumberFormatException e) {
                     // If parsing fails, choice remains -1, handled by the default case
                     System.err.println("Invalid input format. Please enter a number.");
                     continue; // Skip the switch and re-display menu
                }


                // Use switch statement for flow control based on user choice
                switch (choice) {
                    case 1:
                        addJob();
                        break;
                    case 2:
                        processNextJob();
                        break;
                    case 3:
                        displayQueue();
                        break;
                    case 4:
                        displayCompletedJobs();
                        break;
                    case 5:
                        System.out.println("Exiting Print Scheduler. Goodbye!");
                        running = false; // Set flag to exit the loop
                        break;
                    default:
                        // Handles numbers outside 1-5 range and cases where parseInt succeeded but input was invalid (e.g., leading/trailing spaces)
                        System.err.println("Invalid choice. Please enter a number between 1 and 5.");
                }
            }
        } catch (Exception e) {
            // Catch any unexpected exceptions that occur during execution
            System.err.println("\nAn unexpected error occurred during scheduler execution:");
            e.printStackTrace(System.err); // Print stack trace to standard error
        } finally {
            // Ensure resources (like the scanner) are closed properly
            if (scanner != null) {
                scanner.close();
                System.out.println("Scanner closed.");
            }
            System.out.println("Scheduler shutdown complete.");
        }
    }

    /**
     * Main method to start the PrintScheduler application.
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        PrintScheduler scheduler = new PrintScheduler();
        scheduler.run(); // Start the application loop
    }
}
