/*
 * Exam Question #1104
 * Generated on: 2025-05-12 17:25:17
 * Generated by: Account 3
 * 
 * QUESTION:
 * ## Advanced Java Programming Exam Task: Task Processing System
 * 
 * **Problem Description:**
 * 
 * You are tasked with developing a simple command-line based Task Processing System. This system should manage a queue of pending tasks and maintain a list of completed tasks. Users should be able to add new tasks, process the next task from the queue, view the list of pending tasks, view the list of completed tasks, and exit the application.
 * 
 * The system must adhere to the following requirements and demonstrate advanced Java programming concepts:
 * 
 * 1.  **Task Representation:** Create a `Task` class with private fields for a unique integer ID, a string description, and a boolean indicating completion status. Include a constructor, appropriate getters, a method to mark the task as complete, and a `toString()` method for easy display.
 * 2.  **System Core:** Create a `TaskProcessingSystem` class that manages the task collections.
 *     *   It must use a `java.util.Queue<Task>` to store pending tasks.
 *     *   It must use a `java.util.List<Task>` (implemented by `java.util.ArrayList`) to store completed tasks.
 *     *   It should maintain a counter for generating unique task IDs.
 *     *   It must include methods for:
 *         *   Adding a new task (assigning a unique ID, adding to the pending queue).
 *         *   Processing the next task (removing from the queue, marking as complete, adding to the completed list). Handle the case where the queue is empty.
 *         *   Viewing all pending tasks (printing them without removing from the queue).
 *         *   Viewing all completed tasks (printing them from the list).
 * 3.  **User Interface:** Implement a command-line interface using `java.util.Scanner` in the `main` method of the `TaskProcessingSystem` class.
 *     *   Display a menu of options (Add Task, Process Task, View Pending, View Completed, Exit).
 *     *   Read user input using `Scanner`.
 *     *   Use a `switch` statement to handle the different menu options.
 * 4.  **Error Handling & Output:**
 *     *   Use `System.out` for displaying the menu, prompts, successful operations, and task lists.
 *     *   Use `System.err` for printing error messages (e.g., invalid menu choice, invalid task description, attempting to process when the queue is empty).
 *     *   Implement input validation for the task description (it cannot be empty).
 *     *   Implement exception handling using `try-catch` blocks. Specifically, handle potential `InputMismatchException` when reading integer input from the `Scanner` and include a general catch block for any unexpected runtime exceptions that might occur within the main application loop (demonstrating class-wide handling). Ensure the `Scanner` is properly closed using a `finally` block or similar mechanism.
 * 5.  **Best Practices:** Apply principles of encapsulation (private fields, public methods), use meaningful variable and method names, and include basic comments/documentation.
 * 
 * **Expected Output:**
 * 
 * The program should display a menu, accept user input, perform the requested actions, print appropriate messages (to `System.out` or `System.err`), and handle errors gracefully.
 * 
 * Example interaction flow:
 * 
 * ```
 * Task Processing System Menu:
 * 1. Add New Task
 * 2. Process Next Task
 * 3. View Pending Tasks
 * 4. View Completed Tasks
 * 5. Exit
 * Enter your choice: 1
 * Enter task description: Implement feature X
 * Task added: Implement feature X
 * 
 * Task Processing System Menu:
 * ...
 * Enter your choice: 1
 * Enter task description: Fix bug Y
 * Task added: Fix bug Y
 * 
 * Task Processing System Menu:
 * ...
 * Enter your choice: 3
 * 
 * --- Pending Tasks ---
 * Task ID: 1, Description: "Implement feature X", Completed: No
 * Task ID: 2, Description: "Fix bug Y", Completed: No
 * ---------------------
 * 
 * Task Processing System Menu:
 * ...
 * Enter your choice: 2
 * Processed task: Implement feature X
 * 
 * Task Processing System Menu:
 * ...
 * Enter your choice: 3
 * 
 * --- Pending Tasks ---
 * Task ID: 2, Description: "Fix bug Y", Completed: No
 * ---------------------
 * 
 * Task Processing System Menu:
 * ...
 * Enter your choice: 4
 * 
 * --- Completed Tasks ---
 * Task ID: 1, Description: "Implement feature X", Completed: Yes
 * ---------------------
 * 
 * Task Processing System Menu:
 * ...
 * Enter your choice: invalid_input
 * Invalid input. Please enter a number.
 * 
 * Task Processing System Menu:
 * ...
 * Enter your choice: 6
 * Invalid choice. Please enter a number between 1 and 5.
 * 
 * Task Processing System Menu:
 * ...
 * Enter your choice: 2
 * Processed task: Fix bug Y
 * 
 * Task Processing System Menu:
 * ...
 * Enter your choice: 2
 * No pending tasks to process.
 * 
 * Task Processing System Menu:
 * ...
 * Enter your choice: 5
 * Exiting Task Processing System. Goodbye!
 * Scanner closed.
 * ```
 * 
 * Your solution should implement the `Task` and `TaskProcessingSystem` classes in a single Java file for simplicity in an exam environment.
 * 
 * **Evaluation Criteria:**
 * 
 * *   Correct usage of `Queue`, `ArrayList`, and `List`.
 * *   Proper implementation of the `Task` class.
 * *   Effective use of `Scanner`, `switch`, `System.out`, and `System.err`.
 * *   Robust error handling using `try-catch` (specifically for `InputMismatchException` and general exceptions) and input validation.
 * *   Adherence to best practices (encapsulation, naming, comments).
 * *   Correct logic for managing pending and completed tasks.
 *
 * EXPLANATION:
 * This solution implements a `TaskProcessingSystem` using the required Java components and best practices.
 * 
 * 1.  **`Task` Class:** A simple class encapsulating task data (`id`, `description`, `isCompleted`). It includes a constructor, getters, a `markComplete` method, and an overridden `toString` for easy printing. This demonstrates encapsulation.
 * 
 * 2.  **`TaskProcessingSystem` Class:**
 *     *   It uses a `Queue<Task>` (`pendingTasks`) implemented by `LinkedList`. The `Queue` interface is suitable for managing tasks in a First-In, First-Out (FIFO) order, where tasks are processed in the order they are added. Methods like `offer()` (to add) and `poll()` (to retrieve and remove the head) are used, which are standard `Queue` operations.
 *     *   It uses a `List<Task>` (`completedTasks`) implemented by `ArrayList`. The `List` interface provides indexed access and is suitable for storing completed tasks where order of completion might matter, or where you might later want to access tasks by index. `ArrayList` is a common, dynamic array implementation. Declaring it as `List` demonstrates using the interface type, promoting flexibility.
 *     *   A `nextTaskId` counter ensures each task gets a unique ID.
 *     *   Methods like `addTask`, `processNextTask`, `viewPendingTasks`, and `viewCompletedTasks` encapsulate the core logic of the system, operating on the internal collections.
 * 
 * 3.  **User Interface (`main` method):**
 *     *   A `Scanner` is used to read input from `System.in`.
 *     *   A loop keeps the system running until the user chooses to exit.
 *     *   `displayMenu()` prints the options to `System.out`.
 *     *   A `switch` statement handles the user's integer choice, directing execution to the appropriate method call (`addTask`, `processNextTask`, etc.).
 * 
 * 4.  **Error Handling & Output:**
 *     *   `System.out` is used for standard program output (menu, prompts, success messages, task listings).
 *     *   `System.err` is specifically used for printing error messages, directing them to the standard error stream which is good practice for separating normal output from errors.
 *     *   Input validation is performed in `addTask` to ensure the description is not empty. An error is printed to `System.err` if validation fails.
 *     *   The `main` method includes `try-catch` blocks:
 *         *   An inner `try-catch` specifically catches `InputMismatchException` which occurs if the user enters non-integer text when an integer is expected by `scanner.nextInt()`. This prevents the program from crashing and prompts the user to enter a valid number. `scanner.next()` is used within the catch block to consume the invalid input, preventing an infinite loop.
 *         *   An outer `try-catch` wraps the main `while` loop. This demonstrates class-wide exception handling, catching any other unexpected `Exception` that might propagate up from the system logic or other parts of the loop. It prints an error message and the stack trace to `System.err`.
 *     *   A `finally` block ensures that the `Scanner` resource is closed properly before the program terminates, regardless of whether an exception occurred or the loop exited normally. This is important for resource management.
 * 
 * 5.  **Best Practices:** The code uses private fields and public methods for encapsulation, has descriptive names (`pendingTasks`, `processNextTask`), includes Javadoc-style comments for classes and methods, and separates logic into distinct methods for clarity.
 * 
 * This solution effectively combines the required Java components (`Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.err`, `System.out`, `try-catch`) in a practical scenario, demonstrating understanding of collections, control flow, user interaction, and robust error handling, making it a suitable challenging exam task.
 */

import java.util.Queue;
import java.util.LinkedList; // Commonly used Queue implementation
import java.util.List;
import java.util.ArrayList; // Commonly used List implementation
import java.util.Scanner;
import java.util.InputMismatchException;

/**
 * Represents a single task in the system.
 */
class Task {
    private int id;
    private String description;
    private boolean isCompleted;

    /**
     * Constructs a new Task.
     * @param id The unique ID for the task.
     * @param description A brief description of the task.
     */
    public Task(int id, String description) {
        this.id = id;
        this.description = description;
        this.isCompleted = false; // Tasks start as not completed
    }

    // --- Getters ---
    public int getId() {
        return id;
    }

    public String getDescription() {
        return description;
    }

    public boolean isCompleted() {
        return isCompleted;
    }

    /**
     * Marks the task as completed.
     */
    public void markComplete() {
        this.isCompleted = true;
    }

    /**
     * Provides a string representation of the Task.
     * @return Formatted string showing task details.
     */
    @Override
    public String toString() {
        return String.format("Task ID: %d, Description: \"%s\", Completed: %s",
                             id, description, isCompleted ? "Yes" : "No");
    }
}

/**
 * The main system for managing and processing tasks.
 * Includes the main application logic, user interface, and error handling.
 */
public class TaskProcessingSystem {
    // Queue to hold tasks that are waiting to be processed
    private Queue<Task> pendingTasks;
    // List to hold tasks that have been processed
    private List<Task> completedTasks; // Declared as List, implemented as ArrayList
    // Counter for generating unique task IDs
    private int nextTaskId;
    // Scanner for reading user input
    private Scanner scanner;

    /**
     * Constructs a new TaskProcessingSystem, initializing collections and scanner.
     */
    public TaskProcessingSystem() {
        this.pendingTasks = new LinkedList<>(); // LinkedList implements Queue
        this.completedTasks = new ArrayList<>(); // ArrayList implements List
        this.nextTaskId = 1; // Start task IDs from 1
        this.scanner = new Scanner(System.in);
    }

    /**
     * Generates a unique ID for a new task.
     * @return The next available task ID.
     */
    private int generateTaskId() {
        return nextTaskId++;
    }

    /**
     * Adds a new task to the pending queue.
     * Performs validation on the task description.
     * @param description The description of the task.
     */
    public void addTask(String description) {
        if (description == null || description.trim().isEmpty()) {
            // Use System.err for error messages
            System.err.println("Error: Task description cannot be empty.");
            return;
        }
        Task newTask = new Task(generateTaskId(), description.trim());
        pendingTasks.offer(newTask); // Use offer() which is safe for bounded queues (though LinkedList is unbounded)
        System.out.println("Task added: " + newTask.getDescription()); // Use System.out for success messages
    }

    /**
     * Processes the next task from the pending queue.
     * Removes it from the queue, marks it complete, and adds it to the completed list.
     * Handles the case where the pending queue is empty.
     */
    public void processNextTask() {
        if (pendingTasks.isEmpty()) {
            System.out.println("No pending tasks to process."); // Use System.out for informational messages
            return;
        }
        // poll() retrieves and removes the head of the queue
        Task taskToProcess = pendingTasks.poll();
        taskToProcess.markComplete();
        completedTasks.add(taskToProcess); // Add to the completed list
        System.out.println("Processed task: " + taskToProcess.getDescription()); // Use System.out for success
    }

    /**
     * Displays all tasks currently in the pending queue without removing them.
     */
    public void viewPendingTasks() {
        System.out.println("\n--- Pending Tasks ---"); // Use System.out for output
        if (pendingTasks.isEmpty()) {
            System.out.println("No pending tasks.");
            return;
        }
        // Iterate through the Queue using forEach or an iterator
        pendingTasks.forEach(System.out::println);
        System.out.println("---------------------\n");
    }

    /**
     * Displays all tasks that have been completed and are in the completed list.
     */
    public void viewCompletedTasks() {
        System.out.println("\n--- Completed Tasks ---"); // Use System.out for output
        if (completedTasks.isEmpty()) {
            System.out.println("No completed tasks.");
            return;
        }
        // Iterate through the List
        completedTasks.forEach(System.out::println);
        System.out.println("---------------------\n");
    }

    /**
     * Displays the main menu options to the user.
     */
    private void displayMenu() {
        System.out.println("\nTask Processing System Menu:"); // Use System.out for menu
        System.out.println("1. Add New Task");
        System.out.println("2. Process Next Task");
        System.out.println("3. View Pending Tasks");
        System.out.println("4. View Completed Tasks");
        System.out.println("5. Exit");
        System.out.print("Enter your choice: "); // Use System.out for prompt
    }

    /**
     * The main entry point of the application.
     * Contains the main loop, user interaction logic, switch statement,
     * and class-wide exception handling.
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        TaskProcessingSystem system = new TaskProcessingSystem();
        boolean running = true;

        // Class-wide exception handling block wrapping the main application loop
        try {
            while (running) {
                system.displayMenu();

                int choice = -1; // Default value to indicate invalid input
                try {
                    // Attempt to read integer input
                    choice = system.scanner.nextInt();
                } catch (InputMismatchException e) {
                    // Catch specific exception for non-integer input
                    System.err.println("Invalid input. Please enter a number.");
                    system.scanner.next(); // Consume the invalid input to prevent infinite loop
                    continue; // Skip the rest of the loop iteration and show the menu again
                }

                // Consume the newline character left by nextInt() to prepare for nextLine()
                system.scanner.nextLine();

                // Switch statement to handle different menu choices
                switch (choice) {
                    case 1:
                        System.out.print("Enter task description: ");
                        String description = system.scanner.nextLine();
                        system.addTask(description); // Call method to add task
                        break;
                    case 2:
                        system.processNextTask(); // Call method to process task
                        break;
                    case 3:
                        system.viewPendingTasks(); // Call method to view pending
                        break;
                    case 4:
                        system.viewCompletedTasks(); // Call method to view completed
                        break;
                    case 5:
                        running = false; // Set running to false to exit the loop
                        System.out.println("Exiting Task Processing System. Goodbye!");
                        break;
                    default:
                        // Handle choices outside the valid range
                        System.err.println("Invalid choice. Please enter a number between 1 and 5.");
                }
            }
        } catch (Exception e) {
            // General catch block for any other unexpected exceptions
            System.err.println("An unexpected error occurred: " + e.getMessage());
            e.printStackTrace(System.err); // Print stack trace to the error stream
        } finally {
            // This block executes regardless of whether an exception occurred or not
            // It's crucial for closing resources like Scanner
            if (system.scanner != null) {
                system.scanner.close();
                System.out.println("Scanner closed.");
            }
        }
    }
}
