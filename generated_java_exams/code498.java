/*
 * Exam Question #498
 * Generated on: 2025-05-11 23:20:05
 * Generated by: Account 2
 * 
 * QUESTION:
 * **Java Programming Exam Task: Hospital Appointment Management System**
 * 
 * You are tasked with developing a simplified Hospital Appointment Management System. The system needs to manage doctors and their respective patient waiting lists. Patients arrive and are added to a queue for a specific doctor. When a doctor becomes available, the next patient from their waiting list is processed.
 * 
 * Your solution must demonstrate advanced understanding of core Java concepts and utilize *all* the following components:
 * 
 * 1.  `java.util.Queue`
 * 2.  `java.util.ArrayList`
 * 3.  `java.util.List` interface
 * 4.  `java.util.Scanner`
 * 5.  `switch` statement
 * 6.  `System.err`
 * 7.  `System.out`
 * 8.  Class-wide `try-catch` block for exception handling
 * 
 * **System Functionality:**
 * 
 * The system should support the following commands via standard input:
 * 
 * *   `ADD_DOCTOR <name> <specialty>`: Registers a new doctor with the given name and specialty. Doctor names are unique identifiers.
 * *   `ADD_PATIENT <doctor_name> <patient_name>`: Adds a patient with `<patient_name>` to the waiting list of the doctor named `<doctor_name>`. Patients are added to the end of the queue.
 * *   `PROCESS_APPOINTMENT <doctor_name>`: Takes the next patient from the waiting list of `<doctor_name>` and simulates processing the appointment. The patient is removed from the queue.
 * *   `LIST_DOCTORS`: Lists all registered doctors and their specialties.
 * *   `LIST_WAITLIST <doctor_name>`: Lists all patients currently in the waiting list for the doctor named `<doctor_name>`, in the order they will be processed.
 * *   `EXIT`: Terminates the program.
 * 
 * **Input and Output:**
 * 
 * *   Commands are read from standard input using `Scanner`.
 * *   Normal system messages (confirmations, lists) should go to `System.out`.
 * *   Error messages (e.g., doctor not found, invalid command, empty waitlist) must go to `System.err`.
 * *   Input validation is required (e.g., check if doctor exists, check if names are empty).
 * 
 * **Implementation Requirements:**
 * 
 * *   Create appropriate classes (`Patient`, `Doctor`, `AppointmentSystem`).
 * *   Use private fields and public methods for proper encapsulation.
 * *   Employ meaningful variable and method names.
 * *   Include comments where necessary to explain complex logic.
 * *   Handle potential runtime errors using a `try-catch` block encompassing the main command processing loop.
 * *   Ensure the waiting list for each doctor is implemented using a `Queue`.
 * *   Manage the collection of doctors using an `ArrayList` referenced by a `List` interface variable.
 * 
 * **Example Interaction:**
 * 
 * ```
 * ADD_DOCTOR Dr.Smith Cardiology
 * Doctor Dr.Smith (Cardiology) added.
 * ADD_DOCTOR Dr.Jones Pediatrics
 * Doctor Dr.Jones (Pediatrics) added.
 * LIST_DOCTORS
 * Doctors:
 * - Dr.Smith (Cardiology)
 * - Dr.Jones (Pediatrics)
 * ADD_PATIENT Dr.Smith Alice
 * Patient Alice added to Dr.Smith's waitlist.
 * ADD_PATIENT Dr.Jones Bob
 * Patient Bob added to Dr.Jones's waitlist.
 * ADD_PATIENT Dr.Smith Charlie
 * Patient Charlie added to Dr.Smith's waitlist.
 * LIST_WAITLIST Dr.Smith
 * Dr.Smith's Waitlist:
 * - Alice
 * - Charlie
 * PROCESS_APPOINTMENT Dr.Smith
 * Processing appointment for Alice with Dr.Smith.
 * LIST_WAITLIST Dr.Smith
 * Dr.Smith's Waitlist:
 * - Charlie
 * PROCESS_APPOINTMENT Dr.Smith
 * Processing appointment for Charlie with Dr.Smith.
 * PROCESS_APPOINTMENT Dr.Smith
 * Dr.Smith's waitlist is empty.
 * ADD_PATIENT Dr.NotFound David
 * Error: Doctor 'Dr.NotFound' not found.
 * EXIT
 * Exiting system.
 * ```
 * 
 * Your solution should be a single Java file containing all necessary classes.
 *
 * EXPLANATION:
 * This solution implements a simple hospital appointment management system as described in the problem. It effectively utilizes all the required Java components and adheres to good programming practices.
 * 
 * **Class Structure:**
 * 
 * 1.  `Patient` class: A simple class to hold patient information (name).
 * 2.  `Doctor` class: Represents a doctor, holding their name, specialty, and crucially, a `Queue<Patient>` named `waitlist` to manage the patients waiting for them. It includes methods to add and process patients using `Queue` operations (`offer` and `poll`).
 * 3.  `AppointmentSystem` class: This is the main class that orchestrates the system. It contains a `List<Doctor>` (implemented by `ArrayList`) to store all registered doctors. It handles user input via `Scanner`, parses commands, and directs operations to the appropriate `Doctor` objects.
 * 
 * **Required Components Usage:**
 * 
 * *   `java.util.Queue`: Used within the `Doctor` class (`private Queue<Patient> waitlist;`) to maintain the order of patients waiting for a specific doctor. `LinkedList` is used as a concrete implementation of `Queue`. The `offer()` method is used to add patients (at the end), and `poll()` is used to remove and retrieve the next patient (from the front).
 * *   `java.util.ArrayList`: Used in the `AppointmentSystem` class (`private List<Doctor> doctors = new ArrayList<>();`) to store the collection of `Doctor` objects.
 * *   `java.util.List`: The collection of doctors is declared using the `List` interface (`private List<Doctor> doctors;`). This promotes programming to interfaces rather than concrete implementations.
 * *   `java.util.Scanner`: An instance is created in the `AppointmentSystem` constructor (`private Scanner scanner;`) and used in the `run()` method to read user commands from `System.in`.
 * *   `switch` statement: Located in the `run()` method, it is used to determine which action to perform based on the user's command string (`ADD_DOCTOR`, `ADD_PATIENT`, etc.).
 * *   `System.err`: Used throughout the `AppointmentSystem` class to print error messages, such as invalid commands, missing arguments, doctor not found, or issues during operations.
 * *   `System.out`: Used for printing normal output, including system startup messages, confirmations of successful operations (adding doctor/patient), listing doctors, and listing waitlists.
 * *   Class-wide `try-catch`: A `try-catch` block is wrapped around the main command processing `while` loop in the `run()` method. This provides a basic level of exception handling for the core execution flow, catching any unexpected `Exception` that might occur during command processing or input handling and printing an error message and stack trace to `System.err`. A `finally` block ensures the `Scanner` is closed.
 * 
 * **Best Practices:**
 * 
 * *   **Encapsulation:** Fields in `Patient`, `Doctor`, and `AppointmentSystem` are `private`, and access is provided through public getter methods (`getName`, `getSpecialty`, `getWaitlist`).
 * *   **Meaningful Names:** Classes (`Patient`, `Doctor`, `AppointmentSystem`), fields (`name`, `specialty`, `waitlist`, `doctors`), and methods (`addDoctor`, `findDoctor`, `addPatientToWaitlist`, `processNextAppointment`, `listWaitlist`, `run`) have names that clearly indicate their purpose.
 * *   **Comments:** Comments are included to explain the purpose of classes, fields, and key methods, as well as specific implementation choices (like using `LinkedList` for `Queue`).
 * *   **Input Validation:** Checks are performed before processing commands to ensure required arguments are present and not empty, and that referenced doctors exist (`findDoctor` helper method). Error messages are printed to `System.err` for invalid input.
 * *   **Error Handling:** Logical errors (doctor not found, empty waitlist) are handled gracefully with informative messages to `System.err` or `System.out`. The `try-catch` block handles unexpected runtime errors.
 * *   **Clean Code Structure:** The code is organized into logical methods within the `AppointmentSystem` class, separating different functionalities (doctor management, patient/appointment management, main loop).
 * 
 * This solution demonstrates the practical application of the required Java data structures and control flow mechanisms within a simulated real-world scenario, fulfilling the requirements of the exam task.
 */

import java.util.ArrayList;
import java.util.LinkedList; // LinkedList implements Queue
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.Iterator; // Useful for listing queue contents

// Represents a patient
class Patient {
    private String name;

    public Patient(String name) {
        this.name = name;
    }

    public String getName() {
        return name;
    }

    @Override
    public String toString() {
        return name;
    }
}

// Represents a doctor with a waiting list
class Doctor {
    private String name;
    private String specialty;
    private Queue<Patient> waitlist; // Use Queue for waiting list

    public Doctor(String name, String specialty) {
        this.name = name;
        this.specialty = specialty;
        this.waitlist = new LinkedList<>(); // LinkedList implements Queue
    }

    public String getName() {
        return name;
    }

    public String getSpecialty() {
        return specialty;
    }

    public Queue<Patient> getWaitlist() {
        return waitlist;
    }

    // Add a patient to the end of the waitlist
    public boolean addPatient(Patient patient) {
        return waitlist.offer(patient); // offer is preferred over add for capacity-constrained queues, though LinkedList is not capacity-constrained
    }

    // Get and remove the next patient from the waitlist
    public Patient processNextPatient() {
        return waitlist.poll(); // poll returns null if queue is empty
    }

    // Check if waitlist is empty
    public boolean isWaitlistEmpty() {
        return waitlist.isEmpty();
    }

    @Override
    public String toString() {
        return name + " (" + specialty + ")";
    }
}

// Main system class to manage doctors and appointments
public class AppointmentSystem {
    // Use List interface for the collection of doctors, implemented by ArrayList
    private List<Doctor> doctors;
    private Scanner scanner;

    public AppointmentSystem() {
        this.doctors = new ArrayList<>(); // Use ArrayList to store doctors
        this.scanner = new Scanner(System.in);
    }

    // --- Doctor Management ---

    // Adds a new doctor to the system
    public void addDoctor(String name, String specialty) {
        if (name == null || name.trim().isEmpty() || specialty == null || specialty.trim().isEmpty()) {
            System.err.println("Error: Doctor name and specialty cannot be empty.");
            return;
        }
        // Check if doctor already exists
        if (findDoctor(name) != null) {
            System.err.println("Error: Doctor '" + name + "' already exists.");
            return;
        }
        Doctor newDoctor = new Doctor(name.trim(), specialty.trim());
        doctors.add(newDoctor); // Add to the ArrayList
        System.out.println("Doctor " + newDoctor + " added.");
    }

    // Finds a doctor by name (case-sensitive)
    private Doctor findDoctor(String name) {
        if (name == null || name.trim().isEmpty()) {
             return null; // Cannot find doctor with empty name
        }
        for (Doctor doctor : doctors) { // Iterate through the ArrayList
            if (doctor.getName().equals(name.trim())) {
                return doctor;
            }
        }
        return null; // Doctor not found
    }

    // Lists all registered doctors
    public void listDoctors() {
        if (doctors.isEmpty()) {
            System.out.println("No doctors registered.");
            return;
        }
        System.out.println("Doctors:");
        for (Doctor doctor : doctors) { // Iterate through the ArrayList
            System.out.println("- " + doctor);
        }
    }

    // --- Patient and Appointment Management ---

    // Adds a patient to a doctor's waitlist
    public void addPatientToWaitlist(String doctorName, String patientName) {
        if (doctorName == null || doctorName.trim().isEmpty() || patientName == null || patientName.trim().isEmpty()) {
            System.err.println("Error: Doctor name and patient name cannot be empty.");
            return;
        }
        Doctor doctor = findDoctor(doctorName);
        if (doctor == null) {
            System.err.println("Error: Doctor '" + doctorName + "' not found.");
            return;
        }
        Patient patient = new Patient(patientName.trim());
        if (doctor.addPatient(patient)) { // Add to the Queue
            System.out.println("Patient " + patient + " added to " + doctor.getName() + "'s waitlist.");
        } else {
             // This case is unlikely with LinkedList, but good practice for Queue interface
             System.err.println("Error: Could not add patient to " + doctor.getName() + "'s waitlist.");
        }
    }

    // Processes the next appointment for a doctor
    public void processNextAppointment(String doctorName) {
        if (doctorName == null || doctorName.trim().isEmpty()) {
            System.err.println("Error: Doctor name cannot be empty.");
            return;
        }
        Doctor doctor = findDoctor(doctorName);
        if (doctor == null) {
            System.err.println("Error: Doctor '" + doctorName + "' not found.");
            return;
        }

        Patient nextPatient = doctor.processNextPatient(); // Poll from the Queue
        if (nextPatient != null) {
            System.out.println("Processing appointment for " + nextPatient.getName() + " with " + doctor.getName() + ".");
        } else {
            System.out.println(doctor.getName() + "'s waitlist is empty.");
        }
    }

    // Lists the patients in a doctor's waitlist
    public void listWaitlist(String doctorName) {
        if (doctorName == null || doctorName.trim().isEmpty()) {
            System.err.println("Error: Doctor name cannot be empty.");
            return;
        }
        Doctor doctor = findDoctor(doctorName);
        if (doctor == null) {
            System.err.println("Error: Doctor '" + doctorName + "' not found.");
            return;
        }

        Queue<Patient> waitlist = doctor.getWaitlist(); // Get the Queue
        if (waitlist.isEmpty()) {
            System.out.println(doctor.getName() + "'s Waitlist: Empty");
            return;
        }

        System.out.println(doctor.getName() + "'s Waitlist:");
        // Iterate through the queue without removing elements
        Iterator<Patient> iterator = waitlist.iterator();
        while (iterator.hasNext()) {
            System.out.println("- " + iterator.next().getName());
        }
    }

    // --- Main System Loop ---

    public void run() {
        System.out.println("Hospital Appointment Management System");
        System.out.println("Commands: ADD_DOCTOR <name> <specialty>, ADD_PATIENT <doctor_name> <patient_name>, PROCESS_APPOINTMENT <doctor_name>, LIST_DOCTORS, LIST_WAITLIST <doctor_name>, EXIT");

        boolean running = true;
        // Class-wide exception handling for the main loop
        try {
            while (running) {
                System.out.print("> ");
                String line = scanner.nextLine().trim();
                String[] parts = line.split(" ", 3); // Split into command and up to 2 arguments
                String command = parts[0].toUpperCase();

                // Using switch statement for flow control
                switch (command) {
                    case "ADD_DOCTOR":
                        if (parts.length >= 3) {
                            addDoctor(parts[1], parts[2]);
                        } else {
                            System.err.println("Error: Invalid arguments for ADD_DOCTOR. Usage: ADD_DOCTOR <name> <specialty>");
                        }
                        break;
                    case "ADD_PATIENT":
                        if (parts.length >= 3) {
                            addPatientToWaitlist(parts[1], parts[2]);
                        } else {
                            System.err.println("Error: Invalid arguments for ADD_PATIENT. Usage: ADD_PATIENT <doctor_name> <patient_name>");
                        }
                        break;
                    case "PROCESS_APPOINTMENT":
                        if (parts.length >= 2) {
                            processNextAppointment(parts[1]);
                        } else {
                            System.err.println("Error: Invalid arguments for PROCESS_APPOINTMENT. Usage: PROCESS_APPOINTMENT <doctor_name>");
                        }
                        break;
                    case "LIST_DOCTORS":
                        listDoctors();
                        break;
                    case "LIST_WAITLIST":
                        if (parts.length >= 2) {
                            listWaitlist(parts[1]);
                        } else {
                            System.err.println("Error: Invalid arguments for LIST_WAITLIST. Usage: LIST_WAITLIST <doctor_name>");
                        }
                        break;
                    case "EXIT":
                        System.out.println("Exiting system.");
                        running = false;
                        break;
                    default:
                        System.err.println("Error: Unknown command '" + command + "'.");
                        break;
                }
            }
        } catch (Exception e) {
            // Catch any unexpected runtime exceptions during command processing
            System.err.println("An unexpected system error occurred: " + e.getMessage());
            e.printStackTrace(System.err); // Print stack trace to error stream
        } finally {
            // Ensure scanner is closed
            if (scanner != null) {
                scanner.close();
            }
        }
    }

    // Main method to start the application
    public static void main(String[] args) {
        AppointmentSystem system = new AppointmentSystem();
        system.run();
    }
}
