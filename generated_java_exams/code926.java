/*
 * Exam Question #926
 * Generated on: 2025-05-12 17:00:39
 * Generated by: Account 4
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Advanced Task Management System
 * 
 * **Objective:** Design and implement a simple console-based Task Management System that allows users to add, view, and manage tasks with different priorities and statuses. This task requires demonstrating proficiency in using core Java collections, input handling, control flow, and exception handling.
 * 
 * **Scenario:** You are developing a basic system for managing tasks. Some tasks are urgent and need to be processed in a specific order, while others are standard. The system needs to track all tasks and provide basic management operations.
 * 
 * **Requirements:**
 * 
 * 1.  **Task Representation:** Create a `Task` class with the following private fields:
 *     *   `id` (int): Unique identifier for the task.
 *     *   `description` (String): A brief description of the task.
 *     *   `priority` (enum `Priority`): Represents the task's urgency (e.g., `HIGH`, `MEDIUM`, `LOW`).
 *     *   `status` (enum `Status`): Represents the task's current state (e.g., `PENDING`, `PROCESSING`, `COMPLETED`, `CANCELLED`).
 *     *   Include a constructor, and public getter and setter methods for these fields (ensure `id` is only set during creation or is read-only).
 *     *   Override the `toString()` method to provide a clear representation of the task.
 * 
 * 2.  **Task Manager:** Create a `TaskManager` class responsible for managing tasks.
 *     *   It must use a `java.util.List` (specifically an `ArrayList`) to store *all* tasks.
 *     *   It must use a `java.util.Queue` (e.g., `LinkedList` implementing `Queue`) to store *only* high-priority tasks that are currently `PENDING`. This queue represents tasks needing immediate attention, processed in FIFO order.
 *     *   Implement the following public methods:
 *         *   `addTask(String description, Priority priority)`: Creates a new `Task`, assigns a unique ID (starting from 1), adds it to the main task list, and if the priority is `HIGH` and status is `PENDING`, adds it to the urgent task queue. Returns the ID of the newly added task.
 *         *   `viewAllTasks()`: Returns a `java.util.List` of all tasks currently in the system.
 *         *   `viewUrgentTasks()`: Returns a `java.util.List` of tasks currently in the urgent task queue (without removing them).
 *         *   `processNextUrgentTask()`: Removes the next task from the urgent task queue, updates its status to `PROCESSING` in the main task list, and returns the processed task. If the queue is empty, it should indicate that.
 *         *   `updateTaskStatus(int taskId, Status newStatus)`: Finds the task by ID in the main list and updates its status. If the task is found and its status is updated to `COMPLETED` or `CANCELLED`, it should be removed from the urgent queue *if* it was there. Returns `true` if updated successfully, `false` otherwise (e.g., task not found).
 *         *   `findTaskById(int taskId)`: Private helper method to find a task in the main list by its ID.
 * 
 * 3.  **Console Application (`TaskManagementApp`):**
 *     *   Use `java.util.Scanner` to get user input from the console.
 *     *   Present a menu of options to the user:
 *         1.  Add New Task
 *         2.  View All Tasks
 *         3.  View Urgent Tasks Queue
 *         4.  Process Next Urgent Task
 *         5.  Mark Task as Completed/Cancelled
 *         6.  Exit
 *     *   Use a `switch` statement to handle the user's menu selection.
 *     *   Implement input validation. Handle cases where the user enters non-numeric input for menu choices or IDs, or invalid values for priority/status.
 *     *   Use `System.out` for displaying the menu, task details, and success messages.
 *     *   Use `System.err` for displaying error messages (e.g., invalid input, task not found, urgent queue empty).
 *     *   Implement class-wide exception handling using `try-catch` blocks in the main application loop to gracefully handle unexpected errors, particularly `InputMismatchException` from `Scanner` and potential `RuntimeException`s from task operations.
 * 
 * **Enums:** Define `Priority` and `Status` enums as described above.
 * 
 * **Best Practices:**
 * *   Follow proper encapsulation (`private` fields, `public` methods).
 * *   Use meaningful names for variables, methods, and classes.
 * *   Add comments to explain complex logic.
 * *   Handle potential null values or empty collections gracefully.
 * 
 * **Expected Output:** The application should run in a loop, presenting the menu, taking user input, performing the requested action, and displaying results or error messages until the user chooses to exit. Output format for tasks should be clear (e.g., `[ID] [PRIORITY] [STATUS] - Description`).
 * 
 * **Example Interaction Flow:**
 * 
 * ```
 * Task Management System Menu:
 * 1. Add New Task
 * 2. View All Tasks
 * 3. View Urgent Tasks Queue
 * 4. Process Next Urgent Task
 * 5. Mark Task as Completed/Cancelled
 * 6. Exit
 * Enter your choice: 1
 * Enter task description: Fix critical bug
 * Enter priority (HIGH, MEDIUM, LOW): HIGH
 * Task added with ID: 1
 * 
 * Task Management System Menu:
 * ...
 * Enter your choice: 1
 * Enter task description: Update documentation
 * Enter priority (HIGH, MEDIUM, LOW): LOW
 * Task added with ID: 2
 * 
 * Task Management System Menu:
 * ...
 * Enter your choice: 3
 * Urgent Tasks Queue:
 * [1] HIGH PENDING - Fix critical bug
 * 
 * Task Management System Menu:
 * ...
 * Enter your choice: 4
 * Processing urgent task: [1] HIGH PENDING - Fix critical bug
 * Task ID 1 status updated to PROCESSING.
 * 
 * Task Management System Menu:
 * ...
 * Enter your choice: 2
 * All Tasks:
 * [1] HIGH PROCESSING - Fix critical bug
 * [2] LOW PENDING - Update documentation
 * 
 * Task Management System Menu:
 * ...
 * Enter your choice: 5
 * Enter Task ID to update: 1
 * Enter new status (COMPLETED, CANCELLED): COMPLETED
 * Task ID 1 status updated to COMPLETED.
 * 
 * Task Management System Menu:
 * ...
 * Enter your choice: 3
 * Urgent Tasks Queue:
 * (Queue is empty)
 * 
 * Task Management System Menu:
 * ...
 * Enter your choice: 6
 * Exiting Task Management System.
 * ```
 * 
 * **Evaluation:** Your solution will be evaluated based on correctness, adherence to requirements (especially the use of specified components), code structure, error handling, and best practices.
 *
 * EXPLANATION:
 * This solution implements a Task Management System demonstrating the required Java concepts.
 * 
 * 1.  **Task Class:** Represents a single task with `id`, `description`, `priority`, and `status`. It uses enums (`Priority`, `Status`) for clarity and type safety. Getters and a setter for status are provided, adhering to encapsulation. `toString()` is overridden for easy printing.
 * 
 * 2.  **TaskManager Class:**
 *     *   `allTasks`: An `ArrayList` (implementing `List`) stores all `Task` objects created, providing a comprehensive list of tasks in the system.
 *     *   `urgentTasks`: A `LinkedList` (implementing `Queue`) specifically holds `HIGH` priority tasks that are `PENDING`. This models a queue where urgent tasks are processed in the order they were added (FIFO).
 *     *   `nextTaskId`: An integer is used to generate unique task IDs sequentially.
 *     *   `addTask`: Creates a `Task`, adds it to `allTasks`, and conditionally adds it to `urgentTasks` if it's high priority and pending.
 *     *   `viewAllTasks`: Returns a copy of the `allTasks` list.
 *     *   `viewUrgentTasks`: Returns a list containing elements from the `urgentTasks` queue using `new ArrayList<>(urgentTasks)`, allowing viewing without removing elements from the queue.
 *     *   `processNextUrgentTask`: Uses `urgentTasks.poll()` to remove and retrieve the head of the queue. If a task is retrieved, it finds the *same* task object in `allTasks` (using `findTaskById`) and updates its status to `PROCESSING`. Since both the queue and list hold references to the *same* `Task` object, updating the status on one reference reflects in the other.
 *     *   `updateTaskStatus`: Finds the task in `allTasks` by ID. If found, updates its status. If the new status is `COMPLETED` or `CANCELLED`, it attempts to remove the task from the `urgentTasks` queue using `urgentTasks.remove(task)`. This is necessary because a completed/cancelled task is no longer urgent.
 *     *   `findTaskById`: A private helper method to locate a task within the `allTasks` list.
 * 
 * 3.  **TaskManagementApp Class:**
 *     *   This is the main application class that handles the user interface.
 *     *   It uses a `Scanner` to read input from `System.in`.
 *     *   A `while` loop keeps the application running until the user chooses to exit.
 *     *   Inside the loop, a menu is printed using `System.out`.
 *     *   A `switch` statement handles the user's integer choice, directing execution to the appropriate helper method (`addTask`, `viewAllTasks`, etc.).
 *     *   **Exception Handling:** A `try-catch` block wraps the core logic within the `while` loop.
 *         *   `InputMismatchException` is caught specifically when reading the menu choice (`scanner.nextInt()`). This handles cases where the user enters text instead of a number. An error message is printed to `System.err`, and `scanner.nextLine()` is called to clear the invalid input from the buffer.
 *         *   A general `Exception` catch block is included as a fallback to handle any other unexpected runtime errors that might occur within the operations, printing an error message to `System.err` and a stack trace for debugging.
 *     *   Helper methods (`addTask`, `viewAllTasks`, etc.) encapsulate the logic for each menu option.
 *     *   Input validation for priority and status is performed within `addTask` and `updateTaskStatus` using `try-catch` blocks around `Priority.valueOf()` and `Status.valueOf()`, printing error messages to `System.err` for invalid enum values.
 *     *   Error messages related to system state (e.g., task not found, empty queue) are printed to `System.err`.
 *     *   Normal output (menu, task lists, success messages) is printed to `System.out`.
 * 
 * This solution effectively integrates `Queue`, `ArrayList` (`List`), `Scanner`, `Switch`, `System.err`, `System.out`, and `try-catch` within a practical, object-oriented design, demonstrating key Java programming concepts and best practices like encapsulation, meaningful names, and basic error handling.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.InputMismatchException;

// Enum for Task Priority
enum Priority {
    HIGH, MEDIUM, LOW
}

// Enum for Task Status
enum Status {
    PENDING, PROCESSING, COMPLETED, CANCELLED
}

// Represents a single task
class Task {
    private int id;
    private String description;
    private Priority priority;
    private Status status;

    public Task(int id, String description, Priority priority) {
        this.id = id;
        this.description = description;
        this.priority = priority;
        this.status = Status.PENDING; // Default status
    }

    // Getters
    public int getId() {
        return id;
    }

    public String getDescription() {
        return description;
    }

    public Priority getPriority() {
        return priority;
    }

    public Status getStatus() {
        return status;
    }

    // Setter for status
    public void setStatus(Status status) {
        this.status = status;
    }

    @Override
    public String toString() {
        return String.format("[%d] %s %s - %s", id, priority, status, description);
    }
}

// Manages the collection of tasks
class TaskManager {
    private List<Task> allTasks;
    private Queue<Task> urgentTasks;
    private int nextTaskId;

    public TaskManager() {
        this.allTasks = new ArrayList<>();
        this.urgentTasks = new LinkedList<>(); // LinkedList implements Queue
        this.nextTaskId = 1;
    }

    /**
     * Adds a new task to the system.
     * @param description The task description.
     * @param priority The task priority.
     * @return The ID of the newly created task.
     */
    public int addTask(String description, Priority priority) {
        int currentId = nextTaskId++;
        Task newTask = new Task(currentId, description, priority);
        allTasks.add(newTask);

        // Add high priority tasks to the urgent queue if pending
        if (priority == Priority.HIGH && newTask.getStatus() == Status.PENDING) {
            urgentTasks.offer(newTask); // offer is preferred over add for queues
        }

        return currentId;
    }

    /**
     * Returns a list of all tasks in the system.
     * @return A List of Task objects.
     */
    public List<Task> viewAllTasks() {
        return new ArrayList<>(allTasks); // Return a copy to prevent external modification
    }

    /**
     * Returns a list of tasks currently in the urgent queue without removing them.
     * @return A List of Task objects from the urgent queue.
     */
    public List<Task> viewUrgentTasks() {
        // Convert queue elements to a list for viewing
        return new ArrayList<>(urgentTasks);
    }

    /**
     * Processes the next task in the urgent queue.
     * Removes the task from the queue and updates its status to PROCESSING in the main list.
     * @return The task that was processed, or null if the queue was empty.
     */
    public Task processNextUrgentTask() {
        Task taskToProcess = urgentTasks.poll(); // Remove and return the head of the queue

        if (taskToProcess != null) {
            // Find the task in the main list and update its status
            Task taskInList = findTaskById(taskToProcess.getId());
            if (taskInList != null) {
                taskInList.setStatus(Status.PROCESSING);
                // Note: Since taskToProcess is the same object reference as taskInList,
                // updating taskInList is sufficient.
            } else {
                 // This case should ideally not happen if logic is correct,
                 // but good for robustness.
                 System.err.println("Error: Processed urgent task not found in main list!");
            }
        }
        return taskToProcess;
    }

    /**
     * Updates the status of a task by its ID.
     * @param taskId The ID of the task to update.
     * @param newStatus The new status to set.
     * @return true if the task was found and updated, false otherwise.
     */
    public boolean updateTaskStatus(int taskId, Status newStatus) {
        Task task = findTaskById(taskId);
        if (task != null) {
            task.setStatus(newStatus);

            // If status changes to completed or cancelled, remove from urgent queue if present
            if (newStatus == Status.COMPLETED || newStatus == Status.CANCELLED) {
                 // Removing from LinkedList (which Queue extends) is O(n),
                 // but acceptable for this scale.
                 // Note: Use task object reference for removal
                 urgentTasks.remove(task);
            }
            // If status changes from PENDING to something else, and it was HIGH priority,
            // it should also be removed from the urgent queue.
            // This is implicitly handled by the remove(task) call above if the task was in the queue.

            return true;
        }
        return false; // Task not found
    }

    /**
     * Finds a task in the main list by its ID.
     * @param taskId The ID to search for.
     * @return The Task object if found, null otherwise.
     */
    private Task findTaskById(int taskId) {
        for (Task task : allTasks) {
            if (task.getId() == taskId) {
                return task;
            }
        }
        return null; // Task not found
    }
}

// Main application class
public class TaskManagementApp {

    private static TaskManager taskManager = new TaskManager();
    private static Scanner scanner = new Scanner(System.in);

    public static void main(String[] args) {
        System.out.println("Welcome to the Task Management System!");

        boolean running = true;
        while (running) {
            printMenu();
            try {
                System.out.print("Enter your choice: ");
                int choice = scanner.nextInt();
                scanner.nextLine(); // Consume newline

                switch (choice) {
                    case 1:
                        addTask();
                        break;
                    case 2:
                        viewAllTasks();
                        break;
                    case 3:
                        viewUrgentTasks();
                        break;
                    case 4:
                        processNextUrgentTask();
                        break;
                    case 5:
                        updateTaskStatus();
                        break;
                    case 6:
                        running = false;
                        System.out.println("Exiting Task Management System.");
                        break;
                    default:
                        System.err.println("Invalid choice. Please enter a number between 1 and 6.");
                }
            } catch (InputMismatchException e) {
                System.err.println("Invalid input. Please enter a number.");
                scanner.nextLine(); // Consume the invalid input
            } catch (Exception e) {
                // Catch any other unexpected exceptions
                System.err.println("An unexpected error occurred: " + e.getMessage());
                e.printStackTrace(System.err); // Print stack trace to stderr
            }
            System.out.println(); // Add a blank line for readability
        }

        scanner.close();
    }

    private static void printMenu() {
        System.out.println("Task Management System Menu:");
        System.out.println("1. Add New Task");
        System.out.println("2. View All Tasks");
        System.out.println("3. View Urgent Tasks Queue");
        System.out.println("4. Process Next Urgent Task");
        System.out.println("5. Mark Task as Completed/Cancelled");
        System.out.println("6. Exit");
    }

    private static void addTask() {
        System.out.print("Enter task description: ");
        String description = scanner.nextLine();

        Priority priority = null;
        while (priority == null) {
            System.out.print("Enter priority (HIGH, MEDIUM, LOW): ");
            String priorityStr = scanner.nextLine().trim().toUpperCase();
            try {
                priority = Priority.valueOf(priorityStr);
            } catch (IllegalArgumentException e) {
                System.err.println("Invalid priority entered. Please use HIGH, MEDIUM, or LOW.");
            }
        }

        int taskId = taskManager.addTask(description, priority);
        System.out.println("Task added with ID: " + taskId);
    }

    private static void viewAllTasks() {
        List<Task> tasks = taskManager.viewAllTasks();
        if (tasks.isEmpty()) {
            System.out.println("No tasks in the system.");
        } else {
            System.out.println("All Tasks:");
            for (Task task : tasks) {
                System.out.println(task);
            }
        }
    }

    private static void viewUrgentTasks() {
        List<Task> urgentTasks = taskManager.viewUrgentTasks();
        if (urgentTasks.isEmpty()) {
            System.out.println("Urgent Tasks Queue:\n(Queue is empty)");
        } else {
            System.out.println("Urgent Tasks Queue:");
            for (Task task : urgentTasks) {
                System.out.println(task);
            }
        }
    }

    private static void processNextUrgentTask() {
        Task processedTask = taskManager.processNextUrgentTask();
        if (processedTask != null) {
            System.out.println("Processing urgent task: " + processedTask);
            System.out.println("Task ID " + processedTask.getId() + " status updated to PROCESSING.");
        } else {
            System.err.println("No urgent tasks to process. The queue is empty.");
        }
    }

    private static void updateTaskStatus() {
        System.out.print("Enter Task ID to update: ");
        int taskId;
        try {
            taskId = scanner.nextInt();
            scanner.nextLine(); // Consume newline
        } catch (InputMismatchException e) {
            System.err.println("Invalid input. Please enter a valid number for Task ID.");
            scanner.nextLine(); // Consume the invalid input
            return;
        }

        Status newStatus = null;
        while (newStatus == null) {
            System.out.print("Enter new status (PENDING, PROCESSING, COMPLETED, CANCELLED): ");
            String statusStr = scanner.nextLine().trim().toUpperCase();
            try {
                newStatus = Status.valueOf(statusStr);
            } catch (IllegalArgumentException e) {
                System.err.println("Invalid status entered. Please use PENDING, PROCESSING, COMPLETED, or CANCELLED.");
            }
        }

        boolean success = taskManager.updateTaskStatus(taskId, newStatus);
        if (success) {
            System.out.println("Task ID " + taskId + " status updated to " + newStatus + ".");
        } else {
            System.err.println("Error: Task with ID " + taskId + " not found.");
        }
    }
}
