/*
 * Exam Question #831
 * Generated on: 2025-05-12 16:47:47
 * Generated by: Account 2
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Event Registration System
 * 
 * **Scenario:**
 * 
 * You are tasked with developing a simple command-line based Event Registration System. The system manages a list of available sessions and a queue of attendees waiting to be registered. Attendees arrive and are added to a general registration queue. An administrator then processes attendees one by one from the front of the queue, attempting to register them for a specific session. Registration for a session is only possible if the session exists and has available capacity.
 * 
 * **Requirements:**
 * 
 * 1.  **Core Functionality:**
 *     *   Maintain a collection of available `Session` objects.
 *     *   Maintain a queue of attendee names waiting for registration processing.
 *     *   Provide a menu-driven interface for user interaction.
 * 
 * 2.  **`Session` Class:**
 *     *   Create a class named `Session`.
 *     *   It must have private fields for:
 *         *   `id` (String, unique identifier)
 *         *   `topic` (String)
 *         *   `speaker` (String)
 *         *   `capacity` (int, maximum attendees)
 *         *   `registeredAttendees` (a collection to store names of registered attendees).
 *     *   Implement a constructor to initialize these fields.
 *     *   Implement public getter methods for all fields.
 *     *   Implement a public method `addAttendee(String attendeeName)` that attempts to add an attendee's name to the `registeredAttendees` collection. This method should return `true` if the attendee was successfully added (i.e., there was space), and `false` otherwise.
 *     *   Implement a public method `isFull()` that returns `true` if the session has reached its capacity, `false` otherwise.
 *     *   Include appropriate input validation in the constructor (e.g., positive capacity, non-empty ID).
 * 
 * 3.  **Main System Class:**
 *     *   Create a main class (e.g., `EventManagementSystem`) containing the `main` method and the core logic.
 *     *   This class must have private fields for:
 *         *   The collection of `Session` objects.
 *         *   The queue of attendee names waiting in the registration queue.
 *         *   A `Scanner` object for reading user input.
 *     *   Implement a constructor to initialize these collections and the `Scanner`. Optionally, pre-populate with a few sample sessions.
 *     *   Implement a `run()` method containing the main application loop and menu handling.
 * 
 * 4.  **Menu Options (using `switch` statement):**
 *     *   **1. Add New Session:** Prompts the user for session details (ID, topic, speaker, capacity) and creates/adds a new `Session` object to the collection. Validate input. Ensure session ID is unique (print error if duplicate).
 *     *   **2. Add Attendee to Registration Queue:** Prompts the user for an attendee's name and adds it to the registration queue. Validate attendee name (non-empty).
 *     *   **3. Process Next Attendee from Queue:** Takes the next attendee from the front of the registration queue. Prompts the user for the ID of the session to register them for.
 *         *   If the queue is empty, print an error.
 *         *   If the session ID is not found, print an error, and the attendee remains in the queue.
 *         *   If the session is full, print a message, and the attendee remains in the queue.
 *         *   If successful, remove the attendee from the queue and add them to the target session's registered attendees list. Print success message.
 *     *   **4. View Sessions:** Displays a list of all sessions, showing ID, topic, speaker, current attendees, and capacity.
 *     *   **5. View Registration Queue:** Displays the names of all attendees currently in the registration queue, in order.
 *     *   **6. Exit:** Terminates the application.
 * 
 * 5.  **Required Java Components:** Your solution **must** explicitly use ALL of the following:
 *     *   `java.util.Queue` (for the registration queue)
 *     *   `java.util.ArrayList` (at least one instance, e.g., for sessions or registered attendees)
 *     *   `java.util.List` interface (declare at least one collection using the `List` interface type)
 *     *   `java.util.Scanner` (for user input)
 *     *   `switch` statement (for menu navigation)
 *     *   `System.err` (for printing error messages, e.g., invalid input, session not found, queue empty)
 *     *   `System.out` (for printing menu, prompts, success messages, lists)
 *     *   Class-wide exception handling using `try-catch` blocks in the main `run` method to handle potential runtime issues (e.g., `InputMismatchException` from `Scanner`, `IllegalArgumentException` from validation).
 * 
 * 6.  **Best Practices:**
 *     *   Use proper encapsulation (private fields, public methods).
 *     *   Use meaningful variable and method names.
 *     *   Include basic comments to explain key parts of the code.
 *     *   Implement input validation where necessary.
 *     *   Implement proper error handling using `System.err` and `try-catch`.
 *     *   Structure the code cleanly (separate classes, methods for distinct tasks).
 * 
 * **Expected Output:**
 * 
 * Your program should present a menu, accept user input, and display appropriate information or error messages based on the chosen action and system state. Examples:
 * 
 * ```
 * --- Event Registration System ---
 * Menu:
 * 1. Add New Session
 * 2. Add Attendee to Registration Queue
 * 3. Process Next Attendee from Queue
 * 4. View Sessions
 * 5. View Registration Queue
 * 6. Exit
 * Enter your choice: 4
 * --- Available Sessions ---
 * 1. Session [ID=S001, Topic=Introduction to Java, Speaker=Dr. Code, Attendees=0/50]
 * 2. Session [ID=S002, Topic=Advanced Algorithms, Speaker=Prof. Data, Attendees=0/30]
 * 3. Session [ID=S003, Topic=Networking Basics, Speaker=Eng. Connect, Attendees=0/40]
 * 
 * Enter your choice: 2
 * --- Add Attendee to Queue ---
 * Enter Attendee Name: Alice
 * 
 * Attendee 'Alice' added to registration queue.
 * 
 * Enter your choice: 5
 * --- Registration Queue ---
 * 1. Alice
 * 
 * Enter your choice: 3
 * --- Process Next Attendee ---
 * Processing attendee: Alice
 * --- Available Sessions ---
 * 1. Session [ID=S001, Topic=Introduction to Java, Speaker=Dr. Code, Attendees=0/50]
 * 2. Session [ID=S002, Topic=Advanced Algorithms, Speaker=Prof. Data, Attendees=0/30]
 * 3. Session [ID=S003, Topic=Networking Basics, Speaker=Eng. Connect, Attendees=0/40]
 * Enter the ID of the session to register Alice for: S001
 * 
 * Successfully registered Alice for session 'S001'.
 * 
 * Enter your choice: 4
 * --- Available Sessions ---
 * 1. Session [ID=S001, Topic=Introduction to Java, Speaker=Dr. Code, Attendees=1/50]
 * 2. Session [ID=S002, Topic=Advanced Algorithms, Speaker=Prof. Data, Attendees=0/30]
 * 3. Session [ID=S003, Topic=Networking Basics, Speaker=Eng. Connect, Attendees=0/40]
 * 
 * Enter your choice: 3
 * --- Process Next Attendee ---
 * Registration queue is empty. No attendees to process.
 * 
 * Enter your choice: 7
 * Invalid choice. Please enter a number between 1 and 6.
 * 
 * Enter your choice: abc
 * Invalid input. Please enter a number.
 * 
 * Enter your choice: 6
 * Exiting system. Goodbye!
 * ```
 * 
 * Implement the Java code for this system.
 *
 * EXPLANATION:
 * The provided solution implements a simple Event Registration System demonstrating the required Java concepts and best practices.
 * 
 * **Overall Architecture:**
 * The system is composed of two main classes:
 * 1.  `Session`: An object-oriented representation of an event session, holding its details (`id`, `topic`, `speaker`, `capacity`) and managing its list of registered attendees (`registeredAttendees`). It encapsulates session-specific logic like checking capacity and adding attendees.
 * 2.  `EventManagementSystem`: The main class that orchestrates the application flow. It holds the central data structures (`sessions` and `registrationQueue`), manages user interaction via the `Scanner` and a menu (`switch`), and contains the primary application loop (`run` method) along with class-wide exception handling.
 * 
 * **Usage of Required Components:**
 * 
 * *   **`java.util.Queue`:** The `registrationQueue` field in `EventManagementSystem` is declared as `Queue<String>` and implemented using `java.util.LinkedList`. This correctly models the "waiting line" behavior where attendees are processed in the order they were added (First-In, First-Out). Methods like `offer()` (to add) and `poll()` (to remove from the head) are used. `peek()` is used to inspect the next element without removing it.
 * *   **`java.util.ArrayList`:** The `sessions` field in `EventManagementSystem` is declared as `List<Session>` and implemented using `java.util.ArrayList`. This allows dynamic resizing and easy access to sessions. Within the `Session` class, the `registeredAttendees` field is declared as `List<String>` and also implemented using `java.util.ArrayList`. This provides a dynamic list to store attendee names for a specific session.
 * *   **`java.util.List` interface:** Both `sessions` and `registeredAttendees` are declared using the `List` interface type (`List<Session>` and `List<String>`), demonstrating polymorphism and coding to the interface rather than the specific implementation (`ArrayList`).
 * *   **`java.util.Scanner`:** A `Scanner` object is used in the `EventManagementSystem` class to read various types of user input from the console (`System.in`), including menu choices, session details, and attendee names.
 * *   **`switch` statement:** The main menu logic within the `run` method uses a `switch` statement based on the user's integer choice to direct execution to the appropriate handler method (`addSession`, `addAttendeeToQueue`, etc.).
 * *   **`System.err`:** Used specifically for printing error messages to the standard error stream. This includes messages for invalid menu choices, `InputMismatchException`, `IllegalArgumentException`, session not found errors, queue empty errors, duplicate session IDs, and other processing failures. This separates error output from normal program output.
 * *   **`System.out`:** Used for all normal program output, such as printing the menu, prompts for input, success messages, session lists, and the contents of the registration queue.
 * *   **Class-wide exception handling with `try-catch` blocks:** The primary `run` method contains a `try-catch` block that wraps the main application loop (`while(running)`). This block catches potential `InputMismatchException` (e.g., if the user enters text instead of a number for the menu choice), `IllegalArgumentException` (potentially thrown by the `Session` constructor during initialization or when adding sessions), and a general `Exception` for any other unexpected runtime errors. Specific methods like `addSession` also include local `try-catch` blocks to handle potential `InputMismatchException` when reading specific data like capacity, preventing the entire application from crashing due to a single input error. The `finally` block ensures the `Scanner` is closed.
 * 
 * **Best Practices:**
 * 
 * *   **Encapsulation:** Private fields are used in both `Session` and `EventManagementSystem`, with public getter methods provided where necessary (`Session`). The internal state of objects is protected.
 * *   **Meaningful Names:** Variables (`sessions`, `registrationQueue`, `currentAttendee`, `targetSession`), methods (`addSession`, `processNextAttendee`, `viewRegistrationQueue`), and classes (`Session`, `EventManagementSystem`) have names that clearly indicate their purpose.
 * *   **Comments:** Basic comments are included to explain the purpose of classes, methods, and key code sections, aiding readability.
 * *   **Input Validation:** Checks are performed for non-empty strings (session ID, attendee name) and positive numbers (session capacity). Duplicate session IDs are also checked. Validation errors often result in `System.err` messages and prevent invalid state changes.
 * *   **Error Handling:** Specific error conditions (queue empty, session not found, session full, invalid input) are checked and handled gracefully with informative messages to `System.err` or `System.out`. The `try-catch` blocks prevent program termination due to runtime errors.
 * *   **Clean Code Structure:** The code is divided into logical units (`Session` class, methods within `EventManagementSystem` for each menu option). The `run` method acts as a clear entry point and controller.
 * 
 * **Key Logic Flow (Option 3: Process Next Attendee):**
 * This method demonstrates the interaction between the `Queue` and the `List` (`Session`'s `registeredAttendees`).
 * 1.  It first checks if the `registrationQueue` is empty using `isEmpty()`.
 * 2.  If not empty, it uses `peek()` to look at the next attendee without removing them yet. This is important because registration might fail (session full or not found), and the attendee should remain in the queue in those cases.
 * 3.  It prompts the user for a session ID and searches the `sessions` `List` to find the corresponding `Session` object.
 * 4.  It checks if the `targetSession` was found and if it's full using `isFull()`.
 * 5.  Only if the session is found AND has space, it calls `targetSession.addAttendee()`. If `addAttendee()` returns `true` (successful registration), the attendee is then removed from the `registrationQueue` using `poll()`. This two-step process (peek then poll after success) ensures the attendee is only removed from the queue if they are successfully registered for a session.
 * 
 * This solution effectively combines various fundamental and intermediate Java concepts to solve a practical simulation problem, meeting all specified requirements for the exam task.
 */

import java.util.ArrayList;
import java.util.LinkedList; // LinkedList is a common Queue implementation
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.InputMismatchException;

/**
 * Represents a single session within the event management system.
 * Manages session details and registered attendees.
 */
class Session {
    private String id;
    private String topic;
    private String speaker;
    private int capacity;
    private List<String> registeredAttendees; // Using List interface, implemented by ArrayList

    /**
     * Constructs a new Session.
     *
     * @param id The unique identifier for the session.
     * @param topic The topic of the session.
     * @param speaker The speaker presenting the session.
     * @param capacity The maximum number of attendees allowed.
     * @throws IllegalArgumentException if ID is empty or capacity is not positive.
     */
    public Session(String id, String topic, String speaker, int capacity) {
        // Input validation
        if (id == null || id.trim().isEmpty()) {
            throw new IllegalArgumentException("Session ID cannot be empty.");
        }
        if (capacity <= 0) {
            throw new IllegalArgumentException("Capacity must be a positive number.");
        }

        this.id = id.trim();
        this.topic = topic != null ? topic.trim() : "N/A";
        this.speaker = speaker != null ? speaker.trim() : "N/A";
        this.capacity = capacity;
        this.registeredAttendees = new ArrayList<>(); // Implementation is ArrayList
    }

    // --- Getters ---
    public String getId() { return id; }
    public String getTopic() { return topic; }
    public String getSpeaker() { return speaker; }
    public int getCapacity() { return capacity; }
    public List<String> getRegisteredAttendees() { return registeredAttendees; } // Returns the internal list

    /**
     * Gets the current number of attendees registered for the session.
     * @return The number of registered attendees.
     */
    public int getCurrentAttendees() { return registeredAttendees.size(); }

    /**
     * Attempts to add an attendee to this session.
     *
     * @param attendeeName The name of the attendee to register.
     * @return true if the attendee was successfully added, false if session is full or name is invalid.
     */
    public boolean addAttendee(String attendeeName) {
        if (isFull()) {
            return false; // Session is full
        }
        if (attendeeName == null || attendeeName.trim().isEmpty()) {
            return false; // Invalid name
        }
        // Add attendee if there's space and name is valid
        return registeredAttendees.add(attendeeName.trim());
    }

    /**
     * Checks if the session has reached its maximum capacity.
     * @return true if full, false otherwise.
     */
    public boolean isFull() {
        return registeredAttendees.size() >= capacity;
    }

    /**
     * Provides a string representation of the session for display.
     * @return Formatted session details string.
     */
    @Override
    public String toString() {
        return "Session [ID=" + id + ", Topic=" + topic + ", Speaker=" + speaker +
               ", Attendees=" + registeredAttendees.size() + "/" + capacity + "]";
    }
}

/**
 * Main class for the Event Registration System.
 * Manages sessions and the attendee registration queue.
 */
public class EventManagementSystem {
    // Use List interface type, implemented by ArrayList
    private List<Session> sessions;
    // Use Queue interface type, implemented by LinkedList
    private Queue<String> registrationQueue;
    private Scanner scanner;

    /**
     * Constructs the EventManagementSystem, initializing collections and scanner.
     * Adds some initial sample sessions.
     */
    public EventManagementSystem() {
        sessions = new ArrayList<>(); // ArrayList implementation
        registrationQueue = new LinkedList<>(); // LinkedList implementation for Queue
        scanner = new Scanner(System.in);

        // Add some initial sessions for testing
        try {
            sessions.add(new Session("S001", "Introduction to Java", "Dr. Code", 50));
            sessions.add(new Session("S002", "Advanced Algorithms", "Prof. Data", 30));
            sessions.add(new Session("S003", "Networking Basics", "Eng. Connect", 40));
        } catch (IllegalArgumentException e) {
            // This should not happen with hardcoded values, but good practice
            System.err.println("Error initializing sample sessions: " + e.getMessage());
        }
    }

    /**
     * Starts the main application loop and handles the user menu.
     * Contains the class-wide exception handling block.
     */
    public void run() {
        System.out.println("--- Event Registration System ---");
        boolean running = true;

        // Class-wide try-catch block for general exceptions during menu interaction
        try {
            while (running) {
                printMenu();
                System.out.print("Enter your choice: ");
                int choice = scanner.nextInt();
                scanner.nextLine(); // Consume the newline character after reading int

                switch (choice) {
                    case 1:
                        addSession();
                        break;
                    case 2:
                        addAttendeeToQueue();
                        break;
                    case 3:
                        processNextAttendee();
                        break;
                    case 4:
                        viewSessions();
                        break;
                    case 5:
                        viewRegistrationQueue();
                        break;
                    case 6:
                        running = false;
                        System.out.println("Exiting system. Goodbye!");
                        break;
                    default:
                        // Invalid menu option
                        System.err.println("Invalid choice. Please enter a number between 1 and 6.");
                }
                System.out.println(); // Print a blank line for better readability between actions
            }
        } catch (InputMismatchException e) {
            // Handles cases where user enters non-integer for menu choice
            System.err.println("Invalid input. Please enter a number for the menu choice.");
            // It's usually necessary to consume the invalid input token after catching InputMismatchException
            // However, since this catch is around the main loop's nextInt(), and we exit or continue,
            // re-consuming here might interfere with the next loop iteration's nextInt().
            // A more robust input loop might be needed for complex scenarios, but for this exam structure,
            // letting the loop potentially re-prompt after the error might be acceptable.
            // Let's add scanner.nextLine() here to attempt to clear the line, although it's tricky.
            scanner.nextLine(); // Attempt to consume the rest of the line containing invalid input
            run(); // Restart the run loop - simple recovery strategy for exam
        } catch (IllegalArgumentException e) {
             // Catches validation errors thrown by Session constructor, etc.
             System.err.println("Configuration Error: " + e.getMessage());
        } catch (Exception e) {
            // Catch any other unexpected runtime exceptions
            System.err.println("An unexpected error occurred: " + e.getMessage());
            e.printStackTrace(); // Print stack trace for debugging in an exam setting
        } finally {
            // Ensure scanner is closed when the application exits
            if (scanner != null) {
                scanner.close();
            }
        }
    }

    /**
     * Prints the main menu options to the console.
     */
    private void printMenu() {
        System.out.println("Menu:");
        System.out.println("1. Add New Session");
        System.out.println("2. Add Attendee to Registration Queue");
        System.out.println("3. Process Next Attendee from Queue");
        System.out.println("4. View Sessions");
        System.out.println("5. View Registration Queue");
        System.out.println("6. Exit");
    }

    /**
     * Handles adding a new session based on user input.
     * Includes input validation and checks for duplicate session IDs.
     */
    private void addSession() {
        System.out.println("--- Add New Session ---");
        System.out.print("Enter Session ID: ");
        String id = scanner.nextLine();
        System.out.print("Enter Topic: ");
        String topic = scanner.nextLine();
        System.out.print("Enter Speaker: ");
        String speaker = scanner.nextLine();
        System.out.print("Enter Capacity: ");

        int capacity = 0;
        try {
            capacity = scanner.nextInt();
            scanner.nextLine(); // Consume the rest of the line
        } catch (InputMismatchException e) {
             System.err.println("Invalid input for capacity. Please enter a number.");
             scanner.nextLine(); // Consume the invalid input
             return; // Exit the method on input error
        }

        // Check if session ID already exists before creating the object
        boolean idExists = sessions.stream().anyMatch(session -> session.getId().equalsIgnoreCase(id));
        if (idExists) {
            System.err.println("Error: Session with ID '" + id + "' already exists. Cannot add.");
            return; // Exit the method
        }

        try {
            Session newSession = new Session(id, topic, speaker, capacity);
            sessions.add(newSession); // Add to the sessions list
            System.out.println("Session '" + id + "' added successfully.");
        } catch (IllegalArgumentException e) {
            // Catches validation errors from the Session constructor
            System.err.println("Error creating session: " + e.getMessage());
        }
    }

    /**
     * Handles adding a new attendee name to the registration queue.
     * Validates attendee name input.
     */
    private void addAttendeeToQueue() {
        System.out.println("--- Add Attendee to Queue ---");
        System.out.print("Enter Attendee Name: ");
        String attendeeName = scanner.nextLine();

        if (attendeeName == null || attendeeName.trim().isEmpty()) {
            System.err.println("Attendee name cannot be empty.");
            return;
        }

        // offer() is generally preferred over add() for queues as it doesn't throw exceptions
        boolean added = registrationQueue.offer(attendeeName.trim());
        if (added) {
             System.out.println("Attendee '" + attendeeName.trim() + "' added to registration queue.");
        } else {
             // This case is rare for LinkedList unless memory is exhausted
             System.err.println("Failed to add attendee to queue.");
        }
    }

    /**
     * Processes the next attendee from the front of the registration queue.
     * Prompts for a session ID and attempts to register the attendee.
     * Handles queue empty, session not found, and session full scenarios.
     */
    private void processNextAttendee() {
        System.out.println("--- Process Next Attendee ---");

        // Check if the queue is empty
        if (registrationQueue.isEmpty()) {
            System.err.println("Registration queue is empty. No attendees to process.");
            return;
        }

        // Peek the next attendee without removing yet
        String currentAttendee = registrationQueue.peek();
        System.out.println("Processing attendee: " + currentAttendee);

        // Show available sessions to help the user choose
        viewSessions();

        System.out.print("Enter the ID of the session to register " + currentAttendee + " for: ");
        String sessionId = scanner.nextLine();

        // Find the target session by ID
        Session targetSession = null;
        for (Session session : sessions) {
            if (session.getId().equalsIgnoreCase(sessionId)) {
                targetSession = session;
                break;
            }
        }

        // Handle registration outcome
        if (targetSession == null) {
            System.err.println("Error: Session with ID '" + sessionId + "' not found.");
            // Attendee remains in the queue if the session is not found.
        } else if (targetSession.isFull()) {
            System.out.println("Session '" + targetSession.getId() + "' is full. Cannot register " + currentAttendee + ".");
            // Attendee remains in the queue if the session is full.
        } else {
            // Session found and has space - attempt to register
            boolean addedToSession = targetSession.addAttendee(currentAttendee); // Add to session's list

            if (addedToSession) {
                 // If successfully added to session, remove from the registration queue
                 String removedAttendee = registrationQueue.poll(); // poll() removes and returns the head
                 // Basic check to ensure the correct attendee was removed (should always be true here)
                 if (removedAttendee != null && removedAttendee.equals(currentAttendee)) {
                     System.out.println("Successfully registered " + currentAttendee + " for session '" + targetSession.getId() + "'.");
                 } else {
                     // This indicates a logic error if poll() didn't return the peeked element
                     System.err.println("Internal Error: Failed to remove attendee from queue after successful registration.");
                     // The attendee might be duplicated (in session list and still in queue) - needs manual fix in a real system
                 }
            } else {
                // This case should ideally not be reached if isFull() check passes,
                // but is included for defensive programming against addAttendee failure.
                System.err.println("Failed to register " + currentAttendee + " for session '" + targetSession.getId() + "' due to an internal issue.");
                // Attendee remains in queue.
            }
        }
    }

    /**
     * Displays details of all available sessions.
     */
    private void viewSessions() {
        System.out.println("--- Available Sessions ---");
        if (sessions.isEmpty()) {
            System.out.println("No sessions available.");
            return;
        }
        // Iterate using a standard for loop or enhanced for loop
        for (int i = 0; i < sessions.size(); i++) {
            Session session = sessions.get(i); // Access using index for numbered list
            System.out.println((i + 1) + ". " + session); // Session's toString() is used here
        }
    }

    /**
     * Displays the current attendees in the registration queue, in order.
     */
    private void viewRegistrationQueue() {
        System.out.println("--- Registration Queue ---");
        if (registrationQueue.isEmpty()) {
            System.out.println("Queue is empty.");
            return;
        }
        // Iterate through the queue without removing elements
        int i = 1;
        for (String attendee : registrationQueue) {
            System.out.println(i++ + ". " + attendee);
        }
    }

    /**
     * Main method to start the application.
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        EventManagementSystem system = new EventManagementSystem();
        system.run(); // Start the main application loop
    }
}
