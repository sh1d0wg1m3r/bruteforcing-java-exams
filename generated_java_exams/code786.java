/*
 * Exam Question #786
 * Generated on: 2025-05-12 16:40:30
 * Generated by: Account 3
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Warehouse Order Fulfillment System
 * 
 * **Objective:** Design and implement a console-based simulation of a warehouse order fulfillment system. The system should manage inventory, accept customer orders, queue them for processing, and fulfill them based on inventory availability.
 * 
 * **Requirements:**
 * 
 * 1.  **Core Functionality:**
 *     *   Maintain a list of items in inventory with their current quantities.
 *     *   Accept new orders, each containing a list of items and desired quantities. Orders should be added to a waiting queue.
 *     *   Process orders from the queue in a First-In, First-Out (FIFO) manner.
 *     *   During processing, check if all items in the order are available in sufficient quantities in the inventory.
 *     *   If sufficient inventory exists for *all* items in an order, decrement the inventory quantities and mark the order as fulfilled (by removing it from the queue).
 *     *   If insufficient inventory exists for *any* item in an order, the order should *not* be processed or removed from the queue. An error message should be displayed.
 *     *   Allow the user to view the current inventory levels.
 *     *   Allow the user to view the pending orders in the queue.
 * 
 * 2.  **User Interface:**
 *     *   Use `java.util.Scanner` to read user commands from the console.
 *     *   Implement the following commands using a `switch` statement:
 *         *   `add <item1> <quantity1> [<item2> <quantity2> ...]`: Adds a new order to the queue. Example: `add Laptop 1 Mouse 2`.
 *         *   `process`: Attempts to process the next order in the queue.
 *         *   `inventory`: Displays the current inventory levels.
 *         *   `orders`: Displays the list of pending orders in the queue.
 *         *   `help`: Displays the list of available commands.
 *         *   `exit`: Terminates the program.
 *     *   Use `System.out` for normal output (prompts, success messages, displaying data).
 *     *   Use `System.err` to report errors (invalid commands, insufficient inventory, items not found, etc.).
 * 
 * 3.  **Data Structures:**
 *     *   Use `java.util.Queue` (specifically `java.util.LinkedList` which implements `Queue`) to manage pending orders.
 *     *   Use `java.util.ArrayList` to store the warehouse inventory. Use `java.util.List` as the interface type where appropriate (e.g., for inventory and the list of items within an order).
 * 
 * 4.  **Object-Oriented Design:**
 *     *   Create classes to represent `Item` (name, quantity) and `Order` (unique ID, list of items).
 *     *   Create a `Warehouse` class to manage the inventory and the order queue. This class should contain the core logic for adding orders, processing orders, and viewing data.
 *     *   The main application logic (command loop, Scanner, switch) should be in a separate class (e.g., `WarehouseSystem`).
 *     *   Follow best practices: private fields, public methods (getters/setters where necessary), meaningful names, appropriate comments (Javadoc style for classes/methods, inline for complex logic).
 * 
 * 5.  **Error Handling:**
 *     *   Implement input validation for commands and quantities.
 *     *   Use `try-catch` blocks for class-wide exception handling in the main command loop to gracefully handle errors originating from the `Warehouse` methods (e.g., attempting to process an empty queue, insufficient inventory).
 *     *   Define and use a custom exception class (e.g., `InsufficientInventoryException`) for the specific case of insufficient stock during order processing.
 *     *   Handle other potential errors like invalid input format or items not found using appropriate standard exceptions (`IllegalArgumentException`, `IllegalStateException`) and report them using `System.err`.
 * 
 * **Initial State:**
 * The system should start with a predefined initial inventory (e.g., Laptop: 10, Mouse: 50, Keyboard: 30, Monitor: 15).
 * 
 * **Expected Output:**
 * The output should reflect the commands entered, showing success messages, inventory updates (implicitly via the `inventory` command), pending orders, and clear error messages on `System.err` when operations fail. See the example interaction flow in the thought block above for expected behavior.
 * 
 * **Evaluation Criteria:**
 * *   Correct implementation of all required features and commands.
 * *   Proper use of `Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.err`, `System.out`, `try-catch`.
 * *   Correct object-oriented design and encapsulation.
 * *   Effective error handling and input validation.
 * *   Code clarity, readability, comments, and adherence to best practices.
 *
 * EXPLANATION:
 * The provided solution implements a simple Warehouse Order Fulfillment System demonstrating the required Java concepts.
 * 
 * 1.  **Problem Structure:** The system is divided into logical classes:
 *     *   `Item`: Represents a product with a name and quantity. Follows encapsulation with private fields and public getters/setters.
 *     *   `Order`: Represents a customer order with a unique ID and a `List` of `Item`s representing the requested products and quantities for that order. It uses an `ArrayList` internally for the item list, adhering to the `List` interface requirement.
 *     *   `InsufficientInventoryException`: A custom checked exception extending `Exception`, specifically for signaling insufficient stock during order processing.
 *     *   `Warehouse`: This is the core class managing the system's state. It holds the `inventory` (an `ArrayList` implementing `List`) and `pendingOrders` (a `LinkedList` implementing `Queue`). It contains methods for adding orders (`addOrder`), processing the next order (`processNextOrder`), and viewing the state (`viewInventory`, `viewPendingOrders`). It encapsulates the main business logic.
 *     *   `WarehouseSystem`: The main class containing the `main` method. It handles user interaction using `Scanner`, parses commands, and uses a `switch` statement to dispatch actions to the `Warehouse` object. It also implements the class-wide exception handling using a `try-catch` block around the command processing logic.
 * 
 * 2.  **Required Java Components Usage:**
 *     *   `java.util.Queue`: The `pendingOrders` field in the `Warehouse` class is declared as `Queue<Order>` and initialized with `new LinkedList<>()`. `offer()` is used to add orders, and `peek()` and `poll()` are used to inspect and remove orders during processing.
 *     *   `java.util.ArrayList`: The `inventory` field in the `Warehouse` class is declared as `List<Item>` and initialized with `new ArrayList<>()`. It's also used to construct the list of items (`orderItems`) when parsing the `add` command in `WarehouseSystem`.
 *     *   `java.util.List` interface: Used as the type for the `inventory` field and for the `items` field within the `Order` class, promoting good practice by programming to the interface.
 *     *   `java.util.Scanner`: Used in the `main` method of `WarehouseSystem` to read user input from `System.in`.
 *     *   `switch` statement: Used in the `main` method of `WarehouseSystem` to control the flow based on the user's command input.
 *     *   `System.err`: Used in the `catch` blocks within the `main` method of `WarehouseSystem` to report errors caught from `Warehouse` methods. It is also used within `addOrder` for specific input validation errors (like item not found or non-positive quantity) before an exception is thrown.
 *     *   `System.out`: Used throughout `WarehouseSystem` and `Warehouse` for displaying prompts, help messages, success messages, inventory status, and pending orders.
 *     *   Class-wide exception handling with `try-catch`: A large `try-catch` block is wrapped around the `switch` statement in the `main` method. This block catches specific exceptions (`IllegalArgumentException`, `IllegalStateException`, `InsufficientInventoryException`) that might be thrown by the `Warehouse` methods, providing a centralized point for error reporting using `System.err`. A general `catch (Exception e)` is included as a fallback for unexpected errors.
 * 
 * 3.  **Best Practices:**
 *     *   **Encapsulation:** Fields in `Item`, `Order`, and `Warehouse` are private, accessed via public methods.
 *     *   **Meaningful Names:** Variable and method names (`pendingOrders`, `processNextOrder`, `findInventoryItem`, `InsufficientInventoryException`, `viewInventory`) clearly indicate their purpose.
 *     *   **Comments and Documentation:** Javadoc comments are provided for classes and public methods, explaining their purpose, parameters, and return values. Inline comments clarify complex logic, particularly in `processNextOrder` and the command parsing in `main`.
 *     *   **Input Validation:** The `add` command parsing in `main` checks for correct format and uses `try-catch` for `NumberFormatException`. The `addOrder` method in `Warehouse` validates item existence and positive quantities.
 *     *   **Error Handling:** Specific exceptions are used (`IllegalArgumentException` for bad input, `IllegalStateException` for invalid system state like empty queue, `InsufficientInventoryException` for stock issues). Errors are reported to `System.err`.
 *     *   **Clean Code Structure:** The system is modularized into classes with single responsibilities. The `main` method focuses on interaction and error handling, delegating core logic to the `Warehouse` class.
 * 
 * 4.  **Complexity and Realism:** The system simulates a realistic FIFO order processing workflow. The `processNextOrder` method introduces complexity by requiring a check-then-update logic across multiple items and handling the case where an order fails due to insufficient stock (leaving it in the queue). The `add` command parsing requires handling variable arguments and potential format errors. The custom exception adds another layer to the error handling strategy.
 * 
 * This solution effectively integrates the required Java components into a functional system, demonstrating understanding of data structures, object-oriented principles, and robust error handling.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;

/**
 * Represents an item with a name and quantity.
 */
class Item {
    private String name;
    private int quantity;

    /**
     * Constructs an Item.
     * @param name The name of the item.
     * @param quantity The quantity of the item.
     */
    public Item(String name, int quantity) {
        this.name = name;
        this.quantity = quantity;
    }

    /**
     * Gets the item name.
     * @return The name.
     */
    public String getName() {
        return name;
    }

    /**
     * Gets the item quantity.
     * @return The quantity.
     */
    public int getQuantity() {
        return quantity;
    }

    /**
     * Sets the item quantity. Used for updating inventory.
     * @param quantity The new quantity.
     */
    public void setQuantity(int quantity) {
        this.quantity = quantity;
    }

    @Override
    public String toString() {
        return name + " (" + quantity + ")";
    }
}

/**
 * Represents a customer order containing a list of items.
 */
class Order {
    private int orderId;
    private List<Item> items; // List of items requested in this specific order

    /**
     * Constructs an Order.
     * @param orderId The unique ID for the order.
     * @param items The list of items and quantities in the order.
     */
    public Order(int orderId, List<Item> items) {
        this.orderId = orderId;
        // Create a new list to hold the order items to avoid external modifications
        this.items = new ArrayList<>(items);
    }

    /**
     * Gets the order ID.
     * @return The order ID.
     */
    public int getOrderId() {
        return orderId;
    }

    /**
     * Gets the list of items in the order.
     * @return The list of items.
     */
    public List<Item> getItems() {
        return items; // Return the list of items in the order
    }

    @Override
    public String toString() {
        return "Order ID " + orderId + ", Items: " + items;
    }
}

/**
 * Custom exception for insufficient inventory during order processing.
 */
class InsufficientInventoryException extends Exception {
    /**
     * Constructs an InsufficientInventoryException.
     * @param message The detail message.
     */
    public InsufficientInventoryException(String message) {
        super(message);
    }
}

/**
 * Manages the warehouse inventory and pending orders.
 */
class Warehouse {
    // Using ArrayList for inventory as we need quick iteration/search by name
    private List<Item> inventory = new ArrayList<>();
    // Using LinkedList which implements Queue for FIFO order processing
    private Queue<Order> pendingOrders = new LinkedList<>();
    private int nextOrderId = 1; // Counter for unique order IDs

    /**
     * Constructs a Warehouse and initializes inventory.
     */
    public Warehouse() {
        // Add initial inventory items
        inventory.add(new Item("Laptop", 10));
        inventory.add(new Item("Mouse", 50));
        inventory.add(new Item("Keyboard", 30));
        inventory.add(new Item("Monitor", 15));
        System.out.println("Warehouse initialized with starting inventory.");
    }

    /**
     * Finds an item in the inventory by name (case-insensitive).
     * @param itemName The name of the item to find.
     * @return The Item object if found, otherwise null.
     */
    private Item findInventoryItem(String itemName) {
        for (Item item : inventory) {
            if (item.getName().equalsIgnoreCase(itemName)) {
                return item;
            }
        }
        return null; // Item not found
    }

    /**
     * Adds a new order to the pending orders queue.
     * Performs validation to ensure items exist and quantities are positive.
     * @param orderItems The list of items and quantities for the new order.
     * @throws IllegalArgumentException if the order is empty, contains unknown items, or has non-positive quantities.
     */
    public void addOrder(List<Item> orderItems) throws IllegalArgumentException {
        if (orderItems == null || orderItems.isEmpty()) {
            throw new IllegalArgumentException("Order cannot be empty.");
        }

        // Validate items and quantities before creating the order
        for (Item orderItem : orderItems) {
            if (orderItem == null || orderItem.getName() == null || orderItem.getName().trim().isEmpty()) {
                 throw new IllegalArgumentException("Order contains an invalid item entry.");
            }
            if (findInventoryItem(orderItem.getName()) == null) {
                // Use System.err for user-facing error related to input
                System.err.println("Error: Item '" + orderItem.getName() + "' not found in inventory. Order not added.");
                throw new IllegalArgumentException("Item '" + orderItem.getName() + "' not found in inventory.");
            }
            if (orderItem.getQuantity() <= 0) {
                 System.err.println("Error: Item quantity must be positive for '" + orderItem.getName() + "'. Order not added.");
                 throw new IllegalArgumentException("Item quantity must be positive for '" + orderItem.getName() + "'.");
            }
        }

        // If validation passes, create and add the order
        Order newOrder = new Order(nextOrderId++, orderItems);
        pendingOrders.offer(newOrder); // Add to the end of the queue
        System.out.println("Order " + newOrder.getOrderId() + " added to the queue.");
    }

    /**
     * Attempts to process the next order in the queue (FIFO).
     * Checks inventory availability before processing.
     * @throws IllegalStateException if there are no pending orders.
     * @throws InsufficientInventoryException if there is not enough inventory for the order.
     */
    public void processNextOrder() throws IllegalStateException, InsufficientInventoryException {
        // Peek the order to inspect it without removing it yet
        Order orderToProcess = pendingOrders.peek();

        if (orderToProcess == null) {
            throw new IllegalStateException("No pending orders to process.");
        }

        System.out.println("Attempting to process Order " + orderToProcess.getOrderId() + "...");

        // --- First Pass: Check if sufficient inventory exists for ALL items ---
        for (Item orderItem : orderToProcess.getItems()) {
            Item inventoryItem = findInventoryItem(orderItem.getName());

            // This case indicates a logic error or external modification if addOrder validated correctly
            if (inventoryItem == null) {
                 // Report as a critical error since inventory state is inconsistent
                 System.err.println("Critical Error: Item '" + orderItem.getName() + "' in order " + orderToProcess.getOrderId() + " not found in inventory during processing check.");
                 // Decide whether to fail processing or skip item. Failing the order is safer.
                 throw new IllegalStateException("Inventory item for order " + orderToProcess.getOrderId() + " disappeared.");
            }

            if (inventoryItem.getQuantity() < orderItem.getQuantity()) {
                // Use custom exception for insufficient stock scenario
                throw new InsufficientInventoryException("Insufficient inventory for item '" + orderItem.getName() + "'. Needed: " + orderItem.getQuantity() + ", Available: " + inventoryItem.getQuantity() + ". Order not processed.");
            }
        }

        // --- Second Pass: If checks passed, update inventory and remove order ---
        // Only update inventory if ALL items have sufficient stock
        for (Item orderItem : orderToProcess.getItems()) {
             Item inventoryItem = findInventoryItem(orderItem.getName());
             // Defensive check, should not be null here based on first pass
             if (inventoryItem != null) {
                 inventoryItem.setQuantity(inventoryItem.getQuantity() - orderItem.getQuantity());
             } else {
                 // Should not happen, but log if it does
                 System.err.println("Internal Error: Inventory item '" + orderItem.getName() + "' was found in first pass but not second for order " + orderToProcess.getOrderId());
             }
        }

        // Remove the order from the front of the queue
        pendingOrders.poll();
        System.out.println("Order " + orderToProcess.getOrderId() + " processed successfully.");
    }

    /**
     * Displays the current inventory levels to System.out.
     */
    public void viewInventory() {
        System.out.println("\n--- Current Inventory ---");
        if (inventory.isEmpty()) {
            System.out.println("Inventory is empty.");
        } else {
            for (Item item : inventory) {
                System.out.println(item.getName() + ": " + item.getQuantity());
            }
        }
        System.out.println("-------------------------");
    }

    /**
     * Displays the pending orders in the queue to System.out.
     */
    public void viewPendingOrders() {
        System.out.println("\n--- Pending Orders ---");
        if (pendingOrders.isEmpty()) {
            System.out.println("No pending orders.");
        } else {
            // Iterate through the queue without removing elements
            int count = 1;
            for (Order order : pendingOrders) {
                System.out.println("Order " + count + " (ID " + order.getOrderId() + "): " + order.getItems());
                count++;
            }
        }
        System.out.println("----------------------");
    }
}

/**
 * Main class to run the Warehouse Order Fulfillment System.
 * Handles user interaction and command processing.
 */
public class WarehouseSystem {

    /**
     * Main method to start the application.
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        Warehouse warehouse = new Warehouse();
        Scanner scanner = new Scanner(System.in);

        System.out.println("--- Warehouse Order Fulfillment System ---");
        printHelp();

        boolean running = true;
        while (running) {
            System.out.print("\nEnter command: ");
            String commandLine = scanner.nextLine().trim();
            String[] parts = commandLine.split("\\s+");
            String command = parts.length > 0 ? parts[0].toLowerCase() : "";

            // Class-wide exception handling for operations triggered by commands
            try {
                switch (command) {
                    case "add":
                        // Expected format: add item1 quantity1 item2 quantity2 ...
                        if (parts.length < 3 || parts.length % 2 == 0) {
                            System.err.println("Invalid 'add' command format. Use: add item1 quantity1 [item2 quantity2 ...]");
                        } else {
                            List<Item> orderItems = new ArrayList<>();
                            boolean parseError = false;
                            // Parse item-quantity pairs from command line arguments
                            for (int i = 1; i < parts.length; i += 2) {
                                String itemName = parts[i];
                                try {
                                    int quantity = Integer.parseInt(parts[i+1]);
                                    orderItems.add(new Item(itemName, quantity));
                                } catch (NumberFormatException e) {
                                    // Report invalid quantity format using System.err
                                    System.err.println("Error: Invalid quantity '" + parts[i+1] + "' for item '" + itemName + "'. Quantity must be a number.");
                                    parseError = true; // Mark that parsing failed
                                    break; // Stop processing this command line further
                                }
                            }
                            // Only attempt to add order if all item-quantity pairs were parsed successfully
                            if (!parseError) {
                                // Call warehouse method, potential exceptions handled by surrounding try-catch
                                warehouse.addOrder(orderItems);
                            }
                        }
                        break;

                    case "process":
                        // Call warehouse method, potential exceptions handled by surrounding try-catch
                        warehouse.processNextOrder();
                        break;

                    case "inventory":
                        warehouse.viewInventory();
                        break;

                    case "orders":
                        warehouse.viewPendingOrders();
                        break;

                    case "help":
                        printHelp();
                        break;

                    case "exit":
                        running = false;
                        System.out.println("Exiting system. Goodbye!");
                        break;

                    case "": // Handle empty input line
                         break;

                    default:
                        // Report unknown command using System.err
                        System.err.println("Unknown command: '" + command + "'. Type 'help' for commands.");
                        break;
                }
            } catch (IllegalArgumentException | IllegalStateException | InsufficientInventoryException e) {
                // Catch specific exceptions thrown by Warehouse methods
                // Report user-friendly error message using System.err
                System.err.println("Operation failed: " + e.getMessage());
            } catch (Exception e) {
                // Catch any other unexpected exceptions during command processing
                System.err.println("An unexpected error occurred: " + e.getMessage());
                e.printStackTrace(); // Print stack trace for debugging unexpected errors
            }
        }

        scanner.close(); // Close the scanner when the system exits
        System.out.println("Scanner closed.");
    }

    /**
     * Prints the list of available commands to System.out.
     */
    private static void printHelp() {
        System.out.println("\nAvailable commands:");
        System.out.println("  add <item1> <quantity1> [<item2> <quantity2> ...] - Add a new order to the queue");
        System.out.println("  process                                        - Process the next order in the queue");
        System.out.println("  inventory                                      - View current inventory levels");
        System.out.println("  orders                                         - View pending orders in the queue");
        System.out.println("  help                                           - Display this help message");
        System.out.println("  exit                                           - Exit the system");
    }
}
