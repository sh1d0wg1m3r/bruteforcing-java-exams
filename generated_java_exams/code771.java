/*
 * Exam Question #771
 * Generated on: 2025-05-12 16:38:27
 * Generated by: Account 1
 * 
 * QUESTION:
 * ## Advanced Java Programming Exam Task: Restaurant Order Management System
 * 
 * **Scenario:**
 * 
 * You are tasked with developing a simplified command-line application for a restaurant to manage customer orders. Waitstaff add new orders to a queue, and the kitchen processes orders from the front of the queue. The system should keep track of both pending and completed orders.
 * 
 * **Requirements:**
 * 
 * Implement a Java application named `RestaurantSystem` that meets the following requirements:
 * 
 * 1.  **Data Structures:**
 *     *   Use a `java.util.Queue` to store orders that are waiting to be processed by the kitchen (`pendingOrders`).
 *     *   Use a `java.util.List` (specifically, an `java.util.ArrayList`) to store orders that have been completed (`completedOrders`).
 *     *   Maintain a predefined list of available menu items.
 * 
 * 2.  **Core Functionality (Menu-driven):**
 *     *   Provide a text-based menu to the user (waitstaff/kitchen staff).
 *     *   Use a `java.util.Scanner` to read user input for menu choices and order details.
 *     *   Use a `switch` statement to handle the different menu options.
 *     *   Implement the following menu options:
 *         *   **1. Add New Order:**
 *             *   Prompt for a unique order ID.
 *             *   Allow the user to add multiple items to the order by entering the item name and quantity.
 *             *   Validate that the entered item name exists in the predefined menu. If not, display an error and prompt again or skip the item.
 *             *   Validate that the quantity is a positive integer.
 *             *   Calculate the total price for the order.
 *             *   Add the completed `Order` object to the `pendingOrders` queue.
 *         *   **2. View Pending Orders:**
 *             *   Display the details of all orders currently in the `pendingOrders` queue, showing their position (e.g., 1st, 2nd, etc.).
 *             *   Indicate if there are no pending orders.
 *         *   **3. Process Next Order:**
 *             *   Take the order at the front of the `pendingOrders` queue (FIFO).
 *             *   Move this order to the `completedOrders` list.
 *             *   Display a confirmation message including the processed order ID.
 *             *   Handle the case where the `pendingOrders` queue is empty.
 *         *   **4. View Completed Orders:**
 *             *   Display the details of all orders in the `completedOrders` list.
 *             *   Indicate if there are no completed orders.
 *         *   **5. Exit:** Terminate the application.
 * 
 * 3.  **Error Handling and Output:**
 *     *   Use `System.out` for displaying the menu, prompts, order details, and success messages.
 *     *   Use `System.err` for displaying all error messages (e.g., invalid menu choice, item not found, invalid quantity, empty queue/list operations, invalid input format).
 *     *   Implement class-wide exception handling using `try-catch` block(s) to gracefully handle potential runtime errors, particularly those related to user input parsing (`InputMismatchException`, `NumberFormatException`) or unexpected issues.
 * 
 * 4.  **Object-Oriented Design & Best Practices:**
 *     *   Create appropriate classes (`MenuItem`, `OrderItem`, `Order`) with private fields and public methods (getters, potentially methods for calculations like total price).
 *     *   Ensure proper encapsulation.
 *     *   Use meaningful variable and method names.
 *     *   Include comments to explain complex logic or important sections.
 *     *   Implement input validation as described in requirement 2.
 *     *   Manage resources properly (e.g., close the `Scanner`).
 * 
 * **Expected Output:**
 * 
 * The application should run interactively. Output should clearly distinguish between normal information (`System.out`) and errors (`System.err`). The format of displaying orders (pending or completed) should be clear, showing the order ID, items, and total amount.
 * 
 * **Example Interaction Snippet:**
 * 
 * ```
 * --- Restaurant Order System Menu ---
 * 1. Add New Order
 * 2. View Pending Orders
 * 3. Process Next Order
 * 4. View Completed Orders
 * 5. Exit
 * ------------------------------------
 * Enter your choice: 1
 * --- Add New Order ---
 * Enter Order ID: 101
 * Enter item name (or type 'done' to finish): Burger
 * Enter quantity for Burger: 2
 * Enter item name (or type 'done' to finish): Fries
 * Enter quantity for Fries: 1
 * Enter item name (or type 'done' to finish): Soda
 * Enter quantity for Soda: 3
 * Enter item name (or type 'done' to finish): done
 * Order #101 added to the pending queue.
 * 
 * --- Restaurant Order System Menu ---
 * ...
 * Enter your choice: 2
 * --- Pending Orders ---
 * Position 1:
 * --- Order #101 ---
 *   2 x Burger ($17.98)
 *   1 x Fries ($3.49)
 *   3 x Soda ($5.97)
 * Total: $27.44
 * 
 * --- Restaurant Order System Menu ---
 * ...
 * Enter your choice: 3
 * --- Processing Next Order ---
 * Order #101 processed and moved to completed orders.
 * 
 * --- Restaurant Order System Menu ---
 * ...
 * Enter your choice: 4
 * --- Completed Orders ---
 * --- Order #101 ---
 *   2 x Burger ($17.98)
 *   1 x Fries ($3.49)
 *   3 x Soda ($5.97)
 * Total: $27.44
 * --------------------
 * 
 * --- Restaurant Order System Menu ---
 * ...
 * Enter your choice: 6
 * Invalid choice. Please enter a number between 1 and 5.
 * 
 * --- Restaurant Order System Menu ---
 * ...
 * Enter your choice: process
 * Invalid input. Please enter a number.
 * 
 * --- Restaurant Order System Menu ---
 * ...
 * Enter your choice: 3
 * --- Processing Next Order ---
 * No pending orders to process.
 * 
 * --- Restaurant Order System Menu ---
 * ...
 * Enter your choice: 5
 * Exiting Restaurant System. Goodbye!
 * ```
 * 
 * Your solution should be a single Java file containing all necessary classes.
 *
 * EXPLANATION:
 * This solution implements a simple restaurant order management system demonstrating the required Java concepts.
 * 
 * 1.  **`java.util.Queue`:** The `pendingOrders` field is declared as a `Queue<Order>` and initialized with a `LinkedList` (`new LinkedList<>()`). `LinkedList` is a common implementation of the `Queue` interface that supports FIFO operations efficiently.
 *     *   `pendingOrders.offer(newOrder);` is used to add a new order to the tail of the queue when an order is completed by the waitstaff.
 *     *   `pendingOrders.poll();` is used by the kitchen (`processNextOrder`) to retrieve and remove the order at the head of the queue (the next one to be processed).
 *     *   `pendingOrders.isEmpty();` is used to check if there are any orders waiting.
 * 
 * 2.  **`java.util.ArrayList`:** The `completedOrders` field is declared as a `List<Order>` and explicitly initialized as an `ArrayList` (`new ArrayList<>()`). Inside the `Order` class, the `items` field is also declared as `List<OrderItem>` and initialized as an `ArrayList`.
 *     *   `completedOrders.add(nextOrder);` is used to add an order to the list of completed orders after it's processed from the queue.
 *     *   `newOrder.items = new ArrayList<>();` demonstrates the use of `ArrayList` as the specific implementation for the list of items within an order.
 *     *   Iteration is used (`for (Order order : completedOrders)`) to display completed orders.
 * 
 * 3.  **`java.util.List` interface:** The `completedOrders` field, the `menu` field, and the `items` field within the `Order` class are all declared using the `List` interface (`List<Order>`, `List<MenuItem>`, `List<OrderItem>`). This demonstrates coding to the interface rather than the specific implementation (`ArrayList` or `LinkedList`), which is a best practice for flexibility.
 * 
 * 4.  **`java.util.Scanner`:** A `Scanner` object is used (`new Scanner(System.in)`) within a `try-with-resources` block in the `run()` method to read user input from the console (`System.in`). Methods like `hasNextInt()`, `nextInt()`, and `nextLine()` are used to handle different types of input. The `try-with-resources` ensures the `Scanner` is closed automatically, preventing resource leaks.
 * 
 * 5.  **`switch` statement:** A `switch` statement in the `run()` method is used to control the program flow based on the integer choice entered by the user from the main menu. Each case corresponds to a specific action (add order, view queue, process, view completed, exit).
 * 
 * 6.  **`System.err`:** `System.err.println()` is used specifically for outputting error messages. This includes invalid menu choices, incorrect input types (caught by `hasNextInt()`), item not found errors during order creation, invalid quantity or ID input, and messages indicating that the pending queue is empty when trying to process an order.
 * 
 * 7.  **`System.out`:** `System.out.println()` and `System.out.print()` are used for all normal program output, such as displaying the menu, prompting the user for input, showing order details (pending and completed), confirming actions (like adding or processing an order), and the exit message.
 * 
 * 8.  **Class-wide exception handling with `try-catch`:** A `try-catch(Exception e)` block is placed around the main `while` loop in the `run()` method. This provides a broad safety net to catch any unexpected `Exception` that might occur during the program's execution and print an error message to `System.err`, preventing the program from crashing abruptly. Specific input validation within `addOrder` also uses `if/else` with `hasNextInt()` to manage expected input format issues gracefully, often coupled with `System.err` messages.
 * 
 * **Best Practices:**
 * 
 * *   **Encapsulation:** Classes like `MenuItem`, `OrderItem`, and `Order` have their fields declared as `private`, and access is provided through public getter methods. The `RestaurantSystem` class's data structures are also private.
 * *   **Meaningful Names:** Variable names (`pendingOrders`, `completedOrders`, `orderId`, `quantity`, `menuItem`) and method names (`addOrder`, `processNextOrder`, `viewPendingOrders`, `findMenuItem`) are descriptive and indicate their purpose.
 * *   **Comments:** Comments are included to explain the purpose of classes, methods, specific code blocks (like where required components are used), and important logic sections.
 * *   **Input Validation:** Checks are performed to ensure menu choices are within range, order IDs and quantities are positive integers, and item names exist in the menu. Error messages are provided via `System.err` when validation fails.
 * *   **Error Handling:** Specific error conditions (empty queue, item not found, invalid input format) are handled with explicit checks and `System.err` messages. The broad `try-catch` provides a fallback for unforeseen errors.
 * *   **Clean Code Structure:** The code is organized into separate classes with clear responsibilities (`MenuItem` for menu item data, `OrderItem` for item within an order, `Order` for the order details, `RestaurantSystem` for managing the system logic and user interaction). Methods are kept relatively short and focused.
 * 
 * This solution effectively integrates all the required Java components within a practical, menu-driven application, demonstrating understanding of data structures, control flow, input/output, error handling, and object-oriented principles.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.InputMismatchException;
import java.util.NoSuchElementException; // Although not explicitly required to catch, poll returns null

// Represents a single item on the restaurant menu
class MenuItem {
    private String name;
    private double price;

    public MenuItem(String name, double price) {
        this.name = name;
        this.price = price;
    }

    public String getName() {
        return name;
    }

    public double getPrice() {
        return price;
    }

    @Override
    public String toString() {
        return name + " ($" + String.format("%.2f", price) + ")";
    }
}

// Represents a specific item added to an order (includes quantity)
class OrderItem {
    private MenuItem menuItem;
    private int quantity;

    public OrderItem(MenuItem menuItem, int quantity) {
        this.menuItem = menuItem;
        this.quantity = quantity;
    }

    public MenuItem getMenuItem() {
        return menuItem;
    }

    public int getQuantity() {
        return quantity;
    }

    // Calculates the subtotal for this item based on quantity and price
    public double getSubtotal() {
        return menuItem.getPrice() * quantity;
    }

    @Override
    public String toString() {
        return quantity + " x " + menuItem.getName() + " ($" + String.format("%.2f", getSubtotal()) + ")";
    }
}

// Represents a customer order containing multiple OrderItems
class Order {
    private int orderId;
    // Required: Using List to hold OrderItems, implemented by ArrayList
    private List<OrderItem> items;
    private double totalAmount;

    public Order(int orderId) {
        this.orderId = orderId;
        // Required: Using ArrayList as the implementation for the List of items
        this.items = new ArrayList<>();
        this.totalAmount = 0.0; // Initialize total
    }

    public int getOrderId() {
        return orderId;
    }

    public List<OrderItem> getItems() {
        return items;
    }

    // Adds an item to the order and recalculates the total
    public void addItem(OrderItem item) {
        this.items.add(item);
        calculateTotal(); // Recalculate total when item is added
    }

    // Calculates the total amount for the order
    private void calculateTotal() {
        this.totalAmount = items.stream().mapToDouble(OrderItem::getSubtotal).sum();
    }

    public double getTotalAmount() {
        return totalAmount;
    }

    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        sb.append("--- Order #").append(orderId).append(" ---\n");
        if (items.isEmpty()) {
            sb.append("  (No items)");
        } else {
            for (OrderItem item : items) {
                sb.append("  ").append(item).append("\n");
            }
        }
        sb.append("Total: $").append(String.format("%.2f", totalAmount));
        return sb.toString();
    }
}

// Main class for the Restaurant Order Management System
public class RestaurantSystem {

    // Required: Queue for pending orders (FIFO)
    private Queue<Order> pendingOrders;
    // Required: List for completed orders (using ArrayList as implementation)
    private List<Order> completedOrders;
    // List of available menu items
    private List<MenuItem> menu;

    public RestaurantSystem() {
        // Initialize Queue using LinkedList (common Queue implementation)
        this.pendingOrders = new LinkedList<>();
        // Initialize List using ArrayList
        this.completedOrders = new ArrayList<>();
        // Initialize the predefined menu
        this.menu = initializeMenu();
    }

    // Helper method to create initial menu items
    private List<MenuItem> initializeMenu() {
        List<MenuItem> menuList = new ArrayList<>(); // Using ArrayList for the menu list
        menuList.add(new MenuItem("Burger", 8.99));
        menuList.add(new MenuItem("Pizza", 12.50));
        menuList.add(new MenuItem("Fries", 3.49));
        menuList.add(new MenuItem("Soda", 1.99));
        menuList.add(new MenuItem("Salad", 7.80));
        menuList.add(new MenuItem("Pasta", 10.00));
        return menuList;
    }

    // Helper method to find a MenuItem by name (case-insensitive)
    private MenuItem findMenuItem(String name) {
        for (MenuItem item : menu) {
            if (item.getName().equalsIgnoreCase(name.trim())) {
                return item;
            }
        }
        return null; // Item not found
    }

    // Main application loop
    public void run() {
        // Required: Scanner for user input, using try-with-resources for automatic closing
        try (Scanner scanner = new Scanner(System.in)) {
            int choice = -1;
            // Required: Class-wide exception handling with try-catch
            // This try block catches potential exceptions during the main loop execution
            try {
                while (choice != 5) {
                    printMenu();
                    System.out.print("Enter your choice: ");

                    // Input validation for menu choice
                    if (scanner.hasNextInt()) {
                        choice = scanner.nextInt();
                        scanner.nextLine(); // Consume newline character after reading int

                        // Required: Switch statement for flow control based on menu choice
                        switch (choice) {
                            case 1:
                                addOrder(scanner);
                                break;
                            case 2:
                                viewPendingOrders();
                                break;
                            case 3:
                                processNextOrder();
                                break;
                            case 4:
                                viewCompletedOrders();
                                break;
                            case 5:
                                // Required: System.out for normal output
                                System.out.println("Exiting Restaurant System. Goodbye!");
                                break;
                            default:
                                // Required: System.err for error messages
                                System.err.println("Invalid choice. Please enter a number between 1 and 5.");
                        }
                    } else {
                        // Handles non-integer input for the menu choice
                        // Required: System.err for error messages
                        System.err.println("Invalid input. Please enter a number.");
                        scanner.next(); // Consume the invalid input to prevent infinite loop
                    }
                    System.out.println(); // Add a blank line for readability between menu interactions
                }
            } catch (Exception e) {
                // Catches any unexpected runtime exceptions during the program's execution
                // Required: System.err for error messages
                System.err.println("An unexpected error occurred: " + e.getMessage());
                // Optionally print stack trace for debugging
                // e.printStackTrace(System.err);
            }
        } // Scanner is automatically closed here by try-with-resources
    }

    // Displays the main menu options
    private void printMenu() {
        // Required: System.out for normal output
        System.out.println("--- Restaurant Order System Menu ---");
        System.out.println("1. Add New Order");
        System.out.println("2. View Pending Orders");
        System.out.println("3. Process Next Order");
        System.out.println("4. View Completed Orders");
        System.out.println("5. Exit");
        System.out.println("------------------------------------");
    }

    // Handles the process of adding a new order
    private void addOrder(Scanner scanner) {
        System.out.println("--- Add New Order ---");
        int orderId = -1;
        boolean validId = false;
        while (!validId) {
             System.out.print("Enter Order ID: ");
             // Input validation for Order ID
             if (scanner.hasNextInt()) {
                 orderId = scanner.nextInt();
                 scanner.nextLine(); // Consume newline
                 if (orderId > 0) {
                     // Basic check for uniqueness (optional but good practice, omitted for exam simplicity)
                     // Check if orderId already exists in pending or completed lists
                     validId = true;
                 } else {
                     // Required: System.err for error messages
                     System.err.println("Order ID must be a positive number.");
                 }
             } else {
                 // Required: System.err for error messages
                 System.err.println("Invalid input. Please enter a valid integer for Order ID.");
                 scanner.next(); // Consume invalid input
             }
        }

        Order newOrder = new Order(orderId);

        boolean addingItems = true;
        // Loop to add multiple items to the order
        while (addingItems) {
            System.out.print("Enter item name (or type 'done' to finish): ");
            String itemName = scanner.nextLine().trim();

            if (itemName.equalsIgnoreCase("done")) {
                addingItems = false; // Exit item adding loop
                continue;
            }

            MenuItem menuItem = findMenuItem(itemName);

            if (menuItem == null) {
                // Required: System.err for error messages
                System.err.println("Item '" + itemName + "' not found on the menu.");
                // continue; // Loop back to ask for item name again
                System.out.println("Available items:");
                for(MenuItem item : menu) {
                    System.out.println("- " + item.getName());
                }
                 continue; // Loop back to ask for item name again
            }

            int quantity = -1;
            boolean validQuantity = false;
            while (!validQuantity) {
                System.out.print("Enter quantity for " + menuItem.getName() + ": ");
                // Input validation for quantity
                if (scanner.hasNextInt()) {
                    quantity = scanner.nextInt();
                    scanner.nextLine(); // Consume newline
                    if (quantity > 0) {
                        validQuantity = true;
                    } else {
                         // Required: System.err for error messages
                         System.err.println("Quantity must be a positive number.");
                    }
                } else {
                    // Required: System.err for error messages
                    System.err.println("Invalid input. Please enter a valid integer for quantity.");
                    scanner.next(); // Consume invalid input
                }
            }

            OrderItem orderItem = new OrderItem(menuItem, quantity);
            newOrder.addItem(orderItem); // Add item to the order's list of items
        }

        // Add the completed order to the pending queue if it has items
        if (!newOrder.getItems().isEmpty()) {
            // Required: Queue usage (offer) - Adds the order to the tail of the queue
            pendingOrders.offer(newOrder);
            // Required: System.out for normal output
            System.out.println("Order #" + orderId + " added to the pending queue.");
        } else {
             // Required: System.err for error messages
             System.err.println("Order #" + orderId + " has no items and was not added.");
        }
    }

    // Displays orders currently waiting in the pending queue
    private void viewPendingOrders() {
        System.out.println("--- Pending Orders ---");
        // Required: Queue usage (isEmpty and iteration)
        if (pendingOrders.isEmpty()) {
            // Required: System.out for normal output
            System.out.println("No pending orders.");
        } else {
            // Iterate through the queue for display. Note: Iteration order depends on implementation,
            // but LinkedList iterator respects insertion order (FIFO).
            int count = 1;
            for (Order order : pendingOrders) {
                 // Required: System.out for normal output
                System.out.println("Position " + count + ":\n" + order);
                count++;
            }
        }
    }

    // Processes the next order from the front of the queue
    private void processNextOrder() {
        System.out.println("--- Processing Next Order ---");
        // Required: Queue usage (poll) - Retrieves and removes the head of the queue
        Order nextOrder = pendingOrders.poll();

        if (nextOrder == null) {
            // Handles the case where the queue is empty
            // Required: System.err for error messages
            System.err.println("No pending orders to process.");
        } else {
            // Required: List usage (add) - Adds the processed order to the completed list
            completedOrders.add(nextOrder);
            // Required: System.out for normal output
            System.out.println("Order #" + nextOrder.getOrderId() + " processed and moved to completed orders.");
        }
    }

    // Displays orders that have been completed
    private void viewCompletedOrders() {
        System.out.println("--- Completed Orders ---");
        // Required: List usage (isEmpty and iteration)
        if (completedOrders.isEmpty()) {
             // Required: System.out for normal output
            System.out.println("No completed orders.");
        } else {
            // Iterate through the list of completed orders
            for (Order order : completedOrders) {
                // Required: System.out for normal output
                System.out.println(order);
                System.out.println("--------------------"); // Separator for completed orders
            }
        }
    }

    // Main method to start the application
    public static void main(String[] args) {
        RestaurantSystem system = new RestaurantSystem();
        system.run(); // Start the main application loop
    }
}
