/*
 * Exam Question #758
 * Generated on: 2025-05-12 16:36:38
 * Generated by: Account 3
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Event Entry Queue Management
 * 
 * **Scenario:**
 * 
 * You are tasked with developing a simple console-based application for managing the entry queue for a specific event within an event management system. The system needs to list available events, allow the user to select an event to manage its queue, add attendees to the queue, and process attendees entering the event from the front of the queue.
 * 
 * **Requirements:**
 * 
 * Implement a Java program that fulfills the following requirements:
 * 
 * 1.  **Event and Attendee Representation:**
 *     *   Create a class `Event` with private fields: `id` (int), `name` (String), and `capacity` (int). Include a constructor and public getter methods for these fields.
 *     *   Create a class `Attendee` with private fields: `id` (int - can be generated or simple counter), and `name` (String). Include a constructor and public getter methods.
 * 
 * 2.  **Event Management Core Logic:**
 *     *   Create a class `EventManager` that contains the `main` method.
 *     *   Inside `EventManager`, maintain a `List<Event>` to store available events. Initialize this list with at least 3 sample events using an `ArrayList`.
 *     *   Maintain a `Queue<Attendee>` to manage the entry queue for the *currently selected* event. Use an appropriate implementation like `LinkedList`.
 *     *   Maintain a field `activeEvent` (type `Event`) to track which event's queue is currently being managed. Initialize it to `null`.
 * 
 * 3.  **User Interface:**
 *     *   Present a menu of options to the user using `System.out`:
 *         1.  List All Events
 *         2.  Select Event to Manage Queue
 *         3.  Join Queue (for selected event)
 *         4.  Process Entry (from selected event's queue)
 *         5.  Exit
 *     *   Use `Scanner` to read user input for menu choices, event IDs, and attendee names.
 *     *   Use a `switch` statement to handle the different menu options.
 * 
 * 4.  **Functionality Details:**
 *     *   **List All Events:** Iterate through the `List<Event>` and print details (ID, Name, Capacity) using `System.out`.
 *     *   **Select Event:** Prompt the user for an Event ID. Find the event in the `List<Event>`. If found, set it as the `activeEvent` and initialize/clear the `entryQueue` for this event. If not found, print an error message using `System.err`.
 *     *   **Join Queue:** If an `activeEvent` is selected:
 *         *   Prompt the user for the attendee's name.
 *         *   Create a new `Attendee` object (generate a simple ID).
 *         *   Check if the `entryQueue` size is less than the `activeEvent`'s capacity.
 *         *   If capacity allows, add the `Attendee` to the `entryQueue` using a Queue method (`offer` is recommended). Print a success message using `System.out`.
 *         *   If the queue is full, print an error message using `System.err`.
 *         *   If no `activeEvent` is selected, print an error message using `System.err`.
 *     *   **Process Entry:** If an `activeEvent` is selected:
 *         *   Check if the `entryQueue` is empty.
 *         *   If not empty, remove an `Attendee` from the front of the queue using a Queue method (`poll` is recommended). Print a success message (e.g., "Processing entry for Attendee: [Name]") using `System.out`.
 *         *   If the queue is empty, print an error message using `System.err`.
 *         *   If no `activeEvent` is selected, print an error message using `System.err`.
 *     *   **Exit:** Terminate the program.
 * 
 * 5.  **Error Handling and Best Practices:**
 *     *   Implement input validation. Use a `try-catch` block around the main menu loop (or critical input reading sections) to handle potential `InputMismatchException` (e.g., user enters text instead of a number). Print an error using `System.err` and handle the invalid input gracefully (e.g., clear the scanner buffer).
 *     *   Use `System.err` for all error messages and `System.out` for normal output (menu, lists, success messages).
 *     *   Ensure proper encapsulation (private fields, public getters).
 *     *   Use meaningful variable and method names.
 *     *   Include brief comments where necessary to explain complex logic.
 *     *   Close the `Scanner` resource when the program exits.
 * 
 * **Expected Output Example:**
 * 
 * ```
 * --- Event Management Menu ---
 * 1. List All Events
 * 2. Select Event to Manage Queue
 * 3. Join Queue (for selected event)
 * 4. Process Entry (from selected event's queue)
 * 5. Exit
 * Enter your choice: 1
 * --- Available Events ---
 * ID: 101, Name: Concert Night, Capacity: 5
 * ID: 102, Name: Tech Conference, Capacity: 10
 * ID: 103, Name: Art Exhibition, Capacity: 3
 * --------------------------
 * 
 * --- Event Management Menu ---
 * 1. List All Events
 * 2. Select Event to Manage Queue
 * 3. Join Queue (for selected event)
 * 4. Process Entry (from selected event's queue)
 * 5. Exit
 * Enter your choice: 2
 * Enter Event ID to manage queue: 102
 * Successfully selected event: Tech Conference. Queue reset.
 * 
 * --- Event Management Menu ---
 * 1. List All Events
 * 2. Select Event to Manage Queue
 * 3. Join Queue (for selected event)
 * 4. Process Entry (from selected event's queue)
 * 5. Exit
 * Enter your choice: 3
 * Enter Attendee Name: Alice
 * Alice added to the queue for Tech Conference. Queue size: 1/10
 * 
 * --- Event Management Menu ---
 * 1. List All Events
 * 2. Select Event to Manage Queue
 * 3. Join Queue (for selected event)
 * 4. Process Entry (from selected event's queue)
 * 5. Exit
 * Enter your choice: 3
 * Enter Attendee Name: Bob
 * Bob added to the queue for Tech Conference. Queue size: 2/10
 * 
 * --- Event Management Menu ---
 * 1. List All Events
 * 2. Select Event to Manage Queue
 * 3. Join Queue (for selected event)
 * 4. Process Entry (from selected event's queue)
 * 5. Exit
 * Enter your choice: 4
 * Processing entry for Attendee: Alice. Queue size: 1/10
 * 
 * --- Event Management Menu ---
 * 1. List All Events
 * 2. Select Event to Manage Queue
 * 3. Join Queue (for selected event)
 * 4. Process Entry (from selected event's queue)
 * 5. Exit
 * Enter your choice: 4
 * Processing entry for Attendee: Bob. Queue size: 0/10
 * 
 * --- Event Management Menu ---
 * 1. List All Events
 * 2. Select Event to Manage Queue
 * 3. Join Queue (for selected event)
 * 4. Process Entry (from selected event's queue)
 * 5. Exit
 * Enter your choice: 4
 * Error: Queue is empty for Tech Conference.
 * 
 * --- Event Management Menu ---
 * 1. List All Events
 * 2. Select Event to Manage Queue
 * 3. Join Queue (for selected event)
 * 4. Process Entry (from selected event's queue)
 * 5. Exit
 * Enter your choice: 6
 * Error: Invalid choice. Please enter a number between 1 and 5.
 * 
 * --- Event Management Menu ---
 * 1. List All Events
 * 2. Select Event to Manage Queue
 * 3. Join Queue (for selected event)
 * 4. Process Entry (from selected event's queue)
 * 5. Exit
 * Enter your choice: five
 * Error: Invalid input. Please enter a number.
 * 
 * --- Event Management Menu ---
 * ...
 * Enter your choice: 5
 * Exiting program.
 * ```
 * 
 * Your solution should be provided as a single Java file containing all necessary classes.
 *
 * EXPLANATION:
 * This solution implements a console-based Event Entry Queue Management system demonstrating the required Java concepts and best practices.
 * 
 * 1.  **Class Structure:**
 *     *   `Attendee` and `Event` classes are simple Plain Old Java Objects (POJOs) representing the core data entities. They use private fields and public getters, adhering to **encapsulation**.
 *     *   `EventManager` contains the main logic, including data storage (`events`, `entryQueue`, `activeEvent`) and the application flow (`run` method).
 * 
 * 2.  **Data Structures:**
 *     *   `List<Event> events`: A `List` interface variable is used to hold the collection of `Event` objects. The concrete implementation chosen is `ArrayList`, which is suitable for storing and iterating over a dynamic list of events. This fulfills the requirement for `List` and `ArrayList`.
 *     *   `Queue<Attendee> entryQueue`: A `Queue` interface variable is used to manage attendees waiting to enter the selected event. The `LinkedList` class is used as the concrete implementation. `LinkedList` implements both `List` and `Queue`, and its `Queue` methods (`offer`, `poll`, `peek`) provide efficient FIFO (First-In, First-Out) behavior, which is perfect for a queue of people waiting to enter. This fulfills the requirement for `Queue`.
 * 
 * 3.  **User Interaction:**
 *     *   `Scanner scanner`: An instance of `Scanner` is used throughout the `EventManager` class to read user input from the console (`System.in`). This fulfills the `Scanner` requirement.
 *     *   `displayMenu()`: A helper method prints the available options to the user using `System.out`.
 *     *   `System.out`: Used for all standard output, including the menu, listing events, and success messages.
 *     *   `System.err`: Used specifically for printing error messages, such as invalid input, event not found, queue full, or queue empty. This distinguishes errors from normal output as required.
 * 
 * 4.  **Control Flow:**
 *     *   The `run()` method contains a `while` loop that continues until the user chooses to exit (option 5).
 *     *   `switch (choice)`: A `switch` statement is used to direct the program's execution based on the integer input from the user, handling each menu option separately. This fulfills the `switch` requirement. The `default` case handles invalid integer choices.
 * 
 * 5.  **Functionality Implementation:**
 *     *   **List All Events:** Iterates through the `events` `List` and prints each `Event` object's details using its `toString()` method.
 *     *   **Select Event:** Prompts for an ID, iterates through the `events` `List` to find the matching `Event`. If found, it sets `activeEvent` and creates a *new*, empty `LinkedList` for `entryQueue`, effectively resetting the queue for the newly selected event.
 *     *   **Join Queue:** Checks if an `activeEvent` is selected. If so, it prompts for an attendee name, creates an `Attendee` object (using a simple static counter for unique IDs), checks the current `entryQueue.size()` against the `activeEvent.getCapacity()`. If there's space, `entryQueue.offer(newAttendee)` adds the attendee to the end of the queue.
 *     *   **Process Entry:** Checks if an `activeEvent` is selected. If so, it checks if the `entryQueue` is empty using `isEmpty()`. If not empty, `entryQueue.poll()` removes and returns the `Attendee` at the front of the queue.
 * 
 * 6.  **Error Handling:**
 *     *   `try-catch` blocks: A `try-catch` block wraps the core logic inside the `while` loop in the `run()` method. This provides **class-wide exception handling** for the main operation loop.
 *         *   `catch (InputMismatchException e)`: Specifically catches errors when `scanner.nextInt()` fails because the input was not an integer. It prints an error to `System.err` and, crucially, calls `scanner.nextLine()` to consume the invalid input from the buffer, preventing an infinite loop of error messages.
 *         *   `catch (Exception e)`: A general catch block is included to handle any other unexpected runtime exceptions that might occur during execution, printing a generic error message to `System.err`.
 *     *   Specific checks: The code also includes checks for logical errors, such as trying to join/process a queue when no event is selected, or trying to join a full queue, or processing an empty queue. These conditions trigger specific error messages printed to `System.err`.
 * 
 * 7.  **Best Practices:**
 *     *   Meaningful names (`events`, `entryQueue`, `activeEvent`, `listAllEvents`, `joinQueue`, etc.).
 *     *   Encapsulation (private fields with public getters).
 *     *   Comments explaining the purpose of classes, fields, and methods.
 *     *   Closing the `Scanner` resource (`scanner.close()`) when the application finishes to prevent resource leaks.
 *     *   Using `offer()` and `poll()` for the queue operations is generally preferred over `add()` and `remove()` because they return special values (`false`/`null`) instead of throwing exceptions in capacity-constrained or empty scenarios, making error checking cleaner.
 * 
 * This solution effectively integrates all required components into a functional program that simulates a practical scenario, while demonstrating good coding practices and robust error handling.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.InputMismatchException;

// Represents an Attendee
class Attendee {
    private static int attendeeCounter = 0; // Simple counter for unique IDs
    private int id;
    private String name;

    /**
     * Constructs an Attendee object.
     * @param name The name of the attendee.
     */
    public Attendee(String name) {
        this.id = ++attendeeCounter; // Assign a simple unique ID
        this.name = name;
    }

    // Getter for attendee ID
    public int getId() {
        return id;
    }

    // Getter for attendee name
    public String getName() {
        return name;
    }

    @Override
    public String toString() {
        return "Attendee{" +
               "id=" + id +
               ", name='" + name + '\'' +
               '}';
    }
}

// Represents an Event
class Event {
    private int id;
    private String name;
    private int capacity;

    /**
     * Constructs an Event object.
     * @param id The unique ID of the event.
     * @param name The name of the event.
     * @param capacity The maximum number of attendees the event can hold.
     */
    public Event(int id, String name, int capacity) {
        this.id = id;
        this.name = name;
        this.capacity = capacity;
    }

    // Getter for event ID
    public int getId() {
        return id;
    }

    // Getter for event name
    public String getName() {
        return name;
    }

    // Getter for event capacity
    public int getCapacity() {
        return capacity;
    }

    @Override
    public String toString() {
        return "ID: " + id + ", Name: " + name + ", Capacity: " + capacity;
    }
}

// Manages events and the active event's entry queue
public class EventManager {

    // List to hold all available events (using ArrayList as implementation)
    private List<Event> events;
    // Queue to manage attendees waiting for the active event (using LinkedList as implementation)
    private Queue<Attendee> entryQueue;
    // The event whose queue is currently being managed
    private Event activeEvent;
    // Scanner for user input
    private Scanner scanner;

    /**
     * Constructs an EventManager, initializes events, and prepares for input.
     */
    public EventManager() {
        // Initialize the list of events using ArrayList
        events = new ArrayList<>();
        // Add some sample events
        events.add(new Event(101, "Concert Night", 5));
        events.add(new Event(102, "Tech Conference", 10));
        events.add(new Event(103, "Art Exhibition", 3));

        // Queue will be initialized when an event is selected
        entryQueue = null;
        activeEvent = null;

        scanner = new Scanner(System.in);
    }

    /**
     * Displays the main menu options to the user.
     */
    private void displayMenu() {
        System.out.println("\n--- Event Management Menu ---");
        System.out.println("Currently Managing: " + (activeEvent != null ? activeEvent.getName() : "None Selected"));
        System.out.println("1. List All Events");
        System.out.println("2. Select Event to Manage Queue");
        System.out.println("3. Join Queue (for selected event)");
        System.out.println("4. Process Entry (from selected event's queue)");
        System.out.println("5. Exit");
        System.out.print("Enter your choice: ");
    }

    /**
     * Lists all available events.
     */
    private void listAllEvents() {
        System.out.println("--- Available Events ---");
        // Iterate through the List of events
        for (Event event : events) {
            System.out.println(event); // Uses Event.toString()
        }
        System.out.println("--------------------------");
    }

    /**
     * Allows the user to select an event to manage its queue.
     */
    private void selectEvent() {
        System.out.print("Enter Event ID to manage queue: ");
        try {
            int eventId = scanner.nextInt();
            // Consume the newline character left by nextInt()
            scanner.nextLine();

            Event foundEvent = null;
            // Iterate through the List to find the event by ID
            for (Event event : events) {
                if (event.getId() == eventId) {
                    foundEvent = event;
                    break;
                }
            }

            if (foundEvent != null) {
                activeEvent = foundEvent;
                // Initialize/clear the queue for the newly selected event
                entryQueue = new LinkedList<>(); // LinkedList implements Queue
                System.out.println("Successfully selected event: " + activeEvent.getName() + ". Queue reset.");
            } else {
                // Use System.err for error messages
                System.err.println("Error: Event with ID " + eventId + " not found.");
            }
        } catch (InputMismatchException e) {
            // Use System.err for error messages
            System.err.println("Error: Invalid input. Please enter a number.");
            // Clear the invalid input from the scanner buffer
            scanner.nextLine();
        }
    }

    /**
     * Allows an attendee to join the queue for the active event.
     */
    private void joinQueue() {
        if (activeEvent == null) {
            // Use System.err for error messages
            System.err.println("Error: No event selected. Please select an event first (Option 2).");
            return;
        }

        System.out.print("Enter Attendee Name: ");
        String attendeeName = scanner.nextLine();

        // Check if the queue is full based on event capacity
        if (entryQueue.size() < activeEvent.getCapacity()) {
            Attendee newAttendee = new Attendee(attendeeName);
            // Add attendee to the Queue using offer (returns false if failed, safer than add)
            if (entryQueue.offer(newAttendee)) {
                System.out.println(newAttendee.getName() + " added to the queue for " + activeEvent.getName() + ". Queue size: " + entryQueue.size() + "/" + activeEvent.getCapacity());
            } else {
                 // This case is unlikely with LinkedList unless memory is full, but good practice
                 System.err.println("Error: Failed to add attendee to the queue.");
            }
        } else {
            // Use System.err for error messages
            System.err.println("Error: Queue is full for " + activeEvent.getName() + ". Cannot add " + attendeeName + ".");
        }
    }

    /**
     * Processes the next attendee in the queue, simulating entry.
     */
    private void processEntry() {
         if (activeEvent == null) {
            // Use System.err for error messages
            System.err.println("Error: No event selected. Please select an event first (Option 2).");
            return;
        }

        // Check if the Queue is empty
        if (entryQueue.isEmpty()) {
            // Use System.err for error messages
            System.err.println("Error: Queue is empty for " + activeEvent.getName() + ". No one to process.");
        } else {
            // Remove and retrieve the head of the Queue using poll (returns null if empty)
            Attendee processedAttendee = entryQueue.poll();
            System.out.println("Processing entry for Attendee: " + processedAttendee.getName() + ". Queue size: " + entryQueue.size() + "/" + activeEvent.getCapacity());
        }
    }

    /**
     * Runs the main application loop.
     */
    public void run() {
        int choice = -1;
        while (choice != 5) {
            displayMenu();

            // Class-wide exception handling for input and potential runtime errors
            try {
                choice = scanner.nextInt();
                // Consume the newline character left by nextInt()
                scanner.nextLine();

                // Use a switch statement for flow control based on user choice
                switch (choice) {
                    case 1:
                        listAllEvents();
                        break;
                    case 2:
                        selectEvent();
                        break;
                    case 3:
                        joinQueue();
                        break;
                    case 4:
                        processEntry();
                        break;
                    case 5:
                        System.out.println("Exiting program.");
                        break;
                    default:
                        // Use System.err for error messages
                        System.err.println("Error: Invalid choice. Please enter a number between 1 and 5.");
                }
            } catch (InputMismatchException e) {
                // Handle cases where the user enters non-integer input
                System.err.println("Error: Invalid input. Please enter a number.");
                // Clear the invalid input from the scanner buffer to prevent infinite loop
                scanner.nextLine();
                choice = -1; // Reset choice to prevent accidental exit or invalid processing
            } catch (Exception e) {
                // Catch any other unexpected runtime exceptions
                System.err.println("An unexpected error occurred: " + e.getMessage());
                // e.printStackTrace(); // Uncomment for detailed debugging
            }
        }

        // Close the scanner resource
        scanner.close();
    }

    // Main method to start the application
    public static void main(String[] args) {
        EventManager manager = new EventManager();
        manager.run();
    }
}
