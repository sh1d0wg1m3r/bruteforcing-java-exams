/*
 * Exam Question #767
 * Generated on: 2025-05-12 16:37:47
 * Generated by: Account 5
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Task Management System
 * 
 * **Scenario:**
 * 
 * You are tasked with building a simple command-line application to manage tasks. The system should allow users to add new tasks, process the next task in a queue, view tasks that are pending, and view tasks that have been completed.
 * 
 * **Requirements:**
 * 
 * 1.  **Task Representation:** Create a `Task` class with the following attributes:
 *     *   `id` (int): A unique identifier for the task.
 *     *   `description` (String): A brief description of the task.
 *     *   `status` (String): The current status of the task (e.g., "Pending", "Completed").
 *     *   Implement appropriate getters and setters, and a `toString()` method for easy display. Ensure proper encapsulation (private fields).
 * 
 * 2.  **Task Management Logic:** Create a `TaskScheduler` class responsible for managing the collections of tasks.
 *     *   It must use a `java.util.Queue<Task>` to hold tasks that are pending processing.
 *     *   It must use a `java.util.List<Task>` to hold tasks that have been completed. The variable holding the completed tasks must be declared using the `List` interface type but initialized with a `java.util.ArrayList`.
 *     *   Implement methods:
 *         *   `addTask(String description)`: Creates a new `Task` with a unique ID and "Pending" status, and adds it to the pending queue.
 *         *   `processNextTask()`: Removes the next task from the pending queue, updates its status to "Completed", and adds it to the completed tasks list. This method should return the processed `Task` or indicate if no tasks were pending.
 *         *   `getPendingTasks()`: Returns a `List<Task>` of all tasks currently in the pending queue (without removing them).
 *         *   `getCompletedTasks()`: Returns the `List<Task>` of all completed tasks.
 * 
 * 3.  **User Interface:** Implement a command-line interface in a `main` method within a separate class (e.g., `TaskManagerApp`).
 *     *   Use `java.util.Scanner` to read user input.
 *     *   Present a menu of options to the user:
 *         1.  Add New Task
 *         2.  Process Next Task
 *         3.  View Pending Tasks
 *         4.  View Completed Tasks
 *         5.  Exit
 *     *   Use a `switch` statement to handle the user's menu choice.
 *     *   Use `System.out` for displaying the menu, prompts, and successful output (task details, lists).
 *     *   Use `System.err` for displaying all error messages (e.g., invalid menu choice, attempting to process when the queue is empty, invalid input type).
 * 
 * 4.  **Error Handling:**
 *     *   Implement input validation for the menu choice (ensure it's a valid integer and within the range of options).
 *     *   Handle potential exceptions, particularly `java.util.InputMismatchException` when reading the menu choice. Use a `try-catch` block that effectively wraps the input reading and processing logic within your main application loop.
 *     *   Handle the case where `processNextTask()` is called when the pending queue is empty. Report this error using `System.err`.
 * 
 * 5.  **Best Practices:**
 *     *   Adhere to Java naming conventions.
 *     *   Provide meaningful variable and method names.
 *     *   Include comments where necessary to explain complex logic.
 *     *   Ensure proper encapsulation in the `Task` and `TaskScheduler` classes.
 *     *   Manage resources properly (e.g., close the `Scanner`).
 * 
 * **Expected Output:**
 * 
 * Your program should interact with the user via the console. Examples of interactions include:
 * 
 * *   Displaying the menu.
 * *   Prompting for task description.
 * *   Confirming task addition.
 * *   Reporting which task was processed or if no tasks were pending.
 * *   Listing pending tasks.
 * *   Listing completed tasks.
 * *   Displaying error messages on `System.err` for invalid input or operational errors.
 * *   Exiting cleanly.
 * 
 * ```
 * --- Task Manager Menu ---
 * 1. Add New Task
 * 2. Process Next Task
 * 3. View Pending Tasks
 * 4. View Completed Tasks
 * 5. Exit
 * -------------------------
 * Enter your choice: 1
 * Enter task description: Write report
 * Task added: Task{id=1, description='Write report', status='Pending'}
 * 
 * --- Task Manager Menu ---
 * ...
 * Enter your choice: 1
 * Enter task description: Prepare presentation
 * Task added: Task{id=2, description='Prepare presentation', status='Pending'}
 * 
 * --- Task Manager Menu ---
 * ...
 * Enter your choice: 3
 * Pending Tasks:
 * Task{id=1, description='Write report', status='Pending'}
 * Task{id=2, description='Prepare presentation', status='Pending'}
 * 
 * --- Task Manager Menu ---
 * ...
 * Enter your choice: 2
 * Processed task: Task{id=1, description='Write report', status='Completed'}
 * 
 * --- Task Manager Menu ---
 * ...
 * Enter your choice: 3
 * Pending Tasks:
 * Task{id=2, description='Prepare presentation', status='Pending'}
 * 
 * --- Task Manager Menu ---
 * ...
 * Enter your choice: 4
 * Completed Tasks:
 * Task{id=1, description='Write report', status='Completed'}
 * 
 * --- Task Manager Menu ---
 * ...
 * Enter your choice: invalid_input
 * Invalid input. Please enter a number. (Output on System.err)
 * 
 * --- Task Manager Menu ---
 * ...
 * Enter your choice: 6
 * Invalid choice. Please enter a number between 1 and 5. (Output on System.err)
 * 
 * --- Task Manager Menu ---
 * ...
 * Enter your choice: 2
 * No pending tasks to process. (Output on System.err or System.out, depending on your design choice, but System.err is required for *errors*)
 * 
 * --- Task Manager Menu ---
 * ...
 * Enter your choice: 5
 * Exiting Task Manager.
 * ```
 * 
 * Your solution should consist of the `Task`, `TaskScheduler`, and `TaskManagerApp` classes (or similar structure) in a single code block.
 *
 * EXPLANATION:
 * This solution implements a simple Task Management System demonstrating the required Java concepts and best practices.
 * 
 * 1.  **`Task` Class:** This class represents a single task with an ID, description, and status. It follows encapsulation principles by having private fields and public getter/setter methods. The `toString()` method provides a convenient way to print task details.
 * 
 * 2.  **`TaskScheduler` Class:** This class manages the core logic and data structures.
 *     *   `pendingTasks`: A `Queue<Task>` is used (specifically a `LinkedList` which implements `Queue`). This is appropriate because tasks are processed in the order they are added (First-In, First-Out). `offer()` is used for adding and `poll()` for removing the head of the queue.
 *     *   `completedTasks`: A `List<Task>` is used (specifically initialized as an `ArrayList`). The variable is declared with the `List` interface type (`List<Task> completedTasks = new ArrayList<>();`), demonstrating polymorphism. `ArrayList` is suitable here as we primarily add to and iterate through the completed tasks.
 *     *   `nextTaskId`: A simple counter ensures each task gets a unique ID.
 *     *   Methods like `addTask`, `processNextTask`, `getPendingTasks`, and `getCompletedTasks` provide the interface for managing tasks, keeping the internal collection details hidden (encapsulation). `getPendingTasks` returns a *copy* to prevent external modification of the internal queue structure, while `getCompletedTasks` returns the list reference as modifying a completed list is less critical in this simple example.
 * 
 * 3.  **`TaskManagerApp` Class:** This class contains the `main` method and handles user interaction.
 *     *   `Scanner`: Used to read input from `System.in`.
 *     *   Menu and `switch`: A `while` loop keeps the application running, and a `switch` statement directs the program flow based on the user's integer choice.
 *     *   `System.out` and `System.err`: `System.out.println` is used for standard output like the menu, prompts, and task lists. `System.err.println` is explicitly used for error conditions, such as invalid menu input or attempting to process an empty queue, fulfilling a specific requirement.
 *     *   `try-catch`: A `try-catch` block is placed *inside* the main `while` loop, specifically around the input reading (`scanner.nextInt()`) and the subsequent `switch` logic. This allows the program to catch `InputMismatchException` (if the user enters non-integer input) or other potential exceptions during the processing of a command. Crucially, after catching `InputMismatchException`, `scanner.nextLine()` is called to consume the invalid input line, preventing an infinite loop. The loop continues after handling the error, allowing the user to try again. A general `Exception` catch is included as a fallback for other unexpected issues.
 *     *   Input Validation: The `switch` statement's `default` case handles menu choices outside the 1-5 range, and the `try-catch` handles non-integer input. Basic validation for task description emptiness is also included.
 *     *   Resource Management: The `scanner.close()` call in the `finally` block (or simply after the `while` loop finishes) ensures the `Scanner` resource is released.
 * 
 * This solution effectively integrates the required Java components (`Queue`, `ArrayList`, `List`, `Scanner`, `Switch`, `System.err`, `System.out`, `try-catch`) within a practical scenario, demonstrating object-oriented design, data structure usage, and robust error handling.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.InputMismatchException;

// Represents a single task
class Task {
    private int id;
    private String description;
    private String status; // e.g., "Pending", "Completed"

    public Task(int id, String description) {
        this.id = id;
        this.description = description;
        this.status = "Pending"; // Default status
    }

    // --- Getters ---
    public int getId() {
        return id;
    }

    public String getDescription() {
        return description;
    }

    public String getStatus() {
        return status;
    }

    // --- Setter for status ---
    public void setStatus(String status) {
        this.status = status;
    }

    @Override
    public String toString() {
        return "Task{id=" + id + ", description='" + description + "', status='" + status + "'}";
    }
}

// Manages the collection of tasks
class TaskScheduler {
    private Queue<Task> pendingTasks; // Queue for tasks waiting to be processed
    private List<Task> completedTasks; // List for tasks that have been completed
    private int nextTaskId; // Counter for assigning unique task IDs

    public TaskScheduler() {
        this.pendingTasks = new LinkedList<>(); // LinkedList implements Queue
        this.completedTasks = new ArrayList<>(); // ArrayList implements List
        this.nextTaskId = 1; // Start task IDs from 1
    }

    /**
     * Adds a new task to the pending queue.
     * @param description The description of the task.
     * @return The newly created task.
     */
    public Task addTask(String description) {
        Task newTask = new Task(nextTaskId++, description);
        pendingTasks.offer(newTask); // Use offer() for queue insertion
        return newTask;
    }

    /**
     * Processes the next task in the pending queue.
     * Moves the task from pending to completed list.
     * @return The processed task, or null if the pending queue is empty.
     */
    public Task processNextTask() {
        Task taskToProcess = pendingTasks.poll(); // Use poll() to retrieve and remove head
        if (taskToProcess != null) {
            taskToProcess.setStatus("Completed");
            completedTasks.add(taskToProcess); // Add to the completed list
        }
        return taskToProcess;
    }

    /**
     * Gets a list of tasks currently in the pending queue.
     * @return A List of pending tasks.
     */
    public List<Task> getPendingTasks() {
        // Return a new list containing pending tasks to avoid modifying the original queue
        return new ArrayList<>(pendingTasks);
    }

    /**
     * Gets a list of tasks that have been completed.
     * @return The List of completed tasks.
     */
    public List<Task> getCompletedTasks() {
        return completedTasks; // Return the list reference
    }
}

// Main application class with user interface
public class TaskManagerApp {

    private static void displayMenu() {
        System.out.println("\n--- Task Manager Menu ---");
        System.out.println("1. Add New Task");
        System.out.println("2. Process Next Task");
        System.out.println("3. View Pending Tasks");
        System.out.println("4. View Completed Tasks");
        System.out.println("5. Exit");
        System.out.println("-------------------------");
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in); // Scanner for user input
        TaskScheduler scheduler = new TaskScheduler(); // Task scheduler instance
        boolean running = true;

        // Class-wide exception handling using try-catch around the main loop logic
        while (running) {
            displayMenu();

            try {
                System.out.print("Enter your choice: ");
                // Read integer input - potential InputMismatchException
                int choice = scanner.nextInt();
                // Consume the rest of the line after reading the integer
                scanner.nextLine();

                // Use switch statement for flow control based on user choice
                switch (choice) {
                    case 1:
                        System.out.print("Enter task description: ");
                        String description = scanner.nextLine();
                        if (description == null || description.trim().isEmpty()) {
                            System.err.println("Task description cannot be empty.");
                        } else {
                            Task addedTask = scheduler.addTask(description.trim());
                            System.out.println("Task added: " + addedTask);
                        }
                        break;

                    case 2:
                        Task processedTask = scheduler.processNextTask();
                        if (processedTask != null) {
                            System.out.println("Processed task: " + processedTask);
                        } else {
                            // Use System.err for operational errors like empty queue
                            System.err.println("No pending tasks to process.");
                        }
                        break;

                    case 3:
                        List<Task> pending = scheduler.getPendingTasks();
                        System.out.println("Pending Tasks:");
                        if (pending.isEmpty()) {
                            System.out.println("  (None)");
                        } else {
                            for (Task task : pending) {
                                System.out.println("  " + task); // Use System.out for normal output
                            }
                        }
                        break;

                    case 4:
                        List<Task> completed = scheduler.getCompletedTasks();
                        System.out.println("Completed Tasks:");
                        if (completed.isEmpty()) {
                            System.out.println("  (None)");
                        } else {
                            for (Task task : completed) {
                                System.out.println("  " + task); // Use System.out for normal output
                            }
                        }
                        break;

                    case 5:
                        running = false;
                        System.out.println("Exiting Task Manager."); // Use System.out for normal exit message
                        break;

                    default:
                        // Use System.err for invalid user input outside expected range
                        System.err.println("Invalid choice. Please enter a number between 1 and 5.");
                        break;
                }
            } catch (InputMismatchException e) {
                // Use System.err for handling specific input type errors
                System.err.println("Invalid input. Please enter a number for the menu choice.");
                // Consume the incorrect input to prevent infinite loop
                scanner.nextLine();
            } catch (Exception e) {
                // Catch any other unexpected exceptions
                System.err.println("An unexpected error occurred: " + e.getMessage());
                // e.printStackTrace(); // Optional: useful for debugging during development/exam
            }
        }

        // Close the scanner resource
        scanner.close();
    }
}
