/*
 * Exam Question #1084
 * Generated on: 2025-05-12 17:22:41
 * Generated by: Account 4
 * 
 * QUESTION:
 * **Java Programming Exam Task: Simple Task Processing System**
 * 
 * **Scenario:**
 * You are tasked with developing a simple command-line application to manage tasks for a small team. The system should allow users to add new tasks to a queue for processing, process the next available task, view pending tasks, and view completed tasks.
 * 
 * **Requirements:**
 * 
 * 1.  **Task Representation:** Create a class named `Task` to represent a single task.
 *     *   It should have a unique integer ID and a String description.
 *     *   Implement appropriate encapsulation (private fields, public getters).
 *     *   Include a `toString()` method for easy printing of task details (e.g., "Task [ID]: [Description]").
 * 
 * 2.  **Task Management Logic:** Create a class named `TaskManager` that will handle the task queue and completed task list.
 *     *   Use a `java.util.Queue` (specifically, an implementation like `LinkedList` which implements `Queue`) to store pending tasks in a First-In, First-Out (FIFO) manner.
 *     *   Use a `java.util.List` (specifically, an `ArrayList` which implements `List`) to store completed tasks.
 *     *   Use `java.util.Scanner` to read user input from the console.
 *     *   Maintain a counter for assigning unique task IDs.
 * 
 * 3.  **User Interface:** The `TaskManager` class should have a method (e.g., `run()`) that provides a command-line interface.
 *     *   Display a menu of options to the user:
 *         1.  Add New Task
 *         2.  Process Next Task
 *         3.  View Pending Tasks
 *         4.  View Completed Tasks
 *         5.  Exit
 *     *   Read the user's menu choice using `Scanner`.
 *     *   Use a `switch` statement to handle the user's choice and call the appropriate methods.
 * 
 * 4.  **Core Functionality:**
 *     *   **Add New Task:** Prompt the user for a task description, create a `Task` object with a unique ID, and add it to the pending task queue.
 *     *   **Process Next Task:** Remove the task at the front of the pending queue. If a task is retrieved, move it to the completed tasks list and print a confirmation message using `System.out`. If the queue is empty, print an error message using `System.err`.
 *     *   **View Pending Tasks:** Iterate through and print all tasks currently in the pending queue using `System.out`.
 *     *   **View Completed Tasks:** Iterate through and print all tasks currently in the completed list using `System.out`.
 *     *   **Exit:** Terminate the program.
 * 
 * 5.  **Error Handling and Validation:**
 *     *   Implement input validation for the task description (e.g., ensure it's not empty). If invalid, print an error message to `System.err`.
 *     *   Implement class-wide exception handling using `try-catch` blocks within the main interaction loop (e.g., in the `run()` method) to catch potential issues like invalid menu input (non-integer) or other unexpected errors. Print a generic error message to `System.err` if an exception occurs.
 *     *   Use `System.out` for all normal output (menu, confirmations, task lists).
 *     *   Use `System.err` for all error messages (invalid input, empty queue, exceptions).
 * 
 * 6.  **Best Practices:**
 *     *   Use meaningful variable and method names.
 *     *   Add comments where necessary to explain complex logic.
 *     *   Ensure proper encapsulation in the `Task` and `TaskManager` classes.
 *     *   Maintain a clean code structure.
 * 
 * **Expected Output:**
 * The program should present a menu, accept user input, perform actions, and display results or errors appropriately.
 * 
 * Example Interaction:
 * 
 * ```
 * --- Task Management Menu ---
 * 1. Add New Task
 * 2. Process Next Task
 * 3. View Pending Tasks
 * 4. View Completed Tasks
 * 5. Exit
 * Enter your choice: 1
 * Enter task description: Write report
 * Task added: Task 1: Write report
 * 
 * --- Task Management Menu ---
 * 1. Add New Task
 * ...
 * Enter your choice: 1
 * Enter task description: Prepare presentation
 * Task added: Task 2: Prepare presentation
 * 
 * --- Task Management Menu ---
 * ...
 * Enter your choice: 3
 * --- Pending Tasks ---
 * Task 1: Write report
 * Task 2: Prepare presentation
 * 
 * --- Task Management Menu ---
 * ...
 * Enter your choice: 2
 * Processed task: Task 1: Write report
 * 
 * --- Task Management Menu ---
 * ...
 * Enter your choice: 3
 * --- Pending Tasks ---
 * Task 2: Prepare presentation
 * 
 * --- Task Management Menu ---
 * ...
 * Enter your choice: 4
 * --- Completed Tasks ---
 * Task 1: Write report
 * 
 * --- Task Management Menu ---
 * ...
 * Enter your choice: 2
 * Processed task: Task 2: Prepare presentation
 * 
 * --- Task Management Menu ---
 * ...
 * Enter your choice: 2
 * Error: No tasks in the pending queue to process.
 * 
 * --- Task Management Menu ---
 * ...
 * Enter your choice: abc
 * Error: Invalid input. Please enter a number.
 * 
 * --- Task Management Menu ---
 * ...
 * Enter your choice: 5
 * Exiting Task Management System.
 * ```
 * 
 * Your solution should consist of the Java code for the `Task` and `TaskManager` classes.
 *
 * EXPLANATION:
 * This solution implements a simple Task Management System using the required Java components and following best practices.
 * 
 * 1.  **`Task` Class:** This class serves as a simple data structure to hold the `id` and `description` of a task. It demonstrates encapsulation with private fields and public getter methods. The `toString()` method provides a convenient way to print task details.
 * 
 * 2.  **`TaskManager` Class:** This is the core class managing the application logic.
 *     *   **`Queue<Task> pendingTasks`:** A `LinkedList` is used here because it implements the `Queue` interface, providing FIFO behavior. `offer()` is used to add tasks to the end, and `poll()` is used to remove tasks from the front.
 *     *   **`List<Task> completedTasks`:** An `ArrayList` is used here to store completed tasks. The `List` interface is used for the type declaration, promoting good practice by programming to the interface. Tasks are added to this list using `add()`.
 *     *   **`Scanner scanner`:** Used to read input from `System.in`. It's initialized once and closed when the application exits.
 *     *   **`nextTaskId`:** An integer counter to ensure each task gets a unique ID.
 * 
 * 3.  **`run()` Method:** This method contains the main application loop.
 *     *   It repeatedly displays the menu and reads the user's choice.
 *     *   **`try-catch` Block:** A large `try-catch` block encloses the reading of the choice and the `switch` statement. This is a class-wide exception handling approach for the main interaction loop. It specifically catches `InputMismatchException` if the user enters non-integer input for the menu choice, preventing the program from crashing and printing an error message to `System.err`. A general `Exception` catch is also included as a fallback for any other unexpected errors, printing to `System.err`.
 *     *   **`switch` Statement:** Controls the flow of execution based on the valid user choice, directing the program to call the appropriate method (`addNewTask`, `processNextTask`, etc.). The `default` case handles integer inputs that are outside the valid menu range.
 * 
 * 4.  **Core Functionality Methods (`addNewTask`, `processNextTask`, `viewPendingTasks`, `viewCompletedTasks`):**
 *     *   These methods implement the specific actions for each menu option.
 *     *   `addNewTask` includes basic input validation (`description.isEmpty()`) and uses `System.err` for the validation error. It uses `scanner.nextLine()` after `scanner.nextInt()` (or similar) to consume the leftover newline character, preventing potential input issues in subsequent reads.
 *     *   `processNextTask` demonstrates checking if the queue is empty before attempting to poll, using `System.err` if it is empty.
 *     *   `viewPendingTasks` and `viewCompletedTasks` iterate through the respective collections and print task details using `System.out`.
 * 
 * 5.  **Input/Output Streams:**
 *     *   `System.out` is used exclusively for normal program output, such as the menu, confirmations, and task lists.
 *     *   `System.err` is used exclusively for error messages, including input validation errors, empty queue errors, and general exception messages caught by the `try-catch` block.
 * 
 * 6.  **Best Practices:**
 *     *   **Encapsulation:** Demonstrated in the `Task` class and by keeping the collections and scanner private in `TaskManager`.
 *     *   **Meaningful Names:** Class, method, and variable names are descriptive (e.g., `pendingTasks`, `processNextTask`, `nextTaskId`).
 *     *   **Comments:** Javadoc comments explain the purpose of classes and methods, and inline comments explain specific logic points.
 *     *   **Input Validation & Error Handling:** Implemented for task description and menu choice, with appropriate error messages directed to `System.err`.
 *     *   **Clean Code:** The code is structured into logical methods, making it readable and maintainable.
 * 
 * This solution effectively integrates all required components within a practical scenario, demonstrating understanding of collections, input handling, control flow, and robust error management in Java.
 */

import java.util.Queue;
import java.util.LinkedList;
import java.util.List;
import java.util.ArrayList;
import java.util.Scanner;
import java.util.InputMismatchException;

/**
 * Represents a single task with an ID and description.
 */
class Task {
    private int id;
    private String description;

    /**
     * Constructs a new Task.
     * @param id The unique identifier for the task.
     * @param description A brief description of the task.
     */
    public Task(int id, String description) {
        this.id = id;
        this.description = description;
    }

    /**
     * Gets the task ID.
     * @return The task ID.
     */
    public int getId() {
        return id;
    }

    /**
     * Gets the task description.
     * @return The task description.
     */
    public String getDescription() {
        return description;
    }

    /**
     * Returns a string representation of the Task.
     * @return Formatted string "Task [ID]: [Description]".
     */
    @Override
    public String toString() {
        return "Task " + id + ": " + description;
    }
}

/**
 * Manages the task processing system, handling pending and completed tasks.
 */
public class TaskManager {
    // Queue for tasks waiting to be processed (FIFO)
    private Queue<Task> pendingTasks;
    // List for tasks that have been completed
    private List<Task> completedTasks;
    // Scanner for reading user input
    private Scanner scanner;
    // Counter for assigning unique task IDs
    private int nextTaskId;

    /**
     * Constructs a new TaskManager.
     * Initializes the task collections and the scanner.
     */
    public TaskManager() {
        this.pendingTasks = new LinkedList<>(); // LinkedList implements Queue
        this.completedTasks = new ArrayList<>(); // ArrayList implements List
        this.scanner = new Scanner(System.in);
        this.nextTaskId = 1; // Start task IDs from 1
    }

    /**
     * Displays the main menu options to the user.
     */
    private void displayMenu() {
        System.out.println("\n--- Task Management Menu ---");
        System.out.println("1. Add New Task");
        System.out.println("2. Process Next Task");
        System.out.println("3. View Pending Tasks");
        System.out.println("4. View Completed Tasks");
        System.out.println("5. Exit");
        System.out.print("Enter your choice: ");
    }

    /**
     * Adds a new task based on user input.
     * Prompts for description, validates it, creates a Task object, and adds to the queue.
     */
    private void addNewTask() {
        System.out.print("Enter task description: ");
        // Consume the newline character left by previous nextInt() or similar
        scanner.nextLine();
        String description = scanner.nextLine().trim();

        if (description.isEmpty()) {
            System.err.println("Error: Task description cannot be empty.");
            return; // Exit the method if description is invalid
        }

        Task newTask = new Task(nextTaskId++, description);
        pendingTasks.offer(newTask); // offer() is preferred over add() for queues, returns false on failure
        System.out.println("Task added: " + newTask);
    }

    /**
     * Processes the next task in the pending queue.
     * Removes the task from the queue and adds it to the completed list.
     */
    private void processNextTask() {
        Task taskToProcess = pendingTasks.poll(); // poll() retrieves and removes, returns null if queue is empty

        if (taskToProcess != null) {
            completedTasks.add(taskToProcess);
            System.out.println("Processed task: " + taskToProcess);
        } else {
            System.err.println("Error: No tasks in the pending queue to process.");
        }
    }

    /**
     * Displays all tasks currently in the pending queue.
     */
    private void viewPendingTasks() {
        System.out.println("--- Pending Tasks ---");
        if (pendingTasks.isEmpty()) {
            System.out.println("No pending tasks.");
        } else {
            // Iterating through the queue without removing elements
            for (Task task : pendingTasks) {
                System.out.println(task);
            }
        }
    }

    /**
     * Displays all tasks currently in the completed list.
     */
    private void viewCompletedTasks() {
        System.out.println("--- Completed Tasks ---");
        if (completedTasks.isEmpty()) {
            System.out.println("No completed tasks.");
        } else {
            for (Task task : completedTasks) {
                System.out.println(task);
            }
        }
    }

    /**
     * Runs the main task management application loop.
     * Displays menu, reads input, and performs actions until the user exits.
     * Includes exception handling for input errors.
     */
    public void run() {
        int choice = -1;
        while (choice != 5) {
            displayMenu();
            try {
                choice = scanner.nextInt(); // Read integer choice

                // Use switch statement for flow control based on choice
                switch (choice) {
                    case 1:
                        addNewTask();
                        break;
                    case 2:
                        processNextTask();
                        break;
                    case 3:
                        viewPendingTasks();
                        break;
                    case 4:
                        viewCompletedTasks();
                        break;
                    case 5:
                        System.out.println("Exiting Task Management System.");
                        break;
                    default:
                        // Handle choices outside the defined range
                        System.err.println("Error: Invalid choice. Please enter a number between 1 and 5.");
                }
            } catch (InputMismatchException e) {
                // Catch non-integer input
                System.err.println("Error: Invalid input. Please enter a number.");
                scanner.next(); // Consume the invalid input to prevent infinite loop
                choice = -1; // Reset choice to stay in the loop
            } catch (Exception e) {
                // Catch any other unexpected exceptions
                System.err.println("An unexpected error occurred: " + e.getMessage());
                // e.printStackTrace(); // Uncomment for debugging if needed
                choice = -1; // Reset choice to stay in the loop
            }
        }
        scanner.close(); // Close the scanner when exiting
    }

    /**
     * Main method to start the application.
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        TaskManager manager = new TaskManager();
        manager.run();
    }
}
