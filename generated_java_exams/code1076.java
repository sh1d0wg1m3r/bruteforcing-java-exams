/*
 * Exam Question #1076
 * Generated on: 2025-05-12 17:21:37
 * Generated by: Account 4
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Software Build Task Manager
 * 
 * **Scenario:**
 * 
 * You are tasked with building a simplified Software Build Task Manager system. This system simulates a queue of build tasks waiting to be processed and a list of tasks that have been completed. Users can submit new tasks, process the next task in the queue, and view the lists of pending and completed tasks.
 * 
 * **Requirements:**
 * 
 * Your solution must implement the following functionalities and adhere to the specified Java concepts and best practices:
 * 
 * 1.  **Task Representation:** Create a class `BuildTask` to represent a single build task. It should have private fields for:
 *     *   A unique integer `id`.
 *     *   A `String` `name` (e.g., "Frontend Build", "Backend Compile").
 *     *   A `String` `description` (details about the task).
 *     *   A `TaskStatus` (an `enum` with values like `PENDING`, `PROCESSING`, `COMPLETED`).
 *     *   Provide public getter methods for all fields.
 * 
 * 2.  **Task Management System:** Create a class `BuildSystem` that manages the build tasks. It must contain:
 *     *   A `Queue<BuildTask>` to hold tasks that are waiting to be processed.
 *     *   A `List<BuildTask>` (specifically using `ArrayList` as the implementation) to hold tasks that have been completed.
 *     *   A mechanism to generate unique task IDs (a simple counter is sufficient).
 *     *   Public methods:
 *         *   `addTask(String name, String description)`: Creates a new `BuildTask` with a unique ID, sets its status to `PENDING`, and adds it to the pending tasks queue.
 *         *   `processNextTask()`: Removes the next task from the pending queue, sets its status to `COMPLETED`, and adds it to the completed tasks list. If the queue is empty, it should report an error.
 *         *   `getPendingTasks()`: Returns a `List<BuildTask>` containing all tasks currently in the pending queue. The order should reflect the queue's order.
 *         *   `getCompletedTasks()`: Returns a `List<BuildTask>` containing all tasks currently in the completed tasks list.
 * 
 * 3.  **User Interface (Main Class):** Create a `Main` class with a `main` method to interact with the user.
 *     *   Use `java.util.Scanner` to read user input from the console.
 *     *   Implement a menu-driven interface with the following options:
 *         1.  Submit New Build Task
 *         2.  Process Next Build Task
 *         3.  View Pending Tasks
 *         4.  View Completed Tasks
 *         5.  Exit
 *     *   Use a `switch` statement to handle the different menu options.
 *     *   For option 1, prompt the user for the task name and description.
 *     *   For options 3 and 4, iterate through the respective lists and print the task details (`ID`, `Name`, `Status`).
 *     *   Use `System.out` for normal program output (menu, task details, success messages).
 *     *   Use `System.err` for error messages (e.g., invalid menu option, queue empty when trying to process).
 * 
 * 4.  **Error Handling and Validation:**
 *     *   Implement input validation for the menu choice (ensure it's a number within the valid range). Handle cases where the user enters non-numeric input.
 *     *   Handle the case where `processNextTask()` is called when the pending queue is empty.
 *     *   Implement **class-wide exception handling** using `try-catch` blocks in the `main` method to catch potential unexpected runtime exceptions during program execution and report them gracefully to `System.err`. Ensure the `Scanner` is closed properly, even if an exception occurs.
 * 
 * 5.  **Best Practices:**
 *     *   Use proper encapsulation (private fields, public getters/methods).
 *     *   Use meaningful names for variables, methods, and classes.
 *     *   Include appropriate comments and documentation (e.g., Javadoc for classes and methods).
 *     *   Maintain a clean code structure.
 * 
 * **Expected Output:**
 * 
 * The program should present a menu, accept user input, perform the requested action, and display results or errors. Output format for tasks should clearly show ID, Name, and Status. Example flow:
 * 
 * ```
 * Build Task Manager Menu:
 * 1. Submit New Build Task
 * 2. Process Next Build Task
 * 3. View Pending Tasks
 * 4. View Completed Tasks
 * 5. Exit
 * Enter your choice: 1
 * Enter task name: Frontend Build
 * Enter task description: Compile SASS and JS assets
 * Task submitted successfully!
 * 
 * Build Task Manager Menu:
 * ...
 * Enter your choice: 3
 * --- Pending Tasks ---
 * ID: 1, Name: Frontend Build, Status: PENDING
 * 
 * Build Task Manager Menu:
 * ...
 * Enter your choice: 2
 * Processing next task...
 * Task ID 1 completed.
 * 
 * Build Task Manager Menu:
 * ...
 * Enter your choice: 3
 * --- Pending Tasks ---
 * No pending tasks.
 * 
 * Build Task Manager Menu:
 * ...
 * Enter your choice: 4
 * --- Completed Tasks ---
 * ID: 1, Name: Frontend Build, Status: COMPLETED
 * 
 * Build Task Manager Menu:
 * ...
 * Enter your choice: 6
 * Invalid option. Please enter a number between 1 and 5.
 * 
 * Build Task Manager Menu:
 * ...
 * Enter your choice: abc
 * Invalid input. Please enter a number.
 * 
 * Build Task Manager Menu:
 * ...
 * Enter your choice: 2
 * --- Error ---
 * No tasks in the pending queue to process.
 * 
 * Build Task Manager Menu:
 * ...
 * Enter your choice: 5
 * Exiting Build Task Manager.
 * ```
 * 
 * Your code should be a single `.java` file containing all necessary classes and the `main` method.
 *
 * EXPLANATION:
 * This solution implements a simplified Build Task Manager demonstrating the required Java concepts and best practices.
 * 
 * 1.  **`BuildTask` Class:**
 *     *   Represents a single task.
 *     *   Uses private fields (`id`, `name`, `description`, `status`) for encapsulation.
 *     *   Provides public getters to access task information.
 *     *   Uses an `enum` (`TaskStatus`) for clear and type-safe status representation.
 *     *   Includes a package-private `setStatus` method, allowing only classes within the same package (like `BuildSystem`) to change the status, adhering to encapsulation principles regarding state changes.
 *     *   Overrides `toString()` for easy printing of task details.
 * 
 * 2.  **`BuildSystem` Class:**
 *     *   Manages the collection of tasks.
 *     *   Uses `java.util.Queue<BuildTask>` (`LinkedList` implementation) for `pendingTasks`. `LinkedList` is suitable as it provides efficient `offer()` (add to tail) and `poll()` (remove from head) operations, which are standard for queue behavior (FIFO - First-In, First-Out).
 *     *   Uses `java.util.List<BuildTask>` (`ArrayList` implementation) for `completedTasks`. `ArrayList` provides dynamic array capabilities and fulfills the requirement to use `ArrayList` and the `List` interface.
 *     *   `nextTaskId` is a simple counter to ensure unique IDs for new tasks.
 *     *   `addTask`: Creates a new `BuildTask`, assigns the next ID, sets status to `PENDING`, and adds it to the `pendingTasks` queue using `offer()`.
 *     *   `processNextTask`: Uses `poll()` to retrieve and remove the head of the `pendingTasks` queue. It checks if `poll()` returned `null` (indicating an empty queue) and prints an error to `System.err` if so. If a task is retrieved, its status is updated to `COMPLETED`, and it's added to the `completedTasks` list.
 *     *   `getPendingTasks` and `getCompletedTasks`: Return `List` views of the respective collections. To prevent external modification of the internal state, they return copies or, preferably, unmodifiable views using `Collections.unmodifiableList()`. This demonstrates returning collection data safely.
 * 
 * 3.  **`BuildTaskManager` (Main Class):**
 *     *   Contains the `main` method, the entry point of the application.
 *     *   Uses `java.util.Scanner` to read input from `System.in`.
 *     *   A `while(running)` loop keeps the application active until the user chooses to exit.
 *     *   A `switch` statement handles the user's menu choice, directing execution to the appropriate logic.
 *     *   Input validation for the menu choice is implemented by checking `scanner.hasNextInt()` before reading the integer. If input is not an integer, an error is printed to `System.err`, the invalid token is consumed with `scanner.next()`, and the loop continues. If it is an integer, `scanner.nextInt()` is read, and `scanner.nextLine()` is called immediately after to consume the leftover newline character, preventing issues with subsequent `nextLine()` calls for task name/description.
 *     *   `System.out.println` is used for printing the menu, prompts, success messages, and task details.
 *     *   `System.err.println` is used specifically for printing error messages (invalid input, empty queue error).
 *     *   **Class-wide exception handling:** A large `try-catch (Exception e)` block wraps the main `while` loop. This block catches any unhandled `RuntimeException` or other `Exception` that might occur within the main execution flow, printing a generic error message and the stack trace to `System.err`. This provides a robust top-level error handling mechanism.
 *     *   The `finally` block ensures that the `Scanner` object is closed regardless of whether the program finishes normally or exits due to an exception. Closing the `Scanner` releases the underlying system resources.
 * 
 * 4.  **Required Components Usage:**
 *     *   `Queue`: Used for `pendingTasks` in `BuildSystem`.
 *     *   `ArrayList`: Used for `completedTasks` in `BuildSystem` (explicitly requested as the implementation).
 *     *   `List`: Used as the interface type for `completedTasks` and for the return types of `getPendingTasks`/`getCompletedTasks`.
 *     *   `Scanner`: Used in `main` for user input.
 *     *   `switch`: Used in `main` for the menu selection.
 *     *   `System.err`: Used for all error messages.
 *     *   `System.out`: Used for all normal output.
 *     *   `try-catch`: A top-level block in `main` for general exception handling and specific handling for invalid integer input within the loop.
 * 
 * This solution effectively combines the required Java features within a practical simulation, demonstrating understanding of data structures, object-oriented principles, user interaction, and robust error handling.
 */

import java.util.ArrayList;
import java.util.LinkedList; // LinkedList implements Queue and List
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.Collections; // For unmodifiable list

/**
 * Enum representing the status of a build task.
 */
enum TaskStatus {
    PENDING,
    PROCESSING, // Optional: could be used for more complex simulation
    COMPLETED
}

/**
 * Represents a single build task with an ID, name, description, and status.
 */
class BuildTask {
    private int id;
    private String name;
    private String description;
    private TaskStatus status;

    /**
     * Constructs a new BuildTask.
     * @param id The unique ID of the task.
     * @param name The name of the task.
     * @param description The description of the task.
     */
    public BuildTask(int id, String name, String description) {
        this.id = id;
        this.name = name;
        this.description = description;
        this.status = TaskStatus.PENDING; // New tasks are always pending
    }

    // --- Getters ---

    public int getId() {
        return id;
    }

    public String getName() {
        return name;
    }

    public String getDescription() {
        return description;
    }

    public TaskStatus getStatus() {
        return status;
    }

    /**
     * Updates the status of the task.
     * This method is intended for use by the BuildSystem.
     * @param status The new status for the task.
     */
    void setStatus(TaskStatus status) {
        this.status = status;
    }

    @Override
    public String toString() {
        return String.format("ID: %d, Name: %s, Status: %s", id, name, status);
    }
}

/**
 * Manages the queue of pending build tasks and the list of completed tasks.
 */
class BuildSystem {
    // Using LinkedList as it implements both Queue and List, suitable for this scenario
    private Queue<BuildTask> pendingTasks;
    private List<BuildTask> completedTasks;
    private int nextTaskId; // Counter for generating unique IDs

    /**
     * Constructs a new BuildSystem, initializing task collections and ID counter.
     */
    public BuildSystem() {
        // Use LinkedList for pendingTasks as it provides efficient queue operations (add, poll)
        this.pendingTasks = new LinkedList<>();
        // Use ArrayList for completedTasks for efficient storage and retrieval by index (though not strictly needed here, it fulfills the ArrayList requirement)
        this.completedTasks = new ArrayList<>();
        this.nextTaskId = 1; // Start task IDs from 1
    }

    /**
     * Creates a new build task and adds it to the pending queue.
     * @param name The name of the task.
     * @param description The description of the task.
     */
    public void addTask(String name, String description) {
        BuildTask newTask = new BuildTask(nextTaskId++, name, description);
        pendingTasks.offer(newTask); // offer() is preferred over add() for queues
        System.out.println("Task submitted successfully! " + newTask);
    }

    /**
     * Processes the next task in the pending queue.
     * Removes the task from the queue, updates its status to COMPLETED,
     * and adds it to the completed tasks list.
     * Reports an error if the queue is empty.
     */
    public void processNextTask() {
        BuildTask taskToProcess = pendingTasks.poll(); // poll() returns null if queue is empty

        if (taskToProcess == null) {
            System.err.println("--- Error ---");
            System.err.println("No tasks in the pending queue to process.");
            return;
        }

        System.out.println("Processing next task...");
        // Simulate processing time (optional, not required by problem, but good for realism)
        // try { Thread.sleep(100); } catch (InterruptedException e) { Thread.currentThread().interrupt(); }

        taskToProcess.setStatus(TaskStatus.COMPLETED);
        completedTasks.add(taskToProcess);
        System.out.println("Task ID " + taskToProcess.getId() + " completed.");
    }

    /**
     * Returns a list of all tasks currently in the pending queue.
     * Returns an unmodifiable list to prevent external modification.
     * @return An unmodifiable list of pending tasks.
     */
    public List<BuildTask> getPendingTasks() {
        // Create a new list from the queue elements to return, maintaining queue order
        List<BuildTask> pendingList = new ArrayList<>(pendingTasks);
        return Collections.unmodifiableList(pendingList); // Return unmodifiable view
    }

    /**
     * Returns a list of all tasks currently in the completed tasks list.
     * Returns an unmodifiable list to prevent external modification.
     * @return An unmodifiable list of completed tasks.
     */
    public List<BuildTask> getCompletedTasks() {
         // Return an unmodifiable view of the internal list
        return Collections.unmodifiableList(completedTasks);
    }
}

/**
 * Main class for the Build Task Manager application.
 * Handles user interaction, menu display, and core application flow.
 * Demonstrates Scanner, switch, System.out, System.err, and try-catch.
 */
public class BuildTaskManager {

    public static void main(String[] args) {
        Scanner scanner = null; // Initialize to null for finally block check
        BuildSystem buildSystem = new BuildSystem();
        boolean running = true;

        // Class-wide exception handling for the main application loop
        try {
            scanner = new Scanner(System.in);

            System.out.println("--- Build Task Manager ---");

            while (running) {
                printMenu();

                System.out.print("Enter your choice: ");
                int choice = -1; // Default invalid choice

                // Input validation for menu choice
                if (scanner.hasNextInt()) {
                    choice = scanner.nextInt();
                    scanner.nextLine(); // Consume the newline character
                } else {
                    System.err.println("Invalid input. Please enter a number.");
                    scanner.next(); // Consume the invalid token to prevent infinite loop
                    continue; // Skip the rest of the loop and show menu again
                }

                // Process user choice using a switch statement
                switch (choice) {
                    case 1: // Submit New Build Task
                        System.out.print("Enter task name: ");
                        String name = scanner.nextLine();
                        System.out.print("Enter task description: ");
                        String description = scanner.nextLine();
                        buildSystem.addTask(name, description);
                        break;

                    case 2: // Process Next Build Task
                        buildSystem.processNextTask();
                        break;

                    case 3: // View Pending Tasks
                        System.out.println("\n--- Pending Tasks ---");
                        List<BuildTask> pending = buildSystem.getPendingTasks();
                        if (pending.isEmpty()) {
                            System.out.println("No pending tasks.");
                        } else {
                            for (BuildTask task : pending) {
                                System.out.println(task);
                            }
                        }
                        System.out.println("---------------------\n");
                        break;

                    case 4: // View Completed Tasks
                        System.out.println("\n--- Completed Tasks ---");
                        List<BuildTask> completed = buildSystem.getCompletedTasks();
                        if (completed.isEmpty()) {
                            System.out.println("No completed tasks.");
                        } else {
                            for (BuildTask task : completed) {
                                System.out.println(task);
                            }
                        }
                        System.out.println("---------------------\n");
                        break;

                    case 5: // Exit
                        System.out.println("Exiting Build Task Manager.");
                        running = false;
                        break;

                    default: // Invalid option
                        System.err.println("Invalid option. Please enter a number between 1 and 5.");
                        break;
                }
            }
        } catch (Exception e) {
            // Catch any unexpected runtime exceptions
            System.err.println("\n--- An unexpected system error occurred ---");
            System.err.println("Error details: " + e.getMessage());
            // Print stack trace to System.err for debugging purposes
            e.printStackTrace(System.err);
            System.err.println("------------------------------------------");
        } finally {
            // Ensure the scanner is closed when the application exits or errors out
            if (scanner != null) {
                scanner.close();
                System.out.println("Scanner closed."); // Optional confirmation
            }
        }
    }

    /**
     * Prints the main menu options to the console.
     */
    private static void printMenu() {
        System.out.println("Build Task Manager Menu:");
        System.out.println("1. Submit New Build Task");
        System.out.println("2. Process Next Build Task");
        System.out.println("3. View Pending Tasks");
        System.out.println("4. View Completed Tasks");
        System.out.println("5. Exit");
    }
}
