/*
 * Exam Question #737
 * Generated on: 2025-05-12 16:33:24
 * Generated by: Account 5
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Package Processing Center Simulation
 * 
 * **Scenario:**
 * 
 * You are tasked with developing a simplified simulation of a package processing center. Packages arrive, are placed in an incoming queue, sorted into specific bays based on destination, and then dispatched. Your program should allow a user to interact with the system via command-line input.
 * 
 * **Requirements:**
 * 
 * 1.  **Package Representation:** Create a class `Package` with private fields for `id` (String), `destination` (String - e.g., "LOCAL", "REGIONAL", "NATIONAL"), and `weight` (double). Include a constructor and public getter methods. Implement input validation in the constructor (e.g., ID and destination cannot be null or empty, weight must be positive). Throw an `IllegalArgumentException` for invalid data during package creation.
 * 2.  **Processing Center:** Create a class `PackageProcessingCenter` to manage the packages.
 *     *   It must have a `Queue<Package>` for incoming packages.
 *     *   It must have `List<Package>` instances for each sorting bay (e.g., `localBay`, `regionalBay`, `nationalBay`). Declare these using the `List` interface but instantiate them as `ArrayList`.
 *     *   Implement the following public methods:
 *         *   `addPackage(Package pkg)`: Adds a package to the incoming queue.
 *         *   `sortPackages()`: Moves packages from the incoming queue to the appropriate sorting bay (`localBay`, `regionalBay`, or `nationalBay`) based on the package's destination. Packages with unknown destinations should be reported as errors and remain in the incoming queue (or moved to a separate error list, your choice - leaving in queue is simpler for this task).
 *         *   `dispatchPackages(String destination)`: Removes and returns a `List<Package>` from the specified sorting bay. The bay should be cleared after dispatch. Report an error if the destination is invalid or the bay is empty.
 *         *   `displayStatus()`: Prints the current contents of the incoming queue and all sorting bays.
 * 3.  **User Interface:**
 *     *   Use `Scanner` to read user commands from the console.
 *     *   Implement a command loop that continues until the user enters an "exit" command.
 *     *   Use a `switch` statement to process the following commands:
 *         *   `add <id> <destination> <weight>`: Creates a new `Package` and adds it to the incoming queue. Handle potential `IllegalArgumentException` during package creation and `InputMismatchException` or other `Scanner` issues during input reading.
 *         *   `sort`: Calls the `sortPackages()` method.
 *         *   `dispatch <destination>`: Calls the `dispatchPackages()` method for the given destination.
 *         *   `status`: Calls the `displayStatus()` method.
 *         *   `exit`: Terminates the program.
 *         *   Any other command: Report as an invalid command.
 * 4.  **Error Handling and Output:**
 *     *   Use `System.out` for prompts, successful operation messages, and status display.
 *     *   Use `System.err` for error messages (invalid input, package creation errors, unknown destinations during sort, dispatching from empty/invalid bays, invalid commands).
 *     *   Implement comprehensive exception handling using `try-catch` blocks. The main command processing loop should be wrapped in a `try-catch` block to demonstrate class-wide handling of unexpected exceptions, in addition to specific handling for expected issues like `IllegalArgumentException` or `InputMismatchException` around input processing.
 * 5.  **Best Practices:**
 *     *   Use meaningful variable and method names.
 *     *   Add appropriate comments and documentation (Javadocs are a plus).
 *     *   Ensure proper encapsulation (private fields, public methods).
 *     *   Validate user input where applicable.
 *     *   Properly close resources (the `Scanner`).
 * 
 * **Expected Output:**
 * 
 * The program should provide clear prompts, display system status, and report errors using the appropriate output stream (`System.out` or `System.err`).
 * 
 * Example Interaction:
 * 
 * ```
 * Enter command (add, sort, dispatch, status, exit): add P1 LOCAL 1.5
 * Package P1 added to incoming queue.
 * Enter command (add, sort, dispatch, status, exit): add P2 REGIONAL 5.0
 * Package P2 added to incoming queue.
 * Enter command (add, sort, dispatch, status, exit): status
 * --- System Status ---
 * Incoming Queue: [P1 (LOCAL, 1.5kg), P2 (REGIONAL, 5.0kg)]
 * Local Bay: []
 * Regional Bay: []
 * National Bay: []
 * ---------------------
 * Enter command (add, sort, dispatch, status, exit): sort
 * Sorting packages...
 * Package P1 sorted to Local Bay.
 * Package P2 sorted to Regional Bay.
 * Sorting complete.
 * Enter command (add, sort, dispatch, status, exit): status
 * --- System Status ---
 * Incoming Queue: []
 * Local Bay: [P1 (LOCAL, 1.5kg)]
 * Regional Bay: [P2 (REGIONAL, 5.0kg)]
 * National Bay: []
 * ---------------------
 * Enter command (add, sort, dispatch, status, exit): dispatch LOCAL
 * Dispatching packages from Local Bay...
 * Dispatched [P1 (LOCAL, 1.5kg)]
 * Local Bay cleared.
 * Enter command (add, sort, dispatch, status, exit): status
 * --- System Status ---
 * Incoming Queue: []
 * Local Bay: []
 * Regional Bay: [P2 (REGIONAL, 5.0kg)]
 * National Bay: []
 * ---------------------
 * Enter command (add, sort, dispatch, status, exit): dispatch NATIONAL
 * Error: National Bay is empty. No packages to dispatch.
 * Enter command (add, sort, dispatch, status, exit): add P3 UNKNOWN 2.0
 * Error creating package: Invalid destination: UNKNOWN. Destination must be LOCAL, REGIONAL, or NATIONAL.
 * Enter command (add, sort, dispatch, status, exit): add P4 LOCAL -1.0
 * Error creating package: Weight must be positive.
 * Enter command (add, sort, dispatch, status, exit): sort
 * Sorting packages...
 * Sorting complete. (No packages in incoming queue)
 * Enter command (add, sort, dispatch, status, exit): exit
 * Exiting Package Processing Center simulation.
 * ```
 * 
 * **Constraint Checklist:**
 * 
 * *   Queue: Yes
 * *   ArrayList: Yes
 * *   List interface: Yes
 * *   Scanner: Yes
 * *   Switch statement: Yes
 * *   System.err: Yes
 * *   System.out: Yes
 * *   Class-wide exception handling (`try-catch`): Yes
 * 
 * **Time Estimate:** 45-60 minutes.
 * 
 * ---
 * **Note:** Focus on a clear, well-structured solution that correctly uses all required components and demonstrates robust error handling.
 *
 * EXPLANATION:
 * This solution implements a `PackageProcessingCenter` simulation, demonstrating the required Java concepts in a practical context.
 * 
 * 1.  **`Package` Class:**
 *     *   Represents individual packages with `id`, `destination`, and `weight`.
 *     *   Private fields ensure encapsulation.
 *     *   The constructor includes input validation for all fields, throwing `IllegalArgumentException` for invalid data. This prevents the creation of invalid `Package` objects.
 *     *   `toString()` provides a convenient string representation for printing.
 * 
 * 2.  **`PackageProcessingCenter` Class:**
 *     *   **Required Data Structures:**
 *         *   `incomingQueue`: Declared as `Queue<Package>` and instantiated as `LinkedList`. `LinkedList` implements the `Queue` interface, providing methods like `offer()` (add) and `poll()` (retrieve and remove from the front). This models the FIFO (First-In, First-Out) nature of packages arriving.
 *         *   `localBay`, `regionalBay`, `nationalBay`: Declared as `List<Package>` and instantiated as `ArrayList`. `ArrayList` is a common implementation of the `List` interface, providing dynamic arrays suitable for storing sorted packages.
 *     *   **Methods:**
 *         *   `addPackage()`: Uses `incomingQueue.offer()` to add a package to the end of the queue.
 *         *   `sortPackages()`: Iterates through the `incomingQueue` using `poll()`. A `switch` statement is used to check the package's destination and add it to the corresponding `ArrayList` (sorting bay). Packages with unknown destinations are handled by printing an error to `System.err` and are temporarily stored in a `tempQueue` before being returned to the `incomingQueue` to simulate them needing further inspection.
 *         *   `dispatchPackages()`: Takes a destination string, uses a `switch` statement to identify the correct bay `List`. It checks if the bay is empty using `isEmpty()`. If not empty, it creates a copy of the bay's contents, prints them using `System.out`, clears the original bay `List` using `clear()`, and returns the copied list. Error messages for invalid destinations or empty bays are printed to `System.err`.
 *         *   `displayStatus()`: Prints the current state of the `incomingQueue` and all `List` bays to `System.out` for user visibility.
 *     *   **`run()` Method:**
 *         *   This is the main entry point for the simulation's interactive part.
 *         *   It uses a `Scanner` to read user input line by line.
 *         *   A `try-with-resources` block is used for the `Scanner` (`try (Scanner scanner = new Scanner(System.in))`) to ensure the scanner resource is properly closed automatically when the block is exited.
 *         *   The main command loop (`do...while`) reads commands.
 *         *   A `switch` statement handles the different commands (`add`, `sort`, `dispatch`, `status`, `exit`).
 *         *   **Exception Handling:**
 *             *   Specific `try-catch` blocks are used within the `add` command case to handle potential `InputMismatchException` (if the user enters non-numeric input for weight) and `IllegalArgumentException` (thrown by the `Package` constructor for invalid data). Errors are reported to `System.err`.
 *             *   A broader `try-catch(Exception e)` block wraps the *entire* command processing loop within the `run` method. This serves as a top-level, class-wide exception handler that catches any unexpected runtime exceptions that might occur during command execution and were not specifically handled lower down. It prints a critical error message and the stack trace to `System.err` before allowing the program to terminate (or continue if the exception was non-fatal, though here it leads to termination after the message).
 * 
 * 3.  **Main Method:**
 *     *   The `main` method simply creates an instance of `PackageProcessingCenter` and calls its `run()` method to start the simulation.
 * 
 * This solution effectively uses all the required components (`Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.err`, `System.out`, `try-catch`) in a cohesive program that simulates a practical scenario, while also incorporating best practices like encapsulation, clear naming, and robust error handling.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.InputMismatchException;

/**
 * Represents a package with an ID, destination, and weight.
 */
class Package {
    private String id;
    private String destination;
    private double weight;

    // Allowed destinations
    private static final List<String> VALID_DESTINATIONS = List.of("LOCAL", "REGIONAL", "NATIONAL");

    /**
     * Constructs a new Package.
     *
     * @param id The package ID.
     * @param destination The package destination (LOCAL, REGIONAL, NATIONAL).
     * @param weight The package weight in kg.
     * @throws IllegalArgumentException if id is null/empty, destination is invalid, or weight is not positive.
     */
    public Package(String id, String destination, double weight) {
        if (id == null || id.trim().isEmpty()) {
            throw new IllegalArgumentException("Package ID cannot be null or empty.");
        }
        if (destination == null || !VALID_DESTINATIONS.contains(destination.toUpperCase())) {
             throw new IllegalArgumentException("Invalid destination: " + destination + ". Destination must be LOCAL, REGIONAL, or NATIONAL.");
        }
        if (weight <= 0) {
            throw new IllegalArgumentException("Weight must be positive.");
        }

        this.id = id.trim();
        this.destination = destination.toUpperCase();
        this.weight = weight;
    }

    public String getId() {
        return id;
    }

    public String getDestination() {
        return destination;
    }

    public double getWeight() {
        return weight;
    }

    @Override
    public String toString() {
        return id + " (" + destination + ", " + weight + "kg)";
    }
}

/**
 * Simulates a package processing center.
 * Manages incoming packages, sorts them into bays, and dispatches them.
 */
public class PackageProcessingCenter {

    private Queue<Package> incomingQueue;
    private List<Package> localBay;
    private List<Package> regionalBay;
    private List<Package> nationalBay;

    /**
     * Constructs a new PackageProcessingCenter.
     * Initializes the queue and sorting bays.
     */
    public PackageProcessingCenter() {
        this.incomingQueue = new LinkedList<>(); // LinkedList implements Queue
        this.localBay = new ArrayList<>();      // ArrayList implements List
        this.regionalBay = new ArrayList<>();   // ArrayList implements List
        this.nationalBay = new ArrayList<>();   // ArrayList implements List
    }

    /**
     * Adds a package to the incoming queue.
     * @param pkg The package to add.
     */
    public void addPackage(Package pkg) {
        if (pkg != null) {
            incomingQueue.offer(pkg); // offer is preferred over add for queues
            System.out.println("Package " + pkg.getId() + " added to incoming queue.");
        } else {
            System.err.println("Error: Cannot add a null package.");
        }
    }

    /**
     * Moves packages from the incoming queue to the appropriate sorting bays.
     */
    public void sortPackages() {
        System.out.println("Sorting packages...");
        int sortedCount = 0;
        int unknownCount = 0;
        Queue<Package> tempQueue = new LinkedList<>(); // Use a temp queue to handle packages that can't be sorted

        while (!incomingQueue.isEmpty()) {
            Package pkg = incomingQueue.poll(); // Get package from the front

            if (pkg != null) {
                switch (pkg.getDestination()) {
                    case "LOCAL":
                        localBay.add(pkg);
                        System.out.println("Package " + pkg.getId() + " sorted to Local Bay.");
                        sortedCount++;
                        break;
                    case "REGIONAL":
                        regionalBay.add(pkg);
                        System.out.println("Package " + pkg.getId() + " sorted to Regional Bay.");
                        sortedCount++;
                        break;
                    case "NATIONAL":
                        nationalBay.add(pkg);
                        System.out.println("Package " + pkg.getId() + " sorted to National Bay.");
                        sortedCount++;
                        break;
                    default:
                        // This case should ideally not be reached due to Package constructor validation,
                        // but good practice to handle defensively.
                        System.err.println("Error: Package " + pkg.getId() + " has unknown destination '" + pkg.getDestination() + "'. Leaving in incoming queue.");
                        tempQueue.offer(pkg); // Put it back into the temporary queue
                        unknownCount++;
                        break;
                }
            }
        }
        // Add packages that couldn't be sorted back to the main incoming queue
        while(!tempQueue.isEmpty()){
            incomingQueue.offer(tempQueue.poll());
        }

        if (sortedCount > 0 || unknownCount > 0) {
             System.out.println("Sorting complete. " + sortedCount + " packages sorted, " + unknownCount + " packages with unknown destinations.");
        } else {
             System.out.println("Sorting complete. No packages in incoming queue.");
        }
    }

    /**
     * Dispatches packages from a specific sorting bay.
     *
     * @param destination The destination bay to dispatch from (LOCAL, REGIONAL, NATIONAL).
     * @return A list of dispatched packages, or an empty list if none dispatched or destination invalid.
     */
    public List<Package> dispatchPackages(String destination) {
        if (destination == null) {
            System.err.println("Error: Dispatch destination cannot be null.");
            return new ArrayList<>(); // Return empty list on error
        }

        destination = destination.toUpperCase();
        List<Package> bayToDispatch;
        String bayName;

        switch (destination) {
            case "LOCAL":
                bayToDispatch = localBay;
                bayName = "Local Bay";
                break;
            case "REGIONAL":
                bayToDispatch = regionalBay;
                bayName = "Regional Bay";
                break;
            case "NATIONAL":
                bayToDispatch = nationalBay;
                bayName = "National Bay";
                break;
            default:
                System.err.println("Error: Invalid dispatch destination '" + destination + "'. Must be LOCAL, REGIONAL, or NATIONAL.");
                return new ArrayList<>(); // Return empty list for invalid destination
        }

        System.out.println("Dispatching packages from " + bayName + "...");

        if (bayToDispatch.isEmpty()) {
            System.err.println("Error: " + bayName + " is empty. No packages to dispatch.");
            return new ArrayList<>(); // Return empty list if bay is empty
        } else {
            List<Package> dispatchedList = new ArrayList<>(bayToDispatch); // Create a copy
            System.out.println("Dispatched " + dispatchedList);
            bayToDispatch.clear(); // Clear the bay after dispatch
            System.out.println(bayName + " cleared.");
            return dispatchedList;
        }
    }

    /**
     * Displays the current status of the incoming queue and all sorting bays.
     */
    public void displayStatus() {
        System.out.println("--- System Status ---");
        System.out.println("Incoming Queue: " + incomingQueue);
        System.out.println("Local Bay: " + localBay);
        System.out.println("Regional Bay: " + regionalBay);
        System.out.println("National Bay: " + nationalBay);
        System.out.println("---------------------");
    }

    /**
     * Runs the main command-line interface loop.
     * Handles user input and command processing.
     */
    public void run() {
        System.out.println("Welcome to the Package Processing Center Simulation!");
        // Use try-with-resources for Scanner to ensure it's closed
        try (Scanner scanner = new Scanner(System.in)) {
             // This try-catch block demonstrates class-wide exception handling
            try {
                String command;
                do {
                    System.out.print("Enter command (add, sort, dispatch, status, exit): ");
                    command = scanner.next().toLowerCase(); // Read command

                    switch (command) {
                        case "add":
                            // Handle 'add' command: add <id> <destination> <weight>
                            try {
                                String id = scanner.next();
                                String destination = scanner.next();
                                double weight = scanner.nextDouble();
                                Package newPkg = new Package(id, destination, weight);
                                addPackage(newPkg);
                            } catch (InputMismatchException e) {
                                System.err.println("Error: Invalid input format for 'add'. Expected: add <id> <destination> <weight(number)>");
                                scanner.nextLine(); // Consume the invalid input line
                            } catch (IllegalArgumentException e) {
                                System.err.println("Error creating package: " + e.getMessage());
                            } catch (Exception e) {
                                // Catch any other unexpected errors during add
                                System.err.println("An unexpected error occurred while adding package: " + e.getMessage());
                                e.printStackTrace(System.err); // Print stack trace for debugging
                            }
                            break;

                        case "sort":
                            // Handle 'sort' command
                            sortPackages();
                            break;

                        case "dispatch":
                            // Handle 'dispatch' command: dispatch <destination>
                            try {
                                String destination = scanner.next();
                                dispatchPackages(destination);
                            } catch (Exception e) {
                                // Catch any other unexpected errors during dispatch
                                System.err.println("An unexpected error occurred while dispatching: " + e.getMessage());
                                e.printStackTrace(System.err); // Print stack trace for debugging
                            }
                            break;

                        case "status":
                            // Handle 'status' command
                            displayStatus();
                            break;

                        case "exit":
                            // Handle 'exit' command
                            System.out.println("Exiting Package Processing Center simulation.");
                            break;

                        default:
                            // Handle unknown commands
                            System.err.println("Error: Unknown command '" + command + "'.");
                            // Consume the rest of the line if there was more input after the command
                            if (scanner.hasNextLine()) {
                                scanner.nextLine();
                            }
                            break;
                    }
                } while (!command.equals("exit"));

            } catch (Exception e) {
                // This catches any *uncaught* exception that propagates up to the run loop.
                // It demonstrates a top-level safety net.
                System.err.println("\n--- A critical error occurred! Simulation terminating. ---");
                System.err.println("Error details: " + e.getMessage());
                e.printStackTrace(System.err); // Print stack trace to error stream
            }

        } // Scanner is automatically closed here by try-with-resources
    }

    /**
     * Main method to start the simulation.
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        PackageProcessingCenter center = new PackageProcessingCenter();
        center.run();
    }
}
