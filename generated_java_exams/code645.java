/*
 * Exam Question #645
 * Generated on: 2025-05-12 16:19:17
 * Generated by: Account 5
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Advanced Support Ticket System
 * 
 * **Problem Description:**
 * 
 * You are tasked with developing a simple command-line based Support Ticket System for a small IT helpdesk. The system should allow users to:
 * 1.  Add new support tickets.
 * 2.  View all currently pending tickets.
 * 3.  Process (resolve) the next ticket in line based on the order they were submitted.
 * 4.  Exit the application.
 * 
 * The system must manage tickets in a First-In, First-Out (FIFO) manner for processing. It also needs to maintain a complete record of all tickets ever created (both pending and processed), although the 'view pending' option should only show those awaiting resolution.
 * 
 * **Technical Requirements:**
 * 
 * Your solution must be a single Java application that uses the command line for interaction. It **must** incorporate and demonstrate understanding of the following Java components:
 * 
 * *   `java.util.Queue`: To manage the order of tickets waiting to be processed (FIFO).
 * *   `java.util.ArrayList`: To store a collection of *all* tickets created during the application's runtime.
 * *   `java.util.List`: Use `List` as the declared type for the variable holding the `ArrayList` of all tickets.
 * *   `java.util.Scanner`: To read user input from the console.
 * *   `switch` statement: To handle the main menu navigation based on user choice.
 * *   `System.err`: To output error messages (e.g., invalid input, attempting to process when no tickets are pending).
 * *   `System.out`: To output normal messages (menu, prompts, success messages, ticket lists).
 * *   Class-wide exception handling: Use `try-catch` blocks within the main application logic to gracefully handle potential runtime errors, such as invalid input type or unexpected issues.
 * 
 * **Implementation Details:**
 * 
 * 1.  Create a `SupportTicket` class to represent a single ticket. It should have:
 *     *   A unique integer ID.
 *     *   A String description of the issue.
 *     *   A status (e.g., `PENDING`, `PROCESSED`). Consider using an `enum` for the status.
 *     *   Private fields with public getter methods.
 * 2.  Create a `SupportTicketSystem` class to manage the collection of tickets. It should have:
 *     *   A `Queue` to hold tickets that are currently pending processing.
 *     *   A `List` (implemented by `ArrayList`) to hold *all* tickets created.
 *     *   A mechanism to generate unique ticket IDs.
 *     *   Methods corresponding to the user actions: `addTicket(String description)`, `viewPendingTickets()`, `processNextTicket()`.
 *     *   These methods should encapsulate the logic for interacting with the `Queue` and `List`.
 * 3.  In your main application class (containing the `main` method):
 *     *   Create an instance of `SupportTicketSystem`.
 *     *   Implement a menu-driven loop using `Scanner` for input.
 *     *   Use a `switch` statement to handle the user's menu choice.
 *     *   Include basic input validation (e.g., checking if the input is an integer for the menu choice). If input is invalid, print an error to `System.err` and prompt again or continue the loop.
 *     *   Wrap the core interaction loop (reading input and processing choice) within a `try-catch` block to catch exceptions like `InputMismatchException` or any other unexpected errors, printing error details to `System.err`.
 *     *   When processing a ticket: if the queue is empty, print an error message to `System.err`. Otherwise, remove the next ticket from the queue, update its status (you might need to find it in the `allTickets` list to update its status property, or if the ticket object is mutable, update the object returned by the queue's `poll()` method), and print a success message to `System.out`.
 *     *   When viewing pending tickets: iterate through the `pendingTickets` queue and print details. If the queue is empty, print a message to `System.out`.
 *     *   Ensure proper resource management (e.g., closing the `Scanner`).
 *     *   Use meaningful variable names, follow Java naming conventions, and add comments where necessary for clarity.
 * 
 * **Expected Output:**
 * 
 * The system should present a clear menu. User interactions and system responses should be printed to `System.out`. Error conditions (like invalid input or trying to process an empty queue) must be indicated using `System.err`.
 * 
 * Example interaction flow:
 * 
 * ```
 * --- Support Ticket System ---
 * 1. Add New Ticket
 * 2. View Pending Tickets
 * 3. Process Next Ticket
 * 4. Exit
 * Enter your choice: 1
 * Enter ticket description: My printer is not working.
 * Ticket #1 added.
 * 
 * --- Support Ticket System ---
 * 1. Add New Ticket
 * 2. View Pending Tickets
 * 3. Process Next Ticket
 * 4. Exit
 * Enter your choice: 1
 * Enter ticket description: Cannot access email.
 * Ticket #2 added.
 * 
 * --- Support Ticket System ---
 * 1. Add New Ticket
 * 2. View Pending Tickets
 * 3. Process Next Ticket
 * 4. Exit
 * Enter your choice: 2
 * --- Pending Tickets ---
 * Ticket ID: 1, Description: My printer is not working.
 * Ticket ID: 2, Description: Cannot access email.
 * -------------------------
 * 
 * --- Support Ticket System ---
 * 1. Add New Ticket
 * 2. View Pending Tickets
 * 3. Process Next Ticket
 * 4. Exit
 * Enter your choice: 3
 * Processing ticket #1: My printer is not working. Status updated to PROCESSED.
 * 
 * --- Support Ticket System ---
 * 1. Add New Ticket
 * 2. View Pending Tickets
 * 3. Process Next Ticket
 * 4. Exit
 * Enter your choice: 2
 * --- Pending Tickets ---
 * Ticket ID: 2, Description: Cannot access email.
 * -------------------------
 * 
 * --- Support Ticket System ---
 * 1. Add New Ticket
 * 2. View Pending Tickets
 * 3. Process Next Ticket
 * 4. Exit
 * Enter your choice: 3
 * Processing ticket #2: Cannot access email. Status updated to PROCESSED.
 * 
 * --- Support Ticket System ---
 * 1. Add New Ticket
 * 2. View Pending Tickets
 * 3. Process Next Ticket
 * 4. Exit
 * Enter your choice: 3
 * No tickets currently pending processing.
 * 
 * --- Support Ticket System ---
 * 1. Add New Ticket
 * 2. View Pending Tickets
 * 3. Process Next Ticket
 * 4. Exit
 * Enter your choice: invalid
 * Error: Invalid input. Please enter a number.
 * 
 * --- Support Ticket System ---
 * 1. Add New Ticket
 * 2. View Pending Tickets
 * 3. Process Next Ticket
 * 4. Exit
 * Enter your choice: 5
 * Error: Invalid choice. Please enter a number between 1 and 4.
 * 
 * --- Support Ticket System ---
 * 1. Add New Ticket
 * 2. View Pending Tickets
 * 3. Process Next Ticket
 * 4. Exit
 * Enter your choice: 4
 * Exiting Support Ticket System.
 * ```
 * 
 * Your solution should be provided as a single block of complete, runnable Java code.
 * 
 * **Evaluation Criteria:**
 * 
 * *   Correctness of implementation for all features.
 * *   Proper usage of `Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.err`, `System.out`, and `try-catch`.
 * *   Adherence to best practices (encapsulation, naming, comments).
 * *   Effective error handling and input validation.
 * *   Code structure and readability.
 *
 * EXPLANATION:
 * This solution implements a basic Support Ticket System, demonstrating the required Java concepts in a practical scenario.
 * 
 * 1.  **`SupportTicket` Class:**
 *     *   Represents a single ticket with `id`, `description`, and `status`.
 *     *   Uses an `enum` (`TicketStatus`) for status, providing type safety and readability.
 *     *   Fields are `private` and accessed via public getters, demonstrating encapsulation.
 *     *   Includes a `toString()` method for easy printing.
 * 
 * 2.  **`SupportTicketSystem` Class:**
 *     *   This class manages the collection of tickets.
 *     *   `private Queue<SupportTicket> pendingTickets;`: Declared as a `Queue` interface type, but instantiated with `LinkedList`. `LinkedList` is a common implementation of `Queue` and `List`, providing FIFO behavior suitable for ticket processing. This demonstrates using an interface type for flexibility.
 *     *   `private List<SupportTicket> allTickets;`: Declared as a `List` interface type, instantiated with `ArrayList`. This list keeps a record of *all* tickets ever created, demonstrating the use of `List` and `ArrayList`.
 *     *   `private int nextTicketId;`: Used to generate unique IDs for new tickets.
 *     *   `addTicket(String description)`: Creates a new `SupportTicket`, adds it to both the `allTickets` list and the `pendingTickets` queue (`offer()` is used for the queue as it's generally safer than `add()` in capacity-constrained queues, though `LinkedList` is not capacity-constrained; it's good practice). Includes basic validation for the description.
 *     *   `viewPendingTickets()`: Iterates through the `pendingTickets` queue using a `for-each` loop. This iterates over the elements without removing them, which is the desired behavior for viewing. Checks if the queue is empty before iterating.
 *     *   `processNextTicket()`: Uses `pendingTickets.poll()`. `poll()` retrieves and *removes* the head of the queue (the oldest ticket), adhering to the FIFO requirement. It returns `null` if the queue is empty, which is handled by printing an error message to `System.err`. If a ticket is retrieved, its status is updated to `PROCESSED`. Since the `SupportTicket` object is mutable and the object reference is stored in both the `Queue` and the `List`, updating the object retrieved from the queue also updates the object in the `allTickets` list.
 * 
 * 3.  **`SupportApp` Class (Main Application):**
 *     *   Contains the `main` method where execution begins.
 *     *   A `Scanner` is initialized to read user input.
 *     *   A `SupportTicketSystem` instance is created.
 *     *   A `while` loop keeps the application running until the user chooses to exit.
 *     *   **Class-wide Exception Handling (`try-catch`):** The core `while` loop logic (reading input and processing the choice) is wrapped in a `try-catch` block. This block specifically catches `InputMismatchException` (for non-integer input) and a general `Exception` to handle any other unexpected runtime errors. Error messages for exceptions are printed to `System.err`. The `finally` block ensures the `Scanner` is closed, releasing system resources.
 *     *   **Input Validation:** Inside the `try` block, a nested `try-catch` specifically handles `InputMismatchException` when reading the menu choice. It prints an error to `System.err` and consumes the invalid input to prevent an infinite loop.
 *     *   **`switch` Statement:** Controls the program flow based on the valid integer choice entered by the user, calling the appropriate method in the `SupportTicketSystem` or setting the `running` flag to false for exit. The `default` case handles valid integer inputs that are outside the menu range, printing an error to `System.err`.
 *     *   `System.out` is used for menu display, prompts, success messages, and listing tickets.
 *     *   `System.err` is used for error messages (invalid input, empty queue processing, unexpected exceptions).
 * 
 * This solution effectively integrates all required components, follows object-oriented principles like encapsulation, implements basic input validation and robust error handling, and simulates a realistic task management workflow using Queue for processing order and List for record-keeping.
 */

import java.util.ArrayList;
import java.util.LinkedList; // LinkedList implements Queue
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.InputMismatchException;

// Enum to represent the status of a support ticket
enum TicketStatus {
    PENDING,
    PROCESSED
}

// Represents a single support ticket
class SupportTicket {
    private int id;
    private String description;
    private TicketStatus status;

    // Constructor
    public SupportTicket(int id, String description) {
        this.id = id;
        this.description = description;
        this.status = TicketStatus.PENDING; // New tickets are pending by default
    }

    // Getters
    public int getId() {
        return id;
    }

    public String getDescription() {
        return description;
    }

    public TicketStatus getStatus() {
        return status;
    }

    // Method to update status (used when processing)
    public void setStatus(TicketStatus status) {
        this.status = status;
    }

    @Override
    public String toString() {
        return "Ticket ID: " + id + ", Description: " + description + ", Status: " + status;
    }
}

// Manages the collection and processing of support tickets
class SupportTicketSystem {
    // Queue for tickets awaiting processing (FIFO)
    private Queue<SupportTicket> pendingTickets;
    // List to store all tickets ever created (for record keeping/display)
    private List<SupportTicket> allTickets;
    // Counter for generating unique ticket IDs
    private int nextTicketId;

    // Constructor
    public SupportTicketSystem() {
        this.pendingTickets = new LinkedList<>(); // LinkedList is a common Queue implementation
        this.allTickets = new ArrayList<>();     // ArrayList for storing all tickets
        this.nextTicketId = 1;
    }

    /**
     * Adds a new support ticket to the system.
     *
     * @param description The description of the ticket issue.
     */
    public void addTicket(String description) {
        // Basic validation for description
        if (description == null || description.trim().isEmpty()) {
            System.err.println("Error: Ticket description cannot be empty.");
            return;
        }

        SupportTicket newTicket = new SupportTicket(nextTicketId++, description);
        allTickets.add(newTicket); // Add to the list of all tickets
        pendingTickets.offer(newTicket); // Add to the queue of pending tickets (offer is safer than add)
        System.out.println("Ticket #" + newTicket.getId() + " added.");
    }

    /**
     * Displays all tickets currently in the pending queue.
     */
    public void viewPendingTickets() {
        System.out.println("--- Pending Tickets ---");
        if (pendingTickets.isEmpty()) {
            System.out.println("No tickets currently pending processing.");
        } else {
            // Iterate through the queue without removing elements
            for (SupportTicket ticket : pendingTickets) {
                System.out.println(ticket);
            }
        }
        System.out.println("-------------------------");
    }

    /**
     * Processes the next ticket in the pending queue.
     */
    public void processNextTicket() {
        // poll() retrieves and removes the head of the queue, returns null if queue is empty
        SupportTicket ticketToProcess = pendingTickets.poll();

        if (ticketToProcess == null) {
            System.err.println("No tickets currently pending processing.");
        } else {
            // Update the status of the ticket. Since the object in the queue is the same
            // object in the allTickets list, updating one updates the other.
            ticketToProcess.setStatus(TicketStatus.PROCESSED);
            System.out.println("Processing ticket #" + ticketToProcess.getId() +
                               ": " + ticketToProcess.getDescription() +
                               ". Status updated to " + ticketToProcess.getStatus() + ".");

            // Note: Finding the ticket in allTickets list explicitly to update is unnecessary
            // if we modify the object returned by poll(), as it's a reference to the same object.
            // If SupportTicket were immutable, we would need to replace it in allTickets.
            // Example of finding in allTickets (not needed here due to mutable object):
            // for (SupportTicket ticket : allTickets) {
            //     if (ticket.getId() == ticketToProcess.getId()) {
            //         ticket.setStatus(TicketStatus.PROCESSED); // Update status
            //         break;
            //     }
            // }
        }
    }
}

// Main application class
public class SupportApp {

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        SupportTicketSystem system = new SupportTicketSystem();
        boolean running = true;

        System.out.println("--- Support Ticket System ---");

        // Class-wide exception handling for the main application loop
        try {
            while (running) {
                printMenu();

                int choice = -1;
                // Input validation for menu choice
                try {
                    System.out.print("Enter your choice: ");
                    choice = scanner.nextInt();
                    scanner.nextLine(); // Consume the newline character left by nextInt()
                } catch (InputMismatchException e) {
                    System.err.println("Error: Invalid input. Please enter a number.");
                    scanner.nextLine(); // Consume the invalid input to prevent infinite loop
                    continue; // Skip the rest of the loop and show menu again
                }

                // Switch statement for flow control based on user choice
                switch (choice) {
                    case 1:
                        System.out.print("Enter ticket description: ");
                        String description = scanner.nextLine();
                        system.addTicket(description);
                        break;
                    case 2:
                        system.viewPendingTickets();
                        break;
                    case 3:
                        system.processNextTicket();
                        break;
                    case 4:
                        running = false;
                        System.out.println("Exiting Support Ticket System.");
                        break;
                    default:
                        // Handle choices outside the valid range
                        System.err.println("Error: Invalid choice. Please enter a number between 1 and 4.");
                        break;
                }
                System.out.println(); // Add a newline for better readability between interactions
            }
        } catch (Exception e) {
            // Catch any other unexpected exceptions during the main loop
            System.err.println("An unexpected error occurred: " + e.getMessage());
            e.printStackTrace(System.err); // Print stack trace to System.err
        } finally {
            // Ensure the scanner is closed regardless of exceptions
            if (scanner != null) {
                scanner.close();
            }
        }
    }

    /**
     * Prints the main menu options to the console.
     */
    private static void printMenu() {
        System.out.println("--- Support Ticket System ---");
        System.out.println("1. Add New Ticket");
        System.out.println("2. View Pending Tickets");
        System.out.println("3. Process Next Ticket");
        System.out.println("4. Exit");
    }
}
