/*
 * Exam Question #666
 * Generated on: 2025-05-12 16:22:37
 * Generated by: Account 3
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Advanced Ticket Management System
 * 
 * **Scenario:**
 * 
 * You are tasked with developing a simplified Customer Support Ticket Management System. The system should allow users (simulating support staff) to manage customer tickets through a command-line interface. New tickets arrive and are placed in a queue for processing. Support staff can assign the next available ticket from the queue, resolve assigned tickets, and view the status of all tickets or just the new ones waiting in the queue.
 * 
 * **Requirements:**
 * 
 * 1.  **Data Structures:**
 *     *   Maintain a `Queue` to hold newly submitted tickets waiting to be assigned.
 *     *   Maintain a `List` (specifically using `ArrayList` as the implementation) to store *all* tickets created in the system, regardless of their current status.
 * 2.  **Ticket Representation:**
 *     *   Create a `Ticket` class with the following properties:
 *         *   A unique integer ID (automatically generated).
 *         *   A String description of the issue.
 *         *   A status (e.g., `NEW`, `ASSIGNED`, `RESOLVED`). Use an `enum` for the status.
 *     *   The `Ticket` class should encapsulate its data (private fields) and provide methods to get properties and update the status.
 * 3.  **System Functionality:**
 *     *   Implement a main class (e.g., `TicketManagementSystem`) that contains the `main` method and manages the ticket collections.
 *     *   Provide the following operations via a command-line menu:
 *         *   **Add New Ticket:** Prompt the user for a ticket description, create a `Ticket` object, add it to both the new tickets `Queue` and the master `List`. Assign a unique ID.
 *         *   **Assign Next Ticket:** Take the next ticket from the `Queue`, change its status to `ASSIGNED`, and print confirmation. Handle the case where the queue is empty.
 *         *   **Resolve Ticket:** Prompt the user for a ticket ID. Find the ticket in the master `List`. If found and its status is `ASSIGNED`, change its status to `RESOLVED` and print confirmation. Handle cases where the ID is not found or the ticket is not in the `ASSIGNED` status.
 *         *   **View All Tickets:** Print details (ID, Description, Status) of all tickets in the master `List`.
 *         *   **View New Tickets:** Print details (ID, Description, Status) of tickets currently in the new tickets `Queue`.
 *         *   **Exit:** Terminate the program.
 * 4.  **User Interaction:**
 *     *   Use `java.util.Scanner` to read user input for menu choices and ticket details.
 *     *   Implement a menu-driven interface using a `while` loop and a `switch` statement to process user commands.
 * 5.  **Error Handling & Output:**
 *     *   Use `System.out` for normal program output (menu, confirmations, ticket details).
 *     *   Use `System.err` for error messages (e.g., invalid input, queue empty, ticket not found, invalid status for resolution).
 *     *   Implement class-wide exception handling using a `try-catch` block in the main operational loop to catch unexpected errors. Additionally, handle specific input errors (`InputMismatchException`) during `Scanner` operations.
 * 6.  **Best Practices:**
 *     *   Use meaningful variable and method names.
 *     *   Include appropriate comments and documentation (brief Javadoc is sufficient).
 *     *   Ensure proper encapsulation in the `Ticket` class.
 *     *   Validate user input where necessary (e.g., for ticket IDs).
 * 
 * **Expected Output:**
 * 
 * The program should present a menu, accept user input, perform the requested action, and provide feedback. Errors should be reported to `System.err`.
 * 
 * ```
 * --- Ticket Management System ---
 * 1. Add New Ticket
 * 2. Assign Next Ticket
 * 3. Resolve Ticket
 * 4. View All Tickets
 * 5. View New Tickets
 * 6. Exit
 * Enter your choice: 1
 * Enter ticket description: User cannot log in
 * Ticket 1 added.
 * 
 * --- Ticket Management System ---
 * ... (menu repeats)
 * Enter your choice: 1
 * Enter ticket description: Email not received
 * Ticket 2 added.
 * 
 * --- Ticket Management System ---
 * ... (menu repeats)
 * Enter your choice: 5
 * New Tickets:
 * ID: 1, Status: NEW, Description: User cannot log in
 * ID: 2, Status: NEW, Description: Email not received
 * 
 * --- Ticket Management System ---
 * ... (menu repeats)
 * Enter your choice: 2
 * Ticket 1 assigned.
 * 
 * --- Ticket Management System ---
 * ... (menu repeats)
 * Enter your choice: 5
 * New Tickets:
 * ID: 2, Status: NEW, Description: Email not received
 * 
 * --- Ticket Management System ---
 * ... (menu repeats)
 * Enter your choice: 4
 * All Tickets:
 * ID: 1, Status: ASSIGNED, Description: User cannot log in
 * ID: 2, Status: NEW, Description: Email not received
 * 
 * --- Ticket Management System ---
 * ... (menu repeats)
 * Enter your choice: 3
 * Enter ticket ID to resolve: 1
 * Ticket 1 resolved.
 * 
 * --- Ticket Management System ---
 * ... (menu repeats)
 * Enter your choice: 4
 * All Tickets:
 * ID: 1, Status: RESOLVED, Description: User cannot log in
 * ID: 2, Status: NEW, Description: Email not received
 * 
 * --- Ticket Management System ---
 * ... (menu repeats)
 * Enter your choice: 2
 * Error: No new tickets in the queue. (Output to System.err)
 * 
 * --- Ticket Management System ---
 * ... (menu repeats)
 * Enter your choice: 3
 * Enter ticket ID to resolve: 99
 * Error: Ticket with ID 99 not found. (Output to System.err)
 * 
 * --- Ticket Management System ---
 * ... (menu repeats)
 * Enter your choice: 3
 * Enter ticket ID to resolve: 2
 * Error: Ticket with ID 2 is not currently assigned. (Output to System.err)
 * 
 * --- Ticket Management System ---
 * ... (menu repeats)
 * Enter your choice: InvalidInput (User types 'abc')
 * Error: Invalid input. Please enter a number. (Output to System.err)
 * 
 * --- Ticket Management System ---
 * ... (menu repeats)
 * Enter your choice: 6
 * Exiting system.
 * ```
 * 
 * **Constraints:**
 * 
 * *   Adhere strictly to the required Java components listed.
 * *   The solution should be contained within a few classes (`TicketStatus` enum, `Ticket` class, and the main `TicketManagementSystem` class).
 * 
 * **Evaluation:**
 * 
 * Your solution will be evaluated based on:
 * *   Correct usage of `Queue`, `ArrayList`, `List`, `Scanner`, `switch`.
 * *   Proper implementation of the `Ticket` class with encapsulation.
 * *   Correct implementation of the menu operations.
 * *   Effective use of `System.out` and `System.err`.
 * *   Robust error handling using `try-catch`, including specific `InputMismatchException` handling and a general `Exception` catch for the main loop.
 * *   Code readability, meaningful names, and basic documentation.
 *
 * EXPLANATION:
 * This solution implements a simplified customer support ticket system demonstrating the required Java concepts.
 * 
 * 1.  **`TicketStatus` Enum:** Defines the possible states of a ticket (`NEW`, `ASSIGNED`, `RESOLVED`), providing type safety and readability compared to using raw strings or integers for status.
 * 2.  **`Ticket` Class:**
 *     *   Represents a single support ticket.
 *     *   Encapsulates data (`id`, `description`, `status`) using `private` fields.
 *     *   Provides `public` getter methods (`getId`, `getDescription`, `getStatus`).
 *     *   Includes methods (`assign`, `resolve`) to manage the ticket's status, ensuring status changes are controlled internally.
 *     *   Overrides `toString()` for easy printing of ticket details.
 * 3.  **`TicketManagementSystem` Class:**
 *     *   **Data Structures:**
 *         *   `newTicketsQueue`: Declared as `Queue<Ticket>` and instantiated as `new LinkedList<>()`. `LinkedList` is a common implementation of the `Queue` interface, providing FIFO (First-In, First-Out) behavior suitable for a waiting list of new tickets.
 *         *   `allTicketsList`: Declared as `List<Ticket>` and instantiated as `new ArrayList<>()`. This demonstrates using the `List` interface while leveraging the dynamic array capabilities of `ArrayList` to store all tickets created in the system, allowing easy iteration and searching.
 *         *   `nextTicketId`: A simple counter to ensure each ticket gets a unique ID.
 *     *   **Methods:**
 *         *   `addTicket()`: Creates a `Ticket` object, adds it to *both* the `newTicketsQueue` (using `offer()`) and the `allTicketsList` (using `add()`).
 *         *   `assignNextTicket()`: Uses `newTicketsQueue.poll()` to retrieve and remove the next ticket from the queue. It checks if the result is `null` to handle an empty queue, printing an error to `System.err`. If a ticket is retrieved, its status is updated using the `assign()` method.
 *         *   `resolveTicket()`: Iterates through the `allTicketsList` to find the ticket by ID using a helper method `findTicketById`. It performs validation checks: if the ticket is not found (`System.err`) or if its status is not `ASSIGNED` (`System.err`). If valid, it calls the `resolve()` method on the `Ticket` object.
 *         *   `findTicketById()`: A `private` helper method to search the `allTicketsList` for a ticket with a matching ID.
 *         *   `viewAllTickets()`: Iterates through the `allTicketsList` and prints each ticket's details using its `toString()` method. Handles the case of an empty list.
 *         *   `viewNewTickets()`: Iterates through the `newTicketsQueue` and prints each ticket's details. Iterating directly over a `Queue` using an enhanced for loop provides a view without removing elements, which is suitable here. Handles the case of an empty queue.
 *     *   **`main` Method:**
 *         *   Sets up the `TicketManagementSystem` and `Scanner`.
 *         *   Uses a `while` loop to keep the system running until the user chooses to exit.
 *         *   **Class-wide Exception Handling:** The core `while` loop that drives the application is wrapped in a `try-catch(Exception e)` block. This provides a safety net for any unexpected runtime errors that might occur during the program's execution, printing a general error message and the stack trace to `System.err`.
 *         *   **User Input and `switch`:** Inside the loop, it displays a menu and reads the user's choice using `scanner.nextInt()`. A `switch` statement is used to direct the program flow based on the user's numerical input, calling the appropriate methods in the `TicketManagementSystem` instance.
 *         *   **Specific Input Error Handling:** A nested `try-catch(InputMismatchException e)` block is used specifically around `scanner.nextInt()` calls. This handles cases where the user enters non-integer input when a number is expected. It prints a specific error message to `System.err`, consumes the invalid input using `scanner.next()`, and uses `continue` to restart the loop, prompting the menu again. A `finally` block is used after the `scanner.nextInt()` try-catch to ensure `scanner.nextLine()` is called to consume the leftover newline character, preventing issues in subsequent `scanner.nextLine()` calls for descriptions.
 *         *   `System.out` is used for the menu, successful operation messages, and ticket listings.
 *         *   `System.err` is used for all error conditions identified (invalid choice, empty queue, ticket not found, incorrect status for resolution, invalid input type).
 *         *   The `scanner` is closed in a `finally` block after the main `try-catch` to ensure resources are released when the program terminates, regardless of whether an exception occurred or the user exited normally.
 * 
 * This structure effectively utilizes all required components in a practical context, demonstrates proper data structure choices, encapsulation, flow control, and robust error handling as requested.
 */

import java.util.ArrayList;
import java.util.LinkedList; // LinkedList implements Queue
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.InputMismatchException;

// Enum for Ticket Status
enum TicketStatus {
    NEW, ASSIGNED, RESOLVED
}

// Ticket class representing a support ticket
class Ticket {
    private int id;
    private String description;
    private TicketStatus status;

    /**
     * Constructor for Ticket.
     * @param id The unique ID of the ticket.
     * @param description The description of the issue.
     */
    public Ticket(int id, String description) {
        this.id = id;
        this.description = description;
        this.status = TicketStatus.NEW; // New tickets start with NEW status
    }

    // Getters
    public int getId() {
        return id;
    }

    public String getDescription() {
        return description;
    }

    public TicketStatus getStatus() {
        return status;
    }

    /**
     * Sets the status of the ticket to ASSIGNED.
     */
    public void assign() {
        this.status = TicketStatus.ASSIGNED;
    }

    /**
     * Sets the status of the ticket to RESOLVED.
     */
    public void resolve() {
        this.status = TicketStatus.RESOLVED;
    }

    @Override
    public String toString() {
        return String.format("ID: %d, Status: %s, Description: %s", id, status, description);
    }
}

// Main class managing the ticket system
public class TicketManagementSystem {

    // Use Queue for tickets waiting to be assigned (FIFO)
    private Queue<Ticket> newTicketsQueue;

    // Use List to store all tickets for easy lookup/viewing
    // Use ArrayList as the concrete implementation
    private List<Ticket> allTicketsList;

    private int nextTicketId; // Counter for unique ticket IDs

    /**
     * Constructor initializes the ticket collections and ID counter.
     */
    public TicketManagementSystem() {
        newTicketsQueue = new LinkedList<>(); // LinkedList implements Queue
        allTicketsList = new ArrayList<>();
        nextTicketId = 1; // Start IDs from 1
    }

    /**
     * Adds a new ticket to the system.
     * @param description The description of the new ticket.
     */
    public void addTicket(String description) {
        Ticket newTicket = new Ticket(nextTicketId++, description);
        newTicketsQueue.offer(newTicket); // Add to the end of the queue
        allTicketsList.add(newTicket); // Add to the master list
        System.out.println("Ticket " + newTicket.getId() + " added.");
    }

    /**
     * Assigns the next available ticket from the queue.
     * Changes its status to ASSIGNED.
     */
    public void assignNextTicket() {
        Ticket ticketToAssign = newTicketsQueue.poll(); // Get and remove the head of the queue

        if (ticketToAssign == null) {
            System.err.println("Error: No new tickets in the queue.");
        } else {
            ticketToAssign.assign(); // Update status in the object (which is also in allTicketsList)
            System.out.println("Ticket " + ticketToAssign.getId() + " assigned.");
        }
    }

    /**
     * Resolves a ticket by its ID.
     * Changes its status to RESOLVED if found and currently ASSIGNED.
     * @param ticketId The ID of the ticket to resolve.
     */
    public void resolveTicket(int ticketId) {
        Ticket ticketToResolve = findTicketById(ticketId);

        if (ticketToResolve == null) {
            System.err.println("Error: Ticket with ID " + ticketId + " not found.");
        } else if (ticketToResolve.getStatus() != TicketStatus.ASSIGNED) {
            System.err.println("Error: Ticket with ID " + ticketId + " is not currently assigned.");
        } else {
            ticketToResolve.resolve(); // Update status
            System.out.println("Ticket " + ticketId + " resolved.");
        }
    }

    /**
     * Finds a ticket in the master list by its ID.
     * @param ticketId The ID to search for.
     * @return The Ticket object if found, null otherwise.
     */
    private Ticket findTicketById(int ticketId) {
        // Iterate through the List to find the ticket by ID
        for (Ticket ticket : allTicketsList) {
            if (ticket.getId() == ticketId) {
                return ticket;
            }
        }
        return null; // Ticket not found
    }

    /**
     * Prints details of all tickets in the system.
     */
    public void viewAllTickets() {
        if (allTicketsList.isEmpty()) {
            System.out.println("No tickets in the system yet.");
        } else {
            System.out.println("All Tickets:");
            // Iterate through the List
            for (Ticket ticket : allTicketsList) {
                System.out.println(ticket); // Uses Ticket's toString()
            }
        }
    }

    /**
     * Prints details of tickets currently in the new tickets queue.
     */
    public void viewNewTickets() {
        if (newTicketsQueue.isEmpty()) {
            System.out.println("No new tickets waiting in the queue.");
        } else {
            System.out.println("New Tickets:");
            // Iterate through the Queue (using an enhanced for loop which peeks elements)
            for (Ticket ticket : newTicketsQueue) {
                System.out.println(ticket); // Uses Ticket's toString()
            }
        }
    }

    /**
     * Displays the main menu to the user.
     */
    private void displayMenu() {
        System.out.println("\n--- Ticket Management System ---");
        System.out.println("1. Add New Ticket");
        System.out.println("2. Assign Next Ticket");
        System.out.println("3. Resolve Ticket");
        System.out.println("4. View All Tickets");
        System.out.println("5. View New Tickets");
        System.out.println("6. Exit");
        System.out.print("Enter your choice: ");
    }

    public static void main(String[] args) {
        TicketManagementSystem system = new TicketManagementSystem();
        Scanner scanner = new Scanner(System.in);
        boolean running = true;

        // Class-wide exception handling for the main operational loop
        try {
            while (running) {
                system.displayMenu();

                int choice = -1; // Default invalid choice
                try {
                    choice = scanner.nextInt(); // Read integer choice
                } catch (InputMismatchException e) {
                    System.err.println("Error: Invalid input. Please enter a number.");
                    scanner.next(); // Consume the invalid input
                    continue; // Skip the rest of the loop and show menu again
                } finally {
                    scanner.nextLine(); // Consume the newline character left by nextInt()
                }

                // Switch statement for flow control based on user choice
                switch (choice) {
                    case 1:
                        System.out.print("Enter ticket description: ");
                        String description = scanner.nextLine();
                        if (description == null || description.trim().isEmpty()) {
                             System.err.println("Error: Description cannot be empty.");
                        } else {
                            system.addTicket(description.trim());
                        }
                        break;
                    case 2:
                        system.assignNextTicket();
                        break;
                    case 3:
                        System.out.print("Enter ticket ID to resolve: ");
                        int ticketIdToResolve = -1;
                        try {
                            ticketIdToResolve = scanner.nextInt();
                            scanner.nextLine(); // Consume newline
                            system.resolveTicket(ticketIdToResolve);
                        } catch (InputMismatchException e) {
                             System.err.println("Error: Invalid ticket ID. Please enter a number.");
                             scanner.next(); // Consume invalid input
                        } finally {
                             // Ensure newline is consumed even if exception occurs before nextLine()
                             if (scanner.hasNextLine()) scanner.nextLine();
                        }
                        break;
                    case 4:
                        system.viewAllTickets();
                        break;
                    case 5:
                        system.viewNewTickets();
                        break;
                    case 6:
                        running = false;
                        System.out.println("Exiting system.");
                        break;
                    default:
                        System.err.println("Error: Invalid choice. Please enter a number between 1 and 6.");
                }
            }
        } catch (Exception e) {
            // Catch any other unexpected exceptions during the main loop operation
            System.err.println("An unexpected error occurred: " + e.getMessage());
            e.printStackTrace(); // Print stack trace for debugging unexpected errors
        } finally {
            scanner.close(); // Close the scanner when the application exits
            System.out.println("Scanner closed.");
        }
    }
}
