/*
 * Exam Question #602
 * Generated on: 2025-05-12 16:13:27
 * Generated by: Account 3
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Healthcare Appointment Scheduling System
 * 
 * **Objective:** Implement a simplified command-line healthcare appointment scheduling system that manages patient check-ins, scheduled appointments, and patient processing. This task requires you to demonstrate proficiency in core Java data structures, input/output handling, control flow, and exception management.
 * 
 * **Scenario:** Patients arrive at a clinic and check in, joining a waiting queue. Separately, appointments are scheduled. When a doctor is ready, the next patient from the waiting queue is "processed" (simulating being called for their appointment). The system should track patients in the waiting queue, scheduled appointments, and patients who have been processed.
 * 
 * **Requirements:**
 * 
 * 1.  **Data Structures:**
 *     *   Use a `java.util.Queue` to manage patients who have checked in and are waiting.
 *     *   Use a `java.util.List` (implemented by `java.util.ArrayList`) to store scheduled appointments.
 *     *   Use a `java.util.ArrayList` to store patients who have been processed.
 * 2.  **Classes:**
 *     *   Create a `Patient` class with private fields: `id` (integer), `name` (String). Implement a constructor and public getter methods. The `id` should be automatically generated and unique for each new patient.
 *     *   Create an `Appointment` class with private fields: `patientId` (integer - the ID of the patient), `doctor` (String), `time` (String - simplified representation like "10:00 AM"). Implement a constructor and public getter methods.
 *     *   Create a main class, `AppointmentScheduler`, which contains the `main` method and manages the `Queue`, `List`, and `ArrayList` instances.
 * 3.  **Functionality (via a command-line menu):**
 *     *   **1. Add Patient to Waiting Queue:** Prompt for the patient's name. Create a `Patient` object with a unique ID and add it to the waiting queue. Display the patient's assigned ID and confirmation.
 *     *   **2. Schedule New Appointment:** Prompt for the patient ID (that this appointment is for), doctor's name, and time. Create an `Appointment` object and add it to the list of scheduled appointments. Display confirmation. (Note: For simplicity, you do *not* need to validate if the patient ID exists in the system).
 *     *   **3. Process Next Patient from Queue:** Remove the patient at the front of the waiting queue. Move this patient to the list of processed patients. Display the name of the patient being processed. If the queue is empty, display an error message.
 *     *   **4. View System Status:** Display the current number of patients in the waiting queue, the total number of scheduled appointments, and the number of patients who have been processed.
 *     *   **5. Exit:** Terminate the program.
 * 4.  **Input/Output:**
 *     *   Use `java.util.Scanner` to read all user input (menu choices, patient name, patient ID, doctor, time).
 *     *   Use `System.out` for displaying the menu, prompts, successful operations, and system status.
 *     *   Use `System.err` to display error messages (e.g., invalid input, attempting to process from an empty queue).
 * 5.  **Control Flow:**
 *     *   Use a `switch` statement to handle the user's menu choice.
 *     *   Use a loop to keep the menu running until the user chooses to exit.
 * 6.  **Error Handling:**
 *     *   Implement class-wide exception handling using `try-catch` blocks, particularly around user input operations that might throw exceptions (e.g., `InputMismatchException` when expecting an integer).
 *     *   Handle the specific case of trying to process a patient from an empty queue.
 *     *   Provide informative error messages using `System.err`.
 * 7.  **Best Practices:**
 *     *   Apply proper encapsulation (private fields, public getters/setters).
 *     *   Use meaningful variable and method names.
 *     *   Include appropriate comments and documentation (e.g., Javadoc for classes/methods).
 *     *   Implement basic input validation (e.g., ensuring numeric input where required).
 *     *   Ensure clean code structure (e.g., break down functionality into separate methods).
 * 
 * **Expected Output:**
 * 
 * The program should present a menu. User interaction should involve prompts for necessary information. Output should clearly indicate the results of actions (patient added, appointment scheduled, patient processed, status displayed) or error conditions.
 * 
 * Example Interaction Snippet:
 * 
 * ```
 * --- Appointment Scheduler Menu ---
 * 1. Add Patient to Waiting Queue
 * 2. Schedule New Appointment
 * 3. Process Next Patient from Queue
 * 4. View System Status
 * 5. Exit
 * Enter your choice: 1
 * Enter patient name: Alice
 * Patient Alice added to waiting queue. Assigned ID: 1
 * 
 * --- Appointment Scheduler Menu ---
 * ...
 * Enter your choice: 2
 * Enter patient ID for appointment: 1
 * Enter doctor's name: Dr. Smith
 * Enter appointment time (e.g., 10:00 AM): 10:30 AM
 * Appointment scheduled for Patient ID 1 with Dr. Smith at 10:30 AM.
 * 
 * --- Appointment Scheduler Menu ---
 * ...
 * Enter your choice: 3
 * Processing patient: Alice (ID: 1)
 * Queue is now empty.
 * 
 * --- Appointment Scheduler Menu ---
 * ...
 * Enter your choice: 4
 * --- System Status ---
 * Patients in Waiting Queue: 0
 * Scheduled Appointments: 1
 * Processed Patients: 1
 * ---------------------
 * 
 * --- Appointment Scheduler Menu ---
 * ...
 * Enter your choice: 6
 * Error: Invalid choice. Please enter a number between 1 and 5.
 * 
 * --- Appointment Scheduler Menu ---
 * ...
 * Enter your choice: abc
 * Error: Invalid input. Please enter a number.
 * ```
 *
 * EXPLANATION:
 * The provided solution implements a simplified Healthcare Appointment Scheduling System as requested, demonstrating the usage of various Java concepts.
 * 
 * 1.  **Class Structure and Encapsulation:**
 *     *   `Patient` class: Represents a patient with a unique `id` and `name`. The `id` is automatically generated using a static counter (`nextId`), ensuring uniqueness. Fields are `private`, and public `getter` methods provide controlled access.
 *     *   `Appointment` class: Represents a scheduled appointment linked to a patient via `patientId`, along with `doctor` and `time`. Fields are `private`, and public `getter` methods are provided.
 *     *   `AppointmentScheduler` class: This is the main class that orchestrates the system. It holds instances of the core data structures (`waitingQueue`, `scheduledAppointments`, `processedPatients`) and the `Scanner`. Its methods (`addPatientToQueue`, `scheduleAppointment`, `processNextPatient`, `displayStatus`) encapsulate the system's logic, operating on its internal state.
 * 
 * 2.  **Data Structures:**
 *     *   `waitingQueue`: Declared as `Queue<Patient>` and instantiated as `LinkedList<Patient>`. The `Queue` interface methods (`offer` to add, `poll` to remove from the head, `isEmpty` to check if empty) are used to manage patients waiting for processing in a First-In, First-Out (FIFO) manner.
 *     *   `scheduledAppointments`: Declared as `List<Appointment>` and instantiated as `ArrayList<Appointment>`. The `List` interface method `add` is used to store appointments. `ArrayList` provides dynamic resizing and efficient element access (though not heavily used in this simple example beyond adding and checking size).
 *     *   `processedPatients`: Declared and instantiated as `ArrayList<Patient>`. The `ArrayList` method `add` is used to store patients after they have been processed. This demonstrates the use of `ArrayList` directly.
 * 
 * 3.  **Input/Output and Control Flow:**
 *     *   `Scanner`: An instance of `Scanner` is used to read user input from `System.in` throughout the application. Care is taken to handle the newline character left by `scanner.nextInt()` by calling `scanner.nextLine()` immediately after, preventing issues with subsequent `nextLine()` calls.
 *     *   `System.out`: Used for printing the menu, prompts, success messages, and system status updates.
 *     *   `System.err`: Used specifically for printing error messages (e.g., invalid input, attempting an operation on an empty structure). This is good practice as it separates error output from standard output.
 *     *   `switch` statement: Used in the main loop to cleanly route execution based on the user's integer choice from the menu.
 *     *   `while` loop: Keeps the application running and the menu displayed until the user selects the 'Exit' option (choice 5).
 * 
 * 4.  **Exception Handling:**
 *     *   **Class-wide `try-catch`:** The main `while` loop in the `main` method is wrapped in a `try-catch-finally` block. While the inner `try-catch` handles most expected operational errors (like `InputMismatchException`), this outer block serves as a safety net for any unexpected exceptions that might occur, printing a critical error message to `System.err`.
 *     *   **Specific Exception Handling:** A `try-catch` block is specifically used around `scanner.nextInt()` calls in the `main` method and `scheduleAppointment` to catch `InputMismatchException` if the user enters non-integer input when an integer is expected. This block prints an informative error to `System.err` and consumes the invalid input from the scanner buffer to prevent an infinite loop.
 *     *   **Operational Error Handling:** The `processNextPatient` method explicitly checks if the `waitingQueue` is empty using `isEmpty()` before attempting to `poll()`. If it's empty, it prints an error message to `System.err` instead of throwing an exception (like `NoSuchElementException` which `remove()` would throw, but `poll()` gracefully returns `null`). Basic validation for empty strings is also included for patient name, doctor, and time.
 * 
 * 5.  **Best Practices:**
 *     *   Meaningful names (`waitingQueue`, `addPatientToQueue`, `processNextPatient`, etc.) make the code readable.
 *     *   Javadoc comments explain the purpose of classes and methods. Inline comments clarify specific logic points (like consuming the newline after `nextInt`).
 *     *   The code is structured into logical methods, improving organization and reusability.
 *     *   The `finally` block in `main` ensures that the `Scanner` resource is closed properly before the program terminates, preventing resource leaks.
 * 
 * This solution effectively integrates the required Java components within a practical scenario, demonstrating an understanding of object-oriented design, data structure usage, robust input handling, and layered exception management, fulfilling the requirements of a challenging exam task.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.InputMismatchException;

// Represents a patient in the system
class Patient {
    private int id;
    private String name;
    private static int nextId = 1; // Static counter for unique IDs

    /**
     * Constructs a new Patient with a unique ID.
     * @param name The name of the patient.
     */
    public Patient(String name) {
        this.id = nextId++; // Assign current ID and increment for next patient
        this.name = name;
    }

    // --- Getters ---
    public int getId() {
        return id;
    }

    public String getName() {
        return name;
    }

    @Override
    public String toString() {
        return name + " (ID: " + id + ")";
    }
}

// Represents a scheduled appointment
class Appointment {
    private int patientId;
    private String doctor;
    private String time;

    /**
     * Constructs a new Appointment.
     * @param patientId The ID of the patient for this appointment.
     * @param doctor The name of the doctor.
     * @param time The scheduled time (e.g., "10:00 AM").
     */
    public Appointment(int patientId, String doctor, String time) {
        this.patientId = patientId;
        this.doctor = doctor;
        this.time = time;
    }

    // --- Getters ---
    public int getPatientId() {
        return patientId;
    }

    public String getDoctor() {
        return doctor;
    }

    public String getTime() {
        return time;
    }

    @Override
    public String toString() {
        return "Patient ID: " + patientId + ", Doctor: " + doctor + ", Time: " + time;
    }
}

// Main class managing the scheduling system
public class AppointmentScheduler {
    // --- Data Structures ---
    private Queue<Patient> waitingQueue; // Patients checked in, waiting
    private List<Appointment> scheduledAppointments; // All scheduled appointments
    private List<Patient> processedPatients; // Patients who have been processed

    private Scanner scanner; // For user input

    /**
     * Constructs a new AppointmentScheduler, initializing data structures and scanner.
     */
    public AppointmentScheduler() {
        waitingQueue = new LinkedList<>(); // LinkedList implements Queue
        scheduledAppointments = new ArrayList<>(); // ArrayList implements List
        processedPatients = new ArrayList<>(); // ArrayList
        scanner = new Scanner(System.in);
    }

    /**
     * Displays the main menu options to the user.
     */
    private void displayMenu() {
        System.out.println("\n--- Appointment Scheduler Menu ---");
        System.out.println("1. Add Patient to Waiting Queue");
        System.out.println("2. Schedule New Appointment");
        System.out.println("3. Process Next Patient from Queue");
        System.out.println("4. View System Status");
        System.out.println("5. Exit");
        System.out.print("Enter your choice: ");
    }

    /**
     * Adds a new patient to the waiting queue.
     */
    private void addPatientToQueue() {
        System.out.print("Enter patient name: ");
        String name = scanner.nextLine(); // Read the whole line for name

        if (name == null || name.trim().isEmpty()) {
             System.err.println("Error: Patient name cannot be empty.");
             return;
        }

        Patient newPatient = new Patient(name.trim());
        waitingQueue.offer(newPatient); // Add patient to the end of the queue
        System.out.println("Patient " + newPatient.getName() + " added to waiting queue. Assigned ID: " + newPatient.getId());
    }

    /**
     * Schedules a new appointment.
     */
    private void scheduleAppointment() {
        int patientId = -1; // Use -1 as an invalid initial value
        System.out.print("Enter patient ID for appointment: ");

        try {
            patientId = scanner.nextInt();
            // Consume the rest of the line after reading the integer
            scanner.nextLine();
        } catch (InputMismatchException e) {
            System.err.println("Error: Invalid input for Patient ID. Please enter a number.");
            scanner.nextLine(); // Consume the invalid input to prevent infinite loop
            return; // Exit the method if input is invalid
        }

        System.out.print("Enter doctor's name: ");
        String doctor = scanner.nextLine();

        System.out.print("Enter appointment time (e.g., 10:00 AM): ");
        String time = scanner.nextLine();

        if (doctor == null || doctor.trim().isEmpty() || time == null || time.trim().isEmpty()) {
             System.err.println("Error: Doctor's name and time cannot be empty.");
             return;
        }


        Appointment newAppointment = new Appointment(patientId, doctor.trim(), time.trim());
        scheduledAppointments.add(newAppointment); // Add appointment to the list
        System.out.println("Appointment scheduled for " + newAppointment.toString() + ".");
    }

    /**
     * Processes the next patient from the waiting queue.
     */
    private void processNextPatient() {
        if (waitingQueue.isEmpty()) {
            System.err.println("Error: Waiting queue is empty. No patients to process.");
        } else {
            Patient processedPatient = waitingQueue.poll(); // Remove patient from the front of the queue
            processedPatients.add(processedPatient); // Add patient to the processed list
            System.out.println("Processing patient: " + processedPatient.toString());
        }
    }

    /**
     * Displays the current status of the system's data structures.
     */
    private void displayStatus() {
        System.out.println("\n--- System Status ---");
        System.out.println("Patients in Waiting Queue: " + waitingQueue.size());
        System.out.println("Scheduled Appointments: " + scheduledAppointments.size());
        System.out.println("Processed Patients: " + processedPatients.size());
        System.out.println("---------------------");
    }

    /**
     * Closes the scanner resource.
     */
    private void closeScanner() {
        if (scanner != null) {
            scanner.close();
        }
    }

    /**
     * The main entry point for the Appointment Scheduler application.
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        AppointmentScheduler scheduler = new AppointmentScheduler();
        int choice = -1;

        // Main application loop with class-wide exception handling
        try {
            while (choice != 5) {
                scheduler.displayMenu();

                try {
                    choice = scheduler.scanner.nextInt();
                    // Consume the newline character left by nextInt()
                    scheduler.scanner.nextLine();

                    // Use switch for menu options
                    switch (choice) {
                        case 1:
                            scheduler.addPatientToQueue();
                            break;
                        case 2:
                            scheduler.scheduleAppointment();
                            break;
                        case 3:
                            scheduler.processNextPatient();
                            break;
                        case 4:
                            scheduler.displayStatus();
                            break;
                        case 5:
                            System.out.println("Exiting Appointment Scheduler. Goodbye!");
                            break;
                        default:
                            System.err.println("Error: Invalid choice. Please enter a number between 1 and 5.");
                            break;
                    }
                } catch (InputMismatchException e) {
                    System.err.println("Error: Invalid input. Please enter a number.");
                    scheduler.scanner.nextLine(); // Consume the invalid input
                    choice = -1; // Reset choice to avoid infinite loop on invalid input
                } catch (Exception e) {
                    // Catch any other unexpected exceptions during operation
                    System.err.println("An unexpected error occurred: " + e.getMessage());
                    // e.printStackTrace(System.err); // Optional: for debugging
                }
            }
        } catch (Exception mainException) {
             // This catch block handles exceptions that might escape the inner loop,
             // though the inner loop's catch is designed to handle most operational errors.
             System.err.println("A critical system error occurred: " + mainException.getMessage());
             // mainException.printStackTrace(System.err); // Optional: for debugging
        } finally {
            // Ensure the scanner is closed when the program exits
            scheduler.closeScanner();
            System.out.println("Scanner closed."); // Confirmation
        }
    }
}
