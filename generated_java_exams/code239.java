/*
 * Exam Question #239
 * Generated on: 2025-05-11 22:37:38
 * Generated by: Account 2
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Restaurant Order Management System
 * 
 * **Scenario:**
 * 
 * You are tasked with developing a simplified backend system for a small restaurant's order management. The system should allow staff to view the menu, place new customer orders, process orders in the order they were received, and view the list of pending orders.
 * 
 * **Task:**
 * 
 * Implement a Java console application for this restaurant system.
 * 
 * **Specific Requirements:**
 * 
 * Your solution **must** utilize **ALL** of the following Java components:
 * 
 * 1.  `java.util.Queue`: To manage the pending customer orders in a First-In, First-Out (FIFO) manner.
 * 2.  `java.util.ArrayList`: To store the restaurant's fixed menu items and the list of items within a specific customer order.
 * 3.  `java.util.List` interface: Declare variables and method return types using the `List` interface where appropriate (e.g., for the menu and order items), demonstrating abstraction.
 * 4.  `java.util.Scanner`: To read user input from the console (menu choices, item details for orders).
 * 5.  `switch` statement: To control the flow of the main application menu based on user selection.
 * 6.  `System.err`: To output all error messages (e.g., invalid input, attempting to process an empty queue).
 * 7.  `System.out`: To output all normal messages (e.g., menu display, prompts, order details, queue status).
 * 8.  Class-wide exception handling with `try-catch` blocks: Implement exception handling in the main application loop to catch unexpected errors. Additionally, use specific `try-catch` blocks for handling potential input format errors (like non-numeric input) during order placement.
 * 
 * **Functional Requirements:**
 * 
 * The system should present a menu with the following options:
 * 
 * 1.  **Display Food Menu:** Show the list of available items with their IDs and prices.
 * 2.  **Place New Order:** Allow the user to add multiple items (by ID and quantity) to a single new order. The user should indicate when they are done adding items. Validate input (item ID exists, quantity is positive, input format is correct). Calculate the total price for the order. Add the completed order to the pending orders queue.
 * 3.  **Process Next Order:** Take the oldest pending order from the queue, display its details, and mark it as processed (remove it from the queue). If the queue is empty, display an error message.
 * 4.  **View Pending Orders:** Display a summary list of all orders currently waiting in the queue, showing their order ID, number of items, and total price. Do not remove orders from the queue when viewing.
 * 5.  **Exit:** Terminate the application.
 * 
 * **Implementation Details & Best Practices:**
 * 
 * -   Design appropriate classes for `MenuItem`, `OrderItem` (an item within an order with quantity), and `Order`.
 * -   Create a main class (e.g., `RestaurantSystem`) to manage the menu (a `List`/`ArrayList`), the order queue (`Queue`/`LinkedList`), and the application logic.
 * -   Use proper encapsulation (private fields, public getters/constructors).
 * -   Employ meaningful variable and method names.
 * -   Include basic comments to explain key parts of the code.
 * -   Perform input validation for user choices and order details.
 * -   Handle errors gracefully using `try-catch` and `System.err`.
 * -   Ensure the `Scanner` is handled correctly, especially after reading numbers.
 * 
 * **Expected Output:**
 * 
 * The output should clearly display the menu, prompts for input, order details, queue status, and error messages using `System.out` and `System.err` as specified.
 * 
 * *Hint: For simplicity in an exam setting, you may include all classes within a single `.java` file.*
 *
 * EXPLANATION:
 * This solution implements the Restaurant Order Management System according to the requirements, demonstrating the use of the specified Java components and best practices.
 * 
 * 1.  **`java.util.Queue`**: The `orderQueue` field in the `RestaurantSystem` class is declared as a `Queue<Order>` and initialized with a `LinkedList`. This structure is used to store pending customer orders, naturally enforcing a First-In, First-Out (FIFO) processing order.
 *     -   `orderQueue.offer(newOrder)` is used in `placeOrder` to add a new order to the tail of the queue.
 *     -   `orderQueue.poll()` is used in `processNextOrder` to retrieve and remove the order at the head of the queue.
 *     -   `orderQueue.isEmpty()` is used to check if there are any orders in the queue before attempting to process or view them.
 *     -   Iteration (`for (Order order : orderQueue)`) is used in `viewPendingOrders` to display queue contents without removing elements.
 * 
 * 2.  **`java.util.ArrayList`**:
 *     -   The `menu` field in `RestaurantSystem` is an `ArrayList<MenuItem>`, used to store the fixed list of available food items. Iteration over this `ArrayList` is used in `displayMenu` and `placeOrder` (to find items by ID).
 *     -   The `items` field within the `Order` class is an `ArrayList<OrderItem>`, used to store the specific items and quantities included in that particular order. This `ArrayList` is populated in `placeOrder` and iterated over in `processNextOrder` and `viewPendingOrders` (via the `Order.getItems()` method).
 * 
 * 3.  **`java.util.List` interface**:
 *     -   The `menu` field is declared as `List<MenuItem>`, even though it's instantiated as an `ArrayList`. This demonstrates programming to the interface, allowing flexibility to change the underlying implementation later if needed (e.g., to a `Vector`) without altering code that uses the `menu` variable.
 *     -   The `items` field within the `Order` class is declared as `List<OrderItem>`, similarly demonstrating the use of the interface. The `Order.getItems()` method also returns a `List<OrderItem>`, further promoting abstraction.
 * 
 * 4.  **`java.util.Scanner`**: A `Scanner` object is created in the `run()` method of `RestaurantSystem` to read user input from `System.in`. It's used to get the main menu choice and to read item details (ID and quantity) when placing an order. Careful handling with `scanner.nextLine()` is included after reading numbers (`nextInt()`) to consume the leftover newline character, preventing input issues in subsequent `nextLine()` calls. The scanner is closed in a `finally` block to release the resource.
 * 
 * 5.  **`switch` statement**: A `switch` statement in the `run()` method is used to direct the program's execution flow based on the integer choice entered by the user from the main menu options (1 through 5). The `default` case handles invalid integer inputs.
 * 
 * 6.  **`System.err`**: `System.err.println()` is used exclusively for printing error messages to the standard error stream. Examples include: invalid menu choices, trying to process an empty queue, invalid input format when adding items, item not found, non-positive quantity, `NumberFormatException` during input parsing, and general unexpected exceptions caught by the main `try-catch`. This helps distinguish error output from normal program output.
 * 
 * 7.  **`System.out`**: `System.out.println()` and `System.out.print()` are used for all standard program output, such as displaying the menu options, the food menu, prompts for input, confirmation messages, details of placed/processed orders, status messages (like "No pending orders"), and the exit message.
 * 
 * 8.  **Class-wide exception handling with `try-catch` blocks**:
 *     -   A broad `try-catch(Exception e)` block wraps the core `while(running)` loop within the `run()` method. This serves as a class-wide handler for unexpected runtime exceptions that might occur anywhere within the main application logic, preventing the program from crashing abruptly and providing a generic error message using `System.err`. A `finally` block ensures the `Scanner` is closed regardless of whether an exception occurred or the loop finished normally.
 *     -   A more specific `try-catch(InputMismatchException e)` is placed inside the `while` loop in `run()` specifically to handle cases where the user enters non-integer input when prompted for the main menu choice. This prevents a crash and allows the loop to continue after displaying an error.
 *     -   Another specific `try-catch(NumberFormatException e)` is used within the `placeOrder` method when parsing the item ID and quantity strings. This handles cases where the user enters non-integer values for these inputs, allowing the order placement process to continue by prompting again for the item. A general `catch(Exception e)` is also included in `placeOrder` for any other unexpected issues during item processing.
 * 
 * **Best Practices:**
 * 
 * -   **Encapsulation:** Classes (`MenuItem`, `OrderItem`, `Order`) have private fields and public getters and constructors to control access to their data. Defensive copying is used when returning the list of items from the `Order` class.
 * -   **Meaningful Names:** Variables (`orderQueue`, `nextOrderId`, `itemsForOrder`), methods (`displayMenu`, `placeOrder`, `processNextOrder`), and classes (`MenuItem`, `Order`, `RestaurantSystem`) have names that clearly indicate their purpose.
 * -   **Comments:** Basic comments are included to explain the purpose of classes, methods, and key code sections.
 * -   **Input Validation:** The code checks for valid menu choices, correct input format (ID quantity), positive quantity, and existence of the item ID on the menu.
 * -   **Proper Error Handling:** Errors are caught using `try-catch`, reported using `System.err`, and in many cases, the program is allowed to continue gracefully (e.g., after invalid input).
 * -   **Clean Code Structure:** The logic is divided into separate classes and methods, making the code modular and easier to understand.
 * 
 * The combination of these elements provides a robust solution for the simplified restaurant system and effectively demonstrates advanced Java concepts and best practices in a practical context.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.InputMismatchException;

// Represents a single item on the restaurant menu
class MenuItem {
    private int id;
    private String name;
    private double price;

    public MenuItem(int id, String name, double price) {
        this.id = id;
        this.name = name;
        this.price = price;
    }

    public int getId() { return id; }
    public String getName() { return name; }
    public double getPrice() { return price; }

    // Optional: toString for debugging/display
    @Override
    public String toString() {
        return id + ". " + name + " - $" + String.format("%.2f", price);
    }
}

// Represents an item included in a specific customer order
class OrderItem {
    private MenuItem menuItem;
    private int quantity;

    public OrderItem(MenuItem menuItem, int quantity) {
        this.menuItem = menuItem;
        this.quantity = quantity;
    }

    public MenuItem getMenuItem() { return menuItem; }
    public int getQuantity() { return quantity; }

    public double getSubtotal() {
        return menuItem.getPrice() * quantity;
    }

    // Optional: toString for debugging/display
    @Override
    public String toString() {
        return quantity + " x " + menuItem.getName() + " ($" + String.format("%.2f", getSubtotal()) + ")";
    }
}

// Represents a complete customer order
class Order {
    private int orderId;
    private List<OrderItem> items; // Use List interface, implemented by ArrayList
    private double totalPrice;

    public Order(int orderId, List<OrderItem> items, double totalPrice) {
        this.orderId = orderId;
        // Create a defensive copy of the items list to ensure encapsulation
        this.items = new ArrayList<>(items);
        this.totalPrice = totalPrice;
    }

    public int getOrderId() { return orderId; }
    // Return a defensive copy of the items list
    public List<OrderItem> getItems() { return new ArrayList<>(items); }
    public double getTotalPrice() { return totalPrice; }

    // toString method to easily display order details
    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        sb.append("Order #").append(orderId).append("\n");
        sb.append("Items:\n");
        // Iterate through the ArrayList implementing List
        for (OrderItem item : items) {
            sb.append("- ").append(item).append("\n"); // Uses OrderItem.toString()
        }
        sb.append("Total: $").append(String.format("%.2f", totalPrice));
        return sb.toString();
    }
}

// Main class managing the restaurant system logic
public class RestaurantSystem {

    private List<MenuItem> menu; // Use List interface, implemented by ArrayList
    private Queue<Order> orderQueue; // Use Queue interface, implemented by LinkedList
    private int nextOrderId;

    public RestaurantSystem() {
        // Initialize data structures
        menu = new ArrayList<>(); // ArrayList for menu items
        orderQueue = new LinkedList<>(); // LinkedList for the order queue (implements Queue)
        nextOrderId = 1; // Start order IDs from 1
        initializeMenu(); // Populate the initial menu
    }

    // Populate the initial menu with some items
    private void initializeMenu() {
        menu.add(new MenuItem(1, "Burger", 8.99));
        menu.add(new MenuItem(2, "Fries", 3.49));
        menu.add(new MenuItem(3, "Soda", 1.99));
        menu.add(new MenuItem(4, "Pizza (Slice)", 4.50));
        menu.add(new MenuItem(5, "Salad", 7.00));
        // More items could be added here
    }

    // Display the main menu options to the user
    private void displayMenuOptions() {
        System.out.println("\n--- Restaurant System Menu ---");
        System.out.println("1. Display Food Menu");
        System.out.println("2. Place New Order");
        System.out.println("3. Process Next Order");
        System.out.println("4. View Pending Orders");
        System.out.println("5. Exit");
        System.out.println("------------------------------");
    }

    // Display the food menu with IDs, names, and prices
    private void displayMenu() {
        System.out.println("\n--- Food Menu ---");
        if (menu.isEmpty()) {
            System.out.println("Menu is currently empty.");
            return;
        }
        // Iterate through the ArrayList implementing List to display menu items
        for (MenuItem item : menu) {
            System.out.println(item); // Uses MenuItem.toString()
        }
        System.out.println("-----------------");
    }

    // Handles the process of placing a new customer order
    private void placeOrder(Scanner scanner) {
        System.out.println("\n--- Place New Order ---");
        displayMenu(); // Show menu for reference

        List<OrderItem> itemsForOrder = new ArrayList<>(); // Use ArrayList to collect items for the current order
        double currentOrderTotal = 0;

        System.out.println("Enter Item ID and Quantity (e.g., 1 2) or type 'done' to finish.");

        // Loop to allow adding multiple items to one order
        while (true) {
            System.out.print("Add item (ID quantity or 'done'): ");
            String line = scanner.nextLine().trim();

            if (line.equalsIgnoreCase("done")) {
                if (itemsForOrder.isEmpty()) {
                    System.out.println("No items added. Order cancelled.");
                    return; // Exit placing order if no items were added
                }
                break; // Exit the item-adding loop to finalize the order
            }

            String[] parts = line.split(" ");
            // Basic input format validation
            if (parts.length != 2) {
                System.err.println("Invalid input format. Please enter Item ID and Quantity separated by a space."); // Use System.err
                continue; // Ask for input again
            }

            try {
                // Attempt to parse input as integers
                int itemId = Integer.parseInt(parts[0]);
                int quantity = Integer.parseInt(parts[1]);

                // Validate quantity
                if (quantity <= 0) {
                    System.err.println("Quantity must be a positive number."); // Use System.err
                    continue;
                }

                MenuItem selectedItem = null;
                // Find the menu item by ID by iterating through the menu (ArrayList)
                for (MenuItem item : menu) {
                    if (item.getId() == itemId) {
                        selectedItem = item;
                        break; // Found the item, exit loop
                    }
                }

                // Validate if item ID exists
                if (selectedItem == null) {
                    System.err.println("Item with ID " + itemId + " not found on the menu."); // Use System.err
                    continue;
                }

                // Item found and quantity is valid, create OrderItem and add to list
                OrderItem orderItem = new OrderItem(selectedItem, quantity);
                itemsForOrder.add(orderItem); // Add to the ArrayList for this specific order
                currentOrderTotal += orderItem.getSubtotal();
                System.out.println("-> Added: " + quantity + " x " + selectedItem.getName());

            } catch (NumberFormatException e) {
                // Handle cases where ID or quantity are not valid integers
                System.err.println("Invalid number format for Item ID or Quantity. Please enter integers."); // Use System.err
            } catch (Exception e) {
                // Catch any other unexpected exceptions during item adding
                System.err.println("An unexpected error occurred while adding item: " + e.getMessage()); // Use System.err
                // e.printStackTrace(); // Uncomment for detailed debugging if needed
            }
        }

        // If the loop finished and items were added, finalize and add order to the queue
        Order newOrder = new Order(nextOrderId++, itemsForOrder, currentOrderTotal);
        orderQueue.offer(newOrder); // Add the new order to the tail of the Queue (FIFO)
        System.out.println("\nOrder #" + newOrder.getOrderId() + " placed successfully!");
        System.out.println("Total: $" + String.format("%.2f", newOrder.getTotalPrice()));
    }

    // Processes the next order waiting in the queue (removes the head)
    private void processNextOrder() {
        System.out.println("\n--- Process Next Order ---");
        // Check if the queue is empty using isEmpty()
        if (orderQueue.isEmpty()) {
            System.err.println("No pending orders to process."); // Use System.err for error
            return;
        }

        // Remove and retrieve the head of the queue using poll()
        Order nextOrder = orderQueue.poll();
        System.out.println("Processing Order #" + nextOrder.getOrderId() + "...");

        // Display details of the processed order
        System.out.println(nextOrder); // Uses the Order.toString() method

        System.out.println("Order #" + nextOrder.getOrderId() + " processed and removed from queue.");
    }

    // Views all orders currently in the queue without removing them
    private void viewPendingOrders() {
        System.out.println("\n--- Pending Orders ---");
        // Check if the queue is empty
        if (orderQueue.isEmpty()) {
            System.out.println("No pending orders in the queue."); // Use System.out for status message
            return;
        }

        System.out.println("Orders currently in queue (FIFO):");
        int position = 1;
        // Iterate through the queue using a for-each loop (Queue is Iterable)
        // This does NOT remove elements from the queue, allowing viewing
        for (Order order : orderQueue) {
            System.out.println(position + ". Order #" + order.getOrderId() +
                               " (" + order.getItems().size() + " item(s), Total: $" +
                               String.format("%.2f", order.getTotalPrice()) + ")");
            position++;
        }
        System.out.println("----------------------");
    }

    // The main application loop that interacts with the user
    public void run() {
        Scanner scanner = new Scanner(System.in);
        boolean running = true;

        // Class-wide exception handling for the main application loop
        // Catches unexpected errors that might occur within the loop
        try {
            while (running) {
                displayMenuOptions(); // Show options
                System.out.print("Enter your choice: ");

                // Specific try-catch for reading the integer choice from the main menu
                try {
                    int choice = scanner.nextInt();
                    scanner.nextLine(); // Consume the leftover newline character after reading the integer

                    // Use a switch statement to execute actions based on user choice
                    switch (choice) {
                        case 1:
                            displayMenu();
                            break;
                        case 2:
                            placeOrder(scanner); // This method contains its own input validation and error handling
                            break;
                        case 3:
                            processNextOrder();
                            break;
                        case 4:
                            viewPendingOrders();
                            break;
                        case 5:
                            System.out.println("Exiting Restaurant System. Goodbye!"); // Use System.out for exit message
                            running = false; // Set flag to false to exit the while loop
                            break;
                        default:
                            // Handle cases where the integer choice is not between 1 and 5
                            System.err.println("Invalid choice: " + choice + ". Please enter a number between 1 and 5."); // Use System.err
                    }
                } catch (InputMismatchException e) {
                    // Handle cases where the user enters non-integer input for the main menu choice
                    System.err.println("Invalid input. Please enter a number."); // Use System.err
                    scanner.nextLine(); // Consume the invalid input to prevent an infinite loop
                }
                // Note: Exceptions within placeOrder (like NumberFormatException) are handled inside placeOrder.

                System.out.println(); // Add a newline for better separation between menu iterations
            }
        } catch (Exception e) {
            // Generic catch block for any other unexpected runtime exceptions that weren't handled elsewhere
            System.err.println("A critical unexpected error occurred: " + e.getMessage()); // Use System.err
            e.printStackTrace(); // Print the stack trace for debugging purposes in case of a critical error
        } finally {
            // Ensure the scanner resource is closed when the application exits the try/catch/while loop
            if (scanner != null) {
                scanner.close();
                System.out.println("Scanner resource closed."); // Confirmation message
            }
        }
    }

    // Main method - entry point of the application
    public static void main(String[] args) {
        RestaurantSystem system = new RestaurantSystem();
        system.run(); // Start the main application loop
    }
}
