/*
 * Exam Question #100
 * Generated on: 2025-05-11 22:14:22
 * Generated by: Account 4
 * 
 * QUESTION:
 * **Java Programming Exam Task: Advanced Task Management System**
 * 
 * **Problem Description:**
 * 
 * You are tasked with developing a command-line Task Management System in Java. This system should allow users to add, view, and complete tasks. The system needs to handle tasks with different priorities and manage them efficiently using appropriate data structures and control flow mechanisms.
 * 
 * **Requirements:**
 * 
 * 1.  **Task Representation:** Create a `Task` class with private fields for `description` (String), `priority` (enum: HIGH, MEDIUM, LOW), and `status` (enum: PENDING, COMPLETED). Include a constructor and public getter methods for these fields.
 * 2.  **Data Structures:**
 *     *   Use a `java.util.Queue` to store tasks that are currently pending and waiting to be completed. Tasks should be processed from this queue. A `LinkedList` can be used as the concrete implementation for the `Queue`.
 *     *   Use a `java.util.ArrayList` (declared as `java.util.List`) to maintain a complete history of all tasks ever added to the system, including both pending and completed tasks.
 * 3.  **Core Functionality:**
 *     *   **Add Task:** Prompt the user for a task description and priority (HIGH, MEDIUM, LOW). Validate the priority input. Create a `Task` object, add it to the `ArrayList` (full history), and add it to the `Queue` (pending tasks).
 *     *   **View Tasks:** Display all tasks from the `ArrayList`, showing their description, priority, and status. Clearly distinguish between pending and completed tasks.
 *     *   **Complete Next Task:** Take the next task from the head of the `Queue` and mark its status as `COMPLETED` in the `ArrayList`. Handle the case where the queue is empty.
 *     *   **Exit:** Terminate the program.
 * 4.  **User Interaction:** Use `java.util.Scanner` to read user commands (e.g., "add", "view", "complete", "exit") and task details from the console.
 * 5.  **Control Flow:** Use a `switch` statement to process user commands.
 * 6.  **Error Handling:**
 *     *   Use `System.err` to print error messages (e.g., invalid command, invalid priority input, attempting to complete a task when the queue is empty).
 *     *   Implement class-wide exception handling using `try-catch` blocks to gracefully handle potential runtime errors during the program's execution, particularly around the main command processing loop.
 * 7.  **Output:** Use `System.out` for normal output (prompts, task listings, success messages).
 * 8.  **Best Practices:**
 *     *   Employ proper encapsulation (private fields, public methods).
 *     *   Use meaningful variable and method names.
 *     *   Include appropriate comments and documentation (Javadoc where applicable).
 *     *   Validate user input where necessary (e.g., priority string).
 *     *   Structure the code cleanly with separate classes for `Task` and the main application logic (`TaskManager`).
 * 
 * **Expected Output:**
 * 
 * The program should run interactively. Example interaction might look like this:
 * 
 * ```
 * Task Management System
 * 
 * Enter command (add, view, complete, exit):
 * add
 * Enter task description: Buy groceries
 * Enter priority (HIGH, MEDIUM, LOW): HIGH
 * Task added: Buy groceries [HIGH]
 * 
 * Enter command (add, view, complete, exit):
 * add
 * Enter task description: Schedule meeting
 * Enter priority (HIGH, MEDIUM, LOW): MEDIUM
 * Task added: Schedule meeting [MEDIUM]
 * 
 * Enter command (add, view, complete, exit):
 * view
 * --- All Tasks ---
 * 1. Buy groceries [HIGH] - PENDING
 * 2. Schedule meeting [MEDIUM] - PENDING
 * -----------------
 * 
 * Enter command (add, view, complete, exit):
 * complete
 * Completed task: Buy groceries [HIGH]
 * 
 * Enter command (add, view, complete, exit):
 * view
 * --- All Tasks ---
 * 1. Buy groceries [HIGH] - COMPLETED
 * 2. Schedule meeting [MEDIUM] - PENDING
 * -----------------
 * 
 * Enter command (add, view, complete, exit):
 * complete
 * Completed task: Schedule meeting [MEDIUM]
 * 
 * Enter command (add, view, complete, exit):
 * complete
 * Error: No tasks currently pending in the queue.
 * 
 * Enter command (add, view, complete, exit):
 * view
 * --- All Tasks ---
 * 1. Buy groceries [HIGH] - COMPLETED
 * 2. Schedule meeting [MEDIUM] - COMPLETED
 * -----------------
 * 
 * Enter command (add, view, complete, exit):
 * exit
 * Exiting Task Management System.
 * ```
 * 
 * Your solution should be a single Java file containing all necessary classes and the main method to start the application.
 *
 * EXPLANATION:
 * The solution implements a simple command-line Task Management System as requested, demonstrating the use of various Java concepts and data structures.
 * 
 * 1.  **Task Class:** The `Task` class encapsulates the data for a single task (description, priority, status) using private fields and public getters, adhering to encapsulation principles. It also includes a setter for the status, as status is the only property that changes after creation. Enums `Priority` and `Status` provide type-safe representation for these properties. The `toString()` method is overridden for easy printing. Input validation is included in the constructor.
 * 
 * 2.  **TaskManager Class:** This is the main class containing the application logic.
 *     *   **Data Structures:**
 *         *   `pendingTasks`: A `Queue<Task>` implemented using `LinkedList`. This structure is used to hold tasks that are waiting to be processed in a First-In, First-Out (FIFO) manner, which is a typical use case for a queue. `offer()` is used for adding, and `poll()` for removing from the head.
 *         *   `allTasks`: A `List<Task>` implemented using `ArrayList`. This list serves as a complete record of all tasks ever added, regardless of their current status. It allows viewing the history of tasks.
 *     *   **Scanner:** A `Scanner` object is used to read input from `System.in`. It's initialized in the constructor and closed in the `finally` block of the `run` method to ensure resource cleanup.
 *     *   **`run()` Method:** This method contains the main application loop.
 *         *   It prompts the user for commands.
 *         *   A `try-catch` block surrounds the `while` loop. This provides class-wide exception handling, catching any unexpected exceptions that might occur during the execution of the command processing, preventing the program from crashing abruptly. Specific errors (like invalid input) are handled within the respective methods or the switch's default case using `System.err`.
 *         *   A `switch` statement is used to direct the flow based on the user's command (`add`, `view`, `complete`, `exit`). The `default` case handles unknown commands and prints an error to `System.err`.
 *         *   The loop continues until the "exit" command is entered, which causes the `run` method to return.
 *     *   **`addTask()` Method:**
 *         *   Prompts for description and priority.
 *         *   Validates that the description is not empty.
 *         *   Uses a loop and `try-catch` with `Priority.valueOf()` to validate the priority input string against the `Priority` enum, printing an error to `System.err` if invalid input is given and prompting again.
 *         *   Creates a new `Task` object.
 *         *   Adds the *same* `Task` object reference to both `allTasks` (the history list) and `pendingTasks` (the processing queue). This is crucial because when the status is updated on the object retrieved from the queue, the change is reflected in the object stored in the list as well.
 *         *   Prints a success message to `System.out`.
 *     *   **`viewTasks()` Method:**
 *         *   Iterates through the `allTasks` list.
 *         *   Prints each task's details using its `toString()` method to `System.out`.
 *         *   Handles the case where no tasks have been added.
 *     *   **`completeNextTask()` Method:**
 *         *   Checks if `pendingTasks` queue is empty. If so, it prints an error to `System.err` and returns.
 *         *   Uses `pendingTasks.poll()` to get and remove the task at the head of the queue.
 *         *   Calls `setStatus(Status.COMPLETED)` on the retrieved `Task` object. Since this object is the same instance stored in `allTasks`, its status is updated there automatically.
 *         *   Prints a confirmation message to `System.out`.
 *     *   **`main()` Method:** The entry point of the application. It creates a `TaskManager` instance and calls its `run()` method.
 * 
 * This solution effectively integrates the required Java components (`Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.err`, `System.out`, `try-catch`) within a practical scenario, demonstrating proper object-oriented design, data structure usage, and error handling.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;

// Enum for Task Priority
enum Priority {
    HIGH, MEDIUM, LOW
}

// Enum for Task Status
enum Status {
    PENDING, COMPLETED
}

/**
 * Represents a single task in the Task Management System.
 */
class Task {
    private String description;
    private Priority priority;
    private Status status;

    /**
     * Constructs a new Task.
     * @param description The description of the task.
     * @param priority The priority of the task.
     */
    public Task(String description, Priority priority) {
        if (description == null || description.trim().isEmpty()) {
            throw new IllegalArgumentException("Task description cannot be empty.");
        }
        if (priority == null) {
            throw new IllegalArgumentException("Task priority cannot be null.");
        }
        this.description = description;
        this.priority = priority;
        this.status = Status.PENDING; // New tasks are always pending
    }

    // --- Getters ---
    public String getDescription() {
        return description;
    }

    public Priority getPriority() {
        return priority;
    }

    public Status getStatus() {
        return status;
    }

    // --- Setter for status ---
    public void setStatus(Status status) {
        if (status == null) {
            throw new IllegalArgumentException("Task status cannot be null.");
        }
        this.status = status;
    }

    @Override
    public String toString() {
        return description + " [" + priority + "] - " + status;
    }
}

/**
 * Manages a collection of tasks, allowing adding, viewing, and completing tasks.
 */
public class TaskManager {

    private Queue<Task> pendingTasks; // Tasks waiting to be completed (FIFO processing)
    private List<Task> allTasks;     // All tasks ever added (for history/viewing)
    private Scanner scanner;         // Scanner for user input

    /**
     * Constructs a new TaskManager.
     */
    public TaskManager() {
        this.pendingTasks = new LinkedList<>(); // LinkedList implements Queue
        this.allTasks = new ArrayList<>();      // ArrayList implements List
        this.scanner = new Scanner(System.in);
    }

    /**
     * Runs the main task management loop.
     * Handles user commands and delegates to appropriate methods.
     */
    public void run() {
        System.out.println("Task Management System");
        String command;

        // Class-wide exception handling around the main loop
        try {
            while (true) {
                System.out.println("\nEnter command (add, view, complete, exit):");
                System.out.print("> ");
                command = scanner.nextLine().trim().toLowerCase();

                // Switch statement for command processing
                switch (command) {
                    case "add":
                        addTask();
                        break;
                    case "view":
                        viewTasks();
                        break;
                    case "complete":
                        completeNextTask();
                        break;
                    case "exit":
                        System.out.println("Exiting Task Management System.");
                        return; // Exit the run method
                    default:
                        // Error message for unknown commands
                        System.err.println("Error: Unknown command '" + command + "'. Please use add, view, complete, or exit.");
                        break;
                }
            }
        } catch (Exception e) {
            // Catch any unexpected exceptions during execution
            System.err.println("An unexpected system error occurred: " + e.getMessage());
            e.printStackTrace(); // Print stack trace for debugging
        } finally {
            // Ensure scanner is closed
            if (scanner != null) {
                scanner.close();
            }
        }
    }

    /**
     * Prompts user for task details and adds a new task to the system.
     */
    private void addTask() {
        System.out.print("Enter task description: ");
        String description = scanner.nextLine().trim();

        if (description.isEmpty()) {
            System.err.println("Error: Task description cannot be empty.");
            return;
        }

        Priority priority = null;
        boolean validPriority = false;
        while (!validPriority) {
            System.out.print("Enter priority (HIGH, MEDIUM, LOW): ");
            String priorityInput = scanner.nextLine().trim().toUpperCase();
            try {
                priority = Priority.valueOf(priorityInput);
                validPriority = true;
            } catch (IllegalArgumentException e) {
                // Error message for invalid priority input
                System.err.println("Error: Invalid priority. Please enter HIGH, MEDIUM, or LOW.");
            }
        }

        // Create the task
        Task newTask = new Task(description, priority);

        // Add to both lists
        allTasks.add(newTask);
        pendingTasks.offer(newTask); // offer is generally preferred over add for queues

        System.out.println("Task added: " + newTask.getDescription() + " [" + newTask.getPriority() + "]");
    }

    /**
     * Displays all tasks currently in the system (both pending and completed).
     */
    private void viewTasks() {
        if (allTasks.isEmpty()) {
            System.out.println("No tasks have been added yet.");
            return;
        }

        System.out.println("--- All Tasks ---");
        for (int i = 0; i < allTasks.size(); i++) {
            Task task = allTasks.get(i);
            System.out.println((i + 1) + ". " + task); // Task.toString() provides formatted output
        }
        System.out.println("-----------------");
    }

    /**
     * Completes the next task from the pending queue.
     */
    private void completeNextTask() {
        // Check if the queue is empty
        if (pendingTasks.isEmpty()) {
            // Error message for empty queue
            System.err.println("Error: No tasks currently pending in the queue.");
            return;
        }

        // Get the next task from the queue (and remove it)
        Task taskToComplete = pendingTasks.poll();

        // Update the status of this task (the same object reference exists in allTasks)
        taskToComplete.setStatus(Status.COMPLETED);

        System.out.println("Completed task: " + taskToComplete.getDescription() + " [" + taskToComplete.getPriority() + "]");
    }

    /**
     * Main method to start the Task Management System.
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        TaskManager manager = new TaskManager();
        manager.run();
    }
}
