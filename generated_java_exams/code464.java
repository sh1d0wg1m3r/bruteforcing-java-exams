/*
 * Exam Question #464
 * Generated on: 2025-05-11 23:15:06
 * Generated by: Account 3
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Warehouse Order Fulfillment System
 * 
 * **Scenario:**
 * 
 * You are tasked with developing a simplified Warehouse Management System for an e-commerce company. The system needs to manage product inventory, handle incoming customer orders, and process them based on product availability. Orders are processed in the sequence they are received.
 * 
 * **Requirements:**
 * 
 * Implement a Java program that provides a command-line interface for interacting with the warehouse system. The system must support the following operations via a menu:
 * 
 * 1.  **Add Product to Inventory:** Add a new product with a unique ID, name, price, and initial stock quantity.
 * 2.  **View Inventory:** Display all products currently in the inventory, including their details and stock levels.
 * 3.  **Place Customer Order:** Simulate receiving a customer order. An order consists of one or more items, each specifying a product ID and quantity. The order should be added to a queue for processing.
 * 4.  **Process Next Order:** Take the next order from the queue. For each item in the order, check if sufficient stock is available in the inventory.
 *     *   If stock is sufficient for *all* items in the order: Decrease the stock of each product accordingly and move the order to a list of processed orders.
 *     *   If stock is insufficient for *any* item in the order: The entire order cannot be fulfilled at this time. Do not decrease stock. Move the order to the list of processed orders, marking it as 'FAILED' or indicating the reason.
 * 5.  **View Pending Orders:** Display all orders currently waiting in the processing queue.
 * 6.  **View Processed Orders:** Display all orders that have been processed (either successfully or failed).
 * 7.  **Exit:** Terminate the program.
 * 
 * **Technical Constraints:**
 * 
 * Your solution **must** use all of the following Java components:
 * 
 * *   `java.util.Queue` (for pending orders)
 * *   `java.util.ArrayList` (for inventory and processed orders)
 * *   `java.util.List` interface (use `List` as the declared type for inventory and processed orders, and potentially within the `Order` class)
 * *   `java.util.Scanner` (for reading user input)
 * *   `switch` statement (for handling menu options)
 * *   `System.err` (for printing error messages, e.g., invalid input, product not found, insufficient stock, queue empty)
 * *   `System.out` (for printing normal output, e.g., menu, successful operations, list displays)
 * *   Class-wide exception handling with `try-catch` blocks (e.g., around input parsing, potential null pointers, or general runtime issues).
 * 
 * **Best Practices:**
 * 
 * *   Implement proper encapsulation (private fields, public getters/setters where necessary).
 * *   Use meaningful variable and method names.
 * *   Include appropriate comments and documentation (e.g., Javadoc for classes/methods).
 * *   Implement input validation (e.g., ensure IDs are unique, quantities/prices are positive numbers, product exists).
 * *   Provide clear error messages using `System.err`.
 * *   Structure your code into appropriate classes (`Product`, `Order`, `WarehouseManagementSystem`).
 * *   Use `try-with-resources` for the `Scanner`.
 * 
 * **Input Format Examples:**
 * 
 * *   Adding Product:
 *     ```
 *     Enter product ID: P001
 *     Enter product name: Laptop
 *     Enter product price: 1200.50
 *     Enter initial stock: 10
 *     ```
 * *   Placing Order:
 *     ```
 *     Enter order ID: O101
 *     Enter number of items: 2
 *     Enter item 1 product ID: P001
 *     Enter item 1 quantity: 1
 *     Enter item 2 product ID: P002
 *     Enter item 2 quantity: 5
 *     ```
 *     (User indicates end of items)
 * 
 * **Output Format Examples:**
 * 
 * *   Menu:
 *     ```
 *     --- Warehouse Management System ---
 *     1. Add Product
 *     2. View Inventory
 *     3. Place Order
 *     4. Process Next Order
 *     5. View Pending Orders
 *     6. View Processed Orders
 *     7. Exit
 *     Enter your choice:
 *     ```
 * *   Viewing Inventory:
 *     ```
 *     --- Inventory ---
 *     ID: P001, Name: Laptop, Price: $1200.50, Stock: 9
 *     ID: P002, Name: Keyboard, Price: $75.00, Stock: 15
 *     -----------------
 *     ```
 * *   Viewing Pending Orders:
 *     ```
 *     --- Pending Orders ---
 *     Order ID: O101, Items: [P001 (Qty: 1), P002 (Qty: 5)]
 *     --------------------
 *     ```
 * *   Viewing Processed Orders:
 *     ```
 *     --- Processed Orders ---
 *     Order ID: O101, Status: PROCESSED, Items: [P001 (Qty: 1), P002 (Qty: 5)]
 *     Order ID: O102, Status: FAILED (Insufficient stock for P003), Items: [P003 (Qty: 2)]
 *     ----------------------
 *     ```
 * *   Error Message (using System.err):
 *     ```
 *     ERROR: Product ID P001 already exists.
 *     ERROR: Invalid input. Please enter a number.
 *     ERROR: Cannot process order: Insufficient stock for product P003 (Required: 2, Available: 0)
 *     ERROR: No pending orders to process.
 *     ```
 * 
 * **Task:**
 * 
 * Write the complete Java code for the `WarehouseManagementSystem` and supporting classes (`Product`, `Order`). Ensure all requirements and constraints are met.
 *
 * EXPLANATION:
 * The provided solution implements the `WarehouseManagementSystem` as described in the exam question, demonstrating the required Java concepts and best practices.
 * 
 * **Class Structure:**
 * 
 * 1.  **`Product` Class:** Represents an item available in the inventory.
 *     *   **Encapsulation:** Fields (`id`, `name`, `price`, `stock`) are private. Public getters are provided. A setter is provided only for `stock`, as it's the only field expected to change after creation.
 *     *   **Methods:** Includes a constructor, getters, `setStock`, `decreaseStock` (with validation), `toString` for easy printing, and overridden `equals`/`hashCode` based on the unique `id`.
 * 2.  **`OrderItem` Class:** A simple helper class to represent a specific product and its quantity within an `Order`. It holds a reference to the `Product` object and the requested quantity.
 * 3.  **`Order` Class:** Represents a customer order.
 *     *   **Encapsulation:** Fields (`orderId`, `items`, `status`, `failureReason`) are private. Getters are provided. Setters are provided for `status` and `failureReason` to track processing results.
 *     *   **Data Structure:** Uses `List<OrderItem>` (declared as `List`, instantiated as `ArrayList`) to hold the items. This demonstrates using the `List` interface.
 *     *   **Enum:** Uses an `OrderStatus` enum for clarity (PENDING, PROCESSED, FAILED).
 *     *   **Constructor:** Initializes the order with ID, items, and sets the initial status to `PENDING`. Creates a defensive copy of the items list.
 *     *   **`toString`:** Provides a formatted string representation of the order, including status and items.
 * 4.  **`WarehouseManagementSystem` Class:** The main class that orchestrates the system.
 *     *   **Data Structures:**
 *         *   `inventory`: Declared as `List<Product>`, instantiated as `ArrayList<Product>`. Stores all available products.
 *         *   `pendingOrders`: Declared as `Queue<Order>`, instantiated as `LinkedList<Order>`. Stores orders waiting to be processed, enforcing FIFO order.
 *         *   `processedOrders`: Declared as `List<Order>`, instantiated as `ArrayList<Order>`. Stores orders after they have gone through the processing step, regardless of success or failure.
 *     *   **`Scanner`:** Used as a class field, initialized within a `try-with-resources` block in the `run` method to ensure it's properly closed.
 *     *   **Methods:**
 *         *   `findProductById`: Helper to search the `inventory` list.
 *         *   `addProduct`: Handles user input for product details, validates input (non-empty ID/name, non-negative price/stock), checks for duplicate IDs, creates a `Product` object, and adds it to the `inventory` `ArrayList`. Uses `System.err` for validation errors.
 *         *   `viewInventory`: Iterates through the `inventory` `ArrayList` and prints product details using `System.out`.
 *         *   `placeOrder`: Generates an order ID, prompts the user for items (product ID and quantity), validates product existence and quantity, creates `OrderItem` objects, compiles them into a `List<OrderItem>`, creates an `Order` object, and adds it to the `pendingOrders` `Queue` using `offer()`. Uses `System.err` for validation errors (e.g., product not found, invalid quantity).
 *         *   `processNextOrder`: Retrieves the next order from the `pendingOrders` `Queue` using `poll()`. If the queue is empty (`poll()` returns null), prints an error to `System.err`. If an order is retrieved, it performs a two-pass process:
 *             1.  **Check Stock:** Iterates through the order's items and checks if sufficient stock exists for *all* items in the `inventory`. If any item lacks stock, the `canProcess` flag is set to `false`, and a `failureReason` is recorded.
 *             2.  **Update Stock (if possible):** If `canProcess` is still `true` after the first pass, it iterates again and calls `decreaseStock` on the corresponding `Product` objects in the `inventory`.
 *             Finally, sets the `Order` status (`PROCESSED` or `FAILED`), sets the `failureReason` if applicable, and adds the order to the `processedOrders` `ArrayList`. Uses `System.out` for success messages and `System.err` for failure messages (insufficient stock, no pending orders).
 *         *   `viewPendingOrders`: Iterates through the `pendingOrders` `Queue` (without removing elements) and prints order details using `System.out`.
 *         *   `viewProcessedOrders`: Iterates through the `processedOrders` `ArrayList` and prints order details using `System.out`.
 *         *   `displayMenu`: Prints the interactive menu options to `System.out`.
 *         *   `run`: Contains the main application loop. It uses a `while` loop and a `switch` statement to handle user choices. It wraps the core switch logic in a `try-catch(Exception e)` block for class-wide exception handling, catching any unexpected runtime errors during the execution of a menu option. It also specifically catches `NumberFormatException` when reading the menu choice, directing the error message to `System.err`. The `Scanner` is initialized and managed using a `try-with-resources` block, ensuring it's closed automatically.
 *     *   **`main`:** The entry point of the program, creates a `WarehouseManagementSystem` instance and calls its `run` method.
 * 
 * **Required Components Usage:**
 * 
 * *   `Queue`: `pendingOrders` is declared as `Queue` and used with `offer()` (add) and `poll()` (retrieve and remove).
 * *   `ArrayList`: `inventory` and `processedOrders` are instantiated as `ArrayList`. `OrderItem` list within `Order` is also `ArrayList`.
 * *   `List`: `inventory`, `processedOrders`, and the list of items within `Order` are declared using the `List` interface.
 * *   `Scanner`: Used to read user input in the `run` method and passed to other methods. Managed with `try-with-resources`.
 * *   `switch`: Used in the `run` method to select actions based on user input.
 * *   `System.err`: Used exclusively for printing error messages (invalid input, product not found, insufficient stock, queue empty, unexpected exceptions).
 * *   `System.out`: Used for printing the menu, prompts, successful operation messages, and list displays (inventory, pending, processed orders).
 * *   `try-catch`: Used in the `run` method for class-wide handling of potential exceptions during menu operations and specific handling of `NumberFormatException` for menu input. Also implicitly used within `Double.parseDouble` and `Integer.parseInt` which are handled by the surrounding `try-catch` blocks or specific ones added during input loops.
 * 
 * **Best Practices Implementation:**
 * 
 * *   **Encapsulation:** Clearly defined private fields and public methods in `Product`, `OrderItem`, and `Order`.
 * *   **Naming:** Meaningful names like `pendingOrders`, `processNextOrder`, `insufficientStock`.
 * *   **Comments:** Javadoc comments explain the purpose of classes and key methods. Inline comments explain specific logic points.
 * *   **Input Validation:** Checks for empty strings, negative numbers, non-numeric input (handled by `try-catch` on parsing), and checks for product existence and sufficient stock before processing.
 * *   **Error Handling:** Specific error messages printed to `System.err`. `try-catch` blocks handle potential exceptions gracefully. `poll()` is used on the queue to avoid `NoSuchElementException` when the queue is empty.
 * *   **Clean Code Structure:** Logic is separated into distinct methods within appropriate classes, improving readability and maintainability. The `run` method acts as the main controller.
 * 
 * This solution effectively integrates the required components into a functional system, demonstrating an understanding of core Java concepts, data structures, error handling, and object-oriented design principles suitable for an advanced exam.
 */

import java.util.*;
import java.util.concurrent.atomic.AtomicInteger;

// Represents a product in the inventory
class Product {
    private String id;
    private String name;
    private double price;
    private int stock;

    /**
     * Constructs a new Product.
     * @param id Unique product ID.
     * @param name Product name.
     * @param price Product price.
     * @param stock Initial stock quantity.
     */
    public Product(String id, String name, double price, int stock) {
        this.id = id;
        this.name = name;
        this.price = price;
        this.stock = stock;
    }

    // --- Getters ---
    public String getId() {
        return id;
    }

    public String getName() {
        return name;
    }

    public double getPrice() {
        return price;
    }

    public int getStock() {
        return stock;
    }

    // --- Setters (only for stock, as ID, name, price are typically fixed) ---
    public void setStock(int stock) {
        if (stock >= 0) {
            this.stock = stock;
        } else {
            // This should ideally be handled by validation before calling
            System.err.println("ERROR: Stock cannot be negative for product " + id);
        }
    }

    /**
     * Decreases the stock by the specified quantity.
     * Returns true if stock was sufficient and decreased, false otherwise.
     * @param quantity The amount to decrease stock by.
     * @return true if successful, false if insufficient stock.
     */
    public boolean decreaseStock(int quantity) {
        if (this.stock >= quantity) {
            this.stock -= quantity;
            return true;
        }
        return false;
    }

    @Override
    public String toString() {
        return "ID: " + id + ", Name: " + name + ", Price: $" + String.format("%.2f", price) + ", Stock: " + stock;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Product product = (Product) o;
        return Objects.equals(id, product.id);
    }

    @Override
    public int hashCode() {
        return Objects.hash(id);
    }
}

// Represents an item within an order (Product and quantity)
class OrderItem {
    private Product product; // Reference to the actual product
    private int quantity;

    public OrderItem(Product product, int quantity) {
        this.product = product;
        this.quantity = quantity;
    }

    public Product getProduct() {
        return product;
    }

    public int getQuantity() {
        return quantity;
    }

    @Override
    public String toString() {
        return product.getId() + " (Qty: " + quantity + ")";
    }
}

// Represents a customer order
class Order {
    private String orderId;
    private List<OrderItem> items; // Using List interface
    private OrderStatus status;
    private String failureReason; // To store reason if status is FAILED

    public enum OrderStatus {
        PENDING, PROCESSED, FAILED
    }

    /**
     * Constructs a new Order.
     * @param orderId Unique order ID.
     * @param items List of items in the order.
     */
    public Order(String orderId, List<OrderItem> items) {
        this.orderId = orderId;
        this.items = new ArrayList<>(items); // Create a defensive copy
        this.status = OrderStatus.PENDING;
        this.failureReason = null;
    }

    // --- Getters ---
    public String getOrderId() {
        return orderId;
    }

    public List<OrderItem> getItems() {
        return Collections.unmodifiableList(items); // Return an unmodifiable list
    }

    public OrderStatus getStatus() {
        return status;
    }

    public String getFailureReason() {
        return failureReason;
    }

    // --- Setters ---
    public void setStatus(OrderStatus status) {
        this.status = status;
    }

    public void setFailureReason(String failureReason) {
        this.failureReason = failureReason;
    }

    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        sb.append("Order ID: ").append(orderId);
        sb.append(", Status: ").append(status);
        if (status == OrderStatus.FAILED && failureReason != null) {
            sb.append(" (").append(failureReason).append(")");
        }
        sb.append(", Items: [");
        for (int i = 0; i < items.size(); i++) {
            sb.append(items.get(i));
            if (i < items.size() - 1) {
                sb.append(", ");
            }
        }
        sb.append("]");
        return sb.toString();
    }
}

// Main class for the Warehouse Management System
public class WarehouseManagementSystem {

    // Using List interface for inventory and processed orders, implemented by ArrayList
    private List<Product> inventory;
    // Using Queue interface for pending orders, implemented by LinkedList (common for queues)
    private Queue<Order> pendingOrders;
    private List<Order> processedOrders; // Using List interface

    private Scanner scanner;
    private AtomicInteger orderCounter = new AtomicInteger(100); // For generating simple order IDs

    /**
     * Constructs the WarehouseManagementSystem.
     * Initializes inventory, order queues/lists, and the scanner.
     */
    public WarehouseManagementSystem() {
        this.inventory = new ArrayList<>();
        this.pendingOrders = new LinkedList<>(); // LinkedList implements Queue
        this.processedOrders = new ArrayList<>();
        // Use try-with-resources in the run method for the scanner
    }

    /**
     * Finds a product in the inventory by its ID.
     * @param productId The ID of the product to find.
     * @return The Product object if found, null otherwise.
     */
    private Product findProductById(String productId) {
        for (Product product : inventory) {
            if (product.getId().equals(productId)) {
                return product;
            }
        }
        return null;
    }

    /**
     * Adds a new product to the inventory.
     */
    private void addProduct() {
        System.out.println("\n--- Add Product ---");
        String id = "";
        String name = "";
        double price = -1;
        int stock = -1;

        // Input ID
        System.out.print("Enter product ID: ");
        id = scanner.nextLine().trim();
        if (id.isEmpty()) {
            System.err.println("ERROR: Product ID cannot be empty.");
            return;
        }
        if (findProductById(id) != null) {
            System.err.println("ERROR: Product ID " + id + " already exists.");
            return;
        }

        // Input Name
        System.out.print("Enter product name: ");
        name = scanner.nextLine().trim();
        if (name.isEmpty()) {
            System.err.println("ERROR: Product name cannot be empty.");
            return;
        }

        // Input Price with validation
        while (price < 0) {
            System.out.print("Enter product price: ");
            try {
                price = Double.parseDouble(scanner.nextLine());
                if (price < 0) {
                    System.err.println("ERROR: Price cannot be negative.");
                }
            } catch (NumberFormatException e) {
                System.err.println("ERROR: Invalid input. Please enter a valid number for price.");
                // Consume the rest of the line if needed, though nextLine() handles it
            }
        }

        // Input Stock with validation
        while (stock < 0) {
            System.out.print("Enter initial stock: ");
            try {
                stock = Integer.parseInt(scanner.nextLine());
                if (stock < 0) {
                    System.err.println("ERROR: Stock cannot be negative.");
                }
            } catch (NumberFormatException e) {
                System.err.println("ERROR: Invalid input. Please enter a valid integer for stock.");
                // Consume the rest of the line
            }
        }

        Product newProduct = new Product(id, name, price, stock);
        inventory.add(newProduct);
        System.out.println("Product added successfully: " + newProduct.getName());
    }

    /**
     * Displays all products in the inventory.
     */
    private void viewInventory() {
        System.out.println("\n--- Inventory ---");
        if (inventory.isEmpty()) {
            System.out.println("Inventory is empty.");
        } else {
            for (Product product : inventory) {
                System.out.println(product);
            }
        }
        System.out.println("-----------------");
    }

    /**
     * Places a new customer order and adds it to the pending queue.
     */
    private void placeOrder() {
        System.out.println("\n--- Place Order ---");
        String orderId = "O" + orderCounter.getAndIncrement();
        List<OrderItem> orderItems = new ArrayList<>(); // Using List interface

        System.out.println("Generated Order ID: " + orderId);

        int numberOfItems = -1;
        while(numberOfItems < 1) {
             System.out.print("Enter number of different items in the order: ");
             try {
                 numberOfItems = Integer.parseInt(scanner.nextLine());
                 if (numberOfItems < 1) {
                     System.err.println("ERROR: Number of items must be at least 1.");
                 }
             } catch (NumberFormatException e) {
                 System.err.println("ERROR: Invalid input. Please enter a valid integer.");
             }
        }


        for (int i = 0; i < numberOfItems; i++) {
            System.out.println("--- Item " + (i + 1) + " ---");
            String productId = "";
            Product product = null;
            while (product == null) {
                System.out.print("Enter product ID for item " + (i + 1) + ": ");
                productId = scanner.nextLine().trim();
                if (productId.isEmpty()) {
                     System.err.println("ERROR: Product ID cannot be empty.");
                     continue; // Ask again
                }
                product = findProductById(productId);
                if (product == null) {
                    System.err.println("ERROR: Product with ID " + productId + " not found in inventory.");
                }
            }

            int quantity = -1;
            while (quantity < 1) {
                System.out.print("Enter quantity for " + product.getName() + ": ");
                try {
                    quantity = Integer.parseInt(scanner.nextLine());
                    if (quantity < 1) {
                        System.err.println("ERROR: Quantity must be at least 1.");
                    }
                } catch (NumberFormatException e) {
                    System.err.println("ERROR: Invalid input. Please enter a valid integer for quantity.");
                }
            }

            orderItems.add(new OrderItem(product, quantity));
        }

        if (!orderItems.isEmpty()) {
            Order newOrder = new Order(orderId, orderItems);
            pendingOrders.offer(newOrder); // Add to the end of the queue
            System.out.println("Order " + orderId + " placed and added to pending queue.");
        } else {
             System.err.println("ERROR: Order must contain at least one item. Order not placed.");
        }
    }

    /**
     * Processes the next order from the pending queue.
     * Checks stock and updates inventory if successful.
     */
    private void processNextOrder() {
        System.out.println("\n--- Process Next Order ---");
        Order orderToProcess = pendingOrders.poll(); // Get and remove the head of the queue

        if (orderToProcess == null) {
            System.err.println("ERROR: No pending orders to process.");
            return;
        }

        System.out.println("Attempting to process Order ID: " + orderToProcess.getOrderId());

        boolean canProcess = true;
        String failureReason = null;

        // First pass: Check stock availability for all items without changing anything
        for (OrderItem item : orderToProcess.getItems()) {
            Product product = findProductById(item.getProduct().getId()); // Re-fetch product to get current stock
            if (product == null) {
                 // This case should ideally not happen if product was found when placing order,
                 // but good for robustness.
                 canProcess = false;
                 failureReason = "Product " + item.getProduct().getId() + " not found in inventory.";
                 break;
            }
            if (product.getStock() < item.getQuantity()) {
                canProcess = false;
                failureReason = "Insufficient stock for product " + product.getId() +
                                " (Required: " + item.getQuantity() + ", Available: " + product.getStock() + ")";
                break; // Found one item with insufficient stock, cannot process the whole order
            }
        }

        if (canProcess) {
            // Second pass: Decrease stock for all items
            for (OrderItem item : orderToProcess.getItems()) {
                Product product = findProductById(item.getProduct().getId()); // Re-fetch product
                 if (product != null) { // Should not be null here based on first pass
                    product.decreaseStock(item.getQuantity());
                 }
            }
            orderToProcess.setStatus(Order.OrderStatus.PROCESSED);
            System.out.println("Order " + orderToProcess.getOrderId() + " processed successfully.");
        } else {
            orderToProcess.setStatus(Order.OrderStatus.FAILED);
            orderToProcess.setFailureReason(failureReason);
            System.err.println("ERROR: Order " + orderToProcess.getOrderId() + " failed processing. Reason: " + failureReason);
        }

        processedOrders.add(orderToProcess); // Add to processed list regardless of status
    }

    /**
     * Displays all orders currently in the pending queue.
     */
    private void viewPendingOrders() {
        System.out.println("\n--- Pending Orders ---");
        if (pendingOrders.isEmpty()) {
            System.out.println("No orders pending processing.");
        } else {
            // Iterate without removing elements
            for (Order order : pendingOrders) {
                System.out.println(order);
            }
        }
        System.out.println("--------------------");
    }

    /**
     * Displays all orders that have been processed (successful or failed).
     */
    private void viewProcessedOrders() {
        System.out.println("\n--- Processed Orders ---");
        if (processedOrders.isEmpty()) {
            System.out.println("No orders have been processed yet.");
        } else {
            for (Order order : processedOrders) {
                System.out.println(order);
            }
        }
        System.out.println("----------------------");
    }

    /**
     * Displays the main menu.
     */
    private void displayMenu() {
        System.out.println("\n--- Warehouse Management System ---");
        System.out.println("1. Add Product");
        System.out.println("2. View Inventory");
        System.out.println("3. Place Customer Order");
        System.out.println("4. Process Next Order");
        System.out.println("5. View Pending Orders");
        System.out.println("6. View Processed Orders");
        System.out.println("7. Exit");
        System.out.print("Enter your choice: ");
    }

    /**
     * Runs the main application loop.
     * Handles user input and calls appropriate methods.
     */
    public void run() {
        // Use try-with-resources to ensure scanner is closed
        try (Scanner scanner = new Scanner(System.in)) {
            this.scanner = scanner; // Assign to class field

            int choice = 0;
            while (choice != 7) {
                displayMenu();
                try {
                    choice = Integer.parseInt(scanner.nextLine()); // Read entire line

                    // Class-wide exception handling for the switch operations
                    try {
                        switch (choice) {
                            case 1:
                                addProduct();
                                break;
                            case 2:
                                viewInventory();
                                break;
                            case 3:
                                placeOrder();
                                break;
                            case 4:
                                processNextOrder();
                                break;
                            case 5:
                                viewPendingOrders();
                                break;
                            case 6:
                                viewProcessedOrders();
                                break;
                            case 7:
                                System.out.println("Exiting Warehouse Management System. Goodbye!");
                                break;
                            default:
                                System.err.println("ERROR: Invalid choice. Please enter a number between 1 and 7.");
                        }
                    } catch (Exception e) {
                        // Catch any unexpected runtime exceptions during an operation
                        System.err.println("An unexpected error occurred during operation: " + e.getMessage());
                        e.printStackTrace(); // Print stack trace for debugging in exam context
                    }

                } catch (NumberFormatException e) {
                    // Handle non-integer input for menu choice
                    System.err.println("ERROR: Invalid input. Please enter a number.");
                    choice = 0; // Reset choice to continue loop
                }
                System.out.println(); // Add a blank line for readability
            }
        } catch (Exception e) {
             // Catch any exception related to Scanner setup or closing
             System.err.println("A critical error occurred: " + e.getMessage());
             e.printStackTrace();
        } finally {
             // Scanner is closed automatically by try-with-resources
             this.scanner = null; // Dereference the scanner
        }
    }

    public static void main(String[] args) {
        WarehouseManagementSystem system = new WarehouseManagementSystem();
        system.run();
    }
}
