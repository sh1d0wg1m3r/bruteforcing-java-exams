/*
 * Exam Question #593
 * Generated on: 2025-05-12 16:11:53
 * Generated by: Account 3
 * 
 * QUESTION:
 * **Advanced Java Programming Exam: Document Processing System**
 * 
 * **Problem Description:**
 * 
 * You are tasked with developing a simplified system to manage a queue of documents waiting for processing in an office environment. The system should allow users to add new documents, process the next document in the queue, view the documents currently waiting, and view documents that have been processed (successfully or unsuccessfully).
 * 
 * **Requirements:**
 * 
 * 1.  **`Document` Class:**
 *     *   Create a class named `Document` to represent a document.
 *     *   It should have private fields: `id` (an integer, unique), `name` (a String), and `status` (an enum `Status`).
 *     *   Create an enum `Status` with values: `PENDING`, `PROCESSING`, `COMPLETED`, `FAILED`.
 *     *   The constructor should take `id` and `name`, initializing the status to `PENDING`.
 *     *   Provide public getter methods for all fields.
 *     *   Provide a public setter method for the `status` field.
 *     *   Override the `toString()` method to provide a user-friendly representation of the document (e.g., "ID: [id], Name: [name], Status: [status]").
 * 
 * 2.  **`DocumentProcessor` Class:**
 *     *   Create a class named `DocumentProcessor` to manage the document queue and processing logic.
 *     *   It must use a `java.util.Queue` (specifically, an implementation like `LinkedList`) to hold documents waiting for processing.
 *     *   It must use a `java.util.ArrayList` to store documents that have been processed (archived).
 *     *   It must use `java.util.List` as the type when returning collections of documents where the specific implementation isn't critical (e.g., viewing archived documents).
 *     *   It should have a private field to keep track of the next available document ID.
 *     *   Implement the following public methods:
 *         *   `addDocument(String name)`: Creates a new `Document` with a unique ID and the given name, and adds it to the processing queue. Print a confirmation message using `System.out`.
 *         *   `processNextDocument()`: Removes the next document from the front of the queue. Simulate processing: change its status to `PROCESSING`, then after a brief simulated delay (you can skip the actual delay for the exam, but mention it in comments), randomly set its status to either `COMPLETED` or `FAILED`. Add the processed document to the archived list. Print the outcome using `System.out`. Handle the case where the queue is empty gracefully using `System.err`.
 *         *   `viewProcessingQueue()`: Returns a `List<Document>` containing the documents currently in the processing queue. Print the contents of this list using `System.out`. If the queue is empty, print a message using `System.out`.
 *         *   `viewArchivedDocuments()`: Returns a `List<Document>` containing the documents in the archived list. Print the contents of this list using `System.out`. If the archived list is empty, print a message using `System.out`.
 *         *   `run()`: This method should contain the main application loop.
 *             *   Use `java.util.Scanner` to read user input from the console.
 *             *   Present a menu of options to the user (e.g., Add Document, Process Next, View Queue, View Archived, Exit).
 *             *   Use a `switch` statement to handle the user's choice.
 *             *   Implement input validation (e.g., ensure document name is not empty). Use `System.err` for invalid input messages.
 *             *   Wrap the main interaction logic (reading input and processing commands) within a `try-catch` block to demonstrate class-wide exception handling for unexpected errors. Print any caught exceptions or errors to `System.err`.
 *             *   Ensure the `Scanner` is properly closed when the application exits.
 * 
 * 3.  **General Requirements:**
 *     *   Use `System.out` for all normal output (menu, confirmations, list contents, processing results).
 *     *   Use `System.err` for all error messages (invalid input, empty queue/list conditions for processing, exceptions).
 *     *   Follow best practices:
 *         *   Proper encapsulation (private fields, public methods).
 *         *   Meaningful variable and method names.
 *         *   Appropriate comments and documentation (brief Javadoc or inline comments).
 *         *   Clean code structure (separate classes).
 * 
 * **Expected Output:**
 * 
 * The program should present a menu, accept integer choices, and produce output based on the chosen action. Examples:
 * 
 * *   Adding a document: `System.out` message confirming addition.
 * *   Processing an empty queue: `System.err` message indicating the queue is empty.
 * *   Processing a document: `System.out` message indicating which document was processed and its final status (COMPLETED/FAILED).
 * *   Viewing queues/archives: `System.out` listing documents or a message indicating emptiness.
 * *   Invalid input: `System.err` message.
 * *   Exceptions: Stack trace or error message printed to `System.err`.
 * 
 * **Time Allotment:** 45-60 minutes. Focus on correctness and fulfilling all requirements.
 *
 * EXPLANATION:
 * This solution implements a simple document processing system, fulfilling all the requirements of the exam question and demonstrating the practical use of the specified Java components.
 * 
 * 1.  **`Document` Class:** This class is a simple Plain Old Java Object (POJO) representing the data structure for a document. It uses private fields (`id`, `name`, `status`) and public getters/setters to enforce encapsulation. The `Status` enum provides a type-safe way to represent the different states a document can be in. The `toString()` method provides a convenient way to print document details.
 * 
 * 2.  **`DocumentProcessor` Class:** This is the core class managing the system's logic.
 *     *   **`Queue<Document> processingQueue`:** A `LinkedList` is used here, which is a common implementation of the `Queue` interface. It naturally supports adding elements to the end (`offer`) and removing elements from the front (`remove`), perfectly modeling a processing queue (FIFO - First-In, First-Out).
 *     *   **`List<Document> archivedDocuments`:** An `ArrayList` is used to store documents once they have gone through the processing step. `ArrayList` is suitable here as we primarily need to add processed documents and iterate through them for viewing, and random access isn't a frequent requirement.
 *     *   **`List` Interface:** The `viewProcessingQueue()` and `viewArchivedDocuments()` methods are designed to return `List<Document>`. While `viewArchivedDocuments` returns the internal `ArrayList` directly (which is acceptable for this problem's scope), `viewProcessingQueue` creates a *new* `ArrayList` from the queue's contents before returning it. This is a good practice to prevent external code from directly manipulating the processing queue's internal structure via the returned list reference. Using the `List` interface as the return type promotes flexibility; the caller doesn't need to know or care if it's an `ArrayList`, `LinkedList`, or another `List` implementation.
 *     *   **`nextDocumentId`:** A simple counter to ensure each document gets a unique ID.
 *     *   **`addDocument(String name)`:** Creates a new `Document`, increments the ID counter, and uses `processingQueue.offer()` to add it to the queue. Includes basic input validation for the document name.
 *     *   **`processNextDocument()`:** Uses `processingQueue.remove()` to get and remove the head of the queue. This method throws `NoSuchElementException` if the queue is empty, which is explicitly caught using `System.err` as required. It simulates processing by updating the status and uses a `Random` object to decide the final `COMPLETED` or `FAILED` status before adding the document to the `archivedDocuments` list.
 *     *   **`viewProcessingQueue()` and `viewArchivedDocuments()`:** These methods iterate through the respective collections and print their contents using `System.out`. They also include checks for empty collections and print appropriate messages using `System.out`.
 *     *   **`run()`:** This is the main driver method.
 *         *   **`Scanner`:** Used to read user input from `System.in`. It's created outside the main loop and closed in the `finally` block to ensure resource cleanup.
 *         *   **`switch` Statement:** The user's integer choice from the menu directly controls the program flow using a `switch` statement, calling the appropriate methods of the `DocumentProcessor`.
 *         *   **`System.out` and `System.err`:** Used consistently for normal output (menu, confirmations, lists) and error messages (invalid input, empty queue, processing failures, exceptions) respectively.
 *         *   **`try-catch` for Exception Handling:**
 *             *   An inner `try-catch` block specifically handles `InputMismatchException` that can occur if the user enters non-integer input when an integer is expected by `scanner.nextInt()`. It consumes the invalid input to prevent an infinite loop.
 *             *   The `processNextDocument()` method has its own `try-catch` to specifically handle `NoSuchElementException` (for an empty queue) and a general `Exception` for any other potential issues during processing.
 *             *   A broad `try-catch` block wraps the entire `while(running)` loop in the `run()` method. This fulfills the "class-wide" or "broad" exception handling requirement, catching any unexpected `Exception` that might propagate up from the inner logic or input handling, printing a critical error message and stack trace to `System.err`, and allowing the `finally` block to execute before the program potentially terminates.
 *         *   **`finally`:** Ensures the `Scanner` resource is closed, demonstrating proper resource management.
 * 
 * The solution adheres to best practices by using meaningful names, encapsulation, comments, and separating concerns into different classes. Input validation is performed for the document name, and error conditions (like an empty queue for processing or invalid user input) are handled gracefully using `System.err`.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.Random;
import java.util.NoSuchElementException;

// Represents the status of a document
enum Status {
    PENDING,
    PROCESSING,
    COMPLETED,
    FAILED
}

// Represents a document in the system
class Document {
    private int id;
    private String name;
    private Status status;

    /**
     * Constructs a new Document.
     *
     * @param id   The unique ID of the document.
     * @param name The name or title of the document.
     */
    public Document(int id, String name) {
        this.id = id;
        this.name = name;
        this.status = Status.PENDING; // Documents start as PENDING
    }

    // --- Getters ---
    public int getId() {
        return id;
    }

    public String getName() {
        return name;
    }

    public Status getStatus() {
        return status;
    }

    // --- Setter ---
    public void setStatus(Status status) {
        this.status = status;
    }

    /**
     * Provides a string representation of the document.
     *
     * @return A formatted string describing the document.
     */
    @Override
    public String toString() {
        return "ID: " + id + ", Name: \"" + name + "\", Status: " + status;
    }
}

// Manages the document processing queue and archives
public class DocumentProcessor {

    private Queue<Document> processingQueue; // Queue for pending documents
    private List<Document> archivedDocuments; // List for processed documents
    private int nextDocumentId; // Counter for unique document IDs
    private Random random; // For simulating random processing results

    /**
     * Constructs a new DocumentProcessor.
     */
    public DocumentProcessor() {
        // Use LinkedList as a Queue implementation
        this.processingQueue = new LinkedList<>();
        // Use ArrayList for archiving
        this.archivedDocuments = new ArrayList<>();
        this.nextDocumentId = 1; // Start IDs from 1
        this.random = new Random();
    }

    /**
     * Adds a new document to the processing queue.
     *
     * @param name The name of the document.
     */
    public void addDocument(String name) {
        if (name == null || name.trim().isEmpty()) {
            System.err.println("Error: Document name cannot be empty.");
            return;
        }
        Document newDoc = new Document(nextDocumentId++, name.trim());
        processingQueue.offer(newDoc); // Add to the end of the queue
        System.out.println("Added document to queue: " + newDoc.toString());
    }

    /**
     * Processes the next document in the queue.
     * Removes it from the queue, simulates processing, updates status,
     * and moves it to the archived list.
     */
    public void processNextDocument() {
        try {
            // Retrieve and remove the head of the queue
            Document docToProcess = processingQueue.remove(); // remove() throws NoSuchElementException if queue is empty

            System.out.println("Processing document: " + docToProcess.getName() + " (ID: " + docToProcess.getId() + ")");
            docToProcess.setStatus(Status.PROCESSING);

            // Simulate processing delay (optional for exam, added comment)
            // try { Thread.sleep(100); } catch (InterruptedException e) { Thread.currentThread().interrupt(); }

            // Simulate success or failure randomly
            if (random.nextBoolean()) {
                docToProcess.setStatus(Status.COMPLETED);
                System.out.println("Processing completed successfully for document: " + docToProcess.getName());
            } else {
                docToProcess.setStatus(Status.FAILED);
                System.err.println("Processing failed for document: " + docToProcess.getName()); // Use System.err for failure
            }

            archivedDocuments.add(docToProcess); // Add to the archived list

        } catch (NoSuchElementException e) {
            // Handle the case where the queue is empty
            System.err.println("Error: Processing queue is empty. No documents to process.");
        } catch (Exception e) {
            // Catch any other unexpected errors during processing
            System.err.println("An unexpected error occurred during processing: " + e.getMessage());
            // e.printStackTrace(System.err); // Optional: print stack trace for debugging
        }
    }

    /**
     * Returns a list of documents currently in the processing queue.
     * Note: This returns a new List to avoid modifying the internal queue directly.
     *
     * @return A List of documents in the queue.
     */
    public List<Document> viewProcessingQueue() {
        // Create a new list from the queue elements for viewing
        List<Document> queueList = new ArrayList<>(processingQueue);
        if (queueList.isEmpty()) {
            System.out.println("Processing queue is empty.");
        } else {
            System.out.println("--- Processing Queue ---");
            for (Document doc : queueList) {
                System.out.println(doc);
            }
            System.out.println("------------------------");
        }
        return queueList; // Return the list
    }

    /**
     * Returns a list of documents that have been processed and archived.
     *
     * @return A List of archived documents.
     */
    public List<Document> viewArchivedDocuments() {
        // Return a copy or the list itself; returning the list directly is fine here
        if (archivedDocuments.isEmpty()) {
            System.out.println("Archived documents list is empty.");
        } else {
            System.out.println("--- Archived Documents ---");
            for (Document doc : archivedDocuments) {
                System.out.println(doc);
            }
            System.out.println("--------------------------");
        }
        return archivedDocuments; // Return the list
    }

    /**
     * Runs the main application loop, handling user interaction.
     */
    public void run() {
        Scanner scanner = new Scanner(System.in);
        boolean running = true;

        // Class-wide exception handling wrapping the main loop
        try {
            while (running) {
                printMenu();
                System.out.print("Enter choice: ");

                // Use try-catch for potential input mismatch issues
                try {
                    int choice = scanner.nextInt();
                    scanner.nextLine(); // Consume the newline character after reading int

                    switch (choice) {
                        case 1:
                            System.out.print("Enter document name: ");
                            String docName = scanner.nextLine();
                            addDocument(docName);
                            break;
                        case 2:
                            processNextDocument();
                            break;
                        case 3:
                            viewProcessingQueue();
                            break;
                        case 4:
                            viewArchivedDocuments();
                            break;
                        case 5:
                            System.out.println("Exiting Document Processor.");
                            running = false;
                            break;
                        default:
                            System.err.println("Invalid choice. Please enter a number between 1 and 5.");
                    }
                } catch (java.util.InputMismatchException e) {
                    System.err.println("Invalid input. Please enter a number.");
                    scanner.nextLine(); // Consume the invalid input to prevent infinite loop
                } catch (Exception e) {
                    // Catch any other unexpected exceptions within the switch block
                    System.err.println("An unexpected error occurred during command processing: " + e.getMessage());
                    // e.printStackTrace(System.err); // Optional: print stack trace
                }
                System.out.println(); // Add a newline for better readability between actions
            }
        } catch (Exception e) {
            // This outer catch block handles any exceptions that escape the inner blocks
            // Fulfills the "class-wide" or "broad" exception handling requirement
            System.err.println("A critical error occurred, application is shutting down.");
            e.printStackTrace(System.err); // Print stack trace for critical errors
        } finally {
            // Ensure the scanner is closed regardless of how the loop exits
            scanner.close();
            System.out.println("Scanner closed.");
        }
    }

    // Helper method to print the menu
    private void printMenu() {
        System.out.println("--- Document Processor Menu ---");
        System.out.println("1. Add Document");
        System.out.println("2. Process Next Document");
        System.out.println("3. View Processing Queue");
        System.out.println("4. View Archived Documents");
        System.out.println("5. Exit");
        System.out.println("-----------------------------");
    }

    // Main method to start the application
    public static void main(String[] args) {
        DocumentProcessor processor = new DocumentProcessor();
        processor.run();
    }
}
