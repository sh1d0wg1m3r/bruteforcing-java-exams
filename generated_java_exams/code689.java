/*
 * Exam Question #689
 * Generated on: 2025-05-12 16:26:08
 * Generated by: Account 1
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Job Processing System
 * 
 * **Scenario:**
 * 
 * You are tasked with building a simple system to manage and process jobs. Jobs arrive and are placed in a queue to await processing in the order they were received (First-In, First-Out). Once a job is processed, it is moved to a history list of completed jobs. The system should allow users to submit new jobs, process the next available job, view the list of pending jobs, and view the history of completed jobs via a command-line interface.
 * 
 * **Requirements:**
 * 
 * Your solution must be a complete Java program that demonstrates the following:
 * 
 * 1.  **Data Structures:**
 *     *   Use `java.util.Queue` to store jobs awaiting processing.
 *     *   Use `java.util.ArrayList` to store completed jobs.
 *     *   Use `java.util.List` as the declared type for the collection of completed jobs.
 * 
 * 2.  **Input/Output:**
 *     *   Use `java.util.Scanner` to read user input from the console.
 *     *   Use `System.out` for normal program output (menu, prompts, success messages, list displays).
 *     *   Use `System.err` for displaying error messages (e.g., invalid input, operational errors).
 * 
 * 3.  **Control Flow:**
 *     *   Use a `switch` statement to handle the main menu options.
 *     *   Implement a loop to keep the system running until the user chooses to exit.
 * 
 * 4.  **Error Handling:**
 *     *   Implement class-wide exception handling using `try-catch` blocks to gracefully handle potential runtime errors, such as invalid input format (`InputMismatchException`).
 *     *   Validate user input where necessary (e.g., job description should not be empty).
 *     *   Handle cases where operations cannot be performed (e.g., processing a job when the queue is empty).
 * 
 * 5.  **Object-Oriented Design & Best Practices:**
 *     *   Create a `Job` class to represent a single job with appropriate fields (e.g., ID, description, status) and methods (e.g., constructor, getters, method to mark as completed). Use proper encapsulation (private fields, public methods).
 *     *   Create a separate class (e.g., `JobProcessor`) to manage the collections (`Queue` and `List`) and the core logic (submitting, processing, viewing jobs).
 *     *   Use meaningful variable and method names.
 *     *   Include appropriate comments and documentation (e.g., method descriptions).
 *     *   Structure the code cleanly.
 * 
 * **Functional Requirements (Menu Options):**
 * 
 * The system should present a menu with the following options:
 * 
 * 1.  **Submit New Job:** Prompt the user for a job description. Create a new `Job` object with a unique ID and the provided description, and add it to the pending jobs queue. Display a success message. If the description is empty, display an error using `System.err` and do not submit the job.
 * 2.  **Process Next Job:** Take the job at the front of the pending jobs queue. Mark it as completed and move it to the completed jobs list. Display a success message indicating which job was processed. If the queue is empty, display an error message using `System.err`.
 * 3.  **View Pending Jobs:** Display the details of all jobs currently in the pending queue, in their current order. If the queue is empty, display a message indicating so.
 * 4.  **View Completed Jobs:** Display the details of all jobs that have been processed and are in the completed jobs list. If the list is empty, display a message indicating so.
 * 5.  **Exit:** Terminate the program.
 * 
 * **Expected Interaction & Output:**
 * 
 * The program should start by displaying a welcome message and the menu. It should then repeatedly prompt the user for input, execute the chosen action, and display the results or errors. Invalid menu choices or incorrect input types should be handled gracefully with informative messages printed to `System.err`. Successful operations and list displays should use `System.out`.
 * 
 * **Example Interaction Flow:**
 * 
 * ```
 * --- Job Processing System ---
 * 
 * Select an option:
 * 1. Submit New Job
 * 2. Process Next Job
 * 3. View Pending Jobs
 * 4. View Completed Jobs
 * 5. Exit
 * Enter your choice: 1
 * Enter job description: Process Report A
 * Job submitted successfully: Process Report A
 * 
 * Select an option:
 * ... (menu again)
 * Enter your choice: 1
 * Enter job description: Send Email B
 * Job submitted successfully: Send Email B
 * 
 * Select an option:
 * ... (menu again)
 * Enter your choice: 3
 * --- Pending Jobs ---
 * 1. Job [ID=1, Description='Process Report A', Status=Pending]
 * 2. Job [ID=2, Description='Send Email B', Status=Pending]
 * --------------------
 * 
 * Select an option:
 * ... (menu again)
 * Enter your choice: 2
 * Job processed successfully: Process Report A
 * 
 * Select an option:
 * ... (menu again)
 * Enter your choice: 3
 * --- Pending Jobs ---
 * 1. Job [ID=2, Description='Send Email B', Status=Pending]
 * --------------------
 * 
 * Select an option:
 * ... (menu again)
 * Enter your choice: 4
 * --- Completed Jobs ---
 * 1. Job [ID=1, Description='Process Report A', Status=Completed]
 * ----------------------
 * 
 * Select an option:
 * ... (menu again)
 * Enter your choice: 2
 * Job processed successfully: Send Email B
 * 
 * Select an option:
 * ... (menu again)
 * Enter your choice: 2
 * No pending jobs to process.
 * 
 * Select an option:
 * ... (menu again)
 * Enter your choice: 6
 * Invalid choice. Please enter a number between 1 and 5.
 * 
 * Select an option:
 * ... (menu again)
 * Enter your choice: abc
 * Invalid input. Please enter a number.
 * 
 * Select an option:
 * ... (menu again)
 * Enter your choice: 5
 * Exiting Job Processing System.
 * System shutdown complete.
 * ```
 * 
 * Your code should be well-structured, readable, and adhere to all the specified requirements.
 *
 * EXPLANATION:
 * This solution implements a simple Job Processing System as requested, demonstrating the use of all required Java components and following best practices.
 * 
 * **Architecture:**
 * The system is divided into three main classes for better organization and separation of concerns:
 * 1.  `Job`: Represents the data structure for a single job. It holds the job's ID, description, and completion status. It enforces that the description is not empty upon creation.
 * 2.  `JobProcessor`: Contains the core business logic. It manages the `pendingJobs` queue and the `completedJobs` list. It provides methods to `submitJob`, `processNextJob`, `viewPendingJobs`, and `viewCompletedJobs`.
 * 3.  `JobSystem`: The main class that contains the `main` method. It handles user interaction via a command-line menu, reads input using `Scanner`, directs calls to the `JobProcessor` based on user choice, and manages the main application loop.
 * 
 * **Required Component Usage:**
 * 
 * *   **`java.util.Queue`**: The `pendingJobs` field in `JobProcessor` is declared as a `Queue<Job>` and instantiated as a `LinkedList<Job>`. The `LinkedList` class implements the `Queue` interface and provides the necessary FIFO behavior using methods like `offer()` (to add to the end) and `poll()` (to remove from the front).
 * *   **`java.util.ArrayList`**: The `completedJobs` field in `JobProcessor` is instantiated as an `ArrayList<Job>`. `ArrayList` is used here because the order of completed jobs matters (order of completion), and random access or iteration is needed, which `ArrayList` provides efficiently.
 * *   **`java.util.List`**: The `completedJobs` field is declared using the `List<Job>` interface type, demonstrating good practice by programming to the interface rather than the specific implementation (`ArrayList`).
 * *   **`java.util.Scanner`**: An instance of `Scanner` is created in the `main` method of `JobSystem` to read user input from `System.in`. Methods like `nextInt()` and `nextLine()` are used. The consumption of the newline character after `nextInt()` is crucial to prevent issues with subsequent `nextLine()` calls.
 * *   **`switch` statement**: The `main` method in `JobSystem` uses a `switch` statement on the user's menu choice (`int choice`) to dispatch the appropriate action (calling `JobProcessor` methods or exiting).
 * *   **`System.err`**: This stream is used exclusively for displaying error messages. Examples include invalid menu choices, `InputMismatchException` for non-integer input, validation errors (like empty job description reported from `submitJob`), and operational errors (like trying to process a job when the queue is empty).
 * *   **`System.out`**: This stream is used for all normal program output, including the welcome message, the menu display, prompts for input, success messages after submitting or processing jobs, and displaying the contents of the pending and completed job lists.
 * *   **`try-catch` blocks**: The `main` method in `JobSystem` wraps the input reading and `switch` block in a `try-catch` structure. It specifically catches `InputMismatchException` to handle cases where the user enters non-integer input for the menu choice, preventing the program from crashing and allowing recovery. A general `catch (Exception e)` is included as a fallback for any other unexpected runtime errors. The `submitJob` method in `JobProcessor` also uses a `try-catch` block to handle the `IllegalArgumentException` thrown by the `Job` constructor if an invalid (empty) description is provided.
 * 
 * **Best Practices:**
 * 
 * *   **Encapsulation**: Fields in `Job` and `JobProcessor` are `private`, and access/modification is controlled via public methods (getters, `markCompleted`, `submitJob`, etc.).
 * *   **Meaningful Names**: Classes (`Job`, `JobProcessor`, `JobSystem`), variables (`pendingJobs`, `completedJobs`, `nextJobId`, `description`, `choice`), and methods (`submitJob`, `processNextJob`, `viewPendingJobs`, `printMenu`) have names that clearly indicate their purpose.
 * *   **Comments and Documentation**: Javadoc-style comments are used for classes and methods, explaining their purpose, parameters, and potential exceptions. Inline comments explain specific code nuances (e.g., consuming newline after `nextInt`).
 * *   **Input Validation**: The `Job` constructor validates the description. The `JobSystem` handles non-integer input for the menu. The `JobProcessor.submitJob` method catches the validation error from `Job`.
 * *   **Error Handling**: Specific exceptions are handled (`InputMismatchException`), and operational errors (like an empty queue) are checked for and reported using `System.err`.
 * *   **Clean Code Structure**: The code is logically separated into classes, methods are focused on single responsibilities, and the main loop in `JobSystem` is easy to follow.
 * 
 * This solution effectively integrates the required components into a functional, robust, and well-structured application, demonstrating an advanced understanding of core Java concepts and best practices suitable for a challenging exam task.
 */

// Job.java
// Represents a single job in the system.
package com.example.jobsystem;

public class Job {
    private int id;
    private String description;
    private boolean isCompleted;

    /**
     * Constructs a new Job object.
     * @param id The unique identifier for the job.
     * @param description The description of the job. Cannot be null or empty.
     * @throws IllegalArgumentException if the description is null or empty.
     */
    public Job(int id, String description) {
        if (description == null || description.trim().isEmpty()) {
            throw new IllegalArgumentException("Job description cannot be null or empty.");
        }
        this.id = id;
        this.description = description.trim();
        this.isCompleted = false; // Jobs are initially not completed
    }

    // --- Getters ---
    public int getId() {
        return id;
    }

    public String getDescription() {
        return description;
    }

    public boolean isCompleted() {
        return isCompleted;
    }

    /**
     * Marks this job as completed.
     */
    public void markCompleted() {
        this.isCompleted = true;
    }

    /**
     * Provides a string representation of the Job.
     */
    @Override
    public String toString() {
        return "Job [ID=" + id + ", Description='" + description + "', Status=" + (isCompleted ? "Completed" : "Pending") + "]";
    }
}
```
```java
// JobProcessor.java
// Manages the queue of pending jobs and the list of completed jobs.
package com.example.jobsystem;

import java.util.Queue;
import java.util.LinkedList; // A common implementation of Queue
import java.util.List;
import java.util.ArrayList; // A common implementation of List

public class JobProcessor {
    // Queue to hold jobs waiting to be processed (FIFO)
    private Queue<Job> pendingJobs;

    // List to hold jobs that have been processed
    private List<Job> completedJobs;

    // Counter for generating unique job IDs
    private int nextJobId;

    /**
     * Constructs a new JobProcessor, initializing the collections and job ID counter.
     */
    public JobProcessor() {
        this.pendingJobs = new LinkedList<>(); // Use LinkedList as a Queue
        this.completedJobs = new ArrayList<>(); // Use ArrayList as a List
        this.nextJobId = 1; // Start job IDs from 1
    }

    /**
     * Creates a new Job and adds it to the pending jobs queue.
     * Input validation for description is handled by the Job constructor.
     * @param description The description of the job.
     */
    public void submitJob(String description) {
        // The Job constructor throws IllegalArgumentException if description is invalid.
        // We catch it here to report the error using System.err.
        try {
            Job newJob = new Job(nextJobId, description);
            pendingJobs.offer(newJob); // offer() is generally preferred for queues; adds to the end.
            nextJobId++; // Increment ID for the next job
            System.out.println("Job submitted successfully: " + newJob.getDescription()); // Use System.out for success
        } catch (IllegalArgumentException e) {
            // Use System.err for validation errors
            System.err.println("Submission failed: " + e.getMessage());
        }
    }

    /**
     * Processes the next job from the front of the pending queue.
     * Marks the job as completed and moves it to the completed list.
     */
    public void processNextJob() {
        // Check if the queue is empty before attempting to process
        if (pendingJobs.isEmpty()) {
            // Use System.err for operational errors (cannot perform action)
            System.err.println("No pending jobs to process.");
            return; // Exit the method if nothing to process
        }

        // poll() retrieves and removes the head of the queue. Returns null if empty.
        // Since we checked isEmpty(), it should not return null here.
        Job jobToProcess = pendingJobs.poll();

        if (jobToProcess != null) {
            jobToProcess.markCompleted(); // Mark the job as completed
            completedJobs.add(jobToProcess); // Add the job to the completed list
            System.out.println("Job processed successfully: " + jobToProcess.getDescription()); // Use System.out for success
        } else {
             // Defensive check, should not happen if isEmpty() is checked first
            System.err.println("Error retrieving job from queue.");
        }
    }

    /**
     * Displays all jobs currently in the pending queue.
     */
    public void viewPendingJobs() {
        System.out.println("\n--- Pending Jobs ---"); // Use System.out for normal output
        if (pendingJobs.isEmpty()) {
            System.out.println("No jobs currently pending.");
        } else {
            // Iterate through the queue without removing elements
            int count = 1;
            for (Job job : pendingJobs) {
                System.out.println(count++ + ". " + job);
            }
        }
        System.out.println("--------------------");
    }

    /**
     * Displays all jobs that have been completed.
     */
    public void viewCompletedJobs() {
        System.out.println("\n--- Completed Jobs ---"); // Use System.out for normal output
        if (completedJobs.isEmpty()) {
            System.out.println("No jobs have been completed yet.");
        } else {
            // Iterate through the completed list
            int count = 1;
            for (Job job : completedJobs) {
                System.out.println(count++ + ". " + job);
            }
        }
        System.out.println("----------------------");
    }
}
```
```java
// JobSystem.java
// Main class to run the Job Processing System with a user interface.
package com.example.jobsystem;

import java.util.InputMismatchException; // Specific exception for input type mismatch
import java.util.Scanner; // For reading user input

public class JobSystem {

    public static void main(String[] args) {
        // Use Scanner for reading input from standard input stream (System.in)
        Scanner scanner = new Scanner(System.in);
        JobProcessor processor = new JobProcessor();
        boolean running = true; // Flag to control the main application loop

        System.out.println("--- Job Processing System ---"); // Use System.out for welcome message

        // Main application loop
        while (running) {
            printMenu(); // Display menu options

            // Use try-catch for class-wide exception handling, primarily for input errors
            try {
                System.out.print("Enter your choice: ");
                // Read the integer choice
                int choice = scanner.nextInt();
                // Consume the rest of the line, including the newline character,
                // to prevent issues with subsequent nextLine() calls.
                scanner.nextLine();

                // Use a switch statement to handle different menu options
                switch (choice) {
                    case 1:
                        System.out.print("Enter job description: ");
                        String description = scanner.nextLine();
                        processor.submitJob(description); // Call the processor method
                        break;
                    case 2:
                        processor.processNextJob(); // Call the processor method
                        break;
                    case 3:
                        processor.viewPendingJobs(); // Call the processor method
                        break;
                    case 4:
                        processor.viewCompletedJobs(); // Call the processor method
                        break;
                    case 5:
                        running = false; // Set flag to exit the loop
                        System.out.println("Exiting Job Processing System."); // Use System.out for exit message
                        break;
                    default:
                        // Handle invalid integer choices
                        System.err.println("Invalid choice. Please enter a number between 1 and 5."); // Use System.err for invalid input
                        break;
                }
            } catch (InputMismatchException e) {
                // Catch exception if user enters non-integer input for choice
                System.err.println("Invalid input. Please enter a number."); // Use System.err for input type errors
                scanner.nextLine(); // IMPORTANT: Consume the invalid input to prevent infinite loop
            } catch (Exception e) {
                // Catch any other unexpected exceptions during program execution
                System.err.println("An unexpected error occurred: " + e.getMessage()); // Use System.err for unexpected errors
                // Optional: e.printStackTrace(System.err); // Useful for debugging in exam
            }
            System.out.println(); // Add a blank line for better readability between menu cycles
        }

        scanner.close(); // Close the scanner resource when done
        System.out.println("System shutdown complete.");
    }

    /**
     * Helper method to print the main menu options to the console.
     */
    private static void printMenu() {
        System.out.println("\nSelect an option:"); // Use System.out for menu display
        System.out.println("1. Submit New Job");
        System.out.println("2. Process Next Job");
        System.out.println("3. View Pending Jobs");
        System.out.println("4. View Completed Jobs");
        System.out.println("5. Exit");
    }
}
