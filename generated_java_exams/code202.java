/*
 * Exam Question #202
 * Generated on: 2025-05-11 22:31:23
 * Generated by: Account 2
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Advanced Job Scheduler Simulation
 * 
 * **Objective:** Design and implement a console-based simulation of a simple job scheduler system. The system should allow users to add new jobs to a waiting queue, process the next job from the queue, and view both waiting and completed jobs. This task requires demonstrating proficiency in core Java data structures, control flow, input/output, and exception handling.
 * 
 * **Scenario:** You are building a simplified backend system for processing tasks. New tasks arrive and are placed in a waiting queue. A processor component picks up tasks one by one from the front of the queue, simulates processing, and moves them to a list of completed tasks.
 * 
 * **Requirements:**
 * 
 * 1.  **Job Representation:** Create a simple `Job` class with the following attributes:
 *     *   `id` (int): A unique identifier for the job.
 *     *   `description` (String): A brief description of the job.
 *     *   `status` (String): The current status of the job (e.g., "Waiting", "Processing", "Completed").
 *     *   Include a constructor, getters, and a meaningful `toString()` method.
 * 
 * 2.  **Scheduler Simulation Class:** Create a class named `JobSchedulerSimulation` to manage the system.
 *     *   This class must use a `java.util.Queue<Job>` to store jobs that are waiting to be processed.
 *     *   This class must use a `java.util.List<Job>` (specifically implemented by `java.util.ArrayList<Job>`) to store jobs that have been completed.
 *     *   Use a `java.util.Scanner` for reading user input from the console.
 *     *   Maintain a counter for generating unique job IDs.
 * 
 * 3.  **Functionality:** Implement the following actions via a menu presented to the user:
 *     *   **1. Add New Job:** Prompt the user for a job description. Create a new `Job` object with a unique ID, set its status to "Waiting", and add it to the waiting queue.
 *     *   **2. Process Next Job:** Take the job at the front of the waiting queue. If the queue is not empty, change its status to "Completed" and add it to the completed jobs list. If the queue is empty, inform the user.
 *     *   **3. View Waiting Jobs:** Display the details of all jobs currently in the waiting queue.
 *     *   **4. View Completed Jobs:** Display the details of all jobs currently in the completed jobs list.
 *     *   **5. Exit:** Terminate the simulation.
 * 
 * 4.  **Control Flow:**
 *     *   Use a loop to continuously display the menu and process user input until the "Exit" option is chosen.
 *     *   Use a `switch` statement to handle the different menu options.
 * 
 * 5.  **Input/Output:**
 *     *   Use `System.out` for displaying the menu, prompts, job details, and success messages.
 *     *   Use `System.err` for displaying error messages (e.g., invalid menu choice, empty queue processing attempt, invalid input during job creation).
 * 
 * 6.  **Error Handling:**
 *     *   Implement input validation for user input (e.g., ensuring menu choice is a valid number within the range, ensuring job description is not empty).
 *     *   Use `try-catch` blocks within the `JobSchedulerSimulation` class to handle potential runtime exceptions gracefully, such as issues with reading input or unexpected errors during processing. A single `try-catch` block covering the main interaction loop is sufficient for class-wide handling in this context.
 * 
 * 7.  **Best Practices:**
 *     *   Apply proper encapsulation by making class fields `private` and providing `public` methods for interaction.
 *     *   Use meaningful names for variables, methods, and classes.
 *     *   Include comments or Javadoc to explain the purpose of classes and methods.
 *     *   Ensure resources like `Scanner` are properly closed.
 * 
 * **Expected Output:** The program should display a menu, accept user input, perform the requested actions, and provide appropriate feedback via `System.out` or `System.err`. Example interaction might look like:
 * 
 * ```
 * Job Scheduler Menu:
 * 1. Add New Job
 * 2. Process Next Job
 * 3. View Waiting Jobs
 * 4. View Completed Jobs
 * 5. Exit
 * Enter your choice: 1
 * Enter job description: Clean the office
 * Job added: Job{id=1, description='Clean the office', status='Waiting'}
 * 
 * Job Scheduler Menu:
 * ...
 * Enter your choice: 1
 * Enter job description: Prepare report
 * Job added: Job{id=2, description='Prepare report', status='Waiting'}
 * 
 * Job Scheduler Menu:
 * ...
 * Enter your choice: 3
 * Waiting Jobs:
 * Job{id=1, description='Clean the office', status='Waiting'}
 * Job{id=2, description='Prepare report', status='Waiting'}
 * 
 * Job Scheduler Menu:
 * ...
 * Enter your choice: 2
 * Processing job: Job{id=1, description='Clean the office', status='Waiting'}
 * Job completed: Job{id=1, description='Clean the office', status='Completed'}
 * 
 * Job Scheduler Menu:
 * ...
 * Enter your choice: 4
 * Completed Jobs:
 * Job{id=1, description='Clean the office', status='Completed'}
 * 
 * Job Scheduler Menu:
 * ...
 * Enter your choice: 2
 * Processing job: Job{id=2, description='Prepare report', status='Waiting'}
 * Job completed: Job{id=2, description='Prepare report', status='Completed'}
 * 
 * Job Scheduler Menu:
 * ...
 * Enter your choice: 2
 * No jobs in the waiting queue to process.
 * 
 * Job Scheduler Menu:
 * ...
 * Enter your choice: 6
 * Invalid choice. Please enter a number between 1 and 5.
 * 
 * Job Scheduler Menu:
 * ...
 * Enter your choice: exit
 * Invalid input. Please enter a number.
 * ```
 * 
 * Your solution should be a single Java file containing the `Job` class and the `JobSchedulerSimulation` class with a `main` method to start the simulation.
 *
 * EXPLANATION:
 * This solution implements a `JobSchedulerSimulation` that manages jobs using a `Queue` for waiting tasks and a `List` (specifically an `ArrayList`) for completed tasks, fulfilling all the requirements.
 * 
 * **Key Components and Concepts Demonstrated:**
 * 
 * 1.  **`Job` Class:** A simple Plain Old Java Object (POJO) representing a job with encapsulated fields (`id`, `description`, `status`), a constructor, getters, and a `toString()` method for easy printing.
 * 2.  **`java.util.Queue`:** The `jobQueue` is declared as a `Queue<Job>` and implemented using `java.util.LinkedList`. This correctly models the FIFO (First-In, First-Out) nature of a waiting line where the oldest job is processed first. The `offer()` method is used to add jobs (safer than `add()`), and `poll()` is used to retrieve and remove the head of the queue (safer than `remove()`, as it returns `null` if the queue is empty). Iteration for viewing waiting jobs uses a simple enhanced for loop, which traverses the queue without removing elements.
 * 3.  **`java.util.List` and `java.util.ArrayList`:** The `completedJobs` is declared as a `List<Job>` and initialized as an `ArrayList<Job>`. This demonstrates using the interface type for the variable, allowing flexibility if a different `List` implementation were needed later. `ArrayList` is suitable here as completed jobs don't require FIFO access; random access and dynamic resizing are its strengths. Jobs are added using the `add()` method, and iteration for viewing completed jobs uses an enhanced for loop.
 * 4.  **`java.util.Scanner`:** Used in the `JobSchedulerSimulation` class to read user input from `System.in` for menu choices and job descriptions. Input validation is included to handle non-integer input for the menu and empty job descriptions. `scanner.nextLine()` is used after `scanner.nextInt()` to consume the leftover newline character, preventing input issues in subsequent `nextLine()` calls.
 * 5.  **`switch` Statement:** Located in the `startSimulation` method, the `switch` statement efficiently directs the program flow based on the user's integer menu choice, calling the appropriate private methods (`addNewJob`, `processNextJob`, etc.).
 * 6.  **`System.err`:** Used specifically for outputting error messages, such as invalid menu choices, invalid input during job creation, and attempts to process jobs when the queue is empty. This separates error output from normal program output (`System.out`).
 * 7.  **`System.out`:** Used for displaying the menu, prompts for input, details of jobs, success messages, and simulation start/exit messages.
 * 8.  **Class-wide `try-catch`:** A `try-catch` block wraps the main `while` loop in the `startSimulation` method. This provides a central point for catching unexpected runtime exceptions that might occur during the execution of the simulation logic, preventing the program from crashing abruptly. A general `Exception` is caught, and its message and stack trace are printed to `System.err`. A `finally` block ensures the `Scanner` is closed regardless of whether an exception occurred or the loop finished normally. More specific `try-catch` blocks are also used locally (e.g., around `scanner.nextInt()` to catch `InputMismatchException`).
 * 9.  **Encapsulation:** Fields in both `Job` and `JobSchedulerSimulation` are `private`, and access is provided through `public` methods (getters, constructor, `startSimulation`, `main`).
 * 10. **Meaningful Names:** Variables (`jobQueue`, `completedJobs`, `nextJobId`, `description`), methods (`startSimulation`, `addNewJob`, `processNextJob`, `viewWaitingJobs`), and classes (`Job`, `JobSchedulerSimulation`) have names that clearly indicate their purpose.
 * 11. **Comments and Documentation:** Javadoc comments explain the purpose of classes and methods, and inline comments clarify specific logic points.
 * 12. **Input Validation:** Checks are performed to ensure the menu choice is a valid integer and within the expected range, and that the job description is not empty. Error messages are printed to `System.err` for invalid input.
 * 13. **Error Handling:** The `try-catch` blocks, combined with checking the return value of `queue.poll()` and validating input, provide robust error handling for common issues in this simulation. Using `System.err` for errors is also a key part of this.
 * 14. **Clean Code Structure:** The code is organized into logical methods, each responsible for a single task (displaying menu, adding job, processing job, viewing jobs). The `main` method is kept simple, primarily creating the simulation object and starting it. Resource management (`scanner.close()`) is handled correctly in a `finally` block.
 * 
 * This solution effectively integrates the required Java components into a practical simulation, demonstrating an understanding of data structures, control flow, I/O, and exception handling best practices.
 */

import java.util.LinkedList;
import java.util.Queue;
import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;
import java.util.InputMismatchException;

/**
 * Represents a single job in the scheduling system.
 */
class Job {
    private int id;
    private String description;
    private String status;

    /**
     * Constructs a new Job.
     * @param id The unique identifier for the job.
     * @param description A brief description of the job.
     * @param status The initial status of the job.
     */
    public Job(int id, String description, String status) {
        this.id = id;
        this.description = description;
        this.status = status;
    }

    // Getters
    public int getId() {
        return id;
    }

    public String getDescription() {
        return description;
    }

    public String getStatus() {
        return status;
    }

    // Setter for status (needed for processing)
    public void setStatus(String status) {
        this.status = status;
    }

    /**
     * Returns a string representation of the Job.
     */
    @Override
    public String toString() {
        return "Job{" +
               "id=" + id +
               ", description='" + description + '\'' +
               ", status='" + status + '\'' +
               '}';
    }
}

/**
 * Simulates a job scheduling system using a queue for waiting jobs
 * and a list for completed jobs.
 */
public class JobSchedulerSimulation {

    private Queue<Job> jobQueue; // Queue for jobs waiting to be processed
    private List<Job> completedJobs; // List for jobs that are completed
    private Scanner scanner; // Scanner for user input
    private int nextJobId; // Counter for generating unique job IDs

    /**
     * Constructs a new JobSchedulerSimulation.
     * Initializes the job queue, completed jobs list, scanner, and job ID counter.
     */
    public JobSchedulerSimulation() {
        // Using LinkedList as an implementation of Queue
        this.jobQueue = new LinkedList<>();
        // Using ArrayList as an implementation of List
        this.completedJobs = new ArrayList<>();
        this.scanner = new Scanner(System.in);
        this.nextJobId = 1; // Start job IDs from 1
    }

    /**
     * Starts the main simulation loop, displaying the menu and processing user input.
     * Includes class-wide exception handling.
     */
    public void startSimulation() {
        System.out.println("--- Job Scheduler Simulation Started ---");
        boolean running = true;

        // Class-wide try-catch block for the main simulation loop
        try {
            while (running) {
                displayMenu();
                System.out.print("Enter your choice: ");

                int choice = -1;
                try {
                    choice = scanner.nextInt();
                    // Consume the newline character left by nextInt()
                    scanner.nextLine();
                } catch (InputMismatchException e) {
                    System.err.println("Invalid input. Please enter a number.");
                    scanner.nextLine(); // Consume the invalid input to prevent infinite loop
                    continue; // Skip to the next iteration
                }

                // Use switch statement for menu options
                switch (choice) {
                    case 1:
                        addNewJob();
                        break;
                    case 2:
                        processNextJob();
                        break;
                    case 3:
                        viewWaitingJobs();
                        break;
                    case 4:
                        viewCompletedJobs();
                        break;
                    case 5:
                        running = false;
                        System.out.println("Exiting Job Scheduler Simulation.");
                        break;
                    default:
                        System.err.println("Invalid choice. Please enter a number between 1 and 5.");
                }
                System.out.println(); // Add a newline for better readability between actions
            }
        } catch (Exception e) {
            // Catch any unexpected exceptions during the simulation
            System.err.println("An unexpected error occurred: " + e.getMessage());
            e.printStackTrace(System.err); // Print stack trace to standard error
        } finally {
            // Ensure scanner is closed even if an exception occurs
            closeScanner();
        }
    }

    /**
     * Displays the main menu options to the user.
     */
    private void displayMenu() {
        System.out.println("Job Scheduler Menu:");
        System.out.println("1. Add New Job");
        System.out.println("2. Process Next Job");
        System.out.println("3. View Waiting Jobs");
        System.out.println("4. View Completed Jobs");
        System.out.println("5. Exit");
    }

    /**
     * Prompts the user for job details and adds a new job to the waiting queue.
     */
    private void addNewJob() {
        System.out.print("Enter job description: ");
        String description = scanner.nextLine().trim(); // Read description and trim whitespace

        // Input validation for description
        if (description.isEmpty()) {
            System.err.println("Job description cannot be empty.");
            return; // Exit the method if description is invalid
        }

        Job newJob = new Job(nextJobId++, description, "Waiting");
        jobQueue.offer(newJob); // offer() is preferred for adding to queue (returns false on failure, doesn't throw exception)
        System.out.println("Job added: " + newJob);
    }

    /**
     * Processes the next job from the waiting queue and moves it to the completed list.
     */
    private void processNextJob() {
        // poll() retrieves and removes the head of the queue, or returns null if the queue is empty
        Job jobToProcess = jobQueue.poll();

        if (jobToProcess != null) {
            System.out.println("Processing job: " + jobToProcess);
            // Simulate processing by changing status
            jobToProcess.setStatus("Completed");
            completedJobs.add(jobToProcess);
            System.out.println("Job completed: " + jobToProcess);
        } else {
            System.err.println("No jobs in the waiting queue to process.");
        }
    }

    /**
     * Displays all jobs currently in the waiting queue.
     */
    private void viewWaitingJobs() {
        System.out.println("--- Waiting Jobs ---");
        if (jobQueue.isEmpty()) {
            System.out.println("No jobs waiting.");
        } else {
            // Iterate through the queue without removing elements
            for (Job job : jobQueue) {
                System.out.println(job);
            }
        }
    }

    /**
     * Displays all jobs currently in the completed jobs list.
     */
    private void viewCompletedJobs() {
        System.out.println("--- Completed Jobs ---");
        // Use List interface variable to refer to the ArrayList
        List<Job> completedList = completedJobs;
        if (completedList.isEmpty()) {
            System.out.println("No jobs completed yet.");
        } else {
            // Iterate through the list
            for (Job job : completedList) {
                System.out.println(job);
            }
        }
    }

    /**
     * Closes the scanner resource.
     */
    private void closeScanner() {
        if (scanner != null) {
            scanner.close();
            System.out.println("Scanner closed.");
        }
    }

    /**
     * Main method to start the simulation.
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        JobSchedulerSimulation simulation = new JobSchedulerSimulation();
        simulation.startSimulation();
    }
}
