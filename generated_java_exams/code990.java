/*
 * Exam Question #990
 * Generated on: 2025-05-12 17:09:29
 * Generated by: Account 4
 * 
 * QUESTION:
 * Design and implement a simple command-line Task Management System in Java. The system should allow users to add new tasks to a processing queue, process the next task from the queue, view pending tasks, and view completed tasks.
 * 
 * Your solution must adhere to the following requirements:
 * 
 * 1.  **Data Structures:**
 *     *   Use `java.util.Queue` to manage tasks waiting for processing.
 *     *   Use `java.util.ArrayList` to store tasks that have been completed.
 *     *   Declare variables using the `java.util.List` interface type where appropriate (e.g., for the completed tasks list).
 * 2.  **User Interaction:**
 *     *   Use `java.util.Scanner` to read user input from the console (menu choices and task descriptions).
 * 3.  **Control Flow:**
 *     *   Use a `switch` statement to handle different menu options selected by the user.
 * 4.  **Output:**
 *     *   Use `System.out` for displaying the menu, task details, and success messages.
 *     *   Use `System.err` for displaying error messages (e.g., invalid input, trying to process an empty queue).
 * 5.  **Error Handling:**
 *     *   Implement class-wide exception handling using `try-catch` blocks. Specifically, handle potential input errors when reading the user's menu choice using `Scanner`.
 *     *   Handle the scenario where a user attempts to process a task when the queue is empty, reporting the error via `System.err`.
 * 6.  **Best Practices:**
 *     *   Use proper encapsulation (private fields, public methods) for classes.
 *     *   Use meaningful variable and method names.
 *     *   Include comments and documentation (inline comments explaining logic are sufficient).
 *     *   Implement basic input validation (e.g., check if a task description is provided).
 *     *   Ensure proper error handling messages are displayed via `System.err`.
 *     *   Structure your code logically into appropriate classes.
 * 
 * **System Functionality:**
 * 
 * *   **Add Task:** Prompts the user for a task description. Creates a new task with a unique ID and `PENDING` status and adds it to the processing queue. Input validation should ensure the description is not empty.
 * *   **Process Next Task:** Removes the task at the front of the queue using `poll()`. If a task is retrieved, updates its status to `COMPLETED` and adds it to the completed tasks list. If the queue is empty (`poll()` returns null), prints an error message to `System.err`.
 * *   **View Pending Tasks:** Displays all tasks currently in the processing queue.
 * *   **View Completed Tasks:** Displays all tasks in the completed tasks list.
 * *   **Exit:** Terminates the program.
 * 
 * **Example Interaction (Illustrative):**
 * 
 * ```
 * --- Task Management System ---
 * Task Management System Menu:
 * 1. Add New Task
 * 2. Process Next Task
 * 3. View Pending Tasks
 * 4. View Completed Tasks
 * 5. Exit
 * Enter your choice: 1
 * Enter task description: Write exam question
 * Task 1: 'Write exam question' added to the queue.
 * 
 * Task Management System Menu:
 * 1. Add New Task
 * 2. Process Next Task
 * 3. View Pending Tasks
 * 4. View Completed Tasks
 * 5. Exit
 * Enter your choice: 1
 * Enter task description: Create solution code
 * Task 2: 'Create solution code' added to the queue.
 * 
 * Task Management System Menu:
 * 1. Add New Task
 * 2. Process Next Task
 * 3. View Pending Tasks
 * 4. View Completed Tasks
 * 5. Exit
 * Enter your choice: 3
 * 
 * --- Pending Tasks ---
 * Task 1 [PENDING]: Write exam question
 * Task 2 [PENDING]: Create solution code
 * ---------------------
 * 
 * 
 * Task Management System Menu:
 * 1. Add New Task
 * 2. Process Next Task
 * 3. View Pending Tasks
 * 4. View Completed Tasks
 * 5. Exit
 * Enter your choice: 2
 * Processing task 1: 'Write exam question'... Completed.
 * 
 * Task Management System Menu:
 * 1. Add New Task
 * 2. Process Next Task
 * 3. View Pending Tasks
 * 4. View Completed Tasks
 * 5. Exit
 * Enter your choice: 4
 * 
 * --- Completed Tasks ---
 * Task 1 [COMPLETED]: Write exam question
 * ---------------------
 * 
 * 
 * Task Management System Menu:
 * 1. Add New Task
 * 2. Process Next Task
 * 3. View Pending Tasks
 * 4. View Completed Tasks
 * 5. Exit
 * Enter your choice: 2
 * Processing task 2: 'Create solution code'... Completed.
 * 
 * Task Management System Menu:
 * 1. Add New Task
 * 2. Process Next Task
 * 3. View Pending Tasks
 * 4. View Completed Tasks
 * 5. Exit
 * Enter your choice: 2
 * Error: No tasks in the queue to process.
 * 
 * Task Management System Menu:
 * 1. Add New Task
 * 2. Process Next Task
 * 3. View Pending Tasks
 * 4. View Completed Tasks
 * 5. Exit
 * Enter your choice: abc
 * Error: Invalid input. Please enter a number.
 * 
 * Task Management System Menu:
 * 1. Add New Task
 * 2. Process Next Task
 * 3. View Pending Tasks
 * 4. View Completed Tasks
 * 5. Exit
 * Enter your choice: 6
 * Error: Invalid choice. Please enter a number between 1 and 5.
 * 
 * Task Management System Menu:
 * 1. Add New Task
 * 2. Process Next Task
 * 3. View Pending Tasks
 * 4. View Completed Tasks
 * 5. Exit
 * Enter your choice: 5
 * Exiting Task Management System.
 * ```
 * 
 * Your solution should be provided as a single Java file containing all necessary classes (or nested classes if preferred for simplicity in a single file exam context).
 *
 * EXPLANATION:
 * This solution implements a simple command-line Task Management System, demonstrating the required Java concepts and best practices.
 * 
 * 1.  **`Queue` (`java.util.Queue`)**: The `TaskProcessor` class uses a `Queue<Task>` (`pendingTasks`) implemented by `java.util.LinkedList`. This structure is ideal for managing tasks waiting to be processed because it follows the First-In, First-Out (FIFO) principle. Tasks are added to the end of the queue (`offer()`) and removed from the front (`poll()`).
 * 
 * 2.  **`ArrayList` (`java.util.ArrayList`)**: The `TaskProcessor` uses an `ArrayList<Task>` to store `completedTasks`. An `ArrayList` is suitable here as it provides a dynamic array that is easy to add elements to (`add()`) and iterate over to view the history of completed tasks.
 * 
 * 3.  **`List` interface (`java.util.List`)**: The `completedTasks` field in `TaskProcessor` is declared as `List<Task>`, even though it's instantiated as `ArrayList<Task>`. This demonstrates programming to the interface, which promotes flexibility (the underlying implementation could be changed to `LinkedList` or another `List` implementation later without affecting code that uses the `List` interface). The `getPendingTasks()` and `getCompletedTasks()` methods also return `List<Task>`, adhering to this principle.
 * 
 * 4.  **`Scanner` (`java.util.Scanner`)**: Used in the `main` method of `TaskManagementSystem` to read user input from the console (`System.in`). It reads integer choices using `nextInt()` and string descriptions using `nextLine()`. A crucial detail is consuming the newline character left behind by `nextInt()` using a subsequent `scanner.nextLine()`.
 * 
 * 5.  **`switch` statement**: Used in the `main` method to control the flow of the program based on the integer choice read from the user, directing execution to the appropriate task management operation (add, process, view, exit).
 * 
 * 6.  **`System.err`**: Used specifically for outputting error messages, such as when the user provides invalid input (non-integer choice, empty description) or attempts an action that is not possible (processing from an empty queue). This separates error output from standard program output (`System.out`).
 * 
 * 7.  **`System.out`**: Used for all standard program output, including the menu, prompts, success messages, and the formatted details of pending and completed tasks.
 * 
 * 8.  **`try-catch` blocks**: Implemented in the `main` method around the code that reads the user's menu choice (`scanner.nextInt()`). This specifically catches `InputMismatchException`, which occurs if the user enters non-integer input. The `catch` block prints an error message to `System.err` and consumes the invalid input line using `scanner.nextLine()` to prevent an infinite loop. A general `catch (Exception e)` is also included to handle any other unexpected runtime errors that might occur during command processing, printing a generic error message.
 * 
 * **Best Practices and Structure:**
 * 
 * *   **Encapsulation:** The `Task` and `TaskProcessor` classes have private fields (`id`, `description`, `status`, `pendingTasks`, `completedTasks`) and provide public methods (`get...`, `setStatus`, `addTask`, `processNextTask`) to interact with their state.
 * *   **Meaningful Names:** Class names (`Task`, `TaskProcessor`, `TaskManagementSystem`), method names (`addTask`, `processNextTask`, `getPendingTasks`), and variable names (`pendingTasks`, `completedTasks`, `description`, `choice`) are descriptive.
 * *   **Comments and Documentation:** Inline comments explain the purpose of classes, methods, and key logic sections.
 * *   **Input Validation:** The `addTask` method checks if the provided description is null or empty. The `try-catch` block handles invalid input *type* for the menu choice.
 * *   **Error Handling:** Specific error messages are provided for different failure scenarios (invalid input type, invalid menu number, empty queue, general exception) and directed to `System.err`. The `processNextTask` method uses `poll()` and checks for `null` to handle the empty queue gracefully without relying on exceptions for this expected condition.
 * *   **Clean Code Structure:** The code is organized into separate classes (`TaskStatus`, `Task`, `TaskProcessor`, `TaskManagementSystem`) each responsible for a specific part of the system, promoting modularity and readability. The main application logic is contained within the `TaskManagementSystem` class's `main` method.
 * 
 * This solution effectively integrates the required Java components to build a functional system, demonstrating understanding of data structures, control flow, user interaction, and robust error handling.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.InputMismatchException;

// Enum to represent the status of a task
enum TaskStatus {
    PENDING,
    COMPLETED
}

// Represents a single task
class Task {
    private static int nextId = 1; // Static counter for unique task IDs
    private int id;
    private String description;
    private TaskStatus status;

    /**
     * Constructs a new Task with a unique ID and PENDING status.
     * @param description The description of the task.
     */
    public Task(String description) {
        this.id = nextId++;
        this.description = description;
        this.status = TaskStatus.PENDING;
    }

    // --- Getters ---
    public int getId() {
        return id;
    }

    public String getDescription() {
        return description;
    }

    public TaskStatus getStatus() {
        return status;
    }

    // --- Setter ---
    public void setStatus(TaskStatus status) {
        this.status = status;
    }

    /**
     * Returns a string representation of the task.
     */
    @Override
    public String toString() {
        return String.format("Task %d [%s]: %s", id, status, description);
    }
}

// Manages the collection of tasks (pending and completed)
class TaskProcessor {
    // Queue for tasks waiting to be processed (FIFO)
    private Queue<Task> pendingTasks;
    // List for tasks that have been completed
    private List<Task> completedTasks; // Declared using the List interface

    /**
     * Constructs a new TaskProcessor with empty task lists.
     */
    public TaskProcessor() {
        // LinkedList is a common implementation of the Queue interface
        this.pendingTasks = new LinkedList<>();
        // ArrayList is a common implementation of the List interface
        this.completedTasks = new ArrayList<>();
    }

    /**
     * Adds a new task to the pending queue.
     * Performs basic validation on the description.
     * @param description The description for the new task.
     */
    public void addTask(String description) {
        if (description == null || description.trim().isEmpty()) {
            System.err.println("Error: Task description cannot be empty.");
            return; // Exit method if validation fails
        }
        Task newTask = new Task(description.trim());
        pendingTasks.offer(newTask); // offer() is preferred over add() for queues
        System.out.println("Task " + newTask.getId() + ": '" + newTask.getDescription() + "' added to the queue.");
    }

    /**
     * Processes the next task in the pending queue.
     * Moves the task from pending to completed list upon processing.
     * Handles the case where the pending queue is empty.
     */
    public void processNextTask() {
        // poll() retrieves and removes the head of the queue, or returns null if the queue is empty
        Task taskToProcess = pendingTasks.poll();

        if (taskToProcess != null) {
            System.out.println("Processing task " + taskToProcess.getId() + ": '" + taskToProcess.getDescription() + "'...");
            // Simulate processing...
            taskToProcess.setStatus(TaskStatus.COMPLETED);
            completedTasks.add(taskToProcess);
            System.out.println("Task " + taskToProcess.getId() + " completed.");
        } else {
            // Use System.err for error messages
            System.err.println("Error: No tasks in the queue to process.");
        }
    }

    /**
     * Returns a list of tasks currently in the pending queue.
     * Returns a new list to prevent external modification of the internal queue state.
     * @return A List of pending tasks.
     */
    public List<Task> getPendingTasks() {
        // Convert the queue to a List for easy iteration and display
        return new ArrayList<>(pendingTasks);
    }

    /**
     * Returns a list of tasks that have been completed.
     * Returns a new list to prevent external modification of the internal list state.
     * @return A List of completed tasks.
     */
    public List<Task> getCompletedTasks() {
        // Return a copy of the completed tasks list
        return new ArrayList<>(completedTasks);
    }
}

// Main class to run the Task Management System
public class TaskManagementSystem {

    public static void main(String[] args) {
        // Scanner for reading user input
        Scanner scanner = new Scanner(System.in);
        // TaskProcessor instance to manage tasks
        TaskProcessor processor = new TaskProcessor();
        boolean running = true; // Control flag for the main loop

        System.out.println("--- Task Management System ---");

        // Main application loop
        while (running) {
            printMenu(); // Display menu options

            try {
                System.out.print("Enter your choice: ");
                // Read integer input for menu choice
                int choice = scanner.nextInt();
                // Consume the rest of the line after reading the integer
                scanner.nextLine();

                // Use switch statement to handle different menu options
                switch (choice) {
                    case 1: // Add New Task
                        System.out.print("Enter task description: ");
                        String description = scanner.nextLine();
                        processor.addTask(description); // Call TaskProcessor method
                        break;
                    case 2: // Process Next Task
                        processor.processNextTask(); // Call TaskProcessor method
                        break;
                    case 3: // View Pending Tasks
                        System.out.println("\n--- Pending Tasks ---");
                        List<Task> pending = processor.getPendingTasks(); // Get list from processor
                        if (pending.isEmpty()) {
                            System.out.println("No pending tasks.");
                        } else {
                            for (Task task : pending) {
                                System.out.println(task); // Use Task's toString()
                            }
                        }
                        System.out.println("---------------------\n");
                        break;
                    case 4: // View Completed Tasks
                        System.out.println("\n--- Completed Tasks ---");
                        List<Task> completed = processor.getCompletedTasks(); // Get list from processor
                         if (completed.isEmpty()) {
                            System.out.println("No completed tasks.");
                        } else {
                            for (Task task : completed) {
                                System.out.println(task); // Use Task's toString()
                            }
                        }
                        System.out.println("---------------------\n");
                        break;
                    case 5: // Exit
                        running = false; // Set flag to exit loop
                        System.out.println("Exiting Task Management System.");
                        break;
                    default: // Invalid choice
                        System.err.println("Error: Invalid choice. Please enter a number between 1 and 5.");
                }
            } catch (InputMismatchException e) {
                // Catch exception if user enters non-integer input for menu choice
                System.err.println("Error: Invalid input. Please enter a number.");
                // Consume the invalid input line to prevent infinite loop
                scanner.nextLine();
            } catch (Exception e) {
                // Catch any other unexpected runtime exceptions
                System.err.println("An unexpected error occurred: " + e.getMessage());
                // Optionally print stack trace for debugging: e.printStackTrace();
            }
            System.out.println(); // Add a blank line for readability between interactions
        }

        // Close the scanner resource
        scanner.close();
    }

    /**
     * Prints the main menu options to the console.
     */
    private static void printMenu() {
        System.out.println("Task Management System Menu:");
        System.out.println("1. Add New Task");
        System.out.println("2. Process Next Task");
        System.out.println("3. View Pending Tasks");
        System.out.println("4. View Completed Tasks");
        System.out.println("5. Exit");
    }
}
