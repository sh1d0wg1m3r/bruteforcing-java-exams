/*
 * Exam Question #896
 * Generated on: 2025-05-12 16:56:25
 * Generated by: Account 1
 * 
 * QUESTION:
 * ## Java Programming Exam: Resource Allocation and Task Processing System
 * 
 * **Problem Description:**
 * 
 * You are tasked with developing a simplified console-based system for managing and processing tasks within a resource allocation context. The system should allow users to submit tasks, view pending tasks, process the next available task, view completed tasks, and exit.
 * 
 * Tasks are submitted with a description and a priority level (HIGH, MEDIUM, LOW). The system processes tasks in a First-In, First-Out (FIFO) manner, regardless of priority, using a processing queue. Completed tasks are moved to a historical log.
 * 
 * Your solution must demonstrate proficiency in core Java data structures, control flow, input/output, and exception handling.
 * 
 * **Requirements:**
 * 
 * 1.  **Data Structures:**
 *     *   Use `java.util.Queue` to manage tasks waiting for processing. The processing order must be FIFO.
 *     *   Use `java.util.ArrayList` to store the history of tasks that have been processed.
 *     *   Use `java.util.List` as the declared type for the processed tasks history list.
 * 
 * 2.  **User Interaction:**
 *     *   Use `java.util.Scanner` to read user input from the console.
 *     *   Present a menu of options to the user:
 *         *   Add New Task
 *         *   Process Next Task
 *         *   View Pending Tasks
 *         *   View Processed Tasks
 *         *   Exit
 *     *   Handle user input for menu selection and task details.
 * 
 * 3.  **Control Flow:**
 *     *   Use a `switch` statement to handle the main menu navigation based on user input.
 * 
 * 4.  **Output:**
 *     *   Use `System.out` for all normal output, including the menu, prompts, task details, and success messages.
 *     *   Use `System.err` for displaying error messages (e.g., invalid input, attempting to process from an empty queue).
 * 
 * 5.  **Error Handling:**
 *     *   Implement input validation for the task priority (only "HIGH", "MEDIUM", or "LOW" should be accepted, case-insensitive). Reject invalid priority input and inform the user using `System.err`.
 *     *   Implement a class-wide exception handling mechanism using `try-catch` blocks within the main operational loop or critical methods to catch potential runtime errors and prevent the program from crashing unexpectedly.
 *     *   Handle the specific case of attempting to process a task when the queue is empty, outputting an error message to `System.err`.
 * 
 * 6.  **Object-Oriented Design:**
 *     *   Create a `Task` class with private fields for `taskId` (integer), `description` (String), and `priority` (String). Provide public getter methods and a meaningful `toString()` method.
 *     *   Create a `TaskManagementSystem` class that encapsulates the `Queue` and `List`, and contains methods for adding, processing, viewing tasks, and the main interaction loop. Use private fields and public methods appropriately.
 * 
 * 7.  **Best Practices:**
 *     *   Use meaningful names for variables, methods, and classes.
 *     *   Include comments where necessary to explain complex logic.
 *     *   Ensure proper encapsulation (private fields, public getters/methods).
 * 
 * **Expected Output:**
 * 
 * The program should run interactively. Example interactions:
 * 
 * ```
 * --- Task Management System ---
 * 1. Add New Task
 * 2. Process Next Task
 * 3. View Pending Tasks
 * 4. View Processed Tasks
 * 5. Exit
 * Enter your choice: 1
 * Enter task description: Develop feature X
 * Enter task priority (HIGH, MEDIUM, LOW): HIGH
 * Task added with ID: 1
 * 
 * --- Task Management System ---
 * ...
 * Enter your choice: 1
 * Enter task description: Write documentation
 * Enter task priority (HIGH, MEDIUM, LOW): low
 * Task added with ID: 2
 * 
 * --- Task Management System ---
 * ...
 * Enter your choice: 3
 * Pending Tasks:
 * Task ID: 1, Description: Develop feature X, Priority: HIGH
 * Task ID: 2, Description: Write documentation, Priority: LOW
 * 
 * --- Task Management System ---
 * ...
 * Enter your choice: 2
 * Processing task: Task ID: 1, Description: Develop feature X, Priority: HIGH
 * Task processed.
 * 
 * --- Task Management System ---
 * ...
 * Enter your choice: 3
 * Pending Tasks:
 * Task ID: 2, Description: Write documentation, Priority: LOW
 * 
 * --- Task Management System ---
 * ...
 * Enter your choice: 4
 * Processed Tasks History:
 * Task ID: 1, Description: Develop feature X, Priority: HIGH
 * 
 * --- Task Management System ---
 * ...
 * Enter your choice: 2
 * Processing task: Task ID: 2, Description: Write documentation, Priority: LOW
 * Task processed.
 * 
 * --- Task Management System ---
 * ...
 * Enter your choice: 2
 * Error: No tasks in the queue to process.
 * 
 * --- Task Management System ---
 * ...
 * Enter your choice: 6
 * Error: Invalid choice. Please enter a number between 1 and 5.
 * 
 * --- Task Management System ---
 * ...
 * Enter your choice: 1
 * Enter task description: Refactor code
 * Enter task priority (HIGH, MEDIUM, LOW): URGENT
 * Error: Invalid priority. Please enter HIGH, MEDIUM, or LOW.
 * Task not added.
 * 
 * --- Task Management System ---
 * ...
 * Enter your choice: 5
 * Exiting system.
 * ```
 * 
 * Your code should compile and run, fulfilling all the requirements listed above.
 * 
 * **Note:** For simplicity, the priority level does *not* affect the processing order, which is strictly FIFO based on arrival time in the queue.
 *
 * EXPLANATION:
 * The provided solution implements a `TaskManagementSystem` that simulates a simple resource allocation and task processing flow, fulfilling all the requirements of the exam question.
 * 
 * 1.  **Object-Oriented Structure:**
 *     *   A `Task` class encapsulates the data for a single task (`taskId`, `description`, `priority`) with appropriate private fields and public getters. The `toString()` method provides a convenient way to print task details.
 *     *   The `TaskManagementSystem` class manages the core logic and data structures (`taskQueue`, `processedTasks`). It uses private fields for encapsulation and public methods (`addTask`, `processNextTask`, `displayPendingTasks`, `displayProcessedTasks`, `run`) to expose functionality.
 * 
 * 2.  **Data Structures:**
 *     *   `java.util.Queue<Task> taskQueue`: This is declared using the `Queue` interface and implemented with `java.util.LinkedList`. It correctly stores tasks waiting for processing in a FIFO manner. The `offer()` method is used for adding tasks, and `poll()` is used for retrieving and removing the head of the queue during processing.
 *     *   `java.util.List<Task> processedTasks`: This is declared using the `List` interface and implemented with `java.util.ArrayList`. It serves as a history log, storing tasks after they have been processed. The `add()` method is used to append processed tasks to this list.
 * 
 * 3.  **User Interaction and Control Flow:**
 *     *   `java.util.Scanner scanner`: An instance of `Scanner` reads input from `System.in`. It's used to get the user's menu choice, task description, and priority.
 *     *   `while (choice != 5)` loop: This loop keeps the system running until the user chooses the "Exit" option (choice 5).
 *     *   `switch (choice)` statement: This is used within the loop to direct the program's flow based on the user's integer input, calling the appropriate methods for each menu option.
 *     *   Input validation for the menu choice is handled by checking `scanner.hasNextInt()` before reading, and consuming invalid input to prevent infinite loops.
 * 
 * 4.  **Output:**
 *     *   `System.out.println()`: Used for displaying the menu, prompts for input, task details, and success messages, as required.
 *     *   `System.err.println()`: Used specifically for error messages, such as invalid menu choices, invalid task priority input, and attempting to process from an empty queue.
 * 
 * 5.  **Error Handling:**
 *     *   **Input Validation:** The `addTask` method checks if the provided `priority` string matches "HIGH", "MEDIUM", or "LOW" (case-insensitive) using `toUpperCase()` and string comparison. If the priority is invalid, it prints an error message to `System.err` and returns `false`, preventing the invalid task from being added.
 *     *   **Empty Queue Handling:** The `processNextTask` method explicitly checks if `taskQueue.isEmpty()`. If true, it prints an error message to `System.err` and returns without attempting to `poll()`, which would otherwise result in a `NullPointerException` or similar error depending on the queue implementation if not handled.
 *     *   **Class-wide Exception Handling:** The main `run()` method is wrapped in a `try-catch(Exception e)` block. This block catches any unexpected runtime exceptions that might occur within the main operational loop (e.g., issues with `Scanner` or other unforeseen problems), prints a generic error message to `System.err` along with the exception details, and then allows the program to terminate gracefully (or potentially continue, depending on the specific exception and desired behavior, though printing and exiting is common in simple console apps). A `finally` block ensures the `Scanner` is closed.
 * 
 * 6.  **Best Practices:**
 *     *   Meaningful names (`taskQueue`, `processNextTask`, `displayPendingTasks`, etc.) are used throughout the code.
 *     *   Comments explain the purpose of classes, methods, and key logic sections.
 *     *   Fields are `private`, and access is provided through `public` methods (getters).
 *     *   Input validation and specific error handling for known issues (empty queue, invalid priority) are implemented.
 *     *   The code is structured logically into classes and methods, enhancing readability and maintainability.
 * 
 * This solution effectively demonstrates the required Java components and programming concepts within a practical scenario, providing a robust foundation for a task management system.
 */

import java.util.Queue;
import java.util.LinkedList; // Common implementation for Queue
import java.util.List;
import java.util.ArrayList;
import java.util.Scanner;
import java.util.Locale; // For case-insensitive priority check

// Represents a single task in the system
class Task {
    private int taskId;
    private String description;
    private String priority; // Stored as String, but validated

    // Constructor
    public Task(int taskId, String description, String priority) {
        this.taskId = taskId;
        this.description = description;
        this.priority = priority;
    }

    // Getters
    public int getTaskId() {
        return taskId;
    }

    public String getDescription() {
        return description;
    }

    public String getPriority() {
        return priority;
    }

    // String representation of the Task
    @Override
    public String toString() {
        return "Task ID: " + taskId + ", Description: " + description + ", Priority: " + priority;
    }
}

// Manages the task queue and processed task history
public class TaskManagementSystem {

    private Queue<Task> taskQueue;
    private List<Task> processedTasks; // Using List interface, implemented by ArrayList
    private int nextTaskId;
    private Scanner scanner;

    // Constructor
    public TaskManagementSystem() {
        this.taskQueue = new LinkedList<>(); // LinkedList is a common Queue implementation
        this.processedTasks = new ArrayList<>(); // ArrayList for processed task history
        this.nextTaskId = 1; // Start task IDs from 1
        this.scanner = new Scanner(System.in);
    }

    /**
     * Adds a new task to the queue after validating priority.
     * @param description The task description.
     * @param priority The task priority (HIGH, MEDIUM, LOW).
     * @return true if task was added, false otherwise (due to invalid priority).
     */
    public boolean addTask(String description, String priority) {
        // Validate priority input (case-insensitive)
        String upperPriority = priority.toUpperCase(Locale.US);
        if (!upperPriority.equals("HIGH") && !upperPriority.equals("MEDIUM") && !upperPriority.equals("LOW")) {
            System.err.println("Error: Invalid priority. Please enter HIGH, MEDIUM, or LOW.");
            return false; // Indicate failure
        }

        Task newTask = new Task(nextTaskId++, description, upperPriority);
        taskQueue.offer(newTask); // offer is generally preferred over add for queues as it doesn't throw exception
        System.out.println("Task added with ID: " + newTask.getTaskId());
        return true; // Indicate success
    }

    /**
     * Processes the next task from the queue (FIFO).
     */
    public void processNextTask() {
        if (taskQueue.isEmpty()) {
            System.err.println("Error: No tasks in the queue to process.");
            return;
        }

        Task taskToProcess = taskQueue.poll(); // poll removes and returns the head of the queue
        System.out.println("Processing task: " + taskToProcess);
        processedTasks.add(taskToProcess); // Add to history list
        System.out.println("Task processed.");
    }

    /**
     * Displays all tasks currently in the pending queue.
     */
    public void displayPendingTasks() {
        System.out.println("\nPending Tasks:");
        if (taskQueue.isEmpty()) {
            System.out.println("No tasks pending.");
        } else {
            // Iterate without removing elements
            for (Task task : taskQueue) {
                System.out.println(task);
            }
        }
    }

    /**
     * Displays all tasks that have been processed.
     */
    public void displayProcessedTasks() {
        System.out.println("\nProcessed Tasks History:");
        if (processedTasks.isEmpty()) {
            System.out.println("No tasks processed yet.");
        } else {
            for (Task task : processedTasks) {
                System.out.println(task);
            }
        }
    }

    /**
     * Runs the main interactive loop for the system.
     * Includes class-wide exception handling.
     */
    public void run() {
        int choice = -1;

        // Class-wide try-catch block for the main operational loop
        try {
            while (choice != 5) {
                printMenu();
                System.out.print("Enter your choice: ");

                // Use hasNextInt() to check if the next input is an integer
                if (!scanner.hasNextInt()) {
                    System.err.println("Error: Invalid input. Please enter a number.");
                    scanner.next(); // Consume the invalid input
                    continue; // Skip to the next iteration
                }

                choice = scanner.nextInt();
                scanner.nextLine(); // Consume the newline character left by nextInt()

                // Switch statement for menu navigation
                switch (choice) {
                    case 1: // Add New Task
                        System.out.print("Enter task description: ");
                        String description = scanner.nextLine();
                        System.out.print("Enter task priority (HIGH, MEDIUM, LOW): ");
                        String priority = scanner.nextLine();
                        addTask(description, priority); // addTask handles its own validation/error message
                        break;
                    case 2: // Process Next Task
                        processNextTask(); // processNextTask handles empty queue error
                        break;
                    case 3: // View Pending Tasks
                        displayPendingTasks();
                        break;
                    case 4: // View Processed Tasks
                        displayProcessedTasks();
                        break;
                    case 5: // Exit
                        System.out.println("Exiting system.");
                        break;
                    default: // Invalid choice
                        System.err.println("Error: Invalid choice. Please enter a number between 1 and 5.");
                        break;
                }
                System.out.println(); // Add a newline for better readability between operations
            }
        } catch (Exception e) {
            // Catch any unexpected runtime exceptions
            System.err.println("An unexpected error occurred: " + e.getMessage());
            e.printStackTrace(); // Print stack trace for debugging
        } finally {
            // Ensure scanner is closed
            scanner.close();
        }
    }

    /**
     * Prints the main menu options to the console.
     */
    private void printMenu() {
        System.out.println("--- Task Management System ---");
        System.out.println("1. Add New Task");
        System.out.println("2. Process Next Task");
        System.out.println("3. View Pending Tasks");
        System.out.println("4. View Processed Tasks");
        System.out.println("5. Exit");
    }

    // Main method to start the application
    public static void main(String[] args) {
        TaskManagementSystem system = new TaskManagementSystem();
        system.run();
    }
}
