/*
 * Exam Question #1101
 * Generated on: 2025-05-12 17:25:01
 * Generated by: Account 5
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Service Desk Ticket Management System
 * 
 * **Scenario:**
 * 
 * You are tasked with developing a simple command-line application to simulate a Service Desk system for managing support tickets. The system should allow users to add new tickets, process tickets from a waiting queue, resolve tickets by their ID, and view lists of tickets.
 * 
 * **Requirements:**
 * 
 * Implement a Java application that meets the following specifications:
 * 
 * 1.  **Ticket Representation:** Create a `Ticket` class with the following properties:
 *     *   A unique integer `id` (automatically generated, starting from 1).
 *     *   A `String` `description` of the issue.
 *     *   A `TicketStatus` enum (WAITING, IN_PROGRESS, RESOLVED) representing the ticket's current state.
 *     *   Implement appropriate getters and setters, and a `toString()` method for easy display.
 * 
 * 2.  **Ticket Management Logic:** Create a `TicketManager` class responsible for managing the collection of tickets. This class must use:
 *     *   A `java.util.Queue<Ticket>` to hold tickets that are in the `WAITING` state, representing the queue of tickets waiting to be picked up.
 *     *   A `java.util.List<Ticket>` (specifically, a `java.util.ArrayList<Ticket>`) to store *all* tickets created in the system, regardless of their status. This list allows for easy iteration and searching of all tickets.
 * 
 * 3.  **`TicketManager` Methods:** Implement the following methods in the `TicketManager` class:
 *     *   `addTicket(String description)`: Creates a new `Ticket` with status `WAITING`, adds it to both the `ArrayList` and the `Queue`. Prints a success message using `System.out`. Include basic validation (e.g., non-empty description) and report errors using `System.err`.
 *     *   `processNextTicket()`: Retrieves the next ticket from the `Queue`. If a ticket is available, change its status to `IN_PROGRESS` (update the object reference which is also in the `ArrayList`). Prints details of the processed ticket using `System.out`. If the queue is empty, print an error message using `System.err`.
 *     *   `resolveTicket(int ticketId)`: Finds the ticket with the given ID in the `ArrayList`. If found and not already `RESOLVED`, change its status to `RESOLVED`. If the ticket was in the `WAITING` state when resolved, remove it from the `Queue`. Prints a success message using `System.out`. If the ticket is not found, already resolved, or the ID is invalid, print an error message using `System.err` and return `false`.
 *     *   `listAllTickets()`: Iterates through the `ArrayList` and prints the details of every ticket using `System.out`. If the list is empty, print a message using `System.out`.
 *     *   `listWaitingTickets()`: Iterates through the `Queue` (without removing elements) and prints the details of tickets currently in the waiting queue using `System.out`. If the queue is empty, print a message using `System.out`.
 * 
 * 4.  **User Interface:** Create a main application class (e.g., `ServiceDeskApp`) with a `main` method.
 *     *   Use `java.util.Scanner` to read user input from the console.
 *     *   Implement a menu-driven interface with options corresponding to the `TicketManager` methods (Add, Process, Resolve, List All, List Waiting, Exit).
 *     *   Use a `switch` statement to handle the user's menu choice.
 *     *   Use `System.out` for displaying the menu, prompts, and normal operation messages.
 *     *   Use `System.err` for displaying all error conditions (invalid menu choice, invalid input format, errors reported by `TicketManager` methods).
 * 
 * 5.  **Error Handling:**
 *     *   Implement robust input validation for menu choices and ticket ID input using `try-catch` blocks around `Scanner` operations that might throw `InputMismatchException`. Prompt the user again until valid input is received, reporting errors via `System.err`.
 *     *   Implement **class-wide exception handling** by wrapping the main execution logic within the `main` method in a single `try-catch(Exception e)` block to catch any unexpected runtime errors. Report such errors using `System.err`.
 * 
 * 6.  **Best Practices:**
 *     *   Adhere to proper encapsulation (private fields, public methods).
 *     *   Use meaningful variable, method, and class names.
 *     *   Include comments explaining the purpose of classes, methods, and complex logic sections.
 *     *   Ensure resources like `Scanner` are properly closed.
 * 
 * **Expected Output:**
 * 
 * Your program should interact with the user via the console, displaying a menu, prompting for input, and printing output based on the chosen action. Error conditions (e.g., invalid input, processing an empty queue, resolving a non-existent ticket) must be clearly reported using `System.err`. Successful operations and informational messages should use `System.out`.
 * 
 * Example Interaction Flow (Illustrative):
 * 
 * ```
 * --- Service Desk Ticket Management System ---
 * Select an option:
 * 1. Add New Ticket
 * 2. Process Next Waiting Ticket
 * 3. Resolve Ticket by ID
 * 4. List All Tickets
 * 5. List Waiting Tickets
 * 6. Exit
 * Enter your choice: 1
 * Enter ticket description: Internet connection is down
 * Ticket added: Ticket [ID=1, Status=WAITING, Description='Internet connection is down']
 * 
 * Select an option:
 * ...menu...
 * Enter your choice: 1
 * Enter ticket description: Cannot access shared drive
 * Ticket added: Ticket [ID=2, Status=WAITING, Description='Cannot access shared drive']
 * 
 * Select an option:
 * ...menu...
 * Enter your choice: 5
 * --- Waiting Tickets ---
 * Ticket [ID=1, Status=WAITING, Description='Internet connection is down']
 * Ticket [ID=2, Status=WAITING, Description='Cannot access shared drive']
 * ---------------------
 * 
 * Select an option:
 * ...menu...
 * Enter your choice: 2
 * Processing ticket: Ticket [ID=1, Status=IN_PROGRESS, Description='Internet connection is down']
 * 
 * Select an option:
 * ...menu...
 * Enter your choice: 5
 * --- Waiting Tickets ---
 * Ticket [ID=2, Status=WAITING, Description='Cannot access shared drive']
 * ---------------------
 * 
 * Select an option:
 * ...menu...
 * Enter your choice: 3
 * Enter ID of ticket to resolve: 2
 * Ticket 2 marked as RESOLVED.
 * 
 * Select an option:
 * ...menu...
 * Enter your choice: 5
 * No tickets in the waiting queue.
 * 
 * Select an option:
 * ...menu...
 * Enter your choice: 4
 * --- All Tickets ---
 * Ticket [ID=1, Status=IN_PROGRESS, Description='Internet connection is down']
 * Ticket [ID=2, Status=RESOLVED, Description='Cannot access shared drive']
 * -------------------
 * 
 * Select an option:
 * ...menu...
 * Enter your choice: 2
 * Error: No tickets in the waiting queue to process. (Using System.err)
 * 
 * Select an option:
 * ...menu...
 * Enter your choice: invalid_input
 * Error: Invalid input. Please enter a whole number. (Using System.err)
 * Enter your choice: 7
 * Error: Invalid choice. Please enter a number between 1 and 6. (Using System.err)
 * 
 * Select an option:
 * ...menu...
 * Enter your choice: 6
 * Exiting system. Goodbye!
 * Scanner closed.
 * ```
 * 
 * **Note:** For simplicity in an exam setting, you may place all classes within a single `.java` file without using package declarations.
 *
 * EXPLANATION:
 * The provided solution implements a simple Service Desk Ticket Management System demonstrating the required Java concepts and best practices.
 * 
 * 1.  **Class Structure:** The solution is organized into three classes:
 *     *   `Ticket`: A simple Plain Old Java Object (POJO) representing a ticket with an auto-generated ID, description, and status (`WAITING`, `IN_PROGRESS`, `RESOLVED` enum). It follows encapsulation principles with private fields and public getters/setters.
 *     *   `TicketManager`: This class encapsulates the core logic for managing tickets. It holds the two primary data structures required: a `Queue` for waiting tickets and a `List` (implemented by `ArrayList`) for all tickets. Its methods perform the operations requested in the problem (add, process, resolve, list).
 *     *   `ServiceDeskApp`: This is the main class containing the `main` method. It handles the user interface, menu display, input reading using `Scanner`, and directs calls to the `TicketManager` based on user choices via a `switch` statement.
 * 
 * 2.  **Required Component Usage:**
 *     *   `java.util.Queue`: The `waitingQueue` in `TicketManager` is declared as a `Queue<Ticket>` and instantiated as a `LinkedList`. This is used to manage tickets in a FIFO (First-In, First-Out) manner for the `processNextTicket` operation (`poll()`). When a ticket is resolved while waiting, it's explicitly removed from the queue using `remove()`.
 *     *   `java.util.ArrayList`: The `allTickets` list in `TicketManager` is instantiated as an `ArrayList<Ticket>`. It stores all tickets created, allowing easy iteration (`listAllTickets()`) and searching by ID (`resolveTicket()`).
 *     *   `java.util.List`: The `allTickets` member variable is declared using the `List` interface (`List<Ticket> allTickets;`), demonstrating programming to the interface rather than the concrete implementation where appropriate.
 *     *   `java.util.Scanner`: An instance of `Scanner` is used in the `main` method of `ServiceDeskApp` to read user input from `System.in` for menu choices and ticket details.
 *     *   `switch` statement: A `switch` statement in the `main` method is used to control the program flow based on the user's integer input for the menu selection.
 *     *   `System.err`: Used consistently throughout the code to report error conditions, such as invalid input, empty queues, ticket not found, or unexpected system errors.
 *     *   `System.out`: Used for all normal output, including displaying the menu, prompts for input, success messages (e.g., ticket added, ticket processed), and listing ticket details.
 *     *   Class-wide `try-catch`: The entire content of the `main` method is wrapped in a `try-catch(Exception e)` block. This provides a top-level handler for any unhandled exceptions that might occur during the program's execution, printing a general error message to `System.err`.
 * 
 * 3.  **Error Handling Strategy:**
 *     *   **Input Validation:** A dedicated helper method `readIntInput` is used to handle reading integer inputs (menu choice, ticket ID). This method contains a `try-catch(InputMismatchException)` block within a loop. If the user enters non-integer input, an error is printed to `System.err`, the invalid input is consumed from the scanner, and the loop repeats, prompting the user again. This provides robust input handling without crashing the program. The `scanner.nextLine()` call after reading an integer is crucial to consume the leftover newline character, preventing issues with subsequent `scanner.nextLine()` calls for reading strings.
 *     *   **Method-Specific Errors:** Methods in `TicketManager` (like `addTicket`, `processNextTicket`, `resolveTicket`) contain checks for invalid states or inputs (e.g., empty description, empty queue, ticket not found). These methods use `System.err` to report these specific errors as required.
 *     *   **Class-wide Catch-all:** The `try-catch(Exception e)` in `main` acts as a safety net for any other unexpected runtime exceptions that might occur and are not handled by the more specific input validation.
 * 
 * 4.  **Best Practices:**
 *     *   **Encapsulation:** Fields in `Ticket` and `TicketManager` are `private`, and access is controlled via public methods.
 *     *   **Meaningful Names:** Classes, variables, methods, and enum values have descriptive names reflecting their purpose (e.g., `waitingQueue`, `processNextTicket`, `TicketStatus.RESOLVED`).
 *     *   **Comments:** Javadoc-style comments explain the purpose of classes and methods, and inline comments clarify specific logic points (like consuming the newline after `nextInt()`).
 *     *   **Resource Management:** The `Scanner` object is closed in a `finally` block to ensure the underlying system resource is released, even if exceptions occur.
 *     *   **Clean Code Structure:** The code is separated into logical units (classes), and the `main` method focuses on the application flow and user interaction, delegating business logic to the `TicketManager`. Helper methods (`printMenu`, `readIntInput`) improve readability and reduce code duplication.
 * 
 * The combination of managing data in two different but related collections (`Queue` and `List`), implementing a menu-driven interface with robust input handling, differentiating output streams (`System.out` vs. `System.err`), and applying layered exception handling makes this a challenging task suitable for assessing advanced Java understanding within a reasonable exam timeframe.
 */

import java.util.ArrayList;
import java.util.InputMismatchException;
import java.util.LinkedList; // Common implementation of Queue
import java.util.List;
import java.util.Queue;
import java.util.Scanner;

// Represents a single support ticket
class Ticket {
    private static int nextId = 1; // Static counter for unique IDs
    private int id;
    private String description;
    private TicketStatus status;

    // Enum to represent the possible states of a ticket
    public enum TicketStatus {
        WAITING, IN_PROGRESS, RESOLVED
    }

    /**
     * Constructs a new Ticket.
     * @param description The description of the ticket issue.
     */
    public Ticket(String description) {
        this.id = nextId++; // Assign unique ID and increment counter
        this.description = description;
        this.status = TicketStatus.WAITING; // New tickets start as WAITING
    }

    // --- Getters ---
    public int getId() {
        return id;
    }

    public String getDescription() {
        return description;
    }

    public TicketStatus getStatus() {
        return status;
    }

    // --- Setter for Status ---
    public void setStatus(TicketStatus status) {
        this.status = status;
    }

    /**
     * Provides a string representation of the Ticket.
     * @return Formatted string displaying ticket details.
     */
    @Override
    public String toString() {
        return "Ticket [ID=" + id + ", Status=" + status + ", Description='" + description + "']";
    }
}

// Manages the collection and workflow of tickets
class TicketManager {
    // Queue for tickets waiting to be processed (WAITING status)
    private Queue<Ticket> waitingQueue;
    // List to hold all tickets in the system (any status)
    private List<Ticket> allTickets; // Using List interface type, implemented by ArrayList

    /**
     * Constructs a new TicketManager.
     * Initializes the waiting queue and the list of all tickets.
     */
    public TicketManager() {
        // LinkedList is a common implementation of the Queue interface
        waitingQueue = new LinkedList<>();
        // ArrayList is a common implementation of the List interface
        allTickets = new ArrayList<>();
    }

    /**
     * Adds a new ticket to the system.
     * The ticket is added to both the list of all tickets and the waiting queue.
     * @param description The description of the ticket.
     */
    public void addTicket(String description) {
        // Input validation for description
        if (description == null || description.trim().isEmpty()) {
            System.err.println("Error: Ticket description cannot be empty.");
            return; // Exit method if validation fails
        }

        Ticket newTicket = new Ticket(description);
        // Add to the queue of waiting tickets
        waitingQueue.offer(newTicket); // offer is safer than add, returns false if failed (unlikely with LinkedList)
        // Add to the list of all tickets
        allTickets.add(newTicket);

        // Report success using System.out
        System.out.println("Ticket added: " + newTicket.toString());
    }

    /**
     * Processes the next ticket from the waiting queue.
     * Moves the ticket's status to IN_PROGRESS.
     * Reports success or error using System.out/System.err.
     * @return The ticket that was processed, or null if the queue was empty.
     */
    public Ticket processNextTicket() {
        // Retrieve and remove the head of the queue
        Ticket ticketToProcess = waitingQueue.poll(); // poll returns null if queue is empty

        if (ticketToProcess != null) {
            // Update the status of the ticket.
            // Since the Ticket object in allTickets is the same reference,
            // updating the polled object updates it in the allTickets list too.
            ticketToProcess.setStatus(Ticket.TicketStatus.IN_PROGRESS);

            // Report success using System.out
            System.out.println("Processing ticket: " + ticketToProcess.toString());
            return ticketToProcess;
        } else {
            // Report error using System.err
            System.err.println("Error: No tickets in the waiting queue to process.");
            return null;
        }
    }

    /**
     * Resolves a ticket by its ID.
     * Finds the ticket in the list of all tickets and sets its status to RESOLVED.
     * If the ticket was WAITING, it is also removed from the waiting queue.
     * Reports success or error using System.out/System.err.
     * @param ticketId The ID of the ticket to resolve.
     * @return true if the ticket was found and resolved, false otherwise.
     */
    public boolean resolveTicket(int ticketId) {
         // Basic validation for ticket ID
         if (ticketId <= 0) {
             System.err.println("Error: Invalid ticket ID. Must be positive.");
             return false;
         }

        Ticket ticketToResolve = null;
        // Search for the ticket in the list of all tickets
        for (Ticket ticket : allTickets) {
            if (ticket.getId() == ticketId) {
                ticketToResolve = ticket;
                break; // Found the ticket
            }
        }

        // Check if ticket was found
        if (ticketToResolve == null) {
            System.err.println("Error: Ticket with ID " + ticketId + " not found.");
            return false; // Report error using System.err
        }

        // Check if ticket is already resolved
        if (ticketToResolve.getStatus() == Ticket.TicketStatus.RESOLVED) {
            System.err.println("Error: Ticket " + ticketId + " is already resolved.");
            return false; // Report error using System.err
        }

        // If the ticket was in the waiting queue, remove it
        if (ticketToResolve.getStatus() == Ticket.TicketStatus.WAITING) {
             // LinkedList's remove(Object o) method works here because we have the object reference
             waitingQueue.remove(ticketToResolve);
        }

        // Set the status to RESOLVED
        ticketToResolve.setStatus(Ticket.TicketStatus.RESOLVED);

        // Report success using System.out
        System.out.println("Ticket " + ticketId + " marked as RESOLVED.");
        return true;
    }

    /**
     * Lists all tickets currently in the system, regardless of status.
     * Iterates through the list of all tickets.
     * Reports output using System.out.
     */
    public void listAllTickets() {
        if (allTickets.isEmpty()) {
            System.out.println("No tickets in the system.");
            return;
        }

        System.out.println("\n--- All Tickets ---");
        // Iterate through the List using enhanced for loop
        for (Ticket ticket : allTickets) {
            System.out.println(ticket.toString());
        }
        System.out.println("-------------------\n");
    }

    /**
     * Lists all tickets currently in the waiting queue (WAITING status).
     * Iterates through the queue without removing elements.
     * Reports output using System.out.
     */
    public void listWaitingTickets() {
         if (waitingQueue.isEmpty()) {
            System.out.println("No tickets in the waiting queue.");
            return;
        }

        System.out.println("\n--- Waiting Tickets ---");
        // Iterate through the Queue. The iterator does not remove elements.
        for (Ticket ticket : waitingQueue) {
             System.out.println(ticket.toString());
        }
        System.out.println("---------------------\n");
    }
}

// Main application class with the user interface and entry point
public class ServiceDeskApp {

    // Helper method to print the main menu options
    private static void printMenu() {
        System.out.println("\nSelect an option:");
        System.out.println("1. Add New Ticket");
        System.out.println("2. Process Next Waiting Ticket");
        System.out.println("3. Resolve Ticket by ID");
        System.out.println("4. List All Tickets");
        System.out.println("5. List Waiting Tickets");
        System.out.println("6. Exit");
    }

    /**
     * Helper method to safely read an integer input from the scanner.
     * Handles InputMismatchException and prompts the user again until valid input is received.
     * Consumes the leftover newline character after reading the integer.
     * Reports input errors using System.err.
     * @param scanner The Scanner object to use for reading input.
     * @param prompt The message displayed to the user before reading input.
     * @return The valid integer input provided by the user.
     */
    private static int readIntInput(Scanner scanner, String prompt) {
        int value = -1;
        boolean validInput = false;
        while (!validInput) {
            System.out.print(prompt); // Display the prompt using System.out
            try {
                value = scanner.nextInt();
                validInput = true; // Input was successfully read as an integer
            } catch (InputMismatchException e) {
                System.err.println("Invalid input. Please enter a whole number."); // Report error using System.err
                scanner.next(); // Consume the invalid input to prevent infinite loop
            }
        }
        // Consume the rest of the line, including the newline character,
        // left by nextInt(). This is crucial before the next nextLine() call.
        scanner.nextLine();
        return value;
    }

    /**
     * The main entry point of the application.
     * Sets up the system, runs the main menu loop, and handles top-level exceptions.
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        Scanner scanner = null; // Declare scanner outside try block for finally access

        // --- Class-wide exception handling ---
        // Wrap the entire main logic in a try-catch block to catch unexpected errors
        try {
            scanner = new Scanner(System.in);
            TicketManager manager = new TicketManager();
            boolean running = true; // Flag to control the main loop

            System.out.println("--- Service Desk Ticket Management System ---");

            // Main application loop
            while (running) {
                printMenu(); // Display the menu
                // Read user choice using the safe helper method
                int choice = readIntInput(scanner, "Enter your choice: ");

                // Use a switch statement for menu navigation
                switch (choice) {
                    case 1: // Add New Ticket
                        System.out.print("Enter ticket description: "); // Prompt using System.out
                        String description = scanner.nextLine(); // Read the full description line
                        manager.addTicket(description); // Call manager method
                        break;
                    case 2: // Process Next Waiting Ticket
                        manager.processNextTicket(); // Call manager method, which handles its own output/errors
                        break;
                    case 3: // Resolve Ticket by ID
                        // Read ticket ID using the safe helper method
                        int ticketIdToResolve = readIntInput(scanner, "Enter ID of ticket to resolve: ");
                        manager.resolveTicket(ticketIdToResolve); // Call manager method, which handles its own output/errors
                        break;
                    case 4: // List All Tickets
                        manager.listAllTickets(); // Call manager method
                        break;
                    case 5: // List Waiting Tickets
                         manager.listWaitingTickets(); // Call manager method
                         break;
                    case 6: // Exit
                        System.out.println("Exiting system. Goodbye!"); // System.out for normal exit message
                        running = false; // Set flag to exit loop
                        break;
                    default: // Handle invalid menu choices
                        System.err.println("Invalid choice. Please enter a number between 1 and 6."); // Report error using System.err
                }
            }

        } catch (Exception e) {
            // This block catches any unhandled exceptions that occur within the try block.
            // Reports the error using System.err as required for class-wide handling.
            System.err.println("\nAn unexpected system error occurred!");
            System.err.println("Error details: " + e.getMessage());
            // Optionally print stack trace for debugging purposes
            // e.printStackTrace(System.err);
        } finally {
            // Ensure the scanner resource is closed properly
            if (scanner != null) {
                scanner.close();
                 System.out.println("Scanner resource closed."); // Confirmation using System.out
            }
        }
    }
}
