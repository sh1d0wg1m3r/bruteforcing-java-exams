/*
 * Exam Question #94
 * Generated on: 2025-05-11 22:13:09
 * Generated by: Account 1
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Advanced Task Management System
 * 
 * **Objective:** Design and implement a console-based Task Management System that allows users to add tasks, manage a list of all tasks, queue specific tasks for processing, view the processing queue, and process tasks from the queue. This task requires demonstrating proficiency in using core Java collections, input handling, control flow, and exception handling.
 * 
 * **Scenario:** You are developing a simple backend system for managing tasks. Tasks are created with a description and a priority level. Initially, all tasks are stored in a central repository. Users can then select tasks from this repository and add them to a processing queue. Tasks are processed in a First-In, First-Out (FIFO) manner from the processing queue.
 * 
 * **Requirements:**
 * 
 * 1.  **Task Representation:** Create a `Task` class with private fields for `description` (String) and `priority` (String - must be "High", "Medium", or "Low"). Include a constructor, public getter methods, and a `toString()` method for easy printing.
 * 2.  **Task Management Logic:** Create a `TaskManager` class responsible for managing the collections and operations.
 *     *   It must internally use a `java.util.List` (instantiated as `java.util.ArrayList`) to store *all* tasks created.
 *     *   It must internally use a `java.util.Queue` (e.g., `java.util.LinkedList` which implements `Queue`) to store tasks waiting for processing.
 *     *   Provide methods in `TaskManager` for:
 *         *   `addTask(String description, String priority)`: Adds a new task to the list of all tasks. Must validate the priority string. Returns a boolean indicating success/failure.
 *         *   `getAllTasks()`: Returns the list of all tasks.
 *         *   `addTaskToQueue(int taskIndex)`: Takes a 0-based index from the `allTasks` list, retrieves the corresponding task, and adds it to the processing queue. Must validate the index. Returns a boolean indicating success/failure.
 *         *   `getProcessingQueue()`: Returns the processing queue.
 *         *   `processNextTask()`: Removes and returns the task at the front of the processing queue. Should handle the case where the queue is empty.
 * 3.  **User Interface:** Implement a console-based menu in a main class (e.g., `TaskApp`) using `java.util.Scanner` for user input. The menu should include options for:
 *     *   Add New Task
 *     *   View All Tasks
 *     *   Add Task to Processing Queue (requires user to enter the index from the "View All Tasks" list)
 *     *   View Processing Queue
 *     *   Process Next Task
 *     *   Exit
 * 4.  **Control Flow:** Use a `switch` statement in the main application loop to handle menu selections.
 * 5.  **Input Validation & Error Handling:**
 *     *   Validate user input for menu choices (ensure it's a number within range).
 *     *   Validate task priority input ("High", "Medium", "Low", case-insensitive). Report errors using `System.err`.
 *     *   Validate the task index provided when adding to the queue (must be a valid index in the `allTasks` list). Report errors using `System.err`.
 *     *   Handle the case where the processing queue is empty when attempting to process a task. Report this status using `System.out`.
 *     *   Implement **class-wide exception handling** in the main application class using a `try-catch` block that wraps the main application loop to catch any unexpected runtime errors and print an error message to `System.err`. Also, handle `NumberFormatException` when parsing integer input from the user.
 * 6.  **Output:** Use `System.out` for displaying the menu, prompts, task lists, queue contents, and success messages.
 * 7.  **Best Practices:** Apply principles of encapsulation (private fields, public methods), use meaningful variable and method names, add appropriate comments and basic documentation (e.g., method descriptions), and ensure clean code structure.
 * 8.  **Required Components Checklist:** Your solution **must** explicitly use and demonstrate the functionality of all the following:
 *     *   `java.util.Queue`
 *     *   `java.util.ArrayList`
 *     *   `java.util.List` interface
 *     *   `java.util.Scanner`
 *     *   `switch` statement
 *     *   `System.err`
 *     *   `System.out`
 *     *   `try-catch` blocks (including class-wide handling)
 * 
 * **Expected Output/Behavior:**
 * 
 * *   The application should present a menu upon startup and after each operation (except Exit).
 * *   Adding a task should prompt for description and priority, validate priority, and confirm addition or report error.
 * *   Viewing all tasks should list them with their 0-based index. If empty, print "No tasks available."
 * *   Adding to queue should prompt for an index, validate it, and confirm addition or report invalid index using `System.err`.
 * *   Viewing the queue should list tasks in the queue (front first). If empty, print "Processing queue is empty."
 * *   Processing a task should remove the task from the front of the queue and print its details, or report "Processing queue is empty."
 * *   Invalid menu input (non-numeric or out of range) should be handled with an error message to `System.err`.
 * *   Any unexpected runtime error should be caught by the main `try-catch` block, printing an error message to `System.err`.
 * *   Selecting Exit should terminate the application gracefully.
 * 
 * **Constraint:** Focus on correctness and adherence to all requirements within a reasonable time frame (simulate ~45-60 minutes).
 *
 * EXPLANATION:
 * This solution implements a simple console-based task management system as described in the exam question.
 * 
 * **Class Structure:**
 * *   `Task`: A simple Plain Old Java Object (POJO) representing a task with a description and priority. It enforces that the description is not empty via an `IllegalArgumentException` in the constructor. It includes public getters and a `toString()` method.
 * *   `TaskManager`: This class encapsulates the core logic and data structures. It holds two collections: `allTasks` (a `List<Task>` implemented by `ArrayList`) and `processingQueue` (a `Queue<Task>` implemented by `LinkedList`). It provides methods to add tasks, view tasks, queue tasks, view the queue, and process tasks. Input validation (priority and index) is performed within `TaskManager` methods, reporting errors via `System.err`.
 * *   `TaskApp`: This class contains the `main` method, which serves as the application entry point and handles the user interface logic. It creates a `Scanner` for input and a `TaskManager` instance.
 * 
 * **Required Component Usage:**
 * 
 * 1.  **`java.util.Queue`:** The `processingQueue` field in `TaskManager` is declared as `Queue<Task>` and instantiated as `LinkedList<Task>`. Methods like `offer()` (in `addTaskToQueue`) and `poll()` (in `processNextTask`) are used to interact with the queue following FIFO principles.
 * 2.  **`java.util.ArrayList`:** The `allTasks` field in `TaskManager` is declared as `List<Task>` and explicitly instantiated as `new ArrayList<>()`. This fulfills the requirement to use `ArrayList`.
 * 3.  **`java.util.List` interface:** The `allTasks` field is declared using the `List` interface (`private List<Task> allTasks;`). The `getAllTasks()` method also returns `List<Task>`, demonstrating the use of the interface for variable declaration and return types.
 * 4.  **`java.util.Scanner`:** A `Scanner` object is created in the `main` method to read user input from `System.in`. `scanner.nextLine()` is used consistently to avoid common issues with mixing `nextInt()`, `nextLine()`, etc.
 * 5.  **`switch` statement:** A `switch` statement is used in the `main` method to control the application flow based on the user's menu choice.
 * 6.  **`System.err`:** Used throughout the `TaskManager` and `TaskApp` classes to print error messages, such as invalid priority, invalid task index, and non-numeric input for menu choices or indices.
 * 7.  **`System.out`:** Used for displaying the menu, prompts, successful task additions, listing tasks, viewing the queue, and reporting when the queue is empty or a task is processed.
 * 8.  **`try-catch` blocks:**
 *     *   **Class-wide:** The entire main application loop (`while(running)`) in the `main` method is wrapped in a `try-catch(Exception e)` block. This fulfills the requirement for class-wide exception handling, catching any unhandled runtime exceptions and reporting them to `System.err` with a stack trace.
 *     *   **Specific:** `try-catch(NumberFormatException e)` blocks are used around `Integer.parseInt()` calls when reading the menu choice and the task index to gracefully handle non-numeric input. The `Task` constructor uses `try-catch` to handle potential `IllegalArgumentException` if the description is empty.
 * 
 * **Best Practices:**
 * 
 * *   **Encapsulation:** Fields in `Task` and `TaskManager` are private. Access is provided through public methods. While the solution returns the internal `List` and `Queue` directly for simplicity in demonstrating their use within the exam scope, a note is included acknowledging that returning copies or unmodifiable views would be better for strict encapsulation in production code.
 * *   **Meaningful Names:** Classes, variables, and methods have descriptive names (`Task`, `TaskManager`, `processingQueue`, `addTask`, `processNextTask`, `printMenu`).
 * *   **Comments and Documentation:** Javadoc-style comments explain the purpose of classes and methods. Inline comments clarify specific logic points.
 * *   **Input Validation:** Priority strings are validated against "High", "Medium", "Low" (case-insensitive). Task indices are validated against the bounds of the `allTasks` list size. Numeric input is validated using `Integer.parseInt()` within a `try-catch`.
 * *   **Error Handling:** Errors are reported using `System.err`. Methods like `addTask` and `addTaskToQueue` return boolean status. `processNextTask` returns `null` if the queue is empty, allowing the caller (`main`) to check the result and print an appropriate message. Specific exceptions like `NumberFormatException` are caught.
 * *   **Clean Code Structure:** The logic is separated into distinct classes based on responsibility (`Task` for data, `TaskManager` for logic, `TaskApp` for UI/entry point). The `main` method is kept relatively clean by delegating complex operations to the `TaskManager`. A separate `printMenu` method improves readability. Using `scanner.nextLine()` and parsing avoids common `Scanner` pitfalls.
 * 
 * This solution effectively integrates all required Java components into a functional, albeit simple, application that demonstrates core programming concepts and best practices suitable for evaluating advanced understanding.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.Locale; // To handle case-insensitive priority check robustly

// Represents a single task with description and priority.
class Task {
    private String description;
    private String priority; // High, Medium, Low

    /**
     * Constructs a new Task.
     * @param description The task description.
     * @param priority The task priority (High, Medium, Low). Assumed to be validated before calling.
     * @throws IllegalArgumentException if description is null or empty.
     */
    public Task(String description, String priority) {
        if (description == null || description.trim().isEmpty()) {
            throw new IllegalArgumentException("Task description cannot be empty.");
        }
        this.description = description.trim();
        this.priority = priority;
    }

    public String getDescription() {
        return description;
    }

    public String getPriority() {
        return priority;
    }

    @Override
    public String toString() {
        return "[" + priority + "] " + description;
    }
}

// Manages the collection of all tasks and the processing queue.
class TaskManager {
    // Repository of all tasks created, using List interface and ArrayList implementation
    private List<Task> allTasks;
    // Queue for tasks ready to be processed, using Queue interface and LinkedList implementation
    private Queue<Task> processingQueue;

    /**
     * Constructs a new TaskManager, initializing the task lists and queue.
     */
    public TaskManager() {
        this.allTasks = new ArrayList<>(); // Use ArrayList
        this.processingQueue = new LinkedList<>(); // LinkedList implements Queue
    }

    /**
     * Adds a new task to the list of all tasks.
     * Validates priority input (case-insensitive High, Medium, Low).
     * @param description The task description.
     * @param priority The task priority string.
     * @return true if task was added successfully, false otherwise (e.g., invalid priority).
     */
    public boolean addTask(String description, String priority) {
        String lowerPriority = priority.trim().toLowerCase(Locale.US); // Use Locale.US for consistent case conversion
        if (!lowerPriority.equals("high") && !lowerPriority.equals("medium") && !lowerPriority.equals("low")) {
            System.err.println("Error: Invalid priority '" + priority + "'. Must be High, Medium, or Low.");
            return false;
        }
        try {
             // Create Task object; Task constructor validates description
             Task newTask = new Task(description, priority.trim());
             allTasks.add(newTask);
             System.out.println("Task added: " + newTask);
             return true;
        } catch (IllegalArgumentException e) {
             // Catch description validation error from Task constructor
             System.err.println("Error adding task: " + e.getMessage());
             return false;
        }
    }

    /**
     * Returns the list of all tasks.
     * Note: Returning the internal list directly is a simplification for exam scope.
     * In production code, one might return an unmodifiable list or a copy for better encapsulation.
     * @return A List of all tasks.
     */
    public List<Task> getAllTasks() {
        return allTasks;
    }

    /**
     * Adds a task from the allTasks list to the processing queue based on its index.
     * @param taskIndex The 0-based index of the task in the allTasks list.
     * @return true if task was successfully added to the queue, false otherwise (e.g., invalid index).
     */
    public boolean addTaskToQueue(int taskIndex) {
        if (taskIndex < 0 || taskIndex >= allTasks.size()) {
            System.err.println("Error: Invalid task index " + taskIndex + ". Please provide a valid index from the list (0 to " + (allTasks.size() - 1) + ").");
            return false;
        }
        Task taskToAdd = allTasks.get(taskIndex);
        processingQueue.offer(taskToAdd); // offer is safe, returns false if insertion fails (rare for LinkedList)
        System.out.println("Task added to processing queue: " + taskToAdd);
        return true;
    }

    /**
     * Returns the processing queue.
     * Note: Returning the direct queue is a simplification for exam scope.
     * In production code, one might provide methods to interact with the queue
     * (like peek, poll, size) without exposing the internal Queue object itself.
     * @return The Queue of tasks ready for processing.
     */
    public Queue<Task> getProcessingQueue() {
        return processingQueue;
    }

    /**
     * Processes the next task in the queue by removing it.
     * @return The Task that was processed, or null if the queue was empty.
     */
    public Task processNextTask() {
        Task nextTask = processingQueue.poll(); // poll removes and returns the head, or null if empty
        if (nextTask != null) {
            System.out.println("Processing task: " + nextTask);
            // Simulate processing work here if needed
        } else {
            // Message handled in the calling code for clarity
        }
        return nextTask;
    }
}

// Main application class for the Task Management System.
public class TaskApp {

    private static void printMenu() {
        System.out.println("\n--- Task Management Menu ---");
        System.out.println("1. Add New Task");
        System.out.println("2. View All Tasks");
        System.out.println("3. Add Task to Processing Queue");
        System.out.println("4. View Processing Queue");
        System.out.println("5. Process Next Task");
        System.out.println("0. Exit");
        System.out.println("--------------------------");
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        TaskManager taskManager = new TaskManager();
        boolean running = true;

        // Class-wide exception handling with try-catch blocks
        try {
            while (running) {
                printMenu();
                System.out.print("Enter your choice: ");

                int choice = -1;
                try {
                    // Use nextLine() and parse to avoid issues with Scanner's nextInt()/nextDouble() leaving newlines
                    String input = scanner.nextLine();
                    choice = Integer.parseInt(input);
                } catch (NumberFormatException e) {
                    System.err.println("Invalid input. Please enter a number corresponding to the menu option.");
                    continue; // Skip the rest of the loop and show menu again
                }

                // Switch statement for flow control
                switch (choice) {
                    case 1: // Add New Task
                        System.out.print("Enter task description: ");
                        String description = scanner.nextLine();
                        System.out.print("Enter task priority (High, Medium, Low): ");
                        String priority = scanner.nextLine();
                        taskManager.addTask(description, priority); // addTask handles validation and output
                        break;

                    case 2: // View All Tasks
                        List<Task> allTasks = taskManager.getAllTasks(); // Use List interface
                        if (allTasks.isEmpty()) {
                            System.out.println("No tasks available.");
                        } else {
                            System.out.println("\n--- All Tasks ---");
                            // Iterate through the List and print tasks with index
                            for (int i = 0; i < allTasks.size(); i++) {
                                System.out.println(i + ": " + allTasks.get(i));
                            }
                            System.out.println("-----------------");
                        }
                        break;

                    case 3: // Add Task to Processing Queue
                        System.out.print("Enter index of task to add to queue: ");
                        try {
                            String indexInput = scanner.nextLine();
                            int taskIndex = Integer.parseInt(indexInput);
                            taskManager.addTaskToQueue(taskIndex); // addTaskToQueue handles validation and output
                        } catch (NumberFormatException e) {
                            System.err.println("Invalid input. Please enter a valid task index (a number).");
                        }
                        break;

                    case 4: // View Processing Queue
                        Queue<Task> processingQueue = taskManager.getProcessingQueue(); // Use Queue
                        if (processingQueue.isEmpty()) {
                            System.out.println("Processing queue is empty.");
                        } else {
                            System.out.println("\n--- Processing Queue (Next to process at front) ---");
                            // Iterate through the Queue without removing elements
                            // LinkedList iterator provides elements in order
                            int i = 0;
                            for (Task task : processingQueue) {
                                System.out.println(i++ + ": " + task);
                            }
                            System.out.println("-----------------");
                        }
                        break;

                    case 5: // Process Next Task
                        Task processedTask = taskManager.processNextTask(); // processNextTask handles removal and returns task/null
                        if (processedTask == null) {
                             System.out.println("Processing queue is empty. No tasks to process.");
                        }
                        // Output for successful processing is handled inside processNextTask
                        break;

                    case 0: // Exit
                        System.out.println("Exiting Task Management System. Goodbye!");
                        running = false;
                        break;

                    default:
                        System.err.println("Invalid choice. Please enter a number between 0 and 5.");
                        break;
                }
            }
        } catch (Exception e) {
            // Catch any unexpected exceptions at the class level using System.err
            System.err.println("\nAn unexpected error occurred:");
            e.printStackTrace(System.err); // Print stack trace to the error stream
        } finally {
            // Ensure scanner is closed regardless of how the try block exits
            if (scanner != null) {
                scanner.close();
            }
            System.out.println("Application terminated.");
        }
    }
}
