/*
 * Exam Question #696
 * Generated on: 2025-05-12 16:27:21
 * Generated by: Account 3
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Advanced Task Processing System
 * 
 * **Scenario:**
 * 
 * You are tasked with building a simple command-line application to simulate a task processing system. The system should allow users to create tasks, view all created tasks, add tasks to a processing queue, process the next task from the queue, and view the current state of the processing queue. This system will demonstrate your understanding of core Java collections, input handling, control flow, and error management.
 * 
 * **Requirements:**
 * 
 * 1.  **Task Representation:** Create a `Task` class with private fields for `id` (integer), `description` (String), and `status` (using an enum `TaskStatus` with states like `CREATED`, `QUEUED`, `COMPLETED`, `FAILED`). Include a constructor, appropriate getters, and a method to update the status.
 * 2.  **Task Management:**
 *     *   Maintain a central list of *all* tasks created. This list should use the `List` interface and be implemented by `ArrayList`.
 *     *   Maintain a processing queue for tasks waiting to be processed. This queue must use the `Queue` interface.
 * 3.  **User Interface:** Implement a command-line interface using `Scanner` that presents the following menu options to the user:
 *     *   1. Add New Task
 *     *   2. View All Tasks
 *     *   3. Enqueue Task for Processing (User selects a task by ID from the list of all tasks)
 *     *   4. Process Next Task in Queue
 *     *   5. View Processing Queue
 *     *   0. Exit
 * 4.  **Functionality:**
 *     *   **Add New Task:** Prompt the user for a task description, create a new `Task` object with a unique ID and `CREATED` status, and add it to the list of all tasks.
 *     *   **View All Tasks:** Display all tasks currently in the central list, including their ID, description, and status.
 *     *   **Enqueue Task:** Prompt the user for the ID of a task to enqueue. Find the task in the central list. If found and its status is `CREATED`, change its status to `QUEUED` and add it to the processing queue. Handle cases where the ID is not found or the task is already queued/processed using appropriate error messages.
 *     *   **Process Next Task:** If the processing queue is not empty, remove the next task from the queue, change its status to `COMPLETED`, and print a message indicating processing is complete. If the queue is empty, print an error message.
 *     *   **View Processing Queue:** Display the tasks currently in the processing queue in the order they will be processed.
 *     *   **Exit:** Terminate the application.
 * 5.  **Required Java Components:** Your solution *must* explicitly use and demonstrate understanding of:
 *     *   `java.util.Queue`
 *     *   `java.util.ArrayList`
 *     *   `java.util.List`
 *     *   `java.util.Scanner`
 *     *   `switch` statement
 *     *   `System.err` for error messages
 *     *   `System.out` for normal output and prompts
 *     *   Class-wide exception handling using `try-catch` blocks (at least one significant block covering potential runtime issues like invalid input).
 * 6.  **Best Practices:** Implement the solution adhering to best practices:
 *     *   Proper encapsulation (private fields, public methods).
 *     *   Meaningful variable and method names.
 *     *   Appropriate comments explaining complex parts.
 *     *   Input validation (e.g., ensuring numeric input where expected, checking for empty descriptions, checking if task ID exists).
 *     *   Proper error handling using `try-catch` and `System.err`.
 *     *   Clean code structure (separate concerns into classes/methods).
 * 
 * **Expected Output:**
 * 
 * The program should run interactively, displaying the menu, prompting for input, and printing output or error messages based on the user's choices and the system's state. Successful operations should print informative messages to `System.out`. Errors (like invalid menu choices, non-numeric input, trying to enqueue a non-existent task, trying to process an empty queue) should be reported to `System.err`.
 * 
 * **Example Interaction Snippet:**
 * 
 * ```
 * --- Task Processor Menu ---
 * 1. Add New Task
 * ...
 * 0. Exit
 * ---------------------------
 * Enter your choice: 1
 * 
 * --- Add New Task ---
 * Enter task description: Prepare presentation
 * 
 * Task added successfully: Task [ID=1, Desc='Prepare presentation', Status=CREATED]
 * 
 * --- Task Processor Menu ---
 * ...
 * Enter your choice: 2
 * 
 * --- All Tasks ---
 * Task [ID=1, Desc='Prepare presentation', Status=CREATED]
 * 
 * --- Task Processor Menu ---
 * ...
 * Enter your choice: 3
 * 
 * --- Enqueue Task ---
 * --- All Tasks ---
 * Task [ID=1, Desc='Prepare presentation', Status=CREATED]
 * Enter ID of task to enqueue: 1
 * 
 * Task ID 1 enqueued successfully.
 * 
 * --- Task Processor Menu ---
 * ...
 * Enter your choice: 5
 * 
 * --- Processing Queue ---
 * Tasks in queue (order of processing):
 * 1. Task [ID=1, Desc='Prepare presentation', Status=QUEUED]
 * 
 * --- Task Processor Menu ---
 * ...
 * Enter your choice: 4
 * 
 * --- Process Next Task ---
 * Processing task: Prepare presentation (ID: 1)
 * Task ID 1 completed successfully.
 * 
 * --- Task Processor Menu ---
 * ...
 * Enter your choice: 5
 * 
 * --- Processing Queue ---
 * The processing queue is currently empty.
 * 
 * --- Task Processor Menu ---
 * ...
 * Enter your choice: abc
 * Error: Invalid input. Please enter a number.
 * 
 * --- Task Processor Menu ---
 * ...
 * Enter your choice: 4
 * Error: Processing queue is empty. No tasks to process.
 * 
 * --- Task Processor Menu ---
 * ...
 * Enter your choice: 0
 * Exiting Task Processor. Goodbye!
 * ```
 * 
 * Your solution should be a single Java file containing all necessary classes and the main method to run the application.
 *
 * EXPLANATION:
 * This solution implements a simple Task Processing System as requested, demonstrating the use of various core Java concepts and collections.
 * 
 * 1.  **Task Class and TaskStatus Enum:** The `Task` class encapsulates the data for a single task (ID, description, status). The `TaskStatus` enum provides a clear and type-safe way to represent the different states a task can be in (`CREATED`, `QUEUED`, `COMPLETED`, `FAILED`). Encapsulation is achieved by making fields private and providing public getters and a controlled setter for the status.
 * 
 * 2.  **Collections (`List`, `ArrayList`, `Queue`, `LinkedList`):**
 *     *   `List<Task> allTasks = new ArrayList<>();`: An `ArrayList` is used to store *all* tasks created in the system. `ArrayList` is suitable here because we need to access tasks by index (implicitly, when listing them for the user to choose an ID) and iterate through them easily. Declaring it as `List` promotes using the interface rather than the concrete implementation where possible.
 *     *   `Queue<Task> processingQueue = new LinkedList<>();`: A `Queue` is used specifically for tasks waiting to be processed. The `Queue` interface provides methods like `offer()` to add to the tail and `poll()` to remove from the head, perfectly simulating a waiting line or processing queue where tasks are handled in a First-In, First-Out (FIFO) order. `LinkedList` is a common and efficient implementation of the `Queue` interface.
 * 
 * 3.  **User Input (`Scanner`):** A `Scanner` object reads user input from the console (`System.in`) for menu choices and task details. It's initialized once and closed when the application exits.
 * 
 * 4.  **Control Flow (`switch`):** The main menu navigation in the `run()` method is handled efficiently using a `switch` statement based on the integer input from the user. This provides a clear structure for selecting different program actions.
 * 
 * 5.  **Output Streams (`System.out`, `System.err`):**
 *     *   `System.out.println()` is used for standard output, including the menu, prompts, successful operation confirmations, and listings of tasks/queue contents.
 *     *   `System.err.println()` is specifically used for displaying error messages, such as invalid input, task not found, or attempting an operation on an empty queue. This is good practice as it directs errors to the standard error stream, which can be handled separately from standard output by the operating system or development environment.
 * 
 * 6.  **Exception Handling (`try-catch`):**
 *     *   A `try-catch` block wraps the core logic inside the `run()` loop. This provides a class-wide mechanism to catch unexpected exceptions that might occur during the execution of menu options.
 *     *   A more specific `try-catch (InputMismatchException e)` is used when reading integer input (`scanner.nextInt()`). This is crucial because if the user enters non-numeric text when a number is expected, `scanner.nextInt()` throws this exception. Catching it prevents the program from crashing, informs the user of the error using `System.err`, and consumes the invalid input (`scanner.nextLine()`) to prevent an infinite loop.
 *     *   A general `catch (Exception e)` is included as a fallback for any other runtime errors, printing a general error message and the stack trace to `System.err` for debugging purposes.
 * 
 * 7.  **Input Validation and Error Handling:**
 *     *   Input validation is performed for the task description (checking if it's empty).
 *     *   Validation is performed when enqueuing a task: checking if the entered ID exists, and checking if the task is in a valid state (`CREATED`) to be enqueued.
 *     *   Operations like processing the next task check if the queue is empty before attempting to `poll()`.
 *     *   Appropriate error messages are printed to `System.err` when validation fails or operational errors occur.
 * 
 * 8.  **Code Structure and Best Practices:**
 *     *   The code is structured into logical methods (`addTask`, `viewAllTasks`, `enqueueTask`, etc.) within the `TaskProcessor` class, making it modular and readable.
 *     *   A helper method `findTaskById` is used to avoid code duplication when looking up tasks.
 *     *   Meaningful names are used for variables, methods, and the enum.
 *     *   Comments explain the purpose of classes, methods, and important code blocks.
 * 
 * This solution effectively uses the required Java components in a practical scenario, demonstrating proper object-oriented design principles, error handling, and collection management.
 */

import java.util.ArrayList;
import java.util.List;
import java.util.Queue;
import java.util.LinkedList;
import java.util.Scanner;
import java.util.InputMismatchException;

/**
 * Represents the status of a task in the system.
 */
enum TaskStatus {
    CREATED, QUEUED, COMPLETED, FAILED
}

/**
 * Represents a single task with an ID, description, and status.
 */
class Task {
    private int id;
    private String description;
    private TaskStatus status;

    /**
     * Constructs a new Task.
     * @param id The unique identifier for the task.
     * @param description A brief description of the task.
     */
    public Task(int id, String description) {
        this.id = id;
        this.description = description;
        this.status = TaskStatus.CREATED; // New tasks start as CREATED
    }

    // --- Getters ---
    public int getId() {
        return id;
    }

    public String getDescription() {
        return description;
    }

    public TaskStatus getStatus() {
        return status;
    }

    /**
     * Sets the status of the task.
     * @param status The new status for the task.
     */
    public void setStatus(TaskStatus status) {
        this.status = status;
    }

    @Override
    public String toString() {
        return "Task [ID=" + id + ", Desc='" + description + "', Status=" + status + "]";
    }
}

/**
 * Manages tasks using a list for all tasks and a queue for processing.
 */
public class TaskProcessor {

    // Use List interface, implemented by ArrayList, to store all tasks
    private List<Task> allTasks;
    // Use Queue interface, implemented by LinkedList, for the processing queue
    private Queue<Task> processingQueue;
    private Scanner scanner;
    private int nextTaskId; // Counter for generating unique task IDs

    /**
     * Constructs a new TaskProcessor, initializing collections and scanner.
     */
    public TaskProcessor() {
        allTasks = new ArrayList<>();
        processingQueue = new LinkedList<>(); // LinkedList is a common Queue implementation
        scanner = new Scanner(System.in);
        nextTaskId = 1; // Start task IDs from 1
    }

    /**
     * Displays the main menu options to the user.
     */
    private void printMenu() {
        System.out.println("--- Task Processor Menu ---");
        System.out.println("1. Add New Task");
        System.out.println("2. View All Tasks");
        System.out.println("3. Enqueue Task for Processing");
        System.out.println("4. Process Next Task in Queue");
        System.out.println("5. View Processing Queue");
        System.out.println("0. Exit");
        System.out.println("---------------------------");
    }

    /**
     * Adds a new task based on user input.
     */
    private void addTask() {
        System.out.println("\n--- Add New Task ---");
        System.out.print("Enter task description: ");
        String description = scanner.nextLine();

        // Input validation for description
        if (description == null || description.trim().isEmpty()) {
            System.err.println("Error: Task description cannot be empty.");
            return; // Exit the method if input is invalid
        }

        Task newTask = new Task(nextTaskId++, description.trim());
        allTasks.add(newTask);
        System.out.println("Task added successfully: " + newTask);
    }

    /**
     * Displays all tasks currently in the system.
     */
    private void viewAllTasks() {
        System.out.println("\n--- All Tasks ---");
        if (allTasks.isEmpty()) {
            System.out.println("No tasks created yet.");
        } else {
            // Iterate through the List of all tasks
            for (Task task : allTasks) {
                System.out.println(task);
            }
        }
    }

    /**
     * Enqueues a task for processing based on user-provided ID.
     */
    private void enqueueTask() {
        System.out.println("\n--- Enqueue Task ---");
        viewAllTasks(); // Show tasks to help user pick an ID

        if (allTasks.isEmpty()) {
            System.err.println("Cannot enqueue. No tasks available to select.");
            return;
        }

        System.out.print("Enter ID of task to enqueue: ");
        try {
            int taskId = scanner.nextInt();
            scanner.nextLine(); // Consume the newline character after reading the integer

            Task taskToEnqueue = findTaskById(taskId);

            if (taskToEnqueue == null) {
                System.err.println("Error: Task with ID " + taskId + " not found.");
            } else if (taskToEnqueue.getStatus() == TaskStatus.QUEUED) {
                 System.err.println("Error: Task with ID " + taskId + " is already in the queue.");
            } else if (taskToEnqueue.getStatus() == TaskStatus.COMPLETED || taskToEnqueue.getStatus() == TaskStatus.FAILED) {
                 System.err.println("Error: Task with ID " + taskId + " has already been processed.");
            }
            else {
                processingQueue.offer(taskToEnqueue); // Add task to the end of the queue
                taskToEnqueue.setStatus(TaskStatus.QUEUED); // Update status
                System.out.println("Task ID " + taskId + " enqueued successfully.");
            }
        } catch (InputMismatchException e) {
            // Handle non-integer input for task ID
            System.err.println("Error: Invalid input. Please enter a number for the task ID.");
            scanner.nextLine(); // Consume the invalid input to prevent infinite loop
        }
    }

    /**
     * Processes the next task from the front of the queue.
     */
    private void processNextTask() {
        System.out.println("\n--- Process Next Task ---");
        if (processingQueue.isEmpty()) {
            // Use System.err for operational errors like an empty queue
            System.err.println("Processing queue is empty. No tasks to process.");
        } else {
            // Get and remove the head of the queue
            Task taskToProcess = processingQueue.poll();
            System.out.println("Processing task: " + taskToProcess.getDescription() + " (ID: " + taskToProcess.getId() + ")");

            // Simulate processing - in a real system, this would do actual work
            try {
                 // Optional: Simulate work time
                 Thread.sleep(500);
            } catch (InterruptedException e) {
                // Handle interruption during simulated processing
                System.err.println("Processing interrupted for task ID " + taskToProcess.getId());
                taskToProcess.setStatus(TaskStatus.FAILED); // Mark as failed
                Thread.currentThread().interrupt(); // Restore the interrupted status
                return; // Stop processing this task
            }

            taskToProcess.setStatus(TaskStatus.COMPLETED); // Update status after successful processing
            System.out.println("Task ID " + taskToProcess.getId() + " completed successfully.");
        }
    }

    /**
     * Displays tasks currently waiting in the processing queue.
     */
    private void viewProcessingQueue() {
        System.out.println("\n--- Processing Queue ---");
        if (processingQueue.isEmpty()) {
            System.out.println("The processing queue is currently empty.");
        } else {
            System.out.println("Tasks in queue (order of processing):");
            // Iterate over the queue without removing elements (using enhanced for loop)
            int i = 1;
            for (Task task : processingQueue) {
                System.out.println(i++ + ". " + task);
            }
        }
    }

    /**
     * Helper method to find a Task object by its ID in the allTasks list.
     * @param id The ID of the task to find.
     * @return The Task object if found, null otherwise.
     */
    private Task findTaskById(int id) {
        // Iterate through the List to find the task
        for (Task task : allTasks) {
            if (task.getId() == id) {
                return task;
            }
        }
        return null; // Task not found
    }

    /**
     * The main application loop that handles user interaction.
     */
    public void run() {
        int choice = -1; // Initialize choice to a non-exit value

        // Main loop continues until user chooses to exit (choice 0)
        while (choice != 0) {
            printMenu();
            System.out.print("Enter your choice: ");

            // Use a try-catch block to handle potential exceptions during input or processing
            try {
                // Read user choice
                choice = scanner.nextInt();
                scanner.nextLine(); // Consume the newline character after reading the integer

                // Use a switch statement for menu navigation
                switch (choice) {
                    case 1:
                        addTask();
                        break;
                    case 2:
                        viewAllTasks();
                        break;
                    case 3:
                        enqueueTask();
                        break;
                    case 4:
                        processNextTask();
                        break;
                    case 5:
                        viewProcessingQueue();
                        break;
                    case 0:
                        System.out.println("Exiting Task Processor. Goodbye!");
                        break;
                    default:
                        // Handle choices outside the valid range
                        System.err.println("Invalid choice. Please enter a number between 0 and 5.");
                }
            } catch (InputMismatchException e) {
                // Catch specific exception for non-integer input
                System.err.println("Error: Invalid input. Please enter a number.");
                scanner.nextLine(); // Consume the invalid input to prevent infinite loop
                choice = -1; // Reset choice to prevent accidental exit if '0' was entered invalidly
            } catch (Exception e) {
                // Catch any other unexpected runtime exceptions
                System.err.println("An unexpected error occurred: " + e.getMessage());
                e.printStackTrace(System.err); // Print stack trace for debugging to standard error
                choice = -1; // Reset choice
            }
             System.out.println(); // Add a blank line for better readability between interactions
        }

        // Close the scanner when the application exits
        scanner.close();
    }

    /**
     * The entry point of the application.
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        TaskProcessor processor = new TaskProcessor();
        processor.run(); // Start the application
    }
}
