/*
 * Exam Question #997
 * Generated on: 2025-05-12 17:10:37
 * Generated by: Account 3
 * 
 * QUESTION:
 * ## Advanced Java Programming Exam: Hospital Appointment System
 * 
 * **Problem Description:**
 * 
 * You are tasked with developing a simplified console-based Hospital Appointment Management System. The system should allow patients to schedule appointments with doctors, view scheduled appointments, view waiting lists for doctors, and cancel appointments. If a doctor is unavailable at the requested time, the patient should be added to a waiting list for that specific doctor.
 * 
 * Your solution must demonstrate a strong understanding of core Java concepts and object-oriented design.
 * 
 * **Requirements:**
 * 
 * 1.  **Core Functionality:**
 *     *   Schedule Appointment: Allow a user to schedule an appointment for a patient with a specific doctor at a given time. If the doctor is available, schedule it. If not, add the patient to the doctor's waiting list.
 *     *   View Scheduled Appointments: Display all currently scheduled appointments.
 *     *   View Doctor's Waiting List: Display the patients currently in the waiting queue for a specific doctor.
 *     *   Cancel Appointment: Allow a user to cancel an existing appointment.
 *     *   Exit: Terminate the program.
 * 
 * 2.  **Required Java Components:** Your solution *must* utilize *all* of the following:
 *     *   `java.util.Queue`: To manage the waiting list for each doctor (First-In, First-Out).
 *     *   `java.util.ArrayList`: To store the list of patients, doctors, and scheduled appointments.
 *     *   `java.util.List` interface: Use this interface type for declarations where appropriate (e.g., method parameters, return types, or variable declarations for lists).
 *     *   `java.util.Scanner`: To get user input from the console.
 *     *   `switch` statement: For handling the main menu options.
 *     *   `System.err`: For displaying error messages (e.g., invalid input, doctor not found, appointment not found).
 *     *   `System.out`: For displaying normal output (menu, successful operations, lists).
 *     *   Class-wide exception handling with `try-catch` blocks: Implement robust error handling, catching potential exceptions during input processing or operation execution.
 * 
 * 3.  **Object-Oriented Design:**
 *     *   Create classes for `Patient`, `Doctor`, and `Appointment`.
 *     *   Create a main `Hospital` class (or similar) to manage the collections of patients, doctors, appointments, and waiting lists, and contain the core logic.
 *     *   Use proper encapsulation (private fields, public methods).
 *     *   Implement constructors and `toString()` methods for relevant classes.
 * 
 * 4.  **Data Management:**
 *     *   Pre-populate the system with a few sample `Doctor` and `Patient` objects.
 *     *   Use appropriate collections (`List`, `Queue`, potentially a `Map` to link Doctors to their Queues).
 * 
 * 5.  **Best Practices:**
 *     *   Meaningful variable and method names.
 *     *   Appropriate comments and JavaDocs.
 *     *   Basic input validation (e.g., checking if inputs are empty, handling non-integer menu input).
 *     *   Proper error handling using `try-catch` and `System.err`.
 * 
 * **Simplified Assumptions:**
 * 
 * *   Time is represented as a simple `String` (e.g., "10:00", "14:30"). No complex date/time logic is required.
 * *   Doctor availability is only checked against currently *scheduled* appointments.
 * *   Canceling an appointment does *not* automatically schedule the first patient from the waiting list.
 * *   Patient and Doctor names are unique identifiers for simplicity.
 * 
 * **Example Flow (User Interaction):**
 * 
 * ```
 * --- Hospital Appointment System ---
 * 1. Schedule Appointment
 * 2. View Scheduled Appointments
 * 3. View Doctor's Waiting List
 * 4. Cancel Appointment
 * 5. Exit
 * Enter your choice: 1
 * Enter Patient Name: Alice
 * Enter Doctor Name: Dr. Smith
 * Enter Appointment Time (e.g., 10:00): 10:00
 * Appointment scheduled successfully for Alice with Dr. Smith at 10:00.
 * 
 * --- Hospital Appointment System ---
 * ...
 * Enter your choice: 1
 * Enter Patient Name: Bob
 * Enter Doctor Name: Dr. Smith
 * Enter Appointment Time (e.g., 10:00): 10:00
 * Dr. Smith is unavailable at 10:00. Bob added to Dr. Smith's waiting list.
 * 
 * --- Hospital Appointment System ---
 * ...
 * Enter your choice: 2
 * Scheduled Appointments:
 * Patient: Alice, Doctor: Dr. Smith, Time: 10:00
 * 
 * --- Hospital Appointment System ---
 * ...
 * Enter your choice: 3
 * Enter Doctor Name: Dr. Smith
 * Dr. Smith's Waiting List:
 * Bob
 * 
 * --- Hospital Appointment System ---
 * ...
 * Enter your choice: 4
 * Enter Patient Name: Alice
 * Enter Doctor Name: Dr. Smith
 * Enter Appointment Time (e.g., 10:00): 10:00
 * Appointment cancelled successfully for Alice with Dr. Smith at 10:00.
 * 
 * --- Hospital Appointment System ---
 * ...
 * Enter your choice: 4
 * Enter Patient Name: Charlie
 * Enter Doctor Name: Dr. Jones
 * Enter Appointment Time (e.g., 11:00): 11:00
 * Error: Appointment not found for Charlie with Dr. Jones at 11:00.
 * 
 * --- Hospital Appointment System ---
 * ...
 * Enter your choice: 6
 * Error: Invalid choice. Please enter a number between 1 and 5.
 * 
 * --- Hospital Appointment System ---
 * ...
 * Enter your choice: exit
 * Error: Invalid input. Please enter a number.
 * 
 * --- Hospital Appointment System ---
 * ...
 * Enter your choice: 5
 * Exiting system.
 * ```
 * 
 * **Task:**
 * 
 * Write the complete Java code for this Hospital Appointment System based on the requirements above.
 * 
 * **Evaluation Criteria:**
 * 
 * *   Correct implementation of all required functionalities.
 * *   Correct usage of all required Java components (`Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.err`, `System.out`, `try-catch`).
 * *   Adherence to object-oriented principles (encapsulation, appropriate class design).
 * *   Effective use of data structures.
 * *   Robust error handling and input validation.
 * *   Code readability, comments, and adherence to best practices.
 *
 * EXPLANATION:
 * This solution implements a simplified Hospital Appointment Management System, fulfilling all the specified requirements and demonstrating the requested Java concepts.
 * 
 * **Design and Structure:**
 * 
 * *   **Entity Classes (`Patient`, `Doctor`, `Appointment`):** These classes represent the core entities in the system. They use private fields (`name`, `specialization`, `time`) and public getter methods, demonstrating encapsulation. `toString()` methods are provided for easy printing. Crucially, `equals()` and `hashCode()` methods are overridden based on relevant fields (name for Patient/Doctor, all fields for Appointment) to ensure correct comparison and functionality when using these objects within collections like `List` or `Map`.
 * *   **Management Class (`Hospital`):** This class acts as the central controller. It holds the main data structures (`patients`, `doctors`, `scheduledAppointments`, `waitingLists`) and contains the business logic for scheduling, viewing, and canceling appointments. This separation of concerns promotes modularity.
 * *   **Main Application Class (`HospitalManagementSystem`):** This class contains the `main` method, which handles user interaction via the `Scanner`, displays the menu, and delegates tasks to the `Hospital` object based on user input.
 * 
 * **Required Java Components Usage:**
 * 
 * 1.  **`java.util.Queue`:** Used in the `waitingLists` map. `waitingLists` is declared as `Map<Doctor, Queue<Patient>>`. A `LinkedList` is used as the concrete implementation for the `Queue` because `LinkedList` provides FIFO behavior suitable for a waiting list and implements the `Queue` interface. Patients are added using `offer()` when a doctor is unavailable. Viewing the waiting list iterates through the queue without removing elements.
 * 2.  **`java.util.ArrayList`:** Used for storing the lists of `patients`, `doctors`, and `scheduledAppointments`. These are declared as `List<T>` but instantiated as `new ArrayList<>()`. This demonstrates using the interface type for variable declarations while using a concrete implementation.
 * 3.  **`java.util.List` interface:** Used in the declarations of `patients`, `doctors`, and `scheduledAppointments` variables within the `Hospital` class (`private List<Patient> patients;`). This promotes flexibility as the underlying list implementation could be changed later without affecting the code that uses the `List` interface.
 * 4.  **`java.util.Scanner`:** Used in the `main` method of `HospitalManagementSystem` to read user input from the console for menu choices and appointment details. `scanner.nextInt()` reads the integer choice, and `scanner.nextLine()` is used carefully to consume the remaining newline character after reading numbers.
 * 5.  **`switch` statement:** Used in the `main` method to handle the different menu options selected by the user, directing the program flow to the appropriate method calls in the `Hospital` class.
 * 6.  **`System.err`:** Used throughout the code (primarily in the `Hospital` and `HospitalManagementSystem` classes) to print error messages when invalid input is detected, entities are not found, or operations fail (e.g., appointment not found for cancellation).
 * 7.  **`System.out`:** Used for all normal output, including displaying the menu, success messages, and listing scheduled appointments or waiting list patients.
 * 8.  **Class-wide `try-catch` blocks:** A `try-catch` block is wrapped around the main `switch` statement loop in the `main` method. This catches potential `InputMismatchException` if the user enters non-integer input for the menu choice, preventing the program from crashing and allowing it to prompt the user again. A general `Exception` catch is also included for unexpected errors. Specific checks (like `null` checks for `findPatient`, `findDoctor`, and input string emptiness) are performed before attempting operations, providing more specific error messages via `System.err`.
 * 
 * **Data Structures:**
 * 
 * *   `ArrayList` is suitable for storing lists of entities (`Patient`, `Doctor`, `Appointment`) where elements are added, removed (less frequently for patients/doctors, more for appointments), and iterated over. Random access by index isn't a primary need here, but ArrayList is a common and efficient default.
 * *   `HashMap<Doctor, Queue<Patient>>` is an effective way to manage waiting lists *per doctor*. The `Doctor` object serves as the key, mapping to a `Queue` specifically for patients waiting for that doctor. This allows quick access to a doctor's waiting list.
 * 
 * **Error Handling and Validation:**
 * 
 * *   Input validation: Basic checks are performed to ensure input strings (names, time) are not empty or just whitespace before attempting to use them to find entities or create appointments.
 * *   Entity not found: Methods like `findPatient` and `findDoctor` return `null` if the entity isn't found, and the calling code checks for `null` to print an error using `System.err`.
 * *   Appointment not found: When canceling, the code checks if the `remove()` operation on the `scheduledAppointments` list was successful to determine if the appointment existed.
 * *   `try-catch`: Handles non-numeric input for the menu choice and provides a general catch for unexpected errors, making the system more robust against user input issues.
 * 
 * **Best Practices:**
 * 
 * *   Meaningful names: Variables (`patientName`, `scheduledAppointments`, `waitingLists`), methods (`scheduleAppointment`, `findDoctor`, `isDoctorAvailable`), and classes clearly indicate their purpose.
 * *   Encapsulation: Private fields and public methods are used correctly.
 * *   Comments: Basic JavaDocs and inline comments explain the purpose of classes, methods, and key logic sections.
 * *   Clean Code: The logic is separated into distinct methods within the `Hospital` class, making the `main` method clean and focused on user interaction.
 * 
 * This solution effectively integrates the required components into a practical scenario, demonstrating key Java programming skills suitable for an advanced exam.
 */

import java.util.ArrayList;
import java.util.LinkedList; // LinkedList implements Queue
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.HashMap;
import java.util.Map;
import java.util.InputMismatchException;

// --- Entity Classes ---

/**
 * Represents a Patient.
 */
class Patient {
    private String name;

    public Patient(String name) {
        this.name = name;
    }

    public String getName() {
        return name;
    }

    @Override
    public String toString() {
        return name;
    }

    // Simple equality check based on name for finding patients
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Patient patient = (Patient) o;
        return name.equalsIgnoreCase(patient.name);
    }

    @Override
    public int hashCode() {
        return name.toLowerCase().hashCode();
    }
}

/**
 * Represents a Doctor.
 */
class Doctor {
    private String name;
    private String specialization;

    public Doctor(String name, String specialization) {
        this.name = name;
        this.specialization = specialization;
    }

    public String getName() {
        return name;
    }

    public String getSpecialization() {
        return specialization;
    }

    @Override
    public String toString() {
        return "Dr. " + name + " (" + specialization + ")";
    }

    // Simple equality check based on name for finding doctors
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Doctor doctor = (Doctor) o;
        return name.equalsIgnoreCase(doctor.name);
    }

    @Override
    public int hashCode() {
        return name.toLowerCase().hashCode();
    }
}

/**
 * Represents a scheduled Appointment.
 */
class Appointment {
    private Patient patient;
    private Doctor doctor;
    private String time; // Using String for simplicity

    public Appointment(Patient patient, Doctor doctor, String time) {
        this.patient = patient;
        this.doctor = doctor;
        this.time = time;
    }

    public Patient getPatient() {
        return patient;
    }

    public Doctor getDoctor() {
        return doctor;
    }

    public String getTime() {
        return time;
    }

    @Override
    public String toString() {
        return "Patient: " + patient.getName() + ", Doctor: " + doctor.getName() + ", Time: " + time;
    }

    // Equality check for finding specific appointments to cancel
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Appointment that = (Appointment) o;
        return patient.equals(that.patient) &&
               doctor.equals(that.doctor) &&
               time.equalsIgnoreCase(that.time);
    }

    @Override
    public int hashCode() {
        int result = patient.hashCode();
        result = 31 * result + doctor.hashCode();
        result = 31 * result + time.toLowerCase().hashCode();
        return result;
    }
}

// --- Management Class ---

/**
 * Manages the hospital's patients, doctors, appointments, and waiting lists.
 */
class Hospital {
    private List<Patient> patients;
    private List<Doctor> doctors;
    private List<Appointment> scheduledAppointments;
    // Map to hold a Queue of waiting Patients for each Doctor
    private Map<Doctor, Queue<Patient>> waitingLists;

    public Hospital() {
        patients = new ArrayList<>();
        doctors = new ArrayList<>();
        scheduledAppointments = new ArrayList<>();
        waitingLists = new HashMap<>();

        // Pre-populate some data
        Patient p1 = new Patient("Alice");
        Patient p2 = new Patient("Bob");
        Patient p3 = new Patient("Charlie");
        patients.add(p1);
        patients.add(p2);
        patients.add(p3);

        Doctor d1 = new Doctor("Smith", "Cardiology");
        Doctor d2 = new Doctor("Jones", "Pediatrics");
        doctors.add(d1);
        doctors.add(d2);

        // Initialize waiting lists for all doctors
        for (Doctor doctor : doctors) {
            waitingLists.put(doctor, new LinkedList<>()); // LinkedList implements Queue
        }
    }

    /**
     * Finds a patient by name (case-insensitive).
     * @param name The name of the patient to find.
     * @return The Patient object if found, null otherwise.
     */
    private Patient findPatient(String name) {
        for (Patient patient : patients) {
            if (patient.getName().equalsIgnoreCase(name)) {
                return patient;
            }
        }
        return null;
    }

    /**
     * Finds a doctor by name (case-insensitive).
     * @param name The name of the doctor to find.
     * @return The Doctor object if found, null otherwise.
     */
    private Doctor findDoctor(String name) {
        for (Doctor doctor : doctors) {
            if (doctor.getName().equalsIgnoreCase(name)) {
                return doctor;
            }
        }
        return null;
    }

    /**
     * Checks if a doctor is available at a specific time.
     * Availability is determined by checking for existing scheduled appointments.
     * @param doctor The doctor to check.
     * @param time The time slot to check.
     * @return true if the doctor has no scheduled appointment at that time, false otherwise.
     */
    private boolean isDoctorAvailable(Doctor doctor, String time) {
        for (Appointment appointment : scheduledAppointments) {
            if (appointment.getDoctor().equals(doctor) && appointment.getTime().equalsIgnoreCase(time)) {
                return false; // Doctor is busy
            }
        }
        return true; // Doctor is available
    }

    /**
     * Schedules an appointment or adds the patient to the waiting list.
     * @param patientName The name of the patient.
     * @param doctorName The name of the doctor.
     * @param time The requested appointment time.
     */
    public void scheduleAppointment(String patientName, String doctorName, String time) {
        Patient patient = findPatient(patientName);
        if (patient == null) {
            System.err.println("Error: Patient '" + patientName + "' not found.");
            return;
        }

        Doctor doctor = findDoctor(doctorName);
        if (doctor == null) {
            System.err.println("Error: Doctor '" + doctorName + "' not found.");
            return;
        }

        // Basic input validation for time
        if (time == null || time.trim().isEmpty()) {
             System.err.println("Error: Appointment time cannot be empty.");
             return;
        }


        if (isDoctorAvailable(doctor, time)) {
            Appointment newAppointment = new Appointment(patient, doctor, time);
            scheduledAppointments.add(newAppointment);
            System.out.println("Appointment scheduled successfully for " + patient.getName() +
                               " with " + doctor.getName() + " at " + time + ".");
        } else {
            // Add patient to the doctor's waiting list
            Queue<Patient> doctorWaitingList = waitingLists.get(doctor);
            // Check if patient is already in the waiting list (optional, but good practice)
            if (doctorWaitingList != null && !doctorWaitingList.contains(patient)) {
                doctorWaitingList.offer(patient); // Add to the end of the queue
                System.out.println(doctor.getName() + " is unavailable at " + time +
                                   ". " + patient.getName() + " added to " + doctor.getName() + "'s waiting list.");
            } else if (doctorWaitingList == null) {
                 System.err.println("Internal Error: Waiting list not initialized for " + doctor.getName());
            } else {
                 System.out.println(patient.getName() + " is already in " + doctor.getName() + "'s waiting list.");
            }
        }
    }

    /**
     * Displays all scheduled appointments.
     */
    public void viewScheduledAppointments() {
        if (scheduledAppointments.isEmpty()) {
            System.out.println("No appointments scheduled yet.");
        } else {
            System.out.println("--- Scheduled Appointments ---");
            for (Appointment appointment : scheduledAppointments) {
                System.out.println(appointment);
            }
        }
    }

    /**
     * Displays the waiting list for a specific doctor.
     * @param doctorName The name of the doctor whose waiting list to view.
     */
    public void viewDoctorWaitingList(String doctorName) {
        Doctor doctor = findDoctor(doctorName);
        if (doctor == null) {
            System.err.println("Error: Doctor '" + doctorName + "' not found.");
            return;
        }

        Queue<Patient> doctorWaitingList = waitingLists.get(doctor);
        if (doctorWaitingList == null || doctorWaitingList.isEmpty()) {
            System.out.println(doctor.getName() + "'s waiting list is empty.");
        } else {
            System.out.println("--- " + doctor.getName() + "'s Waiting List ---");
            // Iterate through the queue without removing elements
            for (Patient patient : doctorWaitingList) {
                System.out.println(patient.getName());
            }
        }
    }

    /**
     * Cancels a specific scheduled appointment.
     * @param patientName The name of the patient.
     * @param doctorName The name of the doctor.
     * @param time The appointment time.
     */
    public void cancelAppointment(String patientName, String doctorName, String time) {
        Patient patient = findPatient(patientName);
        if (patient == null) {
            System.err.println("Error: Patient '" + patientName + "' not found.");
            return;
        }

        Doctor doctor = findDoctor(doctorName);
        if (doctor == null) {
            System.err.println("Error: Doctor '" + doctorName + "' not found.");
            return;
        }

         // Basic input validation for time
        if (time == null || time.trim().isEmpty()) {
             System.err.println("Error: Appointment time cannot be empty.");
             return;
        }

        Appointment appointmentToCancel = new Appointment(patient, doctor, time); // Create a dummy appointment for comparison

        boolean removed = scheduledAppointments.remove(appointmentToCancel);

        if (removed) {
            System.out.println("Appointment cancelled successfully for " + patientName +
                               " with " + doctorName + " at " + time + ".");
        } else {
            System.err.println("Error: Appointment not found for " + patientName +
                               " with " + doctorName + " at " + time + ".");
        }
    }
}

// --- Main Application Class ---

public class HospitalManagementSystem {

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        Hospital hospital = new Hospital();
        boolean running = true;

        while (running) {
            printMenu();

            try {
                System.out.print("Enter your choice: ");
                int choice = scanner.nextInt();
                scanner.nextLine(); // Consume newline left-over

                switch (choice) {
                    case 1:
                        System.out.print("Enter Patient Name: ");
                        String patientName = scanner.nextLine();
                        System.out.print("Enter Doctor Name: ");
                        String doctorName = scanner.nextLine();
                        System.out.print("Enter Appointment Time (e.g., 10:00): ");
                        String time = scanner.nextLine();
                        // Basic validation before passing to hospital logic
                        if (patientName.trim().isEmpty() || doctorName.trim().isEmpty() || time.trim().isEmpty()) {
                            System.err.println("Error: All fields (Patient Name, Doctor Name, Time) are required.");
                        } else {
                            hospital.scheduleAppointment(patientName, doctorName, time);
                        }
                        break;
                    case 2:
                        hospital.viewScheduledAppointments();
                        break;
                    case 3:
                        System.out.print("Enter Doctor Name: ");
                        String doctorNameForWaitingList = scanner.nextLine();
                         if (doctorNameForWaitingList.trim().isEmpty()) {
                             System.err.println("Error: Doctor Name is required.");
                         } else {
                            hospital.viewDoctorWaitingList(doctorNameForWaitingList);
                         }
                        break;
                    case 4:
                        System.out.print("Enter Patient Name: ");
                        String patientNameCancel = scanner.nextLine();
                        System.out.print("Enter Doctor Name: ");
                        String doctorNameCancel = scanner.nextLine();
                        System.out.print("Enter Appointment Time (e.g., 10:00): ");
                        String timeCancel = scanner.nextLine();
                         if (patientNameCancel.trim().isEmpty() || doctorNameCancel.trim().isEmpty() || timeCancel.trim().isEmpty()) {
                            System.err.println("Error: All fields (Patient Name, Doctor Name, Time) are required for cancellation.");
                        } else {
                            hospital.cancelAppointment(patientNameCancel, doctorNameCancel, timeCancel);
                        }
                        break;
                    case 5:
                        running = false;
                        System.out.println("Exiting system.");
                        break;
                    default:
                        System.err.println("Error: Invalid choice. Please enter a number between 1 and 5.");
                }
            } catch (InputMismatchException e) {
                System.err.println("Error: Invalid input. Please enter a number.");
                scanner.nextLine(); // Consume the invalid input to prevent infinite loop
            } catch (Exception e) {
                // Catch any other unexpected exceptions
                System.err.println("An unexpected error occurred: " + e.getMessage());
                // e.printStackTrace(); // Uncomment for debugging
            }
            System.out.println(); // Add a blank line for readability
        }

        scanner.close();
    }

    private static void printMenu() {
        System.out.println("--- Hospital Appointment System ---");
        System.out.println("1. Schedule Appointment");
        System.out.println("2. View Scheduled Appointments");
        System.out.println("3. View Doctor's Waiting List");
        System.out.println("4. Cancel Appointment");
        System.out.println("5. Exit");
    }
}
