/*
 * Exam Question #501
 * Generated on: 2025-05-11 23:20:50
 * Generated by: Account 3
 * 
 * QUESTION:
 * **Java Programming Exam Task: Event Session Management System**
 * 
 * **Problem Description:**
 * 
 * You are tasked with developing a simplified Event Session Management System. The system should allow managing multiple sessions within an event. Each session has a limited capacity for attendees. If a session reaches its capacity, subsequent registration requests for that session should be added to a waitlist. If a registered attendee cancels their registration, the first person on the waitlist (if any) should be automatically moved to the registered list.
 * 
 * The system should provide a command-line interface for user interaction.
 * 
 * **Requirements:**
 * 
 * 1.  **Data Structures:**
 *     *   Use `java.util.List` to store the collection of sessions managed by the system.
 *     *   Within each session object:
 *         *   Use `java.util.ArrayList` to store the attendees currently registered for the session.
 *         *   Use `java.util.Queue` to store attendees on the waitlist for the session.
 * 2.  **User Input:**
 *     *   Use `java.util.Scanner` to read user commands and data (like session names, attendee names, capacity).
 * 3.  **Control Flow:**
 *     *   Implement a main application loop that presents a menu of options to the user.
 *     *   Use a `switch` statement to handle the user's choice from the menu.
 * 4.  **Output:**
 *     *   Use `System.out` for displaying the menu, successful operations, and session details.
 *     *   Use `System.err` to display error messages, warnings, and invalid input notifications.
 * 5.  **Error Handling:**
 *     *   Implement input validation (e.g., checking if a session exists, if capacity is valid, if an attendee is already registered or on the waitlist).
 *     *   Use `try-catch` blocks for class-wide exception handling to gracefully manage unexpected errors during program execution.
 * 6.  **Object-Oriented Design:**
 *     *   Create appropriate classes (`Attendee`, `Session`, `EventManager`) with private fields and public methods (encapsulation).
 *     *   Use meaningful names for variables, methods, and classes.
 *     *   Include basic comments and documentation where necessary.
 * 7.  **Functionality:**
 *     *   Add a new session (requires name and capacity). Validate capacity > 0.
 *     *   Register an attendee for a session (requires attendee name and session name).
 *         *   If capacity is available, add to registered list.
 *         *   If full, add to waitlist queue.
 *         *   Handle cases where attendee is already registered or already on the waitlist.
 *         *   Handle case where session does not exist.
 *     *   Cancel an attendee's registration for a session (requires attendee name and session name).
 *         *   Remove from registered list.
 *         *   If removed from registered and the waitlist is not empty, move the first person from the waitlist to the registered list.
 *         *   Handle case where attendee is not registered for the session.
 *         *   Handle case where session does not exist.
 *     *   View details for a specific session (requires session name). Display registered attendees and waitlist attendees.
 *     *   View details for all sessions (list all sessions with basic info).
 *     *   Exit the application.
 * 
 * **Expected Output:**
 * 
 * The system should display a menu, prompt for input based on the selected option, and display results or error messages accordingly.
 * 
 * *   Successful operations should be clearly indicated using `System.out`.
 * *   Errors (invalid input, session not found, attendee issues) should be reported using `System.err`.
 * *   Session details should list registered attendees and waitlist attendees clearly.
 * 
 * **Example Interaction Flow (Illustrative):**
 * 
 * ```
 * Event Session Management System
 * Menu:
 * 1. Add Session
 * 2. Register Attendee
 * 3. Cancel Registration
 * 4. View Session Details
 * 5. View All Sessions
 * 6. Exit
 * Enter choice: 1
 * Enter session name: Java Basics
 * Enter capacity: 2
 * Session 'Java Basics' added with capacity 2.
 * 
 * Enter choice: 1
 * Enter session name: Advanced Topics
 * Enter capacity: 1
 * Session 'Advanced Topics' added with capacity 1.
 * 
 * Enter choice: 2
 * Enter attendee name: Alice
 * Enter session name: Java Basics
 * Alice registered for 'Java Basics'.
 * 
 * Enter choice: 2
 * Enter attendee name: Bob
 * Enter session name: Java Basics
 * Bob registered for 'Java Basics'.
 * 
 * Enter choice: 2
 * Enter attendee name: Charlie
 * Enter session name: Java Basics
 * Session 'Java Basics' is full. Charlie added to waitlist.
 * 
 * Enter choice: 4
 * Enter session name: Java Basics
 * Session: Java Basics (Capacity: 2)
 * Registered Attendees (2): [Alice, Bob]
 * Waitlist (1): [Charlie]
 * 
 * Enter choice: 3
 * Enter attendee name: Alice
 * Enter session name: Java Basics
 * Alice cancelled registration for 'Java Basics'. Charlie moved from waitlist to registered.
 * 
 * Enter choice: 4
 * Enter session name: Java Basics
 * Session: Java Basics (Capacity: 2)
 * Registered Attendees (2): [Bob, Charlie]
 * Waitlist (0): []
 * 
 * Enter choice: 6
 * Exiting system.
 * ```
 * 
 * Implement the Java code for this system.
 *
 * EXPLANATION:
 * This solution implements the Event Session Management System following all the specified requirements.
 * 
 * 1.  **Class Structure:**
 *     *   `Attendee`: A simple class to represent an attendee with a `name`. Includes `equals` and `hashCode` based on the name to correctly identify attendees in collections.
 *     *   `Session`: Manages a single session. It holds the session's `name`, `capacity`, an `ArrayList` (`registeredAttendees`) for attendees within capacity, and a `Queue` (`waitlist`) for attendees waiting for a spot. It includes methods for registration (`registerAttendee`), cancellation (`cancelRegistration`), checking status (`isFull`, `isRegistered`, `isOnWaitlist`), and retrieving lists (returning copies for encapsulation). The `cancelRegistration` method correctly handles moving the first person from the waitlist to the registered list when a spot opens.
 *     *   `EventManager`: Acts as the central manager, holding a `List` (`sessions`) of `Session` objects. It provides methods for adding sessions, registering/cancelling attendees across sessions, and displaying session information. It uses a helper method `findSessionByName` to locate sessions.
 *     *   `EventManagementApp`: Contains the `main` method. This is the entry point of the application. It sets up the `Scanner` and `EventManager` and runs the main application loop.
 * 
 * 2.  **Required Components Usage:**
 *     *   `java.util.Queue`: Used in the `Session` class (`waitlist`) to maintain the order of attendees waiting for registration. `LinkedList` is used as the concrete implementation of `Queue`.
 *     *   `java.util.ArrayList`: Used in the `Session` class (`registeredAttendees`) to store attendees who are successfully registered.
 *     *   `java.util.List`: Used in the `EventManager` class (`sessions`) to hold the collection of `Session` objects. `ArrayList` is used as the concrete implementation.
 *     *   `java.util.Scanner`: Used in the `main` method of `EventManagementApp` to read user input from the console. `scanner.nextLine()` is used consistently to avoid common pitfalls with mixing `nextInt()`/`nextDouble()` and `nextLine()`.
 *     *   `switch statement`: Used in the `main` method within the `while` loop to handle the different menu options selected by the user.
 *     *   `System.err`: Used throughout the `EventManager` and `EventManagementApp` classes to print error messages related to invalid input, sessions/attendees not found, and business logic validation failures (e.g., session already exists, attendee already registered). Also used for printing unexpected exception details.
 *     *   `System.out`: Used throughout the classes to print the menu, prompt for input, confirm successful operations (session added, attendee registered/cancelled), display session details, and indicate system exit.
 *     *   `try-catch blocks`:
 *         *   A large `try-catch(Exception e)` block is wrapped around the main `while` loop in `main`. This provides class-wide exception handling, catching any unexpected runtime exceptions that might occur during the execution of the menu options and preventing the program from crashing abruptly. The caught exception's details are printed to `System.err`.
 *         *   More specific `try-catch` blocks are used where predictable errors might occur, such as catching `NumberFormatException` when parsing capacity input and `IllegalArgumentException` thrown by `Session` or `EventManager` methods for business rule violations (like adding a session with capacity <= 0 or registering an attendee who is already registered). These specific catches also report errors using `System.err`.
 * 
 * 3.  **Best Practices:**
 *     *   **Encapsulation:** Fields in `Attendee`, `Session`, and `EventManager` are `private`. Access is provided through public methods (getters, business logic methods like `registerAttendee`). Copies of collections are returned by getters (`getRegisteredAttendees`, `getWaitlist`) to prevent external modification of internal state.
 *     *   **Meaningful Names:** Classes, variables, and methods have descriptive names (`registeredAttendees`, `cancelRegistration`, `findSessionByName`, `EventManagementApp`).
 *     *   **Comments:** Basic comments are included to explain the purpose of classes and key methods.
 *     *   **Input Validation:** Checks are performed for empty names, invalid capacity, and existence of sessions before attempting operations. Errors are reported via `System.err`.
 *     *   **Error Handling:** Both specific logical errors (using `IllegalArgumentException` and checking return values/conditions) and general unexpected errors (using the main `try-catch`) are handled, with error messages directed to `System.err`.
 *     *   **Clean Code Structure:** The code is divided into logical classes, and methods are reasonably focused on single responsibilities. The `main` method primarily handles user interaction and delegates core logic to the `EventManager`.
 * 
 * This solution effectively demonstrates the required Java concepts and data structures in a practical, albeit simplified, event management scenario, including crucial aspects like capacity limits, waitlists, and error handling.
 */

import java.util.ArrayList;
import java.util.LinkedList; // LinkedList implements Queue
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.Iterator; // Needed for safe removal during iteration

// Represents an attendee
class Attendee {
    private String name;

    public Attendee(String name) {
        this.name = name;
    }

    public String getName() {
        return name;
    }

    @Override
    public String toString() {
        return name;
    }

    // Important for checking if an attendee exists in a list/queue by name
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Attendee attendee = (Attendee) o;
        return name.equals(attendee.name);
    }

    @Override
    public int hashCode() {
        return name.hashCode();
    }
}

// Represents a session within the event
class Session {
    private String name;
    private int capacity;
    private List<Attendee> registeredAttendees; // Using ArrayList as required
    private Queue<Attendee> waitlist; // Using Queue as required

    public Session(String name, int capacity) {
        if (capacity <= 0) {
            throw new IllegalArgumentException("Capacity must be positive.");
        }
        this.name = name;
        this.capacity = capacity;
        this.registeredAttendees = new ArrayList<>(); // Initialize ArrayList
        this.waitlist = new LinkedList<>(); // Initialize Queue using LinkedList
    }

    public String getName() {
        return name;
    }

    public int getCapacity() {
        return capacity;
    }

    public List<Attendee> getRegisteredAttendees() {
        return new ArrayList<>(registeredAttendees); // Return a copy for encapsulation
    }

    public Queue<Attendee> getWaitlist() {
        return new LinkedList<>(waitlist); // Return a copy for encapsulation
    }

    public boolean isFull() {
        return registeredAttendees.size() >= capacity;
    }

    public boolean isRegistered(Attendee attendee) {
        return registeredAttendees.contains(attendee);
    }

    public boolean isOnWaitlist(Attendee attendee) {
        return waitlist.contains(attendee);
    }

    // Attempts to register an attendee
    // Returns true if registered, false if added to waitlist, throws exception if already exists
    public boolean registerAttendee(Attendee attendee) {
        if (isRegistered(attendee) || isOnWaitlist(attendee)) {
            throw new IllegalArgumentException("Attendee '" + attendee.getName() + "' is already registered or on waitlist for session '" + name + "'.");
        }

        if (!isFull()) {
            registeredAttendees.add(attendee);
            return true; // Successfully registered
        } else {
            waitlist.offer(attendee); // Add to the end of the waitlist queue
            return false; // Added to waitlist
        }
    }

    // Attempts to cancel registration for an attendee
    // Returns true if cancelled, false if attendee not found in registered list
    public boolean cancelRegistration(Attendee attendee) {
        boolean removed = registeredAttendees.remove(attendee);

        if (removed) {
            // If someone was removed from registered list and there's someone on the waitlist,
            // move the first person from the waitlist to the registered list.
            if (!waitlist.isEmpty()) {
                Attendee nextAttendee = waitlist.poll(); // Get and remove the head of the queue
                if (nextAttendee != null) { // Should not be null if !waitlist.isEmpty()
                    registeredAttendees.add(nextAttendee);
                    System.out.println(nextAttendee.getName() + " moved from waitlist to registered for '" + name + "'."); // Using System.out for this internal event
                }
            }
            return true; // Successfully cancelled
        } else {
            // Also check waitlist in case they were trying to cancel from there (optional, but good practice)
            // For this problem, we only require cancellation from registered, but let's add a check.
             boolean removedFromWaitlist = waitlist.remove(attendee);
             if(removedFromWaitlist) {
                 // Attendee was on waitlist, not registered.
                 // Depending on requirements, this might be an error or just removal from waitlist.
                 // Let's treat it as successful removal from the system for this session.
                 return true; // Successfully removed from waitlist
             }
            return false; // Attendee not found in either list
        }
    }

    @Override
    public String toString() {
        return "Session: " + name + " (Capacity: " + capacity + ", Registered: " + registeredAttendees.size() + ", Waitlist: " + waitlist.size() + ")";
    }
}

// Manages the collection of sessions
class EventManager {
    private List<Session> sessions; // Using List interface as required

    public EventManager() {
        this.sessions = new ArrayList<>(); // Initialize using ArrayList
    }

    // Finds a session by name
    private Session findSessionByName(String name) {
        for (Session session : sessions) {
            if (session.getName().equalsIgnoreCase(name)) { // Case-insensitive search for session names
                return session;
            }
        }
        return null; // Session not found
    }

    // Adds a new session
    public void addSession(String name, int capacity) {
        if (name == null || name.trim().isEmpty()) {
            throw new IllegalArgumentException("Session name cannot be empty.");
        }
        if (findSessionByName(name) != null) {
            throw new IllegalArgumentException("Session with name '" + name + "' already exists.");
        }
        // Capacity validation is handled in Session constructor

        Session newSession = new Session(name.trim(), capacity);
        sessions.add(newSession);
        System.out.println("Session '" + newSession.getName() + "' added with capacity " + newSession.getCapacity() + "."); // System.out for success
    }

    // Registers an attendee to a session
    public void registerAttendeeToSession(String attendeeName, String sessionName) {
        if (attendeeName == null || attendeeName.trim().isEmpty()) {
            System.err.println("Error: Attendee name cannot be empty."); // System.err for input validation error
            return;
        }
        if (sessionName == null || sessionName.trim().isEmpty()) {
            System.err.println("Error: Session name cannot be empty."); // System.err for input validation error
            return;
        }

        Session session = findSessionByName(sessionName.trim());
        if (session == null) {
            System.err.println("Error: Session '" + sessionName.trim() + "' not found."); // System.err for session not found
            return;
        }

        Attendee attendee = new Attendee(attendeeName.trim());
        try {
            boolean registered = session.registerAttendee(attendee);
            if (registered) {
                System.out.println(attendee.getName() + " registered for '" + session.getName() + "'."); // System.out for success
            } else {
                System.out.println("Session '" + session.getName() + "' is full. " + attendee.getName() + " added to waitlist."); // System.out for waitlist
            }
        } catch (IllegalArgumentException e) {
            System.err.println("Error: " + e.getMessage()); // System.err for registration logic errors
        }
    }

    // Cancels an attendee's registration for a session
    public void cancelAttendeeRegistration(String attendeeName, String sessionName) {
         if (attendeeName == null || attendeeName.trim().isEmpty()) {
            System.err.println("Error: Attendee name cannot be empty."); // System.err for input validation error
            return;
        }
        if (sessionName == null || sessionName.trim().isEmpty()) {
            System.err.println("Error: Session name cannot be empty."); // System.err for input validation error
            return;
        }

        Session session = findSessionByName(sessionName.trim());
        if (session == null) {
            System.err.println("Error: Session '" + sessionName.trim() + "' not found."); // System.err for session not found
            return;
        }

        Attendee attendee = new Attendee(attendeeName.trim());
        boolean cancelled = session.cancelRegistration(attendee);

        if (cancelled) {
             // The session's cancelRegistration method already prints the waitlist move if it happens
            System.out.println(attendee.getName() + " successfully removed from '" + session.getName() + "'."); // System.out for success
        } else {
            System.err.println("Error: Attendee '" + attendee.getName() + "' not found registered or on waitlist for session '" + session.getName() + "'."); // System.err for attendee not found
        }
    }

    // Displays details for a specific session
    public void displaySessionDetails(String sessionName) {
        if (sessionName == null || sessionName.trim().isEmpty()) {
            System.err.println("Error: Session name cannot be empty."); // System.err for input validation error
            return;
        }

        Session session = findSessionByName(sessionName.trim());
        if (session == null) {
            System.err.println("Error: Session '" + sessionName.trim() + "' not found."); // System.err for session not found
            return;
        }

        System.out.println(session); // Prints the basic session info using toString()
        System.out.println("Registered Attendees (" + session.getRegisteredAttendees().size() + "): " + session.getRegisteredAttendees()); // System.out for details
        System.out.println("Waitlist (" + session.getWaitlist().size() + "): " + session.getWaitlist()); // System.out for details
    }

    // Displays details for all sessions
    public void displayAllSessions() {
        if (sessions.isEmpty()) {
            System.out.println("No sessions available yet."); // System.out for empty list
            return;
        }
        System.out.println("--- All Sessions ---"); // System.out header
        for (Session session : sessions) {
            System.out.println(session); // System.out for each session summary
        }
        System.out.println("--------------------"); // System.out footer
    }
}

// Main class to run the application
public class EventManagementApp {

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in); // Using Scanner
        EventManager manager = new EventManager();
        boolean running = true;

        System.out.println("Event Session Management System");

        // Class-wide exception handling using try-catch around the main loop
        try {
            while (running) {
                printMenu();
                System.out.print("Enter choice: ");
                String choiceInput = scanner.nextLine(); // Read full line to avoid issues with nextInt/nextLine mix

                // Use switch statement for flow control
                switch (choiceInput.trim()) {
                    case "1": // Add Session
                        System.out.print("Enter session name: ");
                        String sessionNameAdd = scanner.nextLine();
                        System.out.print("Enter capacity: ");
                        int capacity = 0;
                        try {
                            capacity = Integer.parseInt(scanner.nextLine());
                            manager.addSession(sessionNameAdd, capacity);
                        } catch (NumberFormatException e) {
                            System.err.println("Error: Invalid capacity format. Please enter a number."); // System.err for parsing error
                        } catch (IllegalArgumentException e) {
                             System.err.println("Error: " + e.getMessage()); // System.err for business logic errors (name empty, exists, capacity <= 0)
                        }
                        break;

                    case "2": // Register Attendee
                        System.out.print("Enter attendee name: ");
                        String attendeeNameReg = scanner.nextLine();
                        System.out.print("Enter session name: ");
                        String sessionNameReg = scanner.nextLine();
                        manager.registerAttendeeToSession(attendeeNameReg, sessionNameReg);
                        break;

                    case "3": // Cancel Registration
                        System.out.print("Enter attendee name: ");
                        String attendeeNameCancel = scanner.nextLine();
                        System.out.print("Enter session name: ");
                        String sessionNameCancel = scanner.nextLine();
                        manager.cancelAttendeeRegistration(attendeeNameCancel, sessionNameCancel);
                        break;

                    case "4": // View Session Details
                        System.out.print("Enter session name: ");
                        String sessionNameView = scanner.nextLine();
                        manager.displaySessionDetails(sessionNameView);
                        break;

                    case "5": // View All Sessions
                        manager.displayAllSessions();
                        break;

                    case "6": // Exit
                        running = false;
                        System.out.println("Exiting system."); // System.out for exit message
                        break;

                    default:
                        System.err.println("Invalid choice. Please enter a number between 1 and 6."); // System.err for invalid menu choice
                }
                System.out.println(); // Add a newline for readability
            }
        } catch (Exception e) {
            // Catch any unexpected exceptions during the main loop execution
            System.err.println("An unexpected system error occurred: " + e.getMessage()); // System.err for unexpected errors
            e.printStackTrace(System.err); // Print stack trace to System.err
        } finally {
            // Ensure scanner is closed
            scanner.close();
        }
    }

    // Helper method to print the menu
    private static void printMenu() {
        System.out.println("Menu:"); // System.out for menu
        System.out.println("1. Add Session");
        System.out.println("2. Register Attendee");
        System.out.println("3. Cancel Registration");
        System.out.println("4. View Session Details");
        System.out.println("5. View All Sessions");
        System.out.println("6. Exit");
    }
}
