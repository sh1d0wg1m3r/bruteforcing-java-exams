/*
 * Exam Question #1078
 * Generated on: 2025-05-12 17:21:47
 * Generated by: Account 1
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Logistics Hub Package Processing System
 * 
 * **Scenario:**
 * 
 * You are tasked with developing a simple software system for a small logistics hub. The system needs to manage packages as they arrive, are processed, and then tracked. Packages arrive and are placed in a waiting queue. A worker can then process the next package from the queue. Once processed, the package details are moved to a tracking list. The system should allow users to add new packages, process the next waiting package, view all processed packages, and exit.
 * 
 * **Requirements:**
 * 
 * Implement a Java program that simulates this system. Your solution must adhere to the following:
 * 
 * 1.  **Data Structures:**
 *     *   Use a `java.util.Queue` to hold packages waiting to be processed.
 *     *   Use a `java.util.ArrayList` to store packages that have been processed.
 *     *   Declare the variable for the processed packages using the `java.util.List` interface type.
 * 2.  **User Interaction:**
 *     *   Use `java.util.Scanner` to get user input (menu choices and package details).
 *     *   Present a menu with options:
 *         1.  Add New Package
 *         2.  Process Next Package
 *         3.  View Processed Packages
 *         4.  Exit
 * 3.  **Control Flow:**
 *     *   Use a `switch` statement to handle the user's menu selection.
 *     *   The program should loop, presenting the menu until the user chooses to exit.
 * 4.  **Output:**
 *     *   Use `System.out` for displaying the menu, prompts, successful operation messages, and processed package details.
 *     *   Use `System.err` for displaying error messages (e.g., invalid input, attempting to process from an empty queue).
 * 5.  **Error Handling:**
 *     *   Implement class-wide exception handling using `try-catch` blocks to gracefully handle unexpected errors during the program's execution loop.
 *     *   Handle specific cases like trying to process a package when the queue is empty or invalid menu input.
 * 6.  **Object-Oriented Design:**
 *     *   Create a `Package` class with private fields (e.g., `packageId`, `description`, `status`) and public getter methods. Include a constructor.
 *     *   The main system logic should reside in a separate class (e.g., `PackageProcessingSystem`) that manages the queue and list.
 *     *   Apply proper encapsulation.
 * 7.  **Best Practices:**
 *     *   Use meaningful variable and method names.
 *     *   Include appropriate comments and documentation (basic Javadoc or inline comments where necessary).
 *     *   Implement basic input validation (e.g., check if package ID or description is empty).
 * 
 * **Expected Output:**
 * 
 * The program should display a menu, accept user input, perform the requested action, and display appropriate messages.
 * 
 * *   Adding a package should prompt for ID and description and confirm addition.
 * *   Processing a package should indicate which package is being processed and moved to the tracking list, or report an error if the queue is empty.
 * *   Viewing processed packages should list all packages currently in the tracking list, or indicate if the list is empty.
 * *   Invalid menu input should result in an error message via `System.err`.
 * *   The program should exit cleanly when option 4 is selected.
 * 
 * **Example Interaction Flow:**
 * 
 * ```
 * --- Logistics Hub System Menu ---
 * 1. Add New Package
 * 2. Process Next Package
 * 3. View Processed Packages
 * 4. Exit
 * Enter your choice: 1
 * Enter Package ID: PKG001
 * Enter Description: Small Box
 * Package PKG001 added to the queue.
 * 
 * --- Logistics Hub System Menu ---
 * 1. Add New Package
 * 2. Process Next Package
 * 3. View Processed Packages
 * 4. Exit
 * Enter your choice: 1
 * Enter Package ID: PKG002
 * Enter Description: Medium Envelope
 * Package PKG002 added to the queue.
 * 
 * --- Logistics Hub System Menu ---
 * 1. Add New Package
 * 2. Process Next Package
 * 3. View Processed Packages
 * 4. Exit
 * Enter your choice: 2
 * Processing package: PKG001 - Small Box
 * Package PKG001 processed and moved to tracking.
 * 
 * --- Logistics Hub System Menu ---
 * 1. Add New Package
 * 2. Process Next Package
 * 3. View Processed Packages
 * 4. Exit
 * Enter your choice: 3
 * --- Processed Packages ---
 * ID: PKG001, Description: Small Box, Status: Processed
 * 
 * --- Logistics Hub System Menu ---
 * 1. Add New Package
 * 2. Process Next Package
 * 3. View Processed Packages
 * 4. Exit
 * Enter your choice: 5
 * Invalid choice. Please enter a number between 1 and 4.
 * 
 * --- Logistics Hub System Menu ---
 * 1. Add New Package
 * 2. Process Next Package
 * 3. View Processed Packages
 * 4. Exit
 * Enter your choice: 4
 * Exiting system.
 * ```
 * 
 * Your solution should provide the complete Java code for this system.
 *
 * EXPLANATION:
 * This solution implements a simple Logistics Hub Package Processing System demonstrating the required Java concepts and best practices.
 * 
 * 1.  **Package Class:**
 *     *   The `Package` class serves as a simple data model using **encapsulation**.
 *     *   It has `private` fields (`packageId`, `description`, `status`) and `public` getter methods to access them. A `setStatus` method is provided to update the status.
 *     *   A constructor initializes a new package with a default "Waiting" status.
 *     *   An overridden `toString()` method provides a convenient way to print package details.
 * 
 * 2.  **PackageProcessingSystem Class:**
 *     *   This is the main class managing the system's state and logic.
 *     *   It uses a `Queue<Package>` (`processingQueue`) implemented by `LinkedList` to manage packages waiting for processing. The `Queue` interface methods (`offer`, `poll`) are used appropriately. `offer` is used for adding to avoid exceptions on capacity limits (though `LinkedList` doesn't have a fixed capacity), and `poll` is used for retrieving/removing to handle the empty case gracefully (returns `null`).
 *     *   It uses a `List<Package>` (`processedPackages`) implemented by `ArrayList` to store processed packages. The variable is declared using the `List` **interface**, demonstrating programming to interfaces. `ArrayList` methods (`add`, `isEmpty`, iteration) are used.
 *     *   A `Scanner` is used for **user input**.
 *     *   The `run()` method contains the main application loop, controlled by the `running` boolean flag.
 * 
 * 3.  **Control Flow and User Interaction:**
 *     *   The `displayMenu()` method shows the user options.
 *     *   The `run()` method reads the user's choice using `scanner.nextInt()`.
 *     *   A **`switch` statement** handles the different menu options (1-4).
 *     *   The loop continues until the user enters `4`, which sets `running` to `false`.
 *     *   A `scanner.nextLine()` call is strategically placed after `scanner.nextInt()` to consume the leftover newline character, preventing issues with subsequent `scanner.nextLine()` calls in `addPackage()`.
 * 
 * 4.  **Functionality Methods:**
 *     *   `addPackage()`: Prompts for package details, performs basic **input validation** (checks if ID/description are empty), creates a `Package` object, and adds it to the `processingQueue` using `offer()`. Success messages are printed to **`System.out`**. Errors for empty input are printed to **`System.err`**.
 *     *   `processNextPackage()`: Retrieves the next package from the `processingQueue` using `poll()`. It checks if `poll()` returned `null` (meaning the queue was empty). If a package is retrieved, its status is updated, and it's added to the `processedPackages` list. Success messages are printed to **`System.out`**. The error for an empty queue is printed to **`System.err`**.
 *     *   `viewProcessedPackages()`: Iterates through the `processedPackages` list and prints each package's details using its `toString()` method. It checks if the list is empty and prints an appropriate message to **`System.out`**.
 * 
 * 5.  **Error Handling:**
 *     *   A **`try-catch` block** is wrapped around the main `while(running)` loop in the `run()` method. This provides **class-wide exception handling**, catching any unexpected `Exception` that might occur during the program's execution. It prints an error message and the stack trace to **`System.err`**.
 *     *   A specific `try-catch(InputMismatchException e)` block is nested within the main loop to handle cases where the user enters non-integer input for the menu choice. It prints an error to **`System.err`**, consumes the invalid input using `scanner.next()`, and continues the loop.
 *     *   Specific error messages for empty queue/list and invalid menu options are handled within the respective methods and the `switch` statement's `default` case, using **`System.err`** for errors and **`System.out`** for informational messages.
 *     *   Basic input validation for package details is included in `addPackage()`.
 * 
 * 6.  **Best Practices:**
 *     *   Meaningful names (`processingQueue`, `processedPackages`, `addPackage`, `processNextPackage`, etc.) are used.
 *     *   Comments explain the purpose of classes, methods, and key code sections.
 *     *   The code is structured logically with separate methods for different actions.
 *     *   The `Scanner` is closed in a `finally` block to release system resources.
 * 
 * This solution effectively integrates all required components into a functional system, demonstrating understanding of data structures, control flow, user interaction, object-oriented principles, and robust error handling in Java.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.InputMismatchException;

// Represents a package in the system
class Package {
    private String packageId;
    private String description;
    private String status; // e.g., "Waiting", "Processed"

    /**
     * Constructs a new Package.
     * @param packageId The unique ID of the package.
     * @param description A description of the package.
     */
    public Package(String packageId, String description) {
        this.packageId = packageId;
        this.description = description;
        this.status = "Waiting"; // Default status
    }

    // --- Getters ---
    public String getPackageId() {
        return packageId;
    }

    public String getDescription() {
        return description;
    }

    public String getStatus() {
        return status;
    }

    // --- Setters (for status update) ---
    public void setStatus(String status) {
        this.status = status;
    }

    @Override
    public String toString() {
        return "ID: " + packageId + ", Description: " + description + ", Status: " + status;
    }
}

// Main class for the Package Processing System
public class PackageProcessingSystem {

    private Queue<Package> processingQueue; // Packages waiting to be processed
    private List<Package> processedPackages; // Packages that have been processed
    private Scanner scanner;
    private boolean running;

    /**
     * Constructs a new PackageProcessingSystem.
     */
    public PackageProcessingSystem() {
        // Using LinkedList as a Queue implementation
        this.processingQueue = new LinkedList<>();
        // Using ArrayList to store processed packages, programming to the List interface
        this.processedPackages = new ArrayList<>();
        this.scanner = new Scanner(System.in);
        this.running = true;
    }

    /**
     * Displays the main menu options to the user.
     */
    private void displayMenu() {
        System.out.println("\n--- Logistics Hub System Menu ---");
        System.out.println("1. Add New Package");
        System.out.println("2. Process Next Package");
        System.out.println("3. View Processed Packages");
        System.out.println("4. Exit");
        System.out.print("Enter your choice: ");
    }

    /**
     * Adds a new package to the processing queue based on user input.
     */
    private void addPackage() {
        System.out.print("Enter Package ID: ");
        String packageId = scanner.nextLine().trim(); // Read entire line and trim whitespace

        if (packageId.isEmpty()) {
            System.err.println("Error: Package ID cannot be empty.");
            return;
        }

        System.out.print("Enter Description: ");
        String description = scanner.nextLine().trim();

        if (description.isEmpty()) {
            System.err.println("Error: Description cannot be empty.");
            return;
        }

        Package newPackage = new Package(packageId, description);
        processingQueue.offer(newPackage); // offer() is preferred over add() in queues as it doesn't throw exception on failure
        System.out.println("Package " + packageId + " added to the queue.");
    }

    /**
     * Processes the next package from the queue, updates its status,
     * and moves it to the processed packages list.
     */
    private void processNextPackage() {
        Package packageToProcess = processingQueue.poll(); // poll() retrieves and removes the head of the queue, returns null if empty

        if (packageToProcess == null) {
            System.err.println("Error: No packages in the queue to process.");
        } else {
            System.out.println("Processing package: " + packageToProcess.getPackageId() + " - " + packageToProcess.getDescription());
            packageToProcess.setStatus("Processed"); // Update status
            processedPackages.add(packageToProcess); // Add to the processed list
            System.out.println("Package " + packageToProcess.getPackageId() + " processed and moved to tracking.");
        }
    }

    /**
     * Displays details of all packages in the processed packages list.
     */
    private void viewProcessedPackages() {
        if (processedPackages.isEmpty()) {
            System.out.println("No packages have been processed yet.");
        } else {
            System.out.println("--- Processed Packages ---");
            for (Package pkg : processedPackages) {
                System.out.println(pkg); // Uses the Package.toString() method
            }
        }
    }

    /**
     * Starts the main application loop.
     * Includes class-wide exception handling.
     */
    public void run() {
        // Class-wide try-catch block to handle unexpected errors during execution
        try {
            while (running) {
                displayMenu();
                int choice = -1; // Default invalid choice

                // Handle potential InputMismatchException for non-integer input
                try {
                    choice = scanner.nextInt();
                } catch (InputMismatchException e) {
                    System.err.println("Invalid input. Please enter a number.");
                    scanner.next(); // Consume the invalid input to prevent infinite loop
                    continue; // Skip to the next iteration of the while loop
                } finally {
                    // Consume the newline character left by nextInt()
                    // This is crucial before the next nextLine() call
                    scanner.nextLine();
                }

                // Use a switch statement for menu navigation
                switch (choice) {
                    case 1:
                        addPackage();
                        break;
                    case 2:
                        processNextPackage();
                        break;
                    case 3:
                        viewProcessedPackages();
                        break;
                    case 4:
                        running = false; // Set running flag to false to exit loop
                        System.out.println("Exiting system.");
                        break;
                    default:
                        // Handle choices outside the valid range
                        System.err.println("Invalid choice. Please enter a number between 1 and 4.");
                        break;
                }
            }
        } catch (Exception e) {
            // Catch any other unexpected exceptions during the main loop
            System.err.println("An unexpected error occurred: " + e.getMessage());
            e.printStackTrace(System.err); // Print stack trace to System.err for debugging
        } finally {
            // Ensure the scanner is closed when the application exits
            scanner.close();
            System.out.println("System shut down.");
        }
    }

    /**
     * Main method to start the application.
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        PackageProcessingSystem system = new PackageProcessingSystem();
        system.run(); // Start the system
    }
}
