/*
 * Exam Question #111
 * Generated on: 2025-05-11 22:16:00
 * Generated by: Account 5
 * 
 * QUESTION:
 * **Java Programming Exam Task: Advanced Manufacturing Order Processing System**
 * 
 * **Problem Description:**
 * 
 * You are tasked with developing a simplified Manufacturing Order Processing System. The system should manage incoming production orders, process them sequentially, and keep track of completed orders. The system will interact with a user via the console, allowing them to add new orders, process the next pending order, view the status of orders, and exit.
 * 
 * Your solution must demonstrate a strong understanding of core Java collections, control flow, input/output, and exception handling.
 * 
 * **System Requirements:**
 * 
 * 1.  **Order Representation:** Create a class `ManufacturingOrder` to represent an order. It should contain:
 *     *   A unique integer `orderId`.
 *     *   A `String` `productName`.
 *     *   An integer `quantity`.
 *     *   An enumeration `OrderStatus` with states like `PENDING`, `PROCESSING`, `COMPLETED`.
 *     *   Appropriate constructors, getters, and setters following encapsulation principles.
 *     *   A method `toString()` for easy printing of order details.
 * 
 * 2.  **Processing System:** Create a class `OrderProcessingSystem` that manages the orders. It must contain:
 *     *   A `java.util.Queue<ManufacturingOrder>` to hold orders that are waiting to be processed (`pendingOrders`). Orders should be processed in the order they were added (FIFO).
 *     *   A `java.util.List<ManufacturingOrder>` (specifically using `java.util.ArrayList` as the implementation) to store orders that have been completed (`completedOrders`).
 *     *   Methods to:
 *         *   `addOrder(String productName, int quantity)`: Creates a new `ManufacturingOrder` with a unique ID (you can use a simple counter), sets its status to `PENDING`, and adds it to the `pendingOrders` queue. Must include input validation for quantity (must be positive).
 *         *   `processNextOrder()`: Removes the next order from the `pendingOrders` queue, changes its status to `COMPLETED`, and adds it to the `completedOrders` list. If the queue is empty, it should report an error.
 *         *   `viewPendingOrders()`: Prints details of all orders currently in the `pendingOrders` queue.
 *         *   `viewCompletedOrders()`: Prints details of all orders in the `completedOrders` list.
 *         *   `getSystemStatus()`: Prints the number of pending orders and the number of completed orders.
 * 
 * 3.  **User Interface:** Create a main class (e.g., `ManufacturingApp`) with a `main` method that provides a text-based menu to the user. The menu should offer the following options:
 *     *   Add New Order
 *     *   Process Next Order
 *     *   View Pending Orders
 *     *   View Completed Orders
 *     *   View System Status
 *     *   Exit
 * 
 * 4.  **Technical Requirements:** Your solution must explicitly use and demonstrate the functionality of ALL the following Java components:
 *     *   `java.util.Queue` (as the type for `pendingOrders`)
 *     *   `java.util.ArrayList` (as the implementation for `completedOrders`)
 *     *   `java.util.List` (as the declared type for `completedOrders`)
 *     *   `java.util.Scanner` (for reading user input)
 *     *   `switch` statement (for handling menu choices)
 *     *   `System.err` (for printing error messages, e.g., invalid input, queue empty)
 *     *   `System.out` (for printing menu, prompts, order details, status)
 *     *   Class-wide exception handling using `try-catch` blocks. This means your main application logic (the loop handling user input and actions) should be robust against unexpected errors.
 * 
 * 5.  **Best Practices:** Adhere to good programming practices:
 *     *   Use private fields and public methods for encapsulation.
 *     *   Use meaningful variable and method names.
 *     *   Include comments and basic documentation (e.g., method descriptions).
 *     *   Implement input validation (e.g., for quantity, menu choices).
 *     *   Handle potential errors gracefully using `System.err` and appropriate logic.
 * 
 * **Expected Output:**
 * 
 * The program should display a menu, prompt the user for input, and perform actions based on the input.
 * - Adding an order should confirm the addition.
 * - Processing an order should confirm which order was processed or report if no orders are pending.
 * - Viewing orders/status should list the relevant information clearly.
 * - Invalid input (menu choice, quantity) should result in an error message printed to `System.err`.
 * - Any unhandled exception during the main execution loop should be caught and reported.
 * 
 * **Example Interaction Snippet:**
 * 
 * ```
 * Manufacturing Order Processing System Menu:
 * 1. Add New Order
 * 2. Process Next Order
 * 3. View Pending Orders
 * 4. View Completed Orders
 * 5. View System Status
 * 6. Exit
 * Enter your choice: 1
 * Enter Product Name: Widget
 * Enter Quantity: 100
 * Order added: Order ID: 1, Product: Widget, Quantity: 100, Status: PENDING
 * 
 * Manufacturing Order Processing System Menu:
 * ...
 * Enter your choice: 2
 * Processing next order...
 * Order processed: Order ID: 1, Product: Widget, Quantity: 100, Status: COMPLETED
 * 
 * Manufacturing Order Processing System Menu:
 * ...
 * Enter your choice: 2
 * No pending orders to process.
 * 
 * Manufacturing Order Processing System Menu:
 * ...
 * Enter your choice: 7
 * Invalid choice. Please enter a number between 1 and 6.
 * 
 * Manufacturing Order Processing System Menu:
 * ...
 * Enter your choice: 5
 * System Status:
 * Pending Orders: 0
 * Completed Orders: 1
 * ```
 * 
 * Implement the Java code for this system.
 *
 * EXPLANATION:
 * This solution implements a simplified manufacturing order processing system demonstrating the required Java concepts.
 * 
 * 1.  **`ManufacturingOrder` Class:**
 *     *   Represents a single order with `orderId`, `productName`, `quantity`, and `status`.
 *     *   Uses an `enum` `OrderStatus` for clear state representation (`PENDING`, `COMPLETED`).
 *     *   Follows encapsulation with private fields and public getters/setters.
 *     *   Provides a helpful `toString()` method for printing.
 * 
 * 2.  **`OrderProcessingSystem` Class:**
 *     *   **`Queue<ManufacturingOrder> pendingOrders`**: Declared as a `Queue` interface type and instantiated with `LinkedList`. This correctly uses `Queue` and leverages `LinkedList`'s implementation which is suitable for FIFO operations (`offer` to add, `poll` to remove from head).
 *     *   **`List<ManufacturingOrder> completedOrders`**: Declared as a `List` interface type and instantiated with `ArrayList`. This correctly uses `List` and `ArrayList` for storing completed orders, where order of completion is maintained and random access isn't strictly needed but `ArrayList` is a common and efficient choice for a growing list.
 *     *   **`addOrder` Method**: Creates a new `ManufacturingOrder`, assigns a unique ID using a simple counter (`nextOrderId++`), sets status to `PENDING`, and adds it to the `pendingOrders` queue using `offer()`. Includes input validation to ensure `quantity` is positive, throwing `IllegalArgumentException` if not.
 *     *   **`processNextOrder` Method**: Uses `poll()` to retrieve and remove the next order from the `pendingOrders` queue. If `poll()` returns `null` (queue is empty), it prints an error to `System.err`. Otherwise, it updates the order's status to `COMPLETED` and adds it to the `completedOrders` list.
 *     *   **`viewPendingOrders` and `viewCompletedOrders` Methods**: Iterate through the respective collections (`Queue` and `List`) and print the details of each order using the `toString()` method. `viewPendingOrders` iterates without removing elements.
 *     *   **`getSystemStatus` Method**: Prints the current size of both the pending queue and the completed list using `.size()`.
 * 
 * 3.  **`ManufacturingApp` Class (Main Application):**
 *     *   **`Scanner scanner = new Scanner(System.in)`**: Creates a `Scanner` object to read input from `System.in`.
 *     *   **`OrderProcessingSystem system = new OrderProcessingSystem()`**: Instantiates the processing system.
 *     *   **`while (running)` loop**: The main application loop that continues until the user chooses to exit.
 *     *   **Input Validation**: Checks if the input for the menu choice and quantity is an integer using `hasNextInt()`. If not, it prints an error to `System.err` and consumes the invalid input using `scanner.next()` or `scanner.nextLine()` to prevent an infinite loop.
 *     *   **`switch (choice)` statement**: Handles the different menu options based on the user's integer input. This effectively controls the program flow based on discrete choices.
 *     *   **`System.out`**: Used for displaying the menu, prompts, confirmation messages, order details, and system status.
 *     *   **`System.err`**: Used specifically for printing error messages, such as invalid input warnings or reporting that there are no pending orders to process. This differentiates normal output from error information.
 *     *   **Class-wide `try-catch` Block**: The entire `while` loop that drives the application is wrapped in a `try-catch(Exception e)` block. This provides a robust layer of exception handling for the main execution flow. If any unexpected `Exception` occurs during the user interaction or processing logic (other than those handled specifically, like `IllegalArgumentException` in `addOrder`), it will be caught here. An error message is printed to `System.err`, and the stack trace is also printed to `System.err` for debugging purposes.
 *     *   **`finally` Block**: Ensures that the `scanner.close()` method is called regardless of whether an exception occurred or the loop finished normally. This is crucial for releasing system resources.
 * 
 * This solution effectively integrates all the required components (`Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.err`, `System.out`, `try-catch`) into a functional, albeit simplified, real-world simulation, while adhering to best practices like encapsulation, validation, and error handling.
 */

import java.util.Queue;
import java.util.LinkedList; // Common implementation for Queue
import java.util.List;
import java.util.ArrayList;
import java.util.Scanner;

// Enum for Order Status
enum OrderStatus {
    PENDING,
    PROCESSING, // Could be used if simulating longer process, but not strictly required by prompt
    COMPLETED
}

// Represents a Manufacturing Order
class ManufacturingOrder {
    private int orderId;
    private String productName;
    private int quantity;
    private OrderStatus status;

    // Constructor
    public ManufacturingOrder(int orderId, String productName, int quantity) {
        this.orderId = orderId;
        this.productName = productName;
        this.quantity = quantity;
        this.status = OrderStatus.PENDING; // Default status
    }

    // Getters
    public int getOrderId() {
        return orderId;
    }

    public String getProductName() {
        return productName;
    }

    public int getQuantity() {
        return quantity;
    }

    public OrderStatus getStatus() {
        return status;
    }

    // Setter for status (used by processing system)
    public void setStatus(OrderStatus status) {
        this.status = status;
    }

    // toString method for easy printing
    @Override
    public String toString() {
        return "Order ID: " + orderId +
               ", Product: " + productName +
               ", Quantity: " + quantity +
               ", Status: " + status;
    }
}

// Manages the order processing flow
class OrderProcessingSystem {
    // Use Queue for pending orders (FIFO)
    private Queue<ManufacturingOrder> pendingOrders;
    // Use List (specifically ArrayList) for completed orders
    private List<ManufacturingOrder> completedOrders;
    private int nextOrderId; // Simple counter for unique IDs

    // Constructor
    public OrderProcessingSystem() {
        this.pendingOrders = new LinkedList<>(); // LinkedList implements Queue
        this.completedOrders = new ArrayList<>(); // ArrayList implements List
        this.nextOrderId = 1; // Start order IDs from 1
    }

    /**
     * Adds a new order to the pending queue.
     * @param productName The name of the product.
     * @param quantity The quantity to manufacture.
     * @throws IllegalArgumentException if quantity is not positive.
     */
    public void addOrder(String productName, int quantity) {
        if (quantity <= 0) {
            throw new IllegalArgumentException("Quantity must be a positive number.");
        }
        ManufacturingOrder newOrder = new ManufacturingOrder(nextOrderId++, productName, quantity);
        pendingOrders.offer(newOrder); // offer is preferred over add for queues (returns false instead of throwing exception on failure)
        System.out.println("Order added: " + newOrder);
    }

    /**
     * Processes the next order in the pending queue.
     * Moves the order from pending to completed list.
     */
    public void processNextOrder() {
        // poll() retrieves and removes the head of the queue, returns null if queue is empty
        ManufacturingOrder orderToProcess = pendingOrders.poll();

        if (orderToProcess != null) {
            orderToProcess.setStatus(OrderStatus.COMPLETED);
            completedOrders.add(orderToProcess);
            System.out.println("Order processed: " + orderToProcess);
        } else {
            System.err.println("No pending orders to process.");
        }
    }

    /**
     * Prints details of all pending orders.
     */
    public void viewPendingOrders() {
        System.out.println("\n--- Pending Orders ---");
        if (pendingOrders.isEmpty()) {
            System.out.println("No pending orders.");
        } else {
            // Iterate through the queue without removing elements
            pendingOrders.forEach(System.out::println);
        }
        System.out.println("----------------------");
    }

    /**
     * Prints details of all completed orders.
     */
    public void viewCompletedOrders() {
        System.out.println("\n--- Completed Orders ---");
        if (completedOrders.isEmpty()) {
            System.out.println("No completed orders.");
        } else {
            // Iterate through the list
            completedOrders.forEach(System.out::println);
        }
        System.out.println("------------------------");
    }

    /**
     * Prints the current status of the system (counts).
     */
    public void getSystemStatus() {
        System.out.println("\n--- System Status ---");
        System.out.println("Pending Orders: " + pendingOrders.size());
        System.out.println("Completed Orders: " + completedOrders.size());
        System.out.println("---------------------");
    }
}

// Main application class
public class ManufacturingApp {

    private static void displayMenu() {
        System.out.println("\nManufacturing Order Processing System Menu:");
        System.out.println("1. Add New Order");
        System.out.println("2. Process Next Order");
        System.out.println("3. View Pending Orders");
        System.out.println("4. View Completed Orders");
        System.out.println("5. View System Status");
        System.out.println("6. Exit");
        System.out.print("Enter your choice: ");
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        OrderProcessingSystem system = new OrderProcessingSystem();
        boolean running = true;

        // Class-wide exception handling for the main application loop
        try {
            while (running) {
                displayMenu();

                int choice = -1;
                // Input validation for menu choice
                if (scanner.hasNextInt()) {
                    choice = scanner.nextInt();
                } else {
                    System.err.println("Invalid input. Please enter a number.");
                    scanner.next(); // Consume the invalid input
                    continue; // Skip to the next iteration
                }
                scanner.nextLine(); // Consume the newline character left by nextInt()

                // Use switch statement for menu handling
                switch (choice) {
                    case 1: // Add New Order
                        System.out.print("Enter Product Name: ");
                        String productName = scanner.nextLine();
                        System.out.print("Enter Quantity: ");
                        int quantity = -1;
                        if (scanner.hasNextInt()) {
                            quantity = scanner.nextInt();
                            scanner.nextLine(); // Consume newline
                            try {
                                system.addOrder(productName, quantity);
                            } catch (IllegalArgumentException e) {
                                System.err.println("Error adding order: " + e.getMessage());
                            }
                        } else {
                            System.err.println("Invalid quantity. Please enter an integer.");
                            scanner.next(); // Consume invalid input
                            scanner.nextLine(); // Consume rest of line
                        }
                        break;

                    case 2: // Process Next Order
                        system.processNextOrder();
                        break;

                    case 3: // View Pending Orders
                        system.viewPendingOrders();
                        break;

                    case 4: // View Completed Orders
                        system.viewCompletedOrders();
                        break;

                    case 5: // View System Status
                        system.getSystemStatus();
                        break;

                    case 6: // Exit
                        System.out.println("Exiting Manufacturing Order Processing System. Goodbye!");
                        running = false;
                        break;

                    default: // Invalid choice
                        System.err.println("Invalid choice. Please enter a number between 1 and 6.");
                        break;
                }
            }
        } catch (Exception e) {
            // Catch any unexpected exceptions during execution
            System.err.println("\nAn unexpected system error occurred: " + e.getMessage());
            e.printStackTrace(System.err); // Print stack trace to error stream
        } finally {
            // Ensure scanner is closed
            scanner.close();
            System.out.println("Scanner closed.");
        }
    }
}
