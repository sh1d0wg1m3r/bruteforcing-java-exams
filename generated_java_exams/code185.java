/*
 * Exam Question #185
 * Generated on: 2025-05-11 22:27:49
 * Generated by: Account 1
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Automated Support Ticket System
 * 
 * **Scenario:**
 * 
 * You are tasked with building a simple command-line application to simulate an automated support ticket system. The system should allow users to submit new support tickets, process the oldest pending ticket, view the list of pending tickets, and view the list of completed tickets.
 * 
 * **Requirements:**
 * 
 * 1.  **Ticket Representation:** Create a class named `Ticket` to represent a support ticket. It should have private fields for a unique `ticketId` (integer), `description` (String), and `status` (String, e.g., "Pending", "Completed"). Include a constructor, public getter methods for all fields, and a public method to set the status. Implement a `toString()` method for easy printing.
 * 2.  **System Class:** Create a class named `SupportTicketSystem` that manages the tickets.
 *     *   It must use a `java.util.Queue<Ticket>` to store tickets that are waiting to be processed (pending tickets).
 *     *   It must use a `java.util.List<Ticket>` (specifically instantiated as a `java.util.ArrayList<Ticket>`) to store tickets that have been processed (completed tickets).
 *     *   Include a mechanism (e.g., a private counter) to generate unique ticket IDs sequentially.
 *     *   Implement the following public methods:
 *         *   `addTicket(String description)`: Creates a new `Ticket` with the next available ID and "Pending" status, and adds it to the pending queue. Validate that the description is not empty.
 *         *   `processNextTicket()`: Removes the ticket at the front of the pending queue, sets its status to "Completed", and adds it to the completed list. Handle the case where there are no pending tickets.
 *         *   `viewPendingTickets()`: Prints the details of all tickets currently in the pending queue.
 *         *   `viewCompletedTickets()`: Prints the details of all tickets in the completed list.
 *     *   Implement a `run()` method that contains the main application loop. This method should:
 *         *   Use a `java.util.Scanner` to read user input from the console.
 *         *   Display a menu with options: 1. Add New Ticket, 2. Process Next Ticket, 3. View Pending Tickets, 4. View Completed Tickets, 0. Exit.
 *         *   Use a `switch` statement to handle the user's menu choice, calling the appropriate system method.
 *         *   Handle invalid menu choices.
 *         *   Use `System.out` for displaying the menu, prompts, ticket details, and success messages.
 *         *   Use `System.err` for displaying error messages (e.g., invalid input, empty description, attempting to process when queue is empty).
 *         *   Implement class-wide exception handling using `try-catch` blocks within the `run()` method to handle potential runtime errors, particularly input errors like `InputMismatchException`.
 *         *   The loop should continue until the user chooses to exit (option 0).
 * 3.  **Main Method:** Include a `main` method (either in `SupportTicketSystem` or a separate class) that creates an instance of `SupportTicketSystem` and calls its `run()` method to start the application.
 * 4.  **Best Practices:** Adhere to Java best practices, including proper encapsulation (private fields, public methods), meaningful variable and method names, appropriate comments (especially Javadoc for public methods), and clean code structure.
 * 
 * **Expected Output:**
 * 
 * The application should run interactively. Users should see a menu, be prompted for input, and receive feedback or error messages based on their actions. Examples:
 * 
 * ```
 * --- Automated Support Ticket System ---
 * 
 * --- Menu ---
 * 1. Add New Ticket
 * 2. Process Next Ticket
 * 3. View Pending Tickets
 * 4. View Completed Tickets
 * 0. Exit
 * ------------
 * Enter your choice: 1
 * Enter ticket description: My printer is not working.
 * Ticket #1 added to the queue.
 * 
 * --- Menu ---
 * ... (menu repeats) ...
 * Enter your choice: 1
 * Enter ticket description: Network connection is slow.
 * Ticket #2 added to the queue.
 * 
 * --- Menu ---
 * ... (menu repeats) ...
 * Enter your choice: 3
 * 
 * --- Pending Tickets ---
 * Ticket{ID=1, Description='My printer is not working.', Status='Pending'}
 * Ticket{ID=2, Description='Network connection is slow.', Status='Pending'}
 * -----------------------
 * 
 * --- Menu ---
 * ... (menu repeats) ...
 * Enter your choice: 2
 * Processed ticket #1: My printer is not working.
 * 
 * --- Menu ---
 * ... (menu repeats) ...
 * Enter your choice: 3
 * 
 * --- Pending Tickets ---
 * Ticket{ID=2, Description='Network connection is slow.', Status='Pending'}
 * -----------------------
 * 
 * --- Menu ---
 * ... (menu repeats) ...
 * Enter your choice: 4
 * 
 * --- Completed Tickets ---
 * Ticket{ID=1, Description='My printer is not working.', Status='Completed'}
 * -------------------------
 * 
 * --- Menu ---
 * ... (menu repeats) ...
 * Enter your choice: abc
 * Invalid input. Please enter a number.
 * (Error message on System.err)
 * 
 * --- Menu ---
 * ... (menu repeats) ...
 * Enter your choice: 5
 * Invalid choice. Please enter a number between 0 and 4.
 * (Error message on System.err)
 * 
 * --- Menu ---
 * ... (menu repeats) ...
 * Enter your choice: 2
 * Processed ticket #2: Network connection is slow.
 * 
 * --- Menu ---
 * ... (menu repeats) ...
 * Enter your choice: 2
 * No pending tickets to process.
 * (Message on System.out)
 * 
 * --- Menu ---
 * ... (menu repeats) ...
 * Enter your choice: 0
 * Exiting system. Goodbye!
 * System terminated.
 * ```
 * 
 * **Time Allotment:** 45-60 minutes
 * 
 * **Evaluation:** Your solution will be evaluated based on correctness, adherence to all requirements (including use of specified components), code quality (encapsulation, naming, comments), error handling robustness, and clean structure.
 *
 * EXPLANATION:
 * This solution implements the Automated Support Ticket System as described in the problem statement, demonstrating the required Java concepts and best practices.
 * 
 * 1.  **`Ticket` Class:** This class serves as a simple Plain Old Java Object (POJO) to hold the data for each ticket: a unique ID, a description, and its status.
 *     *   It uses `private` fields (`ticketId`, `description`, `status`) enforcing encapsulation.
 *     *   Public getter methods (`getTicketId`, `getDescription`, `getStatus`) provide controlled access to the data.
 *     *   A public setter (`setStatus`) is provided to allow the system to update the ticket's state when it's processed.
 *     *   `toString()` is overridden for convenient printing of ticket details.
 * 
 * 2.  **`SupportTicketSystem` Class:** This is the core class managing the ticket workflow.
 *     *   **Collections:**
 *         *   `pendingTickets`: Declared as `Queue<Ticket>` and instantiated as `LinkedList<Ticket>`. A `Queue` is used because tickets should be processed in the order they are received (First-In, First-Out - FIFO), which is a natural fit for a queue data structure. `LinkedList` is a common implementation of the `Queue` interface.
 *         *   `completedTickets`: Declared as `List<Ticket>` and instantiated as `ArrayList<Ticket>`. A `List` (specifically `ArrayList`) is suitable for storing completed tickets as there's no specific order requirement for viewing, and `ArrayList` provides efficient storage and iteration.
 *     *   **ID Generation:** `nextTicketId` is a simple integer counter incremented each time a new ticket is created, ensuring unique sequential IDs.
 *     *   **Methods:**
 *         *   `addTicket()`: Takes a description, validates it, creates a new `Ticket` using the next ID, and adds it to the `pendingTickets` queue using `offer()`. `offer()` is preferred over `add()` for queues as it's designed to handle potential capacity restrictions gracefully (though `LinkedList` doesn't have a fixed capacity).
 *         *   `processNextTicket()`: Uses `poll()` to remove and retrieve the head of the `pendingTickets` queue. `poll()` returns `null` if the queue is empty, which is handled explicitly with a user-friendly message printed to `System.out`. If a ticket is retrieved, its status is updated, and it's added to the `completedTickets` list.
 *         *   `viewPendingTickets()` and `viewCompletedTickets()`: These methods iterate through the respective collections (`pendingTickets` queue and `completedTickets` list) and print the details of each ticket using the `forEach` loop and the `Ticket` class's `toString()` method. They also check if the collections are empty and print appropriate messages.
 *     *   **`run()` Method:** This method contains the main interactive loop.
 *         *   A `Scanner` is used to read input from `System.in`.
 *         *   The `displayMenu()` helper method shows the available options.
 *         *   A `while` loop continues until the user enters `0`.
 *         *   **`switch` Statement:** The user's integer choice is handled by a `switch` statement, directing the flow to the appropriate method calls (`addTicket`, `processNextTicket`, etc.).
 *         *   **Input Validation & Error Handling (`System.err`, `try-catch`):**
 *             *   An inner `try-catch` block specifically targets `InputMismatchException`, which occurs if the user enters non-integer input when the system expects an integer. It prints an error to `System.err` and consumes the invalid input using `scanner.nextLine()` to prevent an infinite loop.
 *             *   The `default` case in the `switch` handles integer inputs that are outside the valid menu range (0-4), printing an error to `System.err`.
 *             *   The `addTicket` method includes a check for empty or null descriptions, printing an error to `System.err`.
 *             *   The `processNextTicket` method checks if the queue is empty before attempting to poll, printing a message to `System.out`.
 *             *   An outer `try-catch` block wraps the entire `while` loop in `run()`. This demonstrates a broader "class-wide" exception handling mechanism, catching any `Exception` that might occur during the execution of the system's main loop, providing a safety net and preventing the program from crashing unexpectedly. An inner `catch (Exception e)` is also included within the loop iteration's `try` block to catch other potential runtime exceptions that might occur within a single command's execution.
 *         *   `System.out` is used for normal interaction, prompts, menu display, and successful operation messages. `System.err` is strictly used for error reporting.
 *         *   A `finally` block ensures the `Scanner` is closed when the `run` method finishes (either by exiting the loop or due to a critical exception).
 * 
 * 3.  **`main` Method:** Located within the `SupportTicketSystem` class, this is the entry point of the application. It simply creates an instance of the system and calls the `run()` method to start the interactive process.
 * 
 * This solution effectively integrates all required components (`Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.err`, `System.out`, `try-catch`) into a cohesive, practical application that simulates a real-world scenario while adhering to fundamental object-oriented principles and error handling best practices.
 */

import java.util.Queue;
import java.util.LinkedList; // LinkedList is a common Queue implementation
import java.util.List;
import java.util.ArrayList;
import java.util.Scanner;
import java.util.InputMismatchException;

// Represents a support ticket
class Ticket {
    private int ticketId;
    private String description;
    private String status; // e.g., "Pending", "Completed"

    /**
     * Constructs a new Ticket.
     * @param ticketId The unique identifier for the ticket.
     * @param description The description of the issue.
     */
    public Ticket(int ticketId, String description) {
        this.ticketId = ticketId;
        this.description = description;
        this.status = "Pending"; // Initial status
    }

    // --- Getters ---
    public int getTicketId() {
        return ticketId;
    }

    public String getDescription() {
        return description;
    }

    public String getStatus() {
        return status;
    }

    /**
     * Sets the status of the ticket.
     * @param status The new status (e.g., "Completed").
     */
    public void setStatus(String status) {
        this.status = status;
    }

    /**
     * Provides a string representation of the Ticket.
     * @return String representation.
     */
    @Override
    public String toString() {
        return "Ticket{" +
               "ID=" + ticketId +
               ", Description='" + description + '\'' +
               ", Status='" + status + '\'' +
               '}';
    }
}

// Manages the collection and processing of support tickets
public class SupportTicketSystem {
    private Queue<Ticket> pendingTickets;
    private List<Ticket> completedTickets;
    private int nextTicketId; // Simple ID generator

    /**
     * Constructs a new SupportTicketSystem, initializing collections and ID counter.
     */
    public SupportTicketSystem() {
        this.pendingTickets = new LinkedList<>(); // LinkedList implements Queue
        this.completedTickets = new ArrayList<>(); // ArrayList implements List
        this.nextTicketId = 1; // Start IDs from 1
    }

    /**
     * Adds a new ticket to the pending queue.
     * @param description The description of the ticket issue.
     */
    public void addTicket(String description) {
        // Input validation for description
        if (description == null || description.trim().isEmpty()) {
            System.err.println("Error: Ticket description cannot be empty.");
            return;
        }
        Ticket newTicket = new Ticket(nextTicketId++, description.trim());
        pendingTickets.offer(newTicket); // offer is preferred over add for queues (handles capacity limits, though LinkedList doesn't have fixed capacity)
        System.out.println("Ticket #" + newTicket.getTicketId() + " added to the queue.");
    }

    /**
     * Processes the next ticket in the pending queue.
     * Moves the ticket from pending to completed list.
     */
    public void processNextTicket() {
        Ticket ticketToProcess = pendingTickets.poll(); // poll removes and returns the head, or null if empty
        if (ticketToProcess == null) {
            System.out.println("No pending tickets to process.");
            return;
        }
        ticketToProcess.setStatus("Completed"); // Update status
        completedTickets.add(ticketToProcess); // Add to completed list
        System.out.println("Processed ticket #" + ticketToProcess.getTicketId() + ": " + ticketToProcess.getDescription());
    }

    /**
     * Displays all pending tickets currently in the queue.
     */
    public void viewPendingTickets() {
        System.out.println("\n--- Pending Tickets ---");
        if (pendingTickets.isEmpty()) {
            System.out.println("No tickets currently pending.");
        } else {
            // Iterate through the queue without removing elements
            // Using forEach or an Iterator is suitable
            pendingTickets.forEach(System.out::println);
        }
        System.out.println("-----------------------");
    }

    /**
     * Displays all completed tickets.
     */
    public void viewCompletedTickets() {
        System.out.println("\n--- Completed Tickets ---");
        if (completedTickets.isEmpty()) {
            System.out.println("No tickets have been completed yet.");
        } else {
            // Iterate through the list
            completedTickets.forEach(System.out::println);
        }
        System.out.println("-------------------------");
    }

    /**
     * Runs the main interactive loop for the ticket system.
     * Handles user input, menu display, and delegates actions.
     * Includes exception handling for robustness.
     */
    public void run() {
        Scanner scanner = new Scanner(System.in);
        int choice = -1; // Initialize choice to a non-exit value

        System.out.println("--- Automated Support Ticket System ---");

        // Outer try-catch block for potential unexpected exceptions during the system's operation
        try {
            while (choice != 0) {
                displayMenu();
                System.out.print("Enter your choice: ");

                // Inner try-catch block specifically for handling input errors
                try {
                    choice = scanner.nextInt();
                    scanner.nextLine(); // Consume the newline character left by nextInt()

                    // Switch statement to handle menu options
                    switch (choice) {
                        case 1:
                            System.out.print("Enter ticket description: ");
                            String description = scanner.nextLine();
                            addTicket(description); // Delegate to addTicket method
                            break;
                        case 2:
                            processNextTicket(); // Delegate to processNextTicket method
                            break;
                        case 3:
                            viewPendingTickets(); // Delegate to viewPendingTickets method
                            break;
                        case 4:
                            viewCompletedTickets(); // Delegate to viewCompletedTickets method
                            break;
                        case 0:
                            System.out.println("Exiting system. Goodbye!");
                            break; // Exit the loop
                        default:
                            // Handle invalid integer choices
                            System.err.println("Invalid choice. Please enter a number between 0 and 4.");
                    }
                } catch (InputMismatchException e) {
                    // Handle cases where the user enters non-integer input
                    System.err.println("Invalid input. Please enter a number.");
                    scanner.nextLine(); // Consume the invalid input to prevent an infinite loop
                    choice = -1; // Reset choice to ensure the loop continues
                } catch (Exception e) {
                    // Catch any other unexpected runtime exceptions that might occur within the loop iteration
                    System.err.println("An unexpected error occurred during operation: " + e.getMessage());
                    // e.printStackTrace(System.err); // Optional: print stack trace for debugging
                }
                System.out.println(); // Add a newline for better readability between actions
            }
        } catch (Exception overallException) {
             // This catch block serves as a broader safety net for any exceptions
             // that might occur outside the inner loop logic or escape it.
             System.err.println("A critical system error occurred: " + overallException.getMessage());
             // overallException.printStackTrace(System.err); // Optional: print stack trace
        } finally {
             // Ensure the scanner is closed when the system exits or encounters a critical error
             scanner.close();
             System.out.println("System terminated.");
        }
    }

    /**
     * Displays the main menu options to the console.
     */
    private void displayMenu() {
        System.out.println("\n--- Menu ---");
        System.out.println("1. Add New Ticket");
        System.out.println("2. Process Next Ticket");
        System.out.println("3. View Pending Tickets");
        System.out.println("4. View Completed Tickets");
        System.out.println("0. Exit");
        System.out.println("------------");
    }

    /**
     * Main method to start the Support Ticket System.
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        SupportTicketSystem system = new SupportTicketSystem();
        system.run(); // Start the system's interactive loop
    }
}
