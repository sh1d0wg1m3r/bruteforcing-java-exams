/*
 * Exam Question #136
 * Generated on: 2025-05-11 22:19:59
 * Generated by: Account 3
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Robotics Lab Task Management System
 * 
 * **Problem Description:**
 * 
 * You are tasked with developing a console-based Task Management System for a Robotics Lab. This system will help manage tasks assigned to robots, process them in order, and keep a record of completed work. The system must be interactive, allowing users to add new tasks, process the next task in the queue, view pending tasks, and review the history of completed tasks.
 * 
 * Your solution must be a single Java program (you may include helper classes within the same file if needed) that demonstrates your understanding of fundamental data structures, user input handling, control flow, and exception management in Java.
 * 
 * **Requirements:**
 * 
 * 1.  **Task Representation:** Create a `Task` class to model a task. It should have the following private fields:
 *     *   `taskId`: An integer representing a unique identifier for the task. IDs should be automatically generated sequentially starting from 1 for each new task created during a single program execution.
 *     *   `description`: A String describing the task (e.g., "Calibrate Sensor A", "Clean Area 3").
 *     *   `priority`: An integer representing the task's priority (1 for High, 2 for Medium, 3 for Low).
 *     *   Implement a constructor and public getter methods for these fields. Override the `toString()` method to provide a user-friendly representation of the task.
 * 
 * 2.  **Data Structures:**
 *     *   Use a `java.util.Queue<Task>` to store tasks that are waiting to be processed. Tasks should be processed in First-In, First-Out (FIFO) order. Use an appropriate implementation from the Java Collections Framework (e.g., `LinkedList`).
 *     *   Use a `java.util.List<Task>` to store tasks that have been completed. Use an `java.util.ArrayList` implementation.
 * 
 * 3.  **User Interface & Control:**
 *     *   Implement a command-line interface using `java.util.Scanner` to take input from `System.in`.
 *     *   Present the user with a menu offering the following options:
 *         1.  Add New Task
 *         2.  Process Next Task
 *         3.  View Task Queue
 *         4.  View Completed Tasks History
 *         5.  Exit
 *     *   Use a `switch` statement to handle the user's choice and dispatch to the appropriate logic.
 * 
 * 4.  **Input Validation:**
 *     *   When adding a task, validate that the description is not empty or just whitespace.
 *     *   Validate that the priority entered is one of the allowed values (1, 2, or 3).
 *     *   Handle cases where the user enters non-numeric input when a number (like menu choice or priority) is expected.
 * 
 * 5.  **Output:**
 *     *   Use `System.out.println()` for all normal output, including the menu, prompts, success messages, and displaying task lists/queue contents.
 *     *   Use `System.err.println()` for all error messages, such as invalid input, validation failures, or operational errors (e.g., trying to process a task when the queue is empty in an erroneous state, though the prompt specifies a non-error message for empty queue). Specifically, use `System.err` for invalid menu choices, non-numeric input errors, and task validation errors.
 * 
 * 6.  **Exception Handling:**
 *     *   Implement class-wide exception handling using `try-catch` blocks. This should include:
 *         *   Catching `java.util.InputMismatchException` when reading integer inputs from the `Scanner`.
 *         *   Catching `java.lang.IllegalArgumentException` that might be thrown by the `Task` constructor due to invalid data.
 *         *   Include a general `catch(Exception e)` in the main command processing loop to handle any other unexpected runtime errors gracefully.
 *     *   Report caught exceptions and errors using `System.err`.
 * 
 * 7.  **Best Practices:**
 *     *   Adhere to Java coding conventions (meaningful names, indentation, etc.).
 *     *   Use private fields and public methods for encapsulation.
 *     *   Include brief comments where the code logic might not be immediately obvious.
 *     *   Ensure the `Scanner` resource is closed when the program exits.
 * 
 * **Functionality Details:**
 * 
 * *   **Add New Task:** Prompt for description and priority. If valid, create a `Task` object and add it to the `taskQueue`. Report success or validation errors.
 * *   **Process Next Task:** Attempt to retrieve and remove a task from the head of the `taskQueue`. If the queue is empty, print a message to `System.out` indicating this. If a task is retrieved, print a "Processing..." message, add the task to the `completedTasks` list, and print a "Completed..." message.
 * *   **View Task Queue:** Iterate through and print the details of all tasks currently in the `taskQueue` without removing them. Print a message if the queue is empty.
 * *   **View Completed Tasks History:** Iterate through and print the details of all tasks in the `completedTasks` list. Print a message if the history is empty.
 * *   **Exit:** Terminate the program gracefully.
 * 
 * **Expected Output:**
 * 
 * The program should run interactively in the console. It should display the menu, respond to user input by performing the requested action, and provide appropriate feedback or error messages as specified (`System.out` for normal, `System.err` for errors).
 * 
 * Example Interaction Snippet:
 * 
 * ```
 * Robotics Task Processor Menu:
 * 1. Add New Task
 * 2. Process Next Task
 * 3. View Task Queue
 * 4. View Completed Tasks History
 * 5. Exit
 * Enter your choice: 1
 * --- Add New Task ---
 * Enter task description: Calibrate Arm
 * Enter priority (1=High, 2=Medium, 3=Low): 2
 * Task added to queue: Task ID: 1, Description: "Calibrate Arm", Priority: Medium
 * 
 * Robotics Task Processor Menu:
 * ...
 * Enter your choice: 3
 * --- Current Task Queue ---
 * 1. Task ID: 1, Description: "Calibrate Arm", Priority: Medium
 * 
 * Robotics Task Processor Menu:
 * ...
 * Enter your choice: 2
 * --- Processing Next Task ---
 * Processing task: Calibrate Arm
 * Task completed and moved to history: Task ID: 1, Description: "Calibrate Arm", Priority: Medium
 * 
 * Robotics Task Processor Menu:
 * ...
 * Enter your choice: 4
 * --- Completed Tasks History ---
 * 1. Task ID: 1, Description: "Calibrate Arm", Priority: Medium
 * 
 * Robotics Task Processor Menu:
 * ...
 * Enter your choice: invalid
 * Invalid input. Please enter a number.
 * 
 * Robotics Task Processor Menu:
 * ...
 * Enter your choice: 1
 * --- Add New Task ---
 * Enter task description:
 * Enter priority (1=High, 2=Medium, 3=Low): 1
 * Error adding task: Task description cannot be empty.
 * 
 * Robotics Task Processor Menu:
 * ...
 * Enter your choice: 2
 * --- Processing Next Task ---
 * Task queue is empty. No tasks to process.
 * 
 * Robotics Task Processor Menu:
 * ...
 * Enter your choice: 5
 * Exiting Robotics Task Processor. Goodbye!
 * ```
 * 
 * Your solution should be a single, complete, and runnable Java program file.
 *
 * EXPLANATION:
 * This solution implements the `RoboticsTaskProcessor` system as requested, integrating all specified Java components and following best practices.
 * 
 * 1.  **`Task` Class:** This class serves as a simple Plain Old Java Object (POJO) representing a task. It encapsulates the task's properties (`taskId`, `description`, `priority`) using private fields and provides public getter methods. The `taskId` is managed using a `private static int nextTaskId` counter, ensuring each new task gets a unique, sequential ID within a single program run. The constructor includes basic input validation for `description` (non-empty) and `priority` (within range 1-3), throwing `IllegalArgumentException` if validation fails. The `toString()` method provides a clear string representation of the task, including a user-friendly priority string using a `switch` expression.
 * 
 * 2.  **Data Structures (`Queue` and `List`/`ArrayList`):**
 *     *   `taskQueue`: A `java.util.Queue` is used, specifically implemented by `java.util.LinkedList`. The `Queue` interface is ideal for managing tasks waiting in a line, ensuring they are processed in the order they were added (FIFO). `offer()` is used to add tasks (preferred over `add()` in queues), and `poll()` is used to retrieve and remove the next task.
 *     *   `completedTasks`: A `java.util.List` is used, specifically implemented by `java.util.ArrayList`. The `List` interface is suitable for storing the history of completed tasks, as order of completion is maintained, and random access/iteration is easy. `ArrayList` is a common and efficient general-purpose `List` implementation.
 * 
 * 3.  **User Interface (`Scanner`) and Control (`switch`):**
 *     *   A `java.util.Scanner` is initialized to read input from `System.in`, enabling user interaction via the console.
 *     *   The `run()` method contains the main application loop. Inside this loop, `displayMenu()` prints the options. The user's integer choice is read using `scanner.nextInt()`. A `switch` statement then directs the program flow to the appropriate private method (`addTask`, `processNextTask`, etc.) based on the user's selection. This structure clearly separates the command dispatch logic.
 * 
 * 4.  **Input Validation and Error Handling (`System.err`, `try-catch`, `InputMismatchException`, `IllegalArgumentException`, `Exception`):**
 *     *   Input validation for task description and priority occurs in the `Task` constructor, throwing `IllegalArgumentException`.
 *     *   In the `addTask()` method, a `try-catch` block surrounds the input reading and `Task` creation. It specifically catches `InputMismatchException` if the user types non-numeric input for priority and `IllegalArgumentException` thrown by the `Task` constructor. Error messages are printed to `System.err`.
 *     *   The `run()` method's main loop includes a `try-catch` block that specifically handles `InputMismatchException` when reading the menu choice, preventing the program from crashing on non-numeric input and prompting the user to try again. A general `catch(Exception e)` is also included as requested for class-wide handling of any other unexpected runtime errors that might occur within the loop, printing a generic error message to `System.err`.
 *     *   `System.out` is used exclusively for standard output (menu, prompts, success messages, list/queue displays), while `System.err` is reserved for reporting errors and invalid input, adhering to the requirement and standard practice.
 *     *   The `scanner.nextLine()` calls after reading integers (`scanner.nextInt()`) are crucial to consume the leftover newline character, preventing potential issues with subsequent `scanner.nextLine()` calls that are intended to read entire lines (like the task description).
 * 
 * 5.  **Best Practices:**
 *     *   Encapsulation is achieved by making fields private and providing public getters.
 *     *   Method and variable names (`taskQueue`, `completedTasks`, `addTask`, `processNextTask`, `description`, `priority`, etc.) are meaningful and descriptive.
 *     *   Comments are included to explain the purpose of classes, methods, and less obvious code sections (like Scanner newline handling).
 *     *   The code is structured into logical methods (`addTask`, `processNextTask`, etc.) called from the main `run` loop, improving readability and maintainability.
 *     *   The `Scanner` resource is explicitly closed using `scanner.close()` when the `run` loop finishes (upon selecting the Exit option), releasing system resources.
 * 
 * This solution effectively demonstrates the required Java concepts in a practical, interactive application, showcasing proper data structure usage, robust input handling, control flow with `switch`, and comprehensive exception management using `try-catch` blocks with specific and general exception types, directing output appropriately to `System.out` and `System.err`.
 */

import java.util.Queue;
import java.util.LinkedList;
import java.util.List;
import java.util.ArrayList;
import java.util.Scanner;
import java.util.InputMismatchException;

// Represents a single task for the robotics lab
class Task {
    private static int nextTaskId = 1; // Static counter for unique task IDs
    private int taskId;
    private String description;
    private int priority; // 1: High, 2: Medium, 3: Low

    /**
     * Constructs a new Task.
     * @param description The description of the task.
     * @param priority The priority of the task (1=High, 2=Medium, 3=Low).
     * @throws IllegalArgumentException if description is empty or priority is invalid.
     */
    public Task(String description, int priority) {
        if (description == null || description.trim().isEmpty()) {
            throw new IllegalArgumentException("Task description cannot be empty.");
        }
        if (priority < 1 || priority > 3) {
             throw new IllegalArgumentException("Task priority must be 1 (High), 2 (Medium), or 3 (Low).");
        }
        this.taskId = nextTaskId++; // Assign unique ID and increment counter
        this.description = description.trim();
        this.priority = priority;
    }

    // --- Getters ---
    public int getTaskId() { return taskId; }
    public String getDescription() { return description; }
    public int getPriority() { return priority; }

    /**
     * Provides a string representation of the Task.
     */
    @Override
    public String toString() {
        String priorityStr;
        // Using switch expression (Java 14+) for cleaner code
        priorityStr = switch (priority) {
            case 1 -> "High";
            case 2 -> "Medium";
            case 3 -> "Low";
            default -> "Unknown"; // Should not be reached due to constructor validation
        };
        return "Task ID: " + taskId + ", Description: \"" + description + "\", Priority: " + priorityStr;
    }
}

// Main class for the Robotics Task Processor application
public class RoboticsTaskProcessor {

    // Queue to hold tasks waiting for processing (FIFO)
    private Queue<Task> taskQueue;
    // List to hold tasks that have been completed
    private List<Task> completedTasks; // Using List interface, implemented by ArrayList
    // Scanner for reading user input
    private Scanner scanner;

    /**
     * Constructs a new RoboticsTaskProcessor.
     * Initializes the task queue, completed tasks list, and scanner.
     */
    public RoboticsTaskProcessor() {
        this.taskQueue = new LinkedList<>(); // LinkedList implements Queue
        this.completedTasks = new ArrayList<>(); // ArrayList implements List
        this.scanner = new Scanner(System.in);
    }

    /**
     * Handles adding a new task based on user input.
     * Prompts for description and priority, validates input, creates Task, and adds to queue.
     * Uses System.err for validation errors.
     */
    private void addTask() {
        System.out.println("--- Add New Task ---");
        // Consume the newline character left by previous nextInt/nextDouble if any
        scanner.nextLine();
        System.out.print("Enter task description: ");
        String description = scanner.nextLine();

        System.out.print("Enter priority (1=High, 2=Medium, 3=Low): ");
        int priority = -1; // Default invalid value

        try {
            priority = scanner.nextInt();
            // Consume leftover newline after reading integer
            scanner.nextLine();

            // Attempt to create Task object, which validates description and priority
            Task newTask = new Task(description, priority);
            // Add task to the queue. offer() is preferred over add() in Queue as it doesn't throw exception on capacity issue (though LinkedList is unbounded)
            taskQueue.offer(newTask);
            System.out.println("Task added to queue: " + newTask.getDescription());

        } catch (InputMismatchException e) {
            System.err.println("Invalid input. Priority must be a number.");
            scanner.nextLine(); // Clear the invalid input from the scanner buffer
        } catch (IllegalArgumentException e) {
            // Catch validation errors thrown by the Task constructor
            System.err.println("Error adding task: " + e.getMessage());
        }
    }

    /**
     * Processes the next task from the queue.
     * Removes the head of the queue, adds it to completed tasks. Handles empty queue.
     */
    private void processNextTask() {
        System.out.println("--- Processing Next Task ---");
        // poll() retrieves and removes the head of the queue, returns null if empty
        Task nextTask = taskQueue.poll();

        if (nextTask != null) {
            System.out.println("Processing task: " + nextTask.getDescription());
            // In a real system, processing logic would go here.
            completedTasks.add(nextTask); // Add the completed task to history
            System.out.println("Task completed and moved to history: " + nextTask.getDescription());
        } else {
            // Message for empty queue goes to System.out as it's an expected state, not an error
            System.out.println("Task queue is empty. No tasks to process.");
        }
    }

    /**
     * Displays all tasks currently in the task queue without removing them.
     */
    private void viewTaskQueue() {
        System.out.println("--- Current Task Queue ---");
        if (taskQueue.isEmpty()) {
            System.out.println("The task queue is empty.");
        } else {
            // Iterate over the queue using a for-each loop (doesn't remove elements)
            int index = 1;
            for (Task task : taskQueue) {
                System.out.println(index++ + ". " + task);
            }
        }
    }

    /**
     * Displays all tasks in the completed tasks history list.
     */
    private void viewCompletedTasks() {
        System.out.println("--- Completed Tasks History ---");
        if (completedTasks.isEmpty()) {
            System.out.println("The completed tasks history is empty.");
        } else {
            // Iterate over the list
            int index = 1;
            for (Task task : completedTasks) {
                System.out.println(index++ + ". " + task);
            }
        }
    }

    /**
     * Displays the main menu options to the user.
     */
    private void displayMenu() {
        System.out.println("\nRobotics Task Processor Menu:");
        System.out.println("1. Add New Task");
        System.out.println("2. Process Next Task");
        System.out.println("3. View Task Queue");
        System.out.println("4. View Completed Tasks History");
        System.out.println("5. Exit");
        System.out.print("Enter your choice: ");
    }

    /**
     * The main execution loop of the application.
     * Handles user input, dispatches commands, and includes class-wide exception handling.
     */
    public void run() {
        boolean running = true;
        while (running) {
            displayMenu();
            int choice = -1; // Default invalid choice

            try {
                // Read user's menu choice
                choice = scanner.nextInt();
                // No scanner.nextLine() here immediately after nextInt() because
                // the methods called (addTask, etc.) either don't need it or
                // handle consuming the newline themselves if they mix nextInt/nextLine.
                // addTask specifically handles consuming the newline left by this nextInt.

                // Use a switch statement to handle the chosen action
                switch (choice) {
                    case 1:
                        addTask(); // Add a new task to the queue
                        break;
                    case 2:
                        processNextTask(); // Process the next task in the queue
                        break;
                    case 3:
                        viewTaskQueue(); // Display tasks waiting in the queue
                        break;
                    case 4:
                        viewCompletedTasks(); // Display tasks that have been completed
                        break;
                    case 5:
                        System.out.println("Exiting Robotics Task Processor. Goodbye!");
                        running = false; // Set flag to exit the loop
                        break;
                    default:
                        // Handle invalid menu choices
                        System.err.println("Invalid choice. Please enter a number between 1 and 5.");
                }
            } catch (InputMismatchException e) {
                // Catch error if user enters non-integer for menu choice
                System.err.println("Invalid input. Please enter a number.");
                scanner.nextLine(); // Consume the invalid input to prevent infinite loop
            } catch (Exception e) {
                // Catch any other unexpected runtime exceptions during the main loop execution
                System.err.println("An unexpected error occurred: " + e.getMessage());
                // e.printStackTrace(); // Uncomment for detailed debugging output
            }
        }
        scanner.close(); // Close the scanner when the application exits
    }

    /**
     * The entry point of the application.
     * Creates a RoboticsTaskProcessor instance and starts its run loop.
     */
    public static void main(String[] args) {
        RoboticsTaskProcessor processor = new RoboticsTaskProcessor();
        processor.run(); // Start the main application loop
    }
}
