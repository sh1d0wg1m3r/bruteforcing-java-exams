/*
 * Exam Question #858
 * Generated on: 2025-05-12 16:51:29
 * Generated by: Account 4
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Job Processing Simulation System
 * 
 * **Objective:** Design and implement a console-based system that simulates a simple job processing workflow. The system should manage jobs waiting for processing in a queue and archive completed jobs in a list. Users will interact with the system via a menu. This task requires demonstrating proficiency in core Java concepts including collections, input/output, control flow, exception handling, and object-oriented principles.
 * 
 * **Requirements:**
 * 
 * 1.  **`Job` Class:** Create a class named `Job` with the following private fields:
 *     *   `id` (int): A unique identifier for the job. Must be positive.
 *     *   `description` (String): A brief description of the job. Cannot be null or empty.
 *     *   `status` (String): Represents the current status of the job (e.g., "Pending", "Completed"). Should be initialized to "Pending".
 *     *   Include a constructor to initialize `id` and `description`. The constructor must validate that `id` is positive and `description` is not null or empty, throwing an `IllegalArgumentException` if validation fails.
 *     *   Provide public getter methods for all fields (`getId`, `getDescription`, `getStatus`).
 *     *   Add a public method `setStatus(String status)` to update the job's status.
 *     *   Override the `toString()` method to provide a clear string representation of the job.
 * 
 * 2.  **`JobProcessor` Class:** Create a class named `JobProcessor` to manage the job workflow.
 *     *   Include two private fields:
 *         *   A `Queue<Job>` to hold jobs waiting for processing. Use a suitable implementation like `LinkedList`.
 *         *   A `List<Job>` to hold completed jobs. Use a suitable implementation like `ArrayList`.
 *     *   Implement a public no-argument constructor to initialize these collections.
 *     *   Implement the following public methods:
 *         *   `addJob(Job job)`: Adds a `Job` object to the processing queue. Perform a null check for the input `job`, throwing `IllegalArgumentException` if null. Print a confirmation message to `System.out`.
 *         *   `processNextJob()`: Removes the next job from the front of the processing queue. If a job is successfully retrieved, update its status to "Completed" using the `setStatus` method and add it to the completed jobs list. Return the processed `Job` object. If the processing queue is empty, return `null`.
 *         *   `getProcessingQueue()`: Returns an unmodifiable view (or a copy) of the current processing queue. Use `java.util.Collections.unmodifiableQueue` or create a new `LinkedList`.
 *         *   `getCompletedJobs()`: Returns an unmodifiable view (or a copy) of the current completed jobs list. Use `java.util.Collections.unmodifiableList` or create a new `ArrayList`.
 * 
 * 3.  **`JobSimulation` Class (Main Application):** Create a class named `JobSimulation` with a `main` method to run the simulation.
 *     *   Inside `main`, create a `Scanner` object for reading user input and a `JobProcessor` object.
 *     *   Implement a main application loop that continuously displays a menu to the user using `System.out`. The menu options should be:
 *         1.  Add New Job
 *         2.  Process Next Job
 *         3.  View Processing Queue
 *         4.  View Completed Jobs
 *         5.  Exit
 *     *   Use a `switch` statement to handle the user's menu choice.
 *     *   **Add New Job:** Prompt the user for Job ID (integer) and Description (string). Validate the input: the ID must be a valid integer and the description cannot be empty. Create a `Job` object and add it to the `JobProcessor` using the `addJob` method. Catch `InputMismatchException` for non-integer ID input and `IllegalArgumentException` from the `Job` constructor or `addJob` method. Print error messages for invalid input or job creation failures to `System.err`.
 *     *   **Process Next Job:** Call the `JobProcessor`'s `processNextJob` method. If a job was processed (method returned non-null), print a success message to `System.out`. If the queue was empty (method returned null), print an informative message to `System.err`.
 *     *   **View Processing Queue:** Call `getProcessingQueue` and iterate through the returned queue, printing details of each job to `System.out`. Indicate if the queue is empty.
 *     *   **View Completed Jobs:** Call `getCompletedJobs` and iterate through the returned list, printing details of each job to `System.out`. Indicate if the list is empty.
 *     *   **Exit:** Terminate the application.
 *     *   **Class-wide Exception Handling:** Wrap the main application loop (the `while` loop) within a `try-catch` block to catch any unexpected runtime exceptions that might occur. Print a general error message and the exception details to `System.err`. Ensure the `Scanner` is closed in a `finally` block or using try-with-resources.
 * 
 * 4.  **Best Practices:** Adhere to Java best practices:
 *     *   Proper encapsulation (private fields, public methods).
 *     *   Meaningful variable and method names.
 *     *   Appropriate comments and documentation (basic method descriptions are sufficient for an exam).
 *     *   Input validation and clear error messages (`System.err`).
 *     *   Clean code structure (consider helper methods in `JobSimulation` for menu actions).
 * 
 * **Expected Output:**
 * 
 * The program should run as an interactive console application, displaying the menu, prompting for input, showing status messages and job lists on `System.out`, and printing error messages on `System.err`. The output should clearly distinguish between normal operation and errors.
 * 
 * Example interaction:
 * 
 * ```
 * --- Job Processing System Menu ---
 * 1. Add New Job
 * 2. Process Next Job
 * 3. View Processing Queue
 * 4. View Completed Jobs
 * 5. Exit
 * Enter your choice: 1
 * 
 * --- Add New Job ---
 * Enter Job ID (positive integer): 101
 * Enter Job Description: Process User Data
 * Job added to queue: Process User Data
 * 
 * --- Job Processing System Menu ---
 * ...
 * Enter your choice: 1
 * 
 * --- Add New Job ---
 * Enter Job ID (positive integer): -5
 * Enter Job Description: Invalid Test
 * Error adding job: Job ID must be positive.
 * 
 * --- Job Processing System Menu ---
 * ...
 * Enter your choice: 3
 * 
 * --- Processing Queue ---
 * Job [ID=101, Description='Process User Data', Status=Pending]
 * 
 * --- Job Processing System Menu ---
 * ...
 * Enter your choice: 2
 * 
 * --- Processing Next Job ---
 * Successfully processed job: Process User Data (ID: 101)
 * 
 * --- Job Processing System Menu ---
 * ...
 * Enter your choice: 4
 * 
 * --- Completed Jobs ---
 * Job [ID=101, Description='Process User Data', Status=Completed]
 * 
 * --- Job Processing System Menu ---
 * ...
 * Enter your choice: 2
 * 
 * --- Processing Next Job ---
 * Processing queue is empty. No jobs to process. // This should go to System.err
 * 
 * --- Job Processing System Menu ---
 * ...
 * Enter your choice: 6
 * Invalid choice. Please enter a number between 1 and 5. // This should go to System.err
 * 
 * --- Job Processing System Menu ---
 * ...
 * Enter your choice: exit // Or some non-integer input
 * Invalid input. Please enter a number. // This should go to System.err
 * 
 * --- Job Processing System Menu ---
 * ...
 * Enter your choice: 5
 * Exiting Job Processing System. Goodbye!
 * Scanner closed.
 * ```
 * 
 * **(Note: For the exam, you can provide all classes in a single file for simplicity).**
 *
 * EXPLANATION:
 * This solution implements a basic Job Processing Simulation System demonstrating the required Java concepts.
 * 
 * 1.  **`Job` Class:** This is a simple Plain Old Java Object (POJO) representing a job. It encapsulates the job's state (`id`, `description`, `status`) with private fields and provides public getter methods. Input validation is performed in the constructor using `IllegalArgumentException`, demonstrating how to enforce data integrity at object creation. A `setStatus` method is included to allow controlled modification of the job's status by the processor. The `toString()` method provides a convenient way to print job details.
 * 
 * 2.  **`JobProcessor` Class:** This class manages the core workflow.
 *     *   It uses a `Queue<Job>` (`LinkedList` implementation) to model the waiting line of jobs. `offer()` is used to add jobs, and `poll()` is used to retrieve and remove the next job, adhering to the FIFO (First-In, First-Out) nature of a queue.
 *     *   It uses a `List<Job>` (`ArrayList` implementation) to store jobs once they are completed. `add()` is used to append completed jobs to the list.
 *     *   `addJob` validates the input job object and adds it to the queue.
 *     *   `processNextJob` demonstrates polling from the queue, checking if the queue was empty (`poll()` returns `null`), updating the job's status, and adding it to the completed list.
 *     *   `getProcessingQueue` and `getCompletedJobs` return copies of the internal collections (`LinkedList` copy for Queue, `Collections.unmodifiableList` for List) to prevent external code from directly modifying the processor's state, promoting encapsulation and data integrity.
 * 
 * 3.  **`JobSimulation` Class:** This class contains the `main` method and orchestrates the simulation.
 *     *   A `Scanner` is used to read user input from the console (`System.in`).
 *     *   A `JobProcessor` instance is created to manage the jobs.
 *     *   A `while` loop provides the main application flow, continuing until the user chooses to exit.
 *     *   A `switch` statement is used to handle the user's integer menu choice, directing execution to different parts of the code based on the input. This is a clear and efficient way to manage multiple distinct options.
 *     *   Input handling for the menu choice includes a `try-catch(InputMismatchException)` block to specifically catch cases where the user enters non-integer input, preventing the program from crashing and providing a helpful error message on `System.err`. `scanner.nextLine()` is used after `nextInt()` to consume the remaining newline character, preventing input issues in subsequent `scanner.nextLine()` calls.
 *     *   Helper methods (`addNewJob`, `processNextJob`, etc.) are used to break down the menu actions into smaller, more manageable functions, improving code readability and organization.
 *     *   Error handling is implemented at multiple levels:
 *         *   Specific `try-catch(IllegalArgumentException)` blocks are used when creating a `Job` or adding it to the processor to catch validation errors and report them using `System.err`.
 *         *   The `processNextJob` method in `JobProcessor` returns `null` when the queue is empty, and the caller (`JobSimulation`) checks for this `null` value to print an appropriate message to `System.err`.
 *         *   A general `try-catch(Exception)` block wraps the main `while` loop in `main`. This serves as a class-wide exception handler, catching any unexpected runtime exceptions that might propagate up from the helper methods or other parts of the loop, preventing the program from terminating abruptly and printing the error details to `System.err`.
 *     *   `System.out` is used for all normal output (menu, prompts, success messages, job lists), while `System.err` is reserved exclusively for error messages, clearly separating regular output from error reporting.
 *     *   `try-with-resources` is used for the `Scanner` object in `main`, ensuring that the scanner is automatically closed when the `try` block is exited, even if exceptions occur.
 * 
 * This solution effectively combines the required Java features in a practical scenario, demonstrating understanding of collection types, control flow, object-oriented design principles like encapsulation, and robust error handling using exceptions and distinct output streams.
 */

import java.util.ArrayList;
import java.util.InputMismatchException;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.Collections; // For unmodifiable views

// Class representing a Job
class Job {
    private int id;
    private String description;
    private String status;

    /**
     * Constructs a new Job.
     * @param id The job ID (must be positive).
     * @param description The job description (cannot be null or empty).
     * @throws IllegalArgumentException if id is not positive or description is null/empty.
     */
    public Job(int id, String description) {
        if (id <= 0) {
            throw new IllegalArgumentException("Job ID must be positive.");
        }
        if (description == null || description.trim().isEmpty()) {
            throw new IllegalArgumentException("Job description cannot be empty.");
        }
        this.id = id;
        this.description = description.trim();
        this.status = "Pending"; // Initial status
    }

    public int getId() {
        return id;
    }

    public String getDescription() {
        return description;
    }

    public String getStatus() {
        return status;
    }

    /**
     * Sets the status of the job.
     * @param status The new status.
     */
    public void setStatus(String status) {
        // In a real system, you might validate status transitions here
        this.status = status;
    }

    @Override
    public String toString() {
        return "Job [ID=" + id + ", Description='" + description + "', Status=" + status + "]";
    }
}

// Class managing the job processing workflow
class JobProcessor {
    // Use LinkedList for Queue as it implements the Queue interface and is efficient for adding/removing ends
    private Queue<Job> processingQueue;
    // Use ArrayList for List as it's suitable for storing completed items
    private List<Job> completedJobs;

    /**
     * Constructs a new JobProcessor with empty queues and lists.
     */
    public JobProcessor() {
        this.processingQueue = new LinkedList<>();
        this.completedJobs = new ArrayList<>();
    }

    /**
     * Adds a job to the processing queue.
     * @param job The job to add.
     * @throws IllegalArgumentException if the job is null.
     */
    public void addJob(Job job) {
        if (job == null) {
            throw new IllegalArgumentException("Cannot add a null job.");
        }
        this.processingQueue.offer(job); // offer is the preferred method for adding to a queue
        System.out.println("Job added to queue: " + job.getDescription());
    }

    /**
     * Processes the next job from the queue.
     * Removes the job, updates its status to "Completed", and moves it to the completed list.
     * @return The processed job, or null if the queue was empty.
     */
    public Job processNextJob() {
        Job jobToProcess = processingQueue.poll(); // poll retrieves and removes the head, returns null if empty
        if (jobToProcess != null) {
            // Simulate processing by changing status
            jobToProcess.setStatus("Completed");
            completedJobs.add(jobToProcess);
            return jobToProcess;
        } else {
            return null; // Queue was empty
        }
    }

    /**
     * Returns an unmodifiable view of the processing queue.
     * @return The processing queue.
     */
    public Queue<Job> getProcessingQueue() {
        // Return an unmodifiable view to prevent external modification
        return Collections.unmodifiableQueue(processingQueue); // Requires Java 11+ for unmodifiableQueue directly? No, unmodifiableCollection works on Queue. Let's use Collection view or return a copy. Returning a copy is safer if unmodifiableQueue isn't guaranteed across Java versions or specifically required. Let's return a copy.
        // return new LinkedList<>(processingQueue); // Returning a copy
        // Let's stick to unmodifiableCollection as it's a standard way to provide a read-only view.
        // return (Queue<Job>) Collections.unmodifiableCollection(processingQueue); // Cast needed
        // Or just return the actual queue for simplicity in exam, but note the risk. Let's return a copy.
         return new LinkedList<>(processingQueue);
    }

    /**
     * Returns an unmodifiable view of the completed jobs list.
     * @return The completed jobs list.
     */
    public List<Job> getCompletedJobs() {
        // Return an unmodifiable view to prevent external modification
        return Collections.unmodifiableList(completedJobs);
        // return new ArrayList<>(completedJobs); // Returning a copy
    }
}

// Main class to run the simulation
public class JobSimulation {

    private static final String MENU =
            "\n--- Job Processing System Menu ---\n" +
            "1. Add New Job\n" +
            "2. Process Next Job\n" +
            "3. View Processing Queue\n" +
            "4. View Completed Jobs\n" +
            "5. Exit\n" +
            "Enter your choice: ";

    public static void main(String[] args) {
        // Use try-with-resources for Scanner to ensure it's closed
        try (Scanner scanner = new Scanner(System.in)) {
            JobProcessor processor = new JobProcessor();
            boolean running = true;

            // Class-wide exception handling for unexpected errors during the main loop
            try {
                while (running) {
                    System.out.print(MENU);

                    int choice = -1;
                    try {
                        // Handle non-integer input specifically
                        choice = scanner.nextInt();
                        // Consume the newline character left by nextInt()
                        scanner.nextLine();
                    } catch (InputMismatchException e) {
                        System.err.println("Invalid input. Please enter a number.");
                        scanner.nextLine(); // Consume the invalid input to prevent infinite loop
                        continue; // Skip the rest of the loop and show menu again
                    }

                    // Using switch statement for flow control
                    switch (choice) {
                        case 1:
                            addNewJob(scanner, processor);
                            break;
                        case 2:
                            processNextJob(processor);
                            break;
                        case 3:
                            viewProcessingQueue(processor);
                            break;
                        case 4:
                            viewCompletedJobs(processor);
                            break;
                        case 5:
                            System.out.println("Exiting Job Processing System. Goodbye!");
                            running = false;
                            break;
                        default:
                            System.err.println("Invalid choice. Please enter a number between 1 and 5.");
                    }
                    // Add a newline for better readability between menu iterations, unless exiting
                    if(running) {
                       System.out.println();
                    }
                }
            } catch (Exception e) {
                // Catch any unexpected runtime errors not handled elsewhere
                System.err.println("An unexpected system error occurred:");
                e.printStackTrace(System.err); // Print stack trace to System.err
            }

        } // Scanner is automatically closed here by try-with-resources
        System.out.println("System shut down."); // Indicate program end
    }

    /**
     * Handles adding a new job based on user input.
     * Includes input validation and error handling.
     * @param scanner The Scanner object for input.
     * @param processor The JobProcessor instance.
     */
    private static void addNewJob(Scanner scanner, JobProcessor processor) {
        System.out.println("\n--- Add New Job ---");
        int id = -1;
        System.out.print("Enter Job ID (positive integer): ");
        try {
            id = scanner.nextInt();
            scanner.nextLine(); // Consume newline
        } catch (InputMismatchException e) {
            System.err.println("Invalid input for Job ID. Please enter an integer.");
            scanner.nextLine(); // Consume invalid input
            return; // Exit method if ID input is invalid type
        }

        System.out.print("Enter Job Description: ");
        String description = scanner.nextLine();

        try {
            // Job constructor validates ID and description
            Job newJob = new Job(id, description);
            // processor.addJob also validates (checks for null job)
            processor.addJob(newJob);
        } catch (IllegalArgumentException e) {
            // Catch validation errors from Job constructor or processor.addJob
            System.err.println("Error adding job: " + e.getMessage());
        }
    }

    /**
     * Handles processing the next job in the queue.
     * Prints status messages to System.out or System.err.
     * @param processor The JobProcessor instance.
     */
    private static void processNextJob(JobProcessor processor) {
        System.out.println("\n--- Processing Next Job ---");
        Job processedJob = processor.processNextJob(); // Returns null if queue is empty

        if (processedJob != null) {
            System.out.println("Successfully processed job: " + processedJob.getDescription() + " (ID: " + processedJob.getId() + ")");
        } else {
            System.err.println("Processing queue is empty. No jobs to process.");
        }
    }

    /**
     * Handles viewing the processing queue.
     * Prints job details to System.out.
     * @param processor The JobProcessor instance.
     */
    private static void viewProcessingQueue(JobProcessor processor) {
        System.out.println("\n--- Processing Queue ---");
        // Get an unmodifiable view or copy of the queue
        Queue<Job> queue = processor.getProcessingQueue();

        if (queue.isEmpty()) {
            System.out.println("The processing queue is empty.");
        } else {
            // Iterate through the queue and print each job's details
            // The for-each loop iterates in the order elements would be polled
            queue.forEach(System.out::println);
        }
    }

    /**
     * Handles viewing the completed jobs list.
     * Prints job details to System.out.
     * @param processor The JobProcessor instance.
     */
    private static void viewCompletedJobs(JobProcessor processor) {
        System.out.println("\n--- Completed Jobs ---");
        // Get an unmodifiable view or copy of the list
        List<Job> completed = processor.getCompletedJobs();

        if (completed.isEmpty()) {
            System.out.println("No jobs have been completed yet.");
        } else {
            // Iterate through the list and print each job's details
            completed.forEach(System.out::println);
        }
    }
}
