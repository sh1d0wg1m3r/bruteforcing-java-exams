/*
 * Exam Question #750
 * Generated on: 2025-05-12 16:35:26
 * Generated by: Account 3
 * 
 * QUESTION:
 * **Advanced Task Processing System**
 * 
 * You are tasked with building a system that manages and processes different types of tasks. The system should accept new tasks, queue them for processing, process the next available task, and keep a record of completed tasks.
 * 
 * Your solution must demonstrate proficiency in using various core Java collections and control structures, adhering to best practices.
 * 
 * **Requirements:**
 * 
 * 1.  **Task Representation:** Create a class `Task` to represent a task. It should have private fields for a unique integer `taskId`, a `String taskType` (e.g., "DataAnalysis", "ReportGeneration", "SystemMaintenance"), and a `String status` (initially "Pending", changes to "Completed" upon processing). Include a constructor and appropriate getter methods.
 * 2.  **System Core:** Create a class `TaskProcessingSystem` that manages the tasks. It should contain:
 *     *   A `Queue<Task>` to hold tasks waiting to be processed.
 *     *   A `List<Task>` (specifically using `ArrayList` as the implementation) to store completed tasks.
 *     *   A mechanism to generate unique task IDs (e.g., an integer counter).
 * 3.  **Functionality:** The `TaskProcessingSystem` must provide the following operations via public methods:
 *     *   `addTask(String taskType)`: Creates a new `Task` with a unique ID, sets its status to "Pending", and adds it to the processing queue.
 *     *   `processNextTask()`: Removes the task at the front of the queue, changes its status to "Completed", and adds it to the list of completed tasks. If the queue is empty, it should report an error.
 *     *   `viewPendingTasks()`: Displays the details of all tasks currently in the queue.
 *     *   `viewCompletedTasks()`: Displays the details of all tasks in the completed list.
 * 4.  **User Interface:** Implement a simple command-line interface using `java.util.Scanner` in the `main` method or a dedicated `run` method within `TaskProcessingSystem`. The interface should present a menu to the user with options corresponding to the system's functionality (Add Task, Process Next, View Pending, View Completed, Exit).
 * 5.  **Flow Control:** Use a `switch` statement to handle the different menu options selected by the user.
 * 6.  **Error Handling:**
 *     *   Use `System.err.println()` to display error messages, such as when the user enters invalid input (non-integer, out of menu range) or attempts to process a task when the queue is empty.
 *     *   Implement class-wide exception handling using a `try-catch` block around the main command processing loop in the `run` method to catch unexpected runtime exceptions.
 * 7.  **Output:** Use `System.out.println()` for displaying the menu, prompts, task details, and confirmation messages.
 * 8.  **Best Practices:** Ensure the code follows Java best practices including:
 *     *   Proper encapsulation (private fields, public methods).
 *     *   Meaningful variable and method names.
 *     *   Appropriate comments and documentation (Javadoc where applicable).
 *     *   Input validation for menu choices.
 *     *   Clean code structure (separate classes, methods for distinct logic).
 * 
 * **Expected Output (Example Interaction):**
 * 
 * ```
 * Task Processing System Menu:
 * 1. Add Task
 * 2. Process Next Task
 * 3. View Pending Tasks
 * 4. View Completed Tasks
 * 5. Exit
 * Enter your choice: 1
 * Enter task type (e.g., DataAnalysis): DataAnalysis
 * Task 1 (DataAnalysis) added to queue.
 * 
 * Task Processing System Menu:
 * 1. Add Task
 * 2. Process Next Task
 * 3. View Pending Tasks
 * 4. View Completed Tasks
 * 5. Exit
 * Enter your choice: 1
 * Enter task type (e.g., DataAnalysis): ReportGeneration
 * Task 2 (ReportGeneration) added to queue.
 * 
 * Task Processing System Menu:
 * 1. Add Task
 * 2. Process Next Task
 * 3. View Pending Tasks
 * 4. View Completed Tasks
 * 5. Exit
 * Enter your choice: 3
 * Pending Tasks:
 * Task ID: 1, Type: DataAnalysis, Status: Pending
 * Task ID: 2, Type: ReportGeneration, Status: Pending
 * 
 * Task Processing System Menu:
 * 1. Add Task
 * 2. Process Next Task
 * 3. View Pending Tasks
 * 4. View Completed Tasks
 * 5. Exit
 * Enter your choice: 2
 * Processing task 1 (DataAnalysis)... Task completed.
 * 
 * Task Processing System Menu:
 * 1. Add Task
 * 2. Process Next Task
 * 3. View Pending Tasks
 * 4. View Completed Tasks
 * 5. Exit
 * Enter your choice: 3
 * Pending Tasks:
 * Task ID: 2, Type: ReportGeneration, Status: Pending
 * 
 * Task Processing System Menu:
 * 1. Add Task
 * 2. Process Next Task
 * 3. View Pending Tasks
 * 4. View Completed Tasks
 * 5. Exit
 * Enter your choice: 4
 * Completed Tasks:
 * Task ID: 1, Type: DataAnalysis, Status: Completed
 * 
 * Task Processing System Menu:
 * 1. Add Task
 * 2. Process Next Task
 * 3. View Pending Tasks
 * 4. View Completed Tasks
 * 5. Exit
 * Enter your choice: 6
 * System.err: Invalid choice. Please enter a number between 1 and 5.
 * 
 * Task Processing System Menu:
 * 1. Add Task
 * 2. Process Next Task
 * 3. View Pending Tasks
 * 4. View Completed Tasks
 * 5. Exit
 * Enter your choice: exit
 * System.err: Invalid input. Please enter a number.
 * 
 * Task Processing System Menu:
 * 1. Add Task
 * 2. Process Next Task
 * 3. View Pending Tasks
 * 4. View Completed Tasks
 * 5. Exit
 * Enter your choice: 5
 * Exiting Task Processing System.
 * ```
 * 
 * Your solution should be a single Java file containing all necessary classes.
 *
 * EXPLANATION:
 * The solution implements a simple Task Processing System demonstrating the required Java concepts and best practices.
 * 
 * 1.  **`Task` Class:**
 *     *   Encapsulates task data (`taskId`, `taskType`, `status`) using private fields.
 *     *   Provides public getters for accessing the data.
 *     *   Includes a `setStatus` method, which is used internally by the system.
 *     *   `toString()` is overridden for easy printing of task details.
 * 
 * 2.  **`TaskProcessingSystem` Class:**
 *     *   **`Queue<Task> taskQueue`:** A `Queue` is used (implemented by `LinkedList`) to manage tasks in a First-In, First-Out (FIFO) order, which is natural for a processing queue. `LinkedList` is a common implementation for `Queue`.
 *     *   **`List<Task> completedTasks`:** An `ArrayList` is used to store completed tasks. `ArrayList` provides dynamic resizing and efficient access to elements by index, suitable for maintaining a history of completed items. The variable is declared using the `List` interface type, promoting good practice (programming to interfaces).
 *     *   **`nextTaskId`:** A simple counter generates unique IDs for new tasks.
 *     *   **`addTask(String taskType)`:** Creates a new `Task` object and adds it to the `taskQueue` using `add()`.
 *     *   **`processNextTask()`:** Uses `taskQueue.poll()` to retrieve and remove the head of the queue. It checks if the queue is empty *before* polling to prevent errors, reporting the issue using `System.err`. The processed task's status is updated, and it's added to the `completedTasks` `ArrayList` using `add()`.
 *     *   **`viewPendingTasks()`:** Iterates through the `taskQueue` using an enhanced for loop to display tasks without removing them. Checks for an empty queue and prints a message if so.
 *     *   **`viewCompletedTasks()`:** Iterates through the `completedTasks` `List` to display completed tasks. Checks if the list is empty.
 *     *   **`run()`:** Contains the main logic loop.
 *         *   A `Scanner` reads user input.
 *         *   The main loop (`while(running)`) continues until the user chooses to exit.
 *         *   A `try-catch` block wraps the core loop logic. This provides class-wide exception handling, catching unexpected errors that might occur during the execution of menu options.
 *         *   Inside the loop, there's specific input validation using another `try-catch` block (`InputMismatchException`) to ensure the user enters an integer for the menu choice. Invalid input is reported via `System.err`, and the loop continues.
 *         *   A `switch` statement efficiently handles the different integer menu choices, calling the appropriate methods of the `TaskProcessingSystem`.
 *         *   `System.out.println()` is used for normal output like the menu, prompts, and task details.
 *         *   `System.err.println()` is used for error messages (invalid input, empty queue).
 *         *   The `finally` block ensures the `Scanner` is closed, releasing system resources.
 * 
 * 3.  **`ExamQuestion` Class:**
 *     *   Contains the `main` method, which is the entry point of the application.
 *     *   It creates an instance of `TaskProcessingSystem` and calls its `run()` method to start the interactive system.
 * 
 * This solution effectively integrates `Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.err`, `System.out`, and `try-catch` within a practical, encapsulated, and well-structured system, demonstrating advanced Java programming skills.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.InputMismatchException;

/**
 * Represents a task in the processing system.
 */
class Task {
    private int taskId;
    private String taskType;
    private String status; // e.g., "Pending", "Completed"

    /**
     * Constructs a new Task.
     * @param taskId The unique identifier for the task.
     * @param taskType The type of the task (e.g., "DataAnalysis").
     */
    public Task(int taskId, String taskType) {
        this.taskId = taskId;
        this.taskType = taskType;
        this.status = "Pending"; // Initial status
    }

    // --- Getters ---
    public int getTaskId() {
        return taskId;
    }

    public String getTaskType() {
        return taskType;
    }

    public String getStatus() {
        return status;
    }

    // --- Setter for status (used internally by the system) ---
    public void setStatus(String status) {
        this.status = status;
    }

    @Override
    public String toString() {
        return String.format("Task ID: %d, Type: %s, Status: %s", taskId, taskType, status);
    }
}

/**
 * Manages the queue and completion of tasks.
 */
class TaskProcessingSystem {
    private Queue<Task> taskQueue;
    private List<Task> completedTasks; // Using List interface with ArrayList implementation
    private int nextTaskId;

    /**
     * Constructs a new TaskProcessingSystem.
     * Initializes the task queue, completed tasks list, and task ID counter.
     */
    public TaskProcessingSystem() {
        this.taskQueue = new LinkedList<>(); // LinkedList implements Queue
        this.completedTasks = new ArrayList<>(); // ArrayList implements List
        this.nextTaskId = 1; // Start task IDs from 1
    }

    /**
     * Adds a new task to the processing queue.
     * @param taskType The type of the task to add.
     */
    public void addTask(String taskType) {
        Task newTask = new Task(nextTaskId++, taskType);
        taskQueue.add(newTask);
        System.out.println("Task " + newTask.getTaskId() + " (" + newTask.getTaskType() + ") added to queue.");
    }

    /**
     * Processes the next task from the queue.
     * Removes it from the queue, marks it as completed, and moves it to the completed list.
     * Reports an error if the queue is empty.
     */
    public void processNextTask() {
        if (taskQueue.isEmpty()) {
            System.err.println("Error: No tasks in the queue to process.");
            return;
        }

        Task taskToProcess = taskQueue.poll(); // Get and remove the head of the queue
        System.out.println("Processing task " + taskToProcess.getTaskId() + " (" + taskToProcess.getTaskType() + ")...");

        // Simulate processing (just change status)
        taskToProcess.setStatus("Completed");

        completedTasks.add(taskToProcess); // Add to the completed list
        System.out.println("Task completed.");
    }

    /**
     * Displays all tasks currently in the pending queue.
     */
    public void viewPendingTasks() {
        if (taskQueue.isEmpty()) {
            System.out.println("Pending Tasks: Queue is empty.");
            return;
        }
        System.out.println("Pending Tasks:");
        // Iterate through the queue without removing elements
        for (Task task : taskQueue) {
            System.out.println(task);
        }
    }

    /**
     * Displays all tasks that have been completed.
     */
    public void viewCompletedTasks() {
        if (completedTasks.isEmpty()) {
            System.out.println("Completed Tasks: No tasks have been completed yet.");
            return;
        }
        System.out.println("Completed Tasks:");
        for (Task task : completedTasks) {
            System.out.println(task);
        }
    }

    /**
     * Runs the main command-line interface loop for the task processing system.
     * Includes menu display, user input handling, switch statement, and exception handling.
     */
    public void run() {
        Scanner scanner = new Scanner(System.in);
        boolean running = true;

        // Class-wide exception handling for the main operational loop
        try {
            while (running) {
                printMenu();
                int choice = -1; // Default to an invalid choice

                // Input validation for menu choice
                try {
                    System.out.print("Enter your choice: ");
                    choice = scanner.nextInt();
                } catch (InputMismatchException e) {
                    System.err.println("System.err: Invalid input. Please enter a number.");
                    scanner.next(); // Consume the invalid input to prevent infinite loop
                    continue; // Skip to the next iteration
                }

                // Switch statement for flow control
                switch (choice) {
                    case 1:
                        System.out.print("Enter task type (e.g., DataAnalysis): ");
                        String taskType = scanner.next(); // Read the task type string
                        addTask(taskType);
                        break;
                    case 2:
                        processNextTask();
                        break;
                    case 3:
                        viewPendingTasks();
                        break;
                    case 4:
                        viewCompletedTasks();
                        break;
                    case 5:
                        running = false;
                        System.out.println("Exiting Task Processing System.");
                        break;
                    default:
                        System.err.println("System.err: Invalid choice. Please enter a number between 1 and 5.");
                        break;
                }
                System.out.println(); // Add a newline for better readability between operations
            }
        } catch (Exception e) {
            // Catch any unexpected runtime exceptions during system operation
            System.err.println("System.err: An unexpected error occurred: " + e.getMessage());
            e.printStackTrace(System.err); // Print stack trace to System.err
        } finally {
            // Ensure the scanner is closed
            if (scanner != null) {
                scanner.close();
            }
        }
    }

    /**
     * Prints the main menu options to the console.
     */
    private void printMenu() {
        System.out.println("Task Processing System Menu:");
        System.out.println("1. Add Task");
        System.out.println("2. Process Next Task");
        System.out.println("3. View Pending Tasks");
        System.out.println("4. View Completed Tasks");
        System.out.println("5. Exit");
    }
}

/**
 * Main class to start the Task Processing System.
 */
public class ExamQuestion { // Renamed from main to ExamQuestion as per common practice for class names
    public static void main(String[] args) {
        TaskProcessingSystem system = new TaskProcessingSystem();
        system.run(); // Start the system's interactive loop
    }
}
