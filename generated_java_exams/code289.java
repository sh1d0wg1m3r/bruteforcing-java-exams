/*
 * Exam Question #289
 * Generated on: 2025-05-11 22:50:03
 * Generated by: Account 5
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Advanced Production Line Simulator
 * 
 * **Scenario:**
 * 
 * You are tasked with developing a simplified simulator for a manufacturing production line. The simulator manages a queue of manufacturing tasks, processes them one by one, tracks completed products, and manages a basic inventory of parts required for assembly tasks.
 * 
 * **Requirements:**
 * 
 * Implement a Java program that simulates this production line with the following features:
 * 
 * 1.  **Task Management:** Maintain a queue of manufacturing tasks waiting to be processed.
 * 2.  **Inventory Management:** Maintain a list of available parts. Specific tasks will require consuming parts from this inventory.
 * 3.  **Task Processing:** Process tasks from the front of the queue. Successfully processed tasks result in completed products.
 * 4.  **User Interaction:** Provide a command-line interface for the user to interact with the simulator.
 * 5.  **Required Java Components:** Your solution MUST utilize ALL of the following Java components:
 *     *   `java.util.Queue`: For managing the waiting tasks.
 *     *   `java.util.ArrayList`: For implementing the list of available inventory parts.
 *     *   `java.util.List` interface: For declaring the type of the completed products collection.
 *     *   `java.util.Scanner`: For reading user commands and input.
 *     *   `switch` statement: For handling different user commands.
 *     *   `System.err`: For outputting error messages (e.g., invalid command, insufficient inventory, empty queue).
 *     *   `System.out`: For outputting normal messages (e.g., successful operations, status updates, list contents).
 *     *   Class-wide exception handling with `try-catch` blocks: Wrap the main execution loop (where user commands are processed) in a `try-catch` block to handle any unexpected runtime errors.
 * 
 * 6.  **Commands:** The simulator should accept the following commands (case-insensitive):
 *     *   `ADD_TASK <productType> <taskType>`: Adds a new task to the queue. `<taskType>` can be "ASSEMBLE" or "TEST".
 *         *   If `<taskType>` is "ASSEMBLE", check if required parts are available in inventory. If yes, add the task to the queue and consume the required parts *immediately* upon adding the task. If no, print an error message to `System.err` and do not add the task.
 *         *   If `<taskType>` is "TEST", no parts are consumed upon adding the task.
 *         *   Validate that `<taskType>` is either "ASSEMBLE" or "TEST".
 *     *   `PROCESS_NEXT`: Processes the task at the front of the queue.
 *         *   If the queue is empty, print an error message to `System.err`.
 *         *   If a task is processed, remove it from the queue, simulate processing (print a message), and if it was an "ASSEMBLE" task, add a completed product of the specified type to the list of completed products. If it was a "TEST" task, it's considered a final step, and the product is completed.
 *     *   `ADD_INVENTORY <partName> <quantity>`: Adds the specified quantity of a part to the inventory.
 *     *   `VIEW_QUEUE`: Prints the current tasks in the queue.
 *     *   `VIEW_COMPLETED`: Prints the list of completed products.
 *     *   `VIEW_INVENTORY`: Prints the current contents of the inventory.
 *     *   `EXIT`: Terminates the program.
 *     *   Any other command should result in an "Unknown command" error message printed to `System.err`.
 * 
 * 7.  **Inventory Requirements (Example):**
 *     *   "ASSEMBLE WidgetA" requires "PartA" and "PartB".
 *     *   "ASSEMBLE GadgetB" requires "PartC" and "PartA".
 *     *   "TEST WidgetA" and "TEST GadgetB" require no parts.
 * 
 * 8.  **Best Practices:**
 *     *   Use proper encapsulation (private fields, public methods).
 *     *   Use meaningful variable and method names.
 *     *   Include appropriate comments and documentation (e.g., Javadoc for classes/methods).
 *     *   Implement robust input validation for commands and their arguments.
 *     *   Implement proper error handling using `System.err` for errors and `System.out` for success/information.
 *     *   Structure your code into appropriate classes (e.g., `Task`, `Product`, `ProductionLineSimulator`).
 * 
 * **Expected Output:**
 * 
 * The program should run interactively, accepting commands and printing results or errors to the console using `System.out` and `System.err` as specified. The format of output for viewing lists should be clear (e.g., listing items line by line).
 * 
 * **Example Interaction Snippet:**
 * 
 * ```
 * Enter command: ADD_INVENTORY PartA 5
 * Added 5 x PartA to inventory.
 * Enter command: ADD_INVENTORY PartB 3
 * Added 3 x PartB to inventory.
 * Enter command: VIEW_INVENTORY
 * Current Inventory: [PartA, PartA, PartA, PartA, PartA, PartB, PartB, PartB]
 * Enter command: ADD_TASK WidgetA ASSEMBLE
 * Task added: Assemble WidgetA. Consumed: [PartA, PartB]
 * Enter command: VIEW_QUEUE
 * Task Queue: [Assemble WidgetA]
 * Enter command: VIEW_INVENTORY
 * Current Inventory: [PartA, PartA, PartA, PartA, PartB]
 * Enter command: PROCESS_NEXT
 * Processing task: Assemble WidgetA
 * Task completed: Assemble WidgetA. Product WidgetA completed.
 * Enter command: VIEW_COMPLETED
 * Completed Products: [WidgetA]
 * Enter command: PROCESS_NEXT
 * Error: Production line queue is empty.
 * Enter command: ADD_TASK GadgetB ASSEMBLE
 * Error: Insufficient inventory for task Assemble GadgetB. Required: [PartC, PartA], Available: [PartA, PartA, PartA, PartA, PartB]
 * Enter command: EXIT
 * Exiting simulator.
 * ```
 * 
 * **Deliverables:**
 * 
 * Provide the complete Java code for the simulator.
 *
 * EXPLANATION:
 * This solution implements the `ProductionLineSimulator` as requested, demonstrating the use of all required Java components and adhering to best practices.
 * 
 * 1.  **Class Structure:** The code is organized into three main classes:
 *     *   `Task`: Represents a pending job with a product type, task type, and required parts.
 *     *   `Product`: Represents an item that has successfully gone through a manufacturing process step.
 *     *   `ProductionLineSimulator`: The main class that orchestrates the simulation, managing the queue, inventory, and completed products, and handling user interaction.
 * 
 * 2.  **Required Components Usage:**
 *     *   `java.util.Queue`: The `taskQueue` field in `ProductionLineSimulator` is declared as `Queue<Task>` and instantiated using `ConcurrentLinkedQueue`. `offer()` is used to add tasks, and `poll()` is used to retrieve and remove tasks for processing.
 *     *   `java.util.ArrayList`: The `inventory` field is declared and instantiated explicitly as `ArrayList<String>`, fulfilling the requirement to use `ArrayList`. It stores individual part names.
 *     *   `java.util.List` interface: The `completedProducts` field is declared as `List<Product>` and instantiated using `new ArrayList<>()`. This demonstrates coding to the interface.
 *     *   `java.util.Scanner`: A `Scanner` object is created in the `main` method to read command-line input from `System.in`.
 *     *   `switch` statement: A `switch` statement in the `main` method is used to process the user's command string, directing execution to the appropriate simulator method.
 *     *   `System.err`: Used specifically for printing error messages, such as invalid commands, insufficient inventory, empty queue conditions, and unexpected exceptions caught by the main `try-catch` block.
 *     *   `System.out`: Used for all normal output, including successful task additions, processing messages, and displaying the contents of the queue, completed products, and inventory.
 *     *   Class-wide `try-catch`: The main `while` loop in the `main` method, which processes user commands, is wrapped in a `try-catch` block. This catches any `Exception` that might occur during command processing (though specific errors like insufficient inventory are caught and handled closer to where they occur) and prints an error message and stack trace to `System.err`. A `finally` block ensures the `Scanner` is closed.
 * 
 * 3.  **Functionality and Logic:**
 *     *   **Task Addition (`addTask`):** Takes product and task types. Uses a `switch` to differentiate between "ASSEMBLE" and "TEST". For "ASSEMBLE", it consults the `ASSEMBLY_REQUIREMENTS` map (simulating a configuration) to find required parts. It calls `checkInventory` to verify availability. If sufficient, it calls `consumeInventory` to remove parts *before* adding the task to the queue. If insufficient inventory or an invalid task type is given, custom exceptions (`InsufficientInventoryException`, `InvalidTaskTypeException`) are thrown, which are caught in the `main` method to print the error using `System.err`.
 *     *   **Inventory Check (`checkInventory`):** Creates a temporary copy of the inventory `ArrayList` and attempts to remove each required part from the copy. This simulates checking if the required parts *could* be consumed without modifying the actual inventory during the check.
 *     *   **Inventory Consumption (`consumeInventory`):** Iterates through the list of parts to be consumed and removes them one by one from the actual `inventory` `ArrayList`.
 *     *   **Task Processing (`processNextTask`):** Uses `taskQueue.poll()` to get the next task. If `poll()` returns `null`, it means the queue is empty, and an error is printed to `System.err`. Otherwise, it simulates processing and adds a new `Product` object to the `completedProducts` `List`.
 *     *   **Inventory Addition (`addInventory`):** Adds the specified number of `partName` strings to the `inventory` `ArrayList`. Includes basic validation for quantity.
 *     *   **Viewing Collections (`viewQueue`, `viewCompleted`, `viewInventory`):** These methods simply iterate through and print the contents of the respective collections (`taskQueue`, `completedProducts` `List`, `inventory` `ArrayList`). `viewQueue` iterates without removing elements.
 * 
 * 4.  **Best Practices:**
 *     *   **Encapsulation:** Fields in `Task`, `Product`, and `ProductionLineSimulator` are `private`, and access is provided through `public` methods (getters).
 *     *   **Meaningful Names:** Class, method, and variable names are descriptive (e.g., `taskQueue`, `completedProducts`, `addInventory`, `checkInventory`).
 *     *   **Comments and Documentation:** Javadoc comments are provided for classes and key methods explaining their purpose, parameters, and exceptions. Inline comments clarify specific logic points.
 *     *   **Input Validation:** The `main` method checks the number of arguments for commands like `ADD_TASK` and `ADD_INVENTORY`. `ADD_INVENTORY` also validates that the quantity is a number. `addTask` validates the task type and checks inventory.
 *     *   **Error Handling:** Specific error conditions (insufficient inventory, invalid task type, empty queue, invalid command, invalid number format) are checked, and informative error messages are printed to `System.err`. The main `try-catch` provides a fallback for unexpected errors.
 *     *   **Clean Code Structure:** The logic is divided into methods within the `ProductionLineSimulator` class, keeping the `main` method relatively clean and focused on command parsing and calling the appropriate simulator methods. Helper classes (`Task`, `Product`) encapsulate their data and behavior.
 * 
 * This solution effectively integrates the required Java components into a cohesive, practical simulation, demonstrating an understanding of data structures, control flow, error handling, and object-oriented principles in Java.
 */

import java.util.*;
import java.util.Queue;
import java.util.concurrent.ConcurrentLinkedQueue; // Good Queue choice for potential concurrency, simple Queue interface usage here
import java.util.stream.Collectors;

// --- Helper Classes ---

/**
 * Represents a manufacturing task in the production line.
 */
class Task {
    private String productType;
    private String taskType; // e.g., "ASSEMBLE", "TEST"
    private List<String> requiredParts; // Parts needed *for assembly*

    /**
     * Constructs a new Task.
     * @param productType The type of product this task relates to.
     * @param taskType The type of task (e.g., "ASSEMBLE", "TEST").
     * @param requiredParts The list of parts required for this task (null or empty if none).
     */
    public Task(String productType, String taskType, List<String> requiredParts) {
        this.productType = productType;
        this.taskType = taskType;
        this.requiredParts = requiredParts != null ? new ArrayList<>(requiredParts) : new ArrayList<>();
    }

    public String getProductType() {
        return productType;
    }

    public String getTaskType() {
        return taskType;
    }

    public List<String> getRequiredParts() {
        return new ArrayList<>(requiredParts); // Return a copy
    }

    @Override
    public String toString() {
        return taskType + " " + productType + (requiredParts.isEmpty() ? "" : " (Requires: " + requiredParts + ")");
    }
}

/**
 * Represents a completed product.
 */
class Product {
    private String productType;
    private long completionTimestamp;

    /**
     * Constructs a new Product.
     * @param productType The type of product.
     */
    public Product(String productType) {
        this.productType = productType;
        this.completionTimestamp = System.currentTimeMillis();
    }

    public String getProductType() {
        return productType;
    }

    public long getCompletionTimestamp() {
        return completionTimestamp;
    }

    @Override
    public String toString() {
        return productType + " (Completed: " + new Date(completionTimestamp) + ")";
    }
}

/**
 * Custom exception for insufficient inventory.
 */
class InsufficientInventoryException extends Exception {
    public InsufficientInventoryException(String message) {
        super(message);
    }
}

/**
 * Custom exception for invalid task type.
 */
class InvalidTaskTypeException extends Exception {
     public InvalidTaskTypeException(String message) {
         super(message);
     }
}


// --- Main Simulator Class ---

/**
 * Simulates a production line managing tasks, inventory, and completed products.
 */
public class ProductionLineSimulator {

    // Required Java components
    private Queue<Task> taskQueue;
    private ArrayList<String> inventory; // Using ArrayList specifically as requested
    private List<Product> completedProducts; // Using List interface, implemented by ArrayList

    // Example inventory requirements map (could be loaded from config in real app)
    private static final Map<String, List<String>> ASSEMBLY_REQUIREMENTS = new HashMap<>();

    static {
        ASSEMBLY_REQUIREMENTS.put("WidgetA", Arrays.asList("PartA", "PartB"));
        ASSEMBLY_REQUIREMENTS.put("GadgetB", Arrays.asList("PartC", "PartA"));
        // Add more product assembly requirements here
    }

    /**
     * Constructs a new ProductionLineSimulator.
     * Initializes the queue, inventory, and completed products lists.
     */
    public ProductionLineSimulator() {
        this.taskQueue = new ConcurrentLinkedQueue<>(); // ConcurrentLinkedQueue is a good Queue implementation
        this.inventory = new ArrayList<>(); // ArrayList for inventory as required
        this.completedProducts = new ArrayList<>(); // ArrayList implements List for completed products
    }

    /**
     * Adds a new task to the production line queue if inventory is sufficient for assembly tasks.
     * Consumes inventory immediately for assembly tasks.
     * @param productType The type of product the task is for.
     * @param taskType The type of task ("ASSEMBLE" or "TEST").
     * @throws InsufficientInventoryException if required parts are not available for assembly.
     * @throws InvalidTaskTypeException if the task type is not recognized.
     */
    public void addTask(String productType, String taskType) throws InsufficientInventoryException, InvalidTaskTypeException {
        String upperTaskType = taskType.toUpperCase();
        List<String> requiredParts = new ArrayList<>();

        switch (upperTaskType) { // Using switch statement as required
            case "ASSEMBLE":
                requiredParts = ASSEMBLY_REQUIREMENTS.getOrDefault(productType, new ArrayList<>());
                if (requiredParts.isEmpty() && ASSEMBLY_REQUIREMENTS.containsKey(productType)) {
                    // Product type is known but requires no parts for assembly (unlikely but possible)
                    System.out.println("Note: Assembly task for " + productType + " requires no specific parts.");
                } else if (requiredParts.isEmpty() && !ASSEMBLY_REQUIREMENTS.containsKey(productType)) {
                     System.err.println("Error: Unknown product type '" + productType + "' for assembly.");
                     // Decide if unknown products can be assembled without parts or should fail.
                     // Let's fail for unknown products requiring assembly for strictness.
                     throw new InvalidTaskTypeException("Unknown product type '" + productType + "' for assembly.");
                }

                if (!checkInventory(requiredParts)) {
                    throw new InsufficientInventoryException("Insufficient inventory for task " + upperTaskType + " " + productType +
                            ". Required: " + requiredParts + ", Available: " + getInventorySummary(requiredParts));
                }
                // If inventory is sufficient, consume parts immediately
                consumeInventory(requiredParts);
                System.out.println("Consumed: " + requiredParts);
                break; // End of ASSEMBLE case

            case "TEST":
                // Test tasks require no parts from inventory
                System.out.println("Note: Test task for " + productType + " requires no parts.");
                break; // End of TEST case

            default:
                throw new InvalidTaskTypeException("Invalid task type: " + taskType + ". Must be ASSEMBLE or TEST.");
        }

        Task newTask = new Task(productType, upperTaskType, requiredParts);
        taskQueue.offer(newTask); // Add task to the queue
        System.out.println("Task added: " + newTask);
    }

    /**
     * Processes the next task from the queue.
     * If the task is ASSEMBLE or TEST, a completed product is generated.
     */
    public void processNextTask() {
        Task nextTask = taskQueue.poll(); // Retrieve and remove the head of the queue

        if (nextTask == null) {
            System.err.println("Error: Production line queue is empty."); // Use System.err as required
            return;
        }

        System.out.println("Processing task: " + nextTask.getTaskType() + " " + nextTask.getProductType());

        // Simulate processing time if needed, e.g., Thread.sleep(1000);

        // For this simulation, both ASSEMBLE and TEST tasks complete a product unit.
        // In a real scenario, TEST might transition a product state, not create a new one.
        // Following the prompt's implication, both lead to a 'completed' product state for simplicity.
        Product completedProduct = new Product(nextTask.getProductType());
        completedProducts.add(completedProduct); // Add to the List of completed products

        System.out.println("Task completed: " + nextTask.getTaskType() + " " + nextTask.getProductType() +
                           ". Product " + completedProduct.getProductType() + " completed.");
    }

    /**
     * Adds parts to the inventory.
     * @param partName The name of the part to add.
     * @param quantity The number of parts to add.
     */
    public void addInventory(String partName, int quantity) {
        if (quantity <= 0) {
            System.err.println("Error: Quantity must be positive to add inventory.");
            return;
        }
        for (int i = 0; i < quantity; i++) {
            inventory.add(partName); // Add to ArrayList as required
        }
        System.out.println("Added " + quantity + " x " + partName + " to inventory.");
    }

    /**
     * Checks if the required parts are available in the inventory.
     * This check is done *before* adding an ASSEMBLE task.
     * @param requiredParts The list of parts needed.
     * @return true if all required parts are available, false otherwise.
     */
    private boolean checkInventory(List<String> requiredParts) {
        // Create a temporary mutable copy of inventory for checking
        List<String> currentInventoryCheck = new ArrayList<>(this.inventory);
        for (String part : requiredParts) {
            if (!currentInventoryCheck.remove(part)) { // Try to "consume" the part from the copy
                return false; // Part not found
            }
        }
        return true; // All parts found and theoretically consumable
    }

    /**
     * Consumes (removes) parts from the actual inventory list.
     * This happens *after* a successful inventory check when adding an ASSEMBLE task.
     * @param consumedParts The list of parts to consume.
     */
    private void consumeInventory(List<String> consumedParts) {
        List<String> partsToRemove = new ArrayList<>(consumedParts); // Use a copy to manage removal

        // Iterate through the parts to remove
        Iterator<String> partsToRemoveIterator = partsToRemove.iterator();
        while (partsToRemoveIterator.hasNext()) {
             String partToRemove = partsToRemoveIterator.next();
             // Find and remove the first occurrence of this part in the inventory
             if (inventory.remove(partToRemove)) {
                 partsToRemoveIterator.remove(); // Mark this part as successfully removed from inventory
             } else {
                 // This case should theoretically not happen if checkInventory passed,
                 // but it's good practice to handle potential inconsistencies.
                 System.err.println("Warning: Failed to remove part '" + partToRemove + "' during consumption, despite check.");
             }
        }
        // If partsToRemove is not empty here, it indicates a logic error or concurrency issue (not applicable in single-thread CLI).
    }

     /**
      * Generates a summary string of available inventory for the required parts.
      * Useful for error messages.
      * @param requiredParts The list of parts that were required.
      * @return A string showing counts of required parts currently in inventory.
      */
     private String getInventorySummary(List<String> requiredParts) {
         Map<String, Long> requiredCounts = requiredParts.stream()
                 .collect(Collectors.groupingBy(part -> part, Collectors.counting()));

         Map<String, Long> availableCounts = inventory.stream()
                 .filter(requiredParts::contains) // Only count relevant parts
                 .collect(Collectors.groupingBy(part -> part, Collectors.counting()));

         StringBuilder summary = new StringBuilder("[");
         boolean first = true;
         for (Map.Entry<String, Long> entry : requiredCounts.entrySet()) {
             if (!first) summary.append(", ");
             summary.append(entry.getKey()).append(": ").append(availableCounts.getOrDefault(entry.getKey(), 0L));
             first = false;
         }
         summary.append("]");
         return summary.toString();
     }


    /**
     * Prints the current tasks in the queue.
     */
    public void viewQueue() {
        System.out.println("--- Task Queue ---");
        if (taskQueue.isEmpty()) {
            System.out.println("Queue is empty.");
        } else {
            // Iterate through the queue without removing elements
            taskQueue.forEach(System.out::println);
        }
        System.out.println("------------------");
    }

    /**
     * Prints the list of completed products.
     */
    public void viewCompleted() {
        System.out.println("--- Completed Products ---");
        if (completedProducts.isEmpty()) {
            System.out.println("No products completed yet.");
        } else {
            // Iterate through the List of completed products
            completedProducts.forEach(System.out::println);
        }
        System.out.println("------------------------");
    }

    /**
     * Prints the current contents of the inventory.
     */
    public void viewInventory() {
        System.out.println("--- Current Inventory (" + inventory.size() + " items) ---");
        if (inventory.isEmpty()) {
            System.out.println("Inventory is empty.");
        } else {
            // Print contents of the ArrayList inventory
            System.out.println(inventory); // Prints the default List toString representation
            // Or print line by line:
            // inventory.forEach(System.out::println);
        }
        System.out.println("-------------------------");
    }

    /**
     * Main method to run the simulator.
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        ProductionLineSimulator simulator = new ProductionLineSimulator();
        Scanner scanner = new Scanner(System.in); // Scanner for user input
        boolean running = true;

        System.out.println("Production Line Simulator started. Enter commands (ADD_TASK, PROCESS_NEXT, ADD_INVENTORY, VIEW_QUEUE, VIEW_COMPLETED, VIEW_INVENTORY, EXIT).");

        // Class-wide exception handling with try-catch blocks wrapping the main loop
        try {
            while (running) {
                System.out.print("Enter command: ");
                String inputLine = scanner.nextLine().trim();
                if (inputLine.isEmpty()) {
                    continue;
                }

                String[] parts = inputLine.split("\\s+", 4); // Split into command and up to 3 arguments
                String command = parts[0].toUpperCase(); // Case-insensitive command

                // Using switch statement for flow control as required
                switch (command) {
                    case "ADD_TASK":
                        if (parts.length >= 3) {
                            String productType = parts[1];
                            String taskType = parts[2];
                            try {
                                simulator.addTask(productType, taskType);
                            } catch (InsufficientInventoryException | InvalidTaskTypeException e) {
                                System.err.println("Error adding task: " + e.getMessage()); // Use System.err for specific errors
                            }
                        } else {
                            System.err.println("Error: ADD_TASK requires product type and task type (ASSEMBLE/TEST).");
                        }
                        break;

                    case "PROCESS_NEXT":
                        simulator.processNextTask();
                        break;

                    case "ADD_INVENTORY":
                        if (parts.length == 3) {
                            String partName = parts[1];
                            try {
                                int quantity = Integer.parseInt(parts[2]);
                                simulator.addInventory(partName, quantity);
                            } catch (NumberFormatException e) {
                                System.err.println("Error: Invalid quantity for ADD_INVENTORY. Must be a number.");
                            }
                        } else {
                            System.err.println("Error: ADD_INVENTORY requires part name and quantity.");
                        }
                        break;

                    case "VIEW_QUEUE":
                        simulator.viewQueue();
                        break;

                    case "VIEW_COMPLETED":
                        simulator.viewCompleted();
                        break;

                    case "VIEW_INVENTORY":
                        simulator.viewInventory();
                        break;

                    case "EXIT":
                        running = false;
                        System.out.println("Exiting simulator.");
                        break;

                    default:
                        System.err.println("Error: Unknown command. Please use ADD_TASK, PROCESS_NEXT, ADD_INVENTORY, VIEW_QUEUE, VIEW_COMPLETED, VIEW_INVENTORY, or EXIT.");
                        break;
                }
            }
        } catch (Exception e) {
            // Catch any unexpected exceptions during the main loop execution
            System.err.println("An unexpected error occurred: " + e.getMessage());
            e.printStackTrace(System.err); // Print stack trace to System.err
        } finally {
            // Ensure scanner is closed
            scanner.close();
            System.out.println("Scanner closed.");
        }
    }
}
