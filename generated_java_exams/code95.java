/*
 * Exam Question #95
 * Generated on: 2025-05-11 22:13:14
 * Generated by: Account 2
 * 
 * QUESTION:
 * **Exam Task: Customer Service Request Management System**
 * 
 * You are tasked with developing a simple command-line application to manage customer service requests. The system should allow users (simulating agents) to add new requests, process the next pending request, and view the lists of pending and completed requests.
 * 
 * Your solution must demonstrate a strong understanding of core Java data structures, control flow, input handling, and error management.
 * 
 * **Requirements:**
 * 
 * 1.  **Data Structures:**
 *     *   Use a `Queue` to store requests that are waiting to be processed.
 *     *   Use an `ArrayList` (declared as a `List` interface type) to store requests that have been completed.
 *     *   Define a simple `Request` class to represent a service request. Each request should have a unique ID, a description, and a status (e.g., "PENDING", "COMPLETED").
 * 
 * 2.  **Functionality:**
 *     *   **Add Request:** Allow the user to input a description for a new request. The system should generate a unique ID and add the request to the pending queue with "PENDING" status.
 *     *   **Process Next Request:** Remove the request at the front of the pending queue, change its status to "COMPLETED", and move it to the list of completed requests. If the queue is empty, display an appropriate message.
 *     *   **View Pending Requests:** Display all requests currently in the pending queue.
 *     *   **View Completed Requests:** Display all requests currently in the completed list.
 *     *   **Exit:** Terminate the application.
 * 
 * 3.  **User Interface:**
 *     *   Implement a simple command-line menu using `Scanner` for user input.
 *     *   Use a `switch` statement to handle the different menu options.
 *     *   Display menu options clearly using `System.out`.
 *     *   Display request information clearly using `System.out`.
 * 
 * 4.  **Error Handling and Best Practices:**
 *     *   Implement input validation for menu choices (e.g., ensuring a valid integer is entered).
 *     *   Use `System.err` to report invalid input or operational errors (e.g., attempting to process a request when none are pending).
 *     *   Implement class-wide exception handling using `try-catch` blocks to gracefully handle unexpected issues during the main program loop (e.g., non-integer input for menu).
 *     *   Follow best practices for object-oriented design:
 *         *   Use private fields and public methods (encapsulation).
 *         *   Use meaningful variable and method names.
 *         *   Include basic comments or documentation where necessary.
 *         *   Ensure clean code structure.
 * 
 * **Expected Output:**
 * 
 * The program should present a menu like this:
 * 
 * ```
 * --- Service Request Management ---
 * 1. Add New Request
 * 2. Process Next Pending Request
 * 3. View Pending Requests
 * 4. View Completed Requests
 * 5. Exit
 * Enter your choice:
 * ```
 * 
 * Based on user input, the program should perform the requested action and provide feedback. Examples:
 * 
 * *   Adding a request: "Request [ID] added to pending queue."
 * *   Processing a request: "Processed request [ID]. Moved to completed." or "No pending requests to process."
 * *   Viewing lists: Display formatted details of requests in the respective lists.
 * *   Invalid input: "Invalid input. Please enter a number between 1 and 5." (via `System.err`)
 * *   Exception: "An unexpected error occurred: [error message]" (via `System.err`)
 * 
 * Your solution should consist of one or more Java classes that implement the above requirements.
 *
 * EXPLANATION:
 * This solution implements a simple Customer Service Request Management System as required, demonstrating the use of all specified Java components and adhering to best practices.
 * 
 * **Key Concepts Demonstrated:**
 * 
 * 1.  **`java.util.Queue`:** A `LinkedList` is used to implement the `Queue` interface (`pendingRequests`). This structure is suitable for managing items in a First-In, First-Out (FIFO) order, which is natural for a request processing queue. `offer()` is used to add elements (preferred over `add` in queues as it handles capacity constraints, though `LinkedList` is unbounded), and `poll()` is used to remove and return the head of the queue, returning `null` if the queue is empty.
 * 2.  **`java.util.ArrayList` and `java.util.List`:** An `ArrayList` is used to store completed requests (`completedRequests`). It is declared using the `List` interface type (`List<Request> completedRequests = new ArrayList<>();`), which is good practice as it allows for easier changes to the underlying list implementation if needed. `add()` is used to append completed requests to this list.
 * 3.  **`java.util.Scanner`:** Used in the `run()` method to read user input from the console for menu choices and request descriptions. `scanner.nextInt()` reads the integer choice, and `scanner.nextLine()` is used to consume the leftover newline character and read the full request description.
 * 4.  **`switch` statement:** Used in the `run()` method to control the program flow based on the user's menu choice, directing execution to the appropriate method (`addRequest`, `processNextRequest`, `getPendingRequests`, `getCompletedRequests`) or exiting.
 * 5.  **`System.err`:** Used specifically for printing error messages, such as invalid menu input, attempting to process an empty queue, empty request descriptions, and reporting details of caught exceptions. This separates error output from normal program output (`System.out`).
 * 6.  **`System.out`:** Used for displaying the menu, prompting for input, confirming successful operations (like adding or processing a request), and displaying the lists of pending and completed requests.
 * 7.  **Class-wide Exception Handling (`try-catch`)**: The main `run()` method is wrapped in a `try-catch(Exception e)` block. This provides a top-level handler for any unexpected runtime exceptions that might occur within the main application loop, preventing the program from crashing abruptly. A specific `catch (InputMismatchException e)` is included within the loop to handle non-integer input for the menu choice gracefully, printing an error to `System.err` and consuming the bad input to avoid an infinite loop.
 * 8.  **Encapsulation:** The `Request` class fields (`id`, `description`, `status`) and `ServiceSystem` fields (`pendingRequests`, `completedRequests`, `nextRequestId`) are declared as `private`. Public getter methods are provided in the `Request` class, and public methods in `ServiceSystem` (`addRequest`, `processNextRequest`, `getPendingRequests`, `getCompletedRequests`, `run`) provide controlled access to the system's state and functionality.
 * 9.  **Meaningful Names:** Variable names (`pendingRequests`, `completedRequests`, `nextRequestId`, `description`, `choice`), method names (`addRequest`, `processNextRequest`, `getPendingRequests`, `displayMenu`, `run`), and class names (`Request`, `ServiceSystem`) are descriptive and indicate their purpose.
 * 10. **Comments and Documentation:** Basic Javadoc-style comments are included for classes and methods to explain their purpose and parameters. Inline comments clarify specific implementation details (e.g., using `offer` vs `add`, `poll` returning null).
 * 11. **Input Validation:** The code checks if the request description is empty or null before adding it. The `try-catch(InputMismatchException)` handles cases where the user enters non-numeric input for the menu choice. The `default` case in the `switch` handles valid numeric input that is outside the expected menu range.
 * 12. **Error Handling (Logical):** The `processNextRequest` method explicitly checks if `pendingRequests.poll()` returns `null` to determine if the queue is empty before attempting to process, preventing a potential `NullPointerException` and providing a user-friendly message via `System.err`.
 * 13. **Clean Code Structure:** The code is organized into logical classes (`Request` for data, `ServiceSystem` for logic and UI). The `run` method encapsulates the main application loop and interaction logic, keeping the `main` method simple (just creating the system and calling `run`). The `displayMenu` method separates the menu presentation logic.
 * 
 * This solution effectively integrates the required components within a practical scenario, demonstrating robust handling of user input, data management, and error conditions, suitable for evaluating advanced Java programming skills.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.InputMismatchException;

/**
 * Represents a customer service request.
 */
class Request {
    private int id;
    private String description;
    private String status;

    private static final String STATUS_PENDING = "PENDING";
    private static final String STATUS_COMPLETED = "COMPLETED";

    /**
     * Constructs a new Request.
     *
     * @param id The unique identifier for the request.
     * @param description The description of the request.
     */
    public Request(int id, String description) {
        this.id = id;
        this.description = description;
        this.status = STATUS_PENDING; // New requests are always pending
    }

    // --- Getters ---
    public int getId() {
        return id;
    }

    public String getDescription() {
        return description;
    }

    public String getStatus() {
        return status;
    }

    // --- Setters ---
    public void setStatus(String status) {
        // Basic validation could be added here, but for this exam,
        // assuming valid status strings ("PENDING", "COMPLETED").
        this.status = status;
    }

    /**
     * Marks the request as completed.
     */
    public void markCompleted() {
        this.status = STATUS_COMPLETED;
    }

    @Override
    public String toString() {
        return "Request [ID=" + id + ", Description='" + description + "', Status=" + status + "]";
    }
}

/**
 * Manages the queue of pending requests and list of completed requests.
 */
public class ServiceSystem {
    // Use LinkedList as a concrete implementation of Queue
    private Queue<Request> pendingRequests;
    // Use ArrayList as a concrete implementation of List
    private List<Request> completedRequests;
    private int nextRequestId; // Counter for generating unique request IDs

    /**
     * Constructs a new ServiceSystem.
     */
    public ServiceSystem() {
        pendingRequests = new LinkedList<>(); // Queue for pending
        completedRequests = new ArrayList<>(); // List for completed
        nextRequestId = 1; // Start ID from 1
    }

    /**
     * Adds a new request to the pending queue.
     *
     * @param description The description of the request.
     */
    public void addRequest(String description) {
        if (description == null || description.trim().isEmpty()) {
            System.err.println("Error: Request description cannot be empty.");
            return;
        }
        Request newRequest = new Request(nextRequestId++, description.trim());
        pendingRequests.offer(newRequest); // offer is preferred over add for queues
        System.out.println("Request " + newRequest.getId() + " added to pending queue.");
    }

    /**
     * Processes the next request in the pending queue.
     * Moves the request to the completed list.
     */
    public void processNextRequest() {
        Request requestToProcess = pendingRequests.poll(); // poll returns null if queue is empty

        if (requestToProcess == null) {
            System.err.println("No pending requests to process.");
        } else {
            requestToProcess.markCompleted(); // Change status
            completedRequests.add(requestToProcess); // Add to completed list
            System.out.println("Processed request " + requestToProcess.getId() + ". Moved to completed.");
        }
    }

    /**
     * Gets the list of pending requests.
     *
     * @return A List of pending Request objects.
     */
    public List<Request> getPendingRequests() {
        // Returning the direct list is acceptable for this exam scope,
        // but in a real system, you might return an unmodifiable view
        // or a copy to prevent external modification.
        return new ArrayList<>(pendingRequests); // Return a copy for safety
    }

    /**
     * Gets the list of completed requests.
     *
     * @return A List of completed Request objects.
     */
    public List<Request> getCompletedRequests() {
        return completedRequests;
    }

    /**
     * Displays the main menu to the user.
     */
    private void displayMenu() {
        System.out.println("\n--- Service Request Management ---");
        System.out.println("1. Add New Request");
        System.out.println("2. Process Next Pending Request");
        System.out.println("3. View Pending Requests");
        System.out.println("4. View Completed Requests");
        System.out.println("5. Exit");
        System.out.print("Enter your choice: ");
    }

    /**
     * Runs the main application loop.
     */
    public void run() {
        Scanner scanner = new Scanner(System.in);
        boolean running = true;

        // Class-wide exception handling for the main loop
        try {
            while (running) {
                displayMenu();
                int choice = -1; // Default invalid choice

                try {
                    choice = scanner.nextInt();
                    scanner.nextLine(); // Consume the newline character after reading int
                } catch (InputMismatchException e) {
                    System.err.println("Invalid input. Please enter a number between 1 and 5.");
                    scanner.nextLine(); // Consume the invalid input to prevent infinite loop
                    continue; // Skip to the next loop iteration
                }

                // Use switch statement for flow control
                switch (choice) {
                    case 1:
                        System.out.print("Enter request description: ");
                        String description = scanner.nextLine();
                        addRequest(description);
                        break;
                    case 2:
                        processNextRequest();
                        break;
                    case 3:
                        System.out.println("\n--- Pending Requests ---");
                        List<Request> pending = getPendingRequests();
                        if (pending.isEmpty()) {
                            System.out.println("No pending requests.");
                        } else {
                            for (Request req : pending) {
                                System.out.println(req);
                            }
                        }
                        break;
                    case 4:
                        System.out.println("\n--- Completed Requests ---");
                        List<Request> completed = getCompletedRequests();
                        if (completed.isEmpty()) {
                            System.out.println("No completed requests.");
                        } else {
                            for (Request req : completed) {
                                System.out.println(req);
                            }
                        }
                        break;
                    case 5:
                        System.out.println("Exiting Service Request System. Goodbye!");
                        running = false;
                        break;
                    default:
                        System.err.println("Invalid choice. Please enter a number between 1 and 5.");
                }
            }
        } catch (Exception e) {
            // Catch any other unexpected exceptions during execution
            System.err.println("An unexpected error occurred: " + e.getMessage());
            e.printStackTrace(System.err); // Print stack trace to error stream
        } finally {
            scanner.close(); // Ensure scanner is closed
            System.out.println("Scanner closed.");
        }
    }

    /**
     * Main method to start the application.
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        ServiceSystem system = new ServiceSystem();
        system.run();
    }
}
