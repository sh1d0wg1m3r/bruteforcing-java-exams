/*
 * Exam Question #251
 * Generated on: 2025-05-11 22:39:30
 * Generated by: Account 2
 * 
 * QUESTION:
 * ## Advanced Java Programming Exam Task: Task Scheduling System
 * 
 * **Scenario:**
 * 
 * You are tasked with building a simple console-based task scheduling and management system for a small development team. The system should allow users to add tasks to a pending queue, process the next available task, cancel tasks, and view the status of all tasks.
 * 
 * **Requirements:**
 * 
 * Implement the Task Scheduling System in Java according to the following specifications:
 * 
 * 1.  **Task Representation:**
 *     *   Create an `enum` called `TaskStatus` with states: `PENDING`, `COMPLETED`, `CANCELLED`.
 *     *   Create a class called `Task`. Each `Task` object should have:
 *         *   A unique integer `id`.
 *         *   A `String` `description`.
 *         *   An integer `priority` (lower number indicates higher priority, though for this problem, a simple FIFO queue is sufficient, priority can be stored but not actively used for queue ordering).
 *         *   A `TaskStatus` `status`.
 *     *   Implement appropriate constructors, getters for all fields, and a method to update the status (controlled access recommended).
 * 
 * 2.  **Task Scheduler Logic:**
 *     *   Create a class called `TaskScheduler` that manages the tasks.
 *     *   This class must use a `java.util.Queue<Task>` to store tasks that are currently `PENDING`. Use a `LinkedList` as the concrete implementation for the `Queue`.
 *     *   This class must use a `java.util.ArrayList<Task>` to store tasks that have been `COMPLETED`.
 *     *   This class must use another `java.util.ArrayList<Task>` to store tasks that have been `CANCELLED`.
 *     *   Implement the following methods in `TaskScheduler`:
 *         *   `addTask(String description, int priority)`: Creates a new `Task` with a unique ID, sets its status to `PENDING`, and adds it to the pending queue.
 *         *   `processNextTask()`: Removes the task from the front of the pending queue, sets its status to `COMPLETED`, and adds it to the completed tasks list. Handle the case where the pending queue is empty.
 *         *   `cancelTask(int taskId)`: Searches for a task with the given ID in the pending queue. If found, remove it from the queue, set its status to `CANCELLED`, and add it to the cancelled tasks list. Return `true` if a task was cancelled, `false` otherwise.
 *         *   `getPendingTasks()`: Returns a `List<Task>` containing the current pending tasks.
 *         *   `getCompletedTasks()`: Returns a `List<Task>` containing the completed tasks.
 *         *   `getCancelledTasks()`: Returns a `List<Task>` containing the cancelled tasks.
 * 
 * 3.  **Console Interface:**
 *     *   Create a main class (e.g., `TaskManagementApp`) with a `main` method.
 *     *   Use `java.util.Scanner` to read user input from the console.
 *     *   Present a menu of options to the user:
 *         1.  Add Task
 *         2.  Process Next Task
 *         3.  Cancel Task
 *         4.  View All Tasks
 *         5.  Exit
 *     *   Use a `switch` statement to handle the user's choice.
 *     *   For "Add Task", prompt for description and priority.
 *     *   For "Cancel Task", prompt for the Task ID to cancel.
 *     *   For "View All Tasks", display the contents of the pending, completed, and cancelled lists clearly.
 * 
 * 4.  **Error Handling and Output:**
 *     *   Use `System.out` for displaying the menu, prompts, task information, and success messages.
 *     *   Use `System.err` for displaying error messages (e.g., invalid menu choice, non-integer input when an integer is expected, attempting to process when the queue is empty, attempting to cancel a non-existent task).
 *     *   Implement class-wide exception handling using `try-catch` blocks in the main application loop to catch potential exceptions like `InputMismatchException` from the `Scanner` or other unexpected runtime errors, providing a graceful recovery or termination.
 * 
 * 5.  **Best Practices:**
 *     *   Ensure proper encapsulation by making fields private and using public methods for access and modification.
 *     *   Use meaningful variable, method, and class names.
 *     *   Include appropriate comments and Javadoc documentation.
 *     *   Implement input validation where necessary (e.g., check if input is an integer, check if a task ID exists).
 *     *   Ensure clean code structure.
 * 
 * **Expected Output:**
 * 
 * The program should run interactively. Upon starting, it displays the menu. Based on user input, it performs the requested action and provides feedback. Error conditions should be reported on `System.err`. Viewing tasks should list tasks under appropriate headings (Pending, Completed, Cancelled).
 * 
 * **Example Interaction Snippet:**
 * 
 * ```
 * Task Management System
 * Please choose an option:
 * 1. Add Task
 * 2. Process Next Task
 * 3. Cancel Task
 * 4. View All Tasks
 * 5. Exit
 * Enter choice: 1
 * Enter task description: Implement login feature
 * Enter task priority (e.g., 1-10): 5
 * Task added with ID: 1
 * 
 * Task Management System
 * Please choose an option:
 * ... (menu) ...
 * Enter choice: 1
 * Enter task description: Design database schema
 * Enter task priority (e.g., 1-10): 3
 * Task added with ID: 2
 * 
 * Task Management System
 * Please choose an option:
 * ... (menu) ...
 * Enter choice: 4
 * --- Pending Tasks ---
 * ID: 1, Description: Implement login feature, Priority: 5, Status: PENDING
 * ID: 2, Description: Design database schema, Priority: 3, Status: PENDING
 * --- Completed Tasks ---
 * (None)
 * --- Cancelled Tasks ---
 * (None)
 * 
 * Task Management System
 * Please choose an option:
 * ... (menu) ...
 * Enter choice: 2
 * Processed task ID: 1
 * 
 * Task Management System
 * Please choose an option:
 * ... (menu) ...
 * Enter choice: 4
 * --- Pending Tasks ---
 * ID: 2, Description: Design database schema, Priority: 3, Status: PENDING
 * --- Completed Tasks ---
 * ID: 1, Description: Implement login feature, Priority: 5, Status: COMPLETED
 * --- Cancelled Tasks ---
 * (None)
 * 
 * Task Management System
 * Please choose an option:
 * ... (menu) ...
 * Enter choice: 3
 * Enter Task ID to cancel: 2
 * Task ID 2 cancelled.
 * 
 * Task Management System
 * Please choose an option:
 * ... (menu) ...
 * Enter choice: 4
 * --- Pending Tasks ---
 * (None)
 * --- Completed Tasks ---
 * ID: 1, Description: Implement login feature, Priority: 5, Status: COMPLETED
 * --- Cancelled Tasks ---
 * ID: 2, Description: Design database schema, Priority: 3, Status: CANCELLED
 * 
 * Task Management System
 * Please choose an option:
 * ... (menu) ...
 * Enter choice: 2
 * Error: No tasks in the pending queue to process.
 * 
 * Task Management System
 * Please choose an option:
 * ... (menu) ...
 * Enter choice: 3
 * Enter Task ID to cancel: 99
 * Error: Task with ID 99 not found in the pending queue.
 * 
 * Task Management System
 * Please choose an option:
 * ... (menu) ...
 * Enter choice: invalid_input
 * Error: Invalid input. Please enter a number.
 * 
 * Task Management System
 * Please choose an option:
 * ... (menu) ...
 * Enter choice: 5
 * Exiting system.
 * ```
 * 
 * Your solution must be a single Java file containing all necessary classes and the main method.
 * 
 * **Evaluation Criteria:**
 * 
 * *   Correct usage of `Queue`, `ArrayList`, and `List`.
 * *   Correct usage of `Scanner`, `switch`, `System.out`, and `System.err`.
 * *   Effective implementation of `try-catch` for exception handling.
 * *   Adherence to encapsulation and best practices.
 * *   Correct implementation of task management logic (add, process, cancel, view).
 * *   Robust input validation and error handling.
 * *   Clean and readable code.
 *
 * EXPLANATION:
 * The solution implements a simple console-based task management system as requested, demonstrating the use of various Java concepts and collections.
 * 
 * 1.  **`TaskStatus` Enum:** Defines the possible states a task can be in (`PENDING`, `COMPLETED`, `CANCELLED`), providing type safety and readability compared to using simple integers or strings.
 * 
 * 2.  **`Task` Class:** Represents a single task with its properties (`id`, `description`, `priority`, `status`).
 *     *   It uses a `static` counter (`nextId`) to ensure each task gets a unique ID upon creation.
 *     *   Fields are `private` (`id`, `description`, `priority`, `status`) enforcing encapsulation.
 *     *   Public getter methods (`getId`, `getDescription`, `getPriority`, `getStatus`) provide read access.
 *     *   A `setStatus` method is provided, allowing controlled modification of the task's state by the `TaskScheduler`.
 *     *   The `toString()` method is overridden for easy printing of task details.
 * 
 * 3.  **`TaskScheduler` Class:** Manages the collections of tasks and the operations on them.
 *     *   It holds three private collection fields:
 *         *   `pendingTasks`: A `Queue<Task>` implemented using `LinkedList`. The `Queue` interface is ideal for managing a waiting line of tasks where the oldest task is processed first (FIFO - First-In, First-Out), using methods like `offer()` (add) and `poll()` (remove and return head).
 *         *   `completedTasks`: An `ArrayList<Task>`. `ArrayList` is suitable for storing completed tasks as they are typically viewed or iterated over, and random access might be useful (though not explicitly required by this problem).
 *         *   `cancelledTasks`: Another `ArrayList<Task>`, used similarly to `completedTasks`.
 *     *   `addTask()`: Creates a new `Task` and adds it to the `pendingTasks` queue using `offer()`.
 *     *   `processNextTask()`: Uses `pendingTasks.poll()` to retrieve and remove the task at the head of the queue. If the queue is empty, `poll()` returns `null`, which is handled. If a task is retrieved, its status is updated to `COMPLETED`, and it's added to the `completedTasks` list.
 *     *   `cancelTask(int taskId)`: This is the most complex operation involving the queue. It iterates through the `pendingTasks` queue using an `Iterator`. If a task with the matching `taskId` is found, `iterator.remove()` is used to safely remove the element during iteration. The task's status is then set to `CANCELLED`, and it's added to the `cancelledTasks` list. Iteration is necessary because `Queue` implementations typically don't provide efficient random access or removal by arbitrary element/ID.
 *     *   `getPendingTasks()`, `getCompletedTasks()`, `getCancelledTasks()`: These methods return `List<Task>`. `ArrayList` naturally implements the `List` interface. Returning the `List` interface promotes flexibility. `getPendingTasks()` returns a *copy* (`new ArrayList<>(pendingTasks)`) to prevent external code from modifying the internal `Queue` structure directly, upholding encapsulation.
 * 
 * 4.  **`TaskManagementApp` Class:** Contains the `main` method and handles the user interaction.
 *     *   It initializes the `TaskScheduler` and `Scanner`.
 *     *   A `while` loop keeps the application running until the user chooses to exit.
 *     *   Inside the loop:
 *         *   `printMenu()` displays the options using `System.out`.
 *         *   `scanner.nextInt()` reads the integer choice. A subsequent `scanner.nextLine()` is used to consume the leftover newline character, which is crucial before reading string input (`description`) later.
 *         *   A `switch` statement is used to direct the program flow based on the user's `choice`. This directly fulfills the requirement for a switch statement.
 *         *   Each case calls the appropriate `TaskScheduler` method and provides user feedback using `System.out`.
 *         *   Input validation is performed within cases 1 and 3 to ensure the user enters integers for priority and task ID. If `InputMismatchException` occurs, an error is printed to `System.err`, and `scanner.nextLine()` is used to clear the invalid input from the scanner buffer, preventing an infinite loop.
 *         *   Case 4 uses the `displayTasks` helper method to iterate through the lists obtained from the scheduler and print task details using `System.out`.
 *         *   Case 5 sets the `running` flag to `false` to exit the loop.
 *         *   The `default` case in the switch handles invalid integer choices, printing an error to `System.err`.
 * 
 * 5.  **Exception Handling (`try-catch`):**
 *     *   The main `while` loop is wrapped in a `try...finally` block. The `finally` block ensures the `Scanner` is closed when the application exits, even if an unhandled exception occurs within the loop.
 *     *   Inside the `while` loop, a `try...catch` block specifically targets `InputMismatchException` that might occur when reading the menu choice (`scanner.nextInt()`). If the user enters non-integer input, this block catches it, prints an error to `System.err`, and consumes the invalid input.
 *     *   Additional `try-catch` blocks are used within cases 1 and 3 to handle `InputMismatchException` when reading priority and task ID respectively, printing errors to `System.err` and consuming invalid input.
 *     *   A general `catch (Exception e)` block is included inside the main loop's `try` block as a class-wide handler for any other unexpected runtime exceptions, printing a generic error message to `System.err`. This demonstrates robust error handling beyond just expected input issues.
 * 
 * 6.  **Best Practices:**
 *     *   Encapsulation is maintained throughout the `Task` and `TaskScheduler` classes.
 *     *   Names like `pendingTasks`, `processNextTask`, `cancelTask`, `displayTasks` are descriptive.
 *     *   Comments explain the purpose of classes, methods, and key logic points. Javadoc is used for method documentation.
 *     *   Input validation checks for non-negative priority and handles non-integer input.
 *     *   Error messages are informative and directed to `System.err`.
 *     *   The code is structured into logical classes, promoting maintainability.
 * 
 * This solution effectively integrates all required components (`Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.err`, `System.out`, `try-catch`) into a practical, well-structured application with appropriate error handling and adherence to best practices, making it a challenging yet solvable exam task.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.InputMismatchException;
import java.util.Iterator;

// Enum for Task Status
enum TaskStatus {
    PENDING,
    COMPLETED,
    CANCELLED
}

// Class representing a Task
class Task {
    private int id;
    private String description;
    private int priority; // Stored, but queue processing is FIFO in this simple example
    private TaskStatus status;

    // Static counter for unique task IDs
    private static int nextId = 1;

    /**
     * Constructs a new Task.
     * @param description The task description.
     * @param priority The task priority.
     */
    public Task(String description, int priority) {
        this.id = nextId++;
        this.description = description;
        this.priority = priority;
        this.status = TaskStatus.PENDING; // New tasks are always pending
    }

    // Getters
    public int getId() {
        return id;
    }

    public String getDescription() {
        return description;
    }

    public int getPriority() {
        return priority;
    }

    public TaskStatus getStatus() {
        return status;
    }

    /**
     * Sets the status of the task.
     * This method is intended for use by the TaskScheduler.
     * @param status The new status.
     */
    public void setStatus(TaskStatus status) {
        this.status = status;
    }

    @Override
    public String toString() {
        return String.format("ID: %d, Description: %s, Priority: %d, Status: %s",
                             id, description, priority, status);
    }
}

// Class managing the tasks
class TaskScheduler {
    // Queue for tasks waiting to be processed (PENDING)
    private Queue<Task> pendingTasks;
    // List for tasks that have been completed
    private List<Task> completedTasks;
    // List for tasks that have been cancelled
    private List<Task> cancelledTasks;

    /**
     * Constructs a new TaskScheduler.
     * Initializes the collections.
     */
    public TaskScheduler() {
        // LinkedList implements Queue and is suitable for FIFO operations (add/poll)
        this.pendingTasks = new LinkedList<>();
        this.completedTasks = new ArrayList<>();
        this.cancelledTasks = new ArrayList<>();
    }

    /**
     * Adds a new task to the pending queue.
     * @param description The description of the task.
     * @param priority The priority of the task.
     * @return The newly created Task object.
     */
    public Task addTask(String description, int priority) {
        Task newTask = new Task(description, priority);
        pendingTasks.offer(newTask); // offer is preferred over add for queues
        return newTask;
    }

    /**
     * Processes the next task in the pending queue.
     * Removes the task from the pending queue, marks it as COMPLETED, and moves it to the completed list.
     * @return The processed Task object, or null if the pending queue was empty.
     */
    public Task processNextTask() {
        Task taskToProcess = pendingTasks.poll(); // Retrieves and removes the head of the queue
        if (taskToProcess != null) {
            taskToProcess.setStatus(TaskStatus.COMPLETED);
            completedTasks.add(taskToProcess);
            return taskToProcess;
        }
        return null; // No task in queue
    }

    /**
     * Finds and cancels a task by its ID in the pending queue.
     * If found, removes it from the queue, marks it as CANCELLED, and moves it to the cancelled list.
     * @param taskId The ID of the task to cancel.
     * @return true if a task with the given ID was found and cancelled, false otherwise.
     */
    public boolean cancelTask(int taskId) {
        // Iterate through the pending queue to find the task by ID
        Iterator<Task> iterator = pendingTasks.iterator();
        while (iterator.hasNext()) {
            Task task = iterator.next();
            if (task.getId() == taskId) {
                iterator.remove(); // Safely remove the task from the queue using the iterator
                task.setStatus(TaskStatus.CANCELLED);
                cancelledTasks.add(task);
                return true; // Task found and cancelled
            }
        }
        return false; // Task not found in pending queue
    }

    /**
     * Gets a list of all pending tasks.
     * @return A new ArrayList containing the pending tasks.
     */
    public List<Task> getPendingTasks() {
        // Return a copy to prevent external modification of the internal queue structure
        return new ArrayList<>(pendingTasks);
    }

    /**
     * Gets a list of all completed tasks.
     * @return The list of completed tasks.
     */
    public List<Task> getCompletedTasks() {
        return completedTasks; // ArrayList is already a List
    }

    /**
     * Gets a list of all cancelled tasks.
     * @return The list of cancelled tasks.
     */
    public List<Task> getCancelledTasks() {
        return cancelledTasks; // ArrayList is already a List
    }
}

// Main application class
public class TaskManagementApp {

    public static void main(String[] args) {
        TaskScheduler scheduler = new TaskScheduler();
        Scanner scanner = new Scanner(System.in);
        boolean running = true;

        System.out.println("Task Management System");

        // Class-wide exception handling for the main loop
        try {
            while (running) {
                printMenu();
                int choice = -1;
                try {
                    System.out.print("Enter choice: ");
                    choice = scanner.nextInt();
                    scanner.nextLine(); // Consume newline left-over

                    // Switch statement for flow control
                    switch (choice) {
                        case 1: // Add Task
                            System.out.print("Enter task description: ");
                            String description = scanner.nextLine();
                            int priority = -1;
                            System.out.print("Enter task priority (e.g., 1-10): ");
                            // Input validation for priority
                            try {
                                priority = scanner.nextInt();
                                scanner.nextLine(); // Consume newline
                                if (priority < 0) {
                                     System.err.println("Error: Priority must be a non-negative number.");
                                     break; // Exit case 1
                                }
                                Task addedTask = scheduler.addTask(description, priority);
                                System.out.println("Task added with ID: " + addedTask.getId());
                            } catch (InputMismatchException e) {
                                System.err.println("Error: Invalid input for priority. Please enter an integer.");
                                scanner.nextLine(); // Consume the invalid input
                            }
                            break;

                        case 2: // Process Next Task
                            Task processedTask = scheduler.processNextTask();
                            if (processedTask != null) {
                                System.out.println("Processed task ID: " + processedTask.getId());
                            } else {
                                System.err.println("Error: No tasks in the pending queue to process.");
                            }
                            break;

                        case 3: // Cancel Task
                            int taskIdToCancel = -1;
                            System.out.print("Enter Task ID to cancel: ");
                             // Input validation for task ID
                            try {
                                taskIdToCancel = scanner.nextInt();
                                scanner.nextLine(); // Consume newline

                                boolean cancelled = scheduler.cancelTask(taskIdToCancel);
                                if (cancelled) {
                                    System.out.println("Task ID " + taskIdToCancel + " cancelled.");
                                } else {
                                    System.err.println("Error: Task with ID " + taskIdToCancel + " not found in the pending queue.");
                                }
                            } catch (InputMismatchException e) {
                                System.err.println("Error: Invalid input for Task ID. Please enter an integer.");
                                scanner.nextLine(); // Consume the invalid input
                            }
                            break;

                        case 4: // View All Tasks
                            displayTasks(scheduler.getPendingTasks(), "Pending Tasks");
                            displayTasks(scheduler.getCompletedTasks(), "Completed Tasks");
                            displayTasks(scheduler.getCancelledTasks(), "Cancelled Tasks");
                            break;

                        case 5: // Exit
                            running = false;
                            System.out.println("Exiting system.");
                            break;

                        default:
                            System.err.println("Error: Invalid choice. Please enter a number between 1 and 5.");
                    }
                } catch (InputMismatchException e) {
                    System.err.println("Error: Invalid input. Please enter a number.");
                    scanner.nextLine(); // Consume the invalid input
                } catch (Exception e) {
                     // Catch any other unexpected exceptions
                     System.err.println("An unexpected error occurred: " + e.getMessage());
                     // Optionally print stack trace for debugging during development/testing
                     // e.printStackTrace(System.err);
                }
                 System.out.println(); // Add a newline for better readability between operations
            }
        } finally {
             // Ensure scanner is closed even if an exception occurs
             scanner.close();
        }
    }

    /**
     * Prints the main menu to the console.
     */
    private static void printMenu() {
        System.out.println("Please choose an option:");
        System.out.println("1. Add Task");
        System.out.println("2. Process Next Task");
        System.out.println("3. Cancel Task");
        System.out.println("4. View All Tasks");
        System.out.println("5. Exit");
    }

    /**
     * Displays a list of tasks under a given heading.
     * @param tasks The list of tasks to display.
     * @param heading The heading for the list.
     */
    private static void displayTasks(List<Task> tasks, String heading) {
        System.out.println("--- " + heading + " ---");
        if (tasks.isEmpty()) {
            System.out.println("(None)");
        } else {
            for (Task task : tasks) {
                System.out.println(task);
            }
        }
    }
}
