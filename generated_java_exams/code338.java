/*
 * Exam Question #338
 * Generated on: 2025-05-11 22:57:15
 * Generated by: Account 1
 * 
 * QUESTION:
 * **Java Programming Exam Task: Hospital Appointment Management System**
 * 
 * **Scenario:**
 * You are tasked with developing a simplified hospital appointment management system. The system needs to keep track of registered patients and manage a queue of appointments waiting to be seen by a doctor. The system should be interactive, allowing users to perform various operations via a command-line menu.
 * 
 * **Requirements:**
 * 
 * 1.  **Classes:**
 *     *   Create a `Patient` class with private fields for `patientId` (String) and `name` (String). Provide a constructor and public getter methods.
 *     *   Create an `Appointment` class with private fields for the `Patient` object and a `description` (String, e.g., "Routine Checkup", "Follow-up"). Provide a constructor and public getter methods.
 *     *   Create a main class, `HospitalScheduler`, which will contain the `main` method and the core logic for managing patients and appointments.
 * 
 * 2.  **Data Structures:**
 *     *   In the `HospitalScheduler` class, use an `ArrayList` to store registered `Patient` objects. Declare the variable using the `List` interface type (`List<Patient> patientList`).
 *     *   In the `HospitalScheduler` class, use a `Queue` to store `Appointment` objects waiting to be processed. Choose an appropriate implementation (e.g., `java.util.LinkedList`). Declare the variable using the `Queue` interface type (`Queue<Appointment> appointmentQueue`).
 * 
 * 3.  **Functionality (Menu-Driven):**
 *     The `HospitalScheduler` should present a menu to the user with the following options:
 *     *   `1. Add New Patient`: Prompt for patient name, create a `Patient` object with a simple generated ID (e.g., P001, P002, ...), and add it to the `patientList`.
 *     *   `2. Schedule Appointment`: Prompt for patient ID. Find the patient in `patientList`. If found, prompt for appointment description, create an `Appointment` object, and add it to the `appointmentQueue`. If the patient is not found, display an error.
 *     *   `3. View Waiting Appointments`: Display the details of all appointments currently in the `appointmentQueue` without removing them. If the queue is empty, display a message.
 *     *   `4. Process Next Appointment`: Remove and display the details of the next appointment from the front of the `appointmentQueue`. If the queue is empty, display an error.
 *     *   `5. List All Patients`: Display the details of all registered patients in the `patientList`. If the list is empty, display a message.
 *     *   `6. Exit`: Terminate the program.
 * 
 * 4.  **User Input:**
 *     *   Use `java.util.Scanner` to read user input for menu choices and data (patient name, ID, appointment description).
 *     *   Ensure the scanner is properly closed.
 * 
 * 5.  **Control Flow:**
 *     *   Use a `switch` statement to handle the different menu options based on the user's integer input.
 *     *   Use a loop (e.g., `while`) to keep the menu running until the user chooses to exit.
 * 
 * 6.  **Error Handling:**
 *     *   Implement input validation for the menu choice (ensure it's an integer within the valid range). Handle non-integer input.
 *     *   Use `System.err` to display error messages (e.g., "Invalid menu choice", "Patient not found", "Appointment queue is empty", "Invalid input type").
 *     *   Use `try-catch` blocks for exception handling. Include a broad `try-catch` around the main operational loop in `HospitalScheduler` to demonstrate class-wide handling of unexpected errors, in addition to specific catches (like `InputMismatchException` for Scanner).
 *     *   Use `System.out` for normal output (menu, successful operations, lists).
 * 
 * 7.  **Best Practices:**
 *     *   Follow proper encapsulation (private fields, public methods).
 *     *   Use meaningful variable and method names.
 *     *   Add comments to explain the purpose of classes, complex methods, or tricky logic.
 *     *   Format the code cleanly.
 * 
 * **Expected Output:**
 * 
 * The system should display a menu, accept user input, and perform the requested operations, displaying appropriate output or error messages.
 * 
 * *   Example of adding a patient:
 *     ```
 *     Hospital Appointment Scheduler Menu:
 *     1. Add New Patient
 *     2. Schedule Appointment
 *     ...
 *     Enter your choice: 1
 *     Enter patient name: Alice Smith
 *     Patient added: [ID: P001, Name: Alice Smith]
 *     ```
 * *   Example of scheduling an appointment:
 *     ```
 *     Enter your choice: 2
 *     Enter patient ID: P001
 *     Enter appointment description: Routine Checkup
 *     Appointment scheduled for Alice Smith (P001): Routine Checkup
 *     ```
 * *   Example of viewing waiting appointments:
 *     ```
 *     Enter your choice: 3
 *     --- Waiting Appointments ---
 *     1. Patient: Alice Smith (P001), Description: Routine Checkup
 *     2. Patient: Bob Johnson (P002), Description: Follow-up
 *     --------------------------
 *     ```
 * *   Example of processing an appointment:
 *     ```
 *     Enter your choice: 4
 *     Processing appointment for Alice Smith (P001): Routine Checkup
 *     ```
 * *   Example of error handling:
 *     ```
 *     Enter your choice: 7
 *     Invalid menu choice. Please enter a number between 1 and 6.
 *     ```
 *     ```
 *     Enter your choice: abc
 *     Invalid input type. Please enter a number.
 *     ```
 *     ```
 *     Enter your choice: 2
 *     Enter patient ID: P999
 *     Patient with ID P999 not found.
 *     ```
 * 
 * **Time Allotment:** 45-60 minutes
 * 
 * ---
 *
 * EXPLANATION:
 * This solution implements a simple Hospital Appointment Management System demonstrating the required Java concepts.
 * 
 * 1.  **Classes:**
 *     *   `Patient`: A simple Plain Old Java Object (POJO) class storing patient details. It uses private fields (`patientId`, `name`) and public getter methods, demonstrating encapsulation. The `toString()` method provides a convenient way to print patient information.
 *     *   `Appointment`: Another POJO class storing appointment details, including a reference to the `Patient` object and a description. Encapsulation is also applied here. The `toString()` method formats the appointment details for display.
 *     *   `HospitalScheduler`: This is the main class orchestrating the system. It holds the data structures and the application logic.
 * 
 * 2.  **Data Structures:**
 *     *   `List<Patient> patientList = new ArrayList<>();`: An `ArrayList` is used to store `Patient` objects. It's declared using the `List` interface, promoting good practice by programming to the interface rather than the concrete implementation. `ArrayList` provides dynamic resizing and efficient random access (though not heavily used here).
 *     *   `Queue<Appointment> appointmentQueue = new LinkedList<>();`: A `LinkedList` is used to implement the `Queue` interface. A queue is ideal for a waiting list where appointments are processed in the order they are scheduled (First-In, First-Out - FIFO). `LinkedList` efficiently supports additions to the tail (`offer`) and removals from the head (`poll`).
 * 
 * 3.  **Functionality (Menu-Driven):**
 *     *   The `run()` method contains the main application loop.
 *     *   `displayMenu()` prints the available options to `System.out`.
 *     *   The `while (choice != 6)` loop continues until the user chooses 'Exit'.
 *     *   `scanner.nextInt()` reads the integer menu choice. `scanner.nextLine()` is called immediately after to consume the leftover newline character, preventing issues with subsequent `nextLine()` calls.
 *     *   A `switch` statement efficiently directs execution to the appropriate method based on the user's `choice`.
 *     *   Methods like `addNewPatient()`, `scheduleAppointment()`, `viewWaitingAppointments()`, `processNextAppointment()`, and `listAllPatients()` encapsulate the logic for each menu option.
 * 
 * 4.  **User Input:**
 *     *   `java.util.Scanner` is used to read input from `System.in`.
 *     *   The `scanner` object is a class member, created once in the constructor.
 *     *   It's crucial to close the scanner when the application exits, which is handled in the `finally` block.
 * 
 * 5.  **Control Flow:**
 *     *   The `while` loop manages the overall application flow, repeating the menu display and input processing.
 *     *   The `switch` statement handles the branching logic based on the valid menu choices.
 *     *   Methods return early (using `return;`) when errors occur (e.g., patient not found).
 * 
 * 6.  **Error Handling:**
 *     *   `System.err.println()` is used exclusively for displaying error messages, distinguishing them from normal output.
 *     *   Input validation for the menu choice is done within the `switch` statement's `default` case for invalid numbers and by catching `InputMismatchException` for non-numeric input.
 *     *   A specific `try-catch (InputMismatchException e)` block is placed around `scanner.nextInt()` to handle cases where the user enters text instead of a number for the menu choice. The invalid input is consumed using `scanner.nextLine()` to prevent an infinite loop.
 *     *   A broader `try-catch (Exception e)` is included inside the `while` loop's `try` block to catch any other unexpected exceptions that might occur during the execution of a specific menu option's logic.
 *     *   A top-level `try-catch (Exception mainException)` wraps the entire `while` loop in the `run()` method. This serves as the "class-wide" exception handling requested, catching any uncaught exceptions that propagate up from within the loop, preventing the program from crashing abruptly and allowing the `finally` block to execute.
 *     *   The `finally` block ensures that the `scanner` is closed, releasing system resources, regardless of whether the program exits normally or due to an exception.
 *     *   Specific error conditions within methods (like patient not found in `scheduleAppointment` or empty queue in `processNextAppointment`) are checked using `if` statements, and error messages are printed to `System.err`.
 * 
 * 7.  **Best Practices:**
 *     *   Fields in `Patient`, `Appointment`, and `HospitalScheduler` are `private`.
 *     *   Methods are `public` or `private` as appropriate (`run` is public, helpers like `displayMenu`, `addNewPatient` are private).
 *     *   Variable names (`patientList`, `appointmentQueue`, `nextPatientId`, `scanner`, `menuChoice`) and method names (`addNewPatient`, `scheduleAppointment`, `processNextAppointment`, `findPatientById`) are descriptive.
 *     *   Comments explain the purpose of classes, data structures, and key logic sections.
 *     *   The code is structured into logical methods, improving readability and maintainability.
 * 
 * This solution effectively uses all specified components in a practical scenario, demonstrating proper object-oriented design principles, data structure usage, control flow, and robust error handling.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.InputMismatchException;

// Class representing a Patient
class Patient {
    private String patientId;
    private String name;

    public Patient(String patientId, String name) {
        this.patientId = patientId;
        this.name = name;
    }

    public String getPatientId() {
        return patientId;
    }

    public String getName() {
        return name;
    }

    @Override
    public String toString() {
        return "[ID: " + patientId + ", Name: " + name + "]";
    }
}

// Class representing an Appointment
class Appointment {
    private Patient patient;
    private String description;

    public Appointment(Patient patient, String description) {
        this.patient = patient;
        this.description = description;
    }

    public Patient getPatient() {
        return patient;
    }

    public String getDescription() {
        return description;
    }

    @Override
    public String toString() {
        return "Patient: " + patient.getName() + " (" + patient.getPatientId() + "), Description: " + description;
    }
}

// Main class for the Hospital Appointment Scheduler
public class HospitalScheduler {

    // Use List interface type, implemented by ArrayList
    private List<Patient> patientList;
    // Use Queue interface type, implemented by LinkedList
    private Queue<Appointment> appointmentQueue;
    private Scanner scanner;
    private int nextPatientId = 1; // Counter for generating unique patient IDs

    public HospitalScheduler() {
        patientList = new ArrayList<>();
        appointmentQueue = new LinkedList<>(); // LinkedList is a common Queue implementation
        scanner = new Scanner(System.in);
    }

    // Method to display the main menu
    private void displayMenu() {
        System.out.println("\nHospital Appointment Scheduler Menu:");
        System.out.println("1. Add New Patient");
        System.out.println("2. Schedule Appointment");
        System.out.println("3. View Waiting Appointments");
        System.out.println("4. Process Next Appointment");
        System.out.println("5. List All Patients");
        System.out.println("6. Exit");
        System.out.print("Enter your choice: ");
    }

    // Method to run the scheduler
    public void run() {
        int choice = -1;
        // Class-wide try-catch for the main operational loop
        try {
            while (choice != 6) {
                displayMenu();
                try {
                    // Specific try-catch for reading integer input
                    choice = scanner.nextInt();
                    scanner.nextLine(); // Consume newline left-over

                    // Use switch statement for menu handling
                    switch (choice) {
                        case 1:
                            addNewPatient();
                            break;
                        case 2:
                            scheduleAppointment();
                            break;
                        case 3:
                            viewWaitingAppointments();
                            break;
                        case 4:
                            processNextAppointment();
                            break;
                        case 5:
                            listAllPatients();
                            break;
                        case 6:
                            System.out.println("Exiting Hospital Scheduler. Goodbye!");
                            break;
                        default:
                            // Handle invalid menu numbers
                            System.err.println("Invalid menu choice. Please enter a number between 1 and 6.");
                    }
                } catch (InputMismatchException e) {
                    // Handle non-integer input for menu choice
                    System.err.println("Invalid input type. Please enter a number.");
                    scanner.nextLine(); // Consume the invalid input to prevent infinite loop
                    choice = -1; // Reset choice to stay in loop
                } catch (Exception e) {
                    // Catch any other unexpected exceptions during an operation
                    System.err.println("An unexpected error occurred during operation: " + e.getMessage());
                    // e.printStackTrace(); // Uncomment for detailed debugging
                }
            }
        } catch (Exception mainException) {
            // Broad catch for any exception not handled elsewhere in the main run loop
            System.err.println("A critical error occurred in the scheduler: " + mainException.getMessage());
            mainException.printStackTrace(); // Print stack trace for critical errors
        } finally {
            // Ensure scanner is closed regardless of how the loop exits or errors occur
            if (scanner != null) {
                scanner.close();
                System.out.println("Scanner closed."); // Optional: confirm closure
            }
        }
    }

    // Option 1: Add New Patient
    private void addNewPatient() {
        System.out.print("Enter patient name: ");
        String name = scanner.nextLine();
        String patientId = String.format("P%03d", nextPatientId++);
        Patient newPatient = new Patient(patientId, name);
        patientList.add(newPatient);
        System.out.println("Patient added: " + newPatient);
    }

    // Option 2: Schedule Appointment
    private void scheduleAppointment() {
        System.out.print("Enter patient ID: ");
        String patientId = scanner.nextLine().trim(); // Read ID and trim whitespace

        Patient patient = findPatientById(patientId);

        if (patient == null) {
            System.err.println("Patient with ID " + patientId + " not found.");
            return;
        }

        System.out.print("Enter appointment description: ");
        String description = scanner.nextLine();

        Appointment newAppointment = new Appointment(patient, description);
        appointmentQueue.offer(newAppointment); // offer is generally preferred over add for queues
        System.out.println("Appointment scheduled for " + patient.getName() + " (" + patient.getPatientId() + "): " + description);
    }

    // Helper method to find a patient by ID
    private Patient findPatientById(String patientId) {
        for (Patient p : patientList) {
            if (p.getPatientId().equalsIgnoreCase(patientId)) { // Case-insensitive comparison for ID
                return p;
            }
        }
        return null; // Patient not found
    }

    // Option 3: View Waiting Appointments
    private void viewWaitingAppointments() {
        if (appointmentQueue.isEmpty()) {
            System.out.println("No appointments currently waiting.");
            return;
        }

        System.out.println("--- Waiting Appointments ---");
        int i = 1;
        // Iterate without removing elements (using enhanced for loop or iterator)
        for (Appointment appt : appointmentQueue) {
            System.out.println(i++ + ". " + appt);
        }
        System.out.println("--------------------------");
    }

    // Option 4: Process Next Appointment
    private void processNextAppointment() {
        Appointment nextAppointment = appointmentQueue.poll(); // poll retrieves and removes the head

        if (nextAppointment == null) {
            System.err.println("Appointment queue is empty. Nothing to process.");
        } else {
            System.out.println("Processing appointment for " + nextAppointment.getPatient().getName() +
                    " (" + nextAppointment.getPatient().getPatientId() + "): " + nextAppointment.getDescription());
            // In a real system, you'd add more logic here (e.g., mark as completed)
        }
    }

    // Option 5: List All Patients
    private void listAllPatients() {
        if (patientList.isEmpty()) {
            System.out.println("No patients registered yet.");
            return;
        }

        System.out.println("--- Registered Patients ---");
        for (int i = 0; i < patientList.size(); i++) {
            System.out.println((i + 1) + ". " + patientList.get(i));
        }
        System.out.println("--------------------------");
    }

    // Main method to start the application
    public static void main(String[] args) {
        HospitalScheduler scheduler = new HospitalScheduler();
        scheduler.run();
    }
}
