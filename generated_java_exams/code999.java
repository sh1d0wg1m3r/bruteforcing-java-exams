/*
 * Exam Question #999
 * Generated on: 2025-05-12 17:10:49
 * Generated by: Account 4
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Support Ticket Processing System
 * 
 * **Scenario:**
 * 
 * You are tasked with building a simplified command-line application to simulate a support ticket processing system. The system should manage support tickets, allowing users to add new tickets, process the oldest pending ticket, and view the lists of pending and completed tickets.
 * 
 * **Task:**
 * 
 * Implement a Java program that fulfills the following requirements:
 * 
 * 1.  **`SupportTicket` Class:** Create a class named `SupportTicket` to represent a single ticket. It should contain:
 *     *   A unique integer ID.
 *     *   A string description of the issue.
 *     *   A string status (e.g., "Pending", "Completed").
 *     *   Appropriate private fields and public getter methods.
 *     *   A constructor to initialize the ticket with an ID and description (status should default to "Pending").
 *     *   A method to mark the ticket as "Completed".
 *     *   An overridden `toString()` method for easy printing of ticket details.
 * 
 * 2.  **`TicketProcessingSystem` Class:** Create a class named `TicketProcessingSystem` to manage the collections of tickets. It should contain:
 *     *   A `Queue` (from `java.util.Queue`) to store pending `SupportTicket` objects. Use an appropriate concrete implementation like `LinkedList`.
 *     *   A `List` (from `java.util.List`) to store completed `SupportTicket` objects. Use the `ArrayList` concrete implementation.
 *     *   A mechanism to generate unique ticket IDs (e.g., an instance variable counter).
 *     *   Appropriate private fields and public methods for the following operations:
 *         *   `addTicket(String description)`: Creates a new `SupportTicket`, assigns it the next unique ID, and adds it to the pending queue. Should validate that the description is not null or empty.
 *         *   `processNextTicket()`: Removes the oldest ticket from the pending queue, marks it as "Completed", and adds it to the completed list. This method should handle the case where the pending queue is empty.
 *         *   `viewPendingTickets()`: Prints details of all tickets currently in the pending queue.
 *         *   `viewCompletedTickets()`: Prints details of all tickets in the completed list.
 * 
 * 3.  **Main Application (`SupportSystemApp` class):** Create a class with a `main` method to run the application.
 *     *   Use `java.util.Scanner` to get user input from the console.
 *     *   Implement a menu-driven interface with the following options:
 *         1.  Add New Ticket
 *         2.  Process Next Ticket
 *         3.  View Pending Tickets
 *         4.  View Completed Tickets
 *         5.  Exit
 *     *   Use a `switch` statement to handle the user's menu choice.
 *     *   Display normal program output (menu, prompts, successful operations, ticket lists) using `System.out`.
 *     *   Display error messages (e.g., invalid menu choice, empty ticket description, trying to process an empty queue, invalid input format) using `System.err`.
 *     *   Implement class-wide exception handling using `try-catch` blocks within the main loop to gracefully handle potential issues such as `NumberFormatException` (for non-integer input), `IllegalArgumentException` (for invalid ticket data), or a custom exception (e.g., `EmptyQueueException`) if trying to process from an empty queue.
 * 
 * **Best Practices:**
 * 
 * *   Adhere to proper encapsulation (private fields, public methods).
 * *   Use meaningful variable and method names.
 * *   Include appropriate comments and documentation (e.g., Javadoc comments for public methods).
 * *   Implement input validation where necessary (e.g., ticket description).
 * *   Ensure proper error handling using `try-catch` and `System.err`.
 * *   Maintain a clean and organized code structure.
 * 
 * **Expected Output & Interaction:**
 * 
 * The program should present a menu, accept user input, perform the requested action, and display results or errors.
 * 
 * Example Interaction (Illustrative):
 * 
 * ```
 * --- Support Ticket Processing System ---
 * 
 * --- Menu ---
 * 1. Add New Ticket
 * 2. Process Next Ticket
 * 3. View Pending Tickets
 * 4. View Completed Tickets
 * 5. Exit
 * ------------
 * Enter your choice: 1
 * Enter ticket description: Printer not working
 * 
 * Ticket #1 added to the queue.
 * 
 * --- Menu ---
 * ...
 * Enter your choice: 1
 * Enter ticket description: Network issue in office 3B
 * 
 * Ticket #2 added to the queue.
 * 
 * --- Menu ---
 * ...
 * Enter your choice: 3
 * 
 * --- Pending Tickets ---
 * Ticket #1 [Status: Pending] - Printer not working
 * Ticket #2 [Status: Pending] - Network issue in office 3B
 * -----------------------
 * 
 * --- Menu ---
 * ...
 * Enter your choice: 2
 * 
 * Processed ticket: Ticket #1 [Status: Completed] - Printer not working
 * 
 * --- Menu ---
 * ...
 * Enter your choice: 2
 * 
 * Processed ticket: Ticket #2 [Status: Completed] - Network issue in office 3B
 * 
 * --- Menu ---
 * ...
 * Enter your choice: 2
 * Error: No pending tickets to process.
 * 
 * --- Menu ---
 * ...
 * Enter your choice: 4
 * 
 * --- Completed Tickets ---
 * Ticket #1 [Status: Completed] - Printer not working
 * Ticket #2 [Status: Completed] - Network issue in office 3B
 * -------------------------
 * 
 * --- Menu ---
 * ...
 * Enter your choice: abc
 * Invalid input. Please enter a number.
 * 
 * --- Menu ---
 * ...
 * Enter your choice: 6
 * Invalid choice. Please enter a number between 1 and 5.
 * 
 * --- Menu ---
 * ...
 * Enter your choice: 5
 * Exiting system. Goodbye!
 * ```
 * 
 * Your code should compile and run, allowing the user to interact with the system as described.
 * 
 * **Evaluation Criteria:**
 * 
 * *   Correct usage of `Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.err`, `System.out`.
 * *   Effective implementation of `try-catch` for exception handling.
 * *   Proper class design and encapsulation.
 * *   Meaningful variable and method names.
 * *   Input validation and error handling robustness.
 * *   Clean code structure and comments.
 *
 * EXPLANATION:
 * The provided solution implements a basic Support Ticket Processing System as requested, demonstrating the required Java concepts and best practices.
 * 
 * **Core Design:**
 * 
 * 1.  **`SupportTicket` Class:** This class serves as a simple Plain Old Java Object (POJO) representing a single data item (a ticket). It encapsulates the ticket's state (`ticketId`, `description`, `status`) using private fields and provides public getters and a `complete()` method to control state changes. The `toString()` method provides a convenient way to display ticket information.
 * 
 * 2.  **`TicketProcessingSystem` Class:** This class acts as the system's core logic and data manager.
 *     *   It uses a `java.util.Queue<SupportTicket>` (`pendingTickets`) implemented by `java.util.LinkedList`. The `Queue` is ideal here because tickets are processed in the order they are received (First-In, First-Out - FIFO). The `add()` method adds to the tail, and `poll()` removes from the head.
 *     *   It uses a `java.util.List<SupportTicket>` (`completedTickets`) implemented by `java.util.ArrayList`. The `List` is suitable for storing completed tickets where the order might be maintained (order of completion) but access is primarily for viewing or potentially later searching/indexing, which `ArrayList` supports efficiently.
 *     *   The `nextTicketId` counter ensures each new ticket receives a unique ID.
 *     *   Methods like `addTicket`, `processNextTicket`, `viewPendingTickets`, and `viewCompletedTickets` encapsulate the operations on the ticket collections.
 * 
 * 3.  **`SupportSystemApp` Class:** This contains the `main` method and provides the user interface.
 *     *   A `java.util.Scanner` is used to read input from the console. Using `scanner.nextLine()` and then parsing is a robust way to handle mixed input types and avoid common `Scanner` pitfalls.
 *     *   A `while` loop keeps the application running until the user chooses to exit.
 *     *   A `printMenu()` helper method keeps the `main` method clean.
 *     *   A `switch` statement is used to direct control flow based on the user's numeric menu choice, fulfilling a specific requirement.
 * 
 * **Required Component Usage:**
 * 
 * *   `Queue`: Used for `pendingTickets` to manage FIFO processing.
 * *   `ArrayList`: Used as the concrete implementation for the `completedTickets` `List`.
 * *   `List` interface: Used as the declared type for the `completedTickets` variable, promoting good practice (programming to interfaces).
 * *   `Scanner`: Used in `main` to read user input.
 * *   `Switch`: Used in `main` to handle the menu options.
 * *   `System.err`: Used specifically for printing error messages, such as invalid input, invalid choices, or operational errors (like an empty queue).
 * *   `System.out`: Used for all standard output, including the menu, prompts, success messages, and ticket lists.
 * *   `try-catch` blocks: Implemented in the `main` method to wrap the input reading and operation calls. This provides class-wide exception handling for potential `NumberFormatException` (if input isn't an integer), `IllegalArgumentException` (if `addTicket` receives invalid data), and the custom `EmptyQueueException`.
 * 
 * **Exception Handling and Validation:**
 * 
 * *   **Input Format:** A `try-catch(NumberFormatException)` block around `Integer.parseInt(input)` handles cases where the user enters non-numeric text for the menu choice, printing an error to `System.err`.
 * *   **Invalid Menu Choice:** The `default` case in the `switch` handles integer inputs that are outside the valid range (1-5), printing an error to `System.err`.
 * *   **Invalid Ticket Data:** The `addTicket` method includes validation (`description.trim().isEmpty()`) and throws an `IllegalArgumentException` if the description is invalid. This exception is caught in `main`, and an error message is printed to `System.err`.
 * *   **Empty Queue:** The `processNextTicket` method checks if the `pendingTickets` queue is empty using `poll()` which returns `null`. If it's empty, it throws a custom `EmptyQueueException`. This custom exception is caught in `main`, and a specific error message is printed to `System.err`. This demonstrates creating and using a specific exception type for a domain-specific error condition.
 * *   **General Exception:** A final `catch(Exception e)` block is included to catch any other unexpected runtime errors, ensuring the program doesn't crash abruptly.
 * 
 * **Best Practices:**
 * 
 * *   **Encapsulation:** Achieved by making fields `private` and providing controlled access through `public` methods.
 * *   **Meaningful Names:** Variables (`pendingTickets`, `nextTicketId`), methods (`processNextTicket`, `viewPendingTickets`), and classes (`SupportTicket`, `TicketProcessingSystem`) have names that clearly indicate their purpose.
 * *   **Comments and Documentation:** Javadoc-style comments are used for public classes and methods, explaining their function, parameters, and potential exceptions. Inline comments clarify specific logic points.
 * *   **Clean Code Structure:** The code is organized into separate classes with specific responsibilities (`SupportTicket` for data, `TicketProcessingSystem` for logic/state, `SupportSystemApp` for UI/main loop). The `printMenu` method extracts UI logic. Using `try-with-resources` for the `Scanner` ensures it's properly closed.
 * 
 * This solution effectively combines the required Java components within a practical scenario, demonstrating understanding of data structures, object-oriented principles, user interaction, and robust error handling, making it suitable for a challenging exam task.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;

// Custom exception for when the queue is empty
class EmptyQueueException extends Exception {
    /**
     * Constructs an EmptyQueueException with the specified detail message.
     * @param message The detail message.
     */
    public EmptyQueueException(String message) {
        super(message);
    }
}

/**
 * Represents a single support ticket.
 */
class SupportTicket {
    private int ticketId;
    private String description;
    private String status; // e.g., "Pending", "Completed"

    /**
     * Constructs a new SupportTicket.
     * @param ticketId The unique ID for the ticket.
     * @param description The description of the support issue.
     */
    public SupportTicket(int ticketId, String description) {
        this.ticketId = ticketId;
        this.description = description;
        this.status = "Pending"; // Default status
    }

    // --- Getters ---
    public int getTicketId() {
        return ticketId;
    }

    public String getDescription() {
        return description;
    }

    public String getStatus() {
        return status;
    }

    /**
     * Marks the ticket's status as "Completed".
     */
    public void complete() {
        this.status = "Completed";
    }

    /**
     * Provides a string representation of the ticket.
     * @return A formatted string describing the ticket.
     */
    @Override
    public String toString() {
        return "Ticket #" + ticketId + " [Status: " + status + "] - " + description;
    }
}

/**
 * Manages the collection of support tickets using a queue for pending
 * and a list for completed tickets.
 */
class TicketProcessingSystem {
    // Queue to hold tickets waiting to be processed (FIFO)
    private Queue<SupportTicket> pendingTickets;
    // List to hold tickets that have been processed
    private List<SupportTicket> completedTickets;
    // Counter for generating unique ticket IDs
    private int nextTicketId;

    /**
     * Constructs a new TicketProcessingSystem, initializing the queues and ID counter.
     */
    public TicketProcessingSystem() {
        // LinkedList is a common implementation of the Queue interface
        this.pendingTickets = new LinkedList<>();
        // ArrayList is a common implementation of the List interface
        this.completedTickets = new ArrayList<>();
        this.nextTicketId = 1; // Start ticket IDs from 1
    }

    /**
     * Adds a new ticket to the pending queue.
     * @param description The description of the ticket.
     * @throws IllegalArgumentException if the description is null or empty/whitespace.
     */
    public void addTicket(String description) throws IllegalArgumentException {
        if (description == null || description.trim().isEmpty()) {
            // Use IllegalArgumentException for invalid method arguments
            throw new IllegalArgumentException("Ticket description cannot be empty.");
        }
        // Create new ticket with unique ID and add to the pending queue
        SupportTicket newTicket = new SupportTicket(nextTicketId++, description.trim());
        pendingTickets.add(newTicket);
        System.out.println("Ticket #" + newTicket.getTicketId() + " added to the queue.");
    }

    /**
     * Processes the next ticket in the pending queue (removes, completes, moves to completed list).
     * @return The processed SupportTicket object.
     * @throws EmptyQueueException if the pending queue is empty.
     */
    public SupportTicket processNextTicket() throws EmptyQueueException {
        // poll() retrieves and removes the head of the queue, returns null if empty
        SupportTicket nextTicket = pendingTickets.poll();
        if (nextTicket == null) {
            // Throw custom exception if no tickets are pending
            throw new EmptyQueueException("No pending tickets to process.");
        }
        // Mark ticket as completed and add to the completed list
        nextTicket.complete();
        completedTickets.add(nextTicket);
        return nextTicket;
    }

    /**
     * Displays all tickets currently in the pending queue.
     */
    public void viewPendingTickets() {
        System.out.println("\n--- Pending Tickets ---");
        if (pendingTickets.isEmpty()) {
            System.out.println("No pending tickets.");
        } else {
            // Iterate through the queue without removing elements
            for (SupportTicket ticket : pendingTickets) {
                System.out.println(ticket);
            }
        }
        System.out.println("-----------------------");
    }

    /**
     * Displays all tickets that have been completed.
     */
    public void viewCompletedTickets() {
        System.out.println("\n--- Completed Tickets ---");
        if (completedTickets.isEmpty()) {
            System.out.println("No completed tickets.");
        } else {
            // Iterate through the list
            for (SupportTicket ticket : completedTickets) {
                System.out.println(ticket);
            }
        }
        System.out.println("-------------------------");
    }
}

/**
 * Main application class for the Support Ticket Processing System.
 * Handles user interaction and system operations.
 */
public class SupportSystemApp {

    /**
     * Prints the main menu options to the console.
     */
    private static void printMenu() {
        System.out.println("\n--- Menu ---");
        System.out.println("1. Add New Ticket");
        System.out.println("2. Process Next Ticket");
        System.out.println("3. View Pending Tickets");
        System.out.println("4. View Completed Tickets");
        System.out.println("5. Exit");
        System.out.println("------------");
    }

    /**
     * The main entry point for the application.
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        // Use try-with-resources for Scanner to ensure it's closed
        try (Scanner scanner = new Scanner(System.in)) {
            TicketProcessingSystem system = new TicketProcessingSystem();
            boolean running = true;

            System.out.println("--- Support Ticket Processing System ---");

            while (running) {
                printMenu();
                System.out.print("Enter your choice: ");

                try {
                    // Read the entire line to avoid issues with nextInt() followed by nextLine()
                    String input = scanner.nextLine();
                    int choice = Integer.parseInt(input); // Potential NumberFormatException

                    // Use switch statement for menu navigation
                    switch (choice) {
                        case 1:
                            System.out.print("Enter ticket description: ");
                            String description = scanner.nextLine();
                            // Call system method; potential IllegalArgumentException
                            system.addTicket(description);
                            break;
                        case 2:
                            try {
                                // Call system method; potential EmptyQueueException
                                SupportTicket processed = system.processNextTicket();
                                System.out.println("Processed ticket: " + processed);
                            } catch (EmptyQueueException e) {
                                // Use System.err for specific operational errors
                                System.err.println("Error: " + e.getMessage());
                            }
                            break;
                        case 3:
                            system.viewPendingTickets();
                            break;
                        case 4:
                            system.viewCompletedTickets();
                            break;
                        case 5:
                            System.out.println("Exiting system. Goodbye!");
                            running = false; // Exit the loop
                            break;
                        default:
                            // Use System.err for invalid menu choices
                            System.err.println("Invalid choice. Please enter a number between 1 and 5.");
                    }
                } catch (NumberFormatException e) {
                    // Use System.err for input format errors
                    System.err.println("Invalid input. Please enter a number.");
                } catch (IllegalArgumentException e) {
                     // Use System.err for validation errors from addTicket
                     System.err.println("Error: " + e.getMessage());
                } catch (Exception e) {
                     // Catch any other unexpected exceptions for robustness
                     System.err.println("An unexpected error occurred: " + e.getMessage());
                     // e.printStackTrace(); // Uncomment for debugging if needed
                }
                System.out.println(); // Add a blank line for better readability between operations
            }
        } // Scanner is automatically closed here by try-with-resources
    }
}
