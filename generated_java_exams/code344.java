/*
 * Exam Question #344
 * Generated on: 2025-05-11 22:58:07
 * Generated by: Account 2
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Technical Support Ticket System
 * 
 * **Scenario:**
 * You are tasked with building a simplified technical support ticket management system. The system should allow users to submit new support tickets, process the oldest pending ticket, and view lists of open and closed tickets.
 * 
 * **Requirements:**
 * 
 * 1.  **Implement a `SupportTicket` class:**
 *     *   Should have `private` fields for a unique ticket ID (auto-generated), description, and status (e.g., "Open", "Closed").
 *     *   Provide a constructor to create new tickets with a description, automatically assigning an ID and setting the status to "Open".
 *     *   Include public getter methods for its fields.
 *     *   Include a public method to set the status (e.g., `setStatus(String status)`).
 *     *   Override the `toString()` method to provide a user-friendly representation of the ticket.
 * 
 * 2.  **Implement a `SupportSystem` class:**
 *     *   Manage open tickets using a `java.util.Queue`. Tickets should be processed in the order they were submitted (FIFO).
 *     *   Manage closed tickets using a `java.util.List` (specifically, use `java.util.ArrayList` as the implementation).
 *     *   Include a public method `submitTicket(String description)` that creates a new `SupportTicket` and adds it to the open tickets queue. Implement input validation to ensure the description is not empty.
 *     *   Include a public method `processNextTicket()` that removes the oldest ticket from the open queue, sets its status to "Closed", and adds it to the closed tickets list. This method should handle the case where the open queue is empty by throwing a custom exception.
 *     *   Include public methods `getOpenTickets()` and `getClosedTickets()` that return the respective collections.
 * 
 * 3.  **Implement a main application class (e.g., `SupportSystemApp`) with a `main` method:**
 *     *   Create an instance of `SupportSystem`.
 *     *   Use `java.util.Scanner` to interact with the user via the console.
 *     *   Present a menu with the following options:
 *         1.  Submit New Ticket
 *         2.  Process Next Ticket
 *         3.  List Open Tickets
 *         4.  List Closed Tickets
 *         5.  Exit
 *     *   Use a `switch` statement to handle the user's menu choice.
 *     *   Implement a loop to keep the application running until the user chooses to exit.
 *     *   Use `System.out` for normal output (menu, prompts, ticket listings, confirmation messages).
 *     *   Use `System.err` for error messages (invalid input, attempting to process an empty queue, empty description).
 *     *   Implement class-wide exception handling using `try-catch` blocks to gracefully handle potential issues like invalid user input (e.g., non-numeric input for menu choice) or errors from the `SupportSystem` methods (e.g., attempting to process a ticket when none are available). Include specific catches for expected errors and a general catch for unexpected ones.
 * 
 * 4.  **Create a custom exception class `NoTicketsAvailableException`** that extends `Exception` to be thrown by `processNextTicket()` when the queue is empty.
 * 
 * **Best Practices:**
 * 
 * *   Apply proper encapsulation (`private` fields, public methods).
 * *   Use meaningful variable and method names.
 * *   Include appropriate comments and documentation (Javadocs).
 * *   Perform necessary input validation.
 * *   Implement robust error handling using exceptions and `System.err`.
 * *   Ensure a clean and organized code structure.
 * 
 * **Expected Output/Behavior:**
 * 
 * *   The menu should be displayed repeatedly until the user exits.
 * *   Selecting '1' should prompt for a description, submit the ticket, and confirm submission. An empty description should result in an error message on `System.err`.
 * *   Selecting '2' should process the oldest ticket, confirm processing, and print the processed ticket details. If the queue is empty, an error message should be printed on `System.err`.
 * *   Selecting '3' should list all tickets currently in the open queue, or indicate if the queue is empty.
 * *   Selecting '4' should list all tickets currently in the closed list, or indicate if the list is empty.
 * *   Selecting '5' should exit the application.
 * *   Entering an invalid number for the menu choice should print an error message on `System.err`.
 * *   Entering non-numeric input for the menu choice should be caught by exception handling, print an error message on `System.err`, and the menu should reappear.
 * *   Any unexpected errors during the main loop should be caught and reported on `System.err`.
 * 
 * Your solution should consist of the complete Java code for all necessary classes.
 *
 * EXPLANATION:
 * The provided solution implements a basic technical support ticket management system, demonstrating the required Java concepts and best practices.
 * 
 * 1.  **`SupportTicket` Class:** This class serves as a simple data structure representing a single support ticket. It uses `private` fields (`ticketId`, `description`, `status`) for encapsulation. A `static` field `nextId` ensures each new ticket gets a unique, auto-incrementing ID. Getters provide access to the data, and a `setStatus` method allows changing the ticket's state. The `toString()` method provides a convenient way to print ticket information.
 * 
 * 2.  **`NoTicketsAvailableException` Class:** This is a custom checked exception specifically created to signal the business logic error condition when an attempt is made to process a ticket from an empty queue. Using a custom exception makes the error handling in the calling code more specific and readable.
 * 
 * 3.  **`SupportSystem` Class:** This class is the core of the system logic.
 *     *   It uses a `java.util.Queue<SupportTicket>` named `openTickets` to store tickets awaiting processing. A `LinkedList` is chosen as the implementation because it efficiently supports the `Queue` operations (`offer` to add to the end, `poll` to remove from the front), which are essential for First-In, First-Out (FIFO) behavior required for processing the oldest ticket.
 *     *   It uses a `java.util.List<SupportTicket>` named `closedTickets` to store tickets that have been processed. An `ArrayList` is chosen as the implementation, suitable for storing a dynamic collection of items where element access and addition are common operations. The problem explicitly requires using the `List` interface, which is done by declaring the field as `List` and instantiating it as `ArrayList`.
 *     *   The `submitTicket` method adds a new ticket to the `openTickets` queue using `offer()`. It includes input validation for the description, throwing an `IllegalArgumentException` if it's empty.
 *     *   The `processNextTicket` method retrieves and removes the head of the `openTickets` queue using `poll()`. If `poll()` returns `null` (meaning the queue is empty), it throws the custom `NoTicketsAvailableException`. Otherwise, it updates the ticket's status and adds it to the `closedTickets` list.
 *     *   `getOpenTickets` and `getClosedTickets` provide access to the underlying collections.
 * 
 * 4.  **`SupportSystemApp` Class:** This is the main application class containing the `main` method and the user interface logic.
 *     *   It initializes `SupportSystem` and `Scanner`.
 *     *   The `run` method contains the main application loop.
 *     *   Inside the loop, it displays a menu using `System.out`.
 *     *   It reads the user's integer choice using `scanner.nextInt()`. A call to `scanner.nextLine()` immediately after `nextInt()` is crucial to consume the leftover newline character, preventing issues with subsequent `scanner.nextLine()` calls when reading the ticket description.
 *     *   A `switch` statement handles the different menu options, calling the appropriate methods in the `SupportSystem` instance.
 *     *   `System.out` is used for all standard output, including the menu, prompts, success messages, and ticket listings.
 *     *   `System.err` is specifically used for error messages, such as invalid menu choices, non-numeric input, empty descriptions, and the "no tickets available" error. This adheres to the convention of sending error output to the standard error stream.
 *     *   **Exception Handling:**
 *         *   A `try-catch (InputMismatchException e)` block is placed inside the loop to specifically catch errors if the user enters non-numeric input when prompted for a menu choice. It prints an error on `System.err` and consumes the invalid input from the scanner to prevent an infinite loop.
 *         *   `try-catch` blocks are used around calls to `supportSystem.submitTicket()` and `supportSystem.processNextTicket()` to catch the specific `IllegalArgumentException` (for empty description) and `NoTicketsAvailableException`, respectively. These catches also print error messages to `System.err`.
 *         *   A broader `try-catch (Exception e)` block is wrapped around the entire `while` loop in the `run()` method. This serves as the "class-wide" or top-level handler, catching any other unexpected runtime exceptions that might occur within the loop and printing an error to `System.err` along with the stack trace for debugging.
 *         *   A `finally` block ensures the `Scanner` resource is closed when the `run` method finishes or is exited due to an exception.
 * 
 * This solution effectively integrates all required Java components (`Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.err`, `System.out`, `try-catch`) into a practical scenario, while adhering to key object-oriented principles and error handling best practices.
 */

import java.util.ArrayList;
import java.util.InputMismatchException;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;

/**
 * Represents a technical support ticket.
 */
class SupportTicket {
    private static int nextId = 1; // Static counter for unique ticket IDs

    private int ticketId;
    private String description;
    private String status; // Could be an enum, but String is simpler for exam

    /**
     * Constructs a new SupportTicket with an auto-generated ID and initial status.
     * @param description The description of the issue.
     */
    public SupportTicket(String description) {
        this.ticketId = nextId++;
        this.description = description;
        this.status = "Open"; // Initial status
    }

    // Getters
    public int getTicketId() {
        return ticketId;
    }

    public String getDescription() {
        return description;
    }

    public String getStatus() {
        return status;
    }

    // Setter for status (used when processing)
    public void setStatus(String status) {
        this.status = status;
    }

    /**
     * Returns a string representation of the ticket.
     * @return String representation.
     */
    @Override
    public String toString() {
        return "Ticket [ID=" + ticketId + ", Status=" + status + ", Description='" + description + "']";
    }
}

/**
 * Custom exception thrown when attempting to process a ticket from an empty queue.
 */
class NoTicketsAvailableException extends Exception {
    /**
     * Constructs a new NoTicketsAvailableException with a default message.
     */
    public NoTicketsAvailableException() {
        super("No open tickets available to process.");
    }

    /**
     * Constructs a new NoTicketsAvailableException with the specified detail message.
     * @param message The detail message.
     */
    public NoTicketsAvailableException(String message) {
        super(message);
    }
}

/**
 * Manages the system for support tickets, holding open tickets in a queue
 * and closed tickets in a list.
 */
class SupportSystem {
    // Use LinkedList as a Queue implementation for FIFO processing
    private Queue<SupportTicket> openTickets;
    // Use ArrayList as a List implementation for storing closed tickets
    private List<SupportTicket> closedTickets;

    /**
     * Constructs a new SupportSystem, initializing the ticket queues and lists.
     */
    public SupportSystem() {
        this.openTickets = new LinkedList<>(); // Queue for open tickets
        this.closedTickets = new ArrayList<>(); // List for closed tickets
    }

    /**
     * Submits a new support ticket to the system.
     * Adds the ticket to the end of the open tickets queue.
     * @param description The description of the issue.
     * @throws IllegalArgumentException if the description is null or empty after trimming whitespace.
     */
    public void submitTicket(String description) {
        if (description == null || description.trim().isEmpty()) {
            throw new IllegalArgumentException("Ticket description cannot be empty.");
        }
        SupportTicket newTicket = new SupportTicket(description.trim());
        openTickets.offer(newTicket); // Add to the end of the queue (FIFO)
        System.out.println("Submitted ticket: " + newTicket); // Use System.out for confirmation
    }

    /**
     * Processes the next available ticket from the queue.
     * Removes the oldest ticket from the open queue, sets its status to "Closed",
     * and adds it to the list of closed tickets.
     * @return The processed SupportTicket.
     * @throws NoTicketsAvailableException if the open ticket queue is empty.
     */
    public SupportTicket processNextTicket() throws NoTicketsAvailableException {
        SupportTicket nextTicket = openTickets.poll(); // Retrieve and remove the head of the queue
        if (nextTicket == null) {
            // Throw custom exception if queue is empty
            throw new NoTicketsAvailableException();
        }
        nextTicket.setStatus("Closed"); // Update status
        closedTickets.add(nextTicket); // Add to the list of closed tickets
        System.out.println("Processed ticket: " + nextTicket); // Use System.out for confirmation
        return nextTicket;
    }

    /**
     * Gets the queue of currently open support tickets.
     * @return The Queue of open tickets.
     */
    public Queue<SupportTicket> getOpenTickets() {
        return openTickets; // Returning the reference is acceptable for this problem level
    }

    /**
     * Gets the list of currently closed support tickets.
     * @return The List of closed tickets.
     */
    public List<SupportTicket> getClosedTickets() {
        return closedTickets; // Returning the reference is acceptable for this problem level
    }
}

/**
 * Main application class for the Support Ticket Management System.
 * Provides a command-line interface for interacting with the system.
 */
public class SupportSystemApp {

    private SupportSystem supportSystem;
    private Scanner scanner;

    /**
     * Constructs the SupportSystemApp, initializing the SupportSystem and Scanner.
     */
    public SupportSystemApp() {
        this.supportSystem = new SupportSystem();
        this.scanner = new Scanner(System.in);
    }

    /**
     * Displays the main menu options to the user.
     */
    private void displayMenu() {
        System.out.println("\n--- Support Ticket System Menu ---");
        System.out.println("1. Submit New Ticket");
        System.out.println("2. Process Next Ticket");
        System.out.println("3. List Open Tickets");
        System.out.println("4. List Closed Tickets");
        System.out.println("5. Exit");
        System.out.print("Enter your choice: ");
    }

    /**
     * Runs the main application loop.
     * Handles user input and calls appropriate SupportSystem methods.
     * Implements class-wide exception handling.
     */
    public void run() {
        int choice = 0;
        boolean running = true;

        // Class-wide exception handling for the main application loop
        try {
            while (running) {
                displayMenu();

                // Specific try-catch for handling input issues within the loop iteration
                try {
                    choice = scanner.nextInt();
                    scanner.nextLine(); // Consume the newline character left by nextInt()

                    // Use switch statement for flow control based on user choice
                    switch (choice) {
                        case 1:
                            System.out.print("Enter ticket description: ");
                            String description = scanner.nextLine();
                            try {
                                supportSystem.submitTicket(description);
                            } catch (IllegalArgumentException e) {
                                // Use System.err for validation errors
                                System.err.println("Error: " + e.getMessage());
                            }
                            break;
                        case 2:
                            try {
                                supportSystem.processNextTicket();
                            } catch (NoTicketsAvailableException e) {
                                // Use System.err for business logic errors (empty queue)
                                System.err.println("Error: " + e.getMessage());
                            }
                            break;
                        case 3:
                            System.out.println("\n--- Open Tickets ---");
                            Queue<SupportTicket> openTickets = supportSystem.getOpenTickets();
                            if (openTickets.isEmpty()) {
                                System.out.println("No open tickets."); // Use System.out for normal messages
                            } else {
                                // Iterate and print tickets from the queue (maintaining order)
                                openTickets.forEach(System.out::println);
                            }
                            break;
                        case 4:
                            System.out.println("\n--- Closed Tickets ---");
                            List<SupportTicket> closedTickets = supportSystem.getClosedTickets();
                            if (closedTickets.isEmpty()) {
                                System.out.println("No closed tickets."); // Use System.out for normal messages
                            } else {
                                // Iterate and print tickets from the list
                                closedTickets.forEach(System.out::println);
                            }
                            break;
                        case 5:
                            System.out.println("Exiting system. Goodbye!"); // Use System.out for normal messages
                            running = false; // Set flag to exit loop
                            break;
                        default:
                            // Use System.err for invalid menu choices
                            System.err.println("Invalid choice. Please enter a number between 1 and 5.");
                    }
                } catch (InputMismatchException e) {
                    // Use System.err for scanner input type errors
                    System.err.println("Invalid input. Please enter a number.");
                    scanner.nextLine(); // IMPORTANT: Consume the invalid input to prevent infinite loop
                }
                // Any other specific exceptions from called methods could be caught here if needed
            }
        } catch (Exception e) {
            // General catch block for any unexpected exceptions in the main loop
            System.err.println("An unexpected error occurred: " + e.getMessage());
            e.printStackTrace(); // Print stack trace for debugging unexpected errors
        } finally {
            // Ensure the scanner resource is closed when the application finishes or errors out
            if (scanner != null) {
                scanner.close();
            }
            System.out.println("Application finished."); // Final message
        }
    }

    /**
     * Main method to start the application.
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        SupportSystemApp app = new SupportSystemApp();
        app.run(); // Start the main application loop
    }
}
