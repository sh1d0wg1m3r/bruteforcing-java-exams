/*
 * Exam Question #1129
 * Generated on: 2025-05-12 17:28:53
 * Generated by: Account 1
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Support Ticket Processing System
 * 
 * **Scenario:**
 * 
 * You are tasked with developing a simple command-line application to simulate a basic support ticket processing system. The system should manage incoming support tickets, allow processing of tickets in the order they were received, and keep a record of resolved tickets.
 * 
 * **Requirements:**
 * 
 * 1.  **Ticket Representation:** Create a `Ticket` class with private fields for `ticketId` (an integer, auto-generated) and `description` (a String). Include a constructor, getter methods for the fields, and a `toString()` method to display ticket information.
 * 2.  **System Class:** Create a main class, `SupportTicketSystem`, which will manage the ticket processing.
 * 3.  **Data Structures:**
 *     *   Use a `java.util.Queue<Ticket>` to store pending tickets (tickets waiting to be processed).
 *     *   Use a `java.util.List<Ticket>` to store resolved tickets (tickets that have been processed). The implementation should be `java.util.ArrayList`.
 * 4.  **Functionality:** The system should present a menu to the user with the following options:
 *     *   **1. Add New Ticket:** Prompt the user for a ticket description, create a new `Ticket` object with a unique ID, and add it to the queue of pending tickets.
 *     *   **2. Process Next Ticket:** Remove the next ticket from the pending queue and add it to the list of resolved tickets. If the queue is empty, display an appropriate error message.
 *     *   **3. View Pending Tickets:** Display all tickets currently in the pending queue, without removing them.
 *     *   **4. View Resolved Tickets:** Display all tickets currently in the list of resolved tickets.
 *     *   **5. Exit:** Terminate the application.
 * 5.  **User Input:** Use `java.util.Scanner` to read user input for menu choices and ticket descriptions.
 * 6.  **Control Flow:** Use a `switch` statement to handle the user's menu choice.
 * 7.  **Output:**
 *     *   Use `System.out` for displaying the menu, prompts, ticket details, and success messages.
 *     *   Use `System.err` to display error messages (e.g., invalid input, attempting to process an empty queue, empty description).
 * 8.  **Error Handling:**
 *     *   Implement input validation for the menu choice (ensure it's an integer within the valid range). Handle non-integer input and out-of-range choices using `try-catch` blocks and `System.err`.
 *     *   Implement error handling for attempting to process a ticket when the pending queue is empty. Report this error using `System.err`.
 *     *   Implement a class-wide exception handling mechanism (e.g., a `try-catch` block wrapping the main application loop) to catch unexpected errors.
 * 9.  **Best Practices:**
 *     *   Apply proper encapsulation (private fields, public methods).
 *     *   Use meaningful variable and method names.
 *     *   Include appropriate comments and documentation where necessary.
 *     *   Validate user input where applicable (e.g., non-empty ticket description).
 *     *   Ensure clean code structure.
 * 
 * **Expected Output:**
 * 
 * The program should run interactively, displaying a menu, prompting for input, and providing feedback based on the user's actions. Examples:
 * 
 * ```
 * --- Support Ticket System ---
 * 
 * --- Menu ---
 * 1. Add New Ticket
 * 2. Process Next Ticket
 * 3. View Pending Tickets
 * 4. View Resolved Tickets
 * 5. Exit
 * Enter your choice: 1
 * --- Add New Ticket ---
 * Enter ticket description: My printer is not working.
 * Ticket added: Ticket [ID=1, Description='My printer is not working.']
 * 
 * --- Menu ---
 * ... (menu repeats)
 * Enter your choice: 1
 * --- Add New Ticket ---
 * Enter ticket description: Need help with software installation.
 * Ticket added: Ticket [ID=2, Description='Need help with software installation.']
 * 
 * --- Menu ---
 * ... (menu repeats)
 * Enter your choice: 3
 * --- Pending Tickets ---
 * Ticket [ID=1, Description='My printer is not working.']
 * Ticket [ID=2, Description='Need help with software installation.']
 * 
 * --- Menu ---
 * ... (menu repeats)
 * Enter your choice: 2
 * --- Process Next Ticket ---
 * Processed ticket: Ticket [ID=1, Description='My printer is not working.']
 * 
 * --- Menu ---
 * ... (menu repeats)
 * Enter your choice: 4
 * --- Resolved Tickets ---
 * Ticket [ID=1, Description='My printer is not working.']
 * 
 * --- Menu ---
 * ... (menu repeats)
 * Enter your choice: 2
 * --- Process Next Ticket ---
 * Processed ticket: Ticket [ID=2, Description='Need help with software installation.']
 * 
 * --- Menu ---
 * ... (menu repeats)
 * Enter your choice: 2
 * --- Process Next Ticket ---
 * Error: No pending tickets to process.
 * 
 * --- Menu ---
 * ... (menu repeats)
 * Enter your choice: abc
 * Invalid input. Please enter a number.
 * 
 * --- Menu ---
 * ... (menu repeats)
 * Enter your choice: 9
 * Invalid choice. Please enter a number between 1 and 5.
 * 
 * --- Menu ---
 * ... (menu repeats)
 * Enter your choice: 5
 * Exiting Support Ticket System. Goodbye!
 * Scanner closed.
 * ```
 * 
 * Your solution should be a single Java file containing both the `Ticket` and `SupportTicketSystem` classes.
 *
 * EXPLANATION:
 * This solution implements a basic Support Ticket Processing System demonstrating the required Java concepts and best practices.
 * 
 * 1.  **Ticket Class:** A simple POJO (`Plain Old Java Object`) representing a ticket with an ID and description. Encapsulation is achieved by making fields private and providing public getter methods. A `toString()` method provides a convenient way to display ticket information.
 * 
 * 2.  **SupportTicketSystem Class:** This is the main class orchestrating the system.
 *     *   **Data Structures:**
 *         *   `private Queue<Ticket> pendingTickets;`: A `Queue` is used for pending tickets because it naturally supports FIFO (First-In, First-Out) processing, which is typical for ticket queues. `LinkedList` is a common implementation of the `Queue` interface.
 *         *   `private List<Ticket> resolvedTickets;`: A `List` is used for resolved tickets as their order of processing is maintained, and we might want to access them by index later (though not required by this problem, `List` provides this flexibility). `ArrayList` is chosen as the concrete implementation, declared using the `List` interface reference as requested.
 *     *   **State Variables:** `nextTicketId` ensures unique IDs, and `scanner` manages user input.
 *     *   **Encapsulation:** All state variables (`pendingTickets`, `resolvedTickets`, `nextTicketId`, `scanner`) are declared as `private`.
 *     *   **Methods:** Public methods (`addNewTicket`, `processNextTicket`, `viewPendingTickets`, `viewResolvedTickets`, `run`) provide the system's functionality. `displayMenu` is a private helper method.
 * 
 * 3.  **Main Loop (`run` method):**
 *     *   The core of the application is a `while(running)` loop that continuously displays the menu and processes user input until the user chooses to exit.
 *     *   **Input Handling:** `scanner.nextLine()` is used to read the entire line of input for the menu choice. This is crucial to prevent issues that can arise when mixing `nextInt()` (which doesn't consume the newline character) and `nextLine()`.
 *     *   **Input Validation & Error Handling (Inner try-catch):** An inner `try-catch` block is used specifically for parsing the input string into an integer (`Integer.parseInt`). If the user enters non-numeric input, a `NumberFormatException` is caught, an error message is printed to `System.err`, and `continue` skips the rest of the loop iteration, prompting the user again.
 *     *   **Switch Statement:** The `switch (choice)` block directs the program flow to the appropriate method based on the validated integer input. The `default` case handles valid integers that are outside the expected menu range.
 *     *   **System.out vs. System.err:** `System.out` is used for standard output like the menu, prompts, and successful operation messages. `System.err` is used exclusively for reporting errors, such as invalid input, empty queue conditions, or empty description validation.
 *     *   **Processing Logic:**
 *         *   `addNewTicket`: Reads description, validates it's not empty, creates a `Ticket`, and adds it to the `pendingTickets` queue using `offer()`.
 *         *   `processNextTicket`: Checks if `pendingTickets` is empty first. If not, it removes the next ticket using `poll()` (which returns null if empty, but we checked first) and adds it to the `resolvedTickets` list using `add()`. An error is printed to `System.err` if the queue is empty.
 *         *   `viewPendingTickets` and `viewResolvedTickets`: Iterate through the respective collections (queue and list) and print each ticket's `toString()` representation. `forEach(System.out::println)` is a concise way to do this. Note that iterating the queue does not remove elements.
 * 
 * 4.  **Class-Wide Exception Handling (Outer try-catch):** The main `while` loop within the `run()` method is wrapped in a `try-catch(Exception e)` block. This serves as a fallback mechanism to catch any unexpected runtime exceptions that might occur anywhere within the main application loop, preventing the program from crashing abruptly and providing a generic error message to `System.err`. While specific error conditions (like empty queue or invalid input format) are handled by more targeted checks and inner `try-catch`, this outer block provides robustness against unforeseen issues.
 * 
 * 5.  **Resource Management (finally):** The `finally` block ensures that the `scanner` resource is closed when the `run()` method finishes, regardless of whether it finishes normally or due to an exception caught by the outer `try-catch`. This is important for preventing resource leaks.
 * 
 * This solution effectively uses the required Java components (`Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.err`, `System.out`, `try-catch`) in a practical scenario, adhering to good programming practices like encapsulation, meaningful names, input validation, and comprehensive error handling.
 */

import java.util.Queue;
import java.util.LinkedList; // Common Queue implementation
import java.util.List;
import java.util.ArrayList;
import java.util.Scanner;
import java.util.InputMismatchException; // Although not strictly needed with nextLine() parsing

/**
 * Represents a support ticket in the system.
 */
class Ticket {
    private int ticketId;
    private String description;

    /**
     * Constructs a new Ticket.
     * @param ticketId The unique identifier for the ticket.
     * @param description The description of the support issue.
     */
    public Ticket(int ticketId, String description) {
        this.ticketId = ticketId;
        this.description = description;
    }

    /**
     * Gets the ticket ID.
     * @return The ticket ID.
     */
    public int getTicketId() {
        return ticketId;
    }

    /**
     * Gets the ticket description.
     * @return The ticket description.
     */
    public String getDescription() {
        return description;
    }

    /**
     * Provides a string representation of the Ticket.
     * @return A formatted string displaying ticket ID and description.
     */
    @Override
    public String toString() {
        return "Ticket [ID=" + ticketId + ", Description='" + description + "']";
    }
}

/**
 * Manages the Support Ticket Processing System.
 * Handles adding, processing, and viewing support tickets.
 */
public class SupportTicketSystem {

    // Queue to hold tickets that are waiting to be processed.
    private Queue<Ticket> pendingTickets;
    // List to hold tickets that have been processed. Declared as List interface.
    private List<Ticket> resolvedTickets; // Implemented using ArrayList

    private int nextTicketId; // Counter for assigning unique ticket IDs.
    private Scanner scanner; // Scanner for reading user input.

    /**
     * Constructs a new SupportTicketSystem, initializing collections and scanner.
     */
    public SupportTicketSystem() {
        // Initialize the Queue using LinkedList
        pendingTickets = new LinkedList<>();
        // Initialize the List using ArrayList
        resolvedTickets = new ArrayList<>();
        nextTicketId = 1; // Start ticket IDs from 1
        scanner = new Scanner(System.in);
    }

    /**
     * Adds a new ticket to the pending queue based on user input.
     */
    public void addNewTicket() {
        System.out.println("\n--- Add New Ticket ---");
        System.out.print("Enter ticket description: ");
        String description = scanner.nextLine(); // Read the entire line

        // Input validation: Check if description is empty or just whitespace
        if (description == null || description.trim().isEmpty()) {
            System.err.println("Error: Ticket description cannot be empty.");
            return; // Exit the method if validation fails
        }

        // Create a new Ticket object and add it to the pending queue
        Ticket newTicket = new Ticket(nextTicketId++, description.trim());
        pendingTickets.offer(newTicket); // offer() is preferred over add() for queues
        System.out.println("Ticket added: " + newTicket);
    }

    /**
     * Processes the next ticket from the pending queue, moving it to the resolved list.
     */
    public void processNextTicket() {
        System.out.println("\n--- Process Next Ticket ---");
        // Check if the pending queue is empty before attempting to process
        if (pendingTickets.isEmpty()) {
            System.err.println("Error: No pending tickets to process.");
            return; // Exit the method if queue is empty
        }

        // Remove the head of the queue (the next ticket to be processed)
        Ticket processedTicket = pendingTickets.poll(); // poll() removes and returns the head
        // Add the processed ticket to the list of resolved tickets
        resolvedTickets.add(processedTicket);

        System.out.println("Processed ticket: " + processedTicket);
    }

    /**
     * Displays all tickets currently in the pending queue.
     */
    public void viewPendingTickets() {
        System.out.println("\n--- Pending Tickets ---");
        if (pendingTickets.isEmpty()) {
            System.out.println("No pending tickets.");
        } else {
            // Iterate through the queue and print each ticket
            // Using forEach and lambda for concise iteration
            pendingTickets.forEach(System.out::println);
        }
    }

    /**
     * Displays all tickets currently in the resolved list.
     */
    public void viewResolvedTickets() {
        System.out.println("\n--- Resolved Tickets ---");
        if (resolvedTickets.isEmpty()) {
            System.out.println("No resolved tickets.");
        } else {
            // Iterate through the list and print each ticket
            resolvedTickets.forEach(System.out::println);
        }
    }

    /**
     * Displays the main menu options to the user.
     */
    private void displayMenu() {
        System.out.println("\n--- Menu ---");
        System.out.println("1. Add New Ticket");
        System.out.println("2. Process Next Ticket");
        System.out.println("3. View Pending Tickets");
        System.out.println("4. View Resolved Tickets");
        System.out.println("5. Exit");
    }

    /**
     * Runs the main application loop, handling user interaction and menu navigation.
     */
    public void run() {
        System.out.println("--- Support Ticket System ---");
        boolean running = true;

        // Class-wide try-catch block to handle unexpected exceptions during the main loop execution.
        try {
            while (running) {
                displayMenu();
                System.out.print("Enter your choice: ");

                int choice = -1; // Default value for choice

                // Inner try-catch block for handling potential NumberFormatException
                // when parsing user input.
                try {
                    // Read the entire line to avoid issues with nextInt() followed by nextLine()
                    String inputLine = scanner.nextLine();
                    choice = Integer.parseInt(inputLine); // Attempt to parse the input string as an integer
                } catch (NumberFormatException e) {
                    // Handle cases where the input is not a valid integer.
                    System.err.println("Invalid input. Please enter a number.");
                    continue; // Skip the rest of the loop iteration and show menu again.
                }

                // Use a switch statement to control the flow based on the user's choice.
                switch (choice) {
                    case 1:
                        addNewTicket(); // Call method to add a new ticket.
                        break;
                    case 2:
                        processNextTicket(); // Call method to process the next ticket.
                        break;
                    case 3:
                        viewPendingTickets(); // Call method to view pending tickets.
                        break;
                    case 4:
                        viewResolvedTickets(); // Call method to view resolved tickets.
                        break;
                    case 5:
                        System.out.println("Exiting Support Ticket System. Goodbye!");
                        running = false; // Set flag to false to exit the loop.
                        break;
                    default:
                        // Handle choices that are integers but outside the valid range [1, 5].
                        System.err.println("Invalid choice. Please enter a number between 1 and 5.");
                }
            }
        } catch (Exception e) {
            // Catch any other unexpected exceptions that might occur within the loop.
            System.err.println("An unexpected error occurred: " + e.getMessage());
            // e.printStackTrace(); // Uncomment for detailed debugging information
        } finally {
            // This block ensures the scanner is closed when the application exits,
            // whether normally or due to an exception.
            if (scanner != null) {
                scanner.close();
            }
            System.out.println("Scanner closed."); // Indicate that the scanner resource is released.
        }
    }

    /**
     * The main entry point of the application.
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        // Create an instance of the SupportTicketSystem and start it.
        SupportTicketSystem system = new SupportTicketSystem();
        system.run();
    }
}
