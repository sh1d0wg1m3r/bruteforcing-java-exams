/*
 * Exam Question #266
 * Generated on: 2025-05-11 22:46:51
 * Generated by: Account 5
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Advanced Task Scheduler Simulation
 * 
 * **Scenario:**
 * 
 * You are tasked with building a simple command-line Task Scheduler simulation. The scheduler should manage tasks that are waiting to be processed in a queue and maintain a history of tasks that have been completed. Users should be able to interact with the scheduler via a menu to add new tasks, process the next available task, view the list of pending tasks, view the list of completed tasks, and exit the application.
 * 
 * **Requirements:**
 * 
 * Implement a Java program that simulates this Task Scheduler. Your solution must adhere to the following:
 * 
 * 1.  **Class Structure:** Create two classes:
 *     *   `Task`: Represents a single task with a unique integer ID and a String description.
 *     *   `TaskScheduler`: Manages the task queue and the list of completed tasks, handles user interaction, and contains the main application logic.
 * 2.  **Data Structures:**
 *     *   Use `java.util.Queue` (specifically, an implementation like `LinkedList`) to store tasks waiting to be processed. Tasks should be processed in a First-In, First-Out (FIFO) manner.
 *     *   Use `java.util.ArrayList` to store the history of completed tasks.
 *     *   Declare the history of completed tasks using the `java.util.List` interface type.
 * 3.  **User Input:** Use `java.util.Scanner` to read user commands and task descriptions from the console.
 * 4.  **Control Flow:** Use a `switch` statement to handle the different menu options selected by the user.
 * 5.  **Output:**
 *     *   Use `System.out.println` for normal output, such as the menu, task details, confirmations, and lists of tasks.
 *     *   Use `System.err.println` for displaying error messages, such as attempting to process a task when the queue is empty or handling invalid input.
 * 6.  **Exception Handling:** Implement class-wide exception handling in the `TaskScheduler` class using `try-catch` blocks to gracefully handle potential runtime errors during user interaction (e.g., invalid input format).
 * 7.  **Best Practices:**
 *     *   Implement proper encapsulation (private fields, public methods).
 *     *   Use meaningful variable and method names.
 *     *   Include appropriate comments and documentation (e.g., Javadoc for classes/methods).
 *     *   Perform basic input validation (e.g., check if the queue is empty before processing).
 *     *   Structure the code cleanly.
 * 
 * **Menu Options:**
 * 
 * The program should present the following menu to the user:
 * 
 * ```
 * Task Scheduler Menu:
 * 1. Add New Task
 * 2. Process Next Task
 * 3. View Pending Tasks
 * 4. View Completed Tasks
 * 5. Exit
 * Enter your choice:
 * ```
 * 
 * **Functionality Details:**
 * 
 * *   **Add New Task:** Prompt the user for a task description, create a new `Task` object with a unique ID (incrementing from 1), and add it to the task queue.
 * *   **Process Next Task:** Remove the task at the front of the queue, add it to the completed tasks list, and print a confirmation. If the queue is empty, print an error message to `System.err`.
 * *   **View Pending Tasks:** Print the details (ID and description) of all tasks currently in the queue, in the order they will be processed. If the queue is empty, print a message indicating that.
 * *   **View Completed Tasks:** Print the details (ID and description) of all tasks in the completed tasks list. If the list is empty, print a message indicating that.
 * *   **Exit:** Terminate the program.
 * 
 * **Expected Output:**
 * 
 * The output should be interactive based on user input. Examples:
 * 
 * *   Adding a task: `Task added: [ID] - [Description]`
 * *   Processing a task: `Processing task: [ID] - [Description]` or `Error: The task queue is empty.` (to System.err)
 * *   Viewing pending: List of tasks or `Pending task queue is empty.`
 * *   Viewing completed: List of tasks or `No tasks have been completed yet.`
 * *   Invalid input: `Error: Invalid input. Please enter a number.` (to System.err) or `Error: Invalid menu choice. Please enter a number between 1 and 5.` (to System.err)
 * 
 * **Time Limit:** Assume this task should be completable within 45-60 minutes.
 *
 * EXPLANATION:
 * This solution implements the Task Scheduler simulation using the required Java components and following best practices.
 * 
 * 1.  **`Task` Class:**
 *     *   This is a simple Plain Old Java Object (POJO) representing a task.
 *     *   It has `private` fields (`id`, `description`) demonstrating encapsulation.
 *     *   It provides public getter methods (`getId`, `getDescription`).
 *     *   The `toString()` method is overridden to provide a convenient string representation for printing.
 * 
 * 2.  **`TaskScheduler` Class:**
 *     *   This is the main class containing the application logic.
 *     *   **`Queue<Task> taskQueue;`**: Declared as `Queue` interface type, initialized with `LinkedList`. `LinkedList` is a common implementation of `Queue` and provides the necessary FIFO behavior (`offer` to add, `poll` to remove from the head).
 *     *   **`List<Task> completedTasks;`**: Declared as `List` interface type, initialized with `ArrayList`. `ArrayList` is used to store the history of completed tasks, allowing easy addition and iteration.
 *     *   **`int nextTaskId;`**: A simple counter to generate unique IDs for tasks, demonstrating a basic state management within the class.
 *     *   **`Scanner scanner;`**: Used for reading user input from `System.in`.
 *     *   **Constructor:** Initializes the `taskQueue`, `completedTasks`, `nextTaskId`, and `scanner`.
 *     *   **`addTask(String description)`:** Creates a new `Task` object using the `nextTaskId` and provided description, then adds it to the `taskQueue` using `offer()`. `offer()` is generally preferred over `add()` for queues as it returns `false` if the addition fails (though `LinkedList`'s `offer` won't fail in practice unless memory is exhausted). The `nextTaskId` is incremented for the next task.
 *     *   **`processNextTask()`:** Uses `taskQueue.poll()` to retrieve and remove the task at the head of the queue. `poll()` returns `null` if the queue is empty, which is handled by printing an error message to `System.err`. If a task is retrieved, it's added to the `completedTasks` list.
 *     *   **`viewTaskQueue()`:** Checks if the `taskQueue` is empty. If not, it iterates through the queue using an enhanced for loop (`for (Task task : taskQueue)`) to print each task without removing it.
 *     *   **`viewCompletedTasks()`:** Checks if the `completedTasks` list is empty. If not, it iterates through the list to print each completed task.
 *     *   **`displayMenu()`:** A private helper method to print the menu options to `System.out`.
 *     *   **`runScheduler()`:**
 *         *   Contains the main application loop (`while(running)`).
 *         *   **Class-wide Exception Handling:** The core logic within the loop is wrapped in a `try-catch(Exception e)` block. This demonstrates catching *any* unexpected `Exception` that might occur during the execution of the scheduler's main loop, providing a fallback error message to `System.err` and printing the stack trace for debugging.
 *         *   **Input Handling:** Inside the loop, there's an inner `try-catch(InputMismatchException e)` specifically to handle cases where the user enters non-integer input for the menu choice. It prints an error to `System.err` and consumes the invalid input from the scanner to prevent an infinite loop.
 *         *   **`switch (choice)`:** A `switch` statement is used to direct the program flow based on the valid integer input received from the user.
 *         *   Each case calls the appropriate method (`addTask`, `processNextTask`, etc.).
 *         *   Case 1 includes a basic check for an empty task description.
 *         *   The `default` case handles integer inputs that are not valid menu options, printing an error to `System.err`.
 *         *   The `finally` block ensures that the `Scanner` is closed when the `runScheduler` method exits, releasing system resources.
 *     *   **`main(String[] args)`:** The entry point of the application. It creates a `TaskScheduler` instance and calls `runScheduler()` to start the simulation.
 * 
 * This solution effectively uses the required Java components (`Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.err`, `System.out`, `try-catch`) in a practical scenario, demonstrates key object-oriented principles like encapsulation, and includes important aspects of robust programming like input validation and error handling.
 */

import java.util.Queue;
import java.util.LinkedList;
import java.util.List;
import java.util.ArrayList;
import java.util.Scanner;
import java.util.InputMismatchException;

/**
 * Represents a single task with an ID and description.
 */
class Task {
    private int id;
    private String description;

    /**
     * Constructs a new Task.
     * @param id The unique ID of the task.
     * @param description The description of the task.
     */
    public Task(int id, String description) {
        this.id = id;
        this.description = description;
    }

    /**
     * Gets the task ID.
     * @return The task ID.
     */
    public int getId() {
        return id;
    }

    /**
     * Gets the task description.
     * @return The task description.
     */
    public String getDescription() {
        return description;
    }

    /**
     * Returns a string representation of the Task.
     * @return String in the format "[ID] - [Description]".
     */
    @Override
    public String toString() {
        return id + " - " + description;
    }
}

/**
 * Manages a queue of pending tasks and a list of completed tasks.
 * Handles user interaction via a command-line menu.
 */
public class TaskScheduler { // Renamed to TaskScheduler as requested

    private Queue<Task> taskQueue;
    private List<Task> completedTasks;
    private int nextTaskId;
    private Scanner scanner;

    /**
     * Constructs a new TaskScheduler.
     * Initializes the task queue, completed tasks list, and task ID counter.
     */
    public TaskScheduler() {
        this.taskQueue = new LinkedList<>(); // Using LinkedList as a Queue implementation
        this.completedTasks = new ArrayList<>(); // Using ArrayList implementing List
        this.nextTaskId = 1;
        this.scanner = new Scanner(System.in);
    }

    /**
     * Adds a new task to the pending queue.
     * @param description The description for the new task.
     */
    public void addTask(String description) {
        Task newTask = new Task(nextTaskId++, description);
        taskQueue.offer(newTask); // offer() is preferred over add() for queues
        System.out.println("Task added: " + newTask);
    }

    /**
     * Processes the next task from the queue.
     * Removes the task from the queue and adds it to the completed list.
     */
    public void processNextTask() {
        Task taskToProcess = taskQueue.poll(); // poll() retrieves and removes, returns null if empty
        if (taskToProcess != null) {
            completedTasks.add(taskToProcess);
            System.out.println("Processing task: " + taskToProcess);
        } else {
            System.err.println("Error: The task queue is empty.");
        }
    }

    /**
     * Displays all tasks currently in the pending queue.
     */
    public void viewTaskQueue() {
        if (taskQueue.isEmpty()) {
            System.out.println("Pending task queue is empty.");
        } else {
            System.out.println("--- Pending Tasks ---");
            // Iterate without removing elements
            for (Task task : taskQueue) {
                System.out.println(task);
            }
            System.out.println("---------------------");
        }
    }

    /**
     * Displays all tasks that have been completed.
     */
    public void viewCompletedTasks() {
        if (completedTasks.isEmpty()) {
            System.out.println("No tasks have been completed yet.");
        } else {
            System.out.println("--- Completed Tasks ---");
            for (Task task : completedTasks) {
                System.out.println(task);
            }
            System.out.println("-----------------------");
        }
    }

    /**
     * Displays the main menu to the user.
     */
    private void displayMenu() {
        System.out.println("\nTask Scheduler Menu:");
        System.out.println("1. Add New Task");
        System.out.println("2. Process Next Task");
        System.out.println("3. View Pending Tasks");
        System.out.println("4. View Completed Tasks");
        System.out.println("5. Exit");
        System.out.print("Enter your choice: ");
    }

    /**
     * Runs the main Task Scheduler application loop.
     * Handles user input and dispatches actions based on menu choice.
     */
    public void runScheduler() {
        boolean running = true;

        // Class-wide exception handling for the main loop
        try {
            while (running) {
                displayMenu();
                int choice = -1;
                try {
                    choice = scanner.nextInt();
                    scanner.nextLine(); // Consume newline left-over
                } catch (InputMismatchException e) {
                    System.err.println("Error: Invalid input. Please enter a number.");
                    scanner.nextLine(); // Consume the invalid input to prevent infinite loop
                    continue; // Skip the rest of the loop and show menu again
                }

                switch (choice) {
                    case 1:
                        System.out.print("Enter task description: ");
                        String description = scanner.nextLine();
                        if (description == null || description.trim().isEmpty()) {
                            System.err.println("Error: Task description cannot be empty.");
                        } else {
                            addTask(description.trim());
                        }
                        break;
                    case 2:
                        processNextTask();
                        break;
                    case 3:
                        viewTaskQueue();
                        break;
                    case 4:
                        viewCompletedTasks();
                        break;
                    case 5:
                        System.out.println("Exiting Task Scheduler. Goodbye!");
                        running = false;
                        break;
                    default:
                        System.err.println("Error: Invalid menu choice. Please enter a number between 1 and 5.");
                        break;
                }
            }
        } catch (Exception e) {
            // Catch any unexpected runtime exceptions during the main loop
            System.err.println("An unexpected error occurred: " + e.getMessage());
            e.printStackTrace(); // Print stack trace for debugging
        } finally {
            // Ensure the scanner is closed when the application exits
            if (scanner != null) {
                scanner.close();
            }
        }
    }

    /**
     * Main method to start the Task Scheduler application.
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        TaskScheduler scheduler = new TaskScheduler();
        scheduler.runScheduler();
    }
}
