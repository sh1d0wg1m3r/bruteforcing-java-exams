/*
 * Exam Question #642
 * Generated on: 2025-05-12 16:19:01
 * Generated by: Account 3
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Venue Event Management System
 * 
 * **Scenario:**
 * 
 * You are tasked with developing a simple command-line application to manage attendees for an event held at a venue with limited capacity. Attendees arrive and join a waiting line. An operator uses the system to admit attendees from the front of the line into the venue, provided there is enough remaining capacity.
 * 
 * **Task:**
 * 
 * Implement a Java program that simulates this system. The program should allow the operator to add attendees to the waiting line, admit attendees from the line into the venue, check the current status of the line and venue, list admitted attendees, and exit the application.
 * 
 * **Requirements:**
 * 
 * Your solution *must* demonstrate a strong understanding of core Java concepts and *must* utilize **ALL** of the following Java components:
 * 
 * 1.  `java.util.Queue`: To represent the waiting line of attendees.
 * 2.  `java.util.ArrayList`: To store the list of attendees who have been admitted into the venue.
 * 3.  `java.util.List`: The `ArrayList` must be declared using the `List` interface type.
 * 4.  `java.util.Scanner`: To read user commands and input from the console.
 * 5.  `switch` statement: To process different user commands.
 * 6.  `System.err`: To output error messages (e.g., invalid input, venue full, queue empty).
 * 7.  `System.out`: To output normal information (e.g., prompts, confirmations, status, admitted list).
 * 8.  Class-wide exception handling with `try-catch` blocks: Implement a general exception handler for unexpected errors during the program's execution, printing error details to `System.err`.
 * 
 * **Functionalities (Commands):**
 * 
 * The program should accept the following commands (case-insensitive):
 * 
 * *   `add`: Prompts for an Attendee ID (String) and Name (String), creates an `Attendee` object, and adds it to the end of the waiting queue. Prints a confirmation message to `System.out`. Input validation should ensure ID and Name are not empty.
 * *   `admit`: Prompts for the number of attendees to admit from the front of the queue. Validates the input (must be a positive integer). Checks if there are enough attendees in the queue and if there is enough remaining capacity in the venue. If valid, removes the specified number of attendees from the front of the queue and adds them to the list of admitted attendees. Prints a confirmation for each admitted attendee to `System.out`. If validation fails (e.g., invalid number, queue empty, not enough in queue, not enough capacity), prints an informative error message to `System.err`.
 * *   `status`: Prints the current size of the waiting queue, the number of attendees currently admitted, the total venue capacity, and the remaining capacity to `System.out`.
 * *   `admitted`: Lists all attendees currently in the admitted list, printing their details to `System.out`. If the list is empty, prints a message indicating so.
 * *   `exit`: Prints a goodbye message to `System.out` and terminates the program.
 * 
 * **Data Structure:**
 * 
 * Create a simple `Attendee` class with private fields for ID and Name, a constructor, and public getter methods. Include a `toString()` method for easy printing.
 * 
 * **Constraints:**
 * 
 * *   The venue has a fixed capacity, defined when the system starts.
 * *   Admission is strictly FIFO from the waiting queue.
 * *   Admission cannot exceed the number of people in the queue or the remaining venue capacity.
 * 
 * **Best Practices:**
 * 
 * *   Use proper encapsulation (private fields, public methods).
 * *   Use meaningful variable and method names.
 * *   Include basic comments where necessary to explain complex logic.
 * *   Implement robust input validation for user commands and data.
 * *   Handle errors gracefully using `System.err`.
 * *   Structure your code logically into classes and methods.
 * 
 * **Expected Output/Interaction:**
 * 
 * The program should run in a loop, prompting the user for commands. Output for successful operations and status checks should go to `System.out`. All error messages resulting from invalid commands, invalid input, or failed operations (like trying to admit when the venue is full) must go to `System.err`. Any unexpected exceptions caught by the class-wide handler should also be printed to `System.err`.
 * 
 * **Hints:**
 * 
 * *   `LinkedList` is a common implementation for the `Queue` interface.
 * *   Be careful when mixing `Scanner.nextInt()` and `Scanner.nextLine()`. You may need to consume the newline character left by `nextInt()`.
 * 
 * **Evaluation:**
 * 
 * Your solution will be evaluated based on:
 * *   Correct implementation of all required functionalities.
 * *   Proper usage of ALL specified Java components.
 * *   Adherence to best practices (encapsulation, naming, comments, structure).
 * *   Robust input validation and error handling using both `System.out` and `System.err`.
 * *   Correct class-wide exception handling.
 * 
 * ```java
 * // Your code goes here
 * ```
 * 
 * **Good luck!**
 *
 * EXPLANATION:
 * The provided solution implements a `VenueEventManager` class that simulates managing attendees for a venue with a fixed capacity. It fulfills all the requirements of the exam question.
 * 
 * 1.  **`java.util.Queue`**: The `waitingQueue` is declared as a `Queue<Attendee>` and implemented using `java.util.LinkedList`. Attendees are added using `offer()` and removed from the front using `poll()` when admitted, demonstrating typical Queue operations (FIFO).
 * 2.  **`java.util.ArrayList`**: The `admittedAttendees` is implemented using `java.util.ArrayList`. Admitted attendees are added to this list using `add()`.
 * 3.  **`java.util.List`**: The `admittedAttendees` variable is explicitly declared using the `List<Attendee>` interface type, demonstrating polymorphism and adherence to the requirement.
 * 4.  **`java.util.Scanner`**: A `Scanner` object is used to read user input from `System.in` within the `run` method and helper methods (`handleAddAttendee`, `handleAdmitAttendees`). It handles both `nextLine()` for strings and `nextInt()` for integers. Crucially, it includes logic (`scanner.nextLine()` in `finally` block or after `catch`) to consume the leftover newline character after `nextInt()`, preventing issues in subsequent `nextLine()` calls.
 * 5.  **`switch` statement**: The `run` method uses a `switch` statement on the lowercased user command string to direct execution to the appropriate handler method (`handleAddAttendee`, `handleAdmitAttendees`, etc.).
 * 6.  **`System.err`**: `System.err.println()` is used specifically for error messages, such as invalid command, empty input, non-positive number input, insufficient queue size, or exceeding venue capacity during the `admit` operation.
 * 7.  **`System.out`**: `System.out.println()` is used for all normal program output, including prompts, confirmations of successful operations (adding, admitting), status information, and the list of admitted attendees.
 * 8.  **Class-wide exception handling with `try-catch`**: A `try-catch(Exception e)` block is wrapped around the main `while` loop in the `run` method. This provides a class-wide handler that catches any unexpected runtime exceptions that might occur during command processing, printing an error message to `System.err`. Specific exception handling for `InputMismatchException` is also included in `handleAdmitAttendees` for more targeted error reporting for invalid number input.
 * 
 * **Code Structure and Best Practices:**
 * 
 * *   **Encapsulation**: The `Attendee` class has private fields (`id`, `name`) and public getter methods (`getId`, `getName`). The `VenueEventManager` class has private fields (`waitingQueue`, `admittedAttendees`, `venueCapacity`, `scanner`) and operations are performed through public (`run`) and private helper methods (`handleAddAttendee`, etc.).
 * *   **Meaningful Names**: Variable names like `waitingQueue`, `admittedAttendees`, `venueCapacity`, `countToAdmit`, `remainingCapacity`, and method names like `handleAddAttendee`, `handleAdmitAttendees`, `showStatus`, `listAdmitted` are descriptive.
 * *   **Comments**: Basic inline comments explain the purpose of key methods and important code sections (like Scanner newline handling and error message destinations). Javadoc comments are included for classes and public methods.
 * *   **Input Validation**: The code checks for empty strings for ID/Name, non-positive numbers for the admit count, and uses a `try-catch` block to handle non-integer input for the admit count (`InputMismatchException`).
 * *   **Error Handling**: Conditions like an empty queue, trying to admit more than are in the queue, or trying to admit more than the remaining capacity are checked *before* attempting the admission process, and informative error messages are printed to `System.err`.
 * *   **Clean Code Structure**: The main logic is delegated to separate private methods (`handleAddAttendee`, `handleAdmitAttendees`, etc.), making the `run` method clean and easy to understand. The `Attendee` class is separate, representing a distinct entity.
 * 
 * This solution effectively demonstrates the required Java concepts within a practical scenario, incorporating essential programming practices like validation, error handling, and structured design, making it a challenging yet solvable exam task.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.InputMismatchException;

// Represents an attendee with a unique ID and name.
class Attendee {
    private String id;
    private String name;

    /**
     * Constructs a new Attendee.
     * @param id The unique identifier for the attendee.
     * @param name The name of the attendee.
     */
    public Attendee(String id, String name) {
        this.id = id;
        this.name = name;
    }

    /**
     * Gets the ID of the attendee.
     * @return The attendee's ID.
     */
    public String getId() {
        return id;
    }

    /**
     * Gets the name of the attendee.
     * @return The attendee's name.
     */
    public String getName() {
        return name;
    }

    /**
     * Returns a string representation of the attendee.
     * @return A formatted string containing the attendee's ID and name.
     */
    @Override
    public String toString() {
        return "ID: " + id + ", Name: " + name;
    }
}

/**
 * Manages attendees for an event venue with limited capacity.
 * Handles a waiting queue and a list of admitted attendees.
 */
public class VenueEventManager {

    private Queue<Attendee> waitingQueue;
    private List<Attendee> admittedAttendees; // Declared as List interface type
    private int venueCapacity;
    private Scanner scanner;

    /**
     * Constructs a VenueEventManager with a specified capacity.
     * @param capacity The maximum number of attendees the venue can hold.
     * @throws IllegalArgumentException if capacity is not positive.
     */
    public VenueEventManager(int capacity) {
        if (capacity <= 0) {
            throw new IllegalArgumentException("Venue capacity must be positive.");
        }
        this.venueCapacity = capacity;
        this.waitingQueue = new LinkedList<>(); // LinkedList implements Queue
        this.admittedAttendees = new ArrayList<>(); // ArrayList implements List
        this.scanner = new Scanner(System.in);
    }

    /**
     * Runs the main command-line interface loop for the event manager.
     * Includes class-wide exception handling.
     */
    public void run() {
        System.out.println("--- Venue Event Manager ---");
        System.out.println("Venue Capacity: " + venueCapacity);
        System.out.println("Commands: add, admit, status, admitted, exit");

        // Class-wide exception handling for the main loop
        try {
            while (true) {
                System.out.print("\nEnter command: ");
                String command = scanner.nextLine().trim().toLowerCase();

                // Use switch statement for command processing
                switch (command) {
                    case "add":
                        handleAddAttendee();
                        break;
                    case "admit":
                        handleAdmitAttendees();
                        break;
                    case "status":
                        handleShowStatus();
                        break;
                    case "admitted":
                        handleListAdmitted();
                        break;
                    case "exit":
                        System.out.println("Exiting Event Manager. Goodbye!");
                        return; // Exit the run method and terminate the program
                    default:
                        // Use System.err for unknown command errors
                        System.err.println("Error: Unknown command. Please use add, admit, status, admitted, or exit.");
                }
            }
        } catch (Exception e) {
            // Catch any unexpected runtime exceptions
            System.err.println("An unexpected error occurred: " + e.getMessage());
            // Optionally print stack trace for debugging
             // e.printStackTrace(System.err);
        } finally {
            // Ensure the scanner is closed when the program ends
            if (scanner != null) {
                scanner.close();
            }
        }
    }

    /**
     * Handles the 'add' command to add a new attendee to the waiting queue.
     */
    private void handleAddAttendee() {
        System.out.print("Enter Attendee ID: ");
        String id = scanner.nextLine().trim();
        if (id.isEmpty()) {
             System.err.println("Error: Attendee ID cannot be empty.");
             return;
        }

        System.out.print("Enter Attendee Name: ");
        String name = scanner.nextLine().trim();
        if (name.isEmpty()) {
            System.err.println("Error: Attendee Name cannot be empty.");
            return;
        }

        Attendee newAttendee = new Attendee(id, name);
        // Add attendee to the waiting queue
        if (waitingQueue.offer(newAttendee)) {
            // Use System.out for success messages
            System.out.println("Attendee added to waiting queue: " + newAttendee);
        } else {
             // offer() typically doesn't fail for LinkedList unless memory is exhausted
            System.err.println("Error: Could not add attendee to the queue due to an internal issue.");
        }
    }

    /**
     * Handles the 'admit' command to admit attendees from the queue to the venue.
     */
    private void handleAdmitAttendees() {
        System.out.print("Enter number of attendees to admit: ");
        int countToAdmit = 0;
        try {
            // Attempt to read an integer
            countToAdmit = scanner.nextInt();
        } catch (InputMismatchException e) {
            // Use System.err for invalid input format
            System.err.println("Error: Invalid input. Please enter a number.");
            // Consume the invalid input line to prevent infinite loop
            scanner.nextLine();
            return;
        } finally {
             // Consume the rest of the line after reading the integer.
             // This is crucial for the next scanner.nextLine() call in the main loop.
             if (scanner.hasNextLine()) {
                scanner.nextLine();
             }
        }

        // Validate the number to admit
        if (countToAdmit <= 0) {
            System.err.println("Error: Number to admit must be positive.");
            return;
        }

        int currentQueueSize = waitingQueue.size();
        if (currentQueueSize == 0) {
            System.err.println("Error: Waiting queue is empty. Cannot admit anyone.");
            return;
        }

        if (countToAdmit > currentQueueSize) {
            System.err.println("Error: Cannot admit " + countToAdmit + ". Only " + currentQueueSize + " people in the queue.");
            return;
        }

        int currentAdmittedCount = admittedAttendees.size();
        int remainingCapacity = venueCapacity - currentAdmittedCount;
        if (remainingCapacity <= 0) {
            System.err.println("Error: Venue is already at full capacity (" + venueCapacity + "). Cannot admit more attendees.");
            return;
        }

        if (countToAdmit > remainingCapacity) {
            System.err.println("Error: Cannot admit " + countToAdmit + ". Only " + remainingCapacity + " spots remaining in the venue.");
            // Decide whether to admit partially or fail. Failing as requested number cannot be met.
            return;
        }

        // Proceed with admission
        System.out.println("Admitting " + countToAdmit + " attendees...");
        for (int i = 0; i < countToAdmit; i++) {
            Attendee admitted = waitingQueue.poll(); // Remove from the front of the queue
            if (admitted != null) {
                admittedAttendees.add(admitted); // Add to the list of admitted attendees
                System.out.println("Admitted: " + admitted); // Use System.out for confirmation
            } else {
                 // This case should theoretically not be reached if queue size check passed,
                 // but included for robustness.
                 System.err.println("Warning: Queue unexpectedly became empty during admission process.");
                 break; // Stop admitting if queue is empty
            }
        }
        System.out.println(countToAdmit + " attendees successfully admitted.");
    }

    /**
     * Handles the 'status' command to display current event status.
     */
    private void handleShowStatus() {
        System.out.println("--- Current Status ---"); // Use System.out for status info
        System.out.println("Waiting Queue Size: " + waitingQueue.size());
        System.out.println("Admitted Attendees Count: " + admittedAttendees.size());
        System.out.println("Venue Capacity: " + venueCapacity);
        System.out.println("Remaining Capacity: " + (venueCapacity - admittedAttendees.size()));
        if (!waitingQueue.isEmpty()) {
             // Peek at the next person without removing them
             System.out.println("Next in queue: " + waitingQueue.peek());
        }
        System.out.println("----------------------");
    }

    /**
     * Handles the 'admitted' command to list all admitted attendees.
     */
    private void handleListAdmitted() {
        System.out.println("--- Admitted Attendees ---"); // Use System.out for list header
        if (admittedAttendees.isEmpty()) {
            System.out.println("No attendees have been admitted yet.");
        } else {
            // Iterate through the List (ArrayList) and print details
            for (int i = 0; i < admittedAttendees.size(); i++) {
                 Attendee admitted = admittedAttendees.get(i);
                 System.out.println((i + 1) + ". " + admitted); // Use System.out for list items
            }
        }
        System.out.println("------------------------");
    }

    /**
     * Main method to start the application.
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        // Create an instance of the event manager with a capacity of 10
        // The constructor validates capacity
        try {
            VenueEventManager manager = new VenueEventManager(10);
            manager.run(); // Start the main application loop
        } catch (IllegalArgumentException e) {
             System.err.println("Error initializing event manager: " + e.getMessage());
        }
    }
}
