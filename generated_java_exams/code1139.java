/*
 * Exam Question #1139
 * Generated on: 2025-05-12 17:30:16
 * Generated by: Account 1
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Warehouse Inventory and Order Fulfillment System
 * 
 * **Objective:** Design and implement a simple command-line based system to manage warehouse inventory and process customer orders using various core Java concepts.
 * 
 * **Problem Description:**
 * 
 * You are tasked with building a basic system for a small warehouse. The system needs to keep track of products in stock and process incoming customer orders. Orders should be processed in the order they are received (First-In, First-Out).
 * 
 * The system should support the following operations via user interaction:
 * 
 * 1.  **Add/Update Product:** Add a new product to the inventory or update the quantity of an existing product.
 * 2.  **Place Order:** Accept a customer order for a specific product and quantity and add it to a queue for processing.
 * 3.  **Process Next Order:** Take the next order from the queue, check if sufficient stock is available, and if so, deduct the quantity from the inventory. If not, report an insufficient stock error.
 * 4.  **View Inventory:** Display the current list of products and their quantities in the warehouse.
 * 5.  **View Pending Orders:** Display the list of orders currently waiting in the processing queue.
 * 6.  **Exit:** Terminate the program.
 * 
 * **Technical Requirements:**
 * 
 * Your solution must adhere to the following technical constraints:
 * 
 * *   Use `java.util.Queue` to manage the pending customer orders.
 * *   Use `java.util.ArrayList` to store the product inventory.
 * *   Declare your inventory using the `java.util.List` interface type (e.g., `List<Product> inventory = new ArrayList<>();`).
 * *   Use `java.util.Scanner` to read user input from the console for commands and order details.
 * *   Implement a `switch` statement to handle the different user command options.
 * *   Use `System.err.println()` to display all error messages (e.g., invalid input, insufficient stock, queue empty).
 * *   Use `System.out.println()` to display all normal output (menus, confirmations, inventory lists, etc.).
 * *   Implement class-wide exception handling using `try-catch` blocks to manage potential runtime errors (e.g., `InputMismatchException` from Scanner, custom exceptions for business logic).
 * *   Design your classes with proper encapsulation (private fields, public methods).
 * *   Use meaningful variable and method names.
 * *   Include appropriate comments to explain complex logic.
 * *   Perform basic input validation (e.g., quantities must be non-negative).
 * *   Create a custom exception class, `InsufficientStockException`, to handle cases where an order cannot be fulfilled due to lack of stock.
 * 
 * **Class Structure Suggestion:**
 * 
 * *   `Product` class: Represents an item with `name` (String) and `quantity` (int).
 * *   `Order` class: Represents a customer order with `productName` (String) and `quantity` (int).
 * *   `WarehouseSystem` class: Contains the `main` method, the inventory (`List<Product>`), the order queue (`Queue<Order>`), and methods for the system operations (add product, place order, process order, etc.).
 * 
 * **Expected Output:**
 * 
 * The system should present a menu to the user. Based on the user's choice, it should perform the requested operation and provide feedback using `System.out` for success/information and `System.err` for errors.
 * 
 * Example Interaction Snippet:
 * 
 * ```
 * --- Warehouse System Menu ---
 * 1. Add/Update Product
 * 2. Place Order
 * 3. Process Next Order
 * 4. View Inventory
 * 5. View Pending Orders
 * 6. Exit
 * Enter your choice: 1
 * Enter product name: Laptop
 * Enter quantity: 50
 * Product 'Laptop' added/updated with quantity 50.
 * 
 * --- Warehouse System Menu ---
 * ...
 * Enter your choice: 2
 * Enter product name for order: Laptop
 * Enter quantity for order: 5
 * Order for 5 x Laptop placed.
 * 
 * --- Warehouse System Menu ---
 * ...
 * Enter your choice: 3
 * Processing order for 5 x Laptop...
 * Order processed successfully. 5 x Laptop deducted from inventory.
 * 
 * --- Warehouse System Menu ---
 * ...
 * Enter your choice: 4
 * --- Current Inventory ---
 * Product: Laptop, Quantity: 45
 * -------------------------
 * 
 * --- Warehouse System Menu ---
 * ...
 * Enter your choice: 3
 * Processing order for 10 x Keyboard...
 * Error: Insufficient stock for Keyboard. Required: 10, Available: 0
 * ```
 * 
 * **Evaluation Criteria:**
 * 
 * *   Correct usage of all required Java components (`Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.err`, `System.out`, `try-catch`).
 * *   Proper implementation of inventory and order processing logic.
 * *   Effective use of encapsulation and meaningful names.
 * *   Correct handling of user input and errors, including the custom exception.
 * *   Clean code structure and appropriate comments.
 * 
 * **Good luck!**
 *
 * EXPLANATION:
 * This solution implements a `WarehouseSystem` that manages a product inventory and processes orders.
 * 
 * 1.  **Required Components Usage:**
 *     *   `Queue`: The `pendingOrders` variable is declared as `Queue<Order>` and initialized with a `LinkedList`. `offer()` is used to add orders, `peek()` to view the next order without removing it, and `poll()` to remove it after successful processing or failure handling. This demonstrates the FIFO nature of a queue.
 *     *   `ArrayList`: The `inventory` variable is initialized as `new ArrayList<>()`. `ArrayList` is used as the underlying implementation for the dynamic list of `Product` objects.
 *     *   `List interface`: The `inventory` is declared as `List<Product>`, demonstrating the use of the interface type for better flexibility and abstraction.
 *     *   `Scanner`: A `Scanner` object is used to read user input (integers for choices, strings for names, integers for quantities) from `System.in`.
 *     *   `Switch statement`: The `run()` method uses a `switch` statement based on the user's menu choice to dispatch the corresponding system operation method.
 *     *   `System.err`: Used exclusively for printing error messages, such as invalid input, insufficient stock reports, and unexpected exceptions.
 *     *   `System.out`: Used for printing the menu, success messages, inventory lists, and pending order lists.
 *     *   Class-wide `try-catch`: The `run()` method's main loop includes `try-catch` blocks. One specifically handles `InputMismatchException` during `Scanner` input, preventing crashes when non-numeric input is given where a number is expected. Another general `catch (Exception e)` is included to catch any other unexpected runtime errors that might occur within the loop's execution of system operations, demonstrating robust error handling. The `processNextOrder` method also has a specific `catch` for the custom `InsufficientStockException` and a general `catch` for other potential issues during order processing.
 * 
 * 2.  **Structure and Encapsulation:**
 *     *   Three classes (`InsufficientStockException`, `Product`, `Order`, `WarehouseSystem`) are used to organize the code logically.
 *     *   `Product` and `Order` classes have private fields (`name`, `quantity`, `productName`) and public getter/setter methods, adhering to encapsulation principles.
 *     *   The `WarehouseSystem` class encapsulates the inventory and order queue and provides public methods for the operations, keeping the internal state (`inventory`, `pendingOrders`) private.
 * 
 * 3.  **Logic Implementation:**
 *     *   `addOrUpdateProduct`: Iterates through the inventory to find an existing product. If found, updates quantity; otherwise, adds a new product. Includes basic validation for name and quantity.
 *     *   `findProductByName`: A helper method to search the inventory list.
 *     *   `placeOrder`: Creates an `Order` object and adds it to the `pendingOrders` queue using `offer()`. Includes validation for name and quantity.
 *     *   `processNextOrder`: Uses `peek()` to inspect the next order. It then searches the inventory (`findProductByName`). It checks for product existence and sufficient quantity. If stock is insufficient, it throws the custom `InsufficientStockException`. If successful, it updates the inventory and removes the order from the queue using `poll()`. Error handling catches the custom exception and prints to `System.err`.
 *     *   `viewInventory` and `viewPendingOrders`: Iterate through the respective collections and print their contents. `viewPendingOrders` iterates directly over the queue without removing elements, demonstrating queue traversal.
 *     *   `run`: Implements the main application loop, displaying the menu, reading user input, and using the `switch` statement to call appropriate methods.
 * 
 * 4.  **Error Handling and Validation:**
 *     *   Input validation is performed in `addOrUpdateProduct` and `placeOrder` methods to ensure meaningful data (e.g., non-empty names, non-negative quantities).
 *     *   A custom exception `InsufficientStockException` is defined and thrown when an order cannot be fulfilled.
 *     *   `try-catch` blocks handle `InputMismatchException` during user input reading and the custom `InsufficientStockException` during order processing, providing user-friendly error messages via `System.err`. A general `catch (Exception e)` is used in the main loop and `processNextOrder` for unexpected issues, printing the error message and stack trace to `System.err`.
 * 
 * This solution effectively combines the required Java components within a practical scenario, demonstrating understanding of data structures, object-oriented principles, user interaction, and robust error handling, making it a challenging yet solvable exam task.
 */

import java.util.ArrayList;
import java.util.LinkedList; // Often used for Queue implementation
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.InputMismatchException;

// Custom Exception for insufficient stock
class InsufficientStockException extends Exception {
    public InsufficientStockException(String message) {
        super(message);
    }
}

// Represents a product in the inventory
class Product {
    private String name;
    private int quantity;

    public Product(String name, int quantity) {
        this.name = name;
        this.quantity = quantity;
    }

    public String getName() {
        return name;
    }

    public int getQuantity() {
        return quantity;
    }

    public void setQuantity(int quantity) {
        this.quantity = quantity;
    }

    @Override
    public String toString() {
        return "Product: " + name + ", Quantity: " + quantity;
    }
}

// Represents a customer order
class Order {
    private String productName;
    private int quantity;

    public Order(String productName, int quantity) {
        this.productName = productName;
        this.quantity = quantity;
    }

    public String getProductName() {
        return productName;
    }

    public int getQuantity() {
        return quantity;
    }

    @Override
    public String toString() {
        return "Order for " + quantity + " x " + productName;
    }
}

// Main system class managing inventory and orders
public class WarehouseSystem {
    // Inventory stored as a List (using ArrayList implementation)
    private List<Product> inventory;
    // Pending orders stored in a Queue (using LinkedList implementation)
    private Queue<Order> pendingOrders;
    private Scanner scanner;

    public WarehouseSystem() {
        this.inventory = new ArrayList<>();
        this.pendingOrders = new LinkedList<>(); // LinkedList is a common Queue implementation
        this.scanner = new Scanner(System.in);
    }

    // --- Core System Operations ---

    /**
     * Adds a new product or updates the quantity of an existing one.
     * @param name Product name
     * @param quantity Quantity to add/set
     */
    public void addOrUpdateProduct(String name, int quantity) {
        if (name == null || name.trim().isEmpty()) {
            System.err.println("Error: Product name cannot be empty.");
            return;
        }
        if (quantity < 0) {
             System.err.println("Error: Quantity cannot be negative.");
             return;
        }

        Product existingProduct = findProductByName(name);

        if (existingProduct != null) {
            // Update existing product quantity
            existingProduct.setQuantity(existingProduct.getQuantity() + quantity);
            System.out.println("Product '" + name + "' quantity updated. New quantity: " + existingProduct.getQuantity());
        } else {
            // Add new product
            inventory.add(new Product(name, quantity));
            System.out.println("Product '" + name + "' added with quantity " + quantity + ".");
        }
    }

    /**
     * Finds a product in the inventory by its name.
     * @param name Product name to search for
     * @return The Product object if found, otherwise null
     */
    private Product findProductByName(String name) {
        for (Product product : inventory) {
            if (product.getName().equalsIgnoreCase(name.trim())) {
                return product;
            }
        }
        return null;
    }

    /**
     * Places a new customer order into the pending queue.
     * @param productName The name of the product ordered
     * @param quantity The quantity ordered
     */
    public void placeOrder(String productName, int quantity) {
         if (productName == null || productName.trim().isEmpty()) {
            System.err.println("Error: Product name for order cannot be empty.");
            return;
        }
        if (quantity <= 0) {
             System.err.println("Error: Order quantity must be positive.");
             return;
        }
        Order order = new Order(productName.trim(), quantity);
        pendingOrders.offer(order); // offer is preferred over add for queues (returns false instead of throwing exception on failure)
        System.out.println(order + " placed.");
    }

    /**
     * Processes the next order from the queue.
     * Checks stock and updates inventory or reports insufficient stock.
     */
    public void processNextOrder() {
        Order nextOrder = pendingOrders.peek(); // Use peek to look without removing yet

        if (nextOrder == null) {
            System.err.println("No pending orders to process.");
            return;
        }

        System.out.println("Processing " + nextOrder + "...");

        try {
            Product productInStock = findProductByName(nextOrder.getProductName());

            if (productInStock == null) {
                // Product not found in inventory
                throw new InsufficientStockException("Product '" + nextOrder.getProductName() + "' not found in inventory.");
            }

            if (productInStock.getQuantity() < nextOrder.getQuantity()) {
                // Insufficient stock
                throw new InsufficientStockException(
                    "Insufficient stock for " + nextOrder.getProductName() +
                    ". Required: " + nextOrder.getQuantity() +
                    ", Available: " + productInStock.getQuantity()
                );
            }

            // Sufficient stock, process the order
            productInStock.setQuantity(productInStock.getQuantity() - nextOrder.getQuantity());
            pendingOrders.poll(); // Remove the order from the queue now that it's processed
            System.out.println("Order processed successfully. " + nextOrder.getQuantity() + " x " + nextOrder.getProductName() + " deducted from inventory.");

        } catch (InsufficientStockException e) {
            // Catch custom insufficient stock exception
            System.err.println("Error: " + e.getMessage());
            // The order remains in the queue if processing failed due to stock.
            // Alternatively, you could poll() and move it to a 'failed orders' list.
            // For this problem, we leave it in the queue or could discard it. Let's discard for simplicity.
             pendingOrders.poll(); // Discard the order that failed due to insufficient stock
             System.err.println("Order discarded due to insufficient stock.");
        } catch (Exception e) {
            // Catch any other unexpected exceptions during processing
            System.err.println("An unexpected error occurred while processing order: " + e.getMessage());
            e.printStackTrace(System.err); // Print stack trace to System.err for debugging
            pendingOrders.poll(); // Discard the problematic order
             System.err.println("Order discarded due to processing error.");
        }
    }

    /**
     * Displays the current inventory.
     */
    public void viewInventory() {
        System.out.println("--- Current Inventory ---");
        if (inventory.isEmpty()) {
            System.out.println("Inventory is empty.");
        } else {
            for (Product product : inventory) {
                System.out.println(product);
            }
        }
        System.out.println("-------------------------");
    }

    /**
     * Displays the pending orders in the queue.
     */
    public void viewPendingOrders() {
        System.out.println("--- Pending Orders ---");
        if (pendingOrders.isEmpty()) {
            System.out.println("No pending orders.");
        } else {
            // Iterate through the queue without removing elements
            int i = 1;
            for (Order order : pendingOrders) {
                System.out.println(i++ + ". " + order);
            }
        }
        System.out.println("----------------------");
    }

    // --- Main Application Loop ---

    public void run() {
        int choice = -1;

        while (choice != 6) {
            printMenu();
            try {
                System.out.print("Enter your choice: ");
                choice = scanner.nextInt();
                scanner.nextLine(); // Consume newline left-over

                switch (choice) {
                    case 1:
                        System.out.print("Enter product name: ");
                        String productName = scanner.nextLine();
                        System.out.print("Enter quantity: ");
                        int quantity = scanner.nextInt();
                        scanner.nextLine(); // Consume newline
                        addOrUpdateProduct(productName, quantity);
                        break;
                    case 2:
                        System.out.print("Enter product name for order: ");
                        String orderProductName = scanner.nextLine();
                        System.out.print("Enter quantity for order: ");
                        int orderQuantity = scanner.nextInt();
                         scanner.nextLine(); // Consume newline
                        placeOrder(orderProductName, orderQuantity);
                        break;
                    case 3:
                        processNextOrder();
                        break;
                    case 4:
                        viewInventory();
                        break;
                    case 5:
                        viewPendingOrders();
                        break;
                    case 6:
                        System.out.println("Exiting Warehouse System. Goodbye!");
                        break;
                    default:
                        System.err.println("Invalid choice. Please enter a number between 1 and 6.");
                }
            } catch (InputMismatchException e) {
                System.err.println("Error: Invalid input. Please enter a number for your choice or quantity.");
                scanner.nextLine(); // Consume the invalid input to prevent infinite loop
                choice = -1; // Reset choice to prevent accidental exit if 6 was typed before error
            } catch (Exception e) {
                 // Catch any other unexpected exceptions in the main loop
                System.err.println("An unexpected error occurred: " + e.getMessage());
                e.printStackTrace(System.err);
            }
             System.out.println(); // Add a blank line for readability
        }
        scanner.close(); // Close the scanner when exiting
    }

    private void printMenu() {
        System.out.println("--- Warehouse System Menu ---");
        System.out.println("1. Add/Update Product");
        System.out.println("2. Place Order");
        System.out.println("3. Process Next Order");
        System.out.println("4. View Inventory");
        System.out.println("5. View Pending Orders");
        System.out.println("6. Exit");
    }

    public static void main(String[] args) {
        WarehouseSystem system = new WarehouseSystem();
        system.run();
    }
}
