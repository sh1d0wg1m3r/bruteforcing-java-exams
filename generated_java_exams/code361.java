/*
 * Exam Question #361
 * Generated on: 2025-05-11 23:00:17
 * Generated by: Account 2
 * 
 * QUESTION:
 * ## Advanced Java Programming Exam Task: Task Management System
 * 
 * **Scenario:**
 * 
 * You are tasked with building a simple command-line Task Management System. This system should allow users to add new tasks, view the next task to be processed, complete tasks, and list tasks. Tasks have a description and a priority. The system should process tasks based on their order of entry (FIFO) among tasks of the same priority level (though for this simplified version, we will just use a standard Queue for processing order).
 * 
 * **Requirements:**
 * 
 * 1.  **Task Class:** Create a `Task` class with private fields: `id` (int, unique identifier), `description` (String), and `priority` (String - e.g., "HIGH", "MEDIUM", "LOW"). Include a constructor, public getter methods for all fields, and a meaningful `toString()` method. Implement a static counter for generating unique IDs.
 * 2.  **TaskManager Class:** Create a `TaskManager` class responsible for managing tasks.
 *     *   It must use a `java.util.Queue<Task>` (e.g., `LinkedList`) to store tasks that are pending processing.
 *     *   It must use a `java.util.ArrayList<Task>` to store tasks that have been completed.
 *     *   Provide public methods:
 *         *   `addTask(String description, String priority)`: Creates a new `Task` object, validates the priority, and adds it to the pending tasks queue. Throws an exception if priority is invalid.
 *         *   `viewNextTask()`: Returns the next task from the pending queue without removing it. Returns `null` if the queue is empty.
 *         *   `completeNextTask()`: Removes the next task from the pending queue and adds it to the completed tasks list. Throws a custom exception if the queue is empty.
 *         *   `listPendingTasks()`: Returns a `java.util.List<Task>` containing all tasks currently in the pending queue (without removing them).
 *         *   `listCompletedTasks()`: Returns a `java.util.List<Task>` containing all tasks in the completed tasks list.
 * 3.  **Main Application (`ExamTaskSystem` class):**
 *     *   Create a `main` method to run the application.
 *     *   Use `java.util.Scanner` to read user input from the console.
 *     *   Present a menu to the user with options:
 *         1.  Add New Task
 *         2.  View Next Task
 *         3.  Complete Next Task
 *         4.  List All Pending Tasks
 *         5.  List All Completed Tasks
 *         6.  Exit
 *     *   Use a `switch` statement to handle user menu selections.
 *     *   Implement input validation for menu choices and task priority.
 *     *   Use `System.out` for displaying the menu, prompts, task details, and lists.
 *     *   Use `System.err` for displaying error messages (e.g., invalid input, task completion errors).
 *     *   Implement class-wide exception handling using `try-catch` blocks, specifically handling potential exceptions thrown by `TaskManager` methods or input errors.
 *     *   Ensure the application loop continues until the user chooses to exit.
 * 4.  **Exception Handling:** Define a custom exception class, e.g., `NoTasksPendingException`, to be thrown by `completeNextTask()` when there are no tasks in the queue.
 * 5.  **Best Practices:**
 *     *   Proper encapsulation (private fields, public methods).
 *     *   Meaningful variable and method names.
 *     *   Appropriate comments and documentation (Javadocs).
 *     *   Clean code structure.
 * 
 * **Expected Output:**
 * 
 * The program should interactively prompt the user for actions. Output should be clear, showing menu options, task details, lists, and informative error messages when issues occur (printed to `System.err`).
 * 
 * Example Interaction Snippet:
 * 
 * ```
 * Task Management Menu:
 * 1. Add New Task
 * 2. View Next Task
 * 3. Complete Next Task
 * 4. List All Pending Tasks
 * 5. List All Completed Tasks
 * 6. Exit
 * Enter your choice: 1
 * Enter task description: Write report
 * Enter priority (HIGH, MEDIUM, LOW): HIGH
 * Task added successfully.
 * 
 * Task Management Menu:
 * ...
 * Enter your choice: 2
 * Next task: Task ID: 1, Description: Write report, Priority: HIGH
 * 
 * Task Management Menu:
 * ...
 * Enter your choice: 3
 * Task completed: Task ID: 1, Description: Write report, Priority: HIGH
 * 
 * Task Management Menu:
 * ...
 * Enter your choice: 3
 * Error: No tasks are pending completion.
 * ```
 * 
 * **Grading Criteria:**
 * 
 * *   Correct usage of `Queue`, `ArrayList`, `List`, `Scanner`, `switch`.
 * *   Proper implementation of `Task` and `TaskManager` classes with encapsulation.
 * *   Effective use of `System.out` and `System.err`.
 * *   Robust exception handling with `try-catch` and custom exception.
 * *   Input validation implementation.
 * *   Adherence to best practices (naming, comments, structure).
 * *   Correct program flow and logic.
 * 
 * **Time Limit:** 45-60 minutes
 *
 * EXPLANATION:
 * This solution implements a simple Task Management System demonstrating the required Java concepts.
 * 
 * 1.  **Task Class:**
 *     *   Represents a single task with `id`, `description`, and `priority`.
 *     *   Uses a `static int nextId` to ensure each task gets a unique ID upon creation, simulating a simple primary key.
 *     *   Provides public getter methods for accessing task properties, adhering to encapsulation.
 *     *   Includes a `toString()` method for easy printing of task details.
 * 
 * 2.  **TaskManager Class:**
 *     *   Manages two collections of tasks: `pendingTasks` (using `java.util.Queue`) and `completedTasks` (using `java.util.ArrayList`).
 *     *   **`Queue<Task> pendingTasks`**: A `LinkedList` is used here because it implements the `Queue` interface and provides efficient `offer()` (add to end) and `poll()` (remove from front) operations, suitable for FIFO processing.
 *     *   **`List<Task> completedTasks`**: An `ArrayList` is used to store completed tasks. `ArrayList` is a common and efficient implementation of the `List` interface for storing and retrieving elements by index, though here we just iterate over it.
 *     *   **`addTask()`**: Validates the input priority against a predefined list (`VALID_PRIORITIES`). If valid, it creates a new `Task` object and adds it to the `pendingTasks` queue using `offer()`. Invalid priority throws a `TaskManagementException`. Basic description validation is also included.
 *     *   **`viewNextTask()`**: Uses `peek()` on the `pendingTasks` queue to look at the head element without removing it. Returns `null` if the queue is empty, which is handled by the caller.
 *     *   **`completeNextTask()`**: Uses `poll()` on the `pendingTasks` queue to remove and return the head element. If `poll()` returns `null` (meaning the queue was empty), it throws a custom `NoTasksPendingException`. If a task is successfully retrieved, it's added to the `completedTasks` list.
 *     *   **`listPendingTasks()`** and **`listCompletedTasks()`**: These methods return copies (`new ArrayList<>(...)`) of the internal collections. This is good practice to prevent external code from directly modifying the internal state of the `TaskManager`'s collections. They both return `List<Task>`, demonstrating the use of the `List` interface as a return type.
 * 
 * 3.  **Main Application (`ExamTaskSystem` class):**
 *     *   Contains the `main` method, the entry point of the program.
 *     *   Initializes a `Scanner` for user input and a `TaskManager` instance.
 *     *   Uses a `while` loop (`running`) to keep the application running until the user exits.
 *     *   **`Scanner scanner`**: Reads lines from `System.in` for user input. It's important to close the scanner in a `finally` block to release system resources.
 *     *   Presents a menu and reads the user's choice.
 *     *   **`switch (choice)`**: Controls the program flow based on the user's numeric input, directing execution to the corresponding task management operation. This directly addresses the requirement for a `switch` statement.
 *     *   **Input Validation**: Includes a `try-catch` block around `Integer.parseInt()` to handle non-numeric input for the menu choice.
 *     *   **`System.out`**: Used for printing the menu, prompts, success messages, and lists of tasks.
 *     *   **`System.err`**: Used specifically for printing error messages, such as invalid priority input, the "No tasks pending" error, or general input errors. This visually distinguishes errors from normal output.
 *     *   **Class-wide Exception Handling (`try-catch`)**: The main `while` loop is wrapped in a `try-catch (Exception e)` block. This serves as a top-level handler for any unexpected exceptions that might propagate up. More specific `try-catch` blocks are used within the `switch` cases (e.g., around `taskManager.addTask()` and `taskManager.completeNextTask()`) to handle known potential errors (`TaskManagementException`, `NoTasksPendingException`) gracefully and print informative messages to `System.err`.
 *     *   **Custom Exception (`TaskManagementException`, `NoTasksPendingException`)**: `TaskManagementException` provides a base for task-related errors, and `NoTasksPendingException` is a specific subclass used to indicate the condition of trying to complete a task when none are available. This improves code clarity and allows for specific error handling.
 * 
 * This solution effectively integrates all required components into a functional, albeit simple, application, demonstrating understanding of object-oriented principles, collection usage, user interaction, and robust error handling in Java.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.Arrays; // Added for priority validation example

// Custom exception for task management errors
class TaskManagementException extends Exception {
    public TaskManagementException(String message) {
        super(message);
    }
}

// Custom exception for when no tasks are pending
class NoTasksPendingException extends TaskManagementException {
    public NoTasksPendingException() {
        super("No tasks are pending completion.");
    }
}

// Represents a single task
class Task {
    private static int nextId = 1; // Static counter for unique IDs

    private int id;
    private String description;
    private String priority; // Using String as per requirement, could be enum

    /**
     * Constructs a new Task.
     *
     * @param description The description of the task.
     * @param priority    The priority of the task (e.g., "HIGH", "MEDIUM", "LOW").
     */
    public Task(String description, String priority) {
        this.id = nextId++;
        this.description = description;
        this.priority = priority;
    }

    // --- Getters ---
    public int getId() {
        return id;
    }

    public String getDescription() {
        return description;
    }

    public String getPriority() {
        return priority;
    }

    @Override
    public String toString() {
        return "Task ID: " + id + ", Description: " + description + ", Priority: " + priority;
    }
}

// Manages the collection of tasks
class TaskManager {
    private Queue<Task> pendingTasks; // Tasks waiting to be processed
    private List<Task> completedTasks; // Tasks that have been finished

    // Valid priorities for input validation
    private static final List<String> VALID_PRIORITIES = Arrays.asList("HIGH", "MEDIUM", "LOW");

    /**
     * Constructs a new TaskManager.
     */
    public TaskManager() {
        this.pendingTasks = new LinkedList<>(); // LinkedList implements Queue
        this.completedTasks = new ArrayList<>(); // ArrayList implements List
    }

    /**
     * Adds a new task to the pending queue.
     *
     * @param description The description of the task.
     * @param priority    The priority of the task.
     * @throws TaskManagementException If the priority is invalid.
     */
    public void addTask(String description, String priority) throws TaskManagementException {
        if (description == null || description.trim().isEmpty()) {
             throw new TaskManagementException("Task description cannot be empty.");
        }
        String upperPriority = priority.toUpperCase();
        if (!VALID_PRIORITIES.contains(upperPriority)) {
            throw new TaskManagementException("Invalid priority: " + priority + ". Valid priorities are: " + VALID_PRIORITIES);
        }
        Task newTask = new Task(description.trim(), upperPriority);
        pendingTasks.offer(newTask); // offer is generally preferred over add for queues
        System.out.println("Task added successfully.");
    }

    /**
     * Views the next task in the pending queue without removing it.
     *
     * @return The next task, or null if the queue is empty.
     */
    public Task viewNextTask() {
        return pendingTasks.peek(); // peek returns null if queue is empty
    }

    /**
     * Completes the next task in the pending queue by moving it to the completed list.
     *
     * @throws NoTasksPendingException If the pending queue is empty.
     */
    public void completeNextTask() throws NoTasksPendingException {
        Task nextTask = pendingTasks.poll(); // poll returns null if queue is empty
        if (nextTask == null) {
            throw new NoTasksPendingException();
        }
        completedTasks.add(nextTask);
        System.out.println("Task completed: " + nextTask);
    }

    /**
     * Returns a list of all pending tasks.
     * Note: This creates a new list to avoid exposing the internal queue directly.
     *
     * @return A List of pending tasks.
     */
    public List<Task> listPendingTasks() {
        // Return a new ArrayList containing elements from the queue
        // This avoids modifying the original queue when iterating the returned list
        return new ArrayList<>(pendingTasks);
    }

    /**
     * Returns a list of all completed tasks.
     *
     * @return A List of completed tasks.
     */
    public List<Task> listCompletedTasks() {
        // Return a copy to prevent external modification of the internal list
         return new ArrayList<>(completedTasks);
    }
}

// Main application class
public class ExamTaskSystem {

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        TaskManager taskManager = new TaskManager();
        boolean running = true;

        System.out.println("--- Task Management System ---");

        // Main application loop with class-wide exception handling
        try {
            while (running) {
                printMenu();
                System.out.print("Enter your choice: ");

                int choice = -1;
                try {
                    choice = Integer.parseInt(scanner.nextLine());
                } catch (NumberFormatException e) {
                    System.err.println("Invalid input. Please enter a number.");
                    continue; // Skip to the next iteration
                }

                // Use a switch statement for menu navigation
                switch (choice) {
                    case 1: // Add New Task
                        System.out.print("Enter task description: ");
                        String description = scanner.nextLine();
                        System.out.print("Enter priority (HIGH, MEDIUM, LOW): ");
                        String priority = scanner.nextLine();
                        try {
                            taskManager.addTask(description, priority);
                        } catch (TaskManagementException e) {
                            System.err.println("Error adding task: " + e.getMessage());
                        }
                        break;

                    case 2: // View Next Task
                        Task nextTask = taskManager.viewNextTask();
                        if (nextTask != null) {
                            System.out.println("Next task: " + nextTask);
                        } else {
                            System.out.println("No tasks are pending.");
                        }
                        break;

                    case 3: // Complete Next Task
                        try {
                            taskManager.completeNextTask();
                        } catch (NoTasksPendingException e) {
                            System.err.println("Error: " + e.getMessage());
                        } catch (TaskManagementException e) { // Catch potential broader exceptions
                             System.err.println("An unexpected error occurred during task completion: " + e.getMessage());
                        }
                        break;

                    case 4: // List All Pending Tasks
                        List<Task> pending = taskManager.listPendingTasks();
                        if (pending.isEmpty()) {
                            System.out.println("No pending tasks.");
                        } else {
                            System.out.println("--- Pending Tasks ---");
                            for (Task task : pending) {
                                System.out.println(task);
                            }
                            System.out.println("---------------------");
                        }
                        break;

                    case 5: // List All Completed Tasks
                        List<Task> completed = taskManager.listCompletedTasks();
                        if (completed.isEmpty()) {
                            System.out.println("No completed tasks yet.");
                        } else {
                            System.out.println("--- Completed Tasks ---");
                            for (Task task : completed) {
                                System.out.println(task);
                            }
                            System.out.println("-----------------------");
                        }
                        break;

                    case 6: // Exit
                        running = false;
                        System.out.println("Exiting Task Management System. Goodbye!");
                        break;

                    default: // Invalid menu choice
                        System.err.println("Invalid choice. Please enter a number between 1 and 6.");
                        break;
                }
                System.out.println(); // Add a blank line for readability
            }
        } catch (Exception e) {
            // Catch any unexpected exceptions at the highest level
            System.err.println("An unrecoverable error occurred: " + e.getMessage());
            e.printStackTrace(); // Print stack trace for debugging
        } finally {
            // Ensure scanner is closed
            scanner.close();
        }
    }

    /**
     * Prints the main menu options to the console.
     */
    private static void printMenu() {
        System.out.println("Task Management Menu:");
        System.out.println("1. Add New Task");
        System.out.println("2. View Next Task");
        System.out.println("3. Complete Next Task");
        System.out.println("4. List All Pending Tasks");
        System.out.println("5. List All Completed Tasks");
        System.out.println("6. Exit");
    }
}
