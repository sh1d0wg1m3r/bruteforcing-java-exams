/*
 * Exam Question #272
 * Generated on: 2025-05-11 22:48:04
 * Generated by: Account 2
 * 
 * QUESTION:
 * **Java Programming Exam Task: Task Management System**
 * 
 * **Problem Description:**
 * 
 * Design and implement a simple command-line Task Management System (TMS) for a small team. The system should allow users to manage tasks through a menu-driven interface.
 * 
 * **Core Functionality:**
 * 
 * 1.  **Add Task:** Create a new task. Prompt the user for the task's description and priority (High, Medium, or Low). New tasks are automatically assigned a unique ID and are initially in the "Pending" status.
 * 2.  **Assign Next Task:** Retrieve the oldest task from the pool of pending tasks and change its status to "In Progress".
 * 3.  **Complete Task:** Mark an "In Progress" task as "Completed" using its unique Task ID.
 * 4.  **List Tasks:** Display tasks based on their status:
 *     *   List All Tasks
 *     *   List Pending Tasks
 *     *   List Completed Tasks
 * 5.  **Exit:** Terminate the program.
 * 
 * **Technical Requirements:**
 * 
 * Your solution must demonstrate advanced understanding of Java concepts by incorporating ALL of the following:
 * 
 * *   Use `java.util.Queue` to manage tasks that are in the "Pending" status and available for assignment.
 * *   Use `java.util.ArrayList` to store all tasks created in the system, regardless of their current status.
 * *   Use the `java.util.List` interface when declaring variables or method return types where appropriate (e.g., when referring to or returning collections of tasks).
 * *   Use `java.util.Scanner` for all user input from the console.
 * *   Use a `switch` statement to handle the main menu selections.
 * *   Use `System.err` to display error messages (e.g., invalid user input, trying to assign when no tasks are pending, trying to complete a task that doesn't exist or isn't in the 'In Progress' status).
 * *   Use `System.out` for displaying the menu, prompts, task details, and success messages.
 * *   Implement class-wide exception handling using `try-catch` blocks in the main application loop to gracefully handle potential runtime issues like invalid input format or unexpected errors. Include specific handling for input errors where necessary within the loop for better user experience.
 * *   Design classes with proper encapsulation (private fields, public getters/setters/methods).
 * *   Use meaningful names for variables, methods, and classes.
 * *   Include appropriate comments and basic documentation (like method descriptions).
 * *   Implement basic input validation (e.g., for menu choices, priority input string, task ID).
 * *   Ensure a clean and well-structured code organization (e.g., separate classes for Task, TaskManager, and Main application logic).
 * 
 * **Task Details:**
 * 
 * *   Each task should have a unique integer ID (starting from 1).
 * *   Each task should have a String description.
 * *   Each task should have a String priority ("High", "Medium", "Low").
 * *   Each task should have a String status ("Pending", "In Progress", "Completed").
 * 
 * **Expected Output:**
 * 
 * The program should present a menu, accept user input, perform the requested action, and display appropriate output or error messages. The listing options should clearly display the task details. Example interaction is shown in the problem description above.
 * 
 * **Evaluation:**
 * 
 * Your solution will be evaluated on:
 * *   Correct implementation of all required technical components (`Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.err`, `System.out`, `try-catch`).
 * *   Accuracy and completeness of the core functionality.
 * *   Adherence to best practices (encapsulation, naming, comments, validation, error handling, structure).
 * *   Correct interaction between the `Queue` and `ArrayList` for managing task states.
 *
 * EXPLANATION:
 * This solution implements a simple command-line Task Management System, demonstrating the required Java concepts in a practical scenario.
 * 
 * 1.  **Overall Structure:** The system is organized into three classes:
 *     *   `Task`: Represents a single task with its properties (ID, description, priority, status). It uses encapsulation with private fields and public getters/setters.
 *     *   `TaskManager`: Manages the collection of tasks using the required data structures and implements the core business logic (add, assign, complete, list).
 *     *   `Main`: Contains the `main` method, handles user interaction, displays the menu, processes input using a `Scanner` and `switch` statement, and includes the main `try-catch` block for exception handling.
 * 
 * 2.  **Data Structures (`Queue`, `ArrayList`, `List`):**
 *     *   `java.util.Queue`: A `LinkedList` is used to implement the `pendingTasksQueue`. New tasks are added to this queue using `offer()`. When a task is assigned, it's removed from the front of the queue using `poll()`, ensuring tasks are assigned in the order they were added (FIFO - First-In, First-Out, typical queue behavior).
 *     *   `java.util.ArrayList`: `allTasksList` stores *every* task created. This allows lookup by ID (though implemented via iteration here for simplicity) and filtering tasks based on their status for listing purposes.
 *     *   `java.util.List interface`: Variables and method return types like `List<Task> allTasks`, `List<Task> getTasksByStatus(String status)`, and the parameter `List<Task> tasks` in `printTaskList` are declared using the `List` interface. This demonstrates programming to the interface rather than the concrete implementation (`ArrayList`), a key best practice.
 * 
 * 3.  **User Input (`Scanner`):**
 *     *   A `java.util.Scanner` is used in the `Main` class to read user input for menu choices, task details, and task IDs.
 *     *   Careful handling of `Scanner` input is shown, particularly consuming the newline character after reading integers (`nextInt()`) to prevent issues with subsequent `nextLine()` calls.
 * 
 * 4.  **Flow Control (`switch`):**
 *     *   A `switch` statement in the `Main` class's `while` loop is used to direct program flow based on the user's numeric menu choice, providing a clear and readable way to handle multiple options.
 * 
 * 5.  **Output (`System.out`, `System.err`):**
 *     *   `System.out.println()` and `System.out.print()` are used for all standard output, including the menu, prompts, task details, and success messages.
 *     *   `System.err.println()` is used specifically for displaying error messages, such as invalid input, tasks not found, or tasks being in the wrong status for an operation. Using `System.err` helps distinguish error output from normal program output.
 * 
 * 6.  **Exception Handling (`try-catch`):**
 *     *   A class-wide `try-catch(Exception e)` block wraps the main `while` loop in the `Main` class. This provides a safety net for any unexpected runtime exceptions that might occur, preventing the program from crashing abruptly and printing a general error message to `System.err`.
 *     *   More specific `try-catch(InputMismatchException e)` blocks are used within the loop when reading integer input (`nextInt()`). This handles cases where the user enters non-numeric input for menu choices or task IDs, prints a specific error message to `System.err`, consumes the invalid input, and allows the program to continue by showing the menu again.
 *     *   An `IllegalArgumentException` is thrown by `addTask` for invalid priority and caught in `Main`, demonstrating handling specific business logic errors.
 * 
 * 7.  **Best Practices:**
 *     *   **Encapsulation:** Fields in `Task` and `TaskManager` are private, accessed via public methods.
 *     *   **Meaningful Names:** Variable names (`pendingTasksQueue`, `allTasksList`, `nextTaskId`, `description`, `priority`, `assignedTask`), method names (`addTask`, `assignNextTask`, `completeTask`, `getTasksByStatus`, `printTaskList`), and class names (`Task`, `TaskManager`, `Main`) are descriptive.
 *     *   **Comments and Documentation:** Basic Javadoc-style comments explain the purpose of classes, methods, and key fields.
 *     *   **Input Validation:** The code checks if the menu choice is within the valid range, validates the priority string in `addTask`, and checks if a task ID exists and is in the correct status in `completeTask`.
 *     *   **Error Handling:** Errors are reported using `System.err`, and exceptions are caught to maintain program stability.
 *     *   **Clean Code Structure:** The code is separated into logical classes, making it more organized and maintainable.
 * 
 * This solution effectively integrates all required components, demonstrates their practical use in a cohesive system, and follows important Java programming best practices, making it a challenging yet solvable exam task. The interaction between the `Queue` (for pending assignment) and the `ArrayList` (for the complete task record and status tracking) is central to the problem's design.
 */

package com.example.tms; // Example package declaration

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.InputMismatchException;
import java.util.Optional;

// Represents a single task in the system
class Task {
    private int id;
    private String description;
    private String priority; // High, Medium, Low
    private String status;   // Pending, In Progress, Completed

    /**
     * Constructs a new Task.
     * @param id The unique task ID.
     * @param description The task description.
     * @param priority The task priority.
     */
    public Task(int id, String description, String priority) {
        this.id = id;
        this.description = description;
        this.priority = priority;
        this.status = "Pending"; // New tasks start as Pending
    }

    // --- Getters ---
    public int getId() {
        return id;
    }

    public String getDescription() {
        return description;
    }

    public String getPriority() {
        return priority;
    }

    public String getStatus() {
        return status;
    }

    // --- Setter for status ---
    public void setStatus(String status) {
        this.status = status;
    }

    /**
     * Provides a string representation of the task.
     * @return A formatted string detailing the task.
     */
    @Override
    public String toString() {
        return "ID: " + id + ", Description: " + description + ", Priority: " + priority + ", Status: " + status;
    }
}

// Manages the collection of tasks
class TaskManager {
    // Queue for tasks waiting to be assigned (Pending status)
    private Queue<Task> pendingTasksQueue;
    // List to hold all tasks created in the system
    private List<Task> allTasksList;
    // Counter for generating unique task IDs
    private int nextTaskId;

    /**
     * Constructs a new TaskManager.
     */
    public TaskManager() {
        // Use LinkedList as a concrete implementation of Queue
        this.pendingTasksQueue = new LinkedList<>();
        // Use ArrayList as a concrete implementation of List
        this.allTasksList = new ArrayList<>();
        this.nextTaskId = 1; // Start task IDs from 1
    }

    /**
     * Adds a new task to the system.
     *
     * @param description The task description.
     * @param priority    The task priority (High, Medium, Low).
     * @return The newly created Task object.
     * @throws IllegalArgumentException if priority is invalid.
     */
    public Task addTask(String description, String priority) {
        // Basic validation for priority
        if (!priority.equalsIgnoreCase("High") && !priority.equalsIgnoreCase("Medium") && !priority.equalsIgnoreCase("Low")) {
             throw new IllegalArgumentException("Invalid priority: " + priority + ". Must be High, Medium, or Low.");
        }

        Task newTask = new Task(nextTaskId++, description, priority);
        allTasksList.add(newTask); // Add to the list of all tasks
        pendingTasksQueue.offer(newTask); // Add to the queue of pending tasks
        return newTask;
    }

    /**
     * Assigns the next task from the pending queue.
     * Changes the status of the assigned task to "In Progress".
     *
     * @return The assigned Task, or null if no tasks are pending.
     */
    public Task assignNextTask() {
        // Poll removes the head of the queue (oldest pending task)
        Task taskToAssign = pendingTasksQueue.poll();

        if (taskToAssign != null) {
            // Since the object in the queue is the same reference as in the list,
            // updating the status on the polled object updates it in the list too.
            taskToAssign.setStatus("In Progress");
            return taskToAssign;
        }
        return null; // No tasks in the pending queue
    }

    /**
     * Completes a task by its ID.
     * Changes the status of the task to "Completed" if it's currently "In Progress".
     *
     * @param taskId The ID of the task to complete.
     * @return true if the task was found and completed, false otherwise.
     */
    public boolean completeTask(int taskId) {
        Optional<Task> taskOpt = findTaskById(taskId); // Uses Optional

        if (taskOpt.isPresent()) {
            Task task = taskOpt.get();
            // Can only complete tasks that are In Progress
            if ("In Progress".equals(task.getStatus())) {
                task.setStatus("Completed");
                return true;
            } else {
                // Task found but not in the correct status to be completed
                System.err.println("Error: Task ID " + taskId + " is not In Progress (Current Status: " + task.getStatus() + ").");
                return false;
            }
        } else {
            // Task not found
            System.err.println("Error: Task with ID " + taskId + " not found.");
            return false;
        }
    }

    /**
     * Finds a task by its ID in the list of all tasks.
     *
     * @param taskId The ID of the task to find.
     * @return An Optional containing the Task if found, otherwise empty.
     */
    private Optional<Task> findTaskById(int taskId) {
        for (Task task : allTasksList) {
            if (task.getId() == taskId) {
                return Optional.of(task);
            }
        }
        return Optional.empty(); // Task not found
    }

    /**
     * Returns a list of all tasks in the system.
     *
     * @return A List containing all tasks.
     */
    public List<Task> getAllTasks() {
        return allTasksList; // Returns the List interface type
    }

    /**
     * Returns a list of tasks with the specified status.
     *
     * @param status The status to filter by (e.g., "Pending", "In Progress", "Completed").
     * @return A List containing tasks with the specified status.
     */
    public List<Task> getTasksByStatus(String status) {
        List<Task> filteredList = new ArrayList<>(); // Uses ArrayList implementing List
        for (Task task : allTasksList) {
            if (task.getStatus().equalsIgnoreCase(status)) {
                filteredList.add(task);
            }
        }
        return filteredList; // Returns the List interface type
    }

    /**
     * Prints a list of tasks to System.out.
     *
     * @param tasks The list of tasks to print. Uses List interface.
     * @param title The title for the list display.
     */
    public void printTaskList(List<Task> tasks, String title) {
        System.out.println("--- " + title + " ---");
        if (tasks.isEmpty()) {
            System.out.println("No tasks found.");
        } else {
            for (Task task : tasks) {
                System.out.println(task); // Uses Task.toString()
            }
        }
        System.out.println("-----------------");
    }
}

// Main class to run the Task Management System
public class Main {

    public static void main(String[] args) {
        // Class-wide try-catch block for general exception handling
        try {
            TaskManager taskManager = new TaskManager();
            Scanner scanner = new Scanner(System.in);
            boolean running = true;

            while (running) {
                printMenu();

                int choice = -1;
                System.out.print("Enter your choice: ");
                try {
                    // Handle potential InputMismatchException for integer input
                    choice = scanner.nextInt();
                } catch (InputMismatchException e) {
                    System.err.println("Invalid input. Please enter a number.");
                    scanner.next(); // Consume the invalid input to prevent infinite loop
                    continue; // Skip the rest of the loop body and show menu again
                } finally {
                     // Consume the newline character left by nextInt() or scanner.next()
                     scanner.nextLine();
                }

                // Use switch statement for main menu navigation
                switch (choice) {
                    case 1: // Add Task
                        System.out.print("Enter task description: ");
                        String description = scanner.nextLine();
                        System.out.print("Enter priority (High, Medium, Low): ");
                        String priority = scanner.nextLine();
                        try {
                             Task addedTask = taskManager.addTask(description, priority);
                             System.out.println("Task added with ID: " + addedTask.getId());
                        } catch (IllegalArgumentException e) {
                             // Catch specific validation error from TaskManager
                             System.err.println("Error adding task: " + e.getMessage());
                        }
                        break;

                    case 2: // Assign Next Task
                        Task assignedTask = taskManager.assignNextTask();
                        if (assignedTask != null) {
                            System.out.println("Assigned task ID " + assignedTask.getId() + ": " + assignedTask.getDescription() + " (Priority: " + assignedTask.getPriority() + ")");
                        } else {
                            System.out.println("No tasks currently pending to assign.");
                        }
                        break;

                    case 3: // Complete Task
                        System.out.print("Enter Task ID to complete: ");
                        int taskIdToComplete = -1;
                         try {
                            // Handle potential InputMismatchException for integer input
                            taskIdToComplete = scanner.nextInt();
                         } catch (InputMismatchException e) {
                             System.err.println("Invalid input. Please enter a valid Task ID (number).");
                             scanner.next(); // Consume invalid input
                             continue; // Skip to next iteration
                         } finally {
                              scanner.nextLine(); // Consume newline
                         }

                        boolean completed = taskManager.completeTask(taskIdToComplete);
                        if (completed) {
                            System.out.println("Task ID " + taskIdToComplete + " marked as Completed.");
                        }
                        // Error message is printed inside completeTask method if it fails
                        break;

                    case 4: // List All Tasks
                        List<Task> allTasks = taskManager.getAllTasks(); // Uses List interface
                        taskManager.printTaskList(allTasks, "All Tasks");
                        break;

                    case 5: // List Pending Tasks
                        // Retrieve pending tasks by filtering the main list based on status
                        List<Task> pendingTasks = taskManager.getTasksByStatus("Pending"); // Uses List interface
                        taskManager.printTaskList(pendingTasks, "Pending Tasks");
                        break;

                    case 6: // List Completed Tasks
                         // Retrieve completed tasks by filtering the main list based on status
                        List<Task> completedTasks = taskManager.getTasksByStatus("Completed"); // Uses List interface
                        taskManager.printTaskList(completedTasks, "Completed Tasks");
                        break;

                    case 7: // Exit
                        running = false;
                        System.out.println("Exiting TMS.");
                        break;

                    default:
                        // Handle invalid menu choices
                        System.err.println("Invalid choice. Please enter a number between 1 and 7.");
                }
                System.out.println(); // Add a newline for better readability between operations
            }

            scanner.close(); // Close the scanner resource

        } catch (Exception e) {
            // This catch block handles any other unexpected exceptions
            System.err.println("An unexpected error occurred: " + e.getMessage());
            // e.printStackTrace(); // Uncomment for detailed debugging if needed
        }
    }

    /**
     * Prints the main menu options to System.out.
     */
    private static void printMenu() {
        System.out.println("--- Task Management System ---");
        System.out.println("1. Add Task");
        System.out.println("2. Assign Next Task");
        System.out.println("3. Complete Task");
        System.out.println("4. List All Tasks");
        System.out.println("5. List Pending Tasks");
        System.out.println("6. List Completed Tasks");
        System.out.println("7. Exit");
    }
}
