/*
 * Exam Question #73
 * Generated on: 2025-05-11 22:08:52
 * Generated by: Account 3
 * 
 * QUESTION:
 * **Java Programming Exam Task: Document Processing System Simulation**
 * 
 * You are tasked with building a simple console-based application to simulate a document processing system for a small office. Documents arrive and are placed in a queue to await processing. Once processed, they are moved to a list of completed documents. The system should allow users to interact via the console to manage this process.
 * 
 * **Requirements:**
 * 
 * 1.  **Data Structures:**
 *     *   Use a `java.util.Queue` to hold documents waiting for processing.
 *     *   Use a `java.util.ArrayList` to store documents that have been processed.
 *     *   Declare the processed documents storage using the `java.util.List` interface.
 * 2.  **User Interaction:**
 *     *   Use `java.util.Scanner` to read user commands from the console.
 *     *   Provide a menu of options to the user:
 *         *   Add a new document to the processing queue.
 *         *   Process the next document from the queue (move it to the completed list).
 *         *   List all documents currently in the processing queue.
 *         *   List all documents that have been completed.
 *         *   Exit the application.
 * 3.  **Control Flow:**
 *     *   Use a `switch` statement to handle the different user commands.
 *     *   The application should run in a loop until the user chooses to exit.
 * 4.  **Error Handling:**
 *     *   Implement class-wide exception handling using a `try-catch` block to catch potential runtime errors during the main execution loop.
 *     *   If an error occurs (e.g., trying to process an empty queue, invalid user input), print an informative message to `System.err`.
 *     *   For successful operations and prompts, use `System.out`.
 *     *   Handle the case where the user tries to process a document when the queue is empty.
 * 5.  **Object-Oriented Design:**
 *     *   Create a simple `Document` class (can just store a name/ID).
 *     *   Create a main class (`DocumentProcessorSystem` or similar) that contains the `main` method and manages the queue and list.
 *     *   Implement proper encapsulation (private fields, public methods/main logic).
 * 6.  **Code Quality:**
 *     *   Use meaningful variable and method names.
 *     *   Include appropriate comments where necessary.
 *     *   Ensure input validation where applicable (e.g., basic command validation).
 * 
 * **Expected Output:**
 * 
 * The application should present a menu, process user input, and print relevant messages or lists.
 * 
 * Example Interaction Flow:
 * 
 * ```
 * --- Document Processing System ---
 * Choose an action:
 * A: Add Document
 * P: Process Next Document
 * L: List Pending Documents
 * C: List Completed Documents
 * E: Exit
 * Enter command: A
 * Enter document name: Report_Q1
 * Document 'Report_Q1' added to queue.
 * Enter command: A
 * Enter document name: Invoice_123
 * Document 'Invoice_123' added to queue.
 * Enter command: L
 * --- Pending Documents ---
 * Report_Q1
 * Invoice_123
 * ---------------------------
 * Enter command: P
 * Processing document: Report_Q1
 * Document 'Report_Q1' processed.
 * Enter command: L
 * --- Pending Documents ---
 * Invoice_123
 * ---------------------------
 * Enter command: C
 * --- Completed Documents ---
 * Report_Q1
 * ---------------------------
 * Enter command: P
 * Processing document: Invoice_123
 * Document 'Invoice_123' processed.
 * Enter command: P
 * Error: The processing queue is empty.
 * Enter command: C
 * --- Completed Documents ---
 * Report_Q1
 * Invoice_123
 * ---------------------------
 * Enter command: E
 * Exiting system.
 * ```
 * 
 * Your solution should provide the complete Java code for this system.
 *
 * EXPLANATION:
 * The solution provides a console-based simulation of a document processing system, demonstrating the required Java concepts in a practical scenario.
 * 
 * 1.  **`Document` Class:** A simple class to encapsulate document data (just a `name` in this case) with a constructor and getter, following encapsulation principles. The `toString()` method is overridden for easy printing.
 * 2.  **`DocumentProcessingSystem` Class:**
 *     *   **Data Structures:**
 *         *   `private Queue<Document> pendingDocumentsQueue;`: Declared as `Queue`, initialized with `LinkedList`. `LinkedList` is a common implementation of `Queue` that supports FIFO ordering.
 *         *   `private List<Document> completedDocumentsList;`: Declared as `List`, initialized with `ArrayList`. `ArrayList` is used for storing completed documents, which don't require FIFO access after processing. Using the `List` interface is good practice.
 *     *   **User Input:** `private Scanner scanner;` is used to read input from `System.in`.
 *     *   **Main Loop and Exception Handling:** The `start()` method contains the main application loop (`while(running)`). This loop is wrapped in a `try-catch(Exception e)` block, fulfilling the requirement for class-wide exception handling. Any unexpected exception during the execution of commands within the loop will be caught, an error message printed to `System.err`, and the stack trace printed to `System.err`. A `finally` block ensures the `Scanner` is closed upon exiting the loop or catching an exception.
 *     *   **Menu and Command Processing:**
 *         *   `displayMenu()` prints the available options to `System.out`.
 *         *   `getUserCommand()` reads the user's input. `scanner.nextLine()` is used to read the whole line to prevent issues when mixing `nextLine()` with other `next()` methods if they were used. `trim().toUpperCase()` is used for flexible command handling.
 *         *   `processCommand(String command)` uses a `switch` statement to direct execution based on the user's input character. This fulfills the switch statement requirement. Invalid commands trigger an error message to `System.err`.
 *     *   **Command Implementations:**
 *         *   `addDocument()`: Prompts for a document name, creates a `Document` object, and adds it to the `pendingDocumentsQueue` using `offer()`. Basic input validation checks for an empty name.
 *         *   `processNextDocument()`: Uses `pendingDocumentsQueue.poll()` to get and remove the head of the queue. If `poll()` returns `null` (meaning the queue was empty), an error message is printed to `System.err`. Otherwise, the document is added to the `completedDocumentsList`.
 *         *   `listPendingDocuments()`: Iterates directly over the `pendingDocumentsQueue` (which is possible with `LinkedList`) and prints each document's name to `System.out`. It checks if the queue is empty first.
 *         *   `listCompletedDocuments()`: Iterates over the `completedDocumentsList` (an `ArrayList`) and prints each document's name to `System.out`. It checks if the list is empty first.
 *         *   `exitSystem()`: Sets the `running` flag to `false`, terminating the main loop.
 *     *   **Encapsulation and Code Quality:** Fields are `private`. Public methods (`start`, `main`) control access. Methods are named descriptively (`addDocument`, `processNextDocument`, etc.). Comments explain the purpose of classes and key methods. `System.out` is used for normal output, and `System.err` is used specifically for error conditions (empty queue processing, invalid command, general exceptions).
 * 
 * This solution effectively integrates all required components (`Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.err`, `System.out`, `try-catch`) into a cohesive and practical application, demonstrating understanding of data structures, control flow, user interaction, error handling, and basic object-oriented principles suitable for an advanced exam question.
 */

import java.util.Queue;
import java.util.LinkedList; // Common implementation for Queue
import java.util.List;
import java.util.ArrayList; // Common implementation for List
import java.util.Scanner;
import java.util.InputMismatchException;

// Represents a document in the system
class Document {
    private String name;

    public Document(String name) {
        this.name = name;
    }

    public String getName() {
        return name;
    }

    @Override
    public String toString() {
        return name;
    }
}

// Main system class to manage documents
public class DocumentProcessingSystem {

    // Queue for documents waiting to be processed (FIFO)
    private Queue<Document> pendingDocumentsQueue;
    // List for documents that have been processed
    private List<Document> completedDocumentsList;
    private Scanner scanner;
    private boolean running;

    public DocumentProcessingSystem() {
        // Using LinkedList as a concrete implementation for Queue
        this.pendingDocumentsQueue = new LinkedList<>();
        // Using ArrayList as a concrete implementation for List
        this.completedDocumentsList = new ArrayList<>();
        this.scanner = new Scanner(System.in);
        this.running = true;
    }

    // Starts the document processing system
    public void start() {
        System.out.println("--- Document Processing System ---");

        // Class-wide exception handling for the main loop
        try {
            while (running) {
                displayMenu();
                String command = getUserCommand();
                processCommand(command);
            }
        } catch (Exception e) {
            // Catch any unexpected exceptions during execution
            System.err.println("An unexpected error occurred: " + e.getMessage());
            e.printStackTrace(System.err); // Print stack trace to error stream
        } finally {
            // Ensure scanner is closed when the system stops
            if (scanner != null) {
                scanner.close();
            }
            System.out.println("System shutdown complete.");
        }
    }

    // Displays the available command options
    private void displayMenu() {
        System.out.println("\nChoose an action:");
        System.out.println("A: Add Document");
        System.out.println("P: Process Next Document");
        System.out.println("L: List Pending Documents");
        System.out.println("C: List Completed Documents");
        System.out.println("E: Exit");
        System.out.print("Enter command: ");
    }

    // Gets user input for the command
    private String getUserCommand() {
        // Read the entire line to avoid issues with nextLine() after other next() calls
        return scanner.nextLine().trim().toUpperCase();
    }

    // Processes the user's command using a switch statement
    private void processCommand(String command) {
        switch (command) {
            case "A":
                addDocument();
                break;
            case "P":
                processNextDocument();
                break;
            case "L":
                listPendingDocuments();
                break;
            case "C":
                listCompletedDocuments();
                break;
            case "E":
                exitSystem();
                break;
            default:
                // Handle invalid commands
                System.err.println("Error: Invalid command. Please try again.");
        }
    }

    // Adds a new document to the pending queue
    private void addDocument() {
        System.out.print("Enter document name: ");
        String docName = scanner.nextLine().trim();
        if (docName.isEmpty()) {
            System.err.println("Error: Document name cannot be empty.");
            return;
        }
        Document newDoc = new Document(docName);
        // offer() is generally preferred over add() for queues as it returns false
        // instead of throwing an exception if the queue is capacity-restricted,
        // though LinkedList is not capacity-restricted.
        pendingDocumentsQueue.offer(newDoc);
        System.out.println("Document '" + docName + "' added to queue.");
    }

    // Processes the next document from the queue and moves it to the completed list
    private void processNextDocument() {
        // poll() retrieves and removes the head of the queue, returning null if empty
        Document docToProcess = pendingDocumentsQueue.poll();

        if (docToProcess != null) {
            System.out.println("Processing document: " + docToProcess.getName());
            completedDocumentsList.add(docToProcess); // Add to the completed list
            System.out.println("Document '" + docToProcess.getName() + "' processed.");
        } else {
            // Handle the case where the queue is empty
            System.err.println("Error: The processing queue is empty. No documents to process.");
        }
    }

    // Lists all documents currently in the pending queue
    private void listPendingDocuments() {
        System.out.println("--- Pending Documents ---");
        if (pendingDocumentsQueue.isEmpty()) {
            System.out.println("No documents in the queue.");
        } else {
            // Iterate through the queue without removing elements
            // Note: Iteration order depends on the Queue implementation (LinkedList is ordered)
            for (Document doc : pendingDocumentsQueue) {
                System.out.println(doc.getName());
            }
        }
        System.out.println("---------------------------");
    }

    // Lists all documents that have been completed
    private void listCompletedDocuments() {
        System.out.println("--- Completed Documents ---");
        if (completedDocumentsList.isEmpty()) {
            System.out.println("No completed documents.");
        } else {
            // Iterate through the list
            for (Document doc : completedDocumentsList) {
                System.out.println(doc.getName());
            }
        }
        System.out.println("---------------------------");
    }

    // Sets the flag to exit the system loop
    private void exitSystem() {
        System.out.println("Exiting system.");
        running = false;
    }

    // Main method to run the application
    public static void main(String[] args) {
        DocumentProcessingSystem system = new DocumentProcessingSystem();
        system.start();
    }
}
