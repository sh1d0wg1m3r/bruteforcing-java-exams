/*
 * Exam Question #356
 * Generated on: 2025-05-11 22:59:46
 * Generated by: Account 2
 * 
 * QUESTION:
 * **Advanced Java Programming Exam: Customer Support Ticket System**
 * 
 * **Scenario:**
 * You are tasked with building a simplified command-line customer support ticket system. The system needs to manage incoming support requests, allow agents to process them in the order they arrive, and keep a record of processed tickets.
 * 
 * **Requirements:**
 * 
 * 1.  **Data Structures:**
 *     *   Use a `Queue` to hold tickets that are waiting to be processed (pending tickets). Tickets should be processed in First-In, First-Out (FIFO) order.
 *     *   Use an `ArrayList` to store tickets that have already been processed.
 *     *   Declare the variable holding the processed tickets using the `List` interface type (`List<Ticket> processedTickets = new ArrayList<>();`).
 * 
 * 2.  **Ticket Representation:**
 *     *   Create a `Ticket` class with private fields: `id` (int), `description` (String), and `status` (String, e.g., "Pending", "Processed").
 *     *   Provide a constructor to create new tickets.
 *     *   Provide public getter methods for the fields.
 *     *   Override the `toString()` method in the `Ticket` class for easy printing.
 * 
 * 3.  **System Functionality:**
 *     *   Implement a main application loop that presents a menu to the user.
 *     *   Use a `Scanner` to read user input for menu choices and ticket details.
 *     *   Use a `switch` statement to handle the different menu options:
 *         *   `1`: **Create New Ticket:** Prompt the user for a ticket description. Create a new `Ticket` object (assign a unique ID, e.g., using a static counter). Add the new ticket to the pending `Queue`.
 *         *   `2`: **Process Next Ticket:** Take the next available ticket from the pending `Queue`. If the queue is empty, display an error message. If a ticket is available, update its status to "Processed" and move it from the `Queue` to the processed `List`. Display the details of the processed ticket.
 *         *   `3`: **View Pending Tickets:** Display all tickets currently in the pending `Queue`. If the queue is empty, indicate that.
 *         *   `4`: **View Processed Tickets:** Display all tickets currently in the processed `List`. If the list is empty, indicate that.
 *         *   `5`: **Exit:** Terminate the program.
 *         *   Any other input: Display an error message for an invalid choice.
 * 
 * 4.  **Error Handling:**
 *     *   Implement class-wide exception handling using `try-catch` blocks, particularly around operations that might fail due to invalid user input (e.g., non-integer input when an integer is expected for the menu choice).
 *     *   Use `System.err.println()` to output all error messages (e.g., invalid input, processing an empty queue).
 *     *   Use `System.out.println()` for all normal output (menu, prompts, ticket details, success messages).
 * 
 * 5.  **Best Practices:**
 *     *   Use meaningful variable and method names.
 *     *   Include comments where necessary to explain complex logic.
 *     *   Ensure proper encapsulation in the `Ticket` class.
 *     *   Validate user input where appropriate (e.g., ensuring menu choice is an integer).
 *     *   Structure the code logically with separate methods for different functionalities where beneficial (though a single `main` method with helper logic is acceptable for this exam scope).
 * 
 * **Expected Output:**
 * 
 * The program should interactively guide the user through the menu options. Output should be clear, using `System.out` for normal information and `System.err` for errors.
 * 
 * Example Interaction Flow:
 * ```
 * --- Support Ticket System Menu ---
 * 1. Create New Ticket
 * 2. Process Next Ticket
 * 3. View Pending Tickets
 * 4. View Processed Tickets
 * 5. Exit
 * Enter your choice: 1
 * Enter ticket description: My internet is slow
 * Ticket #1 created and added to pending queue.
 * 
 * --- Support Ticket System Menu ---
 * ...
 * Enter your choice: 1
 * Enter ticket description: Cannot log in
 * Ticket #2 created and added to pending queue.
 * 
 * --- Support Ticket System Menu ---
 * ...
 * Enter your choice: 3
 * --- Pending Tickets ---
 * [Ticket #1 (Pending): My internet is slow]
 * [Ticket #2 (Pending): Cannot log in]
 * 
 * --- Support Ticket System Menu ---
 * ...
 * Enter your choice: 2
 * Processing ticket: [Ticket #1 (Pending): My internet is slow]
 * Ticket #1 processed.
 * 
 * --- Support Ticket System Menu ---
 * ...
 * Enter your choice: 3
 * --- Pending Tickets ---
 * [Ticket #2 (Pending): Cannot log in]
 * 
 * --- Support Ticket System Menu ---
 * ...
 * Enter your choice: 4
 * --- Processed Tickets ---
 * [Ticket #1 (Processed): My internet is slow]
 * 
 * --- Support Ticket System Menu ---
 * ...
 * Enter your choice: 2
 * Processing ticket: [Ticket #2 (Pending): Cannot log in]
 * Ticket #2 processed.
 * 
 * --- Support Ticket System Menu ---
 * ...
 * Enter your choice: 2
 * --- Processed Tickets ---
 * No tickets in the pending queue to process.
 * 
 * --- Support Ticket System Menu ---
 * ...
 * Enter your choice: abc
 * java.util.InputMismatchException: Invalid input. Please enter a number.
 * --- Support Ticket System Menu ---
 * ...
 * Enter your choice: 6
 * System.err: Invalid choice. Please enter a number between 1 and 5.
 * 
 * --- Support Ticket System Menu ---
 * ...
 * Enter your choice: 5
 * Exiting system.
 * ```
 * 
 * Your task is to write the complete Java code for this system.
 *
 * EXPLANATION:
 * This solution implements a simple Customer Support Ticket System demonstrating the required Java concepts.
 * 
 * 1.  **`Ticket` Class:**
 *     *   Encapsulates ticket data (`id`, `description`, `status`) using private fields.
 *     *   Uses a static `nextId` counter to ensure unique IDs for each ticket upon creation.
 *     *   Provides public getter methods for accessing ticket information.
 *     *   Includes a `setStatus` method to allow updating the ticket's status.
 *     *   Overrides `toString()` for convenient printing of ticket details.
 * 
 * 2.  **`SupportSystem` Class:**
 *     *   **Data Structures:**
 *         *   `pendingTickets`: Declared as `Queue<Ticket>` and initialized with `new LinkedList<>()`. `LinkedList` is chosen because it efficiently implements the `Queue` interface, providing FIFO behavior suitable for incoming tickets.
 *         *   `processedTickets`: Declared as `List<Ticket>` and initialized with `new ArrayList<>()`. This fulfills the requirement to use the `List` interface type while using `ArrayList` as the concrete implementation, which is good practice. `ArrayList` is suitable here as we primarily need to store and iterate through processed tickets.
 *     *   **`Scanner`:** An instance of `Scanner` is created to read user input from `System.in`. It's closed when the program exits to release system resources.
 *     *   **`main` Method:** The entry point of the application, which creates a `SupportSystem` instance and calls its `run` method.
 *     *   **`run` Method:**
 *         *   Contains the main application loop (`do-while`) that continues until the user chooses to exit (option 5).
 *         *   Calls `printMenu()` to display options.
 *         *   Uses a `try-catch` block to wrap the input reading (`scanner.nextInt()`) and the `switch` statement. This is the "class-wide" exception handling, catching potential `InputMismatchException` if the user enters non-integer input for the menu choice. It also includes a general `Exception` catch for unexpected errors.
 *         *   Inside the `try` block, it reads the user's choice. `scanner.nextLine()` is called immediately after `scanner.nextInt()` to consume the leftover newline character, preventing issues in subsequent `scanner.nextLine()` calls for ticket descriptions.
 *         *   The `switch` statement directs the program flow based on the user's valid integer input, calling dedicated private methods for each operation.
 *         *   If `InputMismatchException` occurs, an error message is printed to `System.err`, the invalid input is consumed using `scanner.nextLine()`, and the loop continues.
 *         *   If the choice is outside the valid range (1-5), a specific error message is printed to `System.err`.
 *     *   **`printMenu` Method:** A simple helper method to display the menu options using `System.out`.
 *     *   **`createTicket` Method:**
 *         *   Prompts the user for the ticket description using `System.out`.
 *         *   Reads the full line of input using `scanner.nextLine()`.
 *         *   Includes basic validation to check if the description is empty.
 *         *   Creates a new `Ticket` object.
 *         *   Adds the new ticket to the `pendingTickets` queue using `offer()`. `offer()` is generally preferred over `add()` for queues as it handles capacity constraints gracefully (though `LinkedList` doesn't have a fixed capacity).
 *         *   Confirms ticket creation using `System.out`.
 *     *   **`processNextTicket` Method:**
 *         *   Checks if the `pendingTickets` queue is empty using `isEmpty()`. If so, it prints an error to `System.err` and returns.
 *         *   If the queue is not empty, it retrieves and removes the head of the queue using `poll()`.
 *         *   Updates the ticket's status to "Processed".
 *         *   Adds the processed ticket to the `processedTickets` list using `add()`.
 *         *   Prints confirmation using `System.out`.
 *     *   **`viewPendingTickets` Method:**
 *         *   Prints a header using `System.out`.
 *         *   Checks if the `pendingTickets` queue is empty. If so, prints a message using `System.out`.
 *         *   If not empty, it iterates through the queue using an enhanced for loop and prints each ticket's `toString()` representation using `System.out`. Iterating this way does *not* remove elements from the queue.
 *     *   **`viewProcessedTickets` Method:**
 *         *   Prints a header using `System.out`.
 *         *   Checks if the `processedTickets` list is empty. If so, prints a message using `System.out`.
 *         *   If not empty, it iterates through the list using an enhanced for loop and prints each ticket's `toString()` representation using `System.out`.
 * 
 * This solution effectively integrates all required components, simulates a practical scenario, adheres to best practices like encapsulation and meaningful names, and includes robust error handling for user input and system state (like an empty queue). The use of `System.out` and `System.err` is correctly differentiated for normal output and error messages.
 */

import java.util.ArrayList;
import java.util.LinkedList; // LinkedList implements Queue
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.InputMismatchException;

// Represents a single support ticket
class Ticket {
    private static int nextId = 1; // Static counter for unique ticket IDs

    private int id;
    private String description;
    private String status; // e.g., "Pending", "Processed"

    public Ticket(String description) {
        this.id = nextId++;
        this.description = description;
        this.status = "Pending"; // New tickets start as Pending
    }

    // --- Getters ---
    public int getId() {
        return id;
    }

    public String getDescription() {
        return description;
    }

    public String getStatus() {
        return status;
    }

    // --- Setters (for status update) ---
    public void setStatus(String status) {
        this.status = status;
    }

    @Override
    public String toString() {
        return String.format("[Ticket #%d (%s): %s]", id, status, description);
    }
}

// Main class for the Support Ticket System
public class SupportSystem {

    // Use LinkedList which implements Queue for FIFO
    private Queue<Ticket> pendingTickets = new LinkedList<>();
    // Use ArrayList declared with List interface type for processed tickets
    private List<Ticket> processedTickets = new ArrayList<>();
    private Scanner scanner = new Scanner(System.in);

    public static void main(String[] args) {
        SupportSystem system = new SupportSystem();
        system.run();
    }

    // Main application loop
    public void run() {
        int choice = 0;
        do {
            printMenu();
            try {
                System.out.print("Enter your choice: ");
                choice = scanner.nextInt();
                scanner.nextLine(); // Consume newline left-over

                // Class-wide try-catch handles InputMismatchException here

                switch (choice) {
                    case 1:
                        createTicket();
                        break;
                    case 2:
                        processNextTicket();
                        break;
                    case 3:
                        viewPendingTickets();
                        break;
                    case 4:
                        viewProcessedTickets();
                        break;
                    case 5:
                        System.out.println("Exiting system.");
                        break;
                    default:
                        System.err.println("Invalid choice. Please enter a number between 1 and 5.");
                }
            } catch (InputMismatchException e) {
                // Handle non-integer input gracefully
                System.err.println("java.util.InputMismatchException: Invalid input. Please enter a number.");
                scanner.nextLine(); // Consume the invalid input to prevent infinite loop
                choice = 0; // Reset choice to stay in loop
            } catch (Exception e) {
                // Catch any other unexpected exceptions
                System.err.println("An unexpected error occurred: " + e.getMessage());
                e.printStackTrace(); // Print stack trace for debugging
            }
            System.out.println(); // Add a newline for better readability between menu iterations

        } while (choice != 5);

        scanner.close(); // Close the scanner when exiting
    }

    // Prints the main menu
    private void printMenu() {
        System.out.println("--- Support Ticket System Menu ---");
        System.out.println("1. Create New Ticket");
        System.out.println("2. Process Next Ticket");
        System.out.println("3. View Pending Tickets");
        System.out.println("4. View Processed Tickets");
        System.out.println("5. Exit");
    }

    // Handles creating a new ticket
    private void createTicket() {
        System.out.print("Enter ticket description: ");
        String description = scanner.nextLine();
        if (description == null || description.trim().isEmpty()) {
             System.err.println("Ticket description cannot be empty.");
             return; // Don't create ticket if description is empty
        }
        Ticket newTicket = new Ticket(description);
        pendingTickets.offer(newTicket); // offer() is preferred over add() in queues as it doesn't throw exception on capacity constraints (though LinkedList is unbounded)
        System.out.println("Ticket #" + newTicket.getId() + " created and added to pending queue.");
    }

    // Handles processing the next ticket from the queue
    private void processNextTicket() {
        if (pendingTickets.isEmpty()) {
            System.err.println("No tickets in the pending queue to process.");
            return;
        }

        Ticket ticketToProcess = pendingTickets.poll(); // poll() retrieves and removes the head of the queue, returns null if empty (checked above)
        System.out.println("Processing ticket: " + ticketToProcess);
        ticketToProcess.setStatus("Processed");
        processedTickets.add(ticketToProcess); // Add to the list of processed tickets
        System.out.println("Ticket #" + ticketToProcess.getId() + " processed.");
    }

    // Handles viewing pending tickets
    private void viewPendingTickets() {
        System.out.println("--- Pending Tickets ---");
        if (pendingTickets.isEmpty()) {
            System.out.println("No tickets currently pending.");
        } else {
            // Iterate through the queue without removing elements
            for (Ticket ticket : pendingTickets) {
                System.out.println(ticket);
            }
        }
    }

    // Handles viewing processed tickets
    private void viewProcessedTickets() {
        System.out.println("--- Processed Tickets ---");
        if (processedTickets.isEmpty()) {
            System.out.println("No tickets have been processed yet.");
        } else {
            // Iterate through the list
            for (Ticket ticket : processedTickets) {
                System.out.println(ticket);
            }
        }
    }
}
