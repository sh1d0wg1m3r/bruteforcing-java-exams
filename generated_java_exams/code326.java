/*
 * Exam Question #326
 * Generated on: 2025-05-11 22:55:39
 * Generated by: Account 2
 * 
 * QUESTION:
 * ## Advanced Java Programming Exam Task: Task Processing System
 * 
 * **Scenario:**
 * 
 * You are tasked with developing a simple Task Processing System. This system should manage a queue of tasks waiting to be processed and maintain a history of tasks that have been completed. Users should be able to submit new tasks, process the next task in the queue, view the current queue, and view the history of completed tasks through a command-line interface.
 * 
 * **Requirements:**
 * 
 * 1.  **Task Definition:** Create a class named `Task` with the following attributes:
 *     *   A unique integer `id`.
 *     *   A `String` `description`.
 *     *   A `String` `type` (e.g., "STANDARD", "PRIORITY", "MAINTENANCE").
 *     *   Include a constructor, appropriate getters for all fields, and a meaningful `toString()` method.
 * 
 * 2.  **Task Processing System Logic:** Create a class named `TaskProcessingSystem` that encapsulates the system's state and logic. This class must:
 *     *   Use a `java.util.Queue` to store tasks waiting to be processed.
 *     *   Use a `java.util.List` (specifically implemented by `java.util.ArrayList`) to store tasks that have been completed.
 *     *   Use a `java.util.Scanner` to read user input from the console.
 *     *   Implement a command-line interface loop that presents a menu of options to the user.
 *     *   Use a `switch` statement to handle the different user commands.
 * 
 * 3.  **Operations:** Implement the following operations within `TaskProcessingSystem`:
 *     *   **Submit Task:** Prompt the user for task description and type. Create a `Task` object and add it to the processing queue. Validate the task type (accept only "STANDARD", "PRIORITY", "MAINTENANCE"). If the type is invalid, display an error and do not add the task.
 *     *   **Process Next Task:** Remove the task at the front of the queue, simulate processing (e.g., print a "Processing..." message), and add it to the completed tasks list. If the queue is empty, display an error message.
 *     *   **View Task Queue:** Display all tasks currently in the processing queue in their current order. If the queue is empty, display a message indicating so.
 *     *   **View Completed Tasks:** Display all tasks in the completed tasks history. If the history is empty, display a message indicating so.
 *     *   **Exit:** Terminate the program.
 * 
 * 4.  **Error Handling and Output:**
 *     *   Use `System.out` for all normal output, including the menu, prompts, success messages, and task listings.
 *     *   Use `System.err` for all error messages, such as invalid input, invalid task types, or attempting to process from an empty queue.
 *     *   Implement class-wide or main-loop `try-catch` blocks to handle potential exceptions, particularly `java.util.InputMismatchException` if the user enters non-integer input for a command, or other unexpected errors. Display an informative error message using `System.err` when an exception occurs.
 * 
 * 5.  **Best Practices:**
 *     *   Apply proper encapsulation (private fields, public methods).
 *     *   Use meaningful variable and method names.
 *     *   Include appropriate comments and documentation (Javadocs are encouraged but not strictly required for all methods in an exam setting; clear inline comments are sufficient).
 *     *   Implement input validation where necessary (e.g., task type, command input).
 * 
 * **Menu Options:**
 * 
 * 1.  Submit New Task
 * 2.  Process Next Task
 * 3.  View Task Queue
 * 4.  View Completed Tasks
 * 5.  Exit
 * 
 * **Expected Output Format:**
 * 
 * *   Menu displayed clearly.
 * *   Prompts for input clearly worded.
 * *   Task queue/history displayed with task details (ID, description, type).
 * *   Success messages for submission and processing.
 * *   Error messages directed to `System.err`.
 * *   Program terminates upon selecting the Exit option.
 * 
 * Implement the complete Java code for the `Task` and `TaskProcessingSystem` classes.
 *
 * EXPLANATION:
 * The provided solution implements a simple Task Processing System as required by the exam question. It effectively demonstrates the use of all specified Java components within a practical scenario.
 * 
 * 1.  **`Task` Class:** This class serves as a simple data structure (POJO) to hold information about each task. It includes an auto-incrementing static `nextId` to ensure each task gets a unique ID. The constructor validates the input description and type, throwing an `IllegalArgumentException` for invalid types. Getters provide controlled access to the task's attributes, and `toString()` provides a convenient way to represent a task as a string for printing.
 * 
 * 2.  **`TaskProcessingSystem` Class:** This is the core class managing the system's logic and state.
 *     *   **Data Structures:**
 *         *   `taskQueue`: Declared as `Queue<Task>` and initialized with `new LinkedList<>()`. `Queue` is used because tasks are processed in a First-In, First-Out (FIFO) manner. `LinkedList` is a common implementation of `Queue`.
 *         *   `completedTasks`: Declared as `List<Task>` and initialized with `new ArrayList<>()`. `List` provides ordered storage, and `ArrayList` is a standard, dynamic array implementation suitable for storing the history of completed tasks.
 *     *   **Input:** A `Scanner` object is used to read user input from `System.in`.
 *     *   **Menu and Command Handling:** The `displayMenu()` method shows the options. The `runSystem()` method contains the main loop that repeatedly displays the menu, reads the user's choice, and uses a `switch` statement to dispatch the call to the appropriate method (`submitTask`, `processNextTask`, `viewQueue`, `viewHistory`, or exit).
 *     *   **Operations:**
 *         *   `submitTask()`: Prompts for description and type, attempts to create a `Task` object. The `Task` constructor's validation is leveraged here, and any `IllegalArgumentException` is caught and reported to `System.err`. Valid tasks are added to the queue using `queue.offer()`.
 *         *   `processNextTask()`: Uses `queue.poll()` to retrieve and remove the head of the queue. If `poll()` returns `null` (queue is empty), an error is printed to `System.err`. Otherwise, the task is processed (simulated by a print statement) and added to the `completedTasks` list using `list.add()`.
 *         *   `viewQueue()`: Iterates through the `taskQueue` using a `forEach` loop (or an iterator) to display the tasks without removing them. Checks if the queue is empty first. Output goes to `System.out`.
 *         *   `viewCompletedTasks()`: Iterates through the `completedTasks` list to display the completed tasks. Checks if the list is empty first. Output goes to `System.out`.
 *     *   **Error Handling:**
 *         *   Specific validation errors (like invalid task type) are caught in `submitTask` and reported using `System.err.println()`.
 *         *   Attempting to process an empty queue results in an error message printed to `System.err`.
 *         *   A `try-catch` block is wrapped around the core logic within the `runSystem()` loop. This block specifically catches `InputMismatchException` for non-integer input for the command choice, printing an error to `System.err` and consuming the invalid input to prevent an infinite loop. A general `catch (Exception e)` is included as a broader safety net for any other unexpected runtime errors, printing the error to `System.err` and the stack trace for debugging.
 *     *   **Output:** `System.out.println()` is used for menu display, prompts, success messages, and listing tasks/history. `System.err.println()` is reserved for error conditions.
 * 
 * 3.  **Best Practices:**
 *     *   **Encapsulation:** Fields in both `Task` and `TaskProcessingSystem` are `private`, with access controlled by public methods (`getters`, operation methods).
 *     *   **Meaningful Names:** Classes, methods, and variables have names reflecting their purpose (`taskQueue`, `completedTasks`, `submitTask`, `processNextTask`, `runSystem`).
 *     *   **Comments:** Javadoc-style comments are used for classes and methods, explaining their purpose. Inline comments clarify specific logic points.
 *     *   **Input Validation:** Task type is validated in the `Task` constructor. The main loop handles non-integer input validation for the command choice.
 *     *   **Error Handling:** Specific error conditions (empty queue, invalid task type, input mismatch) are anticipated and handled gracefully with informative messages to `System.err`.
 *     *   **Clean Code Structure:** The code is organized into logical methods, making the `runSystem` method readable as it primarily dispatches calls.
 * 
 * This solution effectively integrates the required Java concepts into a functional, albeit simple, system, demonstrating understanding of data structures, control flow, input/output, and exception handling in a practical context.
 */

import java.util.LinkedList;
import java.util.Queue;
import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;
import java.util.InputMismatchException;

// Represents a single task in the system
class Task {
    private static int nextId = 1; // Static counter for unique task IDs

    private int id;
    private String description;
    private String type; // e.g., STANDARD, PRIORITY, MAINTENANCE

    /**
     * Constructs a new Task.
     * @param description The task description.
     * @param type The type of the task.
     * @throws IllegalArgumentException if the task type is invalid.
     */
    public Task(String description, String type) {
        if (description == null || description.trim().isEmpty()) {
            throw new IllegalArgumentException("Task description cannot be empty.");
        }
        if (!isValidTaskType(type)) {
            throw new IllegalArgumentException("Invalid task type: " + type);
        }

        this.id = nextId++; // Assign unique ID and increment counter
        this.description = description.trim();
        this.type = type.toUpperCase(); // Store type in uppercase

        System.out.println("Task " + this.id + " created."); // Confirmation message
    }

    // Helper method to validate task types
    private boolean isValidTaskType(String type) {
        if (type == null) return false;
        String upperType = type.toUpperCase();
        return upperType.equals("STANDARD") || upperType.equals("PRIORITY") || upperType.equals("MAINTENANCE");
    }

    // Getters
    public int getId() {
        return id;
    }

    public String getDescription() {
        return description;
    }

    public String getType() {
        return type;
    }

    @Override
    public String toString() {
        return "Task [ID=" + id + ", Type=" + type + ", Description='" + description + "']";
    }
}

// Manages the task processing queue and completed task history
public class TaskProcessingSystem {
    private Queue<Task> taskQueue; // Queue for tasks waiting to be processed
    private List<Task> completedTasks; // List for tasks that have been processed
    private Scanner scanner; // Scanner for user input

    /**
     * Constructs a new TaskProcessingSystem.
     * Initializes the queue, list, and scanner.
     */
    public TaskProcessingSystem() {
        this.taskQueue = new LinkedList<>(); // LinkedList implements Queue
        this.completedTasks = new ArrayList<>(); // ArrayList implements List
        this.scanner = new Scanner(System.in);
        System.out.println("Task Processing System initialized.");
    }

    /**
     * Displays the main menu to the user.
     */
    private void displayMenu() {
        System.out.println("\n--- Task Processing System Menu ---");
        System.out.println("1. Submit New Task");
        System.out.println("2. Process Next Task");
        System.out.println("3. View Task Queue");
        System.out.println("4. View Completed Tasks");
        System.out.println("5. Exit");
        System.out.print("Enter your choice: ");
    }

    /**
     * Handles the submission of a new task based on user input.
     */
    private void submitTask() {
        System.out.print("Enter task description: ");
        String description = scanner.nextLine();

        System.out.print("Enter task type (STANDARD, PRIORITY, MAINTENANCE): ");
        String type = scanner.nextLine();

        try {
            // Task constructor handles validation
            Task newTask = new Task(description, type);
            taskQueue.offer(newTask); // Add task to the end of the queue
            System.out.println("Task submitted successfully.");
        } catch (IllegalArgumentException e) {
            System.err.println("Error submitting task: " + e.getMessage());
        }
    }

    /**
     * Processes the next task from the queue.
     */
    private void processNextTask() {
        Task nextTask = taskQueue.poll(); // Get and remove task from the front of the queue

        if (nextTask == null) {
            System.err.println("No tasks in the queue to process.");
        } else {
            System.out.println("Processing task: " + nextTask);
            // Simulate processing time if needed (e.g., Thread.sleep)
            completedTasks.add(nextTask); // Add task to the completed list
            System.out.println("Task " + nextTask.getId() + " processed and moved to history.");
        }
    }

    /**
     * Displays the current tasks in the processing queue.
     */
    private void viewQueue() {
        System.out.println("\n--- Current Task Queue ---");
        if (taskQueue.isEmpty()) {
            System.out.println("The task queue is empty.");
        } else {
            // Iterate through the queue without removing elements
            taskQueue.forEach(System.out::println);
        }
    }

    /**
     * Displays the history of completed tasks.
     */
    private void viewCompletedTasks() {
        System.out.println("\n--- Completed Tasks History ---");
        if (completedTasks.isEmpty()) {
            System.out.println("No tasks have been completed yet.");
        } else {
            // Iterate through the completed tasks list
            completedTasks.forEach(System.out::println);
        }
    }

    /**
     * Runs the main interactive loop of the task processing system.
     * Includes class-wide exception handling for the main loop.
     */
    public void runSystem() {
        int choice = 0;
        while (choice != 5) {
            displayMenu();
            try {
                choice = scanner.nextInt();
                scanner.nextLine(); // Consume the newline character after reading the integer

                switch (choice) {
                    case 1:
                        submitTask();
                        break;
                    case 2:
                        processNextTask();
                        break;
                    case 3:
                        viewQueue();
                        break;
                    case 4:
                        viewCompletedTasks();
                        break;
                    case 5:
                        System.out.println("Exiting Task Processing System. Goodbye!");
                        break;
                    default:
                        System.err.println("Invalid choice. Please enter a number between 1 and 5.");
                }
            } catch (InputMismatchException e) {
                System.err.println("Invalid input. Please enter a number.");
                scanner.nextLine(); // Consume the invalid input to prevent infinite loop
            } catch (Exception e) {
                // Catch any other unexpected exceptions during the loop
                System.err.println("An unexpected error occurred: " + e.getMessage());
                e.printStackTrace(); // Print stack trace for debugging
            }
        }
        scanner.close(); // Close the scanner when exiting
    }

    /**
     * Main method to start the Task Processing System.
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        TaskProcessingSystem system = new TaskProcessingSystem();
        system.runSystem();
    }
}
