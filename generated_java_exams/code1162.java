/*
 * Exam Question #1162
 * Generated on: 2025-05-12 17:33:37
 * Generated by: Account 2
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Advanced Task Management System
 * 
 * **Scenario:** You are tasked with developing a simple command-line Task Management System. This system should allow users to add new tasks, process the next pending task, view pending tasks, and view completed tasks.
 * 
 * **Requirements:**
 * 
 * 1.  **Task Representation:** Create a `Task` class to represent a task. It should have a private field for the task description (String). Include a constructor and a `toString()` method.
 * 2.  **Task Management Logic:** Create a `TaskManager` class. This class should manage two collections:
 *     *   A collection for pending tasks, processed in a specific order (e.g., First-In, First-Out).
 *     *   A collection for completed tasks.
 * 3.  **Core Functionality:** The `TaskManager` class should provide the following public methods:
 *     *   `addTask(String description)`: Adds a new task to the pending tasks collection.
 *     *   `processNextTask()`: Removes the next task from the pending tasks collection, marks it as completed (conceptually, by moving it), and adds it to the completed tasks collection. If no tasks are pending, it should indicate an error condition.
 *     *   `listPendingTasks()`: Returns a list of all pending tasks.
 *     *   `listCompletedTasks()`: Returns a list of all completed tasks.
 * 4.  **User Interface:** Implement a command-line interface in a main class (`TaskManagerApp`) using `Scanner` to interact with the user.
 *     *   Display a menu with options:
 *         1.  Add New Task
 *         2.  Process Next Task
 *         3.  View Pending Tasks
 *         4.  View Completed Tasks
 *         5.  Exit
 *     *   Use a `switch` statement to handle the user's menu choice.
 *     *   Implement input validation for the menu choice (ensure it's an integer within the valid range).
 *     *   Implement input validation for the task description (e.g., not empty).
 * 5.  **Required Java Components:** Your solution *must* use ALL of the following Java components:
 *     *   `java.util.Queue` (as the type for the pending tasks collection)
 *     *   `java.util.ArrayList` (as the concrete implementation for the completed tasks collection)
 *     *   `java.util.List` (as the type for the completed tasks collection reference and for the return types of `listPendingTasks` and `listCompletedTasks` - note: `listPendingTasks` will need to return a `List` view or copy of the Queue's contents)
 *     *   `java.util.Scanner` for user input.
 *     *   `switch` statement for menu handling.
 *     *   `System.err` for printing error messages (e.g., invalid input, trying to process an empty queue).
 *     *   `System.out` for printing menu, prompts, task lists, and success messages.
 *     *   Class-wide exception handling using a `try-catch` block in the main execution flow to gracefully handle unexpected errors during the program's execution loop.
 * 6.  **Best Practices:** Adhere to best practices:
 *     *   Proper encapsulation (private fields, public methods).
 *     *   Meaningful variable and method names.
 *     *   Appropriate comments explaining the code.
 *     *   Clean code structure (separate classes).
 * 
 * **Expected Output:**
 * 
 * The program should present the menu, accept user input, perform the requested action, and display results or errors using `System.out` and `System.err` as specified.
 * 
 * *   Adding a task: Prompt for description, confirm addition.
 * *   Processing task: If queue is not empty, confirm which task was processed. If empty, print error to `System.err`.
 * *   Viewing tasks: Print lists of tasks clearly labeled. If a list is empty, indicate that.
 * *   Invalid input: Print error message to `System.err` and re-display menu.
 * *   Unexpected errors (caught by `try-catch`): Print a general error message to `System.err` and potentially exit or continue depending on the catch block's logic (for this exam, printing the error and continuing the loop is acceptable).
 * 
 * **Example Interaction Snippet:**
 * 
 * ```
 * Task Management System
 * 1. Add New Task
 * 2. Process Next Task
 * 3. View Pending Tasks
 * 4. View Completed Tasks
 * 5. Exit
 * Enter your choice: 1
 * Enter task description: Write exam question
 * Task added: Write exam question
 * 
 * Task Management System
 * ...
 * Enter your choice: 3
 * --- Pending Tasks ---
 * [Write exam question]
 * 
 * Task Management System
 * ...
 * Enter your choice: 2
 * Processed task: Write exam question
 * 
 * Task Management System
 * ...
 * Enter your choice: 3
 * --- Pending Tasks ---
 * (No pending tasks)
 * 
 * Task Management System
 * ...
 * Enter your choice: 4
 * --- Completed Tasks ---
 * [Write exam question]
 * 
 * Task Management System
 * ...
 * Enter your choice: 6
 * Error: Invalid choice. Please enter a number between 1 and 5.
 * 
 * Task Management System
 * ...
 * Enter your choice: 2
 * Error: No pending tasks to process.
 * 
 * Task Management System
 * ...
 * Enter your choice: 5
 * Exiting Task Management System.
 * ```
 * 
 * **Note:** The provided solution code must be a single, complete Java file.
 *
 * EXPLANATION:
 * This solution implements the Task Management System as described, fulfilling all requirements and demonstrating the specified Java concepts and best practices.
 * 
 * 1.  **Task Class:** The `Task` class is a simple Plain Old Java Object (POJO) with a private `description` field, a constructor, and an overridden `toString()` method for easy printing. This demonstrates basic encapsulation.
 * 
 * 2.  **TaskManager Class:**
 *     *   It uses a `Queue<Task>` named `pendingTasks` to store tasks waiting to be processed. A `LinkedList` is used as the concrete implementation because it efficiently supports the `Queue` operations (`offer`, `poll`). The `Queue` interface ensures that standard queue behavior is enforced.
 *     *   It uses a `List<Task>` named `completedTasks` to store tasks that have been processed. An `ArrayList` is used as the concrete implementation, suitable for storing and iterating over a list of completed items. Using the `List` interface for the reference promotes flexibility.
 *     *   `addTask(String description)`: Creates a new `Task` object and adds it to the `pendingTasks` queue using `offer()`. Includes a basic check for empty description.
 *     *   `processNextTask()`: Uses `poll()` to retrieve and remove the head of the `pendingTasks` queue. If `poll()` returns `null` (meaning the queue was empty), an error is printed to `System.err`. Otherwise, the retrieved task is added to the `completedTasks` list using `add()`.
 *     *   `listPendingTasks()`: Returns a *new* `ArrayList` populated with the elements from the `pendingTasks` queue. This fulfills the requirement to return a `List<Task>` and prevents external code from directly modifying the internal queue structure.
 *     *   `listCompletedTasks()`: Returns the internal `completedTasks` `List<Task>`.
 * 
 * 3.  **TaskManagerApp Class:**
 *     *   This is the main class containing the `main` method and the user interface logic.
 *     *   A `Scanner` is initialized to read input from `System.in`.
 *     *   A `TaskManager` instance is created.
 *     *   A `while` loop keeps the application running until the user chooses to exit.
 *     *   **Class-wide Exception Handling:** The core `while` loop is wrapped in a `try-catch(Exception e)` block. This demonstrates catching any unexpected exceptions that might occur during the program's main execution flow, printing an error message to `System.err`, and allowing the program to potentially continue or exit gracefully rather than crashing.
 *     *   **Input Handling & Validation:** Inside the loop, it prompts the user for input. A nested `try-catch(InputMismatchException e)` specifically handles cases where the user enters non-integer input for the menu choice, prints an error to `System.err`, consumes the invalid input using `scanner.next()` and `scanner.nextLine()` to prevent an infinite loop, and continues to the next iteration.
 *     *   **Switch Statement:** A `switch` statement is used to direct the program flow based on the valid integer input received from the user. Each case corresponds to a menu option, calling the appropriate `TaskManager` method or setting the `running` flag to `false` for exit. The `default` case handles integer inputs outside the valid range (1-5), printing an error to `System.err`.
 *     *   **System.out and System.err:** `System.out.println` is used for displaying the menu, prompts, success messages, and task lists. `System.err.println` is specifically used for printing error messages related to invalid input, empty queue processing, and the general unexpected exception caught by the outer `try-catch`.
 *     *   **Resource Management:** A `finally` block ensures the `Scanner` is closed when the main `try` block is exited (either normally or due to an exception), releasing system resources.
 * 
 * This solution effectively combines the required data structures (`Queue`, `ArrayList`, `List`) with control flow (`switch`), input/output (`Scanner`, `System.out`, `System.err`), object-oriented principles (encapsulation, separate classes), and robust error handling (`try-catch`) to create a functional and well-structured application, suitable for demonstrating advanced Java understanding.
 */

import java.util.ArrayList;
import java.util.LinkedList; // LinkedList implements Queue
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.InputMismatchException; // Specific exception for Scanner issues

// Represents a single task
class Task {
    private String description;

    // Constructor
    public Task(String description) {
        this.description = description;
    }

    // Getter for description (optional, but good practice)
    public String getDescription() {
        return description;
    }

    // String representation of the task
    @Override
    public String toString() {
        return description;
    }
}

// Manages the collections of tasks
class TaskManager {
    // Queue for pending tasks (FIFO order)
    private Queue<Task> pendingTasks;
    // List for completed tasks
    private List<Task> completedTasks;

    // Constructor initializes the collections
    public TaskManager() {
        // Using LinkedList as a Queue implementation
        this.pendingTasks = new LinkedList<>();
        // Using ArrayList as a List implementation
        this.completedTasks = new ArrayList<>();
    }

    /**
     * Adds a new task to the pending tasks queue.
     * @param description The description of the task.
     */
    public void addTask(String description) {
        if (description == null || description.trim().isEmpty()) {
            // Input validation handled before calling this, but defensive check is good
            System.err.println("Error: Task description cannot be empty.");
            return;
        }
        Task newTask = new Task(description.trim());
        pendingTasks.offer(newTask); // offer is preferred over add for queues
        System.out.println("Task added: " + newTask);
    }

    /**
     * Processes the next task in the pending queue.
     * Moves the task from pending to completed.
     * @return The task that was processed, or null if no tasks were pending.
     */
    public Task processNextTask() {
        Task nextTask = pendingTasks.poll(); // poll retrieves and removes the head
        if (nextTask != null) {
            completedTasks.add(nextTask);
            System.out.println("Processed task: " + nextTask);
            return nextTask;
        } else {
            System.err.println("Error: No pending tasks to process.");
            return null;
        }
    }

    /**
     * Returns a List view of the pending tasks.
     * Note: Iterating directly over the Queue is possible, but returning a List
     * matches the requirement for listPendingTasks returning a List.
     * Creating a new List avoids external modification of the internal queue state
     * via the returned list reference.
     * @return A new ArrayList containing the pending tasks.
     */
    public List<Task> listPendingTasks() {
        // Create a new ArrayList from the elements in the queue
        // This fulfills the requirement to return a List<Task>
        return new ArrayList<>(pendingTasks);
    }

    /**
     * Returns the list of completed tasks.
     * @return The List of completed tasks.
     */
    public List<Task> listCompletedTasks() {
        // Return the internal completedTasks list
        return completedTasks;
    }
}

// Main application class with user interface
public class TaskManagerApp {

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        TaskManager taskManager = new TaskManager();
        boolean running = true;

        System.out.println("Task Management System");

        // Class-wide exception handling for the main application loop
        try {
            while (running) {
                printMenu();

                int choice = -1;
                try {
                    System.out.print("Enter your choice: ");
                    choice = scanner.nextInt();
                    // Consume the newline character left by nextInt()
                    scanner.nextLine();
                } catch (InputMismatchException e) {
                    System.err.println("Error: Invalid input. Please enter a number.");
                    // Consume the invalid input to prevent infinite loop
                    scanner.next();
                    // Consume the newline after the invalid input
                    scanner.nextLine();
                    continue; // Skip the rest of the loop and show menu again
                }

                // Switch statement for menu options
                switch (choice) {
                    case 1: // Add New Task
                        System.out.print("Enter task description: ");
                        String description = scanner.nextLine();
                        if (description.trim().isEmpty()) {
                            System.err.println("Error: Task description cannot be empty.");
                        } else {
                            taskManager.addTask(description);
                        }
                        break;
                    case 2: // Process Next Task
                        taskManager.processNextTask();
                        break;
                    case 3: // View Pending Tasks
                        List<Task> pending = taskManager.listPendingTasks();
                        System.out.println("--- Pending Tasks ---");
                        if (pending.isEmpty()) {
                            System.out.println("(No pending tasks)");
                        } else {
                            for (int i = 0; i < pending.size(); i++) {
                                System.out.println((i + 1) + ". " + pending.get(i));
                            }
                        }
                        break;
                    case 4: // View Completed Tasks
                        List<Task> completed = taskManager.listCompletedTasks();
                        System.out.println("--- Completed Tasks ---");
                        if (completed.isEmpty()) {
                            System.out.println("(No completed tasks)");
                        } else {
                            for (int i = 0; i < completed.size(); i++) {
                                System.out.println((i + 1) + ". " + completed.get(i));
                            }
                        }
                        break;
                    case 5: // Exit
                        running = false;
                        System.out.println("Exiting Task Management System.");
                        break;
                    default: // Invalid choice
                        System.err.println("Error: Invalid choice. Please enter a number between 1 and 5.");
                        break;
                }
                System.out.println(); // Add a blank line for readability
            }
        } catch (Exception e) {
            // Catch any unexpected exceptions during the main loop execution
            System.err.println("An unexpected error occurred: " + e.getMessage());
            // e.printStackTrace(); // Optional: for debugging in a real scenario
        } finally {
            // Ensure the scanner is closed
            if (scanner != null) {
                scanner.close();
            }
        }
    }

    // Helper method to print the menu
    private static void printMenu() {
        System.out.println("Task Management System");
        System.out.println("1. Add New Task");
        System.out.println("2. Process Next Task");
        System.out.println("3. View Pending Tasks");
        System.out.println("4. View Completed Tasks");
        System.out.println("5. Exit");
    }
}
