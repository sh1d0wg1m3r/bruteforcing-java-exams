/*
 * Exam Question #216
 * Generated on: 2025-05-11 22:33:34
 * Generated by: Account 1
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Event Ticketing and Entry Management System
 * 
 * **Scenario:**
 * 
 * You are tasked with developing a simplified command-line system to manage ticket sales and control entry for a small event. The system needs to track all tickets sold, manage a queue of attendees waiting to enter, and process their entry one by one, validating their tickets and marking them as used.
 * 
 * **Requirements:**
 * 
 * Implement a Java application that fulfills the following requirements:
 * 
 * 1.  **Data Structures:**
 *     *   Maintain a collection of all tickets that have been sold. This collection must be declared using the `java.util.List` interface and instantiated as a `java.util.ArrayList`.
 *     *   Maintain a queue of tickets representing attendees who are currently waiting in line to enter the event. This queue must be declared using the `java.util.Queue` interface and instantiated using a suitable implementation (e.g., `java.util.LinkedList`).
 * 
 * 2.  **Ticket Representation:**
 *     *   Create a class named `Ticket` with private fields for `ticketId` (String), `type` (String, e.g., "STANDARD", "VIP"), and `isUsed` (boolean).
 *     *   Include a constructor to initialize `ticketId` and `type`, setting `isUsed` to `false` by default.
 *     *   Provide public getter methods for the fields and a public method `markAsUsed()` to set `isUsed` to `true`.
 *     *   Override the `toString()` method to provide a useful string representation of a ticket.
 * 
 * 3.  **Event Management Logic:**
 *     *   Create a class named `EventManager` that encapsulates the `List` of sold tickets and the `Queue` of attendees waiting for entry.
 *     *   Use `java.util.Scanner` within the `EventManager` class to handle user input from the console.
 *     *   Implement a menu-driven interface using a `switch` statement in the main application loop within `EventManager`. The menu options should be:
 *         1.  Sell Ticket
 *         2.  Enqueue Ticket for Entry
 *         3.  Process Next Entry
 *         4.  List All Sold Tickets
 *         5.  List Entry Queue
 *         6.  Exit
 * 
 * 4.  **Functionality Details:**
 *     *   **Sell Ticket:** Prompt the user for a Ticket ID and Ticket Type (STANDARD or VIP). Create a new `Ticket` object. Validate the ticket type (must be "STANDARD" or "VIP", case-insensitive). Validate that the Ticket ID is unique (not already in the sold tickets list). If valid, add the new ticket to the `soldTickets` list. Print a success message to `System.out`.
 *     *   **Enqueue Ticket for Entry:** Prompt the user for a Ticket ID. Search the `soldTickets` list for the ticket. If found, validate that it has not been marked as used. If valid, add the `Ticket` object to the `entryQueue`. Print a success message to `System.out`. If not found or already used, report an error.
 *     *   **Process Next Entry:** Check if the `entryQueue` is empty. If not, remove the next `Ticket` from the front of the queue. Find the *corresponding* `Ticket` object in the `soldTickets` list (based on Ticket ID) and mark it as used using the `markAsUsed()` method. Print details of the processed ticket to `System.out`. If the queue is empty, print a message to `System.out` indicating this.
 *     *   **List All Sold Tickets:** Iterate through the `soldTickets` list and print the `toString()` representation of each ticket to `System.out`.
 *     *   **List Entry Queue:** Iterate through the `entryQueue` and print the `toString()` representation of each ticket to `System.out`.
 * 
 * 5.  **Error Handling:**
 *     *   Implement robust error handling using `try-catch` blocks.
 *     *   Create custom exception classes for specific business logic errors: `TicketNotFoundException`, `TicketAlreadyUsedException`, `InvalidTicketTypeException`.
 *     *   Use `System.err` to print all error messages (e.g., invalid input, exceptions caught).
 *     *   Use `try-catch` blocks strategically within the `EventManager` methods and especially around the main menu processing loop in the `run()` method to demonstrate "class-wide" handling of exceptions originating from user commands and method calls. Catch `NumberFormatException` for invalid menu input. Catch your custom exceptions for business logic failures. Include a general `catch (Exception e)` for unexpected errors.
 *     *   Implement basic input validation (e.g., non-empty Ticket ID) where appropriate.
 * 
 * 6.  **Best Practices:**
 *     *   Apply proper encapsulation (private fields, public/private methods).
 *     *   Use meaningful variable and method names.
 *     *   Include appropriate comments for clarity.
 *     *   Structure the code into logical classes (`Ticket`, `EventManager`, and a main application class).
 * 
 * **Expected Output:**
 * 
 * The program should present a menu, accept user input, perform the requested operations, print results or list contents to `System.out`, and print error messages to `System.err` when validation or logic fails. The system should continue running until the user chooses the "Exit" option.
 * 
 * **Example Interaction Snippet (Illustrative):**
 * 
 * ```
 * --- Event Ticketing System ---
 * Choose an action:
 * 1. Sell Ticket
 * 2. Enqueue Ticket for Entry
 * 3. Process Next Entry
 * 4. List All Sold Tickets
 * 5. List Entry Queue
 * 6. Exit
 * Enter choice: 1
 * Enter Ticket ID: T001
 * Enter Ticket Type (STANDARD/VIP): standard
 * Ticket T001 (STANDARD) sold successfully.
 * 
 * Choose an action:
 * ... (menu repeats) ...
 * Enter choice: 1
 * Enter Ticket ID: T002
 * Enter Ticket Type (STANDARD/VIP): VIP
 * Ticket T002 (VIP) sold successfully.
 * 
 * Choose an action:
 * ... (menu repeats) ...
 * Enter choice: 1
 * Enter Ticket ID: T001
 * Enter Ticket Type (STANDARD/VIP): standard
 * Error: Ticket with ID T001 already exists.
 * 
 * Choose an action:
 * ... (menu repeats) ...
 * Enter choice: 2
 * Enter Ticket ID: T001
 * Ticket T001 enqueued for entry.
 * 
 * Choose an action:
 * ... (menu repeats) ...
 * Enter choice: 2
 * Enter Ticket ID: T003
 * Operation failed: Ticket with ID T003 not found.
 * 
 * Choose an action:
 * ... (menu repeats) ...
 * Enter choice: 5
 * --- Entry Queue ---
 * 1. Ticket [ID=T001, Type=STANDARD, Used=false]
 * -------------------
 * 
 * Choose an action:
 * ... (menu repeats) ...
 * Enter choice: 3
 * Processed entry for ticket: Ticket [ID=T001, Type=STANDARD, Used=true]
 * 
 * Choose an action:
 * ... (menu repeats) ...
 * Enter choice: 5
 * Entry queue is empty.
 * 
 * Choose an action:
 * ... (menu repeats) ...
 * Enter choice: 4
 * --- Sold Tickets ---
 * 1. Ticket [ID=T001, Type=STANDARD, Used=true]
 * 2. Ticket [ID=T002, Type=VIP, Used=false]
 * --------------------
 * 
 * Choose an action:
 * ... (menu repeats) ...
 * Enter choice: 6
 * Exiting system. Goodbye!
 * ```
 *
 * EXPLANATION:
 * This solution implements the Event Ticketing and Entry Management System as described in the exam question, demonstrating the required Java concepts and best practices.
 * 
 * **Key Concepts Demonstrated:**
 * 
 * 1.  **`Queue` (`java.util.Queue`)**: The `entryQueue` is declared as a `Queue<Ticket>`. This interface guarantees FIFO (First-In, First-Out) behavior, which is essential for managing a waiting line. The `offer()` method is used to add elements to the tail, and `poll()` is used to remove elements from the head when processing entries.
 * 2.  **`ArrayList` (`java.util.ArrayList`)**: The `soldTickets` collection is instantiated as an `ArrayList<Ticket>`. `ArrayList` provides a dynamic array implementation of the `List` interface, suitable for storing and accessing all sold tickets by index or iteration.
 * 3.  **`List` interface (`java.util.List`)**: The `soldTickets` collection is declared using the `List<Ticket>` interface. Programming to interfaces (`List` and `Queue`) rather than concrete implementations (`ArrayList` and `LinkedList`) promotes flexibility and good design.
 * 4.  **`Scanner` (`java.util.Scanner`)**: A `Scanner` object is used within the `EventManager` to read user input from `System.in` for menu choices and ticket details.
 * 5.  **`switch` statement**: The `run()` method uses a `switch` statement to direct program flow based on the user's numeric menu choice, making the menu handling clear and organized.
 * 6.  **`System.err`**: Error messages, such as invalid input, ticket not found, ticket already used, invalid ticket type, and unexpected exceptions, are printed to `System.err`, separating them from normal program output.
 * 7.  **`System.out`**: Normal program output, including the menu, prompts, success messages for operations, and lists of tickets/queue contents, is printed to `System.out`.
 * 8.  **Class-wide Exception Handling (`try-catch`)**:
 *     *   The main `while` loop in the `run()` method is wrapped in a `try` block. This demonstrates catching exceptions that might occur during the processing of any user command within that loop.
 *     *   Specific `catch` blocks are used to handle different types of exceptions: `NumberFormatException` for invalid menu input, custom exceptions (`TicketNotFoundException`, `TicketAlreadyUsedException`, `InvalidTicketTypeException`, `IllegalArgumentException`) for business logic errors thrown by helper methods, and a general `catch (Exception e)` for any other unexpected runtime errors.
 *     *   Helper methods (`sellTicket`, `enqueueForEntry`, `Ticket` constructor) throw specific exceptions when validation or business rules are violated, allowing the calling `run()` method (or prompt methods) to catch and handle them appropriately, often by printing an informative message to `System.err`.
 * 9.  **Custom Exceptions**: `TicketNotFoundException`, `TicketAlreadyUsedException`, and `InvalidTicketTypeException` are defined to provide meaningful error types for specific failure conditions related to the application's business logic.
 * 10. **Encapsulation**: The `Ticket` and `EventManager` classes use private fields and public/private methods to control access to their internal state, adhering to encapsulation principles.
 * 11. **Meaningful Names**: Variables (`soldTickets`, `entryQueue`, `ticketId`, `isUsed`), methods (`sellTicket`, `enqueueForEntry`, `processNextEntry`, `findTicketById`), and exceptions have names that clearly indicate their purpose.
 * 12. **Input Validation**: Checks are performed for empty input strings, valid ticket types ("STANDARD", "VIP"), duplicate ticket IDs during selling, and ticket existence/usage status during enqueuing.
 * 13. **Clean Code Structure**: The code is organized into separate classes (`Ticket`, `EventManager`, `EventApp`) with distinct responsibilities. Helper methods (`printMenu`, `sellTicketPrompt`, etc.) break down complex tasks into smaller, manageable units. Using `Optional` in `findTicketById` is a modern Java practice for handling potentially null results gracefully.
 * 
 * The solution effectively combines these elements to create a functional, robust, and well-structured application that simulates a real-world scenario while rigorously demonstrating advanced Java programming concepts. The interaction between the `List` (for all tickets) and the `Queue` (for waiting tickets), coupled with the requirement to update the state in the `List` based on processing from the `Queue`, adds a practical layer of complexity. The layered exception handling, using both specific and general `try-catch` blocks along with custom exceptions, showcases a strong understanding of error management.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.Optional; // Used for finding tickets safely

// --- Custom Exception Classes ---

/**
 * Custom exception thrown when a requested ticket is not found.
 */
class TicketNotFoundException extends Exception {
    public TicketNotFoundException(String message) {
        super(message);
    }
}

/**
 * Custom exception thrown when an operation is attempted on an already used ticket.
 */
class TicketAlreadyUsedException extends Exception {
    public TicketAlreadyUsedException(String message) {
        super(message);
    }
}

/**
 * Custom exception thrown when an invalid ticket type is provided.
 */
class InvalidTicketTypeException extends Exception {
    public InvalidTicketTypeException(String message) {
        super(message);
    }
}

// --- Ticket Class ---

/**
 * Represents a single event ticket with an ID, type, and usage status.
 */
class Ticket {
    private String ticketId;
    private String type; // e.g., "STANDARD", "VIP"
    private boolean isUsed;

    /**
     * Constructs a new Ticket.
     *
     * @param ticketId The unique ID for the ticket.
     * @param type     The type of the ticket (e.g., "STANDARD", "VIP").
     * @throws InvalidTicketTypeException If the ticket type is not "STANDARD" or "VIP".
     * @throws IllegalArgumentException   If ticketId is null or empty.
     */
    public Ticket(String ticketId, String type) throws InvalidTicketTypeException, IllegalArgumentException {
        if (ticketId == null || ticketId.trim().isEmpty()) {
             throw new IllegalArgumentException("Ticket ID cannot be null or empty.");
        }
        String upperType = type == null ? "" : type.trim().toUpperCase();
        if (!upperType.equals("STANDARD") && !upperType.equals("VIP")) {
            throw new InvalidTicketTypeException("Invalid ticket type: '" + type + "'. Must be STANDARD or VIP.");
        }

        this.ticketId = ticketId.trim().toUpperCase(); // Normalize ID to uppercase
        this.type = upperType; // Normalized type
        this.isUsed = false;
    }

    // --- Getters ---
    public String getTicketId() {
        return ticketId;
    }

    public String getType() {
        return type;
    }

    public boolean isUsed() {
        return isUsed;
    }

    /**
     * Marks the ticket as used.
     */
    public void markAsUsed() {
        this.isUsed = true;
    }

    /**
     * Provides a string representation of the Ticket.
     * @return String representation.
     */
    @Override
    public String toString() {
        return "Ticket [ID=" + ticketId + ", Type=" + type + ", Used=" + isUsed + "]";
    }

    // Optional: Implement equals and hashCode based on ticketId if needed for Set/Map operations
    // For this problem's List/Queue usage, simple iteration and lookup by ID is sufficient.
}

// --- EventManager Class ---

/**
 * Manages event tickets, sales, entry queue, and user interaction.
 */
class EventManager {
    // Use List interface, concrete implementation is ArrayList
    private List<Ticket> soldTickets;
    // Use Queue interface, concrete implementation is LinkedList
    private Queue<Ticket> entryQueue;
    private Scanner scanner;

    /**
     * Constructs a new EventManager, initializing data structures and scanner.
     */
    public EventManager() {
        soldTickets = new ArrayList<>();
        entryQueue = new LinkedList<>();
        scanner = new Scanner(System.in);
    }

    /**
     * Prints the main menu options to System.out.
     */
    private void printMenu() {
        System.out.println("Choose an action:");
        System.out.println("1. Sell Ticket");
        System.out.println("2. Enqueue Ticket for Entry");
        System.out.println("3. Process Next Entry");
        System.out.println("4. List All Sold Tickets");
        System.out.println("5. List Entry Queue");
        System.out.println("6. Exit");
    }

    /**
     * Prompts user for ticket details and attempts to sell a ticket.
     * Handles input and calls the core sellTicket method.
     * Exceptions from sellTicket (InvalidTicketTypeException, IllegalArgumentException)
     * are allowed to propagate up to the main run loop's catch block.
     */
    private void sellTicketPrompt() throws InvalidTicketTypeException, IllegalArgumentException {
        System.out.print("Enter Ticket ID: ");
        String id = scanner.nextLine();
        System.out.print("Enter Ticket Type (STANDARD/VIP): ");
        String type = scanner.nextLine();

        // Basic input validation before calling the core logic
        if (id == null || id.trim().isEmpty()) {
            System.err.println("Ticket ID cannot be empty.");
            return; // Exit prompt method, error handled locally
        }

        // Core logic: create and add ticket. This method might throw exceptions.
        sellTicket(id.trim(), type.trim());
        System.out.println("Ticket " + id.trim().toUpperCase() + " (" + type.trim().toUpperCase() + ") sold successfully.");
    }

    /**
     * Creates and adds a new ticket to the sold tickets list.
     * Checks for duplicate IDs.
     *
     * @param ticketId The unique ID for the ticket.
     * @param type     The type of the ticket (e.g., "STANDARD", "VIP").
     * @throws InvalidTicketTypeException If the ticket type is invalid.
     * @throws IllegalArgumentException   If ticketId is invalid (handled by Ticket constructor).
     */
    private void sellTicket(String ticketId, String type) throws InvalidTicketTypeException, IllegalArgumentException {
        // Check if ticket ID already exists before creating
        Optional<Ticket> existingTicket = findTicketById(ticketId);
        if (existingTicket.isPresent()) {
            // This is a business logic error, report it but don't throw an exception
            // as the prompt handles the input side and just needs feedback.
            // Or, we could throw a custom exception like DuplicateTicketIdException
            // For this exercise, printing error here is acceptable per prompt flow.
            System.err.println("Error: Ticket with ID " + ticketId.toUpperCase() + " already exists.");
            return; // Stop the operation
        }

        // Ticket constructor handles validation for ID format and Type
        Ticket newTicket = new Ticket(ticketId, type);
        soldTickets.add(newTicket);
    }

    /**
     * Prompts user for ticket ID and attempts to enqueue it for entry.
     * Handles input and calls the core enqueueForEntry method.
     * Exceptions from enqueueForEntry (TicketNotFoundException, TicketAlreadyUsedException)
     * are allowed to propagate up to the main run loop's catch block.
     */
    private void enqueueForEntryPrompt() throws TicketNotFoundException, TicketAlreadyUsedException {
        System.out.print("Enter Ticket ID to enqueue for entry: ");
        String id = scanner.nextLine();

        if (id == null || id.trim().isEmpty()) {
             System.err.println("Ticket ID cannot be empty.");
             return; // Exit prompt method
        }

        // Core logic: find and enqueue ticket. This method might throw exceptions.
        enqueueForEntry(id.trim());
        System.out.println("Ticket " + id.trim().toUpperCase() + " enqueued for entry.");
    }

    /**
     * Finds a ticket by its ID and adds it to the entry queue if valid.
     *
     * @param ticketId The ID of the ticket to enqueue.
     * @throws TicketNotFoundException   If no ticket with the given ID is found in soldTickets.
     * @throws TicketAlreadyUsedException If the ticket has already been used.
     */
    private void enqueueForEntry(String ticketId) throws TicketNotFoundException, TicketAlreadyUsedException {
        Optional<Ticket> ticketOptional = findTicketById(ticketId);

        if (!ticketOptional.isPresent()) {
            throw new TicketNotFoundException("Ticket with ID " + ticketId.toUpperCase() + " not found.");
        }

        Ticket ticket = ticketOptional.get();

        if (ticket.isUsed()) {
            throw new TicketAlreadyUsedException("Ticket with ID " + ticketId.toUpperCase() + " has already been used.");
        }

        // Optional: Check if already in queue to prevent duplicates, though Queue allows them
        // For this scenario, adding a ticket already in queue seems illogical
        if (entryQueue.contains(ticket)) {
             System.err.println("Ticket with ID " + ticketId.toUpperCase() + " is already in the entry queue.");
             return; // Do not add again
        }

        entryQueue.offer(ticket); // Add to the end of the queue
    }

    /**
     * Processes the next ticket in the entry queue.
     * This method directly calls the core logic.
     */
    private void processNextEntryPrompt() {
        // No input needed, just call the processing logic
        processNextEntry();
    }


    /**
     * Processes the next ticket in the entry queue.
     * Removes the ticket from the queue and marks it as used in the soldTickets list.
     */
    private void processNextEntry() {
        if (entryQueue.isEmpty()) {
            System.out.println("Entry queue is empty. No one is waiting to enter.");
            return;
        }

        // Get and remove the head of the queue
        Ticket ticketToProcess = entryQueue.poll();

        // Find the corresponding ticket in the soldTickets list to mark it as used.
        // We need to modify the instance stored in the list.
        Optional<Ticket> soldTicketOptional = findTicketById(ticketToProcess.getTicketId());

        if (soldTicketOptional.isPresent()) {
            Ticket soldTicket = soldTicketOptional.get();
            // Ensure we mark the *actual* ticket in the soldTickets list as used
            if (!soldTicket.isUsed()) { // Double check, although logic should prevent this
                 soldTicket.markAsUsed();
                 System.out.println("Processed entry for ticket: " + soldTicket);
            } else {
                 // This indicates a logic error where a used ticket got into the queue
                 System.err.println("Error: Processed a ticket that was already marked used: " + soldTicket);
            }
        } else {
            // This case should ideally not happen if tickets in queue are always from soldTickets
            System.err.println("Internal Error: Ticket from queue (" + ticketToProcess.getTicketId() + ") not found in sold tickets list.");
        }
    }

    /**
     * Lists all tickets that have been sold to System.out.
     */
    private void listSoldTickets() {
        if (soldTickets.isEmpty()) {
            System.out.println("No tickets have been sold yet.");
            return;
        }
        System.out.println("--- Sold Tickets ---");
        // Iterate using a traditional for loop to show index
        for (int i = 0; i < soldTickets.size(); i++) {
            System.out.println((i + 1) + ". " + soldTickets.get(i));
        }
        System.out.println("--------------------");
    }

    /**
     * Lists all tickets currently waiting in the entry queue to System.out.
     */
    private void listEntryQueue() {
        if (entryQueue.isEmpty()) {
            System.out.println("Entry queue is empty.");
            return;
        }
        System.out.println("--- Entry Queue ---");
        // Iterating over a Queue using enhanced for loop or iterator doesn't remove elements
        int index = 1;
        for (Ticket ticket : entryQueue) {
            System.out.println(index++ + ". " + ticket);
        }
        System.out.println("-------------------");
    }

    /**
     * Helper method to find a ticket in the soldTickets list by ID.
     * Uses iteration to find the ticket.
     *
     * @param ticketId The ID to search for.
     * @return An Optional containing the Ticket if found, otherwise empty.
     */
    private Optional<Ticket> findTicketById(String ticketId) {
         if (ticketId == null) return Optional.empty();
         String upperId = ticketId.trim().toUpperCase();
         for (Ticket ticket : soldTickets) {
             if (ticket.getTicketId().equals(upperId)) {
                 return Optional.of(ticket);
             }
         }
         return Optional.empty();
    }


    /**
     * The main application loop handling user interaction and class-wide exception handling.
     */
    public void run() {
        System.out.println("--- Event Ticketing System ---");
        int choice = -1;
        while (choice != 6) {
            printMenu();
            try {
                System.out.print("Enter choice: ");
                String input = scanner.nextLine();

                // Input validation for empty choice
                if (input == null || input.trim().isEmpty()) {
                     System.err.println("Input cannot be empty. Please enter a menu number.");
                     continue; // Skip to next loop iteration
                }

                // Attempt to parse the input as an integer
                choice = Integer.parseInt(input.trim());

                // Use switch for flow control based on valid integer input
                switch (choice) {
                    case 1:
                        sellTicketPrompt(); // Might throw InvalidTicketTypeException, IllegalArgumentException
                        break;
                    case 2:
                        enqueueForEntryPrompt(); // Might throw TicketNotFoundException, TicketAlreadyUsedException
                        break;
                    case 3:
                        processNextEntryPrompt(); // Handles empty queue internally
                        break;
                    case 4:
                        listSoldTickets();
                        break;
                    case 5:
                        listEntryQueue();
                        break;
                    case 6:
                        System.out.println("Exiting system. Goodbye!");
                        break;
                    default:
                        // Handle choices outside the valid range
                        System.err.println("Invalid choice. Please enter a number between 1 and 6.");
                }
            } catch (NumberFormatException e) {
                // Catch exception if input is not a valid integer
                System.err.println("Invalid input format. Please enter a valid number for the menu choice.");
            } catch (TicketNotFoundException | TicketAlreadyUsedException | InvalidTicketTypeException | IllegalArgumentException e) {
                // Catch specific custom exceptions thrown by prompt methods or their calls
                System.err.println("Operation failed: " + e.getMessage());
            } catch (Exception e) {
                // Catch any other unexpected exceptions that might occur
                System.err.println("An unexpected error occurred: " + e.getMessage());
                // For debugging, you might print the stack trace:
                // e.printStackTrace(System.err);
            }
            System.out.println(); // Add a newline for better readability between operations
        }
        scanner.close(); // Close scanner when exiting the application loop
    }
}

// --- Main Application Class ---

/**
 * Main class to start the Event Ticketing System.
 */
public class EventApp {
    public static void main(String[] args) {
        EventManager manager = new EventManager();
        manager.run();
    }
}
