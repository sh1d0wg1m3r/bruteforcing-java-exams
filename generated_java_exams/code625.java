/*
 * Exam Question #625
 * Generated on: 2025-05-12 16:16:32
 * Generated by: Account 5
 * 
 * QUESTION:
 * ## Advanced Java Programming Exam - Task Management System
 * 
 * **Scenario:**
 * 
 * You are tasked with building a simple console-based Task Management System for a small development team. The system should allow users to add new tasks, process the next highest-priority task, view all tasks, and find a specific task by its ID.
 * 
 * **Task Requirements:**
 * 
 * 1.  **Task Representation:** Create a `Task` class with the following attributes:
 *     *   Unique integer `id` (automatically generated).
 *     *   String `description`.
 *     *   `Priority` (an enum: `HIGH`, `MEDIUM`, `LOW`).
 *     *   `Status` (an enum: `PENDING`, `IN_PROGRESS`, `COMPLETED`).
 *     *   The `Task` class must implement `Comparable` based on `Priority`, where `HIGH` is the highest priority.
 * 
 * 2.  **Task Manager:** Create a `TaskManager` class that manages the tasks. It must use:
 *     *   A `Queue` (specifically, a `PriorityQueue`) to hold tasks that are `PENDING`, ordered by priority for processing.
 *     *   A `List` (specifically, an `ArrayList`) to store *all* tasks ever created, regardless of their current status or presence in the processing queue.
 *     *   Proper encapsulation (private fields, public methods).
 * 
 * 3.  **Functionality:** The `TaskManager` must provide the following methods:
 *     *   `addTask(String description, Priority priority)`: Creates a new task, adds it to both the `allTasks` list and the `taskQueue`. Assigns a unique ID.
 *     *   `processNextTask()`: Removes the highest-priority task from the `taskQueue`, updates its status to `IN_PROGRESS` (or `COMPLETED` for simplicity in this exercise), and returns the processed task. Handle the case where the queue is empty.
 *     *   `listAllTasks()`: Returns the `List` of all tasks.
 *     *   `findTaskById(int id)`: Finds and returns a task from the `allTasks` list by its ID. Returns `null` if not found.
 * 
 * 4.  **User Interface:** Implement a simple console interface in a `main` method (perhaps within the `TaskManager` class or a separate class) that uses `Scanner` to interact with the user. The interface should support the following commands:
 *     *   `add <priority> <description>`: Adds a new task. Priority must be `HIGH`, `MEDIUM`, or `LOW`. Description can be multiple words.
 *     *   `process`: Processes the next highest-priority task.
 *     *   `list`: Lists all tasks with their ID, priority, status, and description.
 *     *   `find <id>`: Finds and displays a specific task by ID.
 *     *   `exit`: Exits the application.
 * 
 * 5.  **Control Flow and Output:**
 *     *   Use a `switch` statement to handle the different user commands.
 *     *   Use `System.out` for normal output (prompts, task details, success messages).
 *     *   Use `System.err` for error messages (e.g., invalid command, invalid priority, task not found, processing empty queue).
 * 
 * 6.  **Exception Handling:** Implement robust exception handling using `try-catch` blocks. This should include:
 *     *   Handling invalid user input (e.g., non-integer ID for `find`, invalid priority string for `add`).
 *     *   Handling potential issues during task processing (e.g., `NoSuchElementException` if processing an empty queue, although `Queue.poll()` is safer than `remove()`).
 *     *   Demonstrate class-wide or method-level exception handling for the main command loop.
 * 
 * **Constraints & Best Practices:**
 * 
 * *   Ensure proper input validation for commands and arguments.
 * *   Use meaningful variable and method names.
 * *   Include appropriate comments explaining complex logic.
 * *   Follow Java coding conventions.
 * 
 * **Expected Output Structure:**
 * 
 * ```
 * Welcome to Task Management System!
 * Enter command (add <priority> <description>, process, list, find <id>, exit):
 * > add HIGH Finish Exam Question
 * Task added: [ID: 1, Priority: HIGH, Status: PENDING] Finish Exam Question
 * Enter command (add <priority> <description>, process, list, find <id>, exit):
 * > add LOW Write Documentation
 * Task added: [ID: 2, Priority: LOW, Status: PENDING] Write Documentation
 * Enter command (add <priority> <description>, process, list, find <id>, exit):
 * > add MEDIUM Test Solution
 * Task added: [ID: 3, Priority: MEDIUM, Status: PENDING] Test Solution
 * Enter command (add <priority> <description>, process, list, find <id>, exit):
 * > list
 * All Tasks:
 * [ID: 1, Priority: HIGH, Status: PENDING] Finish Exam Question
 * [ID: 2, Priority: LOW, Status: PENDING] Write Documentation
 * [ID: 3, Priority: MEDIUM, Status: PENDING] Test Solution
 * Enter command (add <priority> <description>, process, list, find <id>, exit):
 * > process
 * Processing task: [ID: 1, Priority: HIGH, Status: COMPLETED] Finish Exam Question
 * Enter command (add <priority> <description>, process, list, find <id>, exit):
 * > list
 * All Tasks:
 * [ID: 1, Priority: HIGH, Status: COMPLETED] Finish Exam Question
 * [ID: 2, Priority: LOW, Status: PENDING] Write Documentation
 * [ID: 3, Priority: MEDIUM, Status: PENDING] Test Solution
 * Enter command (add <priority> <description>, process, list, find <id>, exit):
 * > find 3
 * Task found: [ID: 3, Priority: MEDIUM, Status: PENDING] Test Solution
 * Enter command (add <priority> <description>, process, list, find <id>, exit):
 * > find 99
 * Error: Task with ID 99 not found.
 * Enter command (add <priority> <description>, process, list, find <id>, exit):
 * > add INVALID Test
 * Error: Invalid priority. Use HIGH, MEDIUM, or LOW.
 * Enter command (add <priority> <description>, process, list, find <id>, exit):
 * > process
 * Processing task: [ID: 3, Priority: MEDIUM, Status: COMPLETED] Test Solution
 * Enter command (add <priority> <description>, process, list, find <id>, exit):
 * > process
 * Processing task: [ID: 2, Priority: LOW, Status: COMPLETED] Write Documentation
 * Enter command (add <priority> <description>, process, list, find <id>, exit):
 * > process
 * Error: No tasks to process. Queue is empty.
 * Enter command (add <priority> <description>, process, list, find <id>, exit):
 * > exit
 * Exiting Task Management System.
 * ```
 * 
 * Your solution should provide the complete Java code for this system.
 *
 * EXPLANATION:
 * This solution implements a simple console-based Task Management System demonstrating the required Java concepts.
 * 
 * **Structure:**
 * 
 * 1.  **Enums (`Priority`, `Status`):** Provide type-safe constants for task priority and status, improving code readability and preventing invalid string values. The `Priority` enum includes a static helper method `fromString` for parsing user input case-insensitively.
 * 2.  **`Task` Class:** Represents a single task with an ID, description, priority, and status.
 *     *   **Encapsulation:** Fields are private with public getters and a controlled setter for status.
 *     *   **`Comparable<Task>`:** Implemented to allow `PriorityQueue` to order tasks. The comparison is based on the natural order of the `Priority` enum (where `HIGH` has a lower ordinal than `MEDIUM` and `LOW`), ensuring that `HIGH` priority tasks are processed first by the min-heap `PriorityQueue`.
 *     *   **`toString()`:** Provides a convenient string representation for printing task details.
 *     *   **Input Validation:** The constructor checks for null/empty description and null priority, throwing `IllegalArgumentException`.
 * 3.  **`TaskManager` Class:** Manages collections of tasks and the application logic.
 *     *   **`Queue<Task> taskQueue = new PriorityQueue<>();`**: A `PriorityQueue` is used as a `Queue` to store tasks that are `PENDING`. It automatically orders tasks based on the `compareTo` method implemented in the `Task` class, ensuring the highest priority task is always at the head of the queue (`poll()`).
 *     *   **`List<Task> allTasks = new ArrayList<>();`**: An `ArrayList` is used as a `List` to maintain a history of *all* tasks created, regardless of their status or whether they are currently in the processing queue. This allows listing all tasks or finding a task by ID easily.
 *     *   **`nextTaskId`:** A simple counter to generate unique IDs for tasks.
 *     *   **Methods (`addTask`, `processNextTask`, `listAllTasks`, `findTaskById`):** Implement the core business logic, interacting with the `taskQueue` and `allTasks` list.
 * 4.  **`main` Method (within `TaskManager`):**
 *     *   **`Scanner scanner = new Scanner(System.in);`**: Used to read user input from the console.
 *     *   **Command Loop:** A `while(running)` loop continuously prompts the user for input.
 *     *   **Input Parsing:** The input line is split to extract the command and its arguments.
 *     *   **`switch (command)`**: Controls the flow based on the user's command, directing execution to the appropriate logic block.
 *     *   **`System.out` and `System.err`**: Used correctly for normal output and error messages, respectively.
 * 
 * **Key Concepts Demonstrated:**
 * 
 * *   **Collections Framework:** Effective use of `Queue` (specifically `PriorityQueue`) for priority-based processing and `List` (specifically `ArrayList`) for storing and retrieving elements by index or iteration. Demonstrates choosing the appropriate collection type for a specific task.
 * *   **Enums:** Provides a robust way to represent a fixed set of constants (Priority, Status). The `fromString` helper method shows practical enum usage.
 * *   **Object-Oriented Programming:** Classes (`Task`, `TaskManager`), encapsulation (private fields, public methods), and relationships (TaskManager manages Task objects).
 * *   **`Comparable` Interface:** Used with `PriorityQueue` to define a custom ordering for `Task` objects based on their priority.
 * *   **Input/Output:** Using `Scanner` for console input and `System.out`/`System.err` for output.
 * *   **Control Flow:** Using a `while` loop for the main application loop and a `switch` statement for command dispatch.
 * *   **Exception Handling (`try-catch`):**
 *     *   Specific `try-catch` blocks are used within the `switch` cases to handle expected errors like `IllegalArgumentException` (from invalid priority string) and `NumberFormatException` (from invalid ID string).
 *     *   A broader `try-catch` block wraps the core logic *inside* the `while` loop. This demonstrates handling unexpected exceptions that might occur during command processing, preventing the application from crashing and allowing the loop to continue for the next command.
 * 
 * This solution effectively integrates the required components into a practical, well-structured, and robust application, demonstrating a solid understanding of intermediate to advanced Java concepts.
 */

import java.util.ArrayList;
import java.util.List;
import java.util.Queue;
import java.util.PriorityQueue;
import java.util.Scanner;
import java.util.NoSuchElementException; // Although poll is safer, good to be aware

// Enum for Task Priority
enum Priority {
    HIGH, MEDIUM, LOW;

    // Helper method to get Priority from string case-insensitively
    public static Priority fromString(String priorityStr) {
        if (priorityStr == null) {
            throw new IllegalArgumentException("Priority string cannot be null.");
        }
        return Priority.valueOf(priorityStr.toUpperCase());
    }
}

// Enum for Task Status
enum Status {
    PENDING, IN_PROGRESS, COMPLETED
}

// Task class implementing Comparable for PriorityQueue
class Task implements Comparable<Task> {
    private int id;
    private String description;
    private Priority priority;
    private Status status;

    // Constructor
    public Task(int id, String description, Priority priority) {
        if (description == null || description.trim().isEmpty()) {
            throw new IllegalArgumentException("Task description cannot be empty.");
        }
        if (priority == null) {
            throw new IllegalArgumentException("Task priority cannot be null.");
        }
        this.id = id;
        this.description = description;
        this.priority = priority;
        this.status = Status.PENDING; // New tasks start as PENDING
    }

    // Getters
    public int getId() {
        return id;
    }

    public String getDescription() {
        return description;
    }

    public Priority getPriority() {
        return priority;
    }

    public Status getStatus() {
        return status;
    }

    // Setter for status (used when processing)
    public void setStatus(Status status) {
        this.status = status;
    }

    // Implement compareTo for PriorityQueue
    // Lower value means higher priority (HIGH < MEDIUM < LOW)
    @Override
    public int compareTo(Task other) {
        // Compare based on priority enum's natural order (ordinal())
        // Since HIGH has ordinal 0, MEDIUM 1, LOW 2,
        // we want the smaller ordinal to be "less than" (higher priority).
        return this.priority.compareTo(other.priority);
    }

    // toString for easy printing
    @Override
    public String toString() {
        return "[ID: " + id + ", Priority: " + priority + ", Status: " + status + "] " + description;
    }
}

// TaskManager class
public class TaskManager {
    // Queue for tasks waiting to be processed (ordered by priority)
    private Queue<Task> taskQueue;

    // List to store all tasks ever created
    private List<Task> allTasks;

    // Counter for unique task IDs
    private int nextTaskId;

    // Constructor
    public TaskManager() {
        // PriorityQueue needs tasks to be Comparable
        this.taskQueue = new PriorityQueue<>();
        // ArrayList implements the List interface
        this.allTasks = new ArrayList<>();
        this.nextTaskId = 1; // Start IDs from 1
    }

    /**
     * Adds a new task to the system.
     *
     * @param description The description of the task.
     * @param priority    The priority of the task (HIGH, MEDIUM, LOW).
     * @return The newly created Task object.
     * @throws IllegalArgumentException if description is empty or priority is null.
     */
    public Task addTask(String description, Priority priority) {
        // Input validation handled by Task constructor
        Task newTask = new Task(nextTaskId++, description, priority);
        allTasks.add(newTask); // Add to the list of all tasks
        taskQueue.offer(newTask); // Add to the processing queue
        return newTask;
    }

    /**
     * Processes the next highest-priority task from the queue.
     *
     * @return The processed Task object, or null if the queue is empty.
     */
    public Task processNextTask() {
        // poll() returns null if queue is empty, safer than remove()
        Task taskToProcess = taskQueue.poll();
        if (taskToProcess != null) {
            // In a real system, this might set to IN_PROGRESS and require another step to complete.
            // For this exercise, we'll set directly to COMPLETED for simplicity.
            taskToProcess.setStatus(Status.COMPLETED);
            // Note: The task in the allTasks list is the same object reference,
            // so updating status here updates it in allTasks as well.
        }
        return taskToProcess;
    }

    /**
     * Returns a list of all tasks created in the system.
     *
     * @return A List containing all Task objects.
     */
    public List<Task> listAllTasks() {
        return allTasks;
    }

    /**
     * Finds a task by its unique ID.
     *
     * @param id The ID of the task to find.
     * @return The Task object if found, null otherwise.
     */
    public Task findTaskById(int id) {
        for (Task task : allTasks) {
            if (task.getId() == id) {
                return task;
            }
        }
        return null; // Task not found
    }

    // Main method to run the console application
    public static void main(String[] args) {
        TaskManager manager = new TaskManager();
        Scanner scanner = new Scanner(System.in);
        System.out.println("Welcome to Task Management System!");
        System.out.println("Enter command (add <priority> <description>, process, list, find <id>, exit):");

        boolean running = true;
        while (running) {
            System.out.print("> ");
            String line = scanner.nextLine().trim();
            String[] parts = line.split("\\s+", 3); // Split into command, arg1, arg2... up to 3 parts
            String command = parts.length > 0 ? parts[0].toLowerCase() : "";

            // Class-wide or method-level exception handling around the command processing loop
            try {
                switch (command) {
                    case "add":
                        if (parts.length < 3) {
                            System.err.println("Error: Invalid 'add' command format. Use: add <priority> <description>");
                            break;
                        }
                        String priorityStr = parts[1];
                        String description = parts[2];
                        try {
                            Priority priority = Priority.fromString(priorityStr);
                            Task newTask = manager.addTask(description, priority);
                            System.out.println("Task added: " + newTask);
                        } catch (IllegalArgumentException e) {
                            System.err.println("Error: Invalid priority. Use HIGH, MEDIUM, or LOW.");
                        }
                        break;

                    case "process":
                        Task processedTask = manager.processNextTask();
                        if (processedTask != null) {
                            System.out.println("Processing task: " + processedTask);
                        } else {
                            System.err.println("Error: No tasks to process. Queue is empty.");
                        }
                        break;

                    case "list":
                        List<Task> tasks = manager.listAllTasks();
                        if (tasks.isEmpty()) {
                            System.out.println("No tasks in the system.");
                        } else {
                            System.out.println("All Tasks:");
                            for (Task task : tasks) {
                                System.out.println(task);
                            }
                        }
                        break;

                    case "find":
                        if (parts.length < 2) {
                            System.err.println("Error: Invalid 'find' command format. Use: find <id>");
                            break;
                        }
                        try {
                            int id = Integer.parseInt(parts[1]);
                            Task foundTask = manager.findTaskById(id);
                            if (foundTask != null) {
                                System.out.println("Task found: " + foundTask);
                            } else {
                                System.err.println("Error: Task with ID " + id + " not found.");
                            }
                        } catch (NumberFormatException e) {
                            System.err.println("Error: Invalid task ID. Please enter a number.");
                        }
                        break;

                    case "exit":
                        running = false;
                        System.out.println("Exiting Task Management System.");
                        break;

                    case "": // Handle empty input line
                        break;

                    default:
                        System.err.println("Error: Unknown command. Available commands: add, process, list, find, exit");
                }
            } catch (Exception e) {
                // Catch any unexpected exceptions during command processing
                System.err.println("An unexpected error occurred: " + e.getMessage());
                // e.printStackTrace(); // Uncomment for debugging
            }
        }

        scanner.close(); // Close the scanner
    }
}
