/*
 * Exam Question #730
 * Generated on: 2025-05-12 16:32:21
 * Generated by: Account 4
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Help Desk Request Management System
 * 
 * **Scenario:**
 * 
 * You are tasked with building a simplified Help Desk system to manage incoming support requests. Requests arrive and are placed in a queue for agents to pick up. Once picked up, requests are moved to an "in progress" list. Agents can then update the status of requests in the "in progress" list until they are resolved or closed, at which point they are moved to a "completed" list.
 * 
 * **Requirements:**
 * 
 * Implement a Java console application that simulates this system. Your solution must adhere to the following specific requirements:
 * 
 * 1.  **Request Representation:** Create a class `Request` to represent a support request. It should have private fields for a unique integer `id`, a `String` `description`, and a status. Use an `enum` `RequestStatus` with states like `PENDING_QUEUE`, `IN_PROGRESS`, `RESOLVED`, `CLOSED`. Implement appropriate getters and setters, and a `toString()` method.
 * 2.  **System Core:** Create a class `HelpDeskSystem` that manages the requests. It must contain:
 *     *   A `java.util.Queue` to hold incoming requests (`PENDING_QUEUE` status).
 *     *   A `java.util.List` (implemented using `java.util.ArrayList`) to hold requests currently being worked on (`IN_PROGRESS` status). Declare the variable using the `List` interface type.
 *     *   A `java.util.List` (implemented using `java.util.ArrayList`) to hold completed requests (`RESOLVED` or `CLOSED` status). Declare the variable using the `List` interface type.
 *     *   A mechanism to generate unique request IDs.
 * 3.  **User Interaction:** Use `java.util.Scanner` to get user input from the console.
 * 4.  **Functionality:** Implement the following operations via a menu:
 *     *   **Add New Request:** Prompt the user for a description and add a new request with `PENDING_QUEUE` status to the incoming queue.
 *     *   **Pick Up Request:** Take the next request from the head of the incoming queue, change its status to `IN_PROGRESS`, and move it to the in-progress list. Handle the case where the queue is empty.
 *     *   **Update Request Status:** Prompt the user for a Request ID and a new status (`IN_PROGRESS`, `RESOLVED`, or `CLOSED`). Find the request in the in-progress list by its ID. If found, update its status. If the new status is `RESOLVED` or `CLOSED`, remove the request from the in-progress list and add it to the completed list. Handle cases where the ID is not found in the in-progress list or the entered status is invalid.
 *     *   **View All Requests:** Display all requests currently in the incoming queue, the in-progress list, and the completed list.
 *     *   **Exit:** Terminate the application.
 * 5.  **Control Flow:** Use a `switch` statement in the main application loop to handle the user's menu choice.
 * 6.  **Error Handling:** Implement robust error handling using `try-catch` blocks. This should include:
 *     *   Handling `InputMismatchException` for invalid numeric input from the `Scanner`.
 *     *   Handling `IllegalArgumentException` when parsing the status `enum` from user input.
 *     *   Handling attempts to pick up from an empty queue (display a message).
 *     *   Handling attempts to update a request that is not found in the in-progress list (display an error).
 *     *   Use `System.err` for all error messages.
 *     *   Use `System.out` for all normal output (menu, prompts, success messages, request listings).
 *     *   Implement class-wide exception handling by wrapping the main application loop or key operational calls within a `try-catch` block to catch unexpected errors.
 * 7.  **Best Practices:**
 *     *   Use proper encapsulation (private fields, public methods).
 *     *   Use meaningful variable and method names.
 *     *   Include appropriate comments to explain complex logic.
 *     *   Implement basic input validation (e.g., non-empty description, valid status strings).
 *     *   Structure the code cleanly into logical classes and methods.
 * 
 * **Expected Output:**
 * 
 * The program should present a menu to the user. Based on the user's choice, it should perform the requested action, print relevant information (success messages, request details, listings), or print error messages to `System.err` if an operation fails (e.g., invalid input, request not found, queue empty). The "View All Requests" option should clearly label and list requests in each of the three collections.
 * 
 * **Constraints:**
 * 
 * *   Focus on demonstrating the required Java components and error handling.
 * *   No need for complex features like persistence, multiple agents, or detailed request properties beyond ID, description, and status.
 * *   Assume user input for status update will be one of the valid enum names (case-insensitive for robustness, but case-sensitive `valueOf` is acceptable if error-handled). Let's stick to case-insensitive for better UX.
 *
 * EXPLANATION:
 * The provided Java solution implements a simplified Help Desk Request Management System, demonstrating the required advanced Java concepts and components.
 * 
 * **Overall Architecture:**
 * 
 * The system is composed of two main classes:
 * 1.  `Request`: A simple Plain Old Java Object (POJO) that encapsulates the data for a support request (ID, description, status). It uses an `enum` `RequestStatus` for clear and type-safe status representation. Encapsulation is achieved by making fields private and providing public getters/setters.
 * 2.  `HelpDeskSystem`: This is the core class that manages the collections of requests and handles user interaction and system operations. It contains the `main` method to start the application.
 * 
 * **Use of Required Java Components:**
 * 
 * *   **`java.util.Queue`**: The `incomingRequests` field is declared as a `Queue<Request>` and initialized with a `LinkedList`. This is used to store new requests in a FIFO (First-In, First-Out) manner, simulating a queue of incoming work waiting to be picked up. The `offer()` method is used to add requests to the tail, and `poll()` is used to retrieve and remove requests from the head.
 * *   **`java.util.ArrayList`**: `ArrayList` is used as the concrete implementation for the `inProgressRequests` and `completedRequests` lists. `ArrayList` provides dynamic arrays suitable for storing and accessing requests that are actively being managed or have been completed.
 * *   **`java.util.List`**: The variables `inProgressRequests` and `completedRequests` are declared using the `List` interface type (`List<Request>`). This demonstrates programming to an interface, a key object-oriented principle that promotes flexibility (allowing easy change of the underlying list implementation later if needed) and good design.
 * *   **`java.util.Scanner`**: A `Scanner` object is used throughout the `HelpDeskSystem` class (`scanner` field) to read user input from `System.in` for menu choices, request descriptions, and request IDs/statuses for updates.
 * *   **`switch` statement**: The `run()` method uses a `switch` statement based on the user's menu choice (`choice`) to direct the program flow to the appropriate operation method (`addRequest`, `pickUpRequest`, `updateRequestStatus`, `viewRequests`, or exit).
 * *   **`System.err`**: `System.err` is explicitly used for printing all error messages, such as invalid input, requests not found, or invalid status transitions. This visually distinguishes error output from normal program output.
 * *   **`System.out`**: `System.out` is used for all standard output, including displaying the menu, prompts for input, success messages after operations, and listing the requests when viewing them.
 * *   **`try-catch` blocks**: Exception handling is implemented using `try-catch` blocks in multiple places:
 *     *   In the `run()` method, a `try-catch` block wraps the reading of the menu choice to handle `InputMismatchException` if the user enters non-numeric input.
 *     *   A larger `try-catch` block in `run()` wraps the main `while` loop to catch any unexpected `Exception` that might occur during the system's operation, providing a basic class-wide error handling mechanism.
 *     *   In `updateRequestStatus()`, separate `try-catch` blocks handle `InputMismatchException` when reading the Request ID and `IllegalArgumentException` when attempting to parse the user-provided status string into a `RequestStatus` enum value using `valueOf()`.
 * 
 * **Flow of a Request:**
 * 
 * 1.  A request is created via the "Add New Request" option and added to the `incomingRequests` `Queue` with `PENDING_QUEUE` status.
 * 2.  When "Pick Up Request" is chosen, the oldest request from the `incomingRequests` `Queue` is taken, its status is changed to `IN_PROGRESS`, and it's added to the `inProgressRequests` `List`.
 * 3.  When "Update Request Status" is chosen, the system finds the request by ID within the `inProgressRequests` `List`. If found, its status is updated. If the new status is `RESOLVED` or `CLOSED`, the request is removed from the `inProgressRequests` `List` and added to the `completedRequests` `List`.
 * 4.  "View All Requests" displays the current state of all three collections.
 * 
 * **Best Practices:**
 * 
 * *   **Encapsulation:** The `Request` class demonstrates good encapsulation.
 * *   **Naming:** Variables (`incomingRequests`, `inProgressRequests`, `nextRequestId`) and methods (`addRequest`, `pickUpRequest`, `updateRequestStatus`, `viewRequests`) have meaningful names reflecting their purpose.
 * *   **Comments:** Basic inline comments are used to explain key parts of the code, such as the purpose of collections or specific logic within methods.
 * *   **Input Validation:** Checks are performed for empty descriptions and invalid numeric/enum inputs using `if` statements and `try-catch`.
 * *   **Error Handling:** Errors are reported using `System.err`, specific exceptions are caught where appropriate (`InputMismatchException`, `IllegalArgumentException`), and a general catch in the main loop provides resilience against unhandled errors.
 * *   **Clean Code Structure:** The code is organized into logical classes and methods, each with a single responsibility (e.g., `addRequest` only handles adding, `viewRequests` only handles displaying).
 * 
 * This solution effectively integrates the required Java components within a practical scenario, emphasizing data structure usage, user interaction handling, control flow, and robust error management, making it a suitable challenging exam task.
 */

import java.util.Queue;
import java.util.LinkedList; // Common Queue implementation
import java.util.List;
import java.util.ArrayList; // Common List implementation
import java.util.Scanner;
import java.util.InputMismatchException;
import java.util.Iterator; // Useful for removing from list during iteration

// Enum to represent the status of a support request
enum RequestStatus {
    PENDING_QUEUE,
    IN_PROGRESS,
    RESOLVED,
    CLOSED
}

// Class to represent a support request
class Request {
    private int id;
    private String description;
    private RequestStatus status;

    // Constructor
    public Request(int id, String description) {
        this.id = id;
        this.description = description;
        this.status = RequestStatus.PENDING_QUEUE; // Initial status
    }

    // Getters
    public int getId() {
        return id;
    }

    public String getDescription() {
        return description;
    }

    public RequestStatus getStatus() {
        return status;
    }

    // Setter for status
    public void setStatus(RequestStatus status) {
        this.status = status;
    }

    // Override toString for easy printing
    @Override
    public String toString() {
        return "Request [ID=" + id + ", Status=" + status + ", Description='" + description + "']";
    }
}

// Main class for the Help Desk System logic
public class HelpDeskSystem {

    // Queue for new incoming requests
    private Queue<Request> incomingRequests;
    // List for requests currently being worked on
    private List<Request> inProgressRequests;
    // List for requests that have been resolved or closed
    private List<Request> completedRequests;
    // Counter for generating unique request IDs
    private int nextRequestId;
    // Scanner for reading user input
    private Scanner scanner;

    // Constructor
    public HelpDeskSystem() {
        // Use LinkedList for Queue implementation
        this.incomingRequests = new LinkedList<>();
        // Use ArrayList for List implementations
        this.inProgressRequests = new ArrayList<>();
        this.completedRequests = new ArrayList<>();
        this.nextRequestId = 1; // Start IDs from 1
        this.scanner = new Scanner(System.in);
    }

    // Method to add a new request based on user input
    public void addRequest() {
        System.out.println("Enter request description:");
        String description = scanner.nextLine();

        // Input validation for description
        if (description == null || description.trim().isEmpty()) {
             System.err.println("Error: Request description cannot be empty.");
             return; // Exit method if input is invalid
        }

        Request newRequest = new Request(nextRequestId++, description.trim());
        incomingRequests.offer(newRequest); // Add the new request to the tail of the queue
        System.out.println("Success: Request #" + newRequest.getId() + " added to the incoming queue.");
    }

    // Method to pick up the next request from the queue
    public void pickUpRequest() {
        Request request = incomingRequests.poll(); // Retrieve and remove the head of the queue

        if (request == null) {
            // Handle empty queue case
            System.out.println("Info: No requests currently in the incoming queue.");
        } else {
            request.setStatus(RequestStatus.IN_PROGRESS); // Update status
            inProgressRequests.add(request); // Add to the in-progress list
            System.out.println("Success: Request #" + request.getId() + " picked up and moved to In Progress.");
        }
    }

    // Method to update the status of a request in the in-progress list
    public void updateRequestStatus() {
        System.out.println("Enter Request ID to update status:");
        int idToUpdate;

        // Try-catch for reading integer ID
        try {
            idToUpdate = scanner.nextInt();
            scanner.nextLine(); // Consume the newline character left by nextInt()
        } catch (InputMismatchException e) {
            System.err.println("Error: Invalid input. Please enter a valid number for the Request ID.");
            scanner.nextLine(); // Consume the invalid input to prevent infinite loop
            return; // Exit method on invalid input
        }

        Request requestToUpdate = null;
        // Search for the request in the in-progress list
        // Use Iterator for safe removal if status changes to completed
        Iterator<Request> iterator = inProgressRequests.iterator();
        while (iterator.hasNext()) {
            Request req = iterator.next();
            if (req.getId() == idToUpdate) {
                requestToUpdate = req;
                // Do not break here if using iterator for potential removal later
                break; // Found the request
            }
        }

        // Handle case where request is not found in the in-progress list
        if (requestToUpdate == null) {
            System.err.println("Error: Request with ID " + idToUpdate + " not found in the In Progress list.");
            return; // Exit method
        }

        System.out.println("Current status for Request #" + idToUpdate + ": " + requestToUpdate.getStatus());
        System.out.println("Enter new status (IN_PROGRESS, RESOLVED, CLOSED):");
        String statusString = scanner.nextLine().trim().toUpperCase(); // Read and format status input

        // Try-catch for parsing the status enum
        try {
            RequestStatus newStatus = RequestStatus.valueOf(statusString);

            // Validate transition (optional but good practice - simple version here)
            // Ensure it's a valid status for an 'in progress' item
            if (newStatus == RequestStatus.PENDING_QUEUE) {
                 System.err.println("Error: Cannot change status back to PENDING_QUEUE from In Progress.");
                 return;
            }

            requestToUpdate.setStatus(newStatus); // Update the status
            System.out.println("Success: Status for Request #" + idToUpdate + " updated to " + newStatus + ".");

            // If status is resolved or closed, move from in-progress to completed list
            if (newStatus == RequestStatus.RESOLVED || newStatus == RequestStatus.CLOSED) {
                // Need to find and remove the request from the in-progress list again
                // Using a standard for-each loop and then removing by object reference is fine too,
                // or use the iterator's remove() method if the loop finds it.
                // Let's use iterator remove for demonstration.
                // Re-find with iterator if we didn't keep the iterator position
                 Iterator<Request> removeIterator = inProgressRequests.iterator();
                 while(removeIterator.hasNext()) {
                     Request req = removeIterator.next();
                     if (req.getId() == idToUpdate) {
                         removeIterator.remove(); // Safely remove using iterator
                         break;
                     }
                 }
                completedRequests.add(requestToUpdate); // Add to completed list
                System.out.println("Info: Request #" + idToUpdate + " moved to Completed list.");
            }

        } catch (IllegalArgumentException e) {
            // Handle case where the input string does not match any enum constant
            System.err.println("Error: Invalid status '" + statusString + "'. Valid statuses are IN_PROGRESS, RESOLVED, CLOSED.");
        }
    }

    // Method to display all requests in their respective collections
    public void viewRequests() {
        System.out.println("\n--- Incoming Requests Queue (" + incomingRequests.size() + " requests) ---");
        if (incomingRequests.isEmpty()) {
            System.out.println("  (Queue is empty)");
        } else {
            // Iterate and print queue elements
            incomingRequests.forEach(System.out::println);
        }

        System.out.println("\n--- In Progress Requests List (" + inProgressRequests.size() + " requests) ---");
        if (inProgressRequests.isEmpty()) {
            System.out.println("  (List is empty)");
        } else {
            // Iterate and print list elements
            inProgressRequests.forEach(System.out::println);
        }

        System.out.println("\n--- Completed Requests List (" + completedRequests.size() + " requests) ---");
        if (completedRequests.isEmpty()) {
            System.out.println("  (List is empty)");
        } else {
            // Iterate and print list elements
            completedRequests.forEach(System.out::println);
        }
        System.out.println("---------------------------------------------------\n");
    }

    // Method to display the main menu options
    private void displayMenu() {
        System.out.println("--- Help Desk System Menu ---");
        System.out.println("1. Add New Request");
        System.out.println("2. Pick Up Request from Queue");
        System.out.println("3. Update Request Status (In Progress)");
        System.out.println("4. View All Requests");
        System.out.println("5. Exit");
        System.out.print("Enter your choice: ");
    }

    // Main method to run the application loop
    public void run() {
        boolean running = true;
        // Class-wide exception handling wrapping the main operational loop
        try {
            while (running) {
                displayMenu();
                int choice;
                try {
                    // Read menu choice, handling potential non-integer input
                    choice = scanner.nextInt();
                    scanner.nextLine(); // Consume the leftover newline
                } catch (InputMismatchException e) {
                    System.err.println("Error: Invalid input. Please enter a number corresponding to the menu option.");
                    scanner.nextLine(); // Consume the invalid input to prevent loop
                    continue; // Skip the rest of the loop iteration and show menu again
                }

                // Use switch statement for menu navigation
                switch (choice) {
                    case 1:
                        addRequest();
                        break;
                    case 2:
                        pickUpRequest();
                        break;
                    case 3:
                        updateRequestStatus();
                        break;
                    case 4:
                        viewRequests();
                        break;
                    case 5:
                        running = false; // Set flag to exit loop
                        System.out.println("Exiting Help Desk System. Goodbye!");
                        break;
                    default:
                        // Handle choices outside the valid range
                        System.err.println("Error: Invalid choice. Please enter a number between 1 and 5.");
                }
            }
        } catch (Exception e) {
            // Catch any unexpected runtime exceptions not specifically handled elsewhere
            System.err.println("An unexpected system error occurred: " + e.getMessage());
            // Optional: e.printStackTrace(); for detailed debugging in a real scenario
        } finally {
            // Ensure scanner is closed when the application exits
            if (scanner != null) {
                scanner.close();
            }
        }
    }

    // Entry point of the application
    public static void main(String[] args) {
        HelpDeskSystem system = new HelpDeskSystem();
        system.run(); // Start the system
    }
}
