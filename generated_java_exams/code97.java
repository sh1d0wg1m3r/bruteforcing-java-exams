/*
 * Exam Question #97
 * Generated on: 2025-05-11 22:13:44
 * Generated by: Account 5
 * 
 * QUESTION:
 * ## Advanced Java Programming Exam Task: Emergency Response Dispatch System
 * 
 * **Scenario:**
 * 
 * You are tasked with building a simplified system for managing incoming emergency calls and dispatching them to available responders. The system needs to handle incoming calls in the order they are received, maintain a list of available responders, and assign the next pending call to a responder when requested.
 * 
 * **Requirements:**
 * 
 * Implement a Java program that simulates this system. Your solution must adhere to the following specifications:
 * 
 * 1.  **Core Classes:**
 *     *   Create a `Task` class to represent an emergency call. It should have:
 *         *   A unique integer `id`.
 *         *   A String `description` of the emergency.
 *         *   An enum `TaskStatus` with values `PENDING` and `DISPATCHED`.
 *         *   Private fields for these attributes.
 *         *   A constructor to initialize `id` and `description` (status is initially `PENDING`).
 *         *   Public getter methods for all attributes.
 *         *   A public method `setStatus(TaskStatus status)` to update the task's status.
 *     *   Create a main class, `EmergencyDispatchSystem`, to manage the system's state and operations.
 * 
 * 2.  **System State Management:**
 *     *   The `EmergencyDispatchSystem` class must maintain:
 *         *   A `Queue<Task>` to hold incoming emergency calls that are awaiting dispatch.
 *         *   A `List<String>` to store the names of available responders.
 *         *   A `List<Task>` to hold tasks that have been dispatched.
 *         *   A counter for generating unique task IDs.
 *     *   Declare these data structures using the `java.util.Queue` and `java.util.List` interfaces, instantiated with appropriate concrete classes (`java.util.LinkedList` for the Queue, `java.util.ArrayList` for the Lists).
 * 
 * 3.  **User Interface and Operations:**
 *     *   The `EmergencyDispatchSystem` should have a `main` method that provides a command-line interface using `java.util.Scanner`.
 *     *   Present a menu to the user with the following options:
 *         1.  Add New Emergency Call
 *         2.  Add New Responder
 *         3.  Dispatch Next Pending Call
 *         4.  View Pending Calls
 *         5.  View Dispatched Calls
 *         6.  View Available Responders
 *         7.  Exit
 *     *   Use a `switch` statement in the `main` method to handle the user's menu selection.
 *     *   Implement methods in `EmergencyDispatchSystem` for each menu option (e.g., `addTask(String description)`, `addResponder(String name)`, `dispatchNextTask()`, `viewPendingTasks()`, `viewDispatchedTasks()`, `viewAvailableResponders()`). These methods should be public and interact with the private data structures.
 * 
 * 4.  **Core Logic:**
 *     *   **Add New Emergency Call:** Prompt the user for a description. Create a new `Task` object with a unique ID and `PENDING` status, and add it to the pending tasks queue. Validate that the description is not empty.
 *     *   **Add New Responder:** Prompt the user for a responder name. Add the name to the list of available responders. Validate that the name is not empty.
 *     *   **Dispatch Next Pending Call:**
 *         *   Check if there are any pending tasks in the queue. If not, display an informative message.
 *         *   Check if there are any available responders. If not, display an informative message.
 *         *   If both are available, take the next task from the *front* of the pending queue.
 *         *   Assign it to the *first* responder in the available responders list (for simplicity, responders are always available in this model; you don't need to track their busy status).
 *         *   Update the task's status to `DISPATCHED`.
 *         *   Move the task from the pending queue to the dispatched tasks list.
 *         *   Print a confirmation message indicating which task was dispatched to which responder.
 *     *   **View Pending Calls:** Print the details (ID, description, status) of all tasks currently in the pending queue. If the queue is empty, print a message.
 *     *   **View Dispatched Calls:** Print the details (ID, description, status) of all tasks in the dispatched tasks list. If the list is empty, print a message.
 *     *   **View Available Responders:** Print the names of all responders in the available responders list. If the list is empty, print a message.
 * 
 * 5.  **Error Handling and Output:**
 *     *   Use `System.out` for all normal output, including the menu, confirmations, and list displays.
 *     *   Use `System.err` for displaying error messages, such as invalid input (empty description/name) or attempting to dispatch when no tasks or responders are available.
 *     *   Implement class-wide exception handling using `try-catch` blocks. Wrap the main operational loop (the `while` loop in `main`) within a `try-catch` block to catch potential unexpected runtime exceptions and handle them gracefully by printing an error message using `System.err` before exiting or allowing the loop to continue if possible. Also, handle specific input validation errors (like empty strings) within the respective methods and report them via `System.err`. Handle `InputMismatchException` from `Scanner` when reading integer input.
 * 
 * 6.  **Best Practices:**
 *     *   Use proper encapsulation (private fields, public methods).
 *     *   Use meaningful variable, method, and class names.
 *     *   Include appropriate comments and documentation (e.g., Javadoc for classes and methods).
 *     *   Perform input validation for user-provided data (descriptions, names).
 *     *   Ensure clean code structure and formatting.
 * 
 * **Expected Output:**
 * 
 * The program should present a menu, accept integer input for choices, and string input for descriptions/names. Output should be informative, showing the results of operations, task lists, and error messages clearly distinguishable via `System.out` and `System.err`.
 * 
 * Example interaction flow (not exhaustive):
 * 
 * ```
 * --- Emergency Dispatch System Menu ---
 * 1. Add New Emergency Call
 * 2. Add New Responder
 * 3. Dispatch Next Pending Call
 * 4. View Pending Calls
 * 5. View Dispatched Calls
 * 6. View Available Responders
 * 7. Exit
 * Enter your choice: 1
 * Enter emergency description: House fire on Elm Street
 * New task added: Task{id=1, description='House fire on Elm Street', status=PENDING}
 * 
 * --- Emergency Dispatch System Menu ---
 * ...
 * Enter your choice: 2
 * Enter responder name: Responder Alpha
 * New responder added: Responder Alpha
 * 
 * --- Emergency Dispatch System Menu ---
 * ...
 * Enter your choice: 3
 * Dispatching task...
 * Task 1 ('House fire on Elm Street') dispatched to Responder Alpha.
 * 
 * --- Emergency Dispatch System Menu ---
 * ...
 * Enter your choice: 4
 * --- Pending Tasks ---
 * No pending tasks.
 * 
 * --- Emergency Dispatch System Menu ---
 * ...
 * Enter your choice: 5
 * --- Dispatched Tasks ---
 * Task{id=1, description='House fire on Elm Street', status=DISPATCHED}
 * 
 * --- Emergency Dispatch System Menu ---
 * ...
 * Enter your choice: 3
 * Dispatching task...
 * Error: No pending tasks to dispatch.
 * 
 * --- Emergency Dispatch System Menu ---
 * ...
 * Enter your choice: 7
 * Exiting system.
 * ```
 * 
 * Your solution must be a single Java file containing all necessary classes and the `main` method.
 * 
 * **Challenge:** Ensure your code correctly manages the state transitions (from pending queue to dispatched list) and handles edge cases like empty queues or lists gracefully using appropriate checks and error reporting.
 *
 * EXPLANATION:
 * This solution implements a basic Emergency Response Dispatch System demonstrating the required Java concepts and best practices.
 * 
 * 1.  **`Task` Class:**
 *     *   Represents an individual emergency call with an ID, description, and status (`PENDING` or `DISPATCHED`).
 *     *   Uses an `enum` (`TaskStatus`) for clear status representation.
 *     *   Employs encapsulation with private fields and public getters/setters.
 *     *   Includes input validation in the constructor to ensure the description is not empty, throwing an `IllegalArgumentException`.
 * 
 * 2.  **`EmergencyDispatchSystem` Class:**
 *     *   This is the main class managing the system state.
 *     *   **`Queue<Task> pendingTasks`**: A `LinkedList` is used here, implementing the `Queue` interface. It correctly models the FIFO (First-In, First-Out) nature of incoming calls waiting to be processed. `offer()` is used for adding and `poll()` for retrieving and removing the head element.
 *     *   **`List<String> availableResponders`**: An `ArrayList` is used, implementing the `List` interface. It stores the names of responders. In this simplified model, this list represents the pool of responders who can be assigned tasks; we don't track their individual busy state.
 *     *   **`List<Task> dispatchedTasks`**: Another `ArrayList` implementing `List`. It keeps a record of tasks that have been processed and assigned to a responder.
 *     *   **`nextTaskId`**: An integer counter to ensure each task gets a unique sequential ID.
 *     *   **Encapsulation:** All data structures and the ID counter are `private`, accessed and modified only through the class's public methods.
 * 
 * 3.  **User Interface (`main` method) and Flow Control:**
 *     *   The `main` method creates an instance of `EmergencyDispatchSystem` and a `Scanner` for input.
 *     *   It runs a `while` loop that continues until the user chooses to exit (option 7).
 *     *   Inside the loop, it calls `printMenu()` and reads the user's integer choice.
 *     *   A `switch` statement handles the different integer choices, directing execution to the appropriate method within the `EmergencyDispatchSystem` instance.
 *     *   `scanner.nextLine()` is used after `scanner.nextInt()` to consume the leftover newline character, preventing issues with subsequent `nextLine()` calls.
 * 
 * 4.  **Operational Methods:**
 *     *   **`addTask()`**: Creates a new `Task` object using the provided description and the next available ID, then adds it to the `pendingTasks` queue using `offer()`. Includes a `try-catch` block to handle the `IllegalArgumentException` that the `Task` constructor might throw for empty descriptions, reporting the error via `System.err`.
 *     *   **`addResponder()`**: Adds a responder name to the `availableResponders` list. Includes validation to ensure the name is not empty, reporting the error via `System.err`.
 *     *   **`dispatchNextTask()`**: This method orchestrates the core dispatch logic.
 *         *   It first checks if `pendingTasks` is empty using `isEmpty()`. If so, it prints an error to `System.err` and returns.
 *         *   It then checks if `availableResponders` is empty. If so, it prints an error to `System.err` and returns.
 *         *   If both are available, it uses `pendingTasks.poll()` to get and remove the next task from the queue.
 *         *   It gets the first responder name from `availableResponders.get(0)`.
 *         *   It updates the task's status to `DISPATCHED` using `setStatus()`.
 *         *   It adds the dispatched task to the `dispatchedTasks` list.
 *         *   Finally, it prints a success message using `System.out`.
 *     *   **`viewPendingTasks()`**: Iterates through the `pendingTasks` queue (without removing elements, e.g., using `forEach` or an iterator) and prints each task's details using its `toString()` method. Checks if the queue is empty and prints a message if so.
 *     *   **`viewDispatchedTasks()`**: Iterates through the `dispatchedTasks` list and prints each task's details. Checks if the list is empty.
 *     *   **`viewAvailableResponders()`**: Iterates through the `availableResponders` list and prints each name. Checks if the list is empty.
 * 
 * 5.  **Error Handling:**
 *     *   **Input Validation:** Methods like `addTask` and `addResponder` explicitly check for empty input strings and print error messages to `System.err`.
 *     *   **Operational Errors:** `dispatchNextTask` checks for empty queues/lists before attempting operations, printing errors to `System.err`.
 *     *   **`InputMismatchException`:** A `try-catch` block specifically for `InputMismatchException` is used around `scanner.nextInt()` within the main loop's inner `try` block. This catches non-integer input, prints an error to `System.err`, and consumes the invalid input to prevent an infinite loop.
 *     *   **Class-wide Exception Handling:** The main `while` loop in `main` is wrapped in a `try-catch(Exception e)` block. This serves as a general catch-all for any unexpected runtime exceptions that might occur and weren't handled by more specific `try-catch` blocks (like the `InputMismatchException` or `IllegalArgumentException`). It prints a generic error message to `System.err`.
 *     *   **`finally` block:** A `finally` block ensures that the `Scanner` is closed when the program exits the `try` block (either normally or due to an exception), releasing system resources.
 * 
 * 6.  **Best Practices:**
 *     *   Meaningful names are used (e.g., `pendingTasks`, `dispatchNextTask`, `availableResponders`).
 *     *   Comments and Javadoc-style documentation are included for classes and methods.
 *     *   The code is structured logically with separate methods for distinct operations.
 *     *   `System.out` and `System.err` are used appropriately for different types of output.
 * 
 * This solution effectively integrates all required components to build a functional, albeit simple, simulation while demonstrating good programming practices and robust error handling.
 */

import java.util.Queue;
import java.util.LinkedList;
import java.util.List;
import java.util.ArrayList;
import java.util.Scanner;
import java.util.InputMismatchException;

/**
 * Represents the status of an emergency task.
 */
enum TaskStatus {
    PENDING,
    DISPATCHED
}

/**
 * Represents an emergency call or task.
 */
class Task {
    private int id;
    private String description;
    private TaskStatus status;

    /**
     * Constructs a new Task.
     *
     * @param id The unique ID for the task.
     * @param description The description of the emergency.
     */
    public Task(int id, String description) {
        if (description == null || description.trim().isEmpty()) {
            throw new IllegalArgumentException("Task description cannot be empty.");
        }
        this.id = id;
        this.description = description.trim();
        this.status = TaskStatus.PENDING;
    }

    // Getters
    public int getId() {
        return id;
    }

    public String getDescription() {
        return description;
    }

    public TaskStatus getStatus() {
        return status;
    }

    /**
     * Sets the status of the task.
     *
     * @param status The new status.
     */
    public void setStatus(TaskStatus status) {
        if (status == null) {
             throw new IllegalArgumentException("Task status cannot be null.");
        }
        this.status = status;
    }

    @Override
    public String toString() {
        return "Task{id=" + id + ", description='" + description + "', status=" + status + "}";
    }
}

/**
 * Manages the emergency response dispatch system.
 * Handles incoming calls, responders, and dispatching.
 */
public class EmergencyDispatchSystem {

    private Queue<Task> pendingTasks;
    private List<String> availableResponders; // Simple list of responder names
    private List<Task> dispatchedTasks;
    private int nextTaskId;

    /**
     * Constructs a new EmergencyDispatchSystem.
     * Initializes data structures and task ID counter.
     */
    public EmergencyDispatchSystem() {
        this.pendingTasks = new LinkedList<>(); // LinkedList implements Queue
        this.availableResponders = new ArrayList<>(); // ArrayList implements List
        this.dispatchedTasks = new ArrayList<>(); // ArrayList implements List
        this.nextTaskId = 1;
    }

    /**
     * Adds a new emergency call to the pending tasks queue.
     *
     * @param description The description of the emergency.
     */
    public void addTask(String description) {
        try {
            Task newTask = new Task(nextTaskId++, description);
            pendingTasks.offer(newTask); // offer is preferred over add for queues
            System.out.println("New task added: " + newTask);
        } catch (IllegalArgumentException e) {
            System.err.println("Error adding task: " + e.getMessage());
        }
    }

    /**
     * Adds a new responder to the list of available responders.
     *
     * @param name The name of the responder.
     */
    public void addResponder(String name) {
        if (name == null || name.trim().isEmpty()) {
            System.err.println("Error adding responder: Responder name cannot be empty.");
            return;
        }
        availableResponders.add(name.trim());
        System.out.println("New responder added: " + name.trim());
    }

    /**
     * Dispatches the next pending task to an available responder.
     */
    public void dispatchNextTask() {
        System.out.println("Dispatching task...");

        if (pendingTasks.isEmpty()) {
            System.err.println("Error: No pending tasks to dispatch.");
            return;
        }

        if (availableResponders.isEmpty()) {
            System.err.println("Error: No available responders to dispatch tasks.");
            return;
        }

        // Get the next task from the queue
        Task taskToDispatch = pendingTasks.poll(); // poll retrieves and removes the head

        // Get the first available responder (simple model)
        String responderName = availableResponders.get(0);

        // Update task status and move to dispatched list
        taskToDispatch.setStatus(TaskStatus.DISPATCHED);
        dispatchedTasks.add(taskToDispatch);

        System.out.println("Task " + taskToDispatch.getId() + " ('" + taskToDispatch.getDescription() + "') dispatched to " + responderName + ".");
    }

    /**
     * Displays all pending tasks.
     */
    public void viewPendingTasks() {
        System.out.println("--- Pending Tasks ---");
        if (pendingTasks.isEmpty()) {
            System.out.println("No pending tasks.");
        } else {
            // Iterate through the queue without removing elements
            pendingTasks.forEach(System.out::println);
        }
    }

    /**
     * Displays all dispatched tasks.
     */
    public void viewDispatchedTasks() {
        System.out.println("--- Dispatched Tasks ---");
        if (dispatchedTasks.isEmpty()) {
            System.out.println("No dispatched tasks.");
        } else {
            dispatchedTasks.forEach(System.out::println);
        }
    }

    /**
     * Displays all available responders.
     */
    public void viewAvailableResponders() {
        System.out.println("--- Available Responders ---");
        if (availableResponders.isEmpty()) {
            System.out.println("No responders added yet.");
        } else {
            availableResponders.forEach(System.out::println);
        }
    }

    /**
     * Main method to run the Emergency Dispatch System.
     * Handles user interaction and menu processing.
     */
    public static void main(String[] args) {
        EmergencyDispatchSystem system = new EmergencyDispatchSystem();
        Scanner scanner = new Scanner(System.in);

        // Add some initial responders for demonstration
        system.addResponder("Alpha Team");
        system.addResponder("Bravo Unit");
        system.addResponder("Charlie Squad");

        int choice = -1;

        // Class-wide exception handling around the main operational loop
        try {
            while (choice != 7) {
                printMenu();
                System.out.print("Enter your choice: ");

                try {
                    choice = scanner.nextInt();
                    scanner.nextLine(); // Consume newline left-over

                    switch (choice) {
                        case 1:
                            System.out.print("Enter emergency description: ");
                            String description = scanner.nextLine();
                            system.addTask(description);
                            break;
                        case 2:
                            System.out.print("Enter responder name: ");
                            String name = scanner.nextLine();
                            system.addResponder(name);
                            break;
                        case 3:
                            system.dispatchNextTask();
                            break;
                        case 4:
                            system.viewPendingTasks();
                            break;
                        case 5:
                            system.viewDispatchedTasks();
                            break;
                        case 6:
                            system.viewAvailableResponders();
                            break;
                        case 7:
                            System.out.println("Exiting system.");
                            break;
                        default:
                            System.err.println("Invalid choice. Please enter a number between 1 and 7.");
                    }
                } catch (InputMismatchException e) {
                    System.err.println("Invalid input. Please enter a number.");
                    scanner.nextLine(); // Consume the invalid input to prevent infinite loop
                    choice = -1; // Reset choice to continue loop
                }
                System.out.println(); // Add a newline for better readability
            }
        } catch (Exception e) {
            // Catch any other unexpected exceptions during the main loop execution
            System.err.println("An unexpected system error occurred: " + e.getMessage());
            // e.printStackTrace(); // Uncomment for debugging stack trace
        } finally {
            // Ensure the scanner is closed
            if (scanner != null) {
                scanner.close();
            }
        }
    }

    /**
     * Prints the main menu options to the console.
     */
    private static void printMenu() {
        System.out.println("--- Emergency Dispatch System Menu ---");
        System.out.println("1. Add New Emergency Call");
        System.out.println("2. Add New Responder");
        System.out.println("3. Dispatch Next Pending Call");
        System.out.println("4. View Pending Calls");
        System.out.println("5. View Dispatched Calls");
        System.out.println("6. View Available Responders");
        System.out.println("7. Exit");
    }
}
