/*
 * Exam Question #375
 * Generated on: 2025-05-11 23:02:05
 * Generated by: Account 4
 * 
 * QUESTION:
 * **Advanced Java Programming Exam Task: Simulated Production Line Task Management System**
 * 
 * You are tasked with developing a simplified simulation of a production line's task management system. The system should manage a queue of pending tasks, process them one by one, and keep track of completed and failed tasks.
 * 
 * Your solution must demonstrate proficiency in core Java concepts, including data structures, object-oriented programming, user interaction, error handling, and flow control.
 * 
 * **Requirements:**
 * 
 * 1.  **Task Representation:** Create a class named `Task` to represent a single task. Each task should have:
 *     *   A unique integer `id`.
 *     *   A String `description`.
 *     *   An enum `Status` (PENDING, PROCESSING, COMPLETED, FAILED).
 *     *   Appropriate private fields and public getter methods.
 *     *   A constructor to initialize `id` and `description` (status should initially be PENDING).
 *     *   A method to update the task's status.
 * 
 * 2.  **Task Manager System:** Create a class named `TaskManager` that will manage the tasks. This class must contain:
 *     *   A `Queue<Task>` to hold tasks that are waiting to be processed.
 *     *   A `List<Task>` to hold tasks that have been successfully completed.
 *     *   A `List<Task>` to hold tasks that have failed processing.
 *     *   A mechanism to generate unique task IDs (e.g., a simple counter).
 *     *   Methods for:
 *         *   `addTask(String description)`: Creates a new `Task` with a unique ID, adds it to the pending queue, and prints a confirmation message to `System.out`.
 *         *   `processNextTask()`: Takes the next task from the queue. Simulates processing (see requirement 3). Updates the task's status based on the simulation result and moves it to the appropriate completed or failed list. Prints status updates (`System.out` for success, `System.err` for failure). Handles the case where the queue is empty.
 *         *   `viewStatus()`: Prints the current state of the pending queue, completed list, and failed list to `System.out`.
 * 
 * 3.  **Simulated Processing & Error Handling:**
 *     *   The `processNextTask()` method should simulate task processing. For simplicity, assume processing has a 30% chance of failure.
 *     *   If processing fails, update the task's status to `FAILED` and print an error message to `System.err`.
 *     *   If processing succeeds, update the task's status to `COMPLETED` and print a success message to `System.out`.
 *     *   Use a `try-catch` block within `processNextTask()` to handle potential exceptions during simulated processing (e.g., you could throw a custom `TaskProcessingException` or simply use a conditional check based on a random number). The `try-catch` block must be explicitly used for handling the processing outcome.
 * 
 * 4.  **User Interface:**
 *     *   Implement a `main` method in a separate class (e.g., `ProductionLineApp`) that interacts with the user via the console using `Scanner`.
 *     *   Present a menu of options to the user:
 *         *   1. Add New Task
 *         *   2. Process Next Task
 *         *   3. View All Tasks Status
 *         *   4. Exit
 *     *   Use a `switch` statement to handle the user's choice.
 *     *   Implement a loop to keep the menu running until the user chooses to exit.
 *     *   Include robust input validation for the menu choice: if the user enters non-integer input or an invalid option number, print an error message to `System.err` and prompt again. Use a `try-catch` block around the input reading/processing loop to handle potential `InputMismatchException` or other input-related errors.
 *     *   Ensure all required Java components (`Queue`, `ArrayList`, `List`, `Scanner`, `Switch`, `System.err`, `System.out`, `try-catch`) are used correctly and demonstrably.
 * 
 * 5.  **Best Practices:**
 *     *   Use meaningful variable and method names.
 *     *   Apply proper encapsulation (private fields, public methods).
 *     *   Include comments where necessary to explain complex logic.
 *     *   Structure the code logically into classes.
 * 
 * **Expected Output:**
 * 
 * The program should provide a clear menu, prompt for input, and display appropriate messages for task addition, processing results (success/failure), and task status views. Error messages for invalid input or processing failures should go to `System.err`.
 * 
 * Example Interaction Flow:
 * 
 * ```
 * --- Production Line Task Manager ---
 * Choose an option:
 * 1. Add New Task
 * 2. Process Next Task
 * 3. View All Tasks Status
 * 4. Exit
 * Enter choice: 1
 * Enter task description: Build component A
 * Task 1: 'Build component A' added to the queue.
 * 
 * --- Production Line Task Manager ---
 * Choose an option:
 * 1. Add New Task
 * 2. Process Next Task
 * 3. View All Tasks Status
 * 4. Exit
 * Enter choice: 1
 * Enter task description: Test assembly
 * Task 2: 'Test assembly' added to the queue.
 * 
 * --- Production Line Task Manager ---
 * Choose an option:
 * 1. Add New Task
 * 2. Process Next Task
 * 3. View All Tasks Status
 * 4. Exit
 * Enter choice: 3
 * --- Task Status ---
 * Pending:
 * Task 1: 'Build component A' [PENDING]
 * Task 2: 'Test assembly' [PENDING]
 * Completed:
 * Failed:
 * 
 * --- Production Line Task Manager ---
 * Choose an option:
 * 1. Add New Task
 * 2. Process Next Task
 * 3. View All Tasks Status
 * 4. Exit
 * Enter choice: 2
 * Processing task 1: 'Build component A'...
 * Task 1: 'Build component A' completed successfully.
 * 
 * --- Production Line Task Manager ---
 * Choose an option:
 * 1. Add New Task
 * 2. Process Next Task
 * 3. View All Tasks Status
 * 4. Exit
 * Enter choice: 2
 * Processing task 2: 'Test assembly'...
 * Error processing task 2: 'Test assembly'. Reason: Simulated failure.
 * 
 * --- Production Line Task Manager ---
 * Choose an option:
 * 1. Add New Task
 * 2. Process Next Task
 * 3. View All Tasks Status
 * 4. Exit
 * Enter choice: 3
 * --- Task Status ---
 * Pending:
 * Completed:
 * Task 1: 'Build component A' [COMPLETED]
 * Failed:
 * Task 2: 'Test assembly' [FAILED]
 * 
 * --- Production Line Task Manager ---
 * Choose an option:
 * 1. Add New Task
 * 2. Process Next Task
 * 3. View All Tasks Status
 * 4. Exit
 * Enter choice: 5
 * System.err: Invalid choice. Please enter a number between 1 and 4.
 * 
 * --- Production Line Task Manager ---
 * Choose an option:
 * 1. Add New Task
 * 2. Process Next Task
 * 3. View All Tasks Status
 * 4. Exit
 * Enter choice: quit
 * System.err: Invalid input. Please enter a number.
 * 
 * --- Production Line Task Manager ---
 * Choose an option:
 * 1. Add New Task
 * 2. Process Next Task
 * 3. View All Tasks Status
 * 4. Exit
 * Enter choice: 4
 * Exiting Task Manager.
 * ```
 * 
 * **Assessment Criteria:**
 * 
 * *   Correct usage of `Queue`, `ArrayList`, and `List`.
 * *   Proper implementation of object-oriented principles (classes, encapsulation, enums).
 * *   Effective use of `Scanner` for user input.
 * *   Correct implementation of the `switch` statement for menu handling.
 * *   Appropriate use of `System.out` and `System.err`.
 * *   Robust error handling using `try-catch` for both input validation and simulated processing errors.
 * *   Adherence to best practices (naming, comments, code structure).
 * *   Logical flow and correct implementation of the task management logic.
 *
 * EXPLANATION:
 * This solution implements a basic Task Management System simulating a production line using the required Java components and best practices.
 * 
 * 1.  **Task Class:**
 *     *   The `Task` class is a simple POJO (Plain Old Java Object) representing a task.
 *     *   It uses `private final` fields for `id` and `description` to ensure immutability after creation (except for status).
 *     *   `TaskStatus` is an `enum` providing a clear set of possible states for a task.
 *     *   Public getter methods (`getId`, `getDescription`, `getStatus`) provide controlled access to the task's data, demonstrating encapsulation.
 *     *   A `setStatus` method allows controlled modification of the status.
 *     *   `toString()` is overridden for easy printing of task information.
 * 
 * 2.  **TaskManager Class:**
 *     *   This class orchestrates the task flow.
 *     *   `pendingTasks`: A `Queue<Task>` is used (`LinkedList` implementation) because tasks are processed in the order they are added (First-In, First-Out - FIFO), which is the natural behavior for a production line queue. `offer()` is used for adding and `poll()` for removing, which are standard queue operations.
 *     *   `completedTasks` and `failedTasks`: `List<Task>` interfaces are used (`ArrayList` implementation) to store tasks after processing. Lists are suitable here as the order of completed/failed tasks isn't critical for processing, but we need to store them and iterate over them easily. Using the `List` interface promotes flexibility.
 *     *   `nextTaskId`: A simple integer counter ensures unique IDs for each new task.
 *     *   `addTask`: Creates a `Task` object and adds it to the `pendingTasks` queue. Includes basic validation for the description.
 *     *   `processNextTask`:
 *         *   Uses `pendingTasks.poll()` to get and remove the next task from the queue.
 *         *   Checks if the queue was empty.
 *         *   Uses a `try-catch` block to wrap the simulated processing logic.
 *         *   Inside the `try` block, a `Random` object simulates a 30% chance of failure by potentially throwing a custom `TaskProcessingException`.
 *         *   If no exception is thrown (success), the task status is set to `COMPLETED`, and it's added to the `completedTasks` list.
 *         *   If `TaskProcessingException` is caught (simulated failure), the task status is set to `FAILED`, and it's added to the `failedTasks` list.
 *         *   A general `catch(Exception e)` is included as a safety net for any other unexpected issues during processing simulation.
 *         *   `System.out` is used for success messages, and `System.err` is used for failure messages.
 *     *   `viewStatus`: Iterates through all three collections (`pendingTasks`, `completedTasks`, `failedTasks`) and prints the status of each task using their `toString()` method. It checks if lists/queue are empty before printing.
 * 
 * 3.  **ProductionLineApp Class (`main` method):**
 *     *   This class provides the command-line interface.
 *     *   A `Scanner` is used to read input from `System.in`.
 *     *   A `while` loop keeps the application running until the user chooses to exit.
 *     *   A `try-catch` block is used around the main loop's input reading (`scanner.nextInt()`) and `switch` statement. This is crucial for handling `InputMismatchException` if the user enters non-integer input for the menu choice, preventing the program from crashing and allowing it to prompt again. It also catches other potential exceptions in the main loop.
 *     *   A `switch` statement is used to direct the program flow based on the user's valid integer choice, calling the appropriate `TaskManager` methods.
 *     *   `scanner.nextLine()` is called after `scanner.nextInt()` to consume the leftover newline character, preventing issues with subsequent `nextLine()` calls when reading the task description.
 *     *   `System.out` is used for the menu and general messages. `System.err` is used for invalid input messages.
 *     *   The `scanner` is closed when the loop terminates.
 * 
 * This solution effectively integrates the required Java components (`Queue`, `ArrayList`, `List`, `Scanner`, `Switch`, `System.err`, `System.out`, `try-catch`) into a cohesive, object-oriented application that simulates a real-world scenario while demonstrating important programming concepts like data structures, encapsulation, input handling, and exception management.
 */

import java.util.Queue;
import java.util.LinkedList;
import java.util.List;
import java.util.ArrayList;
import java.util.Scanner;
import java.util.InputMismatchException;
import java.util.Random;

// Enum for Task Status
enum TaskStatus {
    PENDING,
    PROCESSING, // Not strictly used in this simulation, but good practice
    COMPLETED,
    FAILED
}

// Represents a single task in the system
class Task {
    private final int id;
    private final String description;
    private TaskStatus status;

    /**
     * Constructs a new Task.
     * @param id The unique ID of the task.
     * @param description A brief description of the task.
     */
    public Task(int id, String description) {
        this.id = id;
        this.description = description;
        this.status = TaskStatus.PENDING; // Tasks start as PENDING
    }

    // --- Getters ---
    public int getId() {
        return id;
    }

    public String getDescription() {
        return description;
    }

    public TaskStatus getStatus() {
        return status;
    }

    /**
     * Updates the status of the task.
     * @param status The new status for the task.
     */
    public void setStatus(TaskStatus status) {
        this.status = status;
    }

    @Override
    public String toString() {
        return "Task " + id + ": '" + description + "' [" + status + "]";
    }
}

// Manages the collection and processing of tasks
class TaskManager {
    // Use LinkedList as a concrete implementation of Queue
    private final Queue<Task> pendingTasks;
    // Use ArrayList as a concrete implementation of List
    private final List<Task> completedTasks;
    private final List<Task> failedTasks;
    private int nextTaskId; // Counter for unique task IDs
    private final Random random; // For simulating processing success/failure

    // Custom exception for simulated task processing failure
    private static class TaskProcessingException extends Exception {
        public TaskProcessingException(String message) {
            super(message);
        }
    }

    /**
     * Constructs a new TaskManager.
     */
    public TaskManager() {
        this.pendingTasks = new LinkedList<>(); // Queue for pending tasks
        this.completedTasks = new ArrayList<>(); // List for completed tasks
        this.failedTasks = new ArrayList<>();   // List for failed tasks
        this.nextTaskId = 1; // Start task IDs from 1
        this.random = new Random(); // Initialize randomizer
    }

    /**
     * Adds a new task to the pending queue.
     * @param description The description of the task.
     */
    public void addTask(String description) {
        if (description == null || description.trim().isEmpty()) {
            System.err.println("Task description cannot be empty.");
            return;
        }
        Task newTask = new Task(nextTaskId++, description.trim());
        pendingTasks.offer(newTask); // offer() is preferred over add() for capacity-constrained queues
        System.out.println("Task " + newTask.getId() + ": '" + newTask.getDescription() + "' added to the queue.");
    }

    /**
     * Processes the next task from the pending queue.
     * Simulates success (70%) or failure (30%).
     */
    public void processNextTask() {
        Task taskToProcess = pendingTasks.poll(); // Retrieves and removes the head of the queue
        if (taskToProcess == null) {
            System.out.println("No tasks in the pending queue to process.");
            return;
        }

        System.out.println("Processing task " + taskToProcess.getId() + ": '" + taskToProcess.getDescription() + "'...");

        // Simulate processing outcome
        try {
            taskToProcess.setStatus(TaskStatus.PROCESSING); // Optional: Indicate processing state briefly
            // Simulate a chance of failure (e.g., 30% failure rate)
            if (random.nextDouble() < 0.3) {
                throw new TaskProcessingException("Simulated failure.");
            }

            // If simulation didn't throw an exception, it's a success
            taskToProcess.setStatus(TaskStatus.COMPLETED);
            completedTasks.add(taskToProcess); // Add to completed list
            System.out.println("Task " + taskToProcess.getId() + ": '" + taskToProcess.getDescription() + "' completed successfully.");

        } catch (TaskProcessingException e) {
            // Handle simulated failure
            taskToProcess.setStatus(TaskStatus.FAILED);
            failedTasks.add(taskToProcess); // Add to failed list
            System.err.println("Error processing task " + taskToProcess.getId() + ": '" + taskToProcess.getDescription() + "'. Reason: " + e.getMessage());
        } catch (Exception e) {
            // Catch any other unexpected exceptions during processing
             taskToProcess.setStatus(TaskStatus.FAILED);
             failedTasks.add(taskToProcess);
             System.err.println("An unexpected error occurred processing task " + taskToProcess.getId() + ": " + e.getMessage());
             // Optionally log the full stack trace for debugging
             // e.printStackTrace(System.err);
        }
    }

    /**
     * Prints the status of all tasks (pending, completed, failed).
     */
    public void viewStatus() {
        System.out.println("--- Task Status ---");

        System.out.println("Pending:");
        if (pendingTasks.isEmpty()) {
            System.out.println("  (None)");
        } else {
            // Iterate over the queue without removing elements
            pendingTasks.forEach(task -> System.out.println("  " + task));
        }

        System.out.println("Completed:");
        if (completedTasks.isEmpty()) {
            System.out.println("  (None)");
        } else {
            // Iterate over the list
            completedTasks.forEach(task -> System.out.println("  " + task));
        }

        System.out.println("Failed:");
        if (failedTasks.isEmpty()) {
            System.out.println("  (None)");
        } else {
            // Iterate over the list
            failedTasks.forEach(task -> System.out.println("  " + task));
        }
        System.out.println("-------------------");
    }
}

// Main application class for user interaction
public class ProductionLineApp {

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        TaskManager taskManager = new TaskManager();
        boolean running = true;

        while (running) {
            printMenu();
            int choice = -1; // Default invalid choice

            try {
                System.out.print("Enter choice: ");
                choice = scanner.nextInt(); // Read integer choice
                scanner.nextLine(); // Consume the newline character left by nextInt()

                // Use a switch statement to handle the user's choice
                switch (choice) {
                    case 1: // Add New Task
                        System.out.print("Enter task description: ");
                        String description = scanner.nextLine();
                        taskManager.addTask(description);
                        break;
                    case 2: // Process Next Task
                        taskManager.processNextTask();
                        break;
                    case 3: // View All Tasks Status
                        taskManager.viewStatus();
                        break;
                    case 4: // Exit
                        running = false;
                        System.out.println("Exiting Task Manager.");
                        break;
                    default: // Invalid choice
                        System.err.println("Invalid choice. Please enter a number between 1 and 4.");
                        break;
                }
            } catch (InputMismatchException e) {
                // Handle non-integer input
                System.err.println("Invalid input. Please enter a number.");
                scanner.nextLine(); // Consume the invalid input to prevent infinite loop
            } catch (Exception e) {
                // Catch any other unexpected exceptions during the main loop
                System.err.println("An unexpected error occurred: " + e.getMessage());
                // e.printStackTrace(System.err); // Uncomment for debugging
            }
            System.out.println(); // Add a blank line for better readability between cycles
        }

        scanner.close(); // Close the scanner when done
    }

    /**
     * Prints the main menu options to the console.
     */
    private static void printMenu() {
        System.out.println("--- Production Line Task Manager ---");
        System.out.println("Choose an option:");
        System.out.println("1. Add New Task");
        System.out.println("2. Process Next Task");
        System.out.println("3. View All Tasks Status");
        System.out.println("4. Exit");
    }
}
