/*
 * Exam Question #92
 * Generated on: 2025-05-11 22:12:56
 * Generated by: Account 5
 * 
 * QUESTION:
 * ## Advanced Java Programming Exam: Build Queue Management System
 * 
 * **Scenario:**
 * 
 * You are tasked with developing a simplified Build Queue Management System for a software development team. This system will manage build requests, prioritizing critical releases while handling regular feature and bugfix builds in a standard queue.
 * 
 * **System Requirements:**
 * 
 * 1.  **Build Request Representation:** Create a class `BuildRequest` to represent a single build task. It should store:
 *     *   A unique identifier (String).
 *     *   The build type (String - e.g., "Release", "Feature", "Bugfix").
 *     *   A description (String).
 *     *   Proper encapsulation (private fields, public getters).
 *     *   A meaningful `toString()` method for easy display.
 * 
 * 2.  **Build Management Logic:** Create a class `BuildManager` that handles the core logic. It must maintain two collections:
 *     *   A **priority queue** for "Release" build requests. This queue should process requests in the order they are added (FIFO).
 *     *   A **regular list** for "Feature" and "Bugfix" build requests. This list should allow adding requests and processing specific requests by their index.
 *     *   Use `java.util.Queue` for the priority queue (a `LinkedList` is a suitable implementation).
 *     *   Use `java.util.List` for the regular list, implemented by `java.util.ArrayList`.
 *     *   Provide methods for:
 *         *   `addRequest(BuildRequest request)`: Adds a request to the appropriate collection based on its type.
 *         *   `processNextBuild()`: Processes and removes the next available build. It *must* prioritize the priority queue. If the priority queue is empty, it processes the *first* build from the regular list. Returns the processed `BuildRequest` or `null` if no builds are pending.
 *         *   `listPendingBuilds()`: Displays all pending builds, listing priority builds first, followed by regular builds with their index.
 *         *   `processRegularBuildByIndex(int index)`: Processes and removes a specific build from the regular list based on its 0-based index. Returns the processed `BuildRequest` or throws an `IndexOutOfBoundsException` if the index is invalid.
 * 
 * 3.  **User Interface:** Create a main class (e.g., `BuildSystemApp`) with a `main` method to interact with the `BuildManager`. It should:
 *     *   Use `java.util.Scanner` to get user input from the console.
 *     *   Present a menu of options to the user:
 *         1.  Add New Build Request
 *         2.  Process Next Build (Priority First)
 *         3.  Process Regular Build by Index
 *         4.  List All Pending Builds
 *         5.  Exit
 *     *   Use a `switch` statement to handle user command selection.
 *     *   Use `System.out` for menu display, prompts, confirmation messages, and listing builds.
 *     *   Use `System.err` for displaying error messages.
 *     *   Implement robust exception handling using a single `try-catch(Exception e)` block that wraps the main loop's core logic to catch and report *any* unexpected errors during command execution (e.g., invalid input format, index out of bounds).
 * 
 * **Implementation Requirements:**
 * 
 * *   You *must* use `java.util.Queue`, `java.util.ArrayList`, `java.util.List`, `java.util.Scanner`, a `switch` statement, `System.err`, `System.out`, and class-wide `try-catch` blocks as specified.
 * *   Adhere to Java best practices:
 *     *   Proper encapsulation.
 *     *   Meaningful variable and method names.
 *     *   Appropriate comments and documentation (brief Javadoc is sufficient).
 *     *   Basic input validation (e.g., ensuring index is valid before processing).
 * *   The application should loop, allowing multiple commands until the user chooses to exit.
 * 
 * **Expected Output:**
 * 
 * The output should guide the user with a clear menu, prompt for necessary input, and provide informative messages for successful operations, list contents, or errors.
 * 
 * *   Menu display.
 * *   Prompts for build details when adding.
 * *   Confirmation messages after adding or processing.
 * *   Clear listing of pending builds (priority first, then indexed regular builds).
 * *   Error messages printed to `System.err` for invalid commands, invalid index, or other exceptions.
 * 
 * **Example Interaction Flow:**
 * 
 * ```
 * --- Build Queue System ---
 * 1. Add New Build Request
 * 2. Process Next Build (Priority First)
 * 3. Process Regular Build by Index
 * 4. List All Pending Builds
 * 5. Exit
 * Enter command: 1
 * Enter Build ID: build-1
 * Enter Build Type (Release, Feature, Bugfix): Feature
 * Enter Description: Implement user login
 * Build Request added: [Feature] build-1: Implement user login
 * 
 * --- Build Queue System ---
 * ...
 * Enter command: 1
 * Enter Build ID: build-2
 * Enter Build Type (Release, Feature, Bugfix): Release
 * Enter Description: Prepare for production deployment
 * Build Request added: [Release] build-2: Prepare for production deployment
 * 
 * --- Build Queue System ---
 * ...
 * Enter command: 4
 * Pending Builds:
 * Priority Queue:
 *   [Release] build-2: Prepare for production deployment
 * Regular List:
 *   0: [Feature] build-1: Implement user login
 * 
 * --- Build Queue System ---
 * ...
 * Enter command: 2
 * Processing next build: [Release] build-2: Prepare for production deployment
 * 
 * --- Build Queue System ---
 * ...
 * Enter command: 4
 * Pending Builds:
 * Priority Queue:
 *   (Empty)
 * Regular List:
 *   0: [Feature] build-1: Implement user login
 * 
 * --- Build Queue System ---
 * ...
 * Enter command: 3
 * Enter index of regular build to process: 0
 * Processing regular build at index 0: [Feature] build-1: Implement user login
 * 
 * --- Build Queue System ---
 * ...
 * Enter command: 4
 * Pending Builds:
 * Priority Queue:
 *   (Empty)
 * Regular List:
 *   (Empty)
 * 
 * --- Build Queue System ---
 * ...
 * Enter command: 2
 * No builds to process.
 * 
 * --- Build Queue System ---
 * ...
 * Enter command: 6
 * Error: Invalid command. Please enter a number between 1 and 5.
 * 
 * --- Build Queue System ---
 * ...
 * Enter command: 3
 * Enter index of regular build to process: 5
 * Error processing command: java.lang.IndexOutOfBoundsException: Index: 5, Size: 0
 * ```
 *
 * EXPLANATION:
 * The provided solution implements the Build Queue Management System as described in the exam question, demonstrating the required advanced Java concepts and best practices.
 * 
 * **Class Structure:**
 * 
 * 1.  **`BuildRequest`:** A simple Plain Old Java Object (POJO) class representing a build task. It uses `private` fields (`id`, `type`, `description`) and `public` getters (`getId`, `getType`, `getDescription`) to enforce **encapsulation**. The `toString()` method provides a convenient formatted output for build details.
 * 
 * 2.  **`BuildManager`:** This class encapsulates the core logic for managing build requests.
 *     *   It uses a `java.util.Queue<BuildRequest>` named `priorityQueue`, instantiated as a `LinkedList`, to store "Release" builds. The `Queue` interface ensures FIFO processing, and `offer()`/`poll()` methods are used for adding and removing elements.
 *     *   It uses a `java.util.List<BuildRequest>` named `regularList`, instantiated as an `ArrayList`, to store "Feature" and "Bugfix" builds. The `List` interface provides index-based access and modification, which `ArrayList` efficiently supports.
 *     *   The `addRequest()` method demonstrates conditional logic based on build type to add to the appropriate collection.
 *     *   `processNextBuild()` showcases the priority logic: it first checks and processes the `priorityQueue` using `poll()`. Only if the priority queue is empty does it process the first element of the `regularList` using `remove(0)`.
 *     *   `processRegularBuildByIndex(int index)` directly uses the `remove(index)` method of the `ArrayList`. This method automatically throws an `IndexOutOfBoundsException` if the index is invalid, fulfilling the requirement to handle this specific error. An explicit check is included for clarity and potentially a custom error message, but the `ArrayList`'s behavior is key here.
 *     *   `listPendingBuilds()` iterates through both collections (using a standard for-each loop for the `Queue` and an indexed for loop for the `List`) to display their contents separately.
 * 
 * 3.  **`BuildSystemApp`:** This is the main application class containing the `main` method.
 *     *   It uses `java.util.Scanner` to read user input from the console.
 *     *   A `while(true)` loop keeps the application running until the exit command is given.
 *     *   A **`switch` statement** is used to direct the program flow based on the user's command input. This provides a clear and structured way to handle multiple distinct actions.
 *     *   **`System.out`** is used for all standard output: displaying the menu, prompting for input, confirming actions, and listing builds.
 *     *   **`System.err`** is specifically used for displaying error messages, as required. This separates error output from normal program output.
 *     *   **Class-wide exception handling** is implemented with a single `try-catch(Exception e)` block wrapping the core logic inside the `while` loop. This block catches *any* `Exception` that might occur during command processing (e.g., `NumberFormatException` if the user enters non-numeric input for the command, `IndexOutOfBoundsException` if `processRegularBuildByIndex` throws it and it's not caught more specifically, or any other unexpected runtime error). The `catch` block prints an error message to `System.err`, demonstrating robust error reporting. Specific `catch` blocks are also included within `processRegularBuildByIndex` and the main loop's `try` block for `NumberFormatException` and `IndexOutOfBoundsException` respectively, allowing for more specific error messages for common issues before falling back to the general `Exception` catch.
 *     *   Helper methods (`printMenu`, `addNewBuildRequest`, `processNextBuild`, `processRegularBuildByIndex`) are used to break down the main loop's logic into smaller, more manageable units, improving code readability and maintainability.
 *     *   Basic input validation is performed in `addNewBuildRequest` to prevent adding builds with empty details.
 * 
 * **Key Concepts Demonstrated:**
 * 
 * *   **Data Structures:** Practical application of `Queue` (FIFO) and `List`/`ArrayList` (indexed access, dynamic size) for managing different types of data with distinct access patterns.
 * *   **Interfaces vs. Implementations:** Using `Queue` and `List` interfaces while instantiating concrete classes (`LinkedList`, `ArrayList`).
 * *   **Encapsulation:** Protecting data within classes using `private` fields and providing controlled access via `public` methods.
 * *   **Control Flow:** Effective use of `switch` for command dispatch and `while` for the application loop.
 * *   **User Input:** Reading console input using `Scanner`.
 * *   **Input/Output Streams:** Differentiating between normal output (`System.out`) and error output (`System.err`).
 * *   **Exception Handling:** Implementing `try-catch` blocks for anticipating and gracefully handling potential runtime errors, including specific exceptions (`NumberFormatException`, `IndexOutOfBoundsException`) and a general `Exception` catch for robustness.
 * *   **Modularity:** Breaking down the problem into smaller, well-defined classes and methods.
 * *   **Best Practices:** Meaningful names, comments, basic input validation.
 * 
 * This solution effectively integrates all required components within a practical scenario, demonstrating a solid understanding of fundamental and advanced Java programming concepts suitable for an exam setting.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;

/**
 * Represents a single build request in the system.
 */
class BuildRequest {
    private String id;
    private String type; // e.g., "Release", "Feature", "Bugfix"
    private String description;

    /**
     * Constructs a new BuildRequest.
     *
     * @param id The unique identifier for the build.
     * @param type The type of build (e.g., "Release", "Feature").
     * @param description A brief description of the build.
     */
    public BuildRequest(String id, String type, String description) {
        this.id = id;
        this.type = type;
        this.description = description;
    }

    // Getters
    public String getId() {
        return id;
    }

    public String getType() {
        return type;
    }

    public String getDescription() {
        return description;
    }

    /**
     * Provides a string representation of the build request.
     *
     * @return Formatted string for the build request.
     */
    @Override
    public String toString() {
        return "[" + type + "] " + id + ": " + description;
    }
}

/**
 * Manages the queues and lists of build requests.
 */
class BuildManager {
    // Use Queue for priority builds (FIFO)
    private Queue<BuildRequest> priorityQueue = new LinkedList<>();

    // Use List (implemented by ArrayList) for regular builds
    private List<BuildRequest> regularList = new ArrayList<>();

    /**
     * Adds a build request to the appropriate queue/list based on its type.
     * "Release" types go to the priority queue. Others go to the regular list.
     *
     * @param request The BuildRequest to add.
     */
    public void addRequest(BuildRequest request) {
        if ("Release".equalsIgnoreCase(request.getType())) {
            priorityQueue.offer(request); // offer is generally preferred for capacity-constrained queues, but add works too
        } else {
            regularList.add(request);
        }
    }

    /**
     * Processes and removes the next build request. Prioritizes the priority queue.
     * If priority queue is empty, processes the first item from the regular list.
     *
     * @return The processed BuildRequest, or null if no builds are pending.
     */
    public BuildRequest processNextBuild() {
        if (!priorityQueue.isEmpty()) {
            return priorityQueue.poll(); // Remove and return head of priority queue
        } else if (!regularList.isEmpty()) {
            return regularList.remove(0); // Remove and return first element from regular list
        } else {
            return null; // No builds available
        }
    }

    /**
     * Processes and removes a build request from the regular list by index.
     *
     * @param index The 0-based index of the regular build to process.
     * @return The processed BuildRequest.
     * @throws IndexOutOfBoundsException if the index is invalid.
     */
    public BuildRequest processRegularBuildByIndex(int index) throws IndexOutOfBoundsException {
        // List's remove(index) method throws IndexOutOfBoundsException if index is invalid,
        // so explicit check is not strictly necessary for the exception requirement,
        // but adding a check before might provide a clearer message or alternative handling.
        // For this exam, relying on List's exception is sufficient.
         if (index < 0 || index >= regularList.size()) {
             throw new IndexOutOfBoundsException("Index: " + index + ", Size: " + regularList.size());
         }
        return regularList.remove(index);
    }


    /**
     * Displays all pending build requests, listing priority builds first,
     * followed by regular builds with their index.
     */
    public void listPendingBuilds() {
        System.out.println("Pending Builds:");

        System.out.println("Priority Queue:");
        if (priorityQueue.isEmpty()) {
            System.out.println("  (Empty)");
        } else {
            // Iterate without removing
            for (BuildRequest request : priorityQueue) {
                System.out.println("  " + request);
            }
        }

        System.out.println("Regular List:");
        if (regularList.isEmpty()) {
            System.out.println("  (Empty)");
        } else {
            for (int i = 0; i < regularList.size(); i++) {
                System.out.println("  " + i + ": " + regularList.get(i));
            }
        }
    }

    /**
     * Gets the number of pending regular builds.
     * @return The size of the regular build list.
     */
    public int getRegularListSize() {
        return regularList.size();
    }
}

/**
 * Main application class for the Build Queue Management System.
 * Handles user interaction and manages the BuildManager.
 */
public class BuildSystemApp {

    private static Scanner scanner = new Scanner(System.in);
    private static BuildManager buildManager = new BuildManager();

    public static void main(String[] args) {
        System.out.println("--- Build Queue System ---");

        while (true) {
            printMenu();
            System.out.print("Enter command: ");
            String input = scanner.nextLine();

            // Wrap the core logic in a try-catch block for class-wide exception handling
            try {
                int command = Integer.parseInt(input);

                switch (command) {
                    case 1:
                        addNewBuildRequest();
                        break;
                    case 2:
                        processNextBuild();
                        break;
                    case 3:
                        processRegularBuildByIndex();
                        break;
                    case 4:
                        buildManager.listPendingBuilds();
                        break;
                    case 5:
                        System.out.println("Exiting Build Queue System. Goodbye!");
                        scanner.close(); // Close the scanner
                        return; // Exit the application
                    default:
                        System.err.println("Error: Invalid command. Please enter a number between 1 and 5.");
                }
            } catch (NumberFormatException e) {
                System.err.println("Error: Invalid input. Please enter a number for the command.");
            } catch (Exception e) {
                // Catch any other unexpected exceptions
                System.err.println("Error processing command: " + e.toString());
                // e.printStackTrace(System.err); // Uncomment for more detailed stack trace in errors
            }
            System.out.println(); // Add a newline for better readability between commands
        }
    }

    /**
     * Prints the main menu options to the console.
     */
    private static void printMenu() {
        System.out.println("--- Menu ---");
        System.out.println("1. Add New Build Request");
        System.out.println("2. Process Next Build (Priority First)");
        System.out.println("3. Process Regular Build by Index");
        System.out.println("4. List All Pending Builds");
        System.out.println("5. Exit");
        System.out.println("------------");
    }

    /**
     * Handles the process of adding a new build request based on user input.
     */
    private static void addNewBuildRequest() {
        System.out.print("Enter Build ID: ");
        String id = scanner.nextLine();
        System.out.print("Enter Build Type (Release, Feature, Bugfix): ");
        String type = scanner.nextLine();
        System.out.print("Enter Description: ");
        String description = scanner.nextLine();

        // Basic validation
        if (id.trim().isEmpty() || type.trim().isEmpty() || description.trim().isEmpty()) {
            System.err.println("Error: Build details cannot be empty.");
            return;
        }

        BuildRequest newRequest = new BuildRequest(id, type, description);
        buildManager.addRequest(newRequest);
        System.out.println("Build Request added: " + newRequest);
    }

    /**
     * Handles the process of processing the next build request.
     */
    private static void processNextBuild() {
        BuildRequest processedRequest = buildManager.processNextBuild();
        if (processedRequest != null) {
            System.out.println("Processing next build: " + processedRequest);
        } else {
            System.out.println("No builds to process.");
        }
    }

    /**
     * Handles the process of processing a regular build by its index based on user input.
     */
    private static void processRegularBuildByIndex() {
        System.out.print("Enter index of regular build to process: ");
        String indexInput = scanner.nextLine();
        try {
            int index = Integer.parseInt(indexInput);
            // The BuildManager method will throw IndexOutOfBoundsException if invalid
            BuildRequest processedRequest = buildManager.processRegularBuildByIndex(index);
            System.out.println("Processing regular build at index " + index + ": " + processedRequest);
        } catch (NumberFormatException e) {
            System.err.println("Error: Invalid index input. Please enter a number.");
        } catch (IndexOutOfBoundsException e) {
             System.err.println("Error: Invalid index. No regular build found at index " + indexInput + ". There are " + buildManager.getRegularListSize() + " regular builds.");
        }
         // Note: Any other unexpected exception here would be caught by the main try-catch in main().
    }
}
