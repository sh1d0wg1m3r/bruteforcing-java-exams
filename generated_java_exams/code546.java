/*
 * Exam Question #546
 * Generated on: 2025-05-11 23:27:34
 * Generated by: Account 3
 * 
 * QUESTION:
 * **Java Programming Exam Task: Manufacturing Assembly Line Simulation**
 * 
 * **Scenario:**
 * You are tasked with creating a simplified simulation of a manufacturing assembly line. The line processes "Products". Products enter a waiting queue, are processed one by one, and then moved to a list of completed products. The simulation should allow a user to interact with the assembly line via a command-line interface.
 * 
 * **Requirements:**
 * 
 * 1.  **Product Representation:** Create a class `Product` to represent an item being assembled. It should have a private field for the product's name (String). Include a public constructor and a public getter method for the name.
 * 2.  **Assembly Line Management:** Create a class `AssemblyLine` that manages the simulation. This class should contain:
 *     *   A private `Queue<Product>` named `assemblyQueue` to hold products waiting for processing.
 *     *   A private `List<Product>` named `completedProducts` to store products that have finished processing. Use `ArrayList` as the concrete implementation for this list.
 *     *   A private `Scanner` object to read user input.
 * 3.  **Core Functionality:** The `AssemblyLine` class must provide the following public methods:
 *     *   `addProduct(String productName)`: Adds a new `Product` with the given name to the `assemblyQueue`. Validate that `productName` is not null or empty. If invalid, print an error to `System.err`.
 *     *   `processNextProduct()`: Removes the next product from the `assemblyQueue`, simulates processing (simply move it to the `completedProducts` list), and prints a success message to `System.out`. If the `assemblyQueue` is empty, print an error message to `System.err`.
 *     *   `viewQueue()`: Prints the names of all products currently in the `assemblyQueue` to `System.out`, indicating their position. If the queue is empty, print an appropriate message.
 *     *   `viewCompleted()`: Prints the names of all products in the `completedProducts` list to `System.out`. If the list is empty, print an appropriate message.
 *     *   `runSimulation()`: This method should contain the main loop for the simulation. It should repeatedly:
 *         *   Display a menu of options to the user:
 *             1. Add Product
 *             2. Process Next Product
 *             3. View Waiting Queue
 *             4. View Completed Products
 *             5. Exit
 *         *   Read the user's choice using the `Scanner`.
 *         *   Use a `switch` statement to handle the user's choice, calling the appropriate method (`addProduct`, `processNextProduct`, `viewQueue`, `viewCompleted`) or exiting.
 *         *   Handle potential `InputMismatchException` if the user enters non-integer input for the menu choice using a `try-catch` block within the loop. Print an error message to `System.err` and clear the invalid input from the scanner.
 *         *   Handle the "Exit" option to terminate the loop.
 * 4.  **Main Method:** Include a `main` method in the `AssemblyLine` class (or a separate class) to create an `AssemblyLine` object and call its `runSimulation()` method.
 * 5.  **Error Handling:**
 *     *   Use `System.err` for all error messages (e.g., invalid input, trying to process an empty queue, invalid product name).
 *     *   Use `System.out` for all normal output (menu, success messages, list contents).
 *     *   Implement class-wide or method-level `try-catch` blocks as needed, particularly around user input processing.
 * 6.  **Best Practices:**
 *     *   Use meaningful variable and method names.
 *     *   Include appropriate comments and documentation (Javadoc is a plus).
 *     *   Ensure proper encapsulation (private fields, public methods).
 *     *   Use the `List` interface when declaring the `completedProducts` variable, even though the concrete implementation is `ArrayList`.
 * 
 * **Input Format:**
 * The user will enter integers corresponding to menu options. If option 1 is chosen, they will then enter the product name on the next line.
 * 
 * **Expected Output:**
 * *   Menu displayed clearly.
 * *   Normal operations (adding, processing, viewing) print messages to `System.out`.
 * *   Error conditions print messages to `System.err`.
 * *   Queue viewing should show products in order.
 * *   Completed viewing should show products in the order they were completed.
 * 
 * **Example Interaction (Illustrative):**
 * 
 * ```
 * Assembly Line Menu:
 * 1. Add Product
 * 2. Process Next Product
 * 3. View Waiting Queue
 * 4. View Completed Products
 * 5. Exit
 * Enter choice: 1
 * Enter product name: Widget A
 * Product 'Widget A' added to the queue.
 * 
 * Assembly Line Menu:
 * ...
 * Enter choice: 1
 * Enter product name: Gadget B
 * Product 'Gadget B' added to the queue.
 * 
 * Assembly Line Menu:
 * ...
 * Enter choice: 3
 * Waiting Queue:
 * 1. Widget A
 * 2. Gadget B
 * 
 * Assembly Line Menu:
 * ...
 * Enter choice: 2
 * Processing product: Widget A
 * 'Widget A' moved to completed products.
 * 
 * Assembly Line Menu:
 * ...
 * Enter choice: 3
 * Waiting Queue:
 * 1. Gadget B
 * 
 * Assembly Line Menu:
 * ...
 * Enter choice: 4
 * Completed Products:
 * 1. Widget A
 * 
 * Assembly Line Menu:
 * ...
 * Enter choice: 2
 * Processing product: Gadget B
 * 'Gadget B' moved to completed products.
 * 
 * Assembly Line Menu:
 * ...
 * Enter choice: 4
 * Completed Products:
 * 1. Widget A
 * 2. Gadget B
 * 
 * Assembly Line Menu:
 * ...
 * Enter choice: 2
 * System.err: Error: No products in the queue to process.
 * 
 * Assembly Line Menu:
 * ...
 * Enter choice: invalid_input
 * System.err: Invalid input. Please enter a number between 1 and 5.
 * 
 * Assembly Line Menu:
 * ...
 * Enter choice: 5
 * Exiting simulation.
 * ```
 * 
 * **Constraint Checklist & Confidence Score:**
 * 1.  Queue: Yes
 * 2.  ArrayList: Yes
 * 3.  List interface: Yes
 * 4.  Scanner: Yes
 * 5.  Switch statement: Yes
 * 6.  System.err: Yes
 * 7.  System.out: Yes
 * 8.  Try-catch: Yes
 * 9.  Creative/Practical: Yes (Assembly Line Simulation)
 * 10. Best Practices: Yes (Encapsulation, Naming, Comments, Validation, Error Handling, Structure)
 * 11. Challenging but solvable: Yes (Requires integrating multiple components)
 * 
 * Confidence Score: 5/5
 * 
 * **End of Exam Task.**
 *
 * EXPLANATION:
 * The provided solution implements the `AssemblyLine` simulation as described in the exam question, demonstrating the required Java concepts and best practices.
 * 
 * **Core Structure:**
 * The solution is organized into two classes:
 * 1.  `Product`: A simple class representing the item being processed. It follows encapsulation principles with a private `name` field and a public getter.
 * 2.  `AssemblyLine`: This is the main class that orchestrates the simulation logic. It holds the state (`assemblyQueue`, `completedProducts`) and the interaction logic (`runSimulation`, `addProduct`, etc.).
 * 
 * **Required Components Usage:**
 * 
 * 1.  **`Queue` (`java.util.Queue`)**: The `assemblyQueue` is declared as a `Queue<Product>`. This interface is implemented by `LinkedList`, which is instantiated to create the actual queue object (`this.assemblyQueue = new LinkedList<>();`). The `offer()` method is used to add products to the end of the queue, and `poll()` is used to remove products from the front (head) of the queue, simulating the first-in, first-out (FIFO) nature of an assembly line queue.
 * 2.  **`ArrayList` (`java.util.ArrayList`)**: The `completedProducts` list uses `ArrayList` as its concrete implementation (`this.completedProducts = new ArrayList<>();`). `ArrayList` is suitable here as completed products are simply added to the end, and viewing them involves iterating through the list, which are efficient operations for `ArrayList`.
 * 3.  **`List interface` (`java.util.List`)**: The `completedProducts` variable is declared using the `List<Product>` interface (`private List<Product> completedProducts;`). This is a best practice as it allows for flexibility; if the underlying implementation needed to change (e.g., to `LinkedList` or `Vector`), only the instantiation line would need modification, not the code that interacts with the list methods (like `add` or iteration).
 * 4.  **`Scanner` (`java.util.Scanner`)**: A `Scanner` object is used within the `AssemblyLine` class (`private Scanner scanner;`) to read input from `System.in`. It reads integers for menu choices (`scanner.nextInt()`) and strings for product names (`scanner.nextLine()`). Note the use of `scanner.nextLine()` after `scanner.nextInt()` to consume the leftover newline character, preventing input issues in the next loop iteration.
 * 5.  **`Switch statement`**: A `switch` statement is used in the `runSimulation()` method to handle the different menu options entered by the user. Each case corresponds to a menu number and calls the appropriate method (`addProduct`, `processNextProduct`, `viewQueue`, `viewCompleted`) or sets the exit condition.
 * 6.  **`System.err`**: `System.err.println()` is used specifically for printing error messages, such as when an invalid product name is entered, when trying to process an empty queue, or when the user enters invalid input for the menu choice. This differentiates error output from normal program output.
 * 7.  **`System.out`**: `System.out.println()` is used for all standard program output, including displaying the menu, confirmation messages for adding/processing products, and listing the contents of the waiting queue and completed products list.
 * 8.  **Class-wide `try-catch`**: A `try-catch` block is wrapped around the input reading and `switch` statement inside the `runSimulation` loop. This specifically catches `InputMismatchException` which occurs if the user enters non-integer input when an integer is expected by `scanner.nextInt()`. It prints an error to `System.err` and uses `scanner.nextLine()` to consume the invalid input from the buffer, preventing an infinite error loop. A general `catch (Exception e)` is also included as a fallback for any other unexpected runtime errors, printing the error details to `System.err`.
 * 
 * **Best Practices:**
 * 
 * *   **Encapsulation:** Fields (`assemblyQueue`, `completedProducts`, `scanner` in `AssemblyLine`, `name` in `Product`) are declared as `private`. Access and modification are controlled through public methods (`addProduct`, `processNextProduct`, getters).
 * *   **Meaningful Names:** Variables (`assemblyQueue`, `completedProducts`, `productName`, `choice`), classes (`Product`, `AssemblyLine`), and methods (`addProduct`, `processNextProduct`, `runSimulation`) have descriptive names indicating their purpose.
 * *   **Comments and Documentation:** Javadoc comments are included for classes and public methods explaining their role, parameters, and return values. Inline comments clarify specific code logic where necessary (e.g., explaining `scanner.nextLine()` after `nextInt()`).
 * *   **Input Validation:** The `addProduct` method explicitly checks if the `productName` is null or empty/whitespace before creating a `Product` object.
 * *   **Error Handling:** Specific error messages are provided for different failure conditions (empty queue, invalid input type, invalid product name). `System.err` is used correctly for errors. The `try-catch` around input handling makes the program more robust against user errors.
 * *   **Clean Code Structure:** The code is divided into logical methods, each responsible for a single task (adding, processing, viewing, running the loop). The `displayMenu` method is separated for clarity. The `main` method is minimal, simply creating the `AssemblyLine` object and starting the simulation.
 * 
 * This solution effectively integrates the required Java components within a practical simulation scenario, demonstrating understanding of data structures, control flow, input/output, and error handling according to best practices.
 */

import java.util.Queue;
import java.util.LinkedList;
import java.util.List;
import java.util.ArrayList;
import java.util.Scanner;
import java.util.InputMismatchException;

/**
 * Represents a product in the assembly line simulation.
 */
class Product {
    private String name;

    /**
     * Constructs a new Product.
     * @param name The name of the product.
     */
    public Product(String name) {
        this.name = name;
    }

    /**
     * Gets the name of the product.
     * @return The product name.
     */
    public String getName() {
        return name;
    }

    @Override
    public String toString() {
        return name;
    }
}

/**
 * Simulates a manufacturing assembly line processing products.
 */
public class AssemblyLine {

    private Queue<Product> assemblyQueue;
    private List<Product> completedProducts; // Declared as List interface
    private Scanner scanner;

    /**
     * Constructs a new AssemblyLine simulation manager.
     */
    public AssemblyLine() {
        // Use LinkedList as a Queue implementation
        this.assemblyQueue = new LinkedList<>();
        // Use ArrayList as the List implementation
        this.completedProducts = new ArrayList<>();
        this.scanner = new Scanner(System.in);
    }

    /**
     * Adds a new product to the assembly queue.
     * Validates the product name.
     * @param productName The name of the product to add.
     */
    public void addProduct(String productName) {
        if (productName == null || productName.trim().isEmpty()) {
            System.err.println("Error: Product name cannot be empty.");
            return;
        }
        Product newProduct = new Product(productName.trim());
        assemblyQueue.offer(newProduct); // offer is generally preferred for queues
        System.out.println("Product '" + newProduct.getName() + "' added to the queue.");
    }

    /**
     * Processes the next product in the assembly queue.
     * Moves the product from the queue to the completed list.
     */
    public void processNextProduct() {
        Product productToProcess = assemblyQueue.poll(); // poll retrieves and removes the head

        if (productToProcess == null) {
            System.err.println("Error: No products in the queue to process.");
        } else {
            System.out.println("Processing product: " + productToProcess.getName());
            completedProducts.add(productToProcess);
            System.out.println("'" + productToProcess.getName() + "' moved to completed products.");
        }
    }

    /**
     * Displays the products currently waiting in the assembly queue.
     */
    public void viewQueue() {
        System.out.println("--- Waiting Queue ---");
        if (assemblyQueue.isEmpty()) {
            System.out.println("The queue is empty.");
        } else {
            int index = 1;
            // Iterate over the queue without removing elements
            for (Product product : assemblyQueue) {
                System.out.println(index++ + ". " + product.getName());
            }
        }
        System.out.println("---------------------");
    }

    /**
     * Displays the products that have been completed.
     */
    public void viewCompleted() {
        System.out.println("--- Completed Products ---");
        if (completedProducts.isEmpty()) {
            System.out.println("No products have been completed yet.");
        } else {
            int index = 1;
            for (Product product : completedProducts) {
                System.out.println(index++ + ". " + product.getName());
            }
        }
        System.out.println("--------------------------");
    }

    /**
     * Runs the main simulation loop, handling user interaction.
     */
    public void runSimulation() {
        int choice = -1;
        System.out.println("--- Assembly Line Simulation ---");

        while (choice != 5) {
            displayMenu();
            try {
                System.out.print("Enter choice: ");
                choice = scanner.nextInt();
                scanner.nextLine(); // Consume the newline character after reading the integer

                switch (choice) {
                    case 1:
                        System.out.print("Enter product name: ");
                        String productName = scanner.nextLine();
                        addProduct(productName);
                        break;
                    case 2:
                        processNextProduct();
                        break;
                    case 3:
                        viewQueue();
                        break;
                    case 4:
                        viewCompleted();
                        break;
                    case 5:
                        System.out.println("Exiting simulation.");
                        break;
                    default:
                        System.err.println("Invalid choice. Please enter a number between 1 and 5.");
                }
            } catch (InputMismatchException e) {
                System.err.println("Invalid input. Please enter a number.");
                scanner.nextLine(); // Consume the invalid input to prevent infinite loop
                choice = -1; // Reset choice to stay in loop
            } catch (Exception e) {
                // Catch any other unexpected exceptions
                System.err.println("An unexpected error occurred: " + e.getMessage());
                e.printStackTrace(System.err); // Print stack trace to error stream
                choice = 5; // Exit on unexpected error
            }
            System.out.println(); // Add a blank line for readability
        }

        scanner.close(); // Close the scanner when exiting
        System.out.println("Simulation ended.");
    }

    /**
     * Displays the main menu options to the console.
     */
    private void displayMenu() {
        System.out.println("Assembly Line Menu:");
        System.out.println("1. Add Product");
        System.out.println("2. Process Next Product");
        System.out.println("3. View Waiting Queue");
        System.out.println("4. View Completed Products");
        System.out.println("5. Exit");
    }

    /**
     * Main method to start the simulation.
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        AssemblyLine simulation = new AssemblyLine();
        simulation.runSimulation();
    }
}
