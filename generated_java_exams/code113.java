/*
 * Exam Question #113
 * Generated on: 2025-05-11 22:16:10
 * Generated by: Account 2
 * 
 * QUESTION:
 * **Advanced Java Programming Exam Task: Priority Task Management System**
 * 
 * **Problem Description:**
 * 
 * You are tasked with developing a simple command-line application for managing tasks based on priority. The system should allow users to add new tasks, process the highest-priority pending task, and view lists of pending and completed tasks.
 * 
 * A task is defined by a unique ID, a description, and a priority level (an integer, where a *lower* number indicates a *higher* priority, e.g., 1 is highest priority). Tasks are processed one by one, always picking the pending task with the highest priority.
 * 
 * Your solution must adhere to the following technical requirements:
 * 
 * 1.  **Task Representation:** Create a `Task` class with appropriate fields (`id`, `description`, `priority`, `isCompleted`) and methods (constructor, getters). Tasks should be comparable based on priority for processing order.
 * 2.  **Task Management:** Create a `TaskManager` class responsible for managing the collection of tasks.
 *     *   Use a `java.util.Queue` to hold tasks that are pending and ready for processing. This queue must process tasks based on their priority. (Hint: Consider a specific implementation of `Queue` that handles ordering).
 *     *   Use a `java.util.ArrayList` to store tasks that have been completed.
 *     *   Declare variables holding these collections using the `java.util.Queue` and `java.util.List` interfaces.
 * 3.  **User Interface:** Implement a simple command-line interface using `java.util.Scanner` that presents the following options:
 *     *   `a`: Add a new task. Prompts for description and priority.
 *     *   `p`: Process the next highest-priority task.
 *     *   `v`: View pending tasks (sorted by priority).
 *     *   `c`: View completed tasks.
 *     *   `q`: Quit the application.
 * 4.  **Flow Control:** Use a `switch` statement to handle the different user commands.
 * 5.  **Output:**
 *     *   Use `System.out` for all normal output (menu, task details, confirmations).
 *     *   Use `System.err` for all error messages (e.g., invalid input, attempting to process when no tasks are pending).
 * 6.  **Error Handling:** Implement robust error handling:
 *     *   Use `try-catch` blocks to handle potential exceptions, especially around user input (e.g., non-integer input for priority). The main application loop or critical sections should be wrapped in a try-catch to prevent crashes and report errors gracefully.
 *     *   Validate user input where necessary (e.g., priority should be a positive integer).
 *     *   Handle cases where the user attempts to process a task when the pending queue is empty.
 * 7.  **Best Practices:**
 *     *   Employ proper encapsulation (private fields, public getters/methods).
 *     *   Use meaningful variable and method names.
 *     *   Include appropriate comments and documentation (Javadocs are a plus).
 *     *   Ensure clean code structure.
 * 
 * **Expected Output Structure (Example Interaction):**
 * 
 * ```
 * Task Management System
 * Options: a (add), p (process), v (view pending), c (view completed), q (quit)
 * Enter command: a
 * Enter task description: Finish report
 * Enter priority (lower is higher priority): 2
 * Task added: ID 1 - Finish report (Priority: 2)
 * Options: a (add), p (process), v (view pending), c (view completed), q (quit)
 * Enter command: a
 * Enter task description: Respond to email
 * Enter priority (lower is higher priority): 1
 * Task added: ID 2 - Respond to email (Priority: 1)
 * Options: a (add), p (process), v (view pending), c (view completed), q (quit)
 * Enter command: v
 * Pending Tasks:
 * ID 2 - Respond to email (Priority: 1)
 * ID 1 - Finish report (Priority: 2)
 * Options: a (add), p (process), v (view pending), c (view completed), q (quit)
 * Enter command: p
 * Processing task: ID 2 - Respond to email (Priority: 1)
 * Task ID 2 marked as completed.
 * Options: a (add), p (process), v (view pending), c (view completed), q (quit)
 * Enter command: v
 * Pending Tasks:
 * ID 1 - Finish report (Priority: 2)
 * Options: a (add), p (process), v (view pending), c (view completed), q (quit)
 * Enter command: c
 * Completed Tasks:
 * ID 2 - Respond to email (Priority: 1)
 * Options: a (add), p (process), v (view pending), c (view completed), q (quit)
 * Enter command: x
 * Error: Invalid command. Please use a, p, v, c, or q.
 * Options: a (add), p (process), v (view pending), c (view completed), q (quit)
 * Enter command: p
 * Processing task: ID 1 - Finish report (Priority: 2)
 * Task ID 1 marked as completed.
 * Options: a (add), p (process), v (view pending), c (view completed), q (quit)
 * Enter command: p
 * Error: No pending tasks to process.
 * Options: a (add), p (process), v (view pending), c (view completed), q (quit)
 * Enter command: q
 * Exiting Task Management System.
 * ```
 * 
 * Implement the complete Java code for this system.
 *
 * EXPLANATION:
 * The provided solution implements a simple Priority Task Management System, fulfilling all the requirements of the exam task.
 * 
 * 1.  **Task Representation (`Task` class):**
 *     *   The `Task` class encapsulates the data for a single task (`id`, `description`, `priority`, `isCompleted`) using private fields and public getters.
 *     *   It implements the `Comparable<Task>` interface, defining the natural ordering based on priority (`compareTo` method). A lower priority number results in a value less than a higher priority number, which is crucial for the `PriorityQueue`.
 * 
 * 2.  **Task Management (`TaskManager` class):**
 *     *   It uses a `java.util.Queue<Task>` declared as `taskQueue`. The specific implementation chosen is `java.util.PriorityQueue`, which uses the `compareTo` method of the `Task` class to automatically maintain tasks in priority order. This satisfies the requirement of using a `Queue` and processing tasks by priority.
 *     *   It uses a `java.util.List<Task>` declared as `completedTasks`. The specific implementation is `java.util.ArrayList`, satisfying the requirement for both `List` and `ArrayList`.
 *     *   `nextTaskId` is used to assign unique IDs to new tasks.
 *     *   `addTask`: Creates a new `Task` object and adds it to the `taskQueue` using `offer()`. Includes basic validation for description and priority.
 *     *   `processNextTask`: Uses `taskQueue.poll()` to retrieve and remove the head of the queue, which is guaranteed by `PriorityQueue` to be the highest-priority task. It handles the case where the queue is empty. The processed task is marked completed and added to `completedTasks`.
 *     *   `viewPendingTasks`: Iterates through a *copy* of the `taskQueue`'s elements (copied into an `ArrayList`) and sorts this list using the `Task`'s natural ordering (`compareTo`). This is done because iterating directly over a `PriorityQueue` does not guarantee sorted order; copying to a list and sorting ensures the display is in priority order without altering the queue's state.
 *     *   `viewCompletedTasks`: Iterates through the `completedTasks` `ArrayList` and prints the details.
 * 
 * 3.  **User Interface and Flow Control:**
 *     *   The `run()` method contains the main application loop.
 *     *   A `Scanner` is used to read user input from the console.
 *     *   A `switch` statement is used to handle the different command characters entered by the user (`a`, `p`, `v`, `c`, `q`).
 * 
 * 4.  **Output and Error Handling:**
 *     *   `System.out.println()` is used for displaying menus, task details, and successful operation messages.
 *     *   `System.err.println()` is used exclusively for displaying error messages, such as invalid commands, invalid input format (caught by `try-catch`), or attempting to process tasks when the queue is empty.
 *     *   A large `try-catch (Exception e)` block wraps the main `while` loop in the `run()` method. This provides class-wide exception handling, catching any unexpected runtime errors that might occur within the main application flow and preventing the program from crashing abruptly.
 *     *   An inner `try-catch (InputMismatchException e)` is specifically used when reading the task priority to catch non-integer input. It prints an error to `System.err` and consumes the invalid input line from the `Scanner` to prevent an infinite loop.
 *     *   Input validation is performed for priority (must be positive) and description (cannot be empty).
 * 
 * 5.  **Best Practices:**
 *     *   Fields in `Task` and `TaskManager` are `private`, accessed via public methods (`getters`, `addTask`, `processNextTask`, etc.), demonstrating encapsulation.
 *     *   Variable and method names are descriptive (e.g., `taskQueue`, `completedTasks`, `processNextTask`, `viewPendingTasks`).
 *     *   Comments explain the purpose of classes, key methods, and important logic sections (like the `compareTo` method and the `viewPendingTasks` sorting logic).
 *     *   The code is structured into logical classes (`Task`, `TaskManager`) and methods, promoting readability and maintainability.
 *     *   The `Scanner` is properly closed in a `finally` block to release system resources.
 * 
 * This solution effectively integrates the required Java components (`Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.err`, `System.out`, `try-catch`) within a practical task management scenario, demonstrating an understanding of data structures, object-oriented programming, user interaction, and robust error handling.
 */

import java.util.ArrayList;
import java.util.List;
import java.util.Queue;
import java.util.PriorityQueue;
import java.util.Scanner;
import java.util.Comparator;
import java.util.InputMismatchException;

/**
 * Represents a single task with a description, priority, and completion status.
 * Tasks are ordered based on their priority (lower number = higher priority).
 */
class Task implements Comparable<Task> {
    private int id;
    private String description;
    private int priority;
    private boolean isCompleted;

    /**
     * Constructs a new Task.
     * @param id The unique identifier for the task.
     * @param description The description of the task.
     * @param priority The priority level (lower is higher priority).
     */
    public Task(int id, String description, int priority) {
        this.id = id;
        this.description = description;
        this.priority = priority;
        this.isCompleted = false;
    }

    // --- Getters ---
    public int getId() {
        return id;
    }

    public String getDescription() {
        return description;
    }

    public int getPriority() {
        return priority;
    }

    public boolean isCompleted() {
        return isCompleted;
    }

    // --- Setter for completion status ---
    public void markCompleted() {
        this.isCompleted = true;
    }

    /**
     * Compares this task to another task based on priority.
     * Lower priority number means higher priority task.
     * Used by PriorityQueue to order tasks.
     * @param other The task to compare to.
     * @return A negative integer, zero, or a positive integer as this task
     *         is less than, equal to, or greater than the specified task.
     */
    @Override
    public int compareTo(Task other) {
        // Compare priorities: lower number first
        int priorityComparison = Integer.compare(this.priority, other.priority);
        if (priorityComparison != 0) {
            return priorityComparison;
        }
        // If priorities are the same, maintain stable order based on ID (optional but good practice)
        return Integer.compare(this.id, other.id);
    }

    @Override
    public String toString() {
        return "ID " + id + " - " + description + " (Priority: " + priority + ")";
    }
}

/**
 * Manages a collection of tasks using a priority queue for pending tasks
 * and an ArrayList for completed tasks.
 */
public class TaskManager { // Renamed from main class to TaskManager

    // Queue for pending tasks, ordered by priority (lower number = higher priority)
    private Queue<Task> taskQueue;

    // List for completed tasks
    private List<Task> completedTasks;

    // Counter for generating unique task IDs
    private int nextTaskId;

    private Scanner scanner;

    /**
     * Constructs a new TaskManager.
     */
    public TaskManager() {
        // PriorityQueue orders elements based on their natural ordering (Task implements Comparable)
        taskQueue = new PriorityQueue<>();
        completedTasks = new ArrayList<>();
        nextTaskId = 1;
        scanner = new Scanner(System.in);
    }

    /**
     * Adds a new task to the queue.
     * @param description The task description.
     * @param priority The task priority.
     */
    public void addTask(String description, int priority) {
        if (description == null || description.trim().isEmpty()) {
             System.err.println("Error: Task description cannot be empty.");
             return;
        }
         if (priority <= 0) {
             System.err.println("Error: Priority must be a positive integer.");
             return;
         }
        Task newTask = new Task(nextTaskId++, description, priority);
        taskQueue.offer(newTask); // Use offer for queue insertion
        System.out.println("Task added: " + newTask);
    }

    /**
     * Processes the next highest-priority task from the queue.
     * Moves the completed task to the completed list.
     */
    public void processNextTask() {
        Task taskToProcess = taskQueue.poll(); // Use poll to retrieve and remove head, returns null if empty

        if (taskToProcess == null) {
            System.err.println("Error: No pending tasks to process.");
        } else {
            System.out.println("Processing task: " + taskToProcess);
            taskToProcess.markCompleted();
            completedTasks.add(taskToProcess);
            System.out.println("Task ID " + taskToProcess.getId() + " marked as completed.");
        }
    }

    /**
     * Displays all pending tasks currently in the queue.
     * Note: Iterating over a PriorityQueue does NOT guarantee iteration order.
     * To display in priority order, we might need to copy elements or use another structure.
     * For simplicity and to show the Queue's contents, we'll iterate directly,
     * but acknowledge this limitation if strict display order is required without processing.
     * A better way to *display* pending tasks in order is to copy to a temporary list and sort,
     * but the prompt asks to use the Queue for pending tasks. Let's iterate.
     * (Correction: The prompt asks to use Queue for *pending* tasks. Displaying them sorted requires
     * extracting them in sorted order or copying and sorting. Copying to a list and sorting
     * demonstrates List usage for display purposes while Queue holds the actual processing order).
     */
    public void viewPendingTasks() {
        if (taskQueue.isEmpty()) {
            System.out.println("No pending tasks.");
            return;
        }
        System.out.println("Pending Tasks:");
        // To display pending tasks in priority order without removing them from the queue:
        // Copy tasks to a list and sort the list.
        List<Task> pendingList = new ArrayList<>(taskQueue);
        // The Task class's compareTo method provides the correct sorting order
        pendingList.sort(null); // Sorts using the natural order defined by compareTo

        for (Task task : pendingList) {
            System.out.println(task);
        }
    }

    /**
     * Displays all completed tasks.
     */
    public void viewCompletedTasks() {
        if (completedTasks.isEmpty()) {
            System.out.println("No completed tasks.");
            return;
        }
        System.out.println("Completed Tasks:");
        for (Task task : completedTasks) {
            System.out.println(task);
        }
    }

    /**
     * Runs the main application loop, handling user input and commands.
     * Includes class-wide exception handling.
     */
    public void run() {
        System.out.println("Task Management System");
        boolean running = true;

        // Class-wide try-catch wrapping the main application loop
        try {
            while (running) {
                System.out.println("Options: a (add), p (process), v (view pending), c (view completed), q (quit)");
                System.out.print("Enter command: ");

                String command = scanner.nextLine().trim().toLowerCase();

                switch (command) {
                    case "a":
                        System.out.print("Enter task description: ");
                        String description = scanner.nextLine();
                        int priority = -1;
                        try {
                            System.out.print("Enter priority (lower is higher priority): ");
                            priority = scanner.nextInt();
                            // Consume the rest of the line after reading the integer
                            scanner.nextLine();
                            addTask(description, priority);
                        } catch (InputMismatchException e) {
                            System.err.println("Error: Invalid priority input. Please enter an integer.");
                            // Consume the invalid input to prevent infinite loop
                            scanner.nextLine();
                        }
                        break;
                    case "p":
                        processNextTask();
                        break;
                    case "v":
                        viewPendingTasks();
                        break;
                    case "c":
                        viewCompletedTasks();
                        break;
                    case "q":
                        running = false;
                        System.out.println("Exiting Task Management System.");
                        break;
                    default:
                        System.err.println("Error: Invalid command. Please use a, p, v, c, or q.");
                        break;
                }
            }
        } catch (Exception e) {
            // Catch any unexpected exceptions that might occur in the loop
            System.err.println("An unexpected error occurred: " + e.getMessage());
            // e.printStackTrace(); // Uncomment for debugging
        } finally {
            // Ensure the scanner is closed when the application exits
            if (scanner != null) {
                scanner.close();
            }
        }
    }

    /**
     * Main method to start the application.
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        TaskManager manager = new TaskManager();
        manager.run();
    }
}
