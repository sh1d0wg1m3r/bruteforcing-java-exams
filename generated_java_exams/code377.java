/*
 * Exam Question #377
 * Generated on: 2025-05-11 23:02:21
 * Generated by: Account 2
 * 
 * QUESTION:
 * ## Advanced Java Programming Exam Task: Task Scheduler System
 * 
 * **Objective:** Design and implement a command-line application in Java that simulates a simple task scheduling system. The system should manage tasks in a queue for processing and maintain a history of completed tasks. This task requires demonstrating proficiency in core Java data structures, input/output, control flow, and exception handling.
 * 
 * **Scenario:** You are building a basic system to manage tasks that need to be processed sequentially. New tasks are added to a waiting list, and the system processes the oldest task first. Once processed, a task is moved to a history list. The user interacts with the system via a simple menu.
 * 
 * **Requirements:**
 * 
 * 1.  **Core Data Structures:**
 *     *   Use `java.util.Queue` to store tasks that are pending (waiting to be processed).
 *     *   Use `java.util.List` (specifically implemented with `java.util.ArrayList`) to store tasks that have been completed.
 * 2.  **User Interaction:**
 *     *   Use `java.util.Scanner` to read user input from the console (menu choices, task descriptions).
 *     *   Implement a menu-driven interface with the following options:
 *         1.  Add New Task
 *         2.  Process Next Task
 *         3.  View Pending Tasks
 *         4.  View Completed Tasks
 *         5.  Exit
 * 3.  **Control Flow:**
 *     *   Use a `switch` statement to handle the different menu options selected by the user.
 *     *   Use a loop to keep the application running until the user chooses to exit.
 * 4.  **Input/Output:**
 *     *   Use `System.out` for displaying the menu, prompts, successful operation messages, and task lists.
 *     *   Use `System.err` for displaying error messages (e.g., invalid menu choice, invalid input format, empty task description).
 * 5.  **Error Handling & Validation:**
 *     *   Implement **class-wide exception handling** using `try-catch` blocks. Specifically, wrap the main application loop in a `try-catch` block to catch unexpected runtime errors.
 *     *   Implement specific `try-catch` blocks for handling potential `NumberFormatException` when parsing user input for the menu choice.
 *     *   Validate user input for adding tasks: ensure the task description is not empty or just whitespace. Use `System.err` if validation fails.
 *     *   Gracefully handle operations on empty collections (e.g., trying to process a task when the pending queue is empty).
 * 6.  **Code Structure & Best Practices:**
 *     *   Design the system with proper encapsulation. Create a `Task` class (representing a single task) and a `TaskScheduler` class (managing the collections and operations).
 *     *   Use meaningful names for variables, methods, and classes.
 *     *   Include appropriate comments and documentation (e.g., Javadoc for classes/methods).
 *     *   Ensure resources like `Scanner` are properly closed.
 * 
 * **Task Details:**
 * 
 * *   A `Task` should have at least a unique ID (you can simply use a counter) and a `String` description.
 * *   "Add New Task": Prompts the user for a description and adds a new `Task` object to the pending queue.
 * *   "Process Next Task": Removes the task at the front of the pending queue and adds it to the completed list. Reports which task was processed or if the queue was empty.
 * *   "View Pending Tasks": Displays the tasks in the pending queue *without* removing them.
 * *   "View Completed Tasks": Displays the tasks in the completed list.
 * 
 * **Expected Output:**
 * 
 * Your program should display a menu, accept numeric input for choices, and perform the corresponding actions, printing messages to `System.out` for success/info and `System.err` for errors.
 * 
 * Example Interaction Flow:
 * 
 * ```
 * --- Task Scheduler System ---
 * --- Menu ---
 * 1. Add New Task
 * 2. Process Next Task
 * 3. View Pending Tasks
 * 4. View Completed Tasks
 * 5. Exit
 * ------------
 * Enter your choice: 1
 * Enter task description: Write exam question
 * Success: Task added to queue: [ID:1] Write exam question
 * 
 * --- Menu ---
 * ...
 * Enter your choice: 1
 * Enter task description: Create solution code
 * Success: Task added to queue: [ID:2] Create solution code
 * 
 * --- Menu ---
 * ...
 * Enter your choice: 3
 * --- Pending Tasks ---
 * 1. [ID:1] Write exam question
 * 2. [ID:2] Create solution code
 * ---------------------
 * 
 * --- Menu ---
 * ...
 * Enter your choice: 2
 * Success: Task processed: [ID:1] Write exam question
 * 
 * --- Menu ---
 * ...
 * Enter your choice: 3
 * --- Pending Tasks ---
 * 1. [ID:2] Create solution code
 * ---------------------
 * 
 * --- Menu ---
 * ...
 * Enter your choice: 4
 * --- Completed Tasks ---
 * 1. [ID:1] Write exam question
 * -----------------------
 * 
 * --- Menu ---
 * ...
 * Enter your choice: invalid_input
 * Invalid input format. Please enter a number.
 * 
 * --- Menu ---
 * ...
 * Enter your choice: 6
 * Invalid choice. Please select a number between 1 and 5.
 * 
 * --- Menu ---
 * ...
 * Enter your choice: 1
 * Enter task description:
 * Error: Task description cannot be empty.
 * 
 * --- Menu ---
 * ...
 * Enter your choice: 2
 * Success: Task processed: [ID:2] Create solution code
 * 
 * --- Menu ---
 * ...
 * Enter your choice: 2
 * Info: No pending tasks to process.
 * 
 * --- Menu ---
 * ...
 * Enter your choice: 5
 * Exiting Task Scheduler. Goodbye!
 * Scanner closed.
 * ```
 * 
 * You should provide the complete Java code for this system, including all necessary classes.
 *
 * EXPLANATION:
 * This solution implements a simple command-line Task Scheduler system demonstrating the required Java concepts and best practices.
 * 
 * 1.  **`Task` Class:** A basic class encapsulating the data for a single task: an integer `id` and a `String` `description`. It includes a constructor and a `toString()` method for easy representation. Fields are `private` for encapsulation.
 * 
 * 2.  **`TaskScheduler` Class:** This class manages the collections of tasks.
 *     *   `private Queue<Task> pendingTasks;`: Declared as a `Queue` interface reference, implemented using `java.util.LinkedList`. This correctly represents tasks waiting to be processed in a First-In, First-Out (FIFO) manner.
 *     *   `private List<Task> completedTasks;`: Declared as a `List` interface reference, implemented using `java.util.ArrayList`. This stores completed tasks, maintaining their order of completion and allowing easy iteration.
 *     *   `addTask(String description)`: Creates a new `Task` and adds it to the `pendingTasks` queue using `offer()`. Includes input validation to check for empty descriptions, printing an error to `System.err` if invalid. Uses `System.out` for success messages.
 *     *   `processNextTask()`: Removes the next task from the `pendingTasks` queue using `poll()` (which returns `null` if the queue is empty, preventing exceptions) and adds it to the `completedTasks` list. Reports success or emptiness using `System.out`.
 *     *   `viewPendingTasks()`: Iterates through the `pendingTasks` queue (using a for-each loop, which doesn't remove elements) and prints each task using `System.out`. Handles the empty case.
 *     *   `viewCompletedTasks()`: Iterates through the `completedTasks` list and prints each task using `System.out`. Handles the empty case.
 *     *   All fields are `private`, and methods are `public` or `private` as appropriate, demonstrating encapsulation.
 * 
 * 3.  **`TaskSchedulerApp` Class:** This is the main application class.
 *     *   It contains the `main` method, which is the entry point.
 *     *   It holds instances of `TaskScheduler` and `Scanner`.
 *     *   The `run()` method contains the main application loop.
 *     *   **`Scanner`:** An instance of `Scanner` reads user input from `System.in`. It's initialized and later closed in the `finally` block.
 *     *   **`try-catch` (Class-wide):** The entire `while(running)` loop within the `run()` method is wrapped in a `try-catch(Exception e)` block. This provides class-wide exception handling, catching any unexpected runtime errors that might occur during the application's execution and printing an error message to `System.err` along with a stack trace.
 *     *   **`try-catch` (Input Validation):** Inside the loop, a specific `try-catch(NumberFormatException e)` block is used when attempting to parse the user's menu choice from a `String` to an `int`. This handles cases where the user enters non-numeric input, preventing the program from crashing and printing an error message to `System.err`. The `continue` statement skips the rest of the loop body for that iteration, prompting the user again.
 *     *   **`switch` Statement:** A `switch` statement is used to direct the program flow based on the validated integer menu choice, calling the appropriate methods on the `TaskScheduler` instance. The `default` case handles invalid numeric choices, printing an error to `System.err`.
 *     *   **`System.out` and `System.err`:** Used throughout the `run()` method and delegated calls to `TaskScheduler` for output. `System.out` is used for the menu, prompts, and successful/informational messages. `System.err` is specifically used for error conditions (invalid input format, invalid menu choice, task description validation failure).
 *     *   **`finally` Block:** Ensures the `Scanner` resource is closed when the `try` block is exited, whether normally or due to an exception.
 *     *   The `printMenu()` method is a private helper method demonstrating modularity and using `System.out`.
 * 
 * This solution effectively integrates all required components (`Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.err`, `System.out`, `try-catch`) into a cohesive, practical application while adhering to fundamental Java programming best practices like encapsulation, clear naming, validation, and error handling.
 */

import java.util.Queue;
import java.util.List;
import java.util.LinkedList; // Implementation for Queue
import java.util.ArrayList; // Implementation for List
import java.util.Scanner;

/**
 * Represents a single task with an ID and description.
 */
class Task {
    private int id;
    private String description;

    /**
     * Constructs a new Task.
     * @param id The unique identifier for the task.
     * @param description The description of the task.
     */
    public Task(int id, String description) {
        this.id = id;
        this.description = description;
    }

    /**
     * Gets the task ID.
     * @return The task ID.
     */
    public int getId() {
        return id;
    }

    /**
     * Gets the task description.
     * @return The task description.
     */
    public String getDescription() {
        return description;
    }

    /**
     * Provides a string representation of the Task.
     * @return String representation.
     */
    @Override
    public String toString() {
        return "[ID:" + id + "] " + description;
    }
}

/**
 * Manages the collection of tasks using a Queue for pending tasks
 * and a List for completed tasks.
 */
class TaskScheduler {
    // Queue to hold tasks waiting to be processed (FIFO)
    private Queue<Task> pendingTasks;
    // List to hold tasks that have been completed (history)
    private List<Task> completedTasks;
    // Counter for generating unique task IDs
    private int nextTaskId = 1;

    /**
     * Constructs a new TaskScheduler, initializing the task collections.
     */
    public TaskScheduler() {
        // Use LinkedList as the implementation for the Queue interface
        this.pendingTasks = new LinkedList<>();
        // Use ArrayList as the implementation for the List interface
        this.completedTasks = new ArrayList<>();
    }

    /**
     * Adds a new task to the pending tasks queue.
     * Performs basic validation on the description.
     * @param description The description of the task.
     */
    public void addTask(String description) {
        if (description == null || description.trim().isEmpty()) {
            // Use System.err for invalid input messages
            System.err.println("Error: Task description cannot be empty.");
            return;
        }
        Task newTask = new Task(nextTaskId++, description.trim());
        // offer() is preferred over add() in Queue as it returns false if insertion fails
        this.pendingTasks.offer(newTask);
        // Use System.out for normal confirmation messages
        System.out.println("Success: Task added to queue: " + newTask);
    }

    /**
     * Processes the next task in the pending queue.
     * Removes the task from the queue and adds it to the completed list.
     * Handles the case where the queue is empty.
     */
    public void processNextTask() {
        // poll() retrieves and removes the head of the queue, returns null if empty
        Task processedTask = this.pendingTasks.poll();
        if (processedTask != null) {
            this.completedTasks.add(processedTask);
            // Use System.out for normal operation messages
            System.out.println("Success: Task processed: " + processedTask);
        } else {
            // Use System.out for informational messages
            System.out.println("Info: No pending tasks to process.");
        }
    }

    /**
     * Displays all tasks currently in the pending queue.
     * Does not remove tasks from the queue.
     * Uses System.out for output.
     */
    public void viewPendingTasks() {
        // Check if the queue is empty
        if (this.pendingTasks.isEmpty()) {
            System.out.println("Info: No pending tasks.");
        } else {
            System.out.println("--- Pending Tasks ---");
            // Iterate through the queue without removing elements
            int index = 1;
            for (Task task : this.pendingTasks) {
                System.out.println(index++ + ". " + task);
            }
            System.out.println("---------------------");
        }
    }

    /**
     * Displays all tasks that have been completed.
     * Uses System.out for output.
     */
    public void viewCompletedTasks() {
        // Check if the list is empty
        if (this.completedTasks.isEmpty()) {
            System.out.println("Info: No completed tasks.");
        } else {
            System.out.println("--- Completed Tasks ---");
            // Iterate through the list
            int index = 1;
            for (Task task : this.completedTasks) {
                System.out.println(index++ + ". " + task);
            }
            System.out.println("-----------------------");
        }
    }
}

/**
 * Main class for the Task Scheduler System application.
 * Handles user interaction, menu display, and delegates operations to TaskScheduler.
 * Demonstrates Scanner, Switch, System.out, System.err, and class-wide Try-Catch.
 */
public class TaskSchedulerApp {

    // Instance of the TaskScheduler to manage tasks
    private TaskScheduler scheduler = new TaskScheduler();
    // Scanner for reading user input
    private Scanner scanner; // Declare here, initialize in run()

    /**
     * Main method - entry point of the application.
     * Creates and runs the TaskSchedulerApp.
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        TaskSchedulerApp app = new TaskSchedulerApp();
        app.run();
    }

    /**
     * Runs the main application loop, handling user input and menu choices.
     * Includes class-wide exception handling and input validation.
     */
    public void run() {
        // Initialize scanner for System.in
        this.scanner = new Scanner(System.in);
        boolean running = true;

        System.out.println("--- Task Scheduler System ---");

        // Class-wide exception handling for the main application loop
        try {
            while (running) {
                printMenu();
                System.out.print("Enter your choice: ");

                // Input validation for menu choice
                int choice = -1; // Default to an invalid choice
                try {
                    // Read the entire line to handle potential non-numeric input
                    String inputLine = scanner.nextLine();
                    choice = Integer.parseInt(inputLine);
                } catch (NumberFormatException e) {
                    // Use System.err for invalid input errors
                    System.err.println("Invalid input format. Please enter a number.");
                    // Continue the loop to show the menu again
                    continue; // Skip the rest of the loop body for this iteration
                }

                // Switch statement for processing user choices
                switch (choice) {
                    case 1:
                        System.out.print("Enter task description: ");
                        String description = scanner.nextLine();
                        scheduler.addTask(description);
                        break;
                    case 2:
                        scheduler.processNextTask();
                        break;
                    case 3:
                        scheduler.viewPendingTasks();
                        break;
                    case 4:
                        scheduler.viewCompletedTasks();
                        break;
                    case 5:
                        System.out.println("Exiting Task Scheduler. Goodbye!");
                        running = false; // Set flag to exit loop
                        break;
                    default:
                        // Use System.err for invalid choice errors
                        System.err.println("Invalid choice. Please select a number between 1 and 5.");
                        break;
                }
                System.out.println(); // Add a newline for better readability between operations
            }
        } catch (Exception e) {
            // Catch any unexpected runtime exceptions that occur within the loop
            // Use System.err for unexpected errors
            System.err.println("An unexpected system error occurred: " + e.getMessage());
            e.printStackTrace(); // Print stack trace for debugging purposes
        } finally {
            // Ensure the scanner resource is closed regardless of how the loop exits
            if (scanner != null) {
                scanner.close();
                System.out.println("Scanner closed."); // Optional: confirm closure
            }
        }
    }

    /**
     * Prints the main menu options to the console using System.out.
     */
    private void printMenu() {
        System.out.println("--- Menu ---");
        System.out.println("1. Add New Task");
        System.out.println("2. Process Next Task");
        System.out.println("3. View Pending Tasks");
        System.out.println("4. View Completed Tasks");
        System.out.println("5. Exit");
        System.out.println("------------");
    }
}
