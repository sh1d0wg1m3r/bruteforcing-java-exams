/*
 * Exam Question #1056
 * Generated on: 2025-05-12 17:18:55
 * Generated by: Account 4
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Package Processing Center Simulation
 * 
 * **Scenario:**
 * 
 * You are tasked with developing a simplified simulation of a package processing center. Packages arrive and are placed in an incoming queue. Workers process packages one by one from the queue, verify their destination, and sort them into different delivery manifests (local or interstate). The system needs to handle user interaction for adding packages, processing them, and viewing the current status.
 * 
 * **Requirements:**
 * 
 * Implement a Java program that simulates this package processing center. Your solution must adhere to the following requirements:
 * 
 * 1.  **Classes:**
 *     *   Create a `Package` class representing a package with attributes: `packageId` (String), `destination` (String), and `weight` (double). Include appropriate constructors, getters, and setters. Override `toString()` for easy printing.
 *     *   Create a `PackageProcessingCenter` class that manages the package flow.
 * 
 * 2.  **Data Structures:**
 *     *   The `PackageProcessingCenter` must use a `java.util.Queue` to hold incoming packages awaiting processing.
 *     *   The `PackageProcessingCenter` must use `java.util.ArrayList` instances (referenced via the `java.util.List` interface type) to store processed packages in different manifests (e.g., `localManifest`, `interstateManifest`).
 * 
 * 3.  **Functionality:**
 *     *   **Add Package:** Allow the user to add a new package to the incoming queue. Prompt for package ID, destination, and weight. Implement input validation: package ID and destination cannot be empty, weight must be a positive number.
 *     *   **Process Next Package:** Remove the next package from the front of the incoming queue. Simulate processing by asking the user to confirm the destination (e.g., "Is this package for a local destination? (yes/no)"). Based on the user's input, add the package to either the `localManifest` or `interstateManifest` list. Handle the case where the incoming queue is empty.
 *     *   **View Incoming Queue:** Display the details of all packages currently in the incoming queue.
 *     *   **View Manifests:** Display the details of all packages sorted into the local and interstate manifests.
 *     *   **Exit:** Terminate the program.
 * 
 * 4.  **User Interface:**
 *     *   Use `java.util.Scanner` to read user input for menu choices and package details.
 *     *   Present a clear menu of options to the user.
 *     *   Use a `switch` statement to handle the user's menu selection.
 * 
 * 5.  **Error Handling:**
 *     *   Implement class-wide exception handling using `try-catch` blocks for potential issues like invalid input format (e.g., non-numeric weight) or attempting to process from an empty queue.
 *     *   Use `System.err` to print error messages (e.g., "Invalid input:", "Queue is empty:").
 *     *   Use `System.out` for all normal output (menu, prompts, success messages, package details).
 * 
 * 6.  **Best Practices:**
 *     *   Employ proper encapsulation (private fields, public methods).
 *     *   Use meaningful variable and method names.
 *     *   Include appropriate comments and documentation where necessary.
 *     *   Ensure input validation is robust.
 *     *   Structure the code logically.
 * 
 * **Expected Output:**
 * 
 * The program should present a menu, accept user input, perform actions, print results to `System.out`, and print errors to `System.err`. Example interaction might look like:
 * 
 * ```
 * --- Package Processing Center Menu ---
 * 1. Add Package
 * 2. Process Next Package
 * 3. View Incoming Queue
 * 4. View Manifests
 * 5. Exit
 * Enter your choice: 1
 * Enter Package ID: PKG001
 * Enter Destination: Cityville
 * Enter Weight (kg): 2.5
 * Package PKG001 added to incoming queue.
 * 
 * --- Package Processing Center Menu ---
 * 1. Add Package
 * 2. Process Next Package
 * 3. View Incoming Queue
 * 4. View Manifests
 * 5. Exit
 * Enter your choice: 1
 * Enter Package ID: PKG002
 * Enter Destination: Stateburg
 * Enter Weight (kg): abc
 * System.err: Invalid input: Weight must be a valid positive number.
 * 
 * --- Package Processing Center Menu ---
 * ... (user adds more packages) ...
 * 
 * --- Package Processing Center Menu ---
 * 1. Add Package
 * 2. Process Next Package
 * 3. View Incoming Queue
 * 4. View Manifests
 * 5. Exit
 * Enter your choice: 2
 * Processing package: Package [id=PKG001, destination=Cityville, weight=2.5]
 * Is this package for a local destination? (yes/no): yes
 * Package PKG001 sorted into Local Manifest.
 * 
 * --- Package Processing Center Menu ---
 * 1. Add Package
 * 2. Process Next Package
 * 3. View Incoming Queue
 * 4. View Manifests
 * 5. Exit
 * Enter your choice: 4
 * --- Local Manifest ---
 * Package [id=PKG001, destination=Cityville, weight=2.5]
 * --- Interstate Manifest ---
 * (Empty)
 * 
 * --- Package Processing Center Menu ---
 * ... (user continues) ...
 * ```
 * 
 * Your solution should be a complete, runnable Java program.
 *
 * EXPLANATION:
 * This solution implements the `PackageProcessingCenter` simulation, demonstrating the required Java concepts and best practices.
 * 
 * 1.  **`Package` Class:** A simple Plain Old Java Object (POJO) class with private fields (`packageId`, `destination`, `weight`), a constructor, public getters for accessing the data, and an overridden `toString()` method for convenient printing of package details. This adheres to encapsulation principles.
 * 
 * 2.  **`PackageProcessingCenter` Class:**
 *     *   **Data Structures:**
 *         *   `Queue<Package> incomingQueue = new LinkedList<>();`: A `Queue` is used to model the incoming packages, ensuring they are processed in First-In, First-Out (FIFO) order. `LinkedList` is a common implementation of the `Queue` interface.
 *         *   `List<Package> localManifest = new ArrayList<>();` and `List<Package> interstateManifest = new ArrayList<>();`: `ArrayList` is used to store the processed packages in the manifests. The variables are declared using the `List` interface type, which is good practice as it allows for easier switching to a different `List` implementation later if needed.
 *     *   **Encapsulation:** All data structure fields (`incomingQueue`, `localManifest`, `interstateManifest`, `scanner`) are private.
 *     *   **Methods:**
 *         *   `displayMenu()`: A helper method for presenting the user options.
 *         *   `addPackage()`: Handles user input for package details. It includes validation checks (`id.isEmpty()`, `destination.isEmpty()`, `weight <= 0`) and uses a `try-catch` block specifically for handling `InputMismatchException` if the user enters non-numeric input for weight. `System.err` is used for validation and input errors. `incomingQueue.offer()` adds the package to the queue.
 *         *   `processNextPackage()`: Retrieves the next package using `incomingQueue.poll()`. `poll()` is used because it returns `null` if the queue is empty, which is then checked. A `try-catch` block wraps the core processing logic to catch any unexpected errors. It prompts the user for destination confirmation and adds the package to the appropriate `ArrayList` (`localManifest` or `interstateManifest`) via their `List` interface references. `System.err` is used if the queue is empty or if the user provides invalid input for the confirmation.
 *         *   `viewIncomingQueue()`: Iterates through the `incomingQueue` using a for-each loop (which doesn't remove elements) and prints each package. Checks if the queue is empty.
 *         *   `viewManifests()`: Iterates through the `localManifest` and `interstateManifest` `ArrayList`s (referenced as `List`) and prints their contents. Checks if each list is empty.
 *         *   `run()`: This is the main application loop. It continuously displays the menu, reads user input using `scanner.nextInt()`, and uses a `switch` statement to dispatch the call to the appropriate method based on the user's choice. A `try-catch` block is included around reading the menu choice to handle `InputMismatchException`. Another `try-catch` block wraps the entire `while` loop to catch any potentially unhandled exceptions that might propagate up, providing a safety net for the application. The `finally` block ensures the `Scanner` is closed upon exiting.
 *     *   **`main` Method:** Creates an instance of `PackageProcessingCenter` and calls the `run()` method to start the application.
 * 
 * 3.  **Required Components Usage:**
 *     *   `Queue`: Used for `incomingQueue` (`LinkedList` implementation).
 *     *   `ArrayList`: Used for `localManifest` and `interstateManifest` implementations.
 *     *   `List`: Used as the type for `localManifest` and `interstateManifest` variables.
 *     *   `Scanner`: Used in `PackageProcessingCenter` for all user input.
 *     *   `Switch`: Used in the `run()` method to handle menu selection.
 *     *   `System.err`: Used for printing error messages related to invalid input, empty queue conditions, or unexpected errors.
 *     *   `System.out`: Used for printing the menu, prompts, success messages, and package/manifest details.
 *     *   `try-catch`: Used in `addPackage()` for `InputMismatchException`, in `processNextPackage()` for general processing errors and checking for null from `poll()`, and in `run()` for handling menu input errors and as an overall safety net for the main loop.
 * 
 * 4.  **Best Practices:**
 *     *   **Encapsulation:** Fields are private, access is via public methods.
 *     *   **Naming:** Classes, methods, and variables have descriptive names (`Package`, `processNextPackage`, `incomingQueue`, `localManifest`, `packageId`, etc.).
 *     *   **Comments:** Javadoc-style comments explain the purpose of classes and methods, and inline comments explain specific logic.
 *     *   **Input Validation:** Explicit checks are made for empty strings and non-positive weight in `addPackage()`.
 *     *   **Error Handling:** Specific exceptions (`InputMismatchException`) are caught where expected, and general `Exception` catch blocks provide robustness. `System.err` is used appropriately for errors.
 *     *   **Clean Code Structure:** The code is divided into logical classes and methods, with clear responsibilities. The main application logic is contained within the `run()` method.
 * 
 * This solution effectively integrates the required Java components into a functional simulation, demonstrating understanding of data structures, object-oriented principles, user interaction, and robust error handling.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.InputMismatchException;

/**
 * Represents a package with ID, destination, and weight.
 */
class Package {
    private String packageId;
    private String destination;
    private double weight;

    /**
     * Constructs a new Package.
     *
     * @param packageId The unique identifier for the package.
     * @param destination The destination address or city.
     * @param weight The weight of the package in kilograms.
     */
    public Package(String packageId, String destination, double weight) {
        this.packageId = packageId;
        this.destination = destination;
        this.weight = weight;
    }

    // Getters
    public String getPackageId() {
        return packageId;
    }

    public String getDestination() {
        return destination;
    }

    public double getWeight() {
        return weight;
    }

    /**
     * Returns a string representation of the Package.
     */
    @Override
    public String toString() {
        return "Package [id=" + packageId + ", destination=" + destination + ", weight=" + weight + "]";
    }
}

/**
 * Simulates a package processing center managing incoming packages and sorted manifests.
 */
public class PackageProcessingCenter {

    // Queue for packages awaiting processing
    private Queue<Package> incomingQueue;

    // Lists (manifests) for sorted packages
    private List<Package> localManifest;
    private List<Package> interstateManifest;

    private Scanner scanner;

    /**
     * Constructs a PackageProcessingCenter.
     */
    public PackageProcessingCenter() {
        this.incomingQueue = new LinkedList<>(); // LinkedList implements Queue
        this.localManifest = new ArrayList<>();  // Using ArrayList for manifests
        this.interstateManifest = new ArrayList<>();
        this.scanner = new Scanner(System.in);
    }

    /**
     * Displays the main menu options.
     */
    private void displayMenu() {
        System.out.println("\n--- Package Processing Center Menu ---");
        System.out.println("1. Add Package");
        System.out.println("2. Process Next Package");
        System.out.println("3. View Incoming Queue");
        System.out.println("4. View Manifests");
        System.out.println("5. Exit");
        System.out.print("Enter your choice: ");
    }

    /**
     * Adds a new package to the incoming queue based on user input.
     * Handles input validation and exceptions.
     */
    public void addPackage() {
        System.out.print("Enter Package ID: ");
        String id = scanner.nextLine().trim();

        System.out.print("Enter Destination: ");
        String destination = scanner.nextLine().trim();

        double weight = -1; // Use a default invalid value

        // Input validation and exception handling for weight
        try {
            System.out.print("Enter Weight (kg): ");
            weight = scanner.nextDouble();
            // Consume the rest of the line after reading double
            scanner.nextLine();
        } catch (InputMismatchException e) {
            System.err.println("Invalid input: Weight must be a valid positive number.");
            scanner.nextLine(); // Consume the invalid input to prevent infinite loop
            return; // Exit the method if input is invalid
        }

        // Validate ID, Destination, and Weight
        if (id.isEmpty()) {
            System.err.println("Invalid input: Package ID cannot be empty.");
            return;
        }
        if (destination.isEmpty()) {
            System.err.println("Invalid input: Destination cannot be empty.");
            return;
        }
        if (weight <= 0) {
            System.err.println("Invalid input: Weight must be a positive number.");
            return;
        }

        Package newPackage = new Package(id, destination, weight);
        incomingQueue.offer(newPackage); // offer() is generally preferred over add() in queues as it returns false instead of throwing exception on capacity restricted queues
        System.out.println("Package " + id + " added to incoming queue.");
    }

    /**
     * Processes the next package from the incoming queue.
     * Simulates sorting based on user confirmation.
     * Handles empty queue and invalid input during confirmation.
     */
    public void processNextPackage() {
        // Exception handling for empty queue
        try {
            Package packageToProcess = incomingQueue.poll(); // poll() returns null if queue is empty
            if (packageToProcess == null) {
                // Using System.err for an operational error/condition
                System.err.println("Queue is empty: No packages to process.");
                return;
            }

            System.out.println("Processing package: " + packageToProcess);

            // Simulate destination confirmation
            System.out.print("Is this package for a local destination? (yes/no): ");
            String response = scanner.nextLine().trim().toLowerCase();

            if ("yes".equals(response)) {
                localManifest.add(packageToProcess); // Add to local manifest (ArrayList via List interface)
                System.out.println("Package " + packageToProcess.getPackageId() + " sorted into Local Manifest.");
            } else if ("no".equals(response)) {
                interstateManifest.add(packageToProcess); // Add to interstate manifest (ArrayList via List interface)
                System.out.println("Package " + packageToProcess.getPackageId() + " sorted into Interstate Manifest.");
            } else {
                // Using System.err for invalid input during confirmation
                System.err.println("Invalid input: Please answer 'yes' or 'no'. Package was not sorted.");
                // Optionally, you might re-queue the package or handle differently
            }

        } catch (Exception e) {
            // Catch any unexpected exceptions during processing
            System.err.println("An error occurred during package processing: " + e.getMessage());
            e.printStackTrace(); // Print stack trace for debugging unexpected errors
        }
    }

    /**
     * Displays the contents of the incoming queue.
     * Handles empty queue case.
     */
    public void viewIncomingQueue() {
        System.out.println("\n--- Incoming Queue ---");
        if (incomingQueue.isEmpty()) {
            System.out.println("(Empty)");
        } else {
            // Iterate through the queue without removing elements
            for (Package pkg : incomingQueue) {
                System.out.println(pkg);
            }
        }
    }

    /**
     * Displays the contents of the local and interstate manifests.
     * Handles empty manifest cases.
     */
    public void viewManifests() {
        System.out.println("\n--- Local Manifest ---");
        if (localManifest.isEmpty()) {
            System.out.println("(Empty)");
        } else {
            // Iterate through the ArrayLists (via List interface)
            for (Package pkg : localManifest) {
                System.out.println(pkg);
            }
        }

        System.out.println("\n--- Interstate Manifest ---");
        if (interstateManifest.isEmpty()) {
            System.out.println("(Empty)");
        } else {
            // Iterate through the ArrayLists (via List interface)
            for (Package pkg : interstateManifest) {
                System.out.println(pkg);
            }
        }
    }

    /**
     * Runs the main application loop.
     * Handles user input via scanner and switches between menu options.
     * Includes overall try-catch for the main loop.
     */
    public void run() {
        int choice = -1;

        // Overall try-catch for the main application loop
        try {
            while (choice != 5) {
                displayMenu();

                // Exception handling for menu choice input
                try {
                    choice = scanner.nextInt();
                    // Consume the newline character left by nextInt()
                    scanner.nextLine();
                } catch (InputMismatchException e) {
                    System.err.println("Invalid input: Please enter a number between 1 and 5.");
                    scanner.nextLine(); // Consume the invalid input
                    choice = -1; // Reset choice to prevent unintended action
                    continue; // Skip to the next iteration
                }

                // Switch statement for flow control based on user choice
                switch (choice) {
                    case 1:
                        addPackage();
                        break;
                    case 2:
                        processNextPackage();
                        break;
                    case 3:
                        viewIncomingQueue();
                        break;
                    case 4:
                        viewManifests();
                        break;
                    case 5:
                        System.out.println("Exiting Package Processing Center. Goodbye!");
                        break;
                    default:
                        System.err.println("Invalid choice: Please enter a number between 1 and 5.");
                        break;
                }
            }
        } catch (Exception e) {
            // Catch any unexpected exceptions that might occur in the main loop
            System.err.println("An unexpected fatal error occurred: " + e.getMessage());
            e.printStackTrace();
        } finally {
            // Ensure the scanner is closed when the application exits
            if (scanner != null) {
                scanner.close();
            }
        }
    }

    /**
     * Main method to start the application.
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        PackageProcessingCenter center = new PackageProcessingCenter();
        center.run();
    }
}
