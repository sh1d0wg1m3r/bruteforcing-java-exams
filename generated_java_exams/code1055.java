/*
 * Exam Question #1055
 * Generated on: 2025-05-12 17:18:51
 * Generated by: Account 3
 * 
 * QUESTION:
 * **Java Programming Exam Task: Team Task Management System**
 * 
 * You are tasked with developing a simple command-line application for managing tasks for a small team. The system should allow users to add new tasks, process the next pending task, and view completed tasks.
 * 
 * **Requirements:**
 * 
 * 1.  **Task Representation:** Create a simple class `Task` with a `String` field for the task description.
 * 2.  **Task Management Logic:** Implement a class `TeamTaskManager` that manages the tasks.
 *     *   It must maintain a collection of pending tasks using a `Queue`. Tasks should be processed in the order they are added (FIFO).
 *     *   It must maintain a collection of completed tasks using an `ArrayList`.
 *     *   It must expose methods to:
 *         *   Add a new task to the pending queue.
 *         *   Process the next task from the pending queue, moving it to the completed list.
 *         *   Retrieve a list of completed tasks.
 * 3.  **User Interface:** The application should provide a command-line interface using `Scanner`.
 *     *   Present a menu to the user with options:
 *         1.  Add New Task
 *         2.  Process Next Task
 *         3.  View Completed Tasks
 *         4.  Exit
 *     *   Use a `switch` statement to handle the user's menu choice.
 *     *   Prompt the user for necessary input (e.g., task description).
 * 4.  **Output:**
 *     *   Use `System.out` for displaying the menu, prompts, success messages, and the list of completed tasks.
 *     *   Use `System.err` for displaying error messages (e.g., invalid menu choice, trying to process a task when the queue is empty, invalid task description).
 * 5.  **Error Handling:**
 *     *   Implement input validation for menu choices and task descriptions.
 *     *   Use `try-catch` blocks for exception handling. Specifically, wrap the main application loop or critical operational logic within a `try-catch` block to demonstrate class-wide exception handling. Handle potential issues like invalid user input or operational errors gracefully.
 * 6.  **Best Practices:**
 *     *   Apply proper encapsulation (`private` fields, `public` methods).
 *     *   Use meaningful names for variables, methods, and classes.
 *     *   Include appropriate comments and documentation (e.g., Javadoc for classes and methods).
 *     *   Ensure clean code structure.
 *     *   Use the `List` interface when declaring variables or return types where appropriate (e.g., for the completed tasks list).
 * 
 * **Implementation Details:**
 * 
 * *   The main application logic should reside within the `TeamTaskManager` class, perhaps in a `run()` method.
 * *   The `main` method should create an instance of `TeamTaskManager` and start its execution.
 * *   Ensure that attempting to process a task when the queue is empty is handled without crashing, and an appropriate error message is displayed via `System.err`.
 * *   Ensure that adding a task with an empty or null description is validated, and an error message is displayed via `System.err`.
 * 
 * **Expected Output Structure:**
 * 
 * ```
 * --- Team Task Manager Menu ---
 * 1. Add New Task
 * 2. Process Next Task
 * 3. View Completed Tasks
 * 4. Exit
 * Enter your choice: [user input]
 * 
 * [Based on choice, output follows]
 * 
 * // Example Add Task:
 * Enter task description: [user input]
 * Task added successfully.
 * 
 * // Example Process Task (Success):
 * Processing task: [task description]
 * Task completed.
 * 
 * // Example Process Task (Empty Queue):
 * Error: No tasks in the queue to process.
 * 
 * // Example View Completed:
 * --- Completed Tasks ---
 * - [task description 1]
 * - [task description 2]
 * ...
 * -----------------------
 * 
 * // Example Invalid Input:
 * Error: Invalid choice. Please enter a number between 1 and 4.
 * 
 * // Example Invalid Task Description:
 * Error: Task description cannot be empty.
 * 
 * // Example General Error (caught by try-catch):
 * An unexpected error occurred: [error message]
 * 
 * // Example Exit:
 * Exiting Task Manager.
 * ```
 * 
 * Your solution should be a single Java file containing all necessary classes.
 *
 * EXPLANATION:
 * The provided solution implements a simple Team Task Management System demonstrating the required Java concepts.
 * 
 * 1.  **`Task` Class:** A basic POJO (Plain Old Java Object) class representing a task. It has a `private` `description` field, a constructor that validates the description (throws `IllegalArgumentException` if null or empty), and a public getter `getDescription()`. This fulfills the encapsulation requirement.
 * 
 * 2.  **`TeamTaskManager` Class:** This is the core class managing the task flow.
 *     *   **Fields:**
 *         *   `taskQueue`: Declared as `Queue<Task>` and initialized with `new LinkedList<>()`. `LinkedList` implements the `Queue` interface, providing FIFO behavior suitable for a task queue.
 *         *   `completedTasks`: Declared as `List<Task>` and initialized with `new ArrayList<>()`. `ArrayList` provides dynamic resizing and efficient storage for completed tasks, and using the `List` interface demonstrates programming to interfaces.
 *         *   `scanner`: A `Scanner` object for reading user input from the console.
 *     *   **Methods:**
 *         *   `addTask(String description)`: Takes a description, attempts to create a `Task` object. The `Task` constructor handles the validation. If successful, it adds the task to the `taskQueue` using `offer()`. A `try-catch` block is used here to catch the `IllegalArgumentException` thrown by the `Task` constructor if the description is invalid, printing an error to `System.err`.
 *         *   `processNextTask()`: Uses `taskQueue.poll()` to retrieve and remove the head of the queue. `poll()` is safe as it returns `null` if the queue is empty. It checks for `null` and either moves the task to `completedTasks` (using `add()`) and prints a success message to `System.out`, or prints an error to `System.err` if the queue was empty.
 *         *   `viewCompletedTasks()`: Iterates through the `completedTasks` `ArrayList` (using `completedTasks.get(i)`) and prints each task's description to `System.out`. It includes a check for an empty list.
 *         *   `displayMenu()`: A helper method to print the menu options to `System.out`.
 *         *   `getUserChoice()`: A helper method to read integer input for the menu choice. It uses a `while(true)` loop and a `try-catch(InputMismatchException)` to repeatedly prompt the user until a valid integer is entered, consuming the invalid input using `scanner.next()` to prevent an infinite loop.
 *         *   `getUserInput(String prompt)`: A helper method to read a full line of string input (like a task description). It handles consuming any leftover newline characters from previous `nextInt()` calls.
 *         *   `run()`: This method contains the main application loop (`while(true)`). It repeatedly displays the menu, gets the user's choice, validates the choice range, and uses a `switch` statement to call the appropriate task management method (`addTask`, `processNextTask`, `viewCompletedTasks`) or exit.
 *     *   **Class-wide Exception Handling:** The `run()` method is wrapped in a `try-catch(Exception e)` block. This demonstrates class-wide handling of any unexpected runtime exceptions that might occur during the application's main operational loop, printing an error message to `System.err` and the stack trace for debugging. A `finally` block ensures the `Scanner` is closed.
 *     *   **Input Validation & Error Messages:** Input validation for menu choice range and task description is performed. Error messages for invalid input, empty queue, and invalid task description are printed using `System.err`.
 *     *   **Best Practices:** Private fields, public methods, meaningful names (`taskQueue`, `processNextTask`, `completedTasks`), Javadoc comments, and a structured approach with helper methods (`displayMenu`, `getUserChoice`, `getUserInput`) are used. The use of `List` interface for `completedTasks` adheres to the requirement.
 * 
 * 3.  **`main` Method:** The entry point of the application. It simply creates an instance of `TeamTaskManager` and calls its `run()` method to start the interactive loop.
 * 
 * This solution effectively integrates all the required Java components (`Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.err`, `System.out`, `try-catch`) into a practical, albeit simple, application demonstrating core object-oriented principles and error handling techniques.
 */

import java.util.Queue;
import java.util.LinkedList;
import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;
import java.util.InputMismatchException;

/**
 * Represents a simple task with a description.
 */
class Task {
    private String description;

    /**
     * Constructs a new Task.
     * @param description The description of the task. Must not be null or empty.
     */
    public Task(String description) {
        if (description == null || description.trim().isEmpty()) {
            throw new IllegalArgumentException("Task description cannot be empty.");
        }
        this.description = description.trim();
    }

    /**
     * Gets the description of the task.
     * @return The task description.
     */
    public String getDescription() {
        return description;
    }

    @Override
    public String toString() {
        return description;
    }
}

/**
 * Manages a queue of pending tasks and a list of completed tasks.
 * Provides a command-line interface for interaction.
 */
public class TeamTaskManager {

    private Queue<Task> taskQueue;
    private List<Task> completedTasks;
    private Scanner scanner;

    /**
     * Constructs a new TeamTaskManager.
     */
    public TeamTaskManager() {
        this.taskQueue = new LinkedList<>(); // LinkedList implements Queue
        this.completedTasks = new ArrayList<>(); // ArrayList implements List
        this.scanner = new Scanner(System.in);
    }

    /**
     * Adds a new task to the pending queue.
     * Validates that the description is not empty.
     * @param description The description of the task.
     */
    public void addTask(String description) {
        try {
            Task newTask = new Task(description);
            taskQueue.offer(newTask); // offer is preferred over add for queues
            System.out.println("Task added successfully.");
        } catch (IllegalArgumentException e) {
            System.err.println("Error: " + e.getMessage());
        }
    }

    /**
     * Processes the next task from the pending queue, moving it to completed tasks.
     * Handles the case where the queue is empty.
     */
    public void processNextTask() {
        Task nextTask = taskQueue.poll(); // poll returns null if queue is empty
        if (nextTask != null) {
            System.out.println("Processing task: " + nextTask.getDescription());
            completedTasks.add(nextTask);
            System.out.println("Task completed.");
        } else {
            System.err.println("Error: No tasks in the queue to process.");
        }
    }

    /**
     * Displays all completed tasks.
     */
    public void viewCompletedTasks() {
        if (completedTasks.isEmpty()) {
            System.out.println("No tasks have been completed yet.");
            return;
        }
        System.out.println("--- Completed Tasks ---");
        for (int i = 0; i < completedTasks.size(); i++) {
            System.out.println("- " + completedTasks.get(i).getDescription());
        }
        System.out.println("-----------------------");
    }

    /**
     * Displays the main menu options.
     */
    private void displayMenu() {
        System.out.println("\n--- Team Task Manager Menu ---");
        System.out.println("1. Add New Task");
        System.out.println("2. Process Next Task");
        System.out.println("3. View Completed Tasks");
        System.out.println("4. Exit");
        System.out.print("Enter your choice: ");
    }

    /**
     * Gets integer input from the user, handling non-integer input.
     * @return The user's integer choice.
     */
    private int getUserChoice() {
        while (true) {
            try {
                return scanner.nextInt();
            } catch (InputMismatchException e) {
                System.err.println("Error: Invalid input. Please enter a number.");
                scanner.next(); // Consume the invalid input
                System.out.print("Enter your choice: "); // Prompt again
            }
        }
    }

    /**
     * Gets line input from the user.
     * @param prompt The message to display to the user.
     * @return The user's string input.
     */
    private String getUserInput(String prompt) {
        System.out.print(prompt);
        // Consume the newline character left by nextInt()
        if (scanner.hasNextLine()) {
             scanner.nextLine(); // Consume any leftover newline
        }
        return scanner.nextLine();
    }


    /**
     * Runs the main application loop.
     * Includes class-wide exception handling for unexpected errors.
     */
    public void run() {
        int choice;
        // Class-wide exception handling around the main operational loop
        try {
            while (true) {
                displayMenu();
                choice = getUserChoice();

                // Input validation for menu choice range
                if (choice < 1 || choice > 4) {
                    System.err.println("Error: Invalid choice. Please enter a number between 1 and 4.");
                    continue; // Go back to displaying menu
                }

                // Use switch statement for flow control
                switch (choice) {
                    case 1:
                        String description = getUserInput("Enter task description: ");
                        addTask(description);
                        break;
                    case 2:
                        processNextTask();
                        break;
                    case 3:
                        viewCompletedTasks();
                        break;
                    case 4:
                        System.out.println("Exiting Task Manager.");
                        scanner.close();
                        return; // Exit the run method and application
                }
            }
        } catch (Exception e) {
            // Catch any unexpected exceptions during the main loop execution
            System.err.println("An unexpected error occurred: " + e.getMessage());
            e.printStackTrace(); // Print stack trace for debugging
        } finally {
            // Ensure scanner is closed even if an exception occurs
            if (scanner != null) {
                 scanner.close();
            }
        }
    }

    /**
     * Main method to start the application.
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        TeamTaskManager manager = new TeamTaskManager();
        manager.run();
    }
}
