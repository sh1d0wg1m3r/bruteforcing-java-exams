/*
 * Exam Question #726
 * Generated on: 2025-05-12 16:31:35
 * Generated by: Account 3
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Event Check-in System with Priority Queue
 * 
 * **Problem Description:**
 * 
 * You are tasked with developing a simplified event management system focusing on attendee check-in. The system needs to manage registered attendees, handle their arrival at the event, and process check-ins based on priority (VIP attendees are checked in before standard attendees).
 * 
 * Your program should simulate the following workflow:
 * 1.  **Registration:** Attendees are registered with a unique ID, name, and VIP status.
 * 2.  **Arrival:** When an attendee arrives at the event, they join a waiting queue. VIP attendees join a separate VIP queue, while standard attendees join a standard queue.
 * 3.  **Check-in:** A check-in operator processes attendees from the queues. VIP attendees are always processed first. If the VIP queue is empty, the operator processes the next standard attendee.
 * 4.  **Status Reporting:** The system should be able to report the current status, including the number of registered, VIP queue, standard queue, and checked-in attendees.
 * 
 * **Technical Requirements:**
 * 
 * Your Java solution must adhere to the following:
 * 
 * 1.  Use a `java.util.Queue` implementation (like `LinkedList`) to manage the waiting lines for VIP and standard attendees.
 * 2.  Use a `java.util.ArrayList` to store the list of all registered attendees.
 * 3.  Use the `java.util.List` interface type for declarations or method signatures where appropriate (e.g., for the list of registered attendees).
 * 4.  Use `java.util.Scanner` to read user commands and input from the console.
 * 5.  Use a `switch` statement to handle different user commands (e.g., register, arrive, check-in, status, exit).
 * 6.  Use `System.err` to print error messages (e.g., invalid input, attendee not found).
 * 7.  Use `System.out` to print normal output (e.g., success messages, status reports, prompts).
 * 8.  Implement class-wide exception handling using `try-catch` blocks, specifically wrapping the main program loop to catch unexpected runtime errors.
 * 9.  Implement proper encapsulation for class fields.
 * 10. Use meaningful names for variables, methods, and classes.
 * 11. Include appropriate comments and documentation (e.g., Javadoc for classes/methods).
 * 12. Implement basic input validation (e.g., checking if an attendee ID exists).
 * 
 * **User Interaction:**
 * 
 * The program should present a menu of options to the user:
 * *   `register <id> <name> <isVip>`: Registers a new attendee. `<isVip>` should be "yes" or "no".
 * *   `arrive <id>`: Marks an attendee as arrived and adds them to the appropriate queue.
 * *   `checkin`: Processes the next attendee from the queues (VIP first, then standard).
 * *   `status`: Displays the current counts of attendees in each state.
 * *   `exit`: Terminates the program.
 * 
 * **Example Interaction Flow:**
 * 
 * ```
 * Event Check-in System
 * Enter command (register, arrive, checkin, status, exit):
 * register 101 Alice Standard no
 * Attendee 101 (Alice Standard) registered.
 * Enter command (register, arrive, checkin, status, exit):
 * register 102 Bob VIP yes
 * Attendee 102 (Bob VIP) registered.
 * Enter command (register, arrive, checkin, status, exit):
 * register 103 Charlie User no
 * Attendee 103 (Charlie User) registered.
 * Enter command (register, arrive, checkin, status, exit):
 * status
 * --- System Status ---
 * Registered: 3
 * VIP Queue: 0
 * Standard Queue: 0
 * Checked In: 0
 * ---------------------
 * Enter command (register, arrive, checkin, status, exit):
 * arrive 101
 * Attendee 101 (Alice Standard) arrived and joined standard queue.
 * Enter command (register, arrive, checkin, status, exit):
 * arrive 102
 * Attendee 102 (Bob VIP) arrived and joined VIP queue.
 * Enter command (register, arrive, checkin, status, exit):
 * arrive 103
 * Attendee 103 (Charlie User) arrived and joined standard queue.
 * Enter command (register, arrive, checkin, status, exit):
 * status
 * --- System Status ---
 * Registered: 3
 * VIP Queue: 1
 * Standard Queue: 2
 * Checked In: 0
 * ---------------------
 * Enter command (register, arrive, checkin, status, exit):
 * checkin
 * Checked in attendee 102 (Bob VIP).
 * Enter command (register, arrive, checkin, status, exit):
 * checkin
 * Checked in attendee 101 (Alice Standard).
 * Enter command (register, arrive, checkin, status, exit):
 * status
 * --- System Status ---
 * Registered: 3
 * VIP Queue: 0
 * Standard Queue: 1
 * Checked In: 2
 * ---------------------
 * Enter command (register, arrive, checkin, status, exit):
 * checkin
 * Checked in attendee 103 (Charlie User).
 * Enter command (register, arrive, checkin, status, exit):
 * checkin
 * No attendees waiting to check in.
 * Enter command (register, arrive, checkin, status, exit):
 * exit
 * Exiting system.
 * ```
 * 
 * **Evaluation:**
 * 
 * Your solution will be evaluated on:
 * *   Correctness of implementation based on requirements.
 * *   Effective use of all specified Java components.
 * *   Adherence to best practices (encapsulation, naming, comments, error handling).
 * *   Handling of edge cases (e.g., checking in when queues are empty, arriving an unregistered attendee).
 * *   Code clarity and structure.
 * 
 * ```java
 * // Your code goes here
 * ```
 *
 * EXPLANATION:
 * The provided solution implements a simplified event check-in system, demonstrating the required Java concepts and best practices.
 * 
 * 1.  **`Attendee` Class:** This class is a simple Plain Old Java Object (POJO) representing an attendee. It encapsulates the attendee's `id`, `name`, and `isVip` status using private fields and public getters, adhering to encapsulation principles. The `toString()` method provides a convenient representation for printing.
 * 
 * 2.  **`EventManager` Class:** This is the main class containing the system's logic.
 *     *   **Data Structures:**
 *         *   `registeredAttendees`: Declared as `List<Attendee>` and initialized as `new ArrayList<>()`. This list holds all attendees ever registered, acting as a master list for lookups. Using the `List` interface demonstrates programming to the interface, allowing for potential future changes in the underlying implementation without affecting code that uses the `List` type. `ArrayList` is suitable here for efficient storage and lookup (though lookup is currently linear, it's simple for this scale).
 *         *   `vipQueue` and `standardQueue`: Declared as `Queue<Attendee>` and initialized as `new LinkedList<>()`. `Queue` is the appropriate interface for managing waiting lines (FIFO - First-In, First-Out). `LinkedList` is a common implementation of `Queue` that provides efficient additions to the end and removals from the beginning. Two separate queues are used to easily implement the priority logic (always check the `vipQueue` first).
 *         *   `checkedInAttendees`: Declared as `List<Attendee>` and initialized as `new ArrayList<>()`. This list stores attendees who have successfully gone through the check-in process. `ArrayList` is suitable here as the order of check-in might be relevant, and adding to the end is efficient.
 *     *   **`Scanner`:** An instance of `Scanner` is used to read command-line input from `System.in`.
 *     *   **`registerAttendee` Method:** Handles adding new attendees. It includes basic validation to prevent duplicate IDs and ensure the VIP status input is valid ("yes" or "no"). Error messages are printed to `System.err`. Success messages are printed to `System.out`.
 *     *   **`attendeeArrived` Method:** Finds the attendee by ID in the `registeredAttendees` list. If found, it adds them to the appropriate queue (`vipQueue` or `standardQueue`) using the `offer()` method (which is generally preferred over `add()` for queues as it handles capacity constraints gracefully, though `LinkedList` is unbounded). Error messages for unregistered attendees are printed to `System.err`.
 *     *   **`checkInNextAttendee` Method:** Implements the core priority logic. It first checks if the `vipQueue` is empty. If not, it uses `poll()` to retrieve and remove the next VIP attendee. If the `vipQueue` is empty, it then checks the `standardQueue` and polls from there if not empty. The checked-in attendee is moved to the `checkedInAttendees` list. Messages are printed to `System.out`, including a message when both queues are empty.
 *     *   **`viewStatus` Method:** Prints the current size of each collection/queue to `System.out`, providing a system overview.
 *     *   **`findAttendeeById` Method:** A private helper method used internally to search the `registeredAttendees` list.
 *     *   **`runSystem` Method:** This method contains the main application loop.
 *         *   It reads user input line by line using the `Scanner`.
 *         *   Input is split into command parts.
 *         *   A `switch` statement is used to process the command string, directing execution to the appropriate method (`registerAttendee`, `attendeeArrived`, etc.). This fulfills the requirement for using a `switch` statement for flow control.
 *         *   Basic validation for the number of command arguments is included, printing usage errors to `System.err`.
 *         *   **Class-wide Exception Handling:** The entire `while` loop is wrapped in a `try-catch(Exception e)` block. This demonstrates catching any unexpected runtime exception that might occur within the command processing loop, preventing the program from crashing abruptly. An error message is printed to `System.err`, and the stack trace is printed for debugging. A `finally` block ensures the `Scanner` is closed when the loop terminates or an exception occurs.
 *     *   **`main` Method:** The entry point of the application, which simply creates an `EventManager` instance and calls its `runSystem` method.
 * 
 * The solution effectively uses all specified components in a practical scenario, follows best practices for encapsulation, naming, and error handling, and structures the code logically into classes and methods.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;

/**
 * Represents an attendee at an event.
 */
class Attendee {
    private String id;
    private String name;
    private boolean isVip;

    /**
     * Constructs a new Attendee.
     *
     * @param id The unique ID of the attendee.
     * @param name The name of the attendee.
     * @param isVip True if the attendee is VIP, false otherwise.
     */
    public Attendee(String id, String name, boolean isVip) {
        this.id = id;
        this.name = name;
        this.isVip = isVip;
    }

    // Getters for attendee properties
    public String getId() {
        return id;
    }

    public String getName() {
        return name;
    }

    public boolean isVip() {
        return isVip;
    }

    /**
     * Provides a string representation of the attendee.
     * @return String representing the attendee.
     */
    @Override
    public String toString() {
        return id + " (" + name + (isVip ? " VIP" : "") + ")";
    }
}

/**
 * Manages event attendees, registration, arrival, and check-in processes.
 */
public class EventManager {

    // Using List interface for flexibility, implemented by ArrayList
    private List<Attendee> registeredAttendees;
    // Using Queue interface for FIFO behavior, implemented by LinkedList
    private Queue<Attendee> vipQueue;
    private Queue<Attendee> standardQueue;
    // Using List interface for flexibility, implemented by ArrayList
    private List<Attendee> checkedInAttendees;

    private Scanner scanner;

    /**
     * Constructs a new EventManager, initializing data structures.
     */
    public EventManager() {
        registeredAttendees = new ArrayList<>(); // Stores all registered attendees
        vipQueue = new LinkedList<>(); // VIP attendees waiting for check-in
        standardQueue = new LinkedList<>(); // Standard attendees waiting for check-in
        checkedInAttendees = new ArrayList<>(); // Attendees who have been checked in
        scanner = new Scanner(System.in);
    }

    /**
     * Registers a new attendee in the system.
     * Performs basic validation for ID uniqueness and VIP status format.
     *
     * @param id The unique ID for the attendee.
     * @param name The name of the attendee.
     * @param isVipString "yes" or "no" indicating VIP status.
     */
    public void registerAttendee(String id, String name, String isVipString) {
        if (id == null || id.trim().isEmpty() || name == null || name.trim().isEmpty()) {
            System.err.println("Error: ID and Name cannot be empty.");
            return;
        }
        if (findAttendeeById(id) != null) {
            System.err.println("Error: Attendee with ID " + id + " already registered.");
            return;
        }

        boolean isVip;
        if ("yes".equalsIgnoreCase(isVipString)) {
            isVip = true;
        } else if ("no".equalsIgnoreCase(isVipString)) {
            isVip = false;
        } else {
            System.err.println("Error: Invalid VIP status. Use 'yes' or 'no'.");
            return;
        }

        Attendee newAttendee = new Attendee(id, name.trim(), isVip);
        registeredAttendees.add(newAttendee);
        System.out.println("Attendee " + newAttendee + " registered.");
    }

    /**
     * Marks an attendee as arrived and adds them to the appropriate queue.
     *
     * @param id The ID of the arriving attendee.
     */
    public void attendeeArrived(String id) {
        Attendee attendee = findAttendeeById(id);

        if (attendee == null) {
            System.err.println("Error: Attendee with ID " + id + " not registered.");
            return;
        }

        // Basic check to prevent adding same attendee multiple times (could be enhanced)
        if (vipQueue.contains(attendee) || standardQueue.contains(attendee) || checkedInAttendees.contains(attendee)) {
             System.err.println("Error: Attendee with ID " + id + " has already arrived or been checked in.");
             return;
        }


        if (attendee.isVip()) {
            vipQueue.offer(attendee); // offer is preferred over add in queues
            System.out.println("Attendee " + attendee + " arrived and joined VIP queue.");
        } else {
            standardQueue.offer(attendee); // offer is preferred over add in queues
            System.out.println("Attendee " + attendee + " arrived and joined standard queue.");
        }
    }

    /**
     * Checks in the next attendee based on priority (VIP first).
     */
    public void checkInNextAttendee() {
        Attendee attendeeToCheckIn = null;

        if (!vipQueue.isEmpty()) {
            attendeeToCheckIn = vipQueue.poll(); // Retrieves and removes the head
        } else if (!standardQueue.isEmpty()) {
            attendeeToCheckIn = standardQueue.poll(); // Retrieves and removes the head
        }

        if (attendeeToCheckIn != null) {
            checkedInAttendees.add(attendeeToCheckIn);
            System.out.println("Checked in attendee " + attendeeToCheckIn + ".");
        } else {
            System.out.println("No attendees waiting to check in.");
        }
    }

    /**
     * Displays the current status of attendees in different states.
     */
    public void viewStatus() {
        System.out.println("--- System Status ---");
        System.out.println("Registered: " + registeredAttendees.size());
        System.out.println("VIP Queue: " + vipQueue.size());
        System.out.println("Standard Queue: " + standardQueue.size());
        System.out.println("Checked In: " + checkedInAttendees.size());
        System.out.println("---------------------");
    }

    /**
     * Finds a registered attendee by their ID.
     *
     * @param id The ID to search for.
     * @return The Attendee object if found, null otherwise.
     */
    private Attendee findAttendeeById(String id) {
        for (Attendee attendee : registeredAttendees) {
            if (attendee.getId().equals(id)) {
                return attendee;
            }
        }
        return null;
    }

    /**
     * Runs the main command processing loop of the system.
     * Includes class-wide exception handling.
     */
    public void runSystem() {
        System.out.println("Event Check-in System");
        boolean running = true;

        // Class-wide exception handling for the main operational loop
        try {
            while (running) {
                System.out.println("Enter command (register, arrive, checkin, status, exit):");
                String inputLine = scanner.nextLine();
                String[] parts = inputLine.trim().split("\\s+", 4); // Split by whitespace, limit to 4 parts for register command

                if (parts.length == 0 || parts[0].isEmpty()) {
                    continue; // Ignore empty input
                }

                String command = parts[0].toLowerCase();

                switch (command) {
                    case "register":
                        if (parts.length == 4) {
                            String id = parts[1];
                            String name = parts[2];
                            String isVipString = parts[3];
                            registerAttendee(id, name, isVipString);
                        } else {
                            System.err.println("Usage: register <id> <name> <isVip (yes/no)>");
                        }
                        break;
                    case "arrive":
                        if (parts.length == 2) {
                            String id = parts[1];
                            attendeeArrived(id);
                        } else {
                            System.err.println("Usage: arrive <id>");
                        }
                        break;
                    case "checkin":
                        if (parts.length == 1) {
                            checkInNextAttendee();
                        } else {
                            System.err.println("Usage: checkin");
                        }
                        break;
                    case "status":
                        if (parts.length == 1) {
                            viewStatus();
                        } else {
                             System.err.println("Usage: status");
                        }
                        break;
                    case "exit":
                        if (parts.length == 1) {
                            running = false;
                            System.out.println("Exiting system.");
                        } else {
                             System.err.println("Usage: exit");
                        }
                        break;
                    default:
                        System.err.println("Unknown command: " + command);
                        System.err.println("Available commands: register, arrive, checkin, status, exit");
                }
            }
        } catch (Exception e) {
            // Catch any unexpected runtime exceptions during the loop
            System.err.println("An unexpected error occurred: " + e.getMessage());
            e.printStackTrace(); // Print stack trace for debugging
        } finally {
            // Ensure the scanner is closed
            if (scanner != null) {
                scanner.close();
            }
        }
    }

    /**
     * Main method to start the EventManager application.
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        EventManager manager = new EventManager();
        manager.runSystem();
    }
}
