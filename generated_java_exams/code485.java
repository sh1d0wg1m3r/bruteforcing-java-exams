/*
 * Exam Question #485
 * Generated on: 2025-05-11 23:18:05
 * Generated by: Account 2
 * 
 * QUESTION:
 * **Java Programming Exam: Manufacturing Task Processor Simulation**
 * 
 * **Problem Description:**
 * 
 * You are tasked with creating a simplified simulation of a manufacturing assembly line's task processing system. The system manages tasks that need to be processed by a single "worker". Tasks arrive and are placed in a queue awaiting processing. The worker processes tasks one by one from the front of the queue. During processing, a task might either succeed or fail. The system needs to keep track of tasks that are pending, successfully completed, and those that failed processing.
 * 
 * Your program must provide a command-line interface allowing a user to:
 * 1.  Add a new task to the pending queue.
 * 2.  Process the next task from the pending queue.
 * 3.  View all pending tasks.
 * 4.  View all successfully completed tasks.
 * 5.  View all failed tasks.
 * 6.  Exit the application.
 * 
 * **Technical Requirements:**
 * 
 * Your solution must adhere to the following technical specifications:
 * 
 * 1.  **Task Representation:** Create a class named `Task` to represent a manufacturing task. It should have private fields for `taskId` (an integer, auto-incremented or user-provided), `description` (String), and `priority` (an integer between 1 and 5, 5 being highest priority). Include a constructor and appropriate public getter methods. Implement a `toString()` method for easy printing.
 * 2.  **Task Processor System:** Create a class named `TaskProcessor` that manages the task workflow.
 *     *   It must use a `java.util.Queue` (e.g., `java.util.LinkedList`) to hold pending tasks.
 *     *   It must use `java.util.ArrayList` objects, declared using the `java.util.List` interface, to store completed tasks and failed tasks.
 *     *   All data structure fields within `TaskProcessor` must be private.
 *     *   Include public methods for adding tasks, processing the next task, and viewing the different task lists.
 * 3.  **User Interface:**
 *     *   Use `java.util.Scanner` to read user commands and task details from the console.
 *     *   Implement a main loop that presents a menu of options to the user.
 *     *   Use a `switch` statement to handle the different user commands.
 *     *   Print normal output (menu, task lists, success messages) using `System.out`.
 *     *   Print error messages (e.g., invalid input, queue empty, processing failure) using `System.err`.
 * 4.  **Error Handling:**
 *     *   Implement input validation (e.g., ensure priority is within the valid range, handle non-integer input where integers are expected).
 *     *   Use `try-catch` blocks to handle potential exceptions, particularly around Scanner input and task processing logic. The main user interaction loop (`run` method in `TaskProcessor` or similar) should have a class-wide `try-catch` to gracefully handle unexpected errors and prevent the program from crashing abruptly.
 *     *   Handle the case where the user tries to process a task when the queue is empty.
 * 5.  **Processing Logic:** When processing a task, simulate a potential failure. For example, tasks with higher priority might have a lower chance of failure, or you could use a random number generator. If a task fails, move it to the failed list; otherwise, move it to the completed list.
 * 6.  **Best Practices:**
 *     *   Use meaningful variable and method names.
 *     *   Include comments to explain complex parts of the code.
 *     *   Ensure proper encapsulation.
 * 
 * **Expected Output:**
 * 
 * The program should continuously display a menu and process user commands until the user chooses to exit. Output should clearly distinguish between normal information (`System.out`) and errors (`System.err`). Listing tasks should show relevant details (ID, description, priority).
 * 
 * **Example Interaction Flow:**
 * 
 * ```
 * --- Task Processor Menu ---
 * 1. Add New Task
 * 2. Process Next Task
 * 3. View Pending Tasks
 * 4. View Completed Tasks
 * 5. View Failed Tasks
 * 6. Exit
 * Enter your choice: 1
 * Enter Task ID: 101
 * Enter Task Description: Calibrate Sensor
 * Enter Task Priority (1-5): 4
 * Task 101 added to pending queue.
 * 
 * --- Task Processor Menu ---
 * ...
 * Enter your choice: 1
 * Enter Task ID: 102
 * Enter Task Description: Inspect Widget
 * Enter Task Priority (1-5): 3
 * Task 102 added to pending queue.
 * 
 * --- Task Processor Menu ---
 * ...
 * Enter your choice: 3
 * --- Pending Tasks ---
 * Task ID: 101, Description: Calibrate Sensor, Priority: 4
 * Task ID: 102, Description: Inspect Widget, Priority: 3
 * 
 * --- Task Processor Menu ---
 * ...
 * Enter your choice: 2
 * Processing task: Task ID: 101, Description: Calibrate Sensor, Priority: 4
 * Task 101 completed successfully.
 * 
 * --- Task Processor Menu ---
 * ...
 * Enter your choice: 2
 * Processing task: Task ID: 102, Description: Inspect Widget, Priority: 3
 * Error processing task 102: Simulated failure during inspection.
 * Task 102 moved to failed tasks.
 * 
 * --- Task Processor Menu ---
 * ...
 * Enter your choice: 4
 * --- Completed Tasks ---
 * Task ID: 101, Description: Calibrate Sensor, Priority: 4
 * 
 * --- Task Processor Menu ---
 * ...
 * Enter your choice: 5
 * --- Failed Tasks ---
 * Task ID: 102, Description: Inspect Widget, Priority: 3
 * 
 * --- Task Processor Menu ---
 * ...
 * Enter your choice: 6
 * Exiting Task Processor.
 * ```
 * 
 * Your solution must provide the complete Java code for this system.
 *
 * EXPLANATION:
 * This solution implements a `TaskProcessor` system that simulates a manufacturing task workflow, fulfilling all the requirements of the exam question.
 * 
 * 1.  **Task Class:** The `Task` class is a simple Plain Old Java Object (POJO) representing a task with `taskId`, `description`, and `priority`. It uses private fields and public getters, demonstrating encapsulation. The constructor includes basic validation for the priority range and throws an `IllegalArgumentException` if the input is invalid. The `toString()` method provides a convenient way to print task details.
 * 
 * 2.  **TaskProcessor Class:** This class manages the core logic and data structures:
 *     *   `private Queue<Task> pendingTasks = new LinkedList<>();`: A `Queue` is used for `pendingTasks` because tasks are processed in First-In, First-Out (FIFO) order, which is typical for a processing queue or assembly line. `LinkedList` is a common implementation of the `Queue` interface.
 *     *   `private List<Task> completedTasks = new ArrayList<>();`: A `List` is used for `completedTasks` to maintain a history of successful tasks. `ArrayList` is chosen for its common use and efficient element access/addition. It's declared using the `List` interface, demonstrating polymorphism and good practice.
 *     *   `private List<Task> failedTasks = new ArrayList<>();`: Similarly, a `List` (implemented by `ArrayList`) stores tasks that failed processing.
 *     *   `addTask(Task task)`: Uses `queue.offer()` to add a task to the end of the pending queue. `offer()` is generally preferred over `add()` for queues as it returns `false` if the element cannot be added (though for `LinkedList`, it behaves like `add()`).
 *     *   `processNextTask()`: Uses `queue.poll()` to retrieve and remove the task at the head of the queue. It checks if the result is `null` to handle the case of an empty queue. It then simulates success or failure based on a random number and the task's priority, moving the task to the appropriate list (`completedTasks` or `failedTasks`).
 *     *   `view...Tasks()`: These methods iterate through the respective data structures and print the details of each task using the `Task` class's `toString()` method.
 * 
 * 3.  **User Interface and Flow Control:**
 *     *   `Scanner scanner = new Scanner(System.in);`: A `Scanner` is used to read input from the standard input stream (`System.in`).
 *     *   `run()` method: Contains the main application loop (`while(running)`).
 *     *   `printMenu()`: A helper method to display the user options.
 *     *   `switch (choice)`: A `switch` statement is used inside the loop to direct execution based on the user's integer input, handling each menu option. The `default` case handles invalid numerical inputs.
 * 
 * 4.  **Error Handling:**
 *     *   **Input Validation:** `NumberFormatException` is caught when parsing integer inputs (`taskId`, `priority`, `choice`) using `Integer.parseInt()`. `IllegalArgumentException` is caught when creating a `Task` with an invalid priority. Error messages for invalid input are printed to `System.err`.
 *     *   **Processing Empty Queue:** `processNextTask()` explicitly checks if `pendingTasks.poll()` returns `null` and prints an error message to `System.err` if the queue is empty.
 *     *   **Class-wide `try-catch`:** The entire `while` loop in the `run()` method is wrapped in a `try-catch(Exception e)` block. This serves as a top-level safety net, catching any unexpected exceptions that might occur within the application's main execution flow, preventing the program from crashing abruptly. An error message is printed to `System.err`, and the stack trace is included for debugging purposes (`e.printStackTrace()`).
 *     *   **Resource Management:** The `finally` block ensures the `Scanner` is closed when the `run` method finishes (either normally or due to an unhandled exception caught by the outer `try-catch`).
 * 
 * 5.  **Best Practices:**
 *     *   Meaningful names (`pendingTasks`, `processNextTask`, `failureChance`, etc.) are used.
 *     *   Comments explain the purpose of classes, methods, and key logic sections.
 *     *   Encapsulation is maintained with private fields and public methods.
 *     *   The code is structured into logical classes (`Task`, `TaskProcessor`).
 * 
 * This solution effectively demonstrates the required Java components (`Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.err`, `System.out`, `try-catch`) within a practical, simulated scenario, while adhering to best practices for robustness and maintainability.
 */

import java.util.Queue;
import java.util.LinkedList;
import java.util.List;
import java.util.ArrayList;
import java.util.Scanner;
import java.util.Random;

// Represents a manufacturing task
class Task {
    private int taskId;
    private String description;
    private int priority; // 1-5, 5 is highest

    public Task(int taskId, String description, int priority) {
        if (priority < 1 || priority > 5) {
            throw new IllegalArgumentException("Priority must be between 1 and 5.");
        }
        this.taskId = taskId;
        this.description = description;
        this.priority = priority;
    }

    // Getters
    public int getTaskId() {
        return taskId;
    }

    public String getDescription() {
        return description;
    }

    public int getPriority() {
        return priority;
    }

    @Override
    public String toString() {
        return "Task ID: " + taskId + ", Description: " + description + ", Priority: " + priority;
    }
}

// Manages the task processing workflow
public class TaskProcessor {
    // Use Queue for pending tasks (FIFO)
    private Queue<Task> pendingTasks;
    // Use List (implemented by ArrayList) for completed tasks
    private List<Task> completedTasks;
    // Use List (implemented by ArrayList) for failed tasks
    private List<Task> failedTasks;

    private Scanner scanner;
    private Random random; // For simulating processing failure

    public TaskProcessor() {
        // Initialize data structures
        pendingTasks = new LinkedList<>(); // LinkedList implements Queue
        completedTasks = new ArrayList<>();
        failedTasks = new ArrayList<>();
        scanner = new Scanner(System.in);
        random = new Random();
    }

    // Add a new task to the pending queue
    public void addTask(Task task) {
        pendingTasks.offer(task); // offer is preferred over add for queues
        System.out.println("Task " + task.getTaskId() + " added to pending queue.");
    }

    // Process the next task from the pending queue
    public void processNextTask() {
        Task taskToProcess = pendingTasks.poll(); // poll retrieves and removes head

        if (taskToProcess == null) {
            System.err.println("No tasks in the pending queue to process.");
            return;
        }

        System.out.println("Processing task: " + taskToProcess);

        // Simulate processing with a chance of failure
        // Higher priority tasks have lower failure chance (e.g., 5: 10% fail, 1: 50% fail)
        int failureChance = (6 - taskToProcess.getPriority()) * 10; // 10% to 50% chance

        if (random.nextInt(100) < failureChance) {
            // Simulate failure
            System.err.println("Error processing task " + taskToProcess.getTaskId() + ": Simulated failure.");
            failedTasks.add(taskToProcess);
            System.out.println("Task " + taskToProcess.getTaskId() + " moved to failed tasks.");
        } else {
            // Simulate success
            System.out.println("Task " + taskToProcess.getTaskId() + " completed successfully.");
            completedTasks.add(taskToProcess);
        }
    }

    // View all tasks currently in the pending queue
    public void viewPendingTasks() {
        System.out.println("--- Pending Tasks ---");
        if (pendingTasks.isEmpty()) {
            System.out.println("No pending tasks.");
        } else {
            // Iterate through the queue without removing elements
            for (Task task : pendingTasks) {
                System.out.println(task);
            }
        }
    }

    // View all successfully completed tasks
    public void viewCompletedTasks() {
        System.out.println("--- Completed Tasks ---");
        if (completedTasks.isEmpty()) {
            System.out.println("No completed tasks.");
        } else {
            for (Task task : completedTasks) {
                System.out.println(task);
            }
        }
    }

    // View all failed tasks
    public void viewFailedTasks() {
        System.out.println("--- Failed Tasks ---");
        if (failedTasks.isEmpty()) {
            System.out.println("No failed tasks.");
        } else {
            for (Task task : failedTasks) {
                System.out.println(task);
            }
        }
    }

    // Displays the menu and handles user input
    public void run() {
        boolean running = true;

        // Class-wide exception handling for the main loop
        try {
            while (running) {
                printMenu();
                System.out.print("Enter your choice: ");

                int choice = -1;
                try {
                    choice = Integer.parseInt(scanner.nextLine());
                } catch (NumberFormatException e) {
                    System.err.println("Invalid input. Please enter a number.");
                    continue; // Skip to next iteration
                }

                // Use switch for flow control
                switch (choice) {
                    case 1: // Add New Task
                        try {
                            System.out.print("Enter Task ID: ");
                            int taskId = Integer.parseInt(scanner.nextLine());
                            System.out.print("Enter Task Description: ");
                            String description = scanner.nextLine();
                            System.out.print("Enter Task Priority (1-5): ");
                            int priority = Integer.parseInt(scanner.nextLine());

                            Task newTask = new Task(taskId, description, priority);
                            addTask(newTask);
                        } catch (NumberFormatException e) {
                            System.err.println("Invalid input. Please enter valid numbers for ID and Priority.");
                        } catch (IllegalArgumentException e) {
                            System.err.println("Error creating task: " + e.getMessage());
                        } catch (Exception e) {
                            // Catch any other unexpected errors during task creation
                             System.err.println("An unexpected error occurred while adding task: " + e.getMessage());
                        }
                        break;

                    case 2: // Process Next Task
                        processNextTask();
                        break;

                    case 3: // View Pending Tasks
                        viewPendingTasks();
                        break;

                    case 4: // View Completed Tasks
                        viewCompletedTasks();
                        break;

                    case 5: // View Failed Tasks
                        viewFailedTasks();
                        break;

                    case 6: // Exit
                        running = false;
                        System.out.println("Exiting Task Processor.");
                        break;

                    default: // Invalid choice
                        System.err.println("Invalid choice. Please enter a number between 1 and 6.");
                }
                System.out.println(); // Add a newline for better readability
            }
        } catch (Exception e) {
             // This catches any unexpected exception not handled by inner try-catch blocks
             System.err.println("An unrecoverable error occurred: " + e.getMessage());
             e.printStackTrace(); // Print stack trace for debugging
        } finally {
            // Close the scanner when the application exits or an unrecoverable error occurs
            if (scanner != null) {
                scanner.close();
            }
        }
    }

    // Prints the main menu options
    private void printMenu() {
        System.out.println("--- Task Processor Menu ---");
        System.out.println("1. Add New Task");
        System.out.println("2. Process Next Task");
        System.out.println("3. View Pending Tasks");
        System.out.println("4. View Completed Tasks");
        System.out.println("5. View Failed Tasks");
        System.out.println("6. Exit");
    }

    // Main method to start the application
    public static void main(String[] args) {
        TaskProcessor processor = new TaskProcessor();
        processor.run();
    }
}
