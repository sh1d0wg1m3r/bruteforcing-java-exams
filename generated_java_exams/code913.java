/*
 * Exam Question #913
 * Generated on: 2025-05-12 16:58:44
 * Generated by: Account 4
 * 
 * QUESTION:
 * **Advanced Java Programming Exam: Task Prioritization and Management System**
 * 
 * **Problem Description:**
 * 
 * You are tasked with building a simple command-line application for managing tasks within a small project team. The system should allow users to add new tasks, execute the next pending task, view pending tasks, and view completed tasks. Tasks have a description and a priority level. The system should process tasks based on their arrival order (First-In, First-Out) among pending tasks.
 * 
 * **Requirements:**
 * 
 * 1.  **Task Representation:** Create a `Task` class to represent a single task. It should have private fields for a unique `taskId` (an integer, automatically generated), a `description` (String), and a `priority` (an integer, e.g., 1 for High, 2 for Medium, 3 for Low). Include a constructor and appropriate getter methods. Override the `toString()` method for easy printing.
 * 2.  **Task Management System:** Create a `TaskManagementSystem` class.
 *     *   It must use a `java.util.Queue` to store tasks that are pending execution.
 *     *   It must use a `java.util.List` (specifically backed by a `java.util.ArrayList`) to store tasks that have been completed.
 *     *   Implement methods:
 *         *   `addTask(String description, int priority)`: Creates a new `Task` object and adds it to the pending task queue. Assign a unique ID (a simple counter starting from 1 is sufficient).
 *         *   `executeNextTask()`: Removes the next task from the head of the pending queue and adds it to the completed tasks list. This method should handle the case where the pending queue is empty.
 *         *   `viewPendingTasks()`: Prints all tasks currently in the pending queue.
 *         *   `viewCompletedTasks()`: Prints all tasks currently in the completed tasks list.
 *     *   Implement a main operational loop within a method (e.g., `run()`) that interacts with the user via the console.
 * 3.  **User Interface:**
 *     *   Use `java.util.Scanner` to get user input.
 *     *   Present a menu of options to the user:
 *         1.  Add New Task
 *         2.  Execute Next Task
 *         3.  View Pending Tasks
 *         4.  View Completed Tasks
 *         5.  Exit
 *     *   Use a `switch` statement to handle the user's choice.
 * 4.  **Input Validation & Error Handling:**
 *     *   Validate user input for menu choices and task priority. Priority should be a valid integer within a specified range (e.g., 1 to 3).
 *     *   Use `System.err` to print error messages for invalid input or when an operation cannot be performed (e.g., trying to execute a task when the queue is empty).
 *     *   Use `System.out` for all normal output, including the menu, task details, and success messages.
 *     *   Implement class-wide exception handling using `try-catch` blocks around the main operational loop to catch unexpected errors during runtime.
 * 5.  **Best Practices:**
 *     *   Apply proper encapsulation (private fields, public methods).
 *     *   Use meaningful variable and method names.
 *     *   Include appropriate comments and documentation (e.g., Javadoc).
 *     *   Ensure the code structure is clean and readable.
 * 
 * **Expected Output Behavior:**
 * 
 * *   The system should continuously display the menu until the user chooses to exit.
 * *   Adding a task should prompt for description and priority, then confirm addition.
 * *   Executing a task should remove the oldest pending task, print its details, and move it to completed. If the queue is empty, it should print an error message to `System.err`.
 * *   Viewing pending/completed tasks should print the details of all tasks in the respective list/queue, clearly indicating which list is being displayed. If a list is empty, it should indicate that.
 * *   Invalid menu choices or task priorities should result in an error message printed to `System.err`, and the menu should be displayed again.
 * *   Any unexpected runtime exceptions caught by the top-level `try-catch` should print a generic error message to `System.err`.
 * 
 * **Constraints:**
 * 
 * *   You must use `java.util.Queue`, `java.util.ArrayList`, `java.util.List`, `java.util.Scanner`, `switch`, `System.err`, `System.out`, and `try-catch` as specified.
 * *   The solution should be contained within a few classes (`Task`, `TaskManagementSystem`, and potentially a main class to start the system).
 *
 * EXPLANATION:
 * The provided solution implements a simple command-line Task Management System demonstrating the required Java concepts and best practices.
 * 
 * 1.  **Task Class:**
 *     *   The `Task` class is a simple Plain Old Java Object (POJO) representing a task.
 *     *   It uses `private` fields (`taskId`, `description`, `priority`) to enforce encapsulation.
 *     *   Public getter methods are provided to access the private fields.
 *     *   The `toString()` method is overridden to provide a convenient string representation for printing task details.
 *     *   A simple counter (`nextTaskId`) in the `TaskManagementSystem` ensures unique IDs for tasks.
 * 
 * 2.  **TaskManagementSystem Class:**
 *     *   This is the core class managing the tasks.
 *     *   `private Queue<Task> pendingTasks;`: Declared as the `Queue` interface, and initialized with a `LinkedList`. `LinkedList` is chosen because it efficiently implements the `Queue` interface (FIFO behavior) and is suitable for this use case.
 *     *   `private List<Task> completedTasks;`: Declared as the `List` interface, and initialized with an `ArrayList`. `ArrayList` is used to store completed tasks, allowing easy iteration and dynamic resizing.
 *     *   `addTask(String description, int priority)`: Creates a `Task` object and uses `pendingTasks.offer(newTask)` to add it to the end of the queue. `offer()` is generally preferred over `add()` for queues as it handles capacity-constrained queues more gracefully (though `LinkedList` is not capacity-constrained).
 *     *   `executeNextTask()`: Uses `pendingTasks.poll()` to retrieve and remove the task at the head of the queue. `poll()` returns `null` if the queue is empty, which is checked to provide an appropriate error message using `System.err`. If a task is retrieved, it's added to the `completedTasks` `ArrayList` using `completedTasks.add()`.
 *     *   `viewPendingTasks()` and `viewCompletedTasks()`: Iterate through the respective collections (Queue and List) and print task details using `System.out`. They check if the collections are empty and print a message accordingly. Note that iterating a `Queue` typically doesn't remove elements unless using methods like `poll()` or `remove()`.
 *     *   `run()`: Contains the main application loop.
 * 
 * 3.  **User Interface and Control Flow:**
 *     *   A `Scanner` is used to read input from `System.in`.
 *     *   A `while` loop keeps the application running until the user chooses to exit.
 *     *   A `printMenu()` method displays the options using `System.out`.
 *     *   A `switch` statement is used to direct the program flow based on the user's integer choice. Each `case` corresponds to a menu option, calling the appropriate method (`addTask`, `executeNextTask`, etc.).
 *     *   The `default` case of the `switch` handles invalid menu choices, printing an error to `System.err`.
 * 
 * 4.  **Input Validation and Error Handling:**
 *     *   Input validation is performed for the menu choice (checking if it's an integer and within range 1-5) and task priority (checking if it's an integer and within range 1-3).
 *     *   `InputMismatchException` is caught when `scanner.nextInt()` is used, handling non-integer input. `scanner.next()` or `scanner.nextLine()` is used in the `catch` or `finally` block to consume the invalid input and prevent an infinite loop.
 *     *   `System.err.println()` is used specifically for printing error messages related to invalid input or operational errors (like an empty queue).
 *     *   `System.out.println()` is used for all normal program output (menu, prompts, success messages, task listings).
 *     *   A `try-catch (Exception e)` block wraps the main `while` loop in the `run()` method. This provides a class-wide exception handling mechanism, catching any unexpected runtime exceptions that might occur during the program's execution and printing a generic error message to `System.err`. The `finally` block ensures the `Scanner` is closed when the loop terminates or an exception occurs.
 * 
 * 5.  **Best Practices:**
 *     *   Encapsulation is used in the `Task` class.
 *     *   Meaningful names like `pendingTasks`, `completedTasks`, `executeNextTask`, `viewPendingTasks` are used.
 *     *   Basic Javadoc and inline comments explain the purpose of classes, methods, and key code sections.
 *     *   The code is structured into logical methods within the `TaskManagementSystem` class, keeping the `run()` method relatively clean by delegating specific tasks to other methods.
 * 
 * This solution effectively integrates all required components into a functional, albeit simple, system that demonstrates core Java concepts including data structures, object-oriented programming, user input handling, control flow, and robust error management.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.InputMismatchException;

/**
 * Represents a single task with a unique ID, description, and priority.
 */
class Task {
    private int taskId;
    private String description;
    private int priority; // 1=High, 2=Medium, 3=Low

    /**
     * Constructs a new Task.
     * @param taskId The unique identifier for the task.
     * @param description A brief description of the task.
     * @param priority The priority level (1-3).
     */
    public Task(int taskId, String description, int priority) {
        this.taskId = taskId;
        this.description = description;
        this.priority = priority;
    }

    // Getters
    public int getTaskId() {
        return taskId;
    }

    public String getDescription() {
        return description;
    }

    public int getPriority() {
        return priority;
    }

    /**
     * Returns a string representation of the Task.
     */
    @Override
    public String toString() {
        return String.format("Task ID: %d, Description: '%s', Priority: %d",
                             taskId, description, priority);
    }
}

/**
 * Manages a collection of pending and completed tasks.
 * Uses a Queue for pending tasks and a List for completed tasks.
 */
public class TaskManagementSystem {

    private Queue<Task> pendingTasks;
    private List<Task> completedTasks;
    private int nextTaskId; // Counter for generating unique task IDs

    /**
     * Constructs a new TaskManagementSystem.
     * Initializes the pending and completed task collections.
     */
    public TaskManagementSystem() {
        this.pendingTasks = new LinkedList<>(); // LinkedList implements Queue
        this.completedTasks = new ArrayList<>(); // ArrayList implements List
        this.nextTaskId = 1;
    }

    /**
     * Adds a new task to the pending queue.
     * @param description The description of the task.
     * @param priority The priority of the task (1-3).
     */
    public void addTask(String description, int priority) {
        Task newTask = new Task(nextTaskId++, description, priority);
        pendingTasks.offer(newTask); // offer is preferred over add for queues
        System.out.println("Task added: " + newTask);
    }

    /**
     * Executes the next task from the pending queue.
     * Moves the executed task to the completed list.
     * Handles the case where the pending queue is empty.
     */
    public void executeNextTask() {
        Task taskToExecute = pendingTasks.poll(); // poll returns null if queue is empty
        if (taskToExecute != null) {
            completedTasks.add(taskToExecute);
            System.out.println("Task executed: " + taskToExecute);
        } else {
            System.err.println("Error: No pending tasks to execute.");
        }
    }

    /**
     * Prints all tasks currently in the pending queue.
     */
    public void viewPendingTasks() {
        System.out.println("\n--- Pending Tasks ---");
        if (pendingTasks.isEmpty()) {
            System.out.println("No tasks pending.");
        } else {
            // Iterate without removing elements
            for (Task task : pendingTasks) {
                System.out.println(task);
            }
        }
        System.out.println("---------------------\n");
    }

    /**
     * Prints all tasks currently in the completed list.
     */
    public void viewCompletedTasks() {
        System.out.println("\n--- Completed Tasks ---");
        if (completedTasks.isEmpty()) {
            System.out.println("No tasks completed yet.");
        } else {
            for (Task task : completedTasks) {
                System.out.println(task);
            }
        }
        System.out.println("-----------------------\n");
    }

    /**
     * Runs the main operational loop for the Task Management System,
     * handling user interaction.
     */
    public void run() {
        Scanner scanner = new Scanner(System.in);
        boolean running = true;

        // Class-wide exception handling for the main loop
        try {
            while (running) {
                printMenu();
                System.out.print("Enter your choice: ");

                int choice = -1;
                try {
                    choice = scanner.nextInt();
                } catch (InputMismatchException e) {
                    System.err.println("Error: Invalid input. Please enter a number.");
                    scanner.next(); // Consume the invalid input
                    continue; // Skip to the next iteration
                } finally {
                     scanner.nextLine(); // Consume the newline character left by nextInt()
                }


                switch (choice) {
                    case 1: // Add New Task
                        System.out.print("Enter task description: ");
                        String description = scanner.nextLine();

                        int priority = -1;
                        boolean validPriority = false;
                        while (!validPriority) {
                            System.out.print("Enter task priority (1=High, 2=Medium, 3=Low): ");
                            try {
                                priority = scanner.nextInt();
                                if (priority >= 1 && priority <= 3) {
                                    validPriority = true;
                                } else {
                                    System.err.println("Error: Priority must be between 1 and 3.");
                                }
                            } catch (InputMismatchException e) {
                                System.err.println("Error: Invalid input. Please enter a number for priority.");
                                scanner.next(); // Consume the invalid input
                            } finally {
                                scanner.nextLine(); // Consume the newline
                            }
                        }
                        addTask(description, priority);
                        break;

                    case 2: // Execute Next Task
                        executeNextTask();
                        break;

                    case 3: // View Pending Tasks
                        viewPendingTasks();
                        break;

                    case 4: // View Completed Tasks
                        viewCompletedTasks();
                        break;

                    case 5: // Exit
                        System.out.println("Exiting Task Management System. Goodbye!");
                        running = false;
                        break;

                    default:
                        System.err.println("Error: Invalid choice. Please enter a number between 1 and 5.");
                        break;
                }
            }
        } catch (Exception e) {
            // Catch any unexpected exceptions during the main operational loop
            System.err.println("An unexpected error occurred: " + e.getMessage());
            // e.printStackTrace(); // Uncomment for detailed debugging
        } finally {
            // Ensure the scanner is closed
            scanner.close();
            System.out.println("Scanner closed.");
        }
    }

    /**
     * Prints the main menu options to the console.
     */
    private void printMenu() {
        System.out.println("\n--- Task Management Menu ---");
        System.out.println("1. Add New Task");
        System.out.println("2. Execute Next Task");
        System.out.println("3. View Pending Tasks");
        System.out.println("4. View Completed Tasks");
        System.out.println("5. Exit");
        System.out.println("----------------------------");
    }

    /**
     * Main method to start the Task Management System.
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        TaskManagementSystem system = new TaskManagementSystem();
        system.run();
    }
}
