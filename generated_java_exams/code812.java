/*
 * Exam Question #812
 * Generated on: 2025-05-12 16:44:55
 * Generated by: Account 4
 * 
 * QUESTION:
 * ## Advanced Java Programming Exam: Event Session Management System
 * 
 * **Problem Description:**
 * 
 * You are tasked with developing a simplified Event Session Management system. The system should allow managing a set of sessions for an event and attendees who wish to book slots in these sessions. Sessions have a limited capacity. If a session is full, attendees can join a waiting list for that specific session.
 * 
 * Your system must be interactive, driven by a command-line menu.
 * 
 * **Requirements:**
 * 
 * 1.  **Data Structures:**
 *     *   Maintain a collection of `Session` objects.
 *     *   Maintain a collection of `Attendee` objects.
 *     *   Each `Session` must manage its booked attendees and a waiting list of attendees.
 *     *   Each `Attendee` must track the sessions they are booked into.
 * 
 * 2.  **Core Functionality (Menu Options):**
 *     *   **Add New Session:** Prompt for session name and capacity. Create and add a `Session` object. Assign a unique ID.
 *     *   **Add New Attentee:** Prompt for attendee name. Create and add an `Attendee` object. Assign a unique ID.
 *     *   **List All Sessions:** Display details for all sessions (ID, Name, Capacity, Booked Count, Available Slots, Waiting List Size).
 *     *   **List All Attendees:** Display details for all attendees (ID, Name).
 *     *   **Book Attendee to Session:** Prompt for Attendee ID and Session ID.
 *         *   Validate IDs.
 *         *   If the session has available slots, book the attendee into the session and add the session to the attendee's booked list.
 *         *   If the session is full, add the attendee to the session's waiting list (Queue) and notify the user.
 *         *   An attendee cannot be booked into the same session twice (either booked or on the waiting list).
 *     *   **List Attendee Bookings:** Prompt for Attendee ID. Display the list of sessions the attendee is booked into.
 *     *   **List Session Waiting List:** Prompt for Session ID. Display the names of attendees currently on the waiting list for that session, in the order they joined.
 *     *   **Process Session Waiting List:** Prompt for Session ID.
 *         *   Check if the session has available slots.
 *         *   If yes, move attendees from the session's waiting list (Queue) to the booked list one by one until the session is full or the waiting list is empty. Notify the user which attendees were successfully booked.
 *     *   **Exit:** Terminate the program.
 * 
 * 3.  **Technical Constraints:**
 *     *   You **MUST** use `java.util.Queue` for the waiting list within each `Session` object.
 *     *   You **MUST** use `java.util.ArrayList` to store the main collections of `Session` and `Attendee` objects in the management system.
 *     *   You **MUST** use `java.util.List` as the type for collections where appropriate (e.g., `List<Session>` or `List<Attendee>`), demonstrating the use of the interface.
 *     *   You **MUST** use `java.util.Scanner` to get user input from the console.
 *     *   You **MUST** use a `switch` statement to handle the main menu options.
 *     *   You **MUST** use `System.err` to output error messages (e.g., invalid input, item not found, operation failed).
 *     *   You **MUST** use `System.out` for all normal output (menu, prompts, success messages, lists).
 *     *   You **MUST** implement class-wide exception handling using `try-catch` blocks, particularly for handling input parsing errors (`NumberFormatException`).
 * 
 * 4.  **Best Practices:**
 *     *   Implement proper encapsulation (private fields, public methods).
 *     *   Use meaningful variable and method names.
 *     *   Include appropriate comments and documentation (basic Javadoc is sufficient).
 *     *   Implement input validation (e.g., non-empty strings, positive numbers for capacity/IDs, checking if IDs exist).
 *     *   Implement proper error handling as described above.
 *     *   Structure your code into appropriate classes (`Session`, `Attendee`, `EventManager`).
 * 
 * **Expected Output:**
 * 
 * The program should present a menu, accept user input, perform the requested action, and display results or error messages accordingly. Error messages should go to `System.err`. Normal output should go to `System.out`.
 * 
 * Example interaction:
 * 
 * ```
 * --- Event Session Management ---
 * 1. Add New Session
 * 2. Add New Attendee
 * 3. List All Sessions
 * 4. List All Attendees
 * 5. Book Attendee to Session
 * 6. List Attendee Bookings
 * 7. List Session Waiting List
 * 8. Process Session Waiting List
 * 9. Exit
 * Enter choice: 1
 * Enter session name: Java Basics
 * Enter session capacity: 2
 * Session 'Java Basics' (ID: 1) created with capacity 2.
 * --- Event Session Management ---
 * ...
 * Enter choice: 2
 * Enter attendee name: Alice
 * Attendee 'Alice' (ID: 1) registered.
 * ...
 * Enter choice: 2
 * Enter attendee name: Bob
 * Attendee 'Bob' (ID: 2) registered.
 * ...
 * Enter choice: 2
 * Enter attendee name: Charlie
 * Attendee 'Charlie' (ID: 3) registered.
 * ...
 * Enter choice: 5
 * Enter Attendee ID: 1
 * Enter Session ID: 1
 * Attendee 'Alice' (ID: 1) successfully booked into session 'Java Basics' (ID: 1).
 * ...
 * Enter choice: 5
 * Enter Attendee ID: 2
 * Enter Session ID: 1
 * Attendee 'Bob' (ID: 2) successfully booked into session 'Java Basics' (ID: 1).
 * ...
 * Enter choice: 5
 * Enter Attendee ID: 3
 * Enter Session ID: 1
 * Session 'Java Basics' (ID: 1) is full. Attendee 'Charlie' (ID: 3) added to the waiting list.
 * ...
 * Enter choice: 7
 * Enter Session ID: 1
 * Waiting list for session 'Java Basics' (ID: 1):
 * - Charlie (ID: 3)
 * ...
 * Enter choice: 8
 * Enter Session ID: 1
 * No available slots in session 'Java Basics' (ID: 1). Waiting list processing skipped.
 * ...
 * Enter choice: 5
 * Enter Attendee ID: 1
 * Enter Session ID: 1
 * Error: Attendee 'Alice' (ID: 1) is already booked or on the waiting list for session 'Java Basics' (ID: 1).
 * ...
 * (Imagine Bob cancels, freeing a spot - not required functionality for this exam, but for context)
 * ...
 * Enter choice: 8
 * Enter Session ID: 1
 * Processing waiting list for session 'Java Basics' (ID: 1)...
 * Successfully booked 'Charlie' (ID: 3) from waiting list into session 'Java Basics' (ID: 1).
 * Waiting list processing complete.
 * ...
 * Enter choice: 7
 * Enter Session ID: 1
 * Waiting list for session 'Java Basics' (ID: 1) is empty.
 * ...
 * Enter choice: 9
 * Exiting system.
 * ```
 * 
 * **Grading:**
 * 
 * Your solution will be evaluated based on:
 * *   Correct implementation of all required functionality.
 * *   Proper use of ALL specified Java components (`Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.err`, `System.out`, `try-catch`).
 * *   Adherence to best practices (encapsulation, naming, comments, validation, error handling).
 * *   Code clarity and structure.
 * 
 * Good luck!
 *
 * EXPLANATION:
 * This solution implements the Event Session Management system using the required Java components and best practices.
 * 
 * **Core Structure:**
 * 
 * *   **`Attendee` Class:** Represents an attendee with an ID, name, and a `List` of `Session`s they are booked into. Includes methods to add/remove sessions and standard getters. `equals` and `hashCode` are overridden based on ID to ensure correct behavior when using `List.contains()` or `List.remove()`.
 * *   **`Session` Class:** Represents a session with an ID, name, capacity, a `List` of booked `Attendee`s, and a `Queue` for attendees on the waiting list. It includes methods to check capacity, book attendees (handling the waiting list logic), and process the waiting list. `equals` and `hashCode` are overridden based on ID.
 *     *   The `bookedAttendees` uses `List` (implemented by `ArrayList`) for ordered storage of booked individuals.
 *     *   The `waitingList` uses `Queue` (implemented by `LinkedList`) to maintain the First-In, First-Out order required for a waiting list.
 * *   **`EventManager` Class:** Acts as the main controller. It holds the primary collections (`List<Session>` and `List<Attendee>`, implemented as `ArrayList`) and contains the application logic, including the main menu loop, user input handling, and interactions between `Attendee` and `Session` objects.
 * 
 * **Required Component Usage:**
 * 
 * 1.  **`java.util.Queue`:** Used in the `Session` class (`waitingList`) to store attendees waiting for a slot. `LinkedList` is used as the concrete implementation of the `Queue` interface. The `add()` method is used to add to the waiting list, and `poll()` is used in `processWaitingList()` to retrieve and remove attendees from the front of the queue.
 * 2.  **`java.util.ArrayList`:** Used in the `EventManager` class to store the main lists of `sessions` and `attendees`. Also used within the `Attendee` class (`bookedSessions`) and `Session` class (`bookedAttendees`). `ArrayList` provides dynamic resizing and ordered storage suitable for these collections.
 * 3.  **`java.util.List` interface:** Used as the declared type for `sessions` and `attendees` in `EventManager`, and for `bookedSessions` in `Attendee`, and `bookedAttendees` in `Session`. This demonstrates coding to the interface rather than the concrete implementation (`ArrayList`), which is a key object-oriented principle.
 * 4.  **`java.util.Scanner`:** An instance is created in `EventManager` to read user input from `System.in`. `nextLine()` is used for reading entire lines, which is generally safer than `next()` or `nextInt()` when mixing string and number inputs.
 * 5.  **`switch` statement:** Used in the `EventManager.run()` method to dispatch the user's menu choice to the corresponding private helper method (e.g., `addSession()`, `listSessions()`).
 * 6.  **`System.err`:** Used throughout the `EventManager` class to print error messages, such as invalid menu choices, incorrect input formats, items not found, or failed operations (like trying to book an attendee already on the list). This separates error output from standard application output.
 * 7.  **`System.out`:** Used for displaying the menu, prompts for input, success messages, and listing the details of sessions, attendees, and bookings.
 * 8.  **Class-wide exception handling (`try-catch`):**
 *     *   A `try-catch (NumberFormatException)` block is used around `Integer.parseInt()` calls when reading numeric input (menu choice, IDs, capacity) to handle cases where the user enters non-numeric text.
 *     *   A general `try-catch (Exception e)` block is included in the `run()` method's main loop to catch any unexpected runtime errors that might occur during an operation, preventing the program from crashing abruptly.
 * 
 * **Best Practices:**
 * 
 * *   **Encapsulation:** Fields in `Attendee` and `Session` classes are `private`. Public getter methods are provided where necessary. Logic that modifies internal state (like booking or adding to waiting list) is contained within the class methods (`bookAttendee`, `processWaitingList`).
 * *   **Meaningful Names:** Classes, methods, and variables have descriptive names (e.g., `bookAttendeeToSession`, `waitingList`, `getAvailableSlots`, `findAttendeeById`).
 * *   **Comments and Documentation:** Basic Javadoc-style comments are included for classes and key methods explaining their purpose. Inline comments explain specific logic where needed.
 * *   **Input Validation:**
 *     *   Checks are performed for empty strings for names.
 *     *   `try-catch` handles `NumberFormatException` for numeric inputs.
 *     *   Checks are made to ensure entered IDs for sessions and attendees actually exist before attempting operations on them.
 *     *   Capacity input is validated to be a positive number.
 *     *   The `bookAttendee` method checks if the attendee is already booked or on the waiting list before attempting to add them.
 * *   **Error Handling:** Errors are caught (either via `try-catch` or explicit `if` checks) and reported to the user using `System.err` with informative messages.
 * *   **Clean Code Structure:** The logic is separated into distinct classes (`Attendee`, `Session`, `EventManager`). The `EventManager` uses private helper methods for each menu option, keeping the `run()` method clean and focused on the main loop and `switch`.
 * 
 * This solution effectively integrates the required components into a practical scenario, demonstrating advanced Java concepts like object-oriented design, data structure usage, exception handling, and input/output management.
 */

import java.util.ArrayList;
import java.util.LinkedList; // LinkedList implements Queue
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.Iterator; // Needed to safely remove while iterating if needed, though not strictly required by prompt

/**
 * Represents an Attendee in the event.
 */
class Attendee {
    private static int nextId = 1; // For generating unique IDs

    private int id;
    private String name;
    private List<Session> bookedSessions;

    /**
     * Constructs a new Attendee.
     * @param name The name of the attendee.
     */
    public Attendee(String name) {
        this.id = nextId++;
        this.name = name;
        this.bookedSessions = new ArrayList<>();
    }

    public int getId() {
        return id;
    }

    public String getName() {
        return name;
    }

    public List<Session> getBookedSessions() {
        return bookedSessions;
    }

    /**
     * Adds a session to the attendee's booked list.
     * @param session The session to add.
     */
    public void addBookedSession(Session session) {
        if (!this.bookedSessions.contains(session)) {
            this.bookedSessions.add(session);
        }
    }

    /**
     * Removes a session from the attendee's booked list.
     * @param session The session to remove.
     */
    public void removeBookedSession(Session session) {
        this.bookedSessions.remove(session);
    }

    @Override
    public String toString() {
        return "Attendee [ID=" + id + ", Name=" + name + "]";
    }

    // Needed for List.contains() and List.remove() to work correctly based on ID
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Attendee attendee = (Attendee) o;
        return id == attendee.id;
    }

    @Override
    public int hashCode() {
        return id;
    }
}

/**
 * Represents a Session in the event.
 */
class Session {
    private static int nextId = 1; // For generating unique IDs

    private int id;
    private String name;
    private int capacity;
    private List<Attendee> bookedAttendees; // List of attendees booked
    private Queue<Attendee> waitingList;   // Queue of attendees waiting

    /**
     * Constructs a new Session.
     * @param name The name of the session.
     * @param capacity The maximum number of attendees.
     */
    public Session(String name, int capacity) {
        this.id = nextId++;
        this.name = name;
        this.capacity = capacity;
        this.bookedAttendees = new ArrayList<>();
        this.waitingList = new LinkedList<>(); // LinkedList implements Queue
    }

    public int getId() {
        return id;
    }

    public String getName() {
        return name;
    }

    public int getCapacity() {
        return capacity;
    }

    public List<Attendee> getBookedAttendees() {
        return bookedAttendees;
    }

    public Queue<Attendee> getWaitingList() {
        return waitingList;
    }

    /**
     * Checks if the session is currently full.
     * @return true if the number of booked attendees meets or exceeds capacity, false otherwise.
     */
    public boolean isFull() {
        return bookedAttendees.size() >= capacity;
    }

    /**
     * Gets the number of available slots in the session.
     * @return The number of slots remaining.
     */
    public int getAvailableSlots() {
        return capacity - bookedAttendees.size();
    }

    /**
     * Attempts to book an attendee into the session.
     * If full, adds to waiting list.
     * @param attendee The attendee to book.
     * @return 0 if booked successfully, 1 if added to waiting list, -1 if already booked or on waiting list.
     */
    public int bookAttendee(Attendee attendee) {
        // Check if already booked or on waiting list
        if (bookedAttendees.contains(attendee) || waitingList.contains(attendee)) {
            return -1; // Already exists
        }

        if (!isFull()) {
            bookedAttendees.add(attendee);
            attendee.addBookedSession(this);
            return 0; // Booked successfully
        } else {
            waitingList.add(attendee);
            return 1; // Added to waiting list
        }
    }

    /**
     * Attempts to process the waiting list, booking attendees if slots are available.
     * @return The number of attendees successfully booked from the waiting list.
     */
    public int processWaitingList() {
        int bookedCount = 0;
        // Poll from queue and book until full or queue empty
        while (!isFull() && !waitingList.isEmpty()) {
            Attendee waitingAttendee = waitingList.poll(); // Get and remove head of queue
            if (waitingAttendee != null) { // Should not be null if queue is not empty
                 // Need to ensure attendee is not already booked/waiting via other means
                 // (Though our logic should prevent this, defensive check)
                 if (!bookedAttendees.contains(waitingAttendee)) {
                     bookedAttendees.add(waitingAttendee);
                     waitingAttendee.addBookedSession(this);
                     bookedCount++;
                 } else {
                     // This case indicates an issue or concurrent modification,
                     // but given the single-threaded nature of the prompt, less likely.
                     // Re-add to queue or log error depending on desired behavior.
                     // For this problem, we'll just skip and effectively remove from queue.
                 }
            }
        }
        return bookedCount;
    }

    @Override
    public String toString() {
        return "Session [ID=" + id + ", Name=" + name + ", Capacity=" + capacity +
               ", Booked=" + bookedAttendees.size() + ", Available=" + getAvailableSlots() +
               ", Waiting=" + waitingList.size() + "]";
    }

     // Needed for List.contains() and List.remove() to work correctly based on ID
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Session session = (Session) o;
        return id == session.id;
    }

    @Override
    public int hashCode() {
        return id;
    }
}

/**
 * Manages the overall event sessions and attendees.
 */
public class EventManager {

    private List<Session> sessions; // Use List interface, implementation is ArrayList
    private List<Attendee> attendees; // Use List interface, implementation is ArrayList
    private Scanner scanner;

    /**
     * Constructs a new EventManager.
     */
    public EventManager() {
        this.sessions = new ArrayList<>();
        this.attendees = new ArrayList<>();
        this.scanner = new Scanner(System.in);
    }

    /**
     * Finds a session by its ID.
     * @param id The ID of the session to find.
     * @return The Session object if found, null otherwise.
     */
    private Session findSessionById(int id) {
        for (Session session : sessions) {
            if (session.getId() == id) {
                return session;
            }
        }
        return null;
    }

    /**
     * Finds an attendee by their ID.
     * @param id The ID of the attendee to find.
     * @return The Attendee object if found, null otherwise.
     */
    private Attendee findAttendeeById(int id) {
        for (Attendee attendee : attendees) {
            if (attendee.getId() == id) {
                return attendee;
            }
        }
        return null;
    }

    /**
     * Adds a new session based on user input.
     */
    private void addSession() {
        System.out.print("Enter session name: ");
        String name = scanner.nextLine().trim();
        if (name.isEmpty()) {
            System.err.println("Error: Session name cannot be empty.");
            return;
        }

        System.out.print("Enter session capacity: ");
        int capacity = -1;
        try {
            capacity = Integer.parseInt(scanner.nextLine().trim());
            if (capacity <= 0) {
                System.err.println("Error: Session capacity must be a positive number.");
                return;
            }
        } catch (NumberFormatException e) {
            System.err.println("Error: Invalid input for capacity. Please enter a number.");
            return;
        }

        Session newSession = new Session(name, capacity);
        sessions.add(newSession);
        System.out.println("Session '" + newSession.getName() + "' (ID: " + newSession.getId() + ") created with capacity " + newSession.getCapacity() + ".");
    }

    /**
     * Adds a new attendee based on user input.
     */
    private void addAttendee() {
        System.out.print("Enter attendee name: ");
        String name = scanner.nextLine().trim();
         if (name.isEmpty()) {
            System.err.println("Error: Attendee name cannot be empty.");
            return;
        }

        Attendee newAttendee = new Attendee(name);
        attendees.add(newAttendee);
        System.out.println("Attendee '" + newAttendee.getName() + "' (ID: " + newAttendee.getId() + ") registered.");
    }

    /**
     * Lists all registered sessions.
     */
    private void listSessions() {
        if (sessions.isEmpty()) {
            System.out.println("No sessions registered yet.");
            return;
        }
        System.out.println("--- All Sessions ---");
        for (Session session : sessions) {
            System.out.println(session);
        }
        System.out.println("--------------------");
    }

    /**
     * Lists all registered attendees.
     */
    private void listAttendees() {
        if (attendees.isEmpty()) {
            System.out.println("No attendees registered yet.");
            return;
        }
        System.out.println("--- All Attendees ---");
        for (Attendee attendee : attendees) {
            System.out.println(attendee);
        }
        System.out.println("---------------------");
    }

    /**
     * Books an attendee into a session based on user input IDs.
     */
    private void bookAttendeeToSession() {
        System.out.print("Enter Attendee ID: ");
        int attendeeId = -1;
        try {
            attendeeId = Integer.parseInt(scanner.nextLine().trim());
        } catch (NumberFormatException e) {
            System.err.println("Error: Invalid input for Attendee ID. Please enter a number.");
            return;
        }

        System.out.print("Enter Session ID: ");
        int sessionId = -1;
         try {
            sessionId = Integer.parseInt(scanner.nextLine().trim());
        } catch (NumberFormatException e) {
            System.err.println("Error: Invalid input for Session ID. Please enter a number.");
            return;
        }

        Attendee attendee = findAttendeeById(attendeeId);
        Session session = findSessionById(sessionId);

        if (attendee == null) {
            System.err.println("Error: Attendee with ID " + attendeeId + " not found.");
            return;
        }
        if (session == null) {
            System.err.println("Error: Session with ID " + sessionId + " not found.");
            return;
        }

        int result = session.bookAttendee(attendee);

        if (result == 0) {
            System.out.println("Attendee '" + attendee.getName() + "' (ID: " + attendee.getId() + ") successfully booked into session '" + session.getName() + "' (ID: " + session.getId() + ").");
        } else if (result == 1) {
            System.out.println("Session '" + session.getName() + "' (ID: " + session.getId() + ") is full. Attendee '" + attendee.getName() + "' (ID: " + attendee.getId() + ") added to the waiting list.");
        } else if (result == -1) {
             System.err.println("Error: Attendee '" + attendee.getName() + "' (ID: " + attendee.getId() + ") is already booked or on the waiting list for session '" + session.getName() + "' (ID: " + session.getId() + ").");
        }
    }

    /**
     * Lists sessions an attendee is booked into based on user input ID.
     */
    private void listAttendeeBookings() {
        System.out.print("Enter Attendee ID: ");
        int attendeeId = -1;
        try {
            attendeeId = Integer.parseInt(scanner.nextLine().trim());
        } catch (NumberFormatException e) {
            System.err.println("Error: Invalid input for Attendee ID. Please enter a number.");
            return;
        }

        Attendee attendee = findAttendeeById(attendeeId);

        if (attendee == null) {
            System.err.println("Error: Attendee with ID " + attendeeId + " not found.");
            return;
        }

        List<Session> bookings = attendee.getBookedSessions();
        if (bookings.isEmpty()) {
            System.out.println("Attendee '" + attendee.getName() + "' (ID: " + attendee.getId() + ") has no booked sessions.");
        } else {
            System.out.println("Bookings for Attendee '" + attendee.getName() + "' (ID: " + attendee.getId() + "):");
            for (Session session : bookings) {
                System.out.println("- " + session.getName() + " (ID: " + session.getId() + ")");
            }
        }
    }

    /**
     * Lists attendees on a session's waiting list based on user input ID.
     */
    private void listSessionWaitingList() {
        System.out.print("Enter Session ID: ");
        int sessionId = -1;
         try {
            sessionId = Integer.parseInt(scanner.nextLine().trim());
        } catch (NumberFormatException e) {
            System.err.println("Error: Invalid input for Session ID. Please enter a number.");
            return;
        }

        Session session = findSessionById(sessionId);

        if (session == null) {
            System.err.println("Error: Session with ID " + sessionId + " not found.");
            return;
        }

        Queue<Attendee> waitingList = session.getWaitingList();
        if (waitingList.isEmpty()) {
            System.out.println("Waiting list for session '" + session.getName() + "' (ID: " + session.getId() + ") is empty.");
        } else {
            System.out.println("Waiting list for session '" + session.getName() + "' (ID: " + session.getId() + "):");
            // Iterate through the queue without removing elements
            for (Attendee attendee : waitingList) {
                 System.out.println("- " + attendee.getName() + " (ID: " + attendee.getId() + ")");
            }
        }
    }

    /**
     * Processes the waiting list for a session based on user input ID.
     */
    private void processSessionWaitingList() {
         System.out.print("Enter Session ID: ");
        int sessionId = -1;
         try {
            sessionId = Integer.parseInt(scanner.nextLine().trim());
        } catch (NumberFormatException e) {
            System.err.println("Error: Invalid input for Session ID. Please enter a number.");
            return;
        }

        Session session = findSessionById(sessionId);

        if (session == null) {
            System.err.println("Error: Session with ID " + sessionId + " not found.");
            return;
        }

        if (session.getAvailableSlots() <= 0) {
             System.out.println("No available slots in session '" + session.getName() + "' (ID: " + session.getId() + "). Waiting list processing skipped.");
             return;
        }

        if (session.getWaitingList().isEmpty()) {
             System.out.println("Waiting list for session '" + session.getName() + "' (ID: " + session.getId() + ") is empty. Nothing to process.");
             return;
        }

        System.out.println("Processing waiting list for session '" + session.getName() + "' (ID: " + session.getId() + ")...");
        int bookedCount = session.processWaitingList();

        if (bookedCount > 0) {
            System.out.println("Successfully booked " + bookedCount + " attendee(s) from the waiting list.");
        } else {
             // This case should ideally not happen if getAvailableSlots() > 0 and waitingList is not empty
             // but included for completeness or if processWaitingList had complex internal logic.
             System.out.println("No attendees were booked from the waiting list.");
        }
         System.out.println("Waiting list processing complete.");
    }


    /**
     * Displays the main menu.
     */
    private void displayMenu() {
        System.out.println("\n--- Event Session Management ---");
        System.out.println("1. Add New Session");
        System.out.println("2. Add New Attendee");
        System.out.println("3. List All Sessions");
        System.out.println("4. List All Attendees");
        System.out.println("5. Book Attendee to Session");
        System.out.println("6. List Attendee Bookings");
        System.out.println("7. List Session Waiting List");
        System.out.println("8. Process Session Waiting List");
        System.out.println("9. Exit");
        System.out.print("Enter choice: ");
    }

    /**
     * Runs the main event management application loop.
     */
    public void run() {
        boolean running = true;
        while (running) {
            displayMenu();
            String input = scanner.nextLine().trim();

            // Use try-catch for potential NumberFormatException if input is not an integer
            try {
                int choice = Integer.parseInt(input);

                // Use switch statement for menu options
                switch (choice) {
                    case 1:
                        addSession();
                        break;
                    case 2:
                        addAttendee();
                        break;
                    case 3:
                        listSessions();
                        break;
                    case 4:
                        listAttendees();
                        break;
                    case 5:
                        bookAttendeeToSession();
                        break;
                    case 6:
                        listAttendeeBookings();
                        break;
                    case 7:
                        listSessionWaitingList();
                        break;
                    case 8:
                        processSessionWaitingList();
                        break;
                    case 9:
                        System.out.println("Exiting system.");
                        running = false;
                        break;
                    default:
                        // Invalid choice handled by default case
                        System.err.println("Error: Invalid choice. Please enter a number between 1 and 9.");
                }
            } catch (NumberFormatException e) {
                // Catch non-integer input for the main menu choice
                System.err.println("Error: Invalid input. Please enter a number.");
            } catch (Exception e) {
                // Catch any unexpected exceptions during an operation
                System.err.println("An unexpected error occurred: " + e.getMessage());
                e.printStackTrace(); // Print stack trace for debugging unexpected errors
            }
        }
        scanner.close(); // Close the scanner when exiting
    }

    /**
     * Main method to start the application.
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        EventManager manager = new EventManager();
        manager.run();
    }
}
