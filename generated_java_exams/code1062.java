/*
 * Exam Question #1062
 * Generated on: 2025-05-12 17:19:38
 * Generated by: Account 2
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Warehouse Order Processing System
 * 
 * **Scenario:**
 * 
 * You are tasked with developing a simplified system for a small warehouse. The warehouse receives customer orders, which are placed into a queue for processing. The warehouse maintains an inventory of items. When an order is processed, the system must check if all requested items are in stock. If sufficient stock exists for *all* items in the order, the items are deducted from the inventory, and the order is marked as processed. If any item in the order is out of stock or has insufficient quantity, the order *cannot* be processed immediately and remains in the queue (or requires manual intervention - for this simulation, it just stays). The system should allow viewing the current inventory and the orders waiting in the queue.
 * 
 * **Your Task:**
 * 
 * Implement a Java program that simulates this warehouse system. Your program must provide a command-line interface for user interaction.
 * 
 * **Requirements:**
 * 
 * 1.  **Data Structures:**
 *     *   Use a `java.util.Queue` to store incoming customer orders waiting for processing.
 *     *   Use a `java.util.ArrayList` to store the warehouse inventory items. The `ArrayList` should be declared using the `java.util.List` interface type.
 * 2.  **Classes:**
 *     *   Create an `InventoryItem` class (or similar) to represent items in the warehouse inventory. It should have fields for item ID (String), name (String), and quantity (int).
 *     *   Create an `OrderItem` class (or similar) to represent a specific item and its requested quantity *within* an order. It should have fields for item ID (String) and quantity (int).
 *     *   Create an `Order` class (or similar) to represent a customer order. It should have a unique order ID (String) and a `List` of `OrderItem` objects representing the items requested in this order.
 *     *   Create a main class (e.g., `WarehouseSystem`) that contains the `main` method and manages the `Queue` of `Order`s and the `List` of `InventoryItem`s.
 * 3.  **Functionality (via Command-Line Menu):**
 *     *   **Add Initial Inventory:** The system should start with some predefined inventory items (you can hardcode these).
 *     *   **Add New Order:** Prompt the user for an order ID and then allow them to add multiple items to the order (specifying item ID and quantity for each). Add the created `Order` object to the processing queue. Implement basic validation (e.g., quantity > 0).
 *     *   **Process Next Order:** Attempt to process the order at the front of the queue. This involves:
 *         *   Checking if the queue is empty.
 *         *   If not empty, examine the order (without removing it initially - `peek()`).
 *         *   For each `OrderItem` in the order, find the corresponding `InventoryItem` in the inventory `List`.
 *         *   Check if the `InventoryItem` exists and has sufficient quantity for the requested `OrderItem` quantity.
 *         *   **Crucially:** Only if *all* items in the order have sufficient stock, remove the order from the queue (`poll()`), deduct the quantities from the inventory, and print a success message to `System.out`.
 *         *   If any item in the order lacks sufficient stock, print an error message to `System.err` indicating which item is short, and leave the order in the queue.
 *     *   **View Inventory:** Display the current list of inventory items, including their IDs, names, and quantities, using `System.out`.
 *     *   **View Order Queue:** Display the order IDs and perhaps the number of items for each order currently waiting in the queue, using `System.out`.
 *     *   **Exit:** Terminate the program.
 * 4.  **User Input:** Use `java.util.Scanner` to read user commands and input data.
 * 5.  **Control Flow:** Use a `switch` statement to handle the different menu options.
 * 6.  **Error Handling:**
 *     *   Use `System.err` to display error messages (e.g., invalid menu option, invalid input data, insufficient stock during processing, queue is empty).
 *     *   Implement class-wide exception handling using `try-catch` blocks to gracefully handle potential runtime errors (e.g., `NumberFormatException` when parsing input, or other unexpected issues). The main operational loop should be covered by a `try-catch`.
 * 7.  **Best Practices:**
 *     *   Use appropriate access modifiers (`private` fields, `public` methods).
 *     *   Use meaningful variable and method names.
 *     *   Include comments and basic documentation (e.g., Javadoc for classes/methods).
 *     *   Implement input validation where appropriate (e.g., checking for positive quantities).
 * 
 * **Expected Output:**
 * 
 * The program should present a menu, accept user input, and display information or error messages based on the chosen action. Successful operations and system state views go to `System.out`, errors go to `System.err`.
 * 
 * ```
 * --- Warehouse System Menu ---
 * 1. Add New Order
 * 2. Process Next Order
 * 3. View Inventory
 * 4. View Order Queue
 * 5. Exit
 * Enter your choice:
 * ```
 * 
 * Example Interaction:
 * ```
 * Enter your choice: 3
 * --- Current Inventory ---
 * ID: A101, Name: Widget, Quantity: 100
 * ID: B202, Name: Gadget, Quantity: 50
 * ...
 * 
 * Enter your choice: 1
 * Enter Order ID: ORD001
 * --- Add Items to Order ORD001 (Enter 'done' when finished) ---
 * Enter Item ID: A101
 * Enter Quantity: 10
 * Item A101 (Qty 10) added to order.
 * Enter Item ID: B202
 * Enter Quantity: 5
 * Item B202 (Qty 5) added to order.
 * Enter Item ID: done
 * Order ORD001 added to queue.
 * 
 * Enter your choice: 4
 * --- Orders in Queue ---
 * Order ID: ORD001 (2 items)
 * 
 * Enter your choice: 2
 * Processing Order: ORD001
 * Order ORD001 processed successfully. Inventory updated.
 * 
 * Enter your choice: 3
 * --- Current Inventory ---
 * ID: A101, Name: Widget, Quantity: 90
 * ID: B202, Name: Gadget, Quantity: 45
 * ...
 * 
 * Enter your choice: 2
 * Processing Order: ... (if another order exists)
 * OR
 * System.err: Error: Order queue is empty.
 * 
 * Enter your choice: 1
 * Enter Order ID: ORD002
 * --- Add Items to Order ORD002 (Enter 'done' when finished) ---
 * Enter Item ID: A101
 * Enter Quantity: 1000
 * Item A101 (Qty 1000) added to order.
 * Enter Item ID: done
 * Order ORD002 added to queue.
 * 
 * Enter your choice: 2
 * Processing Order: ORD002
 * System.err: Error processing order ORD002: Insufficient stock for item A101 (requested 1000, available 90). Order remains in queue.
 * 
 * Enter your choice: 5
 * Exiting Warehouse System.
 * ```
 * 
 * **Constraint Checklist & Confidence Score:**
 * 
 * 1. Use Queue: Yes
 * 2. Use ArrayList: Yes
 * 3. Use List interface: Yes
 * 4. Use Scanner: Yes
 * 5. Use Switch statement: Yes
 * 6. Use System.err: Yes
 * 7. Use System.out: Yes
 * 8. Use Class-wide try-catch: Yes
 * 
 * Confidence Score: 5/5 - All requirements can be met within a cohesive design.
 * 
 * **Challenge Level:** Moderate to High. Requires understanding multiple data structures, object-oriented design, input handling with validation, conditional logic for processing, and proper error/output streams. The processing logic with the pre-check (`peek` then `poll` based on condition) adds complexity.
 * 
 * **Time Estimate:** 45-60 minutes.
 * 
 * **Grading Considerations:**
 * *   Correct use of all required components.
 * *   Proper class design and encapsulation.
 * *   Correct implementation of the processing logic (checking stock *before* removing/deducting).
 * *   Effective use of `System.out` and `System.err`.
 * *   Robust input handling and validation.
 * *   Appropriate use of `try-catch` for error handling.
 * *   Code readability and adherence to best practices (naming, comments).
 *
 * EXPLANATION:
 * This solution implements the `WarehouseSystem` as described, demonstrating the required Java concepts in a practical scenario.
 * 
 * 1.  **Data Structures:**
 *     *   `java.util.Queue`: The `orderQueue` is declared as a `Queue<Order>` and instantiated using `java.util.LinkedList`. `LinkedList` is a common implementation of `Queue` providing FIFO behavior suitable for processing orders in arrival sequence. `offer()` is used to add orders to the tail, `peek()` to look at the head without removing, and `poll()` to remove the head after successful processing.
 *     *   `java.util.ArrayList`: The `inventory` is declared as a `List<InventoryItem>` and instantiated using `java.util.ArrayList`. `ArrayList` is suitable here for storing and accessing inventory items by iterating or searching (like in `findInventoryItem`).
 *     *   `java.util.List interface`: The `inventory` is typed as `List<InventoryItem>`, adhering to the requirement to use the interface. The `Order` class also uses `List<OrderItem>` for its items, reinforcing the use of the interface.
 * 
 * 2.  **Classes:**
 *     *   `InventoryItem`: Encapsulates item details (ID, name, quantity) with private fields and public getters. Includes a `decreaseQuantity` method with basic validation and a `hasSufficientStock` helper method used during order processing. `toString()` provides a convenient representation.
 *     *   `OrderItem`: Encapsulates an item reference (by ID) and the requested quantity within an order. Private fields, public getters, and `toString()`.
 *     *   `Order`: Encapsulates an order (ID and a `List` of `OrderItem`s). Private fields, public getters, and `toString()`.
 *     *   `WarehouseSystem`: The main class. It holds the `inventory` (`List`) and `orderQueue` (`Queue`). It contains methods for all system operations (`addNewOrder`, `processNextOrder`, `viewInventory`, `viewOrderQueue`, `displayMenu`, `run`) and the `main` method to start execution.
 * 
 * 3.  **Functionality:**
 *     *   **Initial Inventory:** Hardcoded items are added to the `inventory` `ArrayList` upon `WarehouseSystem` instantiation.
 *     *   **Add New Order:** The `addNewOrder` method prompts for input using `Scanner`, creates `OrderItem` objects in an `ArrayList`, bundles them into an `Order` object, and adds it to the `orderQueue` using `offer()`. Input validation for quantity is included.
 *     *   **Process Next Order:** The `processNextOrder` method demonstrates conditional processing. It uses `orderQueue.peek()` to look at the next order. It then iterates through the order's items, using `findInventoryItem` to locate the corresponding `InventoryItem` in the `inventory` `List`. It checks stock using `hasSufficientStock`. Only if *all* items pass the stock check does it proceed to remove the order using `orderQueue.poll()` and update inventory quantities using `decreaseQuantity`. If the check fails for any item, an error is printed to `System.err`, and the order remains in the queue.
 *     *   **View Inventory:** The `viewInventory` method iterates through the `inventory` `ArrayList` and prints each `InventoryItem` using `System.out`.
 *     *   **View Order Queue:** The `viewOrderQueue` method iterates through the `orderQueue` (which is possible with `LinkedList`'s iterator) and prints each `Order` using `System.out`. This shows the orders waiting.
 *     *   **Exit:** The '5' option sets a flag to terminate the main loop in the `run` method.
 * 
 * 4.  **User Input:** `java.util.Scanner` is used throughout the `run` and `addNewOrder` methods to read user input from `System.in`. Using `nextLine()` consistently helps avoid common `Scanner` pitfalls with newlines.
 * 
 * 5.  **Control Flow:** A `while(running)` loop in the `run` method keeps the system active until the user chooses to exit. A `switch` statement is used within the loop to direct execution based on the user's menu choice.
 * 
 * 6.  **Error Handling:**
 *     *   `System.err`: Used for displaying error messages such as invalid menu choices, empty queue, insufficient stock, invalid input formats, and empty order attempts.
 *     *   `Try-catch`: A `try-catch(Exception e)` block wraps the core logic within the `run` method's loop. This provides "class-wide" handling in the sense that any unexpected `RuntimeException` or other `Exception` occurring during the execution of a menu option will be caught, preventing the program from crashing and printing a generic error to `System.err`. A specific `try-catch(NumberFormatException)` is also used when parsing user input for quantity in `addNewOrder` to handle invalid number entries gracefully.
 * 
 * 7.  **Best Practices:**
 *     *   **Encapsulation:** All class fields are `private`, accessed via `public` getters and specific methods (`decreaseQuantity`).
 *     *   **Naming:** Class, variable, and method names are descriptive (e.g., `InventoryItem`, `orderQueue`, `processNextOrder`).
 *     *   **Comments/Documentation:** Basic Javadoc-style comments explain the purpose of classes and key methods. Inline comments clarify specific logic points.
 *     *   **Input Validation:** Checks for empty strings (Order ID, Item ID), positive quantities, and handles `NumberFormatException`.
 *     *   **Clean Code:** The code is structured into separate classes with clear responsibilities. The main logic is contained within the `WarehouseSystem` class, with helper methods for specific tasks.
 * 
 * This solution effectively integrates all required components into a functional system, demonstrating key object-oriented principles, data structure usage, and error handling in Java.
 */

import java.util.ArrayList;
import java.util.LinkedList; // LinkedList implements Queue
import java.util.List;
import java.util.Queue;
import java.util.Scanner;

// Represents an item in the warehouse inventory
class InventoryItem {
    private String itemId;
    private String name;
    private int quantity;

    /**
     * Constructs an InventoryItem.
     * @param itemId The unique ID of the item.
     * @param name The name of the item.
     * @param quantity The current stock quantity.
     */
    public InventoryItem(String itemId, String name, int quantity) {
        this.itemId = itemId;
        this.name = name;
        this.quantity = quantity;
    }

    // Getters
    public String getItemId() {
        return itemId;
    }

    public String getName() {
        return name;
    }

    public int getQuantity() {
        return quantity;
    }

    /**
     * Decreases the quantity of the item.
     * @param amount The amount to decrease.
     * @return true if quantity was decreased, false if amount is invalid or exceeds current quantity.
     */
    public boolean decreaseQuantity(int amount) {
        if (amount <= 0 || amount > this.quantity) {
            return false; // Cannot decrease by non-positive or more than available
        }
        this.quantity -= amount;
        return true;
    }

    /**
     * Checks if sufficient stock is available.
     * @param requestedQuantity The quantity needed.
     * @return true if available quantity is greater than or equal to requested, false otherwise.
     */
    public boolean hasSufficientStock(int requestedQuantity) {
        return this.quantity >= requestedQuantity;
    }

    @Override
    public String toString() {
        return "ID: " + itemId + ", Name: " + name + ", Quantity: " + quantity;
    }
}

// Represents an item and its quantity within a specific order
class OrderItem {
    private String itemId;
    private int quantity;

    /**
     * Constructs an OrderItem.
     * @param itemId The ID of the item.
     * @param quantity The requested quantity of the item.
     */
    public OrderItem(String itemId, int quantity) {
        this.itemId = itemId;
        this.quantity = quantity;
    }

    // Getters
    public String getItemId() {
        return itemId;
    }

    public int getQuantity() {
        return quantity;
    }

    @Override
    public String toString() {
        return "Item ID: " + itemId + ", Qty: " + quantity;
    }
}

// Represents a customer order
class Order {
    private String orderId;
    private List<OrderItem> items; // Using List interface

    /**
     * Constructs an Order.
     * @param orderId The unique ID of the order.
     * @param items A list of items included in the order.
     */
    public Order(String orderId, List<OrderItem> items) {
        this.orderId = orderId;
        this.items = items; // Store the list of items
    }

    // Getters
    public String getOrderId() {
        return orderId;
    }

    public List<OrderItem> getItems() {
        return items;
    }

    @Override
    public String toString() {
        return "Order ID: " + orderId + " (" + items.size() + " items)";
    }
}

// Main class managing the warehouse system
public class WarehouseSystem {
    // Using List interface, implemented by ArrayList
    private List<InventoryItem> inventory;
    // Using Queue interface, implemented by LinkedList for FIFO
    private Queue<Order> orderQueue;
    private Scanner scanner;

    /**
     * Constructs the WarehouseSystem, initializes inventory and queue.
     */
    public WarehouseSystem() {
        // Initialize inventory using ArrayList
        inventory = new ArrayList<>();
        // Initialize order queue using LinkedList (which implements Queue)
        orderQueue = new LinkedList<>();
        scanner = new Scanner(System.in);

        // Add some initial inventory
        addInitialInventory();
    }

    /**
     * Adds predefined items to the inventory.
     */
    private void addInitialInventory() {
        inventory.add(new InventoryItem("A101", "Widget", 100));
        inventory.add(new InventoryItem("B202", "Gadget", 50));
        inventory.add(new InventoryItem("C303", "Dongle", 25));
        inventory.add(new InventoryItem("D404", "Sprocket", 75));
        System.out.println("Initial inventory loaded.");
    }

    /**
     * Finds an InventoryItem by its ID.
     * @param itemId The ID to search for.
     * @return The InventoryItem if found, null otherwise.
     */
    private InventoryItem findInventoryItem(String itemId) {
        for (InventoryItem item : inventory) {
            if (item.getItemId().equalsIgnoreCase(itemId)) {
                return item;
            }
        }
        return null;
    }

    /**
     * Displays the main menu options.
     */
    private void displayMenu() {
        System.out.println("\n--- Warehouse System Menu ---");
        System.out.println("1. Add New Order");
        System.out.println("2. Process Next Order");
        System.out.println("3. View Inventory");
        System.out.println("4. View Order Queue");
        System.out.println("5. Exit");
        System.out.print("Enter your choice: ");
    }

    /**
     * Handles adding a new order based on user input.
     */
    private void addNewOrder() {
        System.out.print("Enter Order ID: ");
        String orderId = scanner.nextLine().trim();
        if (orderId.isEmpty()) {
            System.err.println("Error: Order ID cannot be empty.");
            return;
        }

        List<OrderItem> orderItems = new ArrayList<>(); // Using ArrayList for order items
        System.out.println("--- Add Items to Order " + orderId + " (Enter 'done' when finished) ---");

        while (true) {
            System.out.print("Enter Item ID: ");
            String itemId = scanner.nextLine().trim();
            if (itemId.equalsIgnoreCase("done")) {
                break;
            }
            if (itemId.isEmpty()) {
                System.err.println("Error: Item ID cannot be empty.");
                continue;
            }

            int quantity = -1;
            System.out.print("Enter Quantity: ");
            try {
                quantity = Integer.parseInt(scanner.nextLine().trim());
                if (quantity <= 0) {
                    System.err.println("Error: Quantity must be positive.");
                    continue;
                }
            } catch (NumberFormatException e) {
                System.err.println("Error: Invalid quantity entered. Please enter a number.");
                continue;
            }

            // Optional: Check if item exists in inventory before adding to order
             if (findInventoryItem(itemId) == null) {
                 System.err.println("Warning: Item ID '" + itemId + "' not found in inventory. It will be checked during processing.");
             }


            orderItems.add(new OrderItem(itemId, quantity));
            System.out.println("Item " + itemId + " (Qty " + quantity + ") added to order.");
        }

        if (orderItems.isEmpty()) {
            System.err.println("Error: Cannot add an empty order.");
            return;
        }

        Order newOrder = new Order(orderId, orderItems);
        orderQueue.offer(newOrder); // Add order to the end of the queue
        System.out.println("Order " + orderId + " added to queue.");
    }

    /**
     * Attempts to process the next order in the queue.
     */
    private void processNextOrder() {
        if (orderQueue.isEmpty()) {
            System.err.println("Error: Order queue is empty. Nothing to process.");
            return;
        }

        // Peek at the order without removing it yet
        Order orderToProcess = orderQueue.peek();
        System.out.println("Processing Order: " + orderToProcess.getOrderId());

        boolean canProcess = true;
        // Check stock for all items first
        for (OrderItem orderItem : orderToProcess.getItems()) {
            InventoryItem inventoryItem = findInventoryItem(orderItem.getItemId());
            if (inventoryItem == null) {
                System.err.println("Error processing order " + orderToProcess.getOrderId() + ": Item ID '" + orderItem.getItemId() + "' not found in inventory.");
                canProcess = false;
                break; // Stop checking this order
            }
            if (!inventoryItem.hasSufficientStock(orderItem.getQuantity())) {
                System.err.println("Error processing order " + orderToProcess.getOrderId() + ": Insufficient stock for item " + orderItem.getItemId() + " (requested " + orderItem.getQuantity() + ", available " + inventoryItem.getQuantity() + ").");
                canProcess = false;
                break; // Stop checking this order
            }
        }

        // If all checks passed, process the order
        if (canProcess) {
            // Remove the order from the queue
            orderQueue.poll();

            // Deduct quantities from inventory
            for (OrderItem orderItem : orderToProcess.getItems()) {
                InventoryItem inventoryItem = findInventoryItem(orderItem.getItemId());
                // This should not be null or insufficient stock due to the check above,
                // but defensive programming is good.
                if (inventoryItem != null && inventoryItem.decreaseQuantity(orderItem.getQuantity())) {
                    // Quantity decreased successfully
                } else {
                     // This case should ideally not happen if the pre-check was correct
                     System.err.println("Internal Error: Failed to deduct quantity for item " + orderItem.getItemId() + " in order " + orderToProcess.getOrderId());
                }
            }
            System.out.println("Order " + orderToProcess.getOrderId() + " processed successfully. Inventory updated.");
        } else {
            // If cannot process, print error (already done in the check loop) and leave order in queue
            System.err.println("Order " + orderToProcess.getOrderId() + " remains in queue due to insufficient stock or invalid items.");
        }
    }

    /**
     * Displays the current inventory status.
     */
    private void viewInventory() {
        System.out.println("--- Current Inventory ---");
        if (inventory.isEmpty()) {
            System.out.println("Inventory is empty.");
        } else {
            for (InventoryItem item : inventory) {
                System.out.println(item);
            }
        }
    }

    /**
     * Displays the orders currently waiting in the queue.
     */
    private void viewOrderQueue() {
        System.out.println("--- Orders in Queue ---");
        if (orderQueue.isEmpty()) {
            System.out.println("Order queue is empty.");
        } else {
            // Iterate through the queue without removing elements
            for (Order order : orderQueue) {
                System.out.println(order); // Order.toString() provides summary
            }
        }
    }

    /**
     * Runs the main warehouse system loop.
     */
    public void run() {
        boolean running = true;
        while (running) {
            displayMenu();
            String choiceStr = scanner.nextLine().trim();

            // Class-wide try-catch to handle unexpected errors during processing
            try {
                int choice = -1;
                try {
                    choice = Integer.parseInt(choiceStr);
                } catch (NumberFormatException e) {
                    // Handled below in the default case
                }

                switch (choice) {
                    case 1:
                        addNewOrder();
                        break;
                    case 2:
                        processNextOrder();
                        break;
                    case 3:
                        viewInventory();
                        break;
                    case 4:
                        viewOrderQueue();
                        break;
                    case 5:
                        System.out.println("Exiting Warehouse System.");
                        running = false; // Exit the loop
                        break;
                    default:
                        System.err.println("Error: Invalid choice. Please enter a number between 1 and 5.");
                        break;
                }
            } catch (Exception e) {
                // Catch any unexpected runtime exceptions
                System.err.println("An unexpected error occurred: " + e.getMessage());
                // e.printStackTrace(); // Uncomment for detailed debugging
            }
        }
        scanner.close(); // Close the scanner when exiting
    }

    /**
     * Main method to start the Warehouse System.
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        WarehouseSystem system = new WarehouseSystem();
        system.run();
    }
}
