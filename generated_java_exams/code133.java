/*
 * Exam Question #133
 * Generated on: 2025-05-11 22:19:29
 * Generated by: Account 2
 * 
 * QUESTION:
 * **Java Programming Exam Task: Advanced Hospital Appointment System**
 * 
 * **Problem Description:**
 * 
 * Design and implement a simplified hospital appointment management system. The system needs to manage a list of doctors and a waiting queue of patients for each doctor. Patients are added to a specific doctor's waiting list, and appointments are scheduled by taking the next patient from the front of that doctor's queue. The system should be interactive, allowing users to perform various actions via a menu.
 * 
 * **Requirements:**
 * 
 * 1.  **Core Data Structures:**
 *     *   Maintain a list of `Doctor` objects. Use `java.util.List` as the interface type and `java.util.ArrayList` as the concrete implementation.
 *     *   Each `Doctor` object must manage its own waiting list of `Patient` objects using `java.util.Queue`. A `java.util.LinkedList` is a suitable implementation for the queue.
 * 2.  **Classes:**
 *     *   `Patient`: Represents a patient with at least a `name`.
 *     *   `Doctor`: Represents a doctor with at least a `name` and `specialty`. It must contain a `Queue` of `Patient` objects for its waiting list.
 *     *   `HospitalSystem`: The main class that manages the list of doctors and handles user interaction and system operations.
 *     *   `DoctorNotFoundException`: A custom exception class to indicate when a requested doctor is not found in the system.
 * 3.  **Functionality (Menu Options):**
 *     *   **Add New Doctor:** Prompt for doctor's name and specialty, then add the doctor to the system's list. Basic validation (name/specialty not empty) is required.
 *     *   **Add Patient to Waiting List:** Prompt for patient's name and the target doctor's name. Find the doctor (case-insensitive search is acceptable for doctor name lookup, or strictly case-sensitive if preferred, specify your choice). If found, create a `Patient` object and add it to the end of that doctor's waiting queue. If the doctor is not found, report an error. Basic validation (patient name not empty) is required.
 *     *   **Schedule Next Appointment:** Prompt for the doctor's name. Find the doctor. If found and their waiting queue is not empty, remove the next patient from the front of the queue and announce the scheduled appointment (e.g., "Appointment scheduled for [Patient Name] with Dr. [Doctor Name]"). If the queue is empty, report that there are no patients waiting for this doctor. If the doctor is not found, report an error.
 *     *   **List System Status:** Display a list of all doctors, their specialty, and the current number of patients in their waiting queue.
 *     *   **Exit:** Terminate the program.
 * 4.  **Input/Output:**
 *     *   Use `java.util.Scanner` to read user input from the console.
 *     *   Use `System.out` for displaying the menu, prompts, success messages, and status listings.
 *     *   Use `System.err` for displaying all error messages (e.g., invalid input, doctor not found, queue empty).
 * 5.  **Control Flow:**
 *     *   Use a `switch` statement to handle the main menu selections.
 * 6.  **Error Handling:**
 *     *   Implement input validation for names/specialties (not empty). Use `System.err` for validation failures.
 *     *   Use a `try-catch` block to handle potential exceptions, specifically `DoctorNotFoundException` when looking up doctors, and potentially other unexpected issues. The problem requires "Class-wide exception handling", which can be implemented by wrapping the main operation loop or critical sections in `try-catch` blocks.
 * 7.  **Best Practices:**
 *     *   Employ proper encapsulation (private fields, public methods).
 *     *   Use meaningful variable and method names.
 *     *   Include appropriate comments and documentation (e.g., Javadoc for classes/methods).
 *     *   Ensure clean code structure and organization.
 *     *   Close the `Scanner` resource when done.
 * 
 * **Expected Output:**
 * 
 * The output should be interactive, guiding the user through the menu options. Success messages and status should go to `System.out`, while all error messages (validation, doctor not found, queue empty) should go to `System.err`.
 * 
 * **Example Interaction Flow (Illustrative):**
 * 
 * ```
 * --- Hospital Appointment System Menu ---
 * 1. Add New Doctor
 * 2. Add Patient to Waiting List
 * 3. Schedule Next Appointment
 * 4. List System Status
 * 5. Exit
 * Enter choice: 1
 * Enter doctor name: Dr. Smith
 * Enter doctor specialty: Cardiology
 * Dr. Smith (Cardiology) added.
 * 
 * --- Hospital Appointment System Menu ---
 * ...
 * Enter choice: 2
 * Enter patient name: Alice
 * Enter doctor name for appointment: Dr. Smith
 * Alice added to Dr. Smith's waiting list.
 * 
 * --- Hospital Appointment System Menu ---
 * ...
 * Enter choice: 2
 * Enter patient name: Bob
 * Enter doctor name for appointment: Dr. Jones
 * Doctor 'Dr. Jones' not found.
 * ...
 * Enter choice: 4
 * --- System Status ---
 * Dr. Smith (Cardiology) - Waiting Patients: 1
 * --- End Status ---
 * ...
 * Enter choice: 3
 * Enter doctor name to schedule for: Dr. Smith
 * Appointment scheduled for Alice with Dr. Smith.
 * ...
 * Enter choice: 3
 * Enter doctor name to schedule for: Dr. Smith
 * No patients waiting for Dr. Smith.
 * ...
 * Enter choice: 5
 * Exiting system. Goodbye!
 * ```
 * 
 * Your solution should implement the required classes and the `HospitalSystem` logic to fulfill these requirements.
 *
 * EXPLANATION:
 * This solution implements the required Hospital Appointment System demonstrating the use of various Java concepts.
 * 
 * 1.  **Class Structure:**
 *     *   `Patient`: A simple class encapsulating a patient's name. It includes basic validation in the constructor.
 *     *   `Doctor`: Encapsulates a doctor's name and specialty. Crucially, it holds a `Queue<Patient>` (`waitingQueue`) to manage its specific list of waiting patients. Methods `addPatient` and `scheduleNextPatient` interact with this queue using `offer` and `poll` respectively, which are standard `Queue` operations suitable for this FIFO (First-In, First-Out) scenario.
 *     *   `DoctorNotFoundException`: A custom checked exception extending `Exception`. This provides a specific way to signal that a requested doctor could not be located in the system.
 *     *   `HospitalSystem`: The main class that orchestrates the application. It holds the central list of `Doctor` objects (`List<Doctor> doctors`). It contains methods for each menu option and the `run` method which drives the user interaction loop.
 * 
 * 2.  **Data Structures (`Queue`, `ArrayList`, `List`):**
 *     *   `List<Doctor> doctors = new ArrayList<>();`: The `HospitalSystem` uses `List` as the interface type and `ArrayList` as the concrete implementation to store and manage the collection of `Doctor` objects. `ArrayList` provides dynamic resizing and efficient random access (though we primarily iterate).
 *     *   `Queue<Patient> waitingQueue = new LinkedList<>();`: Each `Doctor` object uses `Queue` as the interface type and `LinkedList` as the concrete implementation for its waiting list. `LinkedList` is a good choice for a queue as `offer` (add to end) and `poll` (remove from front) operations are efficient (O(1)).
 * 
 * 3.  **Input/Output (`Scanner`, `System.out`, `System.err`):**
 *     *   `Scanner scanner = new Scanner(System.in);`: Used in the `run` method of `HospitalSystem` to read user input from the console.
 *     *   `System.out.println(...)`: Used for displaying the menu, prompts, success messages (e.g., doctor added, patient added, appointment scheduled), and the system status listing.
 *     *   `System.err.println(...)`: Used specifically for displaying error messages, such as invalid user input, doctor not found errors, and messages indicating an empty waiting queue when trying to schedule.
 * 
 * 4.  **Control Flow (`Switch`):**
 *     *   The `run` method uses a `while` loop for the main application loop.
 *     *   A `switch` statement is used inside the loop to process the integer choice entered by the user, directing execution to the appropriate method (`addDoctor`, `addPatientToDoctorQueue`, `scheduleAppointmentForDoctor`, `listSystemStatus`).
 * 
 * 5.  **Error Handling (`try-catch`, `DoctorNotFoundException`, Input Validation):**
 *     *   **Custom Exception:** `DoctorNotFoundException` is thrown by the private helper method `findDoctorByName` when a doctor matching the provided name is not found. This makes the intention of the error clear.
 *     *   **Specific Catch:** The methods `addPatientToDoctorQueue` and `scheduleAppointmentForDoctor` specifically catch `DoctorNotFoundException` and print a user-friendly error message using `System.err`.
 *     *   **General Catch:** The `run` method includes a `try-catch(Exception e)` block wrapped around the main `while` loop. This provides "class-wide exception handling" by catching any *unexpected* runtime exceptions that might occur within the loop's execution and printing a general error message to `System.err`. This prevents the program from crashing abruptly due to unforeseen issues.
 *     *   **Input Validation:**
 *         *   The constructors of `Patient` and `Doctor` validate that names/specialties are not null or empty, throwing `IllegalArgumentException`. The `addDoctor` and `addPatientToDoctorQueue` methods catch this specific exception and report it via `System.err`.
 *         *   The `run` method includes validation using `scanner.hasNextInt()` to ensure the menu choice is a number, handling non-integer input gracefully. It also consumes the invalid input to prevent an infinite loop.
 *         *   `findDoctorByName` also checks if the lookup name is empty.
 *     *   **Queue Empty Handling:** The `scheduleAppointmentForDoctor` method explicitly checks if `doctor.scheduleNextPatient()` returns `null` (indicating the queue was empty) and prints an informative message to `System.err`.
 * 
 * 6.  **Best Practices:**
 *     *   **Encapsulation:** Fields in `Patient`, `Doctor`, and `HospitalSystem` are `private`. Access and modification are done via public methods (`getName`, `addPatient`, `scheduleNextPatient`, etc.).
 *     *   **Meaningful Names:** Variable names (`doctors`, `waitingQueue`, `patientName`, `scheduleDocName`) and method names (`addDoctor`, `scheduleNextPatient`, `listSystemStatus`, `findDoctorByName`) clearly indicate their purpose.
 *     *   **Comments/Documentation:** Javadoc-style comments are included for classes and methods to explain their function, parameters, and return values or exceptions. Inline comments clarify specific logic where needed.
 *     *   **Clean Code Structure:** The code is divided into logical classes, and methods are kept relatively focused on single responsibilities. The `run` method handles the top-level interaction, delegating specific tasks to other methods (`addDoctor`, `addPatientToDoctorQueue`, etc.).
 *     *   **Resource Management:** The `Scanner` is closed in a `finally` block within the `run` method's `try-catch`, ensuring it's closed even if an exception occurs.
 * 
 * This solution effectively integrates the required Java components and demonstrates robust error handling, input validation, and good programming practices within the context of a practical scenario.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.Iterator; // Needed for safe removal during iteration if implemented differently, but not strictly necessary for finding

// Custom Exception for Doctor Not Found
class DoctorNotFoundException extends Exception {
    public DoctorNotFoundException(String message) {
        super(message);
    }
}

// Represents a patient
class Patient {
    private String name;

    /**
     * Constructs a new Patient.
     * @param name The name of the patient.
     */
    public Patient(String name) {
        if (name == null || name.trim().isEmpty()) {
            throw new IllegalArgumentException("Patient name cannot be empty.");
        }
        this.name = name.trim();
    }

    /**
     * Gets the patient's name.
     * @return The patient's name.
     */
    public String getName() {
        return name;
    }

    @Override
    public String toString() {
        return name;
    }
}

// Represents a doctor with a waiting queue of patients
class Doctor {
    private String name;
    private String specialty;
    private Queue<Patient> waitingQueue; // Use Queue interface

    /**
     * Constructs a new Doctor.
     * Initializes the waiting queue.
     * @param name The name of the doctor.
     * @param specialty The doctor's specialty.
     */
    public Doctor(String name, String specialty) {
        if (name == null || name.trim().isEmpty()) {
            throw new IllegalArgumentException("Doctor name cannot be empty.");
        }
        if (specialty == null || specialty.trim().isEmpty()) {
             throw new IllegalArgumentException("Doctor specialty cannot be empty.");
        }
        this.name = name.trim();
        this.specialty = specialty.trim();
        this.waitingQueue = new LinkedList<>(); // Use LinkedList as Queue implementation
    }

    /**
     * Gets the doctor's name.
     * @return The doctor's name.
     */
    public String getName() {
        return name;
    }

    /**
     * Gets the doctor's specialty.
     * @return The doctor's specialty.
     */
    public String getSpecialty() {
        return specialty;
    }

    /**
     * Adds a patient to this doctor's waiting queue.
     * @param patient The patient to add.
     */
    public void addPatient(Patient patient) {
        if (patient != null) {
            waitingQueue.offer(patient); // offer is generally preferred over add for queues
        }
    }

    /**
     * Schedules the next patient from the waiting queue.
     * Removes and returns the patient at the front of the queue.
     * @return The next patient, or null if the queue is empty.
     */
    public Patient scheduleNextPatient() {
        return waitingQueue.poll(); // poll returns null if queue is empty
    }

    /**
     * Gets the number of patients currently in the waiting queue.
     * @return The size of the waiting queue.
     */
    public int getWaitingQueueSize() {
        return waitingQueue.size();
    }

    @Override
    public String toString() {
        return "Dr. " + name + " (" + specialty + ")";
    }
}

// Main system class managing doctors and operations
public class HospitalSystem {
    private List<Doctor> doctors; // Use List interface

    /**
     * Constructs a new HospitalSystem.
     * Initializes the list of doctors.
     */
    public HospitalSystem() {
        this.doctors = new ArrayList<>(); // Use ArrayList implementation
    }

    /**
     * Adds a new doctor to the system.
     * @param name The doctor's name.
     * @param specialty The doctor's specialty.
     */
    public void addDoctor(String name, String specialty) {
        try {
            Doctor newDoctor = new Doctor(name, specialty);
            doctors.add(newDoctor);
            System.out.println(newDoctor + " added.");
        } catch (IllegalArgumentException e) {
            System.err.println("Error adding doctor: " + e.getMessage());
        }
    }

    /**
     * Finds a doctor by name (case-insensitive).
     * @param name The name of the doctor to find.
     * @return The Doctor object if found.
     * @throws DoctorNotFoundException if no doctor with the given name is found.
     */
    private Doctor findDoctorByName(String name) throws DoctorNotFoundException {
        if (name == null || name.trim().isEmpty()) {
             throw new DoctorNotFoundException("Doctor name for lookup cannot be empty.");
        }
        String searchName = name.trim();
        for (Doctor doctor : doctors) {
            if (doctor.getName().equalsIgnoreCase(searchName)) { // Case-insensitive lookup
                return doctor;
            }
        }
        throw new DoctorNotFoundException("Doctor '" + name + "' not found.");
    }

    /**
     * Adds a patient to a specific doctor's waiting queue.
     * @param doctorName The name of the doctor.
     * @param patientName The name of the patient.
     */
    public void addPatientToDoctorQueue(String doctorName, String patientName) {
        try {
            Patient newPatient = new Patient(patientName); // Patient constructor validates name
            Doctor doctor = findDoctorByName(doctorName); // findDoctorByName throws DoctorNotFoundException
            doctor.addPatient(newPatient);
            System.out.println(newPatient.getName() + " added to " + doctor.getName() + "'s waiting list.");
        } catch (IllegalArgumentException e) {
             System.err.println("Error adding patient: " + e.getMessage());
        }
        catch (DoctorNotFoundException e) {
            System.err.println(e.getMessage());
        }
    }

    /**
     * Schedules the next appointment for a specific doctor.
     * @param doctorName The name of the doctor.
     */
    public void scheduleAppointmentForDoctor(String doctorName) {
        try {
            Doctor doctor = findDoctorByName(doctorName); // findDoctorByName throws DoctorNotFoundException
            Patient nextPatient = doctor.scheduleNextPatient(); // poll returns null if empty

            if (nextPatient != null) {
                System.out.println("Appointment scheduled for " + nextPatient.getName() + " with " + doctor.getName() + ".");
            } else {
                System.err.println("No patients waiting for " + doctor.getName() + ".");
            }
        } catch (DoctorNotFoundException e) {
            System.err.println(e.getMessage());
        }
    }

    /**
     * Lists the status of all doctors and their waiting queues.
     */
    public void listSystemStatus() {
        System.out.println("--- System Status ---");
        if (doctors.isEmpty()) {
            System.out.println("No doctors registered in the system.");
        } else {
            for (Doctor doctor : doctors) {
                System.out.println(doctor + " - Waiting Patients: " + doctor.getWaitingQueueSize());
            }
        }
        System.out.println("--- End Status ---");
    }

    /**
     * Displays the main menu options.
     */
    private void displayMenu() {
        System.out.println("\n--- Hospital Appointment System Menu ---");
        System.out.println("1. Add New Doctor");
        System.out.println("2. Add Patient to Waiting List");
        System.out.println("3. Schedule Next Appointment");
        System.out.println("4. List System Status");
        System.out.println("5. Exit");
    }

    /**
     * Runs the main application loop.
     * Handles user input and menu selection using a switch statement.
     * Includes class-wide exception handling.
     */
    public void run() {
        Scanner scanner = new Scanner(System.in);
        int choice = -1;

        // Class-wide exception handling around the main loop
        try {
            while (choice != 5) {
                displayMenu();
                System.out.print("Enter choice: ");

                // Input validation for choice
                if (!scanner.hasNextInt()) {
                    System.err.println("Invalid input. Please enter a number.");
                    scanner.next(); // Consume the invalid input
                    continue; // Skip the rest of the loop iteration
                }

                choice = scanner.nextInt();
                scanner.nextLine(); // Consume the newline character after reading the integer

                switch (choice) {
                    case 1: // Add Doctor
                        System.out.print("Enter doctor name: ");
                        String docName = scanner.nextLine();
                        System.out.print("Enter doctor specialty: ");
                        String docSpecialty = scanner.nextLine();
                        addDoctor(docName, docSpecialty);
                        break;
                    case 2: // Add Patient to Waiting List
                        System.out.print("Enter patient name: ");
                        String patientName = scanner.nextLine();
                        System.out.print("Enter doctor name for appointment: ");
                        String targetDocName = scanner.nextLine();
                        addPatientToDoctorQueue(targetDocName, patientName);
                        break;
                    case 3: // Schedule Next Appointment
                        System.out.print("Enter doctor name to schedule for: ");
                        String scheduleDocName = scanner.nextLine();
                        scheduleAppointmentForDoctor(scheduleDocName);
                        break;
                    case 4: // List Status
                        listSystemStatus();
                        break;
                    case 5: // Exit
                        System.out.println("Exiting system. Goodbye!");
                        break;
                    default:
                        System.err.println("Invalid choice. Please enter a number between 1 and 5.");
                }
            }
        } catch (Exception e) {
            // Catch any unexpected exceptions during the main loop execution
            System.err.println("An unexpected system error occurred: " + e.getMessage());
            // e.printStackTrace(); // Uncomment for detailed debugging stack trace
        } finally {
            // Ensure the scanner is closed regardless of exceptions
            scanner.close();
        }
    }

    /**
     * Main method to start the application.
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        HospitalSystem system = new HospitalSystem();
        system.run();
    }
}
