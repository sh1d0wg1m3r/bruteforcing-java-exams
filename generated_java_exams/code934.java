/*
 * Exam Question #934
 * Generated on: 2025-05-12 17:02:04
 * Generated by: Account 2
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Hospital Appointment Scheduler
 * 
 * **Scenario:**
 * 
 * You are tasked with building a simplified appointment scheduling system for a small hospital. The system needs to manage a fixed set of appointment slots with different doctors and a waiting list for patients who cannot immediately book an available slot.
 * 
 * **Requirements:**
 * 
 * Implement a Java program that simulates this system with the following features:
 * 
 * 1.  **Data Structures:**
 *     *   Maintain a collection of available `AppointmentSlot` objects. Each slot should have a Doctor's Name, Time, and whether it is currently booked. Use a `java.util.List` interface reference initialized with a `java.util.ArrayList` implementation to store these slots.
 *     *   Maintain a `java.util.Queue` to hold `Patient` objects who are on the waiting list. Use a suitable `Queue` implementation (like `java.util.LinkedList`).
 * 
 * 2.  **Classes:**
 *     *   Create a `Patient` class with a private field for the patient's name and a public getter method.
 *     *   Create an `AppointmentSlot` class with private fields for doctor's name, time, and a boolean indicating if it's booked. Include a private field for the `Patient` object if booked. Provide a constructor and public methods to get doctor, time, check booking status, and book the slot for a given `Patient`.
 *     *   Create a main class (e.g., `HospitalScheduler`) that contains the `List` of slots and the `Queue` of waiting patients. This class should encapsulate the scheduling logic.
 * 
 * 3.  **Functionality (Menu-Driven):**
 *     The program should present a menu to the user using `System.out` and accept input using `java.util.Scanner`. The menu options should include:
 *     *   **1. Schedule Appointment:** Prompt for patient name and the index of the desired slot. If the slot is available, book it for the patient. If not, display an error.
 *     *   **2. Add to Waiting List:** Prompt for patient name and add them to the waiting list queue.
 *     *   **3. Process Waiting List:** Iterate through the waiting list. For each patient, find the *first* available appointment slot and book it for them. Continue until the waiting list is empty or no more slots are available.
 *     *   **4. View Status:** Display all appointment slots (Doctor, Time, Status - Booked/Available, and Patient Name if booked) and the current waiting list (number of patients and their names).
 *     *   **5. Exit:** Terminate the program.
 * 
 * 4.  **Control Flow & Error Handling:**
 *     *   Use a `switch` statement to handle the user's menu selection.
 *     *   Implement robust input validation. For example, check if the entered slot index is valid and within the bounds of the `ArrayList`. Check if patient names are provided.
 *     *   Use `System.err` to display error messages (e.g., invalid input, slot not available).
 *     *   Use `try-catch` blocks to handle potential exceptions, particularly `java.util.InputMismatchException` for non-integer input when expecting a number, and `java.lang.IndexOutOfBoundsException` when accessing slots by index. A single `try-catch` around the main menu input loop is acceptable for this exam context, but handling specific exceptions within methods is preferred if time permits.
 * 
 * 5.  **Best Practices:**
 *     *   Apply proper encapsulation (private fields, public methods).
 *     *   Use meaningful variable and method names.
 *     *   Include appropriate comments and basic documentation (e.g., Javadoc for classes/methods).
 *     *   Ensure the `Scanner` resource is closed properly.
 * 
 * **Initial State:**
 * 
 * Initialize the system with a few predefined `AppointmentSlot` objects (e.g., Dr. Smith 9:00 AM, Dr. Jones 10:00 AM, Dr. Smith 10:30 AM). All should initially be available.
 * 
 * **Expected Output:**
 * 
 * The program should provide a clear menu, respond to user actions with informative messages (success or error), and display the system's state accurately when viewing status.
 * 
 * **Example Interaction Snippet:**
 * 
 * ```
 * --- Hospital Scheduler Menu ---
 * 1. Schedule Appointment
 * 2. Add to Waiting List
 * 3. Process Waiting List
 * 4. View Status
 * 5. Exit
 * Enter your choice: 4
 * --- Appointment Status ---
 * Slot 0: Dr. Smith at 9:00 AM - Available
 * Slot 1: Dr. Jones at 10:00 AM - Available
 * Slot 2: Dr. Smith at 10:30 AM - Available
 * --- Waiting List ---
 * Waiting list is empty.
 * 
 * --- Hospital Scheduler Menu ---
 * 1. Schedule Appointment
 * 2. Add to Waiting List
 * 3. Process Waiting List
 * 4. View Status
 * 5. Exit
 * Enter your choice: 1
 * Enter patient name: Alice
 * Enter slot index: 1
 * Appointment booked for Alice with Dr. Jones at 10:00 AM.
 * 
 * --- Hospital Scheduler Menu ---
 * ... (view status again) ...
 * Slot 0: Dr. Smith at 9:00 AM - Available
 * Slot 1: Dr. Jones at 10:00 AM - Booked by Alice
 * Slot 2: Dr. Smith at 10:30 AM - Available
 * --- Waiting List ---
 * Waiting list is empty.
 * 
 * --- Hospital Scheduler Menu ---
 * ... (add Bob and Charlie to waiting list) ...
 * Enter your choice: 2
 * Enter patient name: Bob
 * Bob added to the waiting list.
 * Enter your choice: 2
 * Enter patient name: Charlie
 * Charlie added to the waiting list.
 * 
 * --- Hospital Scheduler Menu ---
 * ... (view status again) ...
 * --- Appointment Status ---
 * Slot 0: Dr. Smith at 9:00 AM - Available
 * Slot 1: Dr. Jones at 10:00 AM - Booked by Alice
 * Slot 2: Dr. Smith at 10:30 AM - Available
 * --- Waiting List ---
 * Waiting list (2 patients): Bob, Charlie
 * 
 * --- Hospital Scheduler Menu ---
 * Enter your choice: 3
 * Processing waiting list...
 * Appointment booked for Bob with Dr. Smith at 9:00 AM.
 * Appointment booked for Charlie with Dr. Smith at 10:30 AM.
 * Waiting list processed.
 * 
 * --- Hospital Scheduler Menu ---
 * ... (view status again) ...
 * --- Appointment Status ---
 * Slot 0: Dr. Smith at 9:00 AM - Booked by Bob
 * Slot 1: Dr. Jones at 10:00 AM - Booked by Alice
 * Slot 2: Dr. Smith at 10:30 AM - Booked by Charlie
 * --- Waiting List ---
 * Waiting list is empty.
 * 
 * --- Hospital Scheduler Menu ---
 * Enter your choice: 5
 * Exiting Hospital Scheduler.
 * ```
 * 
 * This task requires integrating multiple core Java concepts and data structures to build a functional, albeit simple, system. Pay close attention to how data flows between components and how errors are handled gracefully.
 *
 * EXPLANATION:
 * This solution provides a complete implementation of the `HospitalScheduler` system as described in the exam question.
 * 
 * 1.  **Class Structure and Encapsulation:**
 *     *   `Patient` class: Simple class with a private `name` field and a public `getName()` getter.
 *     *   `AppointmentSlot` class: Holds details about a slot (`doctorName`, `time`, `isBooked`, `bookedPatient`). Fields are private. Public methods (`getDoctorName`, `getTime`, `isBooked`, `getBookedPatient`, `bookSlot`) provide controlled access and modification. The `bookSlot` method encapsulates the logic for marking a slot as booked.
 *     *   `HospitalScheduler` class: Contains the main logic and data structures (`appointmentSlots`, `waitingList`). These are private fields, demonstrating encapsulation. Public methods like `run()` provide the interface for interacting with the scheduler, while private helper methods (`displayMenu`, `scheduleAppointment`, etc.) handle specific tasks.
 * 
 * 2.  **Data Structures:**
 *     *   `List<AppointmentSlot> appointmentSlots = new ArrayList<>();`: Declares `appointmentSlots` using the `List` interface, promoting flexibility, and initializes it with `ArrayList` for dynamic resizing and index-based access, which is useful for displaying slots by index and retrieving specific slots.
 *     *   `Queue<Patient> waitingList = new LinkedList<>();`: Declares `waitingList` using the `Queue` interface, appropriate for a waiting list where patients are processed in the order they arrive (FIFO - First-In, First-Out). `LinkedList` is a common `Queue` implementation.
 * 
 * 3.  **Functionality Implementation:**
 *     *   The `run()` method contains the main application loop.
 *     *   `displayMenu()` prints the options using `System.out`.
 *     *   User input is read using `java.util.Scanner`.
 *     *   A `switch` statement in the `run()` method directs execution based on the user's `choice`.
 *     *   `scheduleAppointment()`: Reads patient name and slot index. Validates input (non-empty name, valid index range). Checks if the chosen slot is available using `slot.isBooked()`. If available, it calls `slot.bookSlot()` and prints success via `System.out`. If not, it prints an error via `System.err`.
 *     *   `addPatientToWaitingList()`: Reads patient name, validates it, creates a `Patient` object, and adds it to the `waitingList` using `queue.offer()`. Prints success via `System.out`.
 *     *   `processWaitingList()`: Iterates through available slots and the waiting list. It uses `queue.poll()` to remove and retrieve the patient at the front of the queue. It finds the *first* available slot and books it. Success messages are printed to `System.out`. It handles cases where the queue is empty or no slots are available.
 *     *   `viewStatus()`: Iterates through the `appointmentSlots` list and prints each slot's status using the `AppointmentSlot`'s `toString()` method. It then checks the `waitingList`. If not empty, it prints the size and iterates through a temporary `ArrayList` copy of the queue (`new ArrayList<>(waitingList)`) to display patient names without removing them from the queue. Output is sent to `System.out`.
 * 
 * 4.  **Control Flow & Error Handling:**
 *     *   The `switch` statement provides clear branching based on user input.
 *     *   Input validation is performed before processing (e.g., checking `patientName.isEmpty()`, checking `slotIndex` bounds).
 *     *   `System.err.println()` is used for all error messages (invalid input, slot unavailable, etc.).
 *     *   A `try-catch` block is wrapped around the input reading and the `switch` statement within the main loop. This catches potential `InputMismatchException` if the user enters non-integer input when a number is expected, and a general `Exception` for any other unexpected runtime issues. Specific handling for `InputMismatchException` is included to guide the user and consume the invalid input. `IndexOutOfBoundsException` is implicitly handled by the explicit index range check in `scheduleAppointment`, providing a more user-friendly error than letting the exception crash the operation.
 *     *   The `scanner.nextLine()` call after `scanner.nextInt()` is crucial to consume the leftover newline character, preventing issues in subsequent `scanner.nextLine()` calls. This is placed in a `finally` block within `scheduleAppointment` to ensure it runs even if `nextInt()` throws an exception, and explicitly handled after the main `scanner.nextInt()` read in the `run` loop.
 * 
 * 5.  **Best Practices:**
 *     *   Meaningful names are used (e.g., `appointmentSlots`, `waitingList`, `scheduleAppointment`, `bookSlot`).
 *     *   Basic Javadoc comments are provided for classes and methods.
 *     *   Inline comments explain specific logic points.
 *     *   The `Scanner` is closed using `scanner.close()` when the main loop exits, releasing the system resource.
 * 
 * This solution effectively demonstrates the required Java components and best practices within a practical, simulated scenario, making it a suitable task for evaluating advanced understanding.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.InputMismatchException;

/**
 * Represents a patient in the hospital system.
 */
class Patient {
    private String name;

    /**
     * Constructs a Patient object.
     * @param name The name of the patient.
     */
    public Patient(String name) {
        this.name = name;
    }

    /**
     * Gets the name of the patient.
     * @return The patient's name.
     */
    public String getName() {
        return name;
    }

    @Override
    public String toString() {
        return name;
    }
}

/**
 * Represents an appointment slot with a doctor at a specific time.
 */
class AppointmentSlot {
    private String doctorName;
    private String time;
    private boolean isBooked;
    private Patient bookedPatient; // Null if not booked

    /**
     * Constructs an AppointmentSlot object.
     * Initially available.
     * @param doctorName The name of the doctor.
     * @param time The time of the appointment.
     */
    public AppointmentSlot(String doctorName, String time) {
        this.doctorName = doctorName;
        this.time = time;
        this.isBooked = false;
        this.bookedPatient = null;
    }

    /**
     * Gets the doctor's name for this slot.
     * @return The doctor's name.
     */
    public String getDoctorName() {
        return doctorName;
    }

    /**
     * Gets the time for this slot.
     * @return The appointment time.
     */
    public String getTime() {
        return time;
    }

    /**
     * Checks if the slot is currently booked.
     * @return True if booked, false otherwise.
     */
    public boolean isBooked() {
        return isBooked;
    }

    /**
     * Gets the patient booked for this slot.
     * Returns null if the slot is not booked.
     * @return The booked Patient object or null.
     */
    public Patient getBookedPatient() {
        return bookedPatient;
    }

    /**
     * Books this slot for a given patient.
     * @param patient The patient to book the slot for.
     * @return True if booking was successful (slot was available), false otherwise.
     */
    public boolean bookSlot(Patient patient) {
        if (!this.isBooked) {
            this.isBooked = true;
            this.bookedPatient = patient;
            return true;
        }
        return false; // Slot was already booked
    }

    /**
     * Provides a string representation of the appointment slot status.
     * @return A string describing the slot and its status.
     */
    @Override
    public String toString() {
        if (isBooked) {
            return String.format("%s at %s - Booked by %s", doctorName, time, bookedPatient.getName());
        } else {
            return String.format("%s at %s - Available", doctorName, time);
        }
    }
}

/**
 * Manages appointment scheduling and waiting lists for the hospital.
 */
public class HospitalScheduler {
    // Using List interface, implemented by ArrayList
    private List<AppointmentSlot> appointmentSlots;
    // Using Queue interface, implemented by LinkedList
    private Queue<Patient> waitingList;
    private Scanner scanner;

    /**
     * Constructs a HospitalScheduler and initializes appointment slots.
     */
    public HospitalScheduler() {
        // Initialize the list of appointment slots
        appointmentSlots = new ArrayList<>();
        // Add some initial slots
        appointmentSlots.add(new AppointmentSlot("Dr. Smith", "9:00 AM"));
        appointmentSlots.add(new AppointmentSlot("Dr. Jones", "10:00 AM"));
        appointmentSlots.add(new AppointmentSlot("Dr. Smith", "10:30 AM"));
        appointmentSlots.add(new AppointmentSlot("Dr. Lee", "11:00 AM")); // Added one more for variety

        // Initialize the waiting list queue
        waitingList = new LinkedList<>();

        // Initialize scanner for input
        scanner = new Scanner(System.in);
    }

    /**
     * Displays the main menu options to the user.
     */
    private void displayMenu() {
        System.out.println("\n--- Hospital Scheduler Menu ---");
        System.out.println("1. Schedule Appointment");
        System.out.println("2. Add to Waiting List");
        System.out.println("3. Process Waiting List");
        System.out.println("4. View Status");
        System.out.println("5. Exit");
        System.out.print("Enter your choice: ");
    }

    /**
     * Handles scheduling an appointment directly from available slots.
     */
    private void scheduleAppointment() {
        System.out.print("Enter patient name: ");
        String patientName = scanner.nextLine().trim();
        if (patientName.isEmpty()) {
            System.err.println("Error: Patient name cannot be empty.");
            return;
        }

        System.out.print("Enter slot index: ");
        int slotIndex = -1;
        try {
            slotIndex = scanner.nextInt();
        } catch (InputMismatchException e) {
            System.err.println("Error: Invalid input. Please enter a number for the slot index.");
            scanner.nextLine(); // Consume the invalid input
            return;
        } finally {
             // Consume the newline character left by nextInt() or nextLine() after error
             if(scanner.hasNextLine()) scanner.nextLine();
        }


        if (slotIndex < 0 || slotIndex >= appointmentSlots.size()) {
            System.err.println("Error: Invalid slot index. Please enter a number between 0 and " + (appointmentSlots.size() - 1) + ".");
            return;
        }

        AppointmentSlot slot = appointmentSlots.get(slotIndex);

        if (slot.isBooked()) {
            System.err.println("Error: Slot " + slotIndex + " (" + slot.getDoctorName() + " at " + slot.getTime() + ") is already booked.");
        } else {
            Patient patient = new Patient(patientName);
            slot.bookSlot(patient);
            System.out.println("Appointment booked for " + patientName + " with " + slot.getDoctorName() + " at " + slot.getTime() + ".");
        }
    }

    /**
     * Adds a patient to the waiting list.
     */
    private void addPatientToWaitingList() {
        System.out.print("Enter patient name: ");
        String patientName = scanner.nextLine().trim();
        if (patientName.isEmpty()) {
            System.err.println("Error: Patient name cannot be empty.");
            return;
        }

        Patient patient = new Patient(patientName);
        waitingList.offer(patient); // Add to the end of the queue
        System.out.println(patientName + " added to the waiting list.");
    }

    /**
     * Attempts to book available slots using patients from the waiting list.
     */
    private void processWaitingList() {
        System.out.println("Processing waiting list...");
        int bookedCount = 0;

        // Find available slots first to avoid repeated searching inside the loop
        List<AppointmentSlot> availableSlots = new ArrayList<>();
        for (AppointmentSlot slot : appointmentSlots) {
            if (!slot.isBooked()) {
                availableSlots.add(slot);
            }
        }

        // Iterate through available slots and the waiting list simultaneously
        int slotIndex = 0;
        while (!waitingList.isEmpty() && slotIndex < availableSlots.size()) {
            Patient patient = waitingList.poll(); // Get the next patient from the front of the queue
            AppointmentSlot slot = availableSlots.get(slotIndex);

            if (slot.bookSlot(patient)) { // This should always succeed based on how availableSlots is built
                System.out.println("Appointment booked for " + patient.getName() + " with " + slot.getDoctorName() + " at " + slot.getTime() + " from the waiting list.");
                bookedCount++;
                slotIndex++; // Move to the next available slot
            } else {
                 // This case should ideally not happen with the current logic,
                 // but as a safeguard, put the patient back if booking failed unexpectedly.
                 // This would require re-offering, but the logic is simpler if we assume
                 // availableSlots is accurate. For this exam, we'll assume it works.
                 // A more complex system might re-queue based on priority or other rules.
            }
        }

        if (bookedCount == 0) {
            if (waitingList.isEmpty()) {
                System.out.println("Waiting list is empty. No appointments to book.");
            } else {
                System.out.println("No available appointment slots to book patients from the waiting list.");
            }
        } else {
             System.out.println("Waiting list processed. Booked " + bookedCount + " appointment(s).");
        }
    }

    /**
     * Displays the current status of all appointment slots and the waiting list.
     */
    private void viewStatus() {
        System.out.println("\n--- Appointment Status ---");
        if (appointmentSlots.isEmpty()) {
            System.out.println("No appointment slots defined.");
        } else {
            for (int i = 0; i < appointmentSlots.size(); i++) {
                System.out.println("Slot " + i + ": " + appointmentSlots.get(i));
            }
        }

        System.out.println("\n--- Waiting List ---");
        if (waitingList.isEmpty()) {
            System.out.println("Waiting list is empty.");
        } else {
            System.out.println("Waiting list (" + waitingList.size() + " patients):");
            // To display queue contents without removing them, iterate or convert
            // Simple iteration (peek is not suitable for iterating the whole queue)
            // Or convert to list for easy iteration:
            List<Patient> waitingPatientsList = new ArrayList<>(waitingList);
            for (int i = 0; i < waitingPatientsList.size(); i++) {
                System.out.print(waitingPatientsList.get(i).getName() + (i < waitingPatientsList.size() - 1 ? ", " : ""));
            }
            System.out.println(); // New line after listing patients
        }
    }

    /**
     * Runs the main scheduler loop.
     */
    public void run() {
        int choice = -1;
        boolean exit = false;

        while (!exit) {
            displayMenu();
            try {
                // Check if the next input is an integer
                if (scanner.hasNextInt()) {
                    choice = scanner.nextInt();
                } else {
                    // Handle non-integer input
                    System.err.println("Error: Invalid input. Please enter a number between 1 and 5.");
                    scanner.next(); // Consume the non-integer input
                    choice = -1; // Reset choice to ensure switch default is hit
                }
                 // Consume the rest of the line after reading the integer
                scanner.nextLine();

                switch (choice) {
                    case 1:
                        scheduleAppointment();
                        break;
                    case 2:
                        addPatientToWaitingList();
                        break;
                    case 3:
                        processWaitingList();
                        break;
                    case 4:
                        viewStatus();
                        break;
                    case 5:
                        System.out.println("Exiting Hospital Scheduler.");
                        exit = true;
                        break;
                    default:
                        System.err.println("Error: Invalid choice. Please enter a number between 1 and 5.");
                }
            } catch (Exception e) {
                // Catch any other unexpected exceptions
                System.err.println("An unexpected error occurred: " + e.getMessage());
                // e.printStackTrace(); // Uncomment for debugging
            }
        }

        // Close the scanner when the program exits
        scanner.close();
        System.out.println("Scanner closed. Program terminated.");
    }

    /**
     * Main method to start the Hospital Scheduler.
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        HospitalScheduler scheduler = new HospitalScheduler();
        scheduler.run();
    }
}
