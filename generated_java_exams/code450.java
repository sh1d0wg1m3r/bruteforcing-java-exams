/*
 * Exam Question #450
 * Generated on: 2025-05-11 23:12:52
 * Generated by: Account 5
 * 
 * QUESTION:
 * **Advanced Java Programming Exam Task: Automated Package Sorting and Routing System**
 * 
 * **Scenario:**
 * You are tasked with developing a simplified system for a package sorting facility. Packages arrive and are placed in a queue awaiting processing. A sorting operator picks the next package from the queue, determines its destination, and assigns it to a specific delivery route. The system needs to manage the queue, track packages assigned to routes, and provide visibility into the process.
 * 
 * **System Requirements:**
 * 
 * 1.  **Package Representation:** Create a `Package` class to represent a package. It should have:
 *     *   A unique integer ID.
 *     *   A destination address (String).
 *     *   A status (e.g., `PENDING_SORT`, `SORTED`, `ON_ROUTE`). Use an `enum` for status.
 *     *   Appropriate private fields and public getter methods.
 * 
 * 2.  **Sorting Station:** Implement a mechanism to hold packages awaiting sorting. This must use a `java.util.Queue`. Packages should be processed in First-In, First-Out (FIFO) order.
 * 
 * 3.  **Delivery Routes:** Implement a mechanism to hold packages assigned to specific delivery routes. You can assume a few predefined routes (e.g., "Route A", "Route B", "Route C"). Each route should hold a collection of packages assigned to it. This must use `java.util.ArrayList` and be managed using the `java.util.List` interface type.
 * 
 * 4.  **User Interface (Console):** The system should interact with a user via the console using `java.util.Scanner`. Provide a menu with the following options:
 *     *   Add new package to sorting queue.
 *     *   Sort next package from the queue and assign to a route.
 *     *   View packages in the sorting queue.
 *     *   View packages assigned to a specific delivery route.
 *     *   Exit.
 * 
 * 5.  **Functionality Details:**
 *     *   **Add Package:** Prompt the user for package ID and destination. Create a `Package` object with status `PENDING_SORT` and add it to the sorting queue. Ensure the ID is positive.
 *     *   **Sort Package:** Remove the next package from the sorting queue. If the queue is empty, report an error. If successful, change the package status to `SORTED`, prompt the user for the target route (e.g., "A", "B", "C"), change the status to `ON_ROUTE`, and add it to the corresponding route's list. Handle invalid route input.
 *     *   **View Queue:** Display details (ID, Destination, Status) of all packages currently in the sorting queue.
 *     *   **View Route:** Prompt the user for a route name (e.g., "A"). Display details of all packages assigned to that route. If the route is invalid or empty, report it.
 *     *   **Exit:** Terminate the program.
 * 
 * 6.  **Flow Control:** Use a `switch` statement to handle the main menu options.
 * 
 * 7.  **Error Handling:**
 *     *   Use `System.err` to print error messages (e.g., invalid input, queue empty).
 *     *   Use `try-catch` blocks to handle potential exceptions, especially around user input that expects integers or when interacting with collections (e.g., attempting to remove from an empty queue, though `Queue.poll()` is safer, consider other potential issues like `NumberFormatException`). Implement class-wide exception handling where appropriate (e.g., around the main operational loop).
 *     *   Implement input validation (positive ID, non-empty destination, valid route choice).
 * 
 * 8.  **Output:** Use `System.out` for all normal messages and data displays.
 * 
 * 9.  **Best Practices:**
 *     *   Apply proper encapsulation (private fields, public methods).
 *     *   Use meaningful names for variables, methods, and classes.
 *     *   Include appropriate comments and Javadoc documentation.
 *     *   Ensure clean code structure.
 * 
 * **Expected Output Structure (Example):**
 * 
 * ```
 * Package Sorting System Menu:
 * 1. Add Package
 * 2. Sort Next Package
 * 3. View Sorting Queue
 * 4. View Delivery Route
 * 5. Exit
 * Enter your choice: 1
 * Enter Package ID: 101
 * Enter Destination Address: 123 Main St
 * Package 101 added to sorting queue.
 * 
 * Package Sorting System Menu:
 * ...
 * Enter your choice: 3
 * --- Sorting Queue ---
 * ID: 101, Destination: 123 Main St, Status: PENDING_SORT
 * ---------------------
 * 
 * Package Sorting System Menu:
 * ...
 * Enter your choice: 2
 * Processing package from queue...
 * Package 101 (Destination: 123 Main St) sorted.
 * Enter target route (A, B, C): A
 * Package 101 assigned to Route A.
 * 
 * Package Sorting System Menu:
 * ...
 * Enter your choice: 4
 * Enter route name (A, B, C): A
 * --- Packages on Route A ---
 * ID: 101, Destination: 123 Main St, Status: ON_ROUTE
 * -------------------------
 * 
 * Package Sorting System Menu:
 * ...
 * Enter your choice: 2
 * Sorting queue is empty. Cannot sort. (Printed to System.err)
 * 
 * Package Sorting System Menu:
 * ...
 * Enter your choice: 5
 * Exiting system.
 * ```
 * 
 * **Evaluation:**
 * Your solution will be evaluated based on:
 * *   Correct implementation of all required functionalities.
 * *   Proper usage of `Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.err`, `System.out`, and `try-catch`.
 * *   Adherence to best practices (encapsulation, naming, comments, validation, error handling, structure).
 * *   Handling of edge cases (empty queue, invalid input).
 * 
 * Good luck!
 *
 * EXPLANATION:
 * This solution implements a console-based `PackageSortingSystem` that simulates a basic package sorting facility, fulfilling all the requirements of the exam task.
 * 
 * 1.  **Package Class:**
 *     *   Represents a package with `id`, `destination`, and `status`.
 *     *   Uses an `enum` (`PackageStatus`) for clear status representation.
 *     *   Private fields and public getters ensure encapsulation.
 *     *   The constructor includes basic input validation for ID (positive) and destination (not empty), throwing `IllegalArgumentException` on failure.
 *     *   Includes a `toString()` method for easy printing of package details.
 * 
 * 2.  **SortingStation Class:**
 *     *   Manages the queue of packages awaiting sorting.
 *     *   Uses `java.util.Queue<Package>` implemented by `java.util.LinkedList`. `LinkedList` is a common and efficient choice for Queue operations (`offer`, `poll`).
 *     *   `addPackage(Package pkg)`: Uses `queue.offer()` to add packages.
 *     *   `pollNextPackage()`: Uses `queue.poll()` to remove and return the next package. `poll()` is used instead of `remove()` as it safely returns `null` if the queue is empty, avoiding an exception.
 *     *   `viewQueue()`: Returns an `ArrayList` copy of the queue contents. This allows viewing without modifying the original queue and demonstrates using `ArrayList` derived from a `Queue`. The return type is `List<Package>`, fulfilling the requirement to use the `List` interface type.
 *     *   `isQueueEmpty()`: Helper method to check the queue's state.
 * 
 * 3.  **PackageSortingSystem Class:**
 *     *   Contains the main application logic.
 *     *   Holds an instance of `SortingStation`.
 *     *   Uses a `Map<String, List<Package>>` (`deliveryRoutes`) to store packages assigned to different routes. The values in the map are `List<Package>`, specifically instantiated as `ArrayList<Package>`, satisfying the `ArrayList` and `List` interface requirements.
 *     *   Uses `java.util.Scanner` (`scanner`) for user input from `System.in`.
 *     *   `displayMenu()`: Prints the interactive menu options to `System.out`.
 *     *   `addPackage()`: Prompts for ID and destination. Includes `try-catch` around `Integer.parseInt` to handle non-integer input for the ID, printing an error to `System.err`. It also catches the `IllegalArgumentException` thrown by the `Package` constructor if validation fails, printing the error message to `System.err`.
 *     *   `sortNextPackage()`: Checks if the queue is empty using `sortingStation.isQueueEmpty()`, printing an error to `System.err` if so. If not empty, it calls `sortingStation.pollNextPackage()`. It then prompts for a route name, validates the input against `AVAILABLE_ROUTES`, and adds the sorted package to the corresponding `ArrayList` in the `deliveryRoutes` map. The package's status is updated accordingly.
 *     *   `viewSortingQueue()`: Calls `sortingStation.viewQueue()` which returns a `List<Package>` (an `ArrayList` copy) and iterates through it to print package details to `System.out`.
 *     *   `viewDeliveryRoute()`: Prompts for a route name, retrieves the corresponding `List<Package>` from the map, and iterates through it to print package details to `System.out`. Handles invalid route names by printing to `System.err`.
 *     *   `run()`: Contains the main application loop.
 *         *   It has a `try-catch` block wrapping the entire `while` loop. This serves as a class-wide exception handler for any unexpected runtime errors that might occur within the loop's execution, printing the error and stack trace to `System.err`.
 *         *   Inside the loop, it displays the menu and reads user input.
 *         *   Another `try-catch` block specifically handles `NumberFormatException` when parsing the user's menu choice, printing an error to `System.err`.
 *         *   A `switch` statement is used to control the flow based on the user's valid menu choice, calling the appropriate handler method.
 *         *   A `finally` block ensures the `Scanner` is closed when the `run` method exits (either normally or due to an exception), preventing resource leaks.
 *     *   `main()`: The entry point of the program, creating a `PackageSortingSystem` instance and calling its `run()` method.
 * 
 * This solution effectively integrates `Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.err`, `System.out`, and `try-catch` within a practical scenario, demonstrating proper object-oriented design, input validation, and error handling as required.
 */

import java.util.LinkedList;
import java.util.Queue;
import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;
import java.util.Map;
import java.util.HashMap;

// Enum for package status
enum PackageStatus {
    PENDING_SORT,
    SORTED, // Intermediate status after leaving queue, before route assignment
    ON_ROUTE
}

// Represents a package
class Package {
    private int id;
    private String destination;
    private PackageStatus status;

    /**
     * Constructs a new Package.
     * @param id The unique package ID. Must be positive.
     * @param destination The package's destination address. Cannot be null or empty.
     * @throws IllegalArgumentException if id is not positive or destination is invalid.
     */
    public Package(int id, String destination) {
        if (id <= 0) {
            throw new IllegalArgumentException("Package ID must be positive.");
        }
        if (destination == null || destination.trim().isEmpty()) {
            throw new IllegalArgumentException("Destination address cannot be empty.");
        }
        this.id = id;
        this.destination = destination.trim();
        this.status = PackageStatus.PENDING_SORT;
    }

    // Getters
    public int getId() {
        return id;
    }

    public String getDestination() {
        return destination;
    }

    public PackageStatus getStatus() {
        return status;
    }

    // Setter for status (controlled)
    public void setStatus(PackageStatus status) {
        this.status = status;
    }

    @Override
    public String toString() {
        return "ID: " + id + ", Destination: " + destination + ", Status: " + status;
    }
}

// Manages packages awaiting sorting
class SortingStation {
    private Queue<Package> sortingQueue;

    public SortingStation() {
        // LinkedList is a common implementation for Queue
        this.sortingQueue = new LinkedList<>();
    }

    /**
     * Adds a package to the sorting queue.
     * @param pkg The package to add.
     */
    public void addPackage(Package pkg) {
        if (pkg != null) {
            sortingQueue.offer(pkg); // offer is safer than add, returns false on failure
        } else {
            System.err.println("Attempted to add a null package to the queue.");
        }
    }

    /**
     * Removes and returns the next package from the queue for sorting.
     * @return The next package, or null if the queue is empty.
     */
    public Package pollNextPackage() {
        return sortingQueue.poll(); // poll is safer than remove, returns null if empty
    }

    /**
     * Returns a list of packages currently in the sorting queue without removing them.
     * @return A List view of packages in the queue.
     */
    public List<Package> viewQueue() {
        // Return a new ArrayList containing elements from the queue
        // This prevents external modification of the internal queue structure
        return new ArrayList<>(sortingQueue);
    }

    /**
     * Checks if the sorting queue is empty.
     * @return true if the queue is empty, false otherwise.
     */
    public boolean isQueueEmpty() {
        return sortingQueue.isEmpty();
    }
}

// Main system class managing the sorting station and routes
public class PackageSortingSystem {
    private SortingStation sortingStation;
    // Map to hold delivery routes, mapping route name (String) to a list of packages (List<Package>)
    private Map<String, List<Package>> deliveryRoutes;
    private Scanner scanner;

    // Define available routes
    private static final String[] AVAILABLE_ROUTES = {"A", "B", "C"};

    public PackageSortingSystem() {
        this.sortingStation = new SortingStation();
        this.deliveryRoutes = new HashMap<>();
        // Initialize routes
        for (String route : AVAILABLE_ROUTES) {
            deliveryRoutes.put(route, new ArrayList<>()); // Use ArrayList for routes
        }
        this.scanner = new Scanner(System.in);
    }

    /**
     * Displays the main menu to the user.
     */
    private void displayMenu() {
        System.out.println("\nPackage Sorting System Menu:");
        System.out.println("1. Add Package");
        System.out.println("2. Sort Next Package");
        System.out.println("3. View Sorting Queue");
        System.out.println("4. View Delivery Route");
        System.out.println("5. Exit");
        System.out.print("Enter your choice: ");
    }

    /**
     * Handles adding a new package based on user input.
     */
    private void addPackage() {
        System.out.print("Enter Package ID: ");
        int id = -1;
        try {
            id = Integer.parseInt(scanner.nextLine());
        } catch (NumberFormatException e) {
            System.err.println("Invalid input. Please enter a valid integer ID.");
            return;
        }

        System.out.print("Enter Destination Address: ");
        String destination = scanner.nextLine();

        try {
            Package newPackage = new Package(id, destination);
            sortingStation.addPackage(newPackage);
            System.out.println("Package " + id + " added to sorting queue.");
        } catch (IllegalArgumentException e) {
            System.err.println("Error creating package: " + e.getMessage());
        }
    }

    /**
     * Handles sorting the next package from the queue and assigning it to a route.
     */
    private void sortNextPackage() {
        if (sortingStation.isQueueEmpty()) {
            System.err.println("Sorting queue is empty. Cannot sort.");
            return;
        }

        Package pkg = sortingStation.pollNextPackage(); // Get package from queue
        if (pkg != null) {
            System.out.println("Processing package from queue...");
            pkg.setStatus(PackageStatus.SORTED); // Status after leaving queue

            System.out.println("Package " + pkg.getId() + " (Destination: " + pkg.getDestination() + ") sorted.");

            String routeName;
            boolean validRoute = false;
            do {
                System.out.print("Enter target route (" + String.join(", ", AVAILABLE_ROUTES) + "): ");
                routeName = scanner.nextLine().trim().toUpperCase();
                if (deliveryRoutes.containsKey(routeName)) {
                    validRoute = true;
                } else {
                    System.err.println("Invalid route name. Please enter one of: " + String.join(", ", AVAILABLE_ROUTES));
                }
            } while (!validRoute);

            List<Package> routePackages = deliveryRoutes.get(routeName);
            // Ensure the collection type is List<Package> as required
            if (routePackages != null) {
                routePackages.add(pkg);
                pkg.setStatus(PackageStatus.ON_ROUTE); // Status after assigning to route
                System.out.println("Package " + pkg.getId() + " assigned to Route " + routeName + ".");
            } else {
                 // This case should ideally not happen if routes are initialized correctly
                 System.err.println("Internal error: Route '" + routeName + "' not found in map.");
            }
        }
    }

    /**
     * Displays packages currently in the sorting queue.
     */
    private void viewSortingQueue() {
        List<Package> queueContents = sortingStation.viewQueue(); // Get packages as a List
        System.out.println("--- Sorting Queue ---");
        if (queueContents.isEmpty()) {
            System.out.println("Queue is empty.");
        } else {
            for (Package pkg : queueContents) {
                System.out.println(pkg);
            }
        }
        System.out.println("---------------------");
    }

    /**
     * Displays packages assigned to a specific delivery route.
     */
    private void viewDeliveryRoute() {
        System.out.print("Enter route name (" + String.join(", ", AVAILABLE_ROUTES) + "): ");
        String routeName = scanner.nextLine().trim().toUpperCase();

        List<Package> routePackages = deliveryRoutes.get(routeName); // Get packages as a List

        if (routePackages == null) {
            System.err.println("Invalid route name: " + routeName);
            return;
        }

        System.out.println("--- Packages on Route " + routeName + " ---");
        if (routePackages.isEmpty()) {
            System.out.println("Route " + routeName + " has no packages assigned.");
        } else {
            // Explicitly iterate over the List<Package>
            for (Package pkg : routePackages) {
                System.out.println(pkg);
            }
        }
        System.out.println("-------------------------");
    }

    /**
     * Runs the main application loop.
     */
    public void run() {
        int choice = -1;
        // Class-wide exception handling for the main loop
        try {
            while (choice != 5) {
                displayMenu();
                try {
                    choice = Integer.parseInt(scanner.nextLine());
                } catch (NumberFormatException e) {
                    System.err.println("Invalid input. Please enter a number.");
                    continue; // Skip to the next loop iteration
                }

                // Use switch statement for flow control
                switch (choice) {
                    case 1:
                        addPackage();
                        break;
                    case 2:
                        sortNextPackage();
                        break;
                    case 3:
                        viewSortingQueue();
                        break;
                    case 4:
                        viewDeliveryRoute();
                        break;
                    case 5:
                        System.out.println("Exiting system.");
                        break;
                    default:
                        System.err.println("Invalid choice. Please enter a number between 1 and 5.");
                }
            }
        } catch (Exception e) {
            // Catch any unexpected exceptions during execution
            System.err.println("An unexpected error occurred: " + e.getMessage());
            e.printStackTrace(System.err); // Print stack trace to System.err
        } finally {
            // Ensure scanner is closed
            scanner.close();
            System.out.println("Scanner closed.");
        }
    }

    public static void main(String[] args) {
        PackageSortingSystem system = new PackageSortingSystem();
        system.run();
    }
}
