/*
 * Exam Question #600
 * Generated on: 2025-05-12 16:12:58
 * Generated by: Account 4
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Event Check-in System
 * 
 * **Scenario:**
 * 
 * You are tasked with developing a simplified event check-in system for a conference. The system needs to manage a list of registered attendees and process attendees as they arrive and check in. Attendees who arrive form a waiting line (queue) and are processed one by one at the check-in desk.
 * 
 * **Requirements:**
 * 
 * 1.  **Attendee Management:**
 *     *   Create an `Attendee` class with private fields: `id` (int, unique), `name` (String), and `status` (an enum: `REGISTERED`, `WAITING`, `CHECKED_IN`).
 *     *   Include a constructor, public getters for all fields, and a method to update the status.
 *     *   Override `toString()` to provide a readable representation of an attendee (ID, Name, Status).
 * 
 * 2.  **Event Manager Class:**
 *     *   Create an `EventManager` class that manages the system's state.
 *     *   It must have:
 *         *   A `List<Attendee>` to store all registered attendees. Use `ArrayList` as the concrete implementation.
 *         *   A `Queue<Attendee>` to store attendees currently waiting in the check-in line. Use `LinkedList` as the concrete implementation.
 *         *   A private counter for generating unique attendee IDs.
 *     *   Implement the following public methods:
 *         *   `registerAttendee(String name)`: Creates a new `Attendee` with status `REGISTERED`, assigns a unique ID, adds them to the registered list, and prints a success message with the attendee's ID.
 *         *   `addAttendeeToCheckInQueue(int attendeeId)`: Finds the attendee by ID in the registered list. If found and their status is `REGISTERED`, update their status to `WAITING` and add them to the `checkInQueue`. Print success/failure messages using `System.out` or `System.err` respectively.
 *         *   `processNextInQueue()`: Removes the attendee at the front of the `checkInQueue`. If the queue is not empty, find this attendee in the registered list (they should be there), update their status to `CHECKED_IN`, and print a success message. If the queue is empty, print an informative message using `System.err`.
 *         *   `listAllAttendees()`: Prints details of all attendees currently in the registered list using their `toString()` method.
 * 
 * 3.  **Main Application Logic:**
 *     *   In the `main` method, create a `Scanner` object for user input and an `EventManager` object.
 *     *   Implement a command-line interface using a loop that presents the following options to the user:
 *         1.  Register Attendee
 *         2.  Add to Check-in Queue
 *         3.  Process Next in Queue
 *         4.  List All Attendees
 *         5.  Exit
 *     *   Use a `switch` statement to handle the user's choice.
 *     *   Implement robust input validation:
 *         *   For options 2 and 3, ensure the user enters a valid integer ID. Use a `try-catch` block to handle `java.util.InputMismatchException`. If invalid input is detected, print an error message to `System.err` and clear the invalid input from the scanner buffer.
 *         *   For option 1, ensure the name is not empty or just whitespace.
 *     *   Handle potential logical errors within the `EventManager` methods (e.g., attendee not found, queue empty) by printing messages to `System.err`.
 *     *   Use `System.out` for menu prompts, successful operations, and listing attendees.
 *     *   Use `System.err` for all error conditions (invalid input, attendee not found, queue empty, etc.).
 *     *   The main loop should continue until the user chooses the "Exit" option.
 * 
 * 4.  **Best Practices:**
 *     *   Use meaningful variable and method names.
 *     *   Include comments where necessary to explain complex logic.
 *     *   Ensure proper encapsulation (private fields, public methods).
 *     *   Use the `List` interface type for the registered attendees list variable, even though you'll instantiate it as `ArrayList`. Use the `Queue` interface type for the check-in queue variable, instantiated as `LinkedList`.
 *     *   Implement class-wide exception handling within the `main` loop for input parsing.
 * 
 * **Expected Output:**
 * 
 * The program should interact with the user via the console. Example interaction snippets:
 * 
 * ```
 * Event Check-in System Menu:
 * 1. Register Attendee
 * 2. Add to Check-in Queue
 * 3. Process Next in Queue
 * 4. List All Attendees
 * 5. Exit
 * Enter your choice: 1
 * Enter attendee name: Alice
 * 
 * Attendee registered successfully. ID: 1
 * 
 * Event Check-in System Menu:
 * ...
 * Enter your choice: 1
 * Enter attendee name: Bob
 * 
 * Attendee registered successfully. ID: 2
 * 
 * Event Check-in System Menu:
 * ...
 * Enter your choice: 2
 * Enter attendee ID to add to queue: 2
 * 
 * Attendee Bob (ID: 2) added to check-in queue.
 * 
 * Event Check-in System Menu:
 * ...
 * Enter your choice: 2
 * Enter attendee ID to add to queue: 1
 * 
 * Attendee Alice (ID: 1) added to check-in queue.
 * 
 * Event Check-in System Menu:
 * ...
 * Enter your choice: 3
 * 
 * Processing next in queue...
 * Attendee Bob (ID: 2) checked in successfully.
 * 
 * Event Check-in System Menu:
 * ...
 * Enter your choice: 3
 * 
 * Processing next in queue...
 * Attendee Alice (ID: 1) checked in successfully.
 * 
 * Event Check-in System Menu:
 * ...
 * Enter your choice: 3
 * System.err: Check-in queue is empty. No attendees to process.
 * 
 * Event Check-in System Menu:
 * ...
 * Enter your choice: 4
 * --- All Attendees ---
 * ID: 1, Name: Alice, Status: CHECKED_IN
 * ID: 2, Name: Bob, Status: CHECKED_IN
 * --- End of List ---
 * 
 * Event Check-in System Menu:
 * ...
 * Enter your choice: 2
 * Enter attendee ID to add to queue: 99
 * System.err: Attendee with ID 99 not found.
 * 
 * Event Check-in System Menu:
 * ...
 * Enter your choice: 2
 * Enter attendee ID to add to queue: abc
 * System.err: Invalid input. Please enter a numeric Attendee ID.
 * 
 * Event Check-in System Menu:
 * ...
 * Enter your choice: 5
 * 
 * Exiting system.
 * ```
 * 
 * Your solution should be a single Java file containing all necessary classes.
 *
 * EXPLANATION:
 * This solution implements a basic event check-in system demonstrating the required Java concepts and best practices.
 * 
 * 1.  **`AttendeeStatus` Enum:** Defines the possible states an attendee can be in (`REGISTERED`, `WAITING`, `CHECKED_IN`), providing clarity and type safety compared to using simple strings or integers for status.
 * 
 * 2.  **`Attendee` Class:** Represents the core data entity. It uses `private` fields (`id`, `name`, `status`) enforcing encapsulation. Public getter methods provide controlled access to the data. The `setStatus` method allows controlled modification of the status. `toString()` is overridden for easy printing of attendee details.
 * 
 * 3.  **`EventManager` Class:** This class acts as the central controller and data manager.
 *     *   `registeredAttendees`: Declared as `List<Attendee>` but instantiated as `ArrayList`. This demonstrates programming to the interface (`List`), which is a key best practice for flexibility, while using `ArrayList` for its common list functionalities.
 *     *   `checkInQueue`: Declared as `Queue<Attendee>` and instantiated as `LinkedList`. `LinkedList` implements the `Queue` interface and provides efficient operations for adding to the end and removing from the front, which are the primary needs for a queue. Using the `Queue` interface type ensures the code interacts with the queue using only standard queue operations (`offer`, `poll`), hiding the underlying implementation details.
 *     *   `nextAttendeeId`: A simple private counter for generating unique IDs, demonstrating a basic state management technique within the class.
 *     *   Methods (`registerAttendee`, `addAttendeeToCheckInQueue`, `processNextInQueue`, `listAllAttendees`): These methods encapsulate the system's logic. They interact with the `registeredAttendees` list and the `checkInQueue` queue.
 *     *   `findAttendeeById`: A helper method demonstrating iteration over the `registeredAttendees` list to find a specific attendee.
 *     *   Input validation (e.g., checking for empty name) and logical error handling (e.g., attendee not found, queue empty) are implemented within these methods, printing error messages to `System.err`.
 * 
 * 4.  **`EventCheckInSystem` Class (Main):**
 *     *   Contains the `main` method, the entry point of the application.
 *     *   A `Scanner` object is used to read user input from `System.in`.
 *     *   An `EventManager` object is created to handle the system's operations.
 *     *   A `while` loop provides the main application loop, continuing until the `running` flag is set to `false`.
 *     *   A `printMenu` helper method demonstrates modularity.
 *     *   A `switch` statement is used to direct the program flow based on the user's integer choice, fulfilling the requirement for using a switch statement.
 *     *   **Class-wide Exception Handling:** A `try-catch` block wraps the core logic inside the `while` loop. This `try-catch` specifically targets `InputMismatchException`, which occurs if the user enters non-integer input when an integer is expected (like the menu choice or attendee ID). This prevents the program from crashing due to invalid input and allows it to recover by printing an error message to `System.err` and consuming the invalid input from the scanner buffer (`scanner.nextLine()`). A general `Exception` catch is also included as a fallback for any other unexpected runtime errors.
 *     *   `System.out` is used for displaying the menu, prompts, and successful operation messages.
 *     *   `System.err` is used exclusively for printing error messages, directing them to the standard error stream as required.
 *     *   The `Scanner` resource is closed when the program exits.
 * 
 * This solution effectively integrates `Queue`, `ArrayList` (via `List`), `Scanner`, `switch`, `System.err`, `System.out`, and `try-catch` within a practical scenario, adhering to best practices like encapsulation, clear naming, and error handling, making it a challenging yet solvable task for demonstrating advanced Java understanding.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.InputMismatchException;

// Enum to represent the status of an attendee
enum AttendeeStatus {
    REGISTERED,
    WAITING,
    CHECKED_IN
}

// Represents an attendee at the event
class Attendee {
    private final int id;
    private String name;
    private AttendeeStatus status;

    /**
     * Constructs a new Attendee.
     * @param id The unique ID for the attendee.
     * @param name The name of the attendee.
     */
    public Attendee(int id, String name) {
        this.id = id;
        this.name = name;
        this.status = AttendeeStatus.REGISTERED; // Default status
    }

    // Getters
    public int getId() {
        return id;
    }

    public String getName() {
        return name;
    }

    public AttendeeStatus getStatus() {
        return status;
    }

    /**
     * Updates the status of the attendee.
     * @param status The new status.
     */
    public void setStatus(AttendeeStatus status) {
        this.status = status;
    }

    @Override
    public String toString() {
        return String.format("ID: %d, Name: %s, Status: %s", id, name, status);
    }
}

// Manages attendees and the check-in process
class EventManager {
    // List to store all registered attendees (using List interface, implemented by ArrayList)
    private List<Attendee> registeredAttendees;
    // Queue for attendees waiting to check in (using Queue interface, implemented by LinkedList)
    private Queue<Attendee> checkInQueue;
    // Counter for generating unique attendee IDs
    private int nextAttendeeId;

    /**
     * Constructs a new EventManager.
     * Initializes the lists and ID counter.
     */
    public EventManager() {
        // Use ArrayList for the registered attendees list
        this.registeredAttendees = new ArrayList<>();
        // Use LinkedList for the check-in queue (implements Queue)
        this.checkInQueue = new LinkedList<>();
        this.nextAttendeeId = 1; // Start IDs from 1
    }

    /**
     * Registers a new attendee with the given name.
     * @param name The name of the attendee.
     */
    public void registerAttendee(String name) {
        // Input validation: check if name is null or empty/whitespace
        if (name == null || name.trim().isEmpty()) {
            System.err.println("Error: Attendee name cannot be empty.");
            return;
        }

        Attendee newAttendee = new Attendee(nextAttendeeId++, name.trim());
        registeredAttendees.add(newAttendee);
        System.out.println("\nAttendee registered successfully. " + newAttendee);
    }

    /**
     * Finds an attendee by their ID.
     * @param attendeeId The ID of the attendee to find.
     * @return The Attendee object if found, otherwise null.
     */
    private Attendee findAttendeeById(int attendeeId) {
        for (Attendee attendee : registeredAttendees) {
            if (attendee.getId() == attendeeId) {
                return attendee;
            }
        }
        return null; // Attendee not found
    }

    /**
     * Adds an attendee to the check-in queue if they are registered and not already waiting or checked in.
     * @param attendeeId The ID of the attendee to add to the queue.
     */
    public void addAttendeeToCheckInQueue(int attendeeId) {
        Attendee attendee = findAttendeeById(attendeeId);

        if (attendee == null) {
            System.err.println("Error: Attendee with ID " + attendeeId + " not found.");
            return;
        }

        // Check current status before adding to queue
        AttendeeStatus currentStatus = attendee.getStatus();
        if (currentStatus == AttendeeStatus.REGISTERED) {
            attendee.setStatus(AttendeeStatus.WAITING);
            checkInQueue.offer(attendee); // offer is generally preferred over add in queues
            System.out.println("\nAttendee " + attendee.getName() + " (ID: " + attendee.getId() + ") added to check-in queue.");
        } else if (currentStatus == AttendeeStatus.WAITING) {
            System.err.println("Error: Attendee " + attendee.getName() + " (ID: " + attendee.getId() + ") is already in the check-in queue.");
        } else { // CHECKED_IN
            System.err.println("Error: Attendee " + attendee.getName() + " (ID: " + attendee.getId() + ") has already checked in.");
        }
    }

    /**
     * Processes the next attendee in the check-in queue.
     * Updates their status to CHECKED_IN.
     */
    public void processNextInQueue() {
        System.out.println("\nProcessing next in queue...");
        Attendee nextAttendee = checkInQueue.poll(); // Retrieves and removes the head of the queue

        if (nextAttendee == null) {
            System.err.println("Error: Check-in queue is empty. No attendees to process.");
            return;
        }

        // Find the attendee in the registered list to update their status
        // This loop is technically redundant if we trust the queue only contains registered attendees,
        // but it reinforces the idea of updating the master list state.
        // A more efficient approach might pass the registered list reference to the Attendee
        // or have the Attendee manage its own state with a reference back to the manager (less ideal).
        // For this problem, re-finding is acceptable and demonstrates list iteration.
        Attendee registeredAttendee = findAttendeeById(nextAttendee.getId());

        if (registeredAttendee != null) { // Should not be null if logic is correct
            registeredAttendee.setStatus(AttendeeStatus.CHECKED_IN);
            System.out.println("Attendee " + registeredAttendee.getName() + " (ID: " + registeredAttendee.getId() + ") checked in successfully.");
        } else {
            // This indicates a potential logical error in queue management
            System.err.println("Internal Error: Processed attendee from queue (ID: " + nextAttendee.getId() + ") not found in registered list.");
        }
    }

    /**
     * Lists all registered attendees and their current status.
     */
    public void listAllAttendees() {
        System.out.println("\n--- All Attendees ---");
        if (registeredAttendees.isEmpty()) {
            System.out.println("No attendees registered yet.");
        } else {
            for (Attendee attendee : registeredAttendees) {
                System.out.println(attendee); // Uses Attendee's toString()
            }
        }
        System.out.println("--- End of List ---");
    }
}

// Main class to run the Event Check-in System
public class EventCheckInSystem {

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        EventManager eventManager = new EventManager();
        boolean running = true;

        System.out.println("Welcome to the Event Check-in System!");

        // Main application loop
        while (running) {
            printMenu(); // Display menu options
            int choice = -1; // Default invalid choice

            // Class-wide exception handling for input
            try {
                System.out.print("Enter your choice: ");
                choice = scanner.nextInt(); // Read integer input
                // Consume the rest of the line after reading the integer
                scanner.nextLine();

                // Use switch statement for flow control based on user choice
                switch (choice) {
                    case 1:
                        System.out.print("Enter attendee name: ");
                        String name = scanner.nextLine();
                        eventManager.registerAttendee(name); // Validation handled inside method
                        break;
                    case 2:
                        System.out.print("Enter attendee ID to add to queue: ");
                        // No need for another try-catch here because the outer one handles InputMismatchException
                        int idToAdd = scanner.nextInt();
                        scanner.nextLine(); // Consume newline
                        eventManager.addAttendeeToCheckInQueue(idToAdd); // Validation handled inside method
                        break;
                    case 3:
                        eventManager.processNextInQueue(); // Handles empty queue with System.err
                        break;
                    case 4:
                        eventManager.listAllAttendees();
                        break;
                    case 5:
                        System.out.println("\nExiting system.");
                        running = false; // Set flag to exit loop
                        break;
                    default:
                        // Handle invalid menu choices
                        System.err.println("Error: Invalid choice. Please enter a number between 1 and 5.");
                }

            } catch (InputMismatchException e) {
                // Catch non-integer input for menu choice or ID
                System.err.println("Error: Invalid input. Please enter a number.");
                scanner.nextLine(); // IMPORTANT: Consume the invalid input to prevent infinite loop
            } catch (Exception e) {
                // Catch any other unexpected exceptions
                System.err.println("An unexpected error occurred: " + e.getMessage());
                e.printStackTrace(); // Print stack trace for debugging unexpected errors
            }
            // The loop continues, presenting the menu again unless running is false
        }

        scanner.close(); // Close the scanner resource
    }

    /**
     * Prints the main menu options to the console.
     */
    private static void printMenu() {
        System.out.println("\nEvent Check-in System Menu:");
        System.out.println("1. Register Attendee");
        System.out.println("2. Add to Check-in Queue");
        System.out.println("3. Process Next in Queue");
        System.out.println("4. List All Attendees");
        System.out.println("5. Exit");
    }
}
