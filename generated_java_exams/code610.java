/*
 * Exam Question #610
 * Generated on: 2025-05-12 16:14:17
 * Generated by: Account 1
 * 
 * QUESTION:
 * **Java Programming Exam Task: Vehicle Service Center Queue Management System**
 * 
 * **Problem Description:**
 * 
 * You are tasked with developing a simplified Vehicle Service Center management system. The system should manage vehicles waiting for service, track vehicles currently being serviced in bays, and maintain a list of completed service jobs.
 * 
 * The service center has a waiting line for vehicles (a queue) and a fixed number of service bays. Vehicles arrive and are added to the waiting line. When a service bay becomes free, the next vehicle from the waiting line is moved into the bay. Once service is complete, the vehicle is moved from the bay to a list of completed jobs, and the bay becomes free.
 * 
 * Your program should provide a command-line interface for interacting with the system.
 * 
 * **System Requirements:**
 * 
 * 1.  **Vehicle Representation:** Create a `Vehicle` class with attributes like a unique ID (assigned by the system), type (e.g., Car, Truck, Motorcycle), a brief problem description, and a status (e.g., "Waiting", "Servicing", "Completed").
 * 2.  **Service Bay Representation:** Create a `ServiceBay` class representing a service bay. Each bay should have an ID and track whether it's occupied and which `Vehicle` (if any) is currently in it.
 * 3.  **Service Center Logic:** Create a `ServiceCenter` class that manages the system. It should contain:
 *     *   A **Queue** to hold vehicles waiting for service.
 *     *   An **ArrayList** to hold the `ServiceBay` objects. The number of bays should be configurable (e.g., passed to the constructor).
 *     *   A **List** (specifically using `ArrayList` which implements `List`) to hold vehicles whose service is completed.
 * 4.  **User Interface:** Implement a command-line menu using `Scanner` for user input. The menu should offer the following options:
 *     *   Add a new vehicle to the waiting queue.
 *     *   Assign the next vehicle from the queue to an available service bay.
 *     *   Complete service for a vehicle in a specific bay.
 *     *   List the current status (vehicles in queue, vehicles in bays, completed jobs).
 *     *   Exit the program.
 * 5.  **Flow Control:** Use a `switch` statement to handle the different menu options.
 * 6.  **Output:**
 *     *   Use `System.out` for displaying the menu, system status, and successful operation messages.
 *     *   Use `System.err` for displaying error messages (e.g., invalid input, no bays available, queue is empty, invalid bay selection, bay not occupied).
 * 7.  **Error Handling:**
 *     *   Implement **class-wide exception handling** using `try-catch` blocks to gracefully handle potential runtime errors, especially around user input (e.g., `InputMismatchException` when expecting a number but getting text).
 *     *   Validate user input where necessary (e.g., bay index validity).
 *     *   Handle scenarios like trying to assign a vehicle when the queue is empty or no bays are free, or trying to complete service in an empty or invalid bay.
 * 8.  **Best Practices:**
 *     *   Apply proper encapsulation (private fields, public methods).
 *     *   Use meaningful variable and method names.
 *     *   Include appropriate comments and documentation (Javadocs are a plus but not strictly required for all methods in an exam setting, but explaining the core logic is important).
 *     *   Ensure clean code structure.
 * 
 * **Constraints:**
 * 
 * *   You *must* use `java.util.Queue`, `java.util.ArrayList`, `java.util.List`, `java.util.Scanner`, `switch`, `System.err`, `System.out`, and `try-catch` blocks.
 * *   The number of service bays should be initialized when the `ServiceCenter` is created (e.g., pass it to the constructor).
 * 
 * **Expected Output Format (Example for Status):**
 * 
 * ```
 * --- Service Center Status ---
 * Waiting Queue (2 vehicles):
 * ID: 1, Type: Car, Problem: Oil Change
 * ID: 2, Type: Truck, Problem: Tire Rotation
 * 
 * Service Bays (3 bays):
 * Bay 0: Occupied by Vehicle ID 3 (Car, Problem: Brake Check)
 * Bay 1: Available
 * Bay 2: Occupied by Vehicle ID 4 (Motorcycle, Problem: Chain Lube)
 * 
 * Completed Jobs (5 vehicles):
 * ID: 5, Type: Car, Problem: Tune-up (Completed)
 * ID: 6, Type: Truck, Problem: Alignment (Completed)
 * ...
 * -----------------------------
 * ```
 * 
 * Implement the Java code for this system.
 *
 * EXPLANATION:
 * The provided solution implements a basic Vehicle Service Center management system, demonstrating the required Java concepts and best practices.
 * 
 * **Structure:**
 * 
 * The solution is organized into three classes:
 * 1.  `Vehicle`: Represents a vehicle with its details and status.
 * 2.  `ServiceBay`: Represents a service bay, tracking its occupancy and the vehicle within it.
 * 3.  `ServiceCenter`: The main class that orchestrates the operations, managing the queues, bays, and user interaction.
 * 
 * **Required Components Usage:**
 * 
 * 1.  **`java.util.Queue`**: The `waitingQueue` field in `ServiceCenter` is declared as a `Queue<Vehicle>`. It's initialized using `new LinkedList<>()`, as `LinkedList` is a common implementation of the `Queue` interface. `offer()` is used to add vehicles to the tail, and `poll()` is used to retrieve and remove vehicles from the head (FIFO behavior).
 * 2.  **`java.util.ArrayList`**: The `serviceBays` field is explicitly declared and initialized as an `ArrayList<ServiceBay>`. This fulfills the requirement to use `ArrayList`. It's used to store and access the service bays by index.
 * 3.  **`java.util.List`**: The `completedJobs` field is declared as a `List<Vehicle>`. It's initialized using `new ArrayList<>()`, demonstrating how `ArrayList` implements the `List` interface. Completed vehicles are added to this list using the `add()` method.
 * 4.  **`java.util.Scanner`**: A `Scanner` object is used in the `ServiceCenter` class's `runMenu()` method to read user input from `System.in`.
 * 5.  **`switch` statement**: The `runMenu()` method uses a `switch` statement based on the user's integer choice to direct the program flow to the appropriate action (add vehicle, assign bay, complete service, list status, or exit).
 * 6.  **`System.err`**: Used to print error messages to the standard error stream, such as invalid menu choices, input errors, or operational errors (e.g., queue empty, no bays available).
 * 7.  **`System.out`**: Used for normal output, including printing the menu, prompts, confirmation messages, and the service center status.
 * 8.  **Class-wide exception handling with `try-catch`**:
 *     *   The main `runMenu()` loop is wrapped in a `try-finally` block to ensure the `Scanner` is closed.
 *     *   Inside the loop, a nested `try-catch` block specifically handles `InputMismatchException` that might occur if the user enters non-integer input when an integer is expected by `scanner.nextInt()`. It prints an error to `System.err` and consumes the invalid input to prevent an infinite loop.
 *     *   A general `catch (Exception e)` is included in the inner `try-catch` to catch any other unexpected exceptions during the processing of a menu choice, printing an error to `System.err` and the stack trace.
 * 
 * **Best Practices:**
 * 
 * *   **Encapsulation:** Fields in `Vehicle`, `ServiceBay`, and `ServiceCenter` are declared as `private`. Public getter methods (and a setter for status in `Vehicle`) are provided where external access is needed.
 * *   **Meaningful Names:** Class names (`Vehicle`, `ServiceBay`, `ServiceCenter`), variable names (`waitingQueue`, `serviceBays`, `completedJobs`, `problemDescription`, `bayIndex`), and method names (`addVehicleToQueue`, `assignVehicleToBay`, `completeService`, `listStatus`, `runMenu`) are descriptive.
 * *   **Comments and Documentation:** Javadoc-style comments are included for the main methods in `ServiceCenter` explaining their purpose and parameters. Inline comments clarify specific logic points.
 * *   **Input Validation:** The `completeService` method checks if the entered `bayIndex` is within the valid range of service bays. The `try-catch` for `InputMismatchException` handles incorrect data types for input.
 * *   **Error Handling:** Specific error messages are provided via `System.err` for various failure conditions (queue empty, no bays free, invalid bay, bay not occupied), guiding the user.
 * *   **Clean Code Structure:** The code is divided into logical classes, and methods within `ServiceCenter` are kept relatively focused on a single task (adding, assigning, completing, listing).
 * 
 * **Logic Flow:**
 * 
 * 1.  The `main` method creates a `ServiceCenter` instance with a specified number of bays and calls `runMenu()`.
 * 2.  `runMenu()` enters a loop, repeatedly printing the menu and prompting for user input.
 * 3.  User input is read using `Scanner`.
 * 4.  A `switch` statement processes the input choice.
 * 5.  Based on the choice, the corresponding method (`addVehicleToQueue`, `assignVehicleToBay`, `completeService`, `listStatus`) is called.
 * 6.  These methods interact with the `waitingQueue`, `serviceBays`, and `completedJobs` collections, updating the system state.
 * 7.  Input validation and error conditions (like attempting to assign from an empty queue) are checked within the methods, printing messages to `System.err` if errors occur.
 * 8.  The `try-catch` blocks handle unexpected input types or other runtime issues during menu processing.
 * 9.  The loop continues until the user enters '0' to exit.
 * 10. The `finally` block ensures the `Scanner` resource is closed.
 * 
 * This solution effectively integrates all the required Java components into a practical scenario, demonstrating object-oriented design, collection usage, user interaction, and robust error handling suitable for an advanced exam task.
 */

import java.util.ArrayList;
import java.util.LinkedList; // LinkedList implements Queue and List
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.InputMismatchException;

// Represents a vehicle needing service
class Vehicle {
    private int id;
    private String type;
    private String problemDescription;
    private String status; // e.g., "Waiting", "Servicing", "Completed"

    public Vehicle(int id, String type, String problemDescription) {
        this.id = id;
        this.type = type;
        this.problemDescription = problemDescription;
        this.status = "Waiting";
    }

    // --- Getters ---
    public int getId() {
        return id;
    }

    public String getType() {
        return type;
    }

    public String getProblemDescription() {
        return problemDescription;
    }

    public String getStatus() {
        return status;
    }

    // --- Setter ---
    public void setStatus(String status) {
        this.status = status;
    }

    @Override
    public String toString() {
        return "ID: " + id + ", Type: " + type + ", Problem: " + problemDescription + (status.equals("Completed") ? " (" + status + ")" : "");
    }
}

// Represents a service bay
class ServiceBay {
    private int id;
    private boolean isOccupied;
    private Vehicle currentVehicle;

    public ServiceBay(int id) {
        this.id = id;
        this.isOccupied = false;
        this.currentVehicle = null;
    }

    // --- Getters ---
    public int getId() {
        return id;
    }

    public boolean isOccupied() {
        return isOccupied;
    }

    public Vehicle getCurrentVehicle() {
        return currentVehicle;
    }

    // --- Methods to manage bay state ---
    public void occupy(Vehicle vehicle) {
        if (this.isOccupied) {
            // Should not happen with proper logic in ServiceCenter
            System.err.println("Error: Bay " + id + " is already occupied.");
            return;
        }
        this.currentVehicle = vehicle;
        this.isOccupied = true;
        vehicle.setStatus("Servicing");
        System.out.println("Vehicle ID " + vehicle.getId() + " assigned to Bay " + this.id);
    }

    public Vehicle free() {
        if (!this.isOccupied) {
            // Should not happen with proper logic in ServiceCenter
            System.err.println("Error: Bay " + id + " is already free.");
            return null;
        }
        Vehicle completedVehicle = this.currentVehicle;
        this.currentVehicle = null;
        this.isOccupied = false;
        System.out.println("Bay " + this.id + " is now free.");
        return completedVehicle;
    }

    @Override
    public String toString() {
        if (isOccupied) {
            return "Bay " + id + ": Occupied by " + currentVehicle.toString();
        } else {
            return "Bay " + id + ": Available";
        }
    }
}

// Manages the service center operations
public class ServiceCenter {
    private Queue<Vehicle> waitingQueue;
    private ArrayList<ServiceBay> serviceBays; // Using ArrayList directly as required
    private List<Vehicle> completedJobs;      // Using List interface, implemented by ArrayList
    private int nextVehicleId;
    private Scanner scanner;

    public ServiceCenter(int numberOfBays) {
        this.waitingQueue = new LinkedList<>(); // LinkedList implements Queue
        this.serviceBays = new ArrayList<>(numberOfBays);
        for (int i = 0; i < numberOfBays; i++) {
            this.serviceBays.add(new ServiceBay(i));
        }
        this.completedJobs = new ArrayList<>(); // ArrayList implements List
        this.nextVehicleId = 1;
        this.scanner = new Scanner(System.in);
    }

    // --- Core Service Center Operations ---

    /**
     * Adds a new vehicle to the waiting queue.
     * @param type The type of vehicle (e.g., Car, Truck).
     * @param problemDescription The description of the problem.
     */
    public void addVehicleToQueue(String type, String problemDescription) {
        Vehicle newVehicle = new Vehicle(nextVehicleId++, type, problemDescription);
        waitingQueue.offer(newVehicle); // offer is preferred over add for queues
        System.out.println("Vehicle ID " + newVehicle.getId() + " added to waiting queue.");
    }

    /**
     * Assigns the next vehicle from the queue to the first available bay.
     */
    public void assignVehicleToBay() {
        if (waitingQueue.isEmpty()) {
            System.err.println("Error: Waiting queue is empty. No vehicles to assign.");
            return;
        }

        ServiceBay availableBay = null;
        for (ServiceBay bay : serviceBays) {
            if (!bay.isOccupied()) {
                availableBay = bay;
                break; // Found an available bay
            }
        }

        if (availableBay == null) {
            System.err.println("Error: No service bays are currently available.");
            return;
        }

        Vehicle vehicleToService = waitingQueue.poll(); // poll retrieves and removes the head of the queue
        if (vehicleToService != null) {
            availableBay.occupy(vehicleToService);
        } else {
             // This case should ideally not be reached due to the isEmpty check,
             // but poll returns null if empty, so it's good practice.
             System.err.println("Error: Could not retrieve vehicle from queue.");
        }
    }

    /**
     * Completes service for the vehicle in the specified bay.
     * @param bayIndex The index of the bay (0-based).
     */
    public void completeService(int bayIndex) {
        if (bayIndex < 0 || bayIndex >= serviceBays.size()) {
            System.err.println("Error: Invalid bay index. Please enter a number between 0 and " + (serviceBays.size() - 1) + ".");
            return;
        }

        ServiceBay bay = serviceBays.get(bayIndex);

        if (!bay.isOccupied()) {
            System.err.println("Error: Bay " + bay.getId() + " is not occupied.");
            return;
        }

        Vehicle completedVehicle = bay.free();
        if (completedVehicle != null) {
            completedVehicle.setStatus("Completed");
            completedJobs.add(completedVehicle); // Add to the list of completed jobs
            System.out.println("Service completed for Vehicle ID " + completedVehicle.getId() + " in Bay " + bay.getId() + ".");
        } else {
             // Should not happen if bay was occupied, but defensive programming
             System.err.println("Error: Could not retrieve vehicle from bay " + bay.getId() + " after freeing.");
        }
    }

    /**
     * Lists the current status of the queue, bays, and completed jobs.
     */
    public void listStatus() {
        System.out.println("\n--- Service Center Status ---");

        System.out.println("Waiting Queue (" + waitingQueue.size() + " vehicles):");
        if (waitingQueue.isEmpty()) {
            System.out.println("  (Empty)");
        } else {
            // Iterate without removing elements
            for (Vehicle vehicle : waitingQueue) {
                System.out.println("  " + vehicle);
            }
        }

        System.out.println("\nService Bays (" + serviceBays.size() + " bays):");
        for (ServiceBay bay : serviceBays) {
            System.out.println("  " + bay);
        }

        System.out.println("\nCompleted Jobs (" + completedJobs.size() + " vehicles):");
        if (completedJobs.isEmpty()) {
            System.out.println("  (Empty)");
        } else {
            for (Vehicle vehicle : completedJobs) {
                System.out.println("  " + vehicle);
            }
        }
        System.out.println("-----------------------------\n");
    }

    // --- Main Application Loop ---

    /**
     * Runs the main interactive menu for the service center.
     */
    public void runMenu() {
        int choice = -1;

        // Class-wide exception handling for the main menu loop
        try {
            while (choice != 0) {
                printMenu();
                System.out.print("Enter your choice: ");

                try {
                    choice = scanner.nextInt();
                    scanner.nextLine(); // Consume newline left-over

                    // Use switch statement for menu options
                    switch (choice) {
                        case 1:
                            System.out.print("Enter vehicle type: ");
                            String type = scanner.nextLine();
                            System.out.print("Enter problem description: ");
                            String problem = scanner.nextLine();
                            addVehicleToQueue(type, problem);
                            break;
                        case 2:
                            assignVehicleToBay();
                            break;
                        case 3:
                            System.out.print("Enter bay index to complete service (0 to " + (serviceBays.size() - 1) + "): ");
                            int bayIndex = scanner.nextInt();
                            scanner.nextLine(); // Consume newline
                            completeService(bayIndex);
                            break;
                        case 4:
                            listStatus();
                            break;
                        case 0:
                            System.out.println("Exiting Service Center System. Goodbye!");
                            break;
                        default:
                            System.err.println("Error: Invalid choice. Please enter a number from the menu.");
                    }
                } catch (InputMismatchException e) {
                    System.err.println("Error: Invalid input. Please enter a number.");
                    scanner.nextLine(); // Consume the invalid input to prevent infinite loop
                    choice = -1; // Reset choice to continue loop
                } catch (Exception e) {
                    // Catch any other unexpected exceptions during menu processing
                    System.err.println("An unexpected error occurred: " + e.getMessage());
                    e.printStackTrace(); // Print stack trace for debugging
                }
            }
        } finally {
            // Ensure scanner is closed when exiting the loop (either normally or via exception)
            scanner.close();
            System.out.println("Scanner closed.");
        }
    }

    /**
     * Prints the main menu options.
     */
    private void printMenu() {
        System.out.println("\n--- Service Center Menu ---");
        System.out.println("1. Add Vehicle to Queue");
        System.out.println("2. Assign Vehicle to Bay");
        System.out.println("3. Complete Service in Bay");
        System.out.println("4. List Status");
        System.out.println("0. Exit");
        System.out.println("---------------------------");
    }

    // Main method to start the application
    public static void main(String[] args) {
        // Example: Create a service center with 3 bays
        ServiceCenter center = new ServiceCenter(3);
        center.runMenu();
    }
}
