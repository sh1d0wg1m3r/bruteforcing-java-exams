/*
 * Exam Question #904
 * Generated on: 2025-05-12 16:57:34
 * Generated by: Account 1
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Warehouse Inventory and Order Processing System
 * 
 * **Problem Description:**
 * 
 * You are tasked with developing a simplified Warehouse Inventory and Order Processing system. The system should manage a list of products in stock and process incoming customer orders from a queue. Users should be able to interact with the system via a command-line interface.
 * 
 * **System Requirements:**
 * 
 * 1.  **Product Management:**
 *     *   Maintain a list of products in the warehouse. Each product should have a unique ID (integer), a name (String), a quantity in stock (integer), and a price (double).
 *     *   Allow adding new products to the inventory.
 *     *   Allow viewing the current inventory list.
 * 
 * 2.  **Order Management:**
 *     *   Maintain a queue of incoming customer orders.
 *     *   Each order should have a unique Order ID (integer) and contain a list of requested items. Each requested item specifies a Product ID and the desired quantity.
 *     *   Allow adding new orders to the queue.
 *     *   Allow viewing the list of pending orders in the queue.
 *     *   Implement a function to process the next order in the queue. Processing an order involves checking if sufficient stock exists for *all* requested items.
 *         *   If stock is sufficient for *all* items, decrement the stock for each item and mark the order as successfully processed.
 *         *   If stock is insufficient for *any* item, the order *fails*. Do not decrement stock for any item in this failed order. Mark the order as failed and indicate which product had insufficient stock.
 *     *   After processing, the order should be removed from the queue.
 * 
 * 3.  **User Interface:**
 *     *   Provide a text-based menu with options:
 *         1.  Add Product
 *         2.  Add Order
 *         3.  Process Next Order
 *         4.  View Inventory
 *         5.  View Pending Orders
 *         6.  Exit
 *     *   Use `java.util.Scanner` to read user input.
 *     *   Use a `switch` statement to handle menu selections.
 * 
 * 4.  **Error Handling and Validation:**
 *     *   Validate user input (e.g., ensure quantities/prices are positive, product IDs exist).
 *     *   Use `System.err` to display error messages (e.g., "Invalid input", "Product ID not found", "Insufficient stock", "Order queue is empty").
 *     *   Use `System.out` for normal output (menu, inventory list, order details, success messages).
 *     *   Implement class-wide or main loop level exception handling using `try-catch` blocks to gracefully handle unexpected errors (like non-integer input when an integer is expected).
 * 
 * **Required Java Components:**
 * 
 * Your solution *must* use all of the following:
 * *   `java.util.Queue`
 * *   `java.util.ArrayList`
 * *   `java.util.List` (used as interface type)
 * *   `java.util.Scanner`
 * *   `switch` statement
 * *   `System.err`
 * *   `System.out`
 * *   `try-catch` blocks for exception handling
 * 
 * **Best Practices:**
 * 
 * *   Use meaningful variable and method names.
 * *   Employ proper encapsulation (private fields, public methods/getters).
 * *   Include appropriate comments and basic documentation (e.g., Javadoc for classes/methods).
 * *   Structure your code logically into appropriate classes (`Product`, `Order`, `Warehouse`).
 * 
 * **Expected Output:**
 * 
 * The system should print a menu, accept user input, perform the requested action, print results or errors, and loop until the user chooses to exit. Output format for inventory and orders should be clear and readable. Error messages should be distinct (using `System.err`).
 * 
 * **Example Interaction Snippet (Illustrative):**
 * 
 * ```
 * --- Warehouse Menu ---
 * 1. Add Product
 * 2. Add Order
 * 3. Process Next Order
 * 4. View Inventory
 * 5. View Pending Orders
 * 6. Exit
 * Enter your choice: 1
 * Enter Product ID: 101
 * Enter Product Name: Laptop
 * Enter Quantity: 50
 * Enter Price: 1200.50
 * Product added successfully.
 * 
 * --- Warehouse Menu ---
 * 1. Add Product
 * 2. Add Order
 * 3. Process Next Order
 * 4. View Inventory
 * 5. View Pending Orders
 * 6. Exit
 * Enter your choice: 4
 * --- Current Inventory ---
 * ID: 101, Name: Laptop, Quantity: 50, Price: $1200.50
 * 
 * --- Warehouse Menu ---
 * ... (user adds more products, adds an order) ...
 * 
 * Enter your choice: 3
 * Processing Order ID: 501
 * Checking stock for Product ID 101 (Quantity: 2) ... Sufficient stock.
 * Checking stock for Product ID 102 (Quantity: 10) ... Insufficient stock (Needed: 10, Available: 5).
 * Order ID 501 failed due to insufficient stock for Product ID 102. Stock levels unchanged.
 * 
 * --- Warehouse Menu ---
 * ... (user continues) ...
 * ```
 * 
 * **Time Limit:** 45-60 minutes
 * 
 * **Note:** You should create separate classes for `Product`, `Order`, and the main `Warehouse` logic. The `main` method should reside in the `Warehouse` class.
 *
 * EXPLANATION:
 * This solution implements a basic Warehouse Inventory and Order Processing system demonstrating the required Java concepts.
 * 
 * 1.  **Class Structure:**
 *     *   `Product`: Encapsulates product data (ID, name, quantity, price) with private fields and public getters/setters. Includes a `toString()` for easy printing.
 *     *   `OrderItem`: A simple class to represent a product and quantity requested within an order.
 *     *   `Order`: Encapsulates order data (Order ID, list of `OrderItem`s, status). Uses an `ArrayList` to store the items for that specific order. Includes methods to add items and set status. Includes a `toString()` for easy printing.
 *     *   `Warehouse`: The main class containing the core logic. It holds the inventory (`List<Product>`) and the pending orders queue (`Queue<Order>`). It contains methods for each menu option and the `main` method for the application loop.
 * 
 * 2.  **Required Components Usage:**
 *     *   `java.util.List`: The `inventory` is declared as `List<Product>`, promoting interface-based programming.
 *     *   `java.util.ArrayList`: `inventory` is instantiated as an `ArrayList`, a concrete implementation of `List` suitable for dynamic resizing and access by index (though primarily iterated here). The `items` list within the `Order` class also uses `ArrayList`.
 *     *   `java.util.Queue`: The `pendingOrders` is declared as `Queue<Order>`, representing a First-In, First-Out collection.
 *     *   `java.util.LinkedList`: `pendingOrders` is instantiated as a `LinkedList`, which is a common and efficient implementation of the `Queue` interface. `offer()` is used to add to the end, `peek()` to view the head without removing, and `poll()` to remove the head.
 *     *   `java.util.Scanner`: An instance is created in the `Warehouse` class to read user input from `System.in`. It's used within the `main` loop and the `addProduct`, `addOrder` methods.
 *     *   `switch` statement: Used in the `main` method's loop to direct execution based on the user's menu choice.
 *     *   `System.err`: Used specifically for printing error messages (e.g., invalid input, product not found, insufficient stock, empty queue).
 *     *   `System.out`: Used for all normal output, such as the menu, prompts, success messages, inventory listing, and pending order details.
 *     *   `try-catch` blocks:
 *         *   A primary `try-catch` block wraps the main application loop in the `main` method. This catches general exceptions that might occur during the loop execution, including `InputMismatchException` from `Scanner` if the user enters non-numeric input when an integer is expected.
 *         *   Specific `try-catch` blocks are also included within `addProduct` and `addOrder` to handle `InputMismatchException` locally during input reading for those specific operations, allowing the main loop to continue even if input fails for one action.
 *         *   A `try-catch` is used within `processNextOrder` to catch any unexpected errors during the processing logic itself.
 * 
 * 3.  **Business Logic Implementation:**
 *     *   **Add Product:** Prompts for product details, performs basic validation (positive ID, non-negative quantity/price, non-empty name, checks for duplicate ID), creates a `Product` object, and adds it to the `inventory` `ArrayList`.
 *     *   **Add Order:** Prompts for order ID and a list of items (Product ID and quantity). It validates that the entered Product IDs exist in the `inventory` and that quantities are positive. It creates an `Order` object with `OrderItem`s and adds it to the `pendingOrders` `Queue` using `offer()`.
 *     *   **Process Next Order:** Checks if the `pendingOrders` queue is empty. If not, it `peek()`s at the next order. It then iterates through the order's items, checking stock availability for *each* item using `findProductById` and comparing quantities. If *all* items have sufficient stock, it `poll()`s the order from the queue, updates the quantity of each affected product in the `inventory` `ArrayList`, and sets the order status to "Processed". If *any* item has insufficient stock, it `poll()`s the order, sets the status to "Failed - Insufficient Stock", and *does not* modify the inventory quantities.
 *     *   **View Inventory:** Iterates through the `inventory` `ArrayList` and prints each `Product` using its `toString()` method.
 *     *   **View Pending Orders:** Iterates through the `pendingOrders` `Queue` using an enhanced for loop (which uses an iterator internally) to print each `Order` without removing it from the queue.
 * 
 * 4.  **Best Practices:**
 *     *   **Encapsulation:** Fields in `Product`, `OrderItem`, and `Order` are private, accessed via public methods.
 *     *   **Naming:** Variable and method names are descriptive (e.g., `pendingOrders`, `findProductById`, `processNextOrder`).
 *     *   **Comments/Documentation:** Basic Javadoc-style comments explain the purpose of classes and methods. Inline comments clarify specific logic sections.
 *     *   **Input Validation:** Checks are performed for positive IDs, quantities, prices, non-empty names, and existence of product IDs before proceeding.
 *     *   **Error Handling:** `System.err` is used for errors. `try-catch` blocks handle potential runtime issues like `InputMismatchException`. Specific error messages guide the user.
 *     *   **Clean Code:** The code is structured into logical methods within the `Warehouse` class, separating concerns for each menu option.
 * 
 * This solution effectively integrates all required components into a functional, albeit simplified, system, demonstrating understanding of data structures, object-oriented principles, user interaction, and error handling in Java.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.InputMismatchException;
import java.util.HashMap;
import java.util.Map;

// Represents a product in the warehouse inventory
class Product {
    private int id;
    private String name;
    private int quantity;
    private double price;

    public Product(int id, String name, int quantity, double price) {
        this.id = id;
        this.name = name;
        this.quantity = quantity;
        this.price = price;
    }

    // Getters
    public int getId() {
        return id;
    }

    public String getName() {
        return name;
    }

    public int getQuantity() {
        return quantity;
    }

    public double getPrice() {
        return price;
    }

    // Setter for quantity (used when processing orders)
    public void setQuantity(int quantity) {
        this.quantity = quantity;
    }

    @Override
    public String toString() {
        return String.format("ID: %d, Name: %s, Quantity: %d, Price: $%.2f",
                             id, name, quantity, price);
    }
}

// Represents an item requested within an order
class OrderItem {
    private int productId;
    private int quantity;

    public OrderItem(int productId, int quantity) {
        this.productId = productId;
        this.quantity = quantity;
    }

    public int getProductId() {
        return productId;
    }

    public int getQuantity() {
        return quantity;
    }

    @Override
    public String toString() {
        return String.format("  - Product ID: %d, Quantity: %d", productId, quantity);
    }
}

// Represents a customer order
class Order {
    private int orderId;
    private List<OrderItem> items;
    private String status; // e.g., "Pending", "Processed", "Failed"

    public Order(int orderId) {
        this.orderId = orderId;
        this.items = new ArrayList<>(); // Using ArrayList for order items
        this.status = "Pending";
    }

    public int getOrderId() {
        return orderId;
    }

    public List<OrderItem> getItems() {
        return items;
    }

    public String getStatus() {
        return status;
    }

    public void addItem(int productId, int quantity) {
        this.items.add(new OrderItem(productId, quantity));
    }

    public void setStatus(String status) {
        this.status = status;
    }

    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        sb.append("Order ID: ").append(orderId).append(", Status: ").append(status).append("\n");
        sb.append("  Items:\n");
        for (OrderItem item : items) {
            sb.append(item.toString()).append("\n");
        }
        return sb.toString();
    }
}

// Main class managing the warehouse operations
public class Warehouse {
    // Using List interface, implemented by ArrayList
    private List<Product> inventory;
    // Using Queue interface, implemented by LinkedList
    private Queue<Order> pendingOrders;
    private Scanner scanner;

    public Warehouse() {
        inventory = new ArrayList<>();
        pendingOrders = new LinkedList<>(); // LinkedList is commonly used for Queue implementation
        scanner = new Scanner(System.in);
    }

    // Helper method to find a product by ID
    private Product findProductById(int productId) {
        for (Product product : inventory) {
            if (product.getId() == productId) {
                return product;
            }
        }
        return null; // Product not found
    }

    // 1. Add Product
    public void addProduct() {
        System.out.println("--- Add Product ---");
        try {
            System.out.print("Enter Product ID: ");
            int id = scanner.nextInt();
            scanner.nextLine(); // Consume newline

            // Check if product ID already exists
            if (findProductById(id) != null) {
                System.err.println("Error: Product with ID " + id + " already exists.");
                return;
            }

            System.out.print("Enter Product Name: ");
            String name = scanner.nextLine();

            System.out.print("Enter Quantity: ");
            int quantity = scanner.nextInt();

            System.out.print("Enter Price: ");
            double price = scanner.nextDouble();
            scanner.nextLine(); // Consume newline

            // Input validation
            if (id <= 0 || quantity < 0 || price < 0) { // Allow 0 quantity for initial add
                 System.err.println("Error: ID, Quantity, and Price must be non-negative. ID must be positive.");
                 return;
            }
             if (name == null || name.trim().isEmpty()) {
                 System.err.println("Error: Product name cannot be empty.");
                 return;
             }


            Product newProduct = new Product(id, name.trim(), quantity, price);
            inventory.add(newProduct);
            System.out.println("Product added successfully.");

        } catch (InputMismatchException e) {
            System.err.println("Error: Invalid input. Please enter the correct data type (e.g., number for ID, quantity, price).");
            scanner.nextLine(); // Clear the invalid input
        } catch (Exception e) {
            System.err.println("An unexpected error occurred while adding product: " + e.getMessage());
        }
    }

    // 2. Add Order
    public void addOrder() {
        System.out.println("--- Add Order ---");
        try {
            System.out.print("Enter Order ID: ");
            int orderId = scanner.nextInt();
            scanner.nextLine(); // Consume newline

             if (orderId <= 0) {
                 System.err.println("Error: Order ID must be positive.");
                 return;
             }

            // Basic check if order ID might be a duplicate (not strictly required by prompt, but good practice)
             // This would require keeping a history of processed/failed orders. Skipping for simplicity based on prompt scope.

            Order newOrder = new Order(orderId);

            System.out.println("Enter items for the order (enter 0 for Product ID to finish):");
            while (true) {
                System.out.print("  Enter Product ID (or 0 to finish): ");
                int productId = scanner.nextInt();
                if (productId == 0) {
                    break;
                }

                // Validate product ID exists in inventory
                Product product = findProductById(productId);
                if (product == null) {
                    System.err.println("  Error: Product with ID " + productId + " not found in inventory. Skipping this item.");
                    scanner.nextLine(); // Consume newline after int
                    continue; // Ask for next item
                }

                System.out.print("  Enter Quantity for Product ID " + productId + ": ");
                int quantity = scanner.nextInt();
                scanner.nextLine(); // Consume newline

                // Validate quantity
                if (quantity <= 0) {
                    System.err.println("  Error: Quantity must be positive. Skipping this item.");
                    continue; // Ask for next item
                }

                newOrder.addItem(productId, quantity);
            }

            if (newOrder.getItems().isEmpty()) {
                 System.err.println("Error: Order must contain at least one item. Order not added.");
            } else {
                pendingOrders.offer(newOrder); // Add order to the queue
                System.out.println("Order " + orderId + " added to pending queue.");
            }


        } catch (InputMismatchException e) {
            System.err.println("Error: Invalid input. Please enter a number for ID and quantity.");
            scanner.nextLine(); // Clear the invalid input
        } catch (Exception e) {
            System.err.println("An unexpected error occurred while adding order: " + e.getMessage());
        }
    }

    // 3. Process Next Order
    public void processNextOrder() {
        System.out.println("--- Process Next Order ---");
        if (pendingOrders.isEmpty()) {
            System.err.println("Error: No pending orders in the queue.");
            return;
        }

        // Use try-catch within this method for processing logic errors
        try {
            Order orderToProcess = pendingOrders.peek(); // Peek to check stock first without removing
            System.out.println("Processing Order ID: " + orderToProcess.getOrderId());

            boolean sufficientStock = true;
            // Map to store changes temporarily before committing
            Map<Integer, Integer> stockChanges = new HashMap<>();

            // First pass: Check stock for all items
            for (OrderItem item : orderToProcess.getItems()) {
                Product product = findProductById(item.getProductId());
                if (product == null) {
                    // This case should ideally not happen if validation was perfect during addOrder
                    System.err.println("  Error: Product ID " + item.getProductId() + " not found in inventory during processing.");
                    sufficientStock = false; // Treat as insufficient stock for processing purposes
                    break; // Stop checking this order
                }
                if (product.getQuantity() < item.getQuantity()) {
                    System.err.println("  Insufficient stock for Product ID " + item.getProductId() +
                                       " (Needed: " + item.getQuantity() + ", Available: " + product.getQuantity() + ").");
                    sufficientStock = false;
                    break; // Stop checking this order
                }
                // If sufficient, record the intended stock change
                stockChanges.put(item.getProductId(), product.getQuantity() - item.getQuantity());
            }

            // Second pass: Update stock if sufficient for all
            if (sufficientStock) {
                // Remove from queue FIRST before modifying inventory to prevent issues if inventory update fails
                // (though unlikely with simple setQuantity, good practice)
                Order processedOrder = pendingOrders.poll(); // Remove from queue
                if (processedOrder != null) { // Should not be null if peek wasn't null
                     for (Map.Entry<Integer, Integer> entry : stockChanges.entrySet()) {
                        Product product = findProductById(entry.getKey());
                        if (product != null) {
                            product.setQuantity(entry.getValue()); // Apply the stock change
                        }
                        // If product is null here, something is very wrong, but we already checked existence
                     }
                    processedOrder.setStatus("Processed");
                    System.out.println("Order ID " + processedOrder.getOrderId() + " processed successfully. Inventory updated.");
                    // In a real system, processed orders might move to a 'completed' list
                } else {
                     System.err.println("Internal Error: Order was null after polling.");
                }

            } else {
                // Order failed due to insufficient stock
                Order failedOrder = pendingOrders.poll(); // Remove from queue
                if (failedOrder != null) {
                    failedOrder.setStatus("Failed - Insufficient Stock");
                    System.out.println("Order ID " + failedOrder.getOrderId() + " failed due to insufficient stock. Inventory unchanged.");
                    // In a real system, failed orders might move to a 'failed' list or be retried
                } else {
                     System.err.println("Internal Error: Order was null after polling on failure.");
                }
            }

        } catch (Exception e) {
            // Catch any other unexpected errors during processing
            System.err.println("An unexpected error occurred during order processing: " + e.getMessage());
            // Optionally, poll the order to prevent infinite loop if processing always fails for it
            // pendingOrders.poll();
        }
    }

    // 4. View Inventory
    public void viewInventory() {
        System.out.println("--- Current Inventory ---");
        if (inventory.isEmpty()) {
            System.out.println("Inventory is empty.");
        } else {
            for (Product product : inventory) {
                System.out.println(product);
            }
        }
    }

    // 5. View Pending Orders
    public void viewPendingOrders() {
        System.out.println("--- Pending Orders ---");
        if (pendingOrders.isEmpty()) {
            System.out.println("No pending orders.");
        } else {
            // Iterate through the queue without removing elements
            int count = 1;
            for (Order order : pendingOrders) {
                System.out.println("Order " + count + ":\n" + order);
                count++;
            }
        }
    }

    // Main method to run the system
    public static void main(String[] args) {
        Warehouse warehouse = new Warehouse();
        int choice = -1;

        // Class-wide or main loop try-catch for general exceptions
        try {
            while (choice != 6) {
                System.out.println("\n--- Warehouse Menu ---");
                System.out.println("1. Add Product");
                System.out.println("2. Add Order");
                System.out.println("3. Process Next Order");
                System.out.println("4. View Inventory");
                System.out.println("5. View Pending Orders");
                System.out.println("6. Exit");
                System.out.print("Enter your choice: ");

                try {
                    choice = warehouse.scanner.nextInt();
                    warehouse.scanner.nextLine(); // Consume newline

                    // Use switch statement for menu flow control
                    switch (choice) {
                        case 1:
                            warehouse.addProduct();
                            break;
                        case 2:
                            warehouse.addOrder();
                            break;
                        case 3:
                            warehouse.processNextOrder();
                            break;
                        case 4:
                            warehouse.viewInventory();
                            break;
                        case 5:
                            warehouse.viewPendingOrders();
                            break;
                        case 6:
                            System.out.println("Exiting Warehouse System. Goodbye!");
                            break;
                        default:
                            System.err.println("Error: Invalid choice. Please enter a number between 1 and 6.");
                    }
                } catch (InputMismatchException e) {
                    System.err.println("Error: Invalid input. Please enter a number.");
                    warehouse.scanner.nextLine(); // Clear the invalid input
                    choice = -1; // Reset choice to prevent accidental exit or loop issue
                }
            }
        } catch (Exception e) {
             // Catch any unhandled exceptions that bubble up from within the loop
             System.err.println("An unexpected fatal error occurred: " + e.getMessage());
             e.printStackTrace(); // Print stack trace for debugging
        } finally {
            // Ensure scanner is closed when the program exits
            if (warehouse.scanner != null) {
                warehouse.scanner.close();
            }
        }
    }
}
