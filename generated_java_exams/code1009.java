/*
 * Exam Question #1009
 * Generated on: 2025-05-12 17:12:19
 * Generated by: Account 3
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Advanced Task Dispatcher System
 * 
 * **Problem Description:**
 * 
 * Design and implement a simple Task Dispatcher system for an office. The system should manage tasks from creation through processing, simulating a workflow where tasks are initially added to a general pool and then moved to a processing queue based on priority.
 * 
 * Your solution must demonstrate a solid understanding of core Java concepts, including collections, control flow, user input, and exception handling.
 * 
 * **Requirements:**
 * 
 * 1.  **Data Structures:**
 *     *   Create a `Task` class with fields for `id` (integer, auto-generated), `description` (String), and `priority` (String: "High", "Medium", "Low"). Include a constructor and appropriate getters.
 *     *   The main dispatcher logic class must maintain two collections:
 *         *   A `java.util.List` (specifically using `java.util.ArrayList`) to store all tasks currently in the system's general pool.
 *         *   A `java.util.Queue` (specifically using `java.util.LinkedList` which implements `Queue`) to store tasks waiting to be processed.
 * 
 * 2.  **Functionality:**
 *     *   **Add Task:** Allow the user to add a new task by providing a description and priority. Assign a unique, sequential ID. Validate the priority input.
 *     *   **List All Tasks:** Display all tasks currently in the general pool (`ArrayList`).
 *     *   **Dispatch Tasks:** Move all tasks from the general pool (`ArrayList`) to the processing queue (`Queue`). Tasks should be added to the queue in priority order: all "High" priority tasks first, then all "Medium", then all "Low". Once dispatched, tasks are removed from the general pool.
 *     *   **Process Next Task:** Take the next task from the head of the processing queue (`Queue`) and simulate processing it (e.g., print its details).
 *     *   **List Processing Queue:** Display tasks currently waiting in the processing queue without removing them.
 *     *   **Exit:** Terminate the program.
 * 
 * 3.  **User Interface:**
 *     *   Use `java.util.Scanner` to interact with the user via the console, presenting a menu of options.
 *     *   Use a `switch` statement to handle the user's menu choice.
 * 
 * 4.  **Error Handling and Output:**
 *     *   Use `System.err` to display error messages (e.g., invalid input, trying to process from an empty queue, trying to dispatch from an empty list).
 *     *   Use `System.out` for all normal output (menu, prompts, task listings, success messages).
 *     *   Implement **class-wide exception handling** using a `try-catch` block in your main application class to catch any unexpected exceptions during program execution. Handle specific input parsing errors (`NumberFormatException`) gracefully where necessary.
 * 
 * 5.  **Best Practices:**
 *     *   Apply proper encapsulation (private fields, public methods).
 *     *   Use meaningful variable and method names.
 *     *   Include appropriate comments and documentation (e.g., Javadoc for methods).
 *     *   Implement input validation (especially for priority).
 *     *   Maintain a clean and organized code structure (consider separate classes for `Task` and the dispatcher logic).
 * 
 * **Expected Output:**
 * 
 * The program should present a menu, accept user input, perform the requested actions, and display appropriate messages or task lists. Error conditions should be reported clearly using `System.err`.
 * 
 * **Example Interaction Flow:**
 * 
 * ```
 * --- Task Dispatcher Menu ---
 * 1. Add New Task
 * 2. List All Tasks
 * 3. Dispatch Tasks to Queue
 * 4. Process Next Task from Queue
 * 5. List Processing Queue
 * 0. Exit
 * --------------------------
 * Enter choice: 1
 * Enter task description: Design Database Schema
 * Enter priority (High, Medium, Low): High
 * Task added: Task [ID=1, Priority=High, Description='Design Database Schema']
 * 
 * --- Task Dispatcher Menu ---
 * ...
 * Enter choice: 1
 * Enter task description: Write documentation
 * Enter priority (High, Medium, Low): Low
 * Task added: Task [ID=2, Priority=Low, Description='Write documentation']
 * 
 * --- Task Dispatcher Menu ---
 * ...
 * Enter choice: 2
 * --- All Tasks ---
 * 1. Task [ID=1, Priority=High, Description='Design Database Schema']
 * 2. Task [ID=2, Priority=Low, Description='Write documentation']
 * -----------------
 * 
 * --- Task Dispatcher Menu ---
 * ...
 * Enter choice: 3
 * --- Dispatching Tasks ---
 * Dispatching High priority tasks...
 *   -> Dispatched: Task [ID=1, Priority=High, Description='Design Database Schema']
 * Dispatching Medium priority tasks...
 * Dispatching Low priority tasks...
 *   -> Dispatched: Task [ID=2, Priority=Low, Description='Write documentation']
 * -------------------------
 * 2 tasks dispatched to the processing queue.
 * 
 * --- Task Dispatcher Menu ---
 * ...
 * Enter choice: 2
 * --- All Tasks ---
 * No tasks in the system.
 * -----------------
 * 
 * --- Task Dispatcher Menu ---
 * ...
 * Enter choice: 5
 * --- Processing Queue ---
 * 1. Task [ID=1, Priority=High, Description='Design Database Schema']
 * 2. Task [ID=2, Priority=Low, Description='Write documentation']
 * ------------------------
 * 
 * --- Task Dispatcher Menu ---
 * ...
 * Enter choice: 4
 * --- Processing Task ---
 * Processing: Task [ID=1, Priority=High, Description='Design Database Schema']
 * Task processing complete.
 * -----------------------
 * 
 * --- Task Dispatcher Menu ---
 * ...
 * Enter choice: 5
 * --- Processing Queue ---
 * 1. Task [ID=2, Priority=Low, Description='Write documentation']
 * ------------------------
 * 
 * --- Task Dispatcher Menu ---
 * ...
 * Enter choice: 0
 * Exiting Task Dispatcher. Goodbye!
 * Scanner closed.
 * ```
 * 
 * **Submission:**
 * 
 * Provide the complete Java code for the `Task` class, the dispatcher logic class, and the main class that contains the `main` method and user interaction loop. Ensure all requirements are met.
 *
 * EXPLANATION:
 * This solution implements a simple Task Dispatcher system demonstrating the required Java concepts.
 * 
 * **Key Components and Concepts Used:**
 * 
 * 1.  **`Task` Class:** A basic Plain Old Java Object (POJO) encapsulating task data (`id`, `description`, `priority`) with private fields and public getters, demonstrating encapsulation.
 * 2.  **`TaskDispatcher` Class:**
 *     *   Manages the core logic and data structures.
 *     *   `private List<Task> allTasks = new ArrayList<>();`: Uses the `List` interface type for the variable, instantiated with `ArrayList`, demonstrating polymorphism and the use of `ArrayList` for dynamic sizing and general storage.
 *     *   `private Queue<Task> processingQueue = new LinkedList<>();`: Uses the `Queue` interface type for the variable, instantiated with `LinkedList`, demonstrating polymorphism and the use of `Queue` for FIFO (First-In, First-Out) processing (or priority-based simulation in this case) using methods like `offer()` (add) and `poll()` (retrieve and remove).
 *     *   **Encapsulation:** All data fields are private, and operations are exposed via public methods (`addTask`, `listAllTasks`, `dispatchTasksToQueue`, `processNextTask`, `listProcessingQueue`).
 *     *   **`addTask` Method:** Handles creating new `Task` objects and adding them to the `allTasks` list. Includes input validation for the priority string, using a `switch` statement for clarity and returning a boolean to indicate success or failure. Error messages for invalid priority go to `System.err`.
 *     *   **`listAllTasks` Method:** Iterates through the `allTasks` `ArrayList` and prints task details to `System.out`. Checks for an empty list.
 *     *   **`dispatchTasksToQueue` Method:**
 *         *   Moves tasks from `allTasks` to `processingQueue`.
 *         *   Demonstrates iterating through a `List`.
 *         *   Uses a `switch` statement based on task priority to categorize tasks into temporary lists.
 *         *   Adds tasks from temporary lists to the `processingQueue` in the specified priority order (High, Medium, Low) using `queue.offer()`.
 *         *   Clears the `allTasks` list after dispatching.
 *         *   Handles the case where `allTasks` is empty using `System.err`.
 *     *   **`processNextTask` Method:**
 *         *   Retrieves and removes the head of the `processingQueue` using `queue.poll()`.
 *         *   Simulates processing by printing task details to `System.out`.
 *         *   Handles the case where `processingQueue` is empty using `System.err`.
 *     *   **`listProcessingQueue` Method:**
 *         *   Iterates through the `processingQueue` using an `Iterator` to list elements *without* removing them, demonstrating safe queue traversal.
 *         *   Prints task details to `System.out`.
 *         *   Handles the case where `processingQueue` is empty using `System.out`.
 * 
 * 3.  **`Main` Class:**
 *     *   Contains the `main` method, the entry point of the application.
 *     *   `Scanner scanner = new Scanner(System.in);`: Used for reading user input from the console.
 *     *   **Menu and `switch`:** Presents a menu to the user and uses a `switch` statement on the parsed integer input to control the program flow, calling the appropriate methods in the `TaskDispatcher`.
 *     *   **Input Validation (`NumberFormatException`):** Uses a `try-catch` block specifically around `Integer.parseInt(input)` to handle non-numeric user input for the menu choice, printing an error to `System.err` and continuing the loop.
 *     *   **Class-Wide Exception Handling (`try-catch(Exception e)`):** A broad `try-catch(Exception e)` block wraps the main `while` loop. This serves as a safety net to catch any unexpected runtime exceptions that might occur anywhere within the loop's execution (in input processing or dispatcher methods) that aren't handled by more specific `try-catch` blocks. It prints a generic error message to `System.err`.
 *     *   **`finally` Block:** Ensures the `Scanner` resource is closed when the program exits, regardless of whether it exits normally or due to an exception caught by the main `try-catch`.
 *     *   **`System.out` and `System.err`:** Used appropriately for normal program output (`System.out`) and error conditions (`System.err`).
 * 
 * This solution effectively integrates the required Java components and demonstrates essential programming practices in the context of a practical, albeit simplified, application scenario.
 */

package com.example.taskdispatcher;

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.Iterator; // Needed for safe queue listing

/**
 * Represents a single task in the system.
 */
class Task {
    private int id;
    private String description;
    private String priority; // "High", "Medium", "Low"

    /**
     * Constructs a new Task.
     * @param id The unique task ID.
     * @param description The task description.
     * @param priority The task priority ("High", "Medium", or "Low").
     */
    public Task(int id, String description, String priority) {
        this.id = id;
        this.description = description;
        // Assume priority is validated before calling constructor
        this.priority = priority;
    }

    public int getId() {
        return id;
    }

    public String getDescription() {
        return description;
    }

    public String getPriority() {
        return priority;
    }

    @Override
    public String toString() {
        return "Task [ID=" + id + ", Priority=" + priority + ", Description='" + description + "']";
    }
}

/**
 * Manages the collection and dispatching of tasks.
 */
class TaskDispatcher {
    // List interface variable holding an ArrayList implementation
    private List<Task> allTasks;
    // Queue interface variable holding a LinkedList implementation
    private Queue<Task> processingQueue;
    private int nextTaskId;

    /**
     * Constructs a new TaskDispatcher.
     */
    public TaskDispatcher() {
        this.allTasks = new ArrayList<>(); // Use ArrayList for general task storage
        this.processingQueue = new LinkedList<>(); // Use LinkedList as a Queue for processing
        this.nextTaskId = 1;
    }

    /**
     * Adds a new task to the system's general task list.
     * Validates the priority input.
     * @param description The task description.
     * @param priority The task priority (case-insensitive "High", "Medium", "Low").
     * @return true if task was added successfully, false otherwise (invalid priority).
     */
    public boolean addTask(String description, String priority) {
        // Input validation for priority
        String lowerPriority = priority.trim().toLowerCase();
        String validatedPriority;

        switch (lowerPriority) { // Using switch for priority validation
            case "high":
                validatedPriority = "High";
                break;
            case "medium":
                validatedPriority = "Medium";
                break;
            case "low":
                validatedPriority = "Low";
                break;
            default:
                System.err.println("Error: Invalid priority '" + priority + "'. Must be High, Medium, or Low.");
                return false; // Indicate failure
        }

        Task newTask = new Task(nextTaskId++, description, validatedPriority);
        allTasks.add(newTask);
        System.out.println("Task added: " + newTask);
        return true; // Indicate success
    }

    /**
     * Lists all tasks currently in the system's main list (general pool).
     */
    public void listAllTasks() {
        System.out.println("\n--- All Tasks ---");
        if (allTasks.isEmpty()) {
            System.out.println("No tasks in the system's general pool.");
        } else {
            // Using enhanced for loop to iterate over the List
            for (int i = 0; i < allTasks.size(); i++) {
                 System.out.println((i + 1) + ". " + allTasks.get(i));
            }
        }
        System.out.println("-----------------");
    }

    /**
     * Dispatches tasks from the main list to the processing queue based on priority.
     * Tasks are moved in order: High, then Medium, then Low.
     * The general task list is cleared after dispatching.
     */
    public void dispatchTasksToQueue() {
        if (allTasks.isEmpty()) {
            System.err.println("No tasks to dispatch from the general pool.");
            return;
        }

        System.out.println("\n--- Dispatching Tasks ---");

        // Use temporary lists to categorize tasks by priority before adding to queue
        List<Task> highPriority = new ArrayList<>();
        List<Task> mediumPriority = new ArrayList<>();
        List<Task> lowPriority = new ArrayList<>();

        // Categorize tasks from the main list
        for (Task task : allTasks) {
            switch (task.getPriority()) { // Using switch statement to handle priority
                case "High":
                    highPriority.add(task);
                    break;
                case "Medium":
                    mediumPriority.add(task);
                    break;
                case "Low":
                    lowPriority.add(task);
                    break;
                default:
                    // This case should ideally not be reached due to validation in addTask
                    System.err.println("Warning: Task with unexpected priority encountered: " + task);
                    break;
            }
        }

        // Add tasks to the processing queue in priority order
        System.out.println("Dispatching High priority tasks...");
        for (Task task : highPriority) {
            processingQueue.offer(task); // offer is the preferred way to add to a queue
             System.out.println("  -> Dispatched: " + task);
        }
        System.out.println("Dispatching Medium priority tasks...");
        for (Task task : mediumPriority) {
            processingQueue.offer(task);
             System.out.println("  -> Dispatched: " + task);
        }
        System.out.println("Dispatching Low priority tasks...");
        for (Task task : lowPriority) {
            processingQueue.offer(task);
             System.out.println("  -> Dispatched: " + task);
        }

        // Clear the main task list as tasks have been moved to the queue
        int dispatchedCount = allTasks.size();
        allTasks.clear();

        System.out.println("-------------------------");
        System.out.println(dispatchedCount + " tasks dispatched to the processing queue.");
    }

    /**
     * Processes the next task from the head of the processing queue.
     * Removes the task from the queue.
     */
    public void processNextTask() {
        System.out.println("\n--- Processing Task ---");
        if (processingQueue.isEmpty()) {
            System.err.println("Processing queue is empty. No tasks to process.");
        } else {
            Task taskToProcess = processingQueue.poll(); // Retrieve and remove the head of the queue
            System.out.println("Processing: " + taskToProcess);
            // Simulate work...
            System.out.println("Task processing complete.");
        }
        System.out.println("-----------------------");
    }

     /**
     * Lists tasks currently waiting in the processing queue without removing them.
     */
    public void listProcessingQueue() {
        System.out.println("\n--- Processing Queue ---");
        if (processingQueue.isEmpty()) {
            System.out.println("Processing queue is empty.");
        } else {
            // Iterate over the queue without removing elements using an Iterator
            Iterator<Task> iterator = processingQueue.iterator();
            int count = 1;
            while (iterator.hasNext()) {
                System.out.println(count++ + ". " + iterator.next());
            }
        }
        System.out.println("------------------------");
    }
}

/**
 * Main class to run the Task Dispatcher application.
 * Contains the main loop and handles user interaction.
 */
public class Main {

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        TaskDispatcher dispatcher = new TaskDispatcher();
        boolean running = true;

        // Class-wide exception handling using a try-catch block around the main application logic
        try {
            while (running) {
                printMenu();
                System.out.print("Enter choice: ");
                String input = scanner.nextLine();
                int choice = -1; // Default invalid choice

                // Specific exception handling for input parsing
                try {
                    choice = Integer.parseInt(input);
                } catch (NumberFormatException e) {
                    System.err.println("Invalid input. Please enter a number.");
                    continue; // Skip the rest of the loop body and show menu again
                }

                // Using switch statement for flow control based on user choice
                switch (choice) {
                    case 1:
                        System.out.print("Enter task description: ");
                        String description = scanner.nextLine();
                        String priority;
                        // Loop until valid priority is entered
                        do {
                            System.out.print("Enter priority (High, Medium, Low): ");
                            priority = scanner.nextLine();
                        } while (!dispatcher.addTask(description, priority)); // addTask handles validation and error message
                        break;
                    case 2:
                        dispatcher.listAllTasks();
                        break;
                    case 3:
                        dispatcher.dispatchTasksToQueue();
                        break;
                    case 4:
                        dispatcher.processNextTask();
                        break;
                    case 5:
                        dispatcher.listProcessingQueue();
                        break;
                    case 0:
                        System.out.println("Exiting Task Dispatcher. Goodbye!");
                        running = false; // Set flag to exit loop
                        break;
                    default:
                        // Handles numbers outside the valid menu range
                        System.err.println("Invalid choice. Please try again.");
                }
                System.out.println(); // Add a newline for better readability between menu interactions
            }
        } catch (Exception e) {
            // Catch any unexpected runtime exceptions not handled elsewhere
            System.err.println("An unexpected application error occurred: " + e.getMessage());
            // e.printStackTrace(); // Uncomment for detailed debugging
        } finally {
            // Ensure resources like Scanner are closed properly
            if (scanner != null) {
                scanner.close();
            }
            // Optional: Confirmation that cleanup happened
            // System.out.println("Application resources cleaned up.");
        }
    }

    /**
     * Prints the main menu options to the console.
     */
    private static void printMenu() {
        System.out.println("--- Task Dispatcher Menu ---");
        System.out.println("1. Add New Task");
        System.out.println("2. List All Tasks");
        System.out.println("3. Dispatch Tasks to Queue");
        System.out.println("4. Process Next Task from Queue");
        System.out.println("5. List Processing Queue");
        System.out.println("0. Exit");
        System.out.println("--------------------------");
    }
}
