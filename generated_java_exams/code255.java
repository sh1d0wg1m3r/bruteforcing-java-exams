/*
 * Exam Question #255
 * Generated on: 2025-05-11 22:40:04
 * Generated by: Account 5
 * 
 * QUESTION:
 * ## Java Advanced Programming Exam Task: Production Line Simulation
 * 
 * **Scenario:**
 * 
 * You are tasked with developing a simplified simulation of a production line. Products arrive, wait in a queue, are processed one by one, and are then categorized as either completed or failed. The system should allow an operator to interact with the line by adding new products, processing the next product in the queue, and viewing the current status of the line.
 * 
 * **Requirements:**
 * 
 * Implement a Java program that simulates this production line. Your solution must demonstrate proficiency in core Java concepts and adhere to best practices. Specifically, your program must:
 * 
 * 1.  Define a `Product` class representing an item on the production line. It should have private fields for a unique ID (String), a name (String), and a status (String, e.g., "Waiting", "Processing", "Completed", "Failed"). Include a constructor, public getters for all fields, and a public method to update the status.
 * 2.  Define a `ProductionLine` class that manages the simulation. This class should:
 *     *   Use a `java.util.Queue<Product>` to hold products waiting for processing.
 *     *   Use a `java.util.List<Product>` to store products that have been successfully completed.
 *     *   Use a *separate* `java.util.List<Product>` to store products that have failed processing.
 *     *   Implement methods to:
 *         *   `addProduct(Product product)`: Adds a product to the waiting queue.
 *         *   `processNextItem(Scanner scanner)`: Takes the next product from the queue, simulates processing (by prompting the user if it succeeded or failed - e.g., 'y' for success, 'n' for fail), updates the product's status, and moves it to the appropriate completed or failed list. This method should handle the case where the queue is empty gracefully.
 *         *   `viewStatus()`: Prints the current state of the production line, including the number of items waiting, completed, and failed, and the details of the next item waiting (if any).
 *         *   `runSimulation()`: Contains the main application loop. It should display a menu of options (Add Product, Process Next, View Status, Exit), read user input using `java.util.Scanner`, and use a `switch` statement to call the appropriate methods.
 * 3.  The `runSimulation` method (or a method it calls that encompasses the main loop logic) must implement class-wide exception handling using a `try-catch` block to catch potential unexpected errors during the simulation loop and report them.
 * 4.  Use `System.out` for all normal output (menu, prompts, status).
 * 5.  Use `System.err` exclusively for reporting errors (e.g., attempting to process when the queue is empty, invalid user input in `runSimulation` or `processNextItem`, unexpected exceptions caught by the class-wide handler).
 * 6.  Implement input validation where necessary (e.g., ensuring menu choices are valid integers, handling non-integer input gracefully, validating success/fail input during processing).
 * 7.  Ensure proper encapsulation (private fields, public methods) and use meaningful variable and method names.
 * 8.  Include appropriate comments and Javadoc documentation for classes and methods.
 * 9.  Close the `Scanner` resource properly when the simulation exits.
 * 
 * **Expected Output/Interaction:**
 * 
 * The program should present a menu like this:
 * 
 * ```
 * --- Production Line Menu ---
 * 1. Add New Product
 * 2. Process Next Item
 * 3. View Status
 * 4. Exit
 * Enter choice: 
 * ```
 * 
 * Based on the choice, the program should:
 * 
 * *   **Add Product:** Prompt for Product ID and Name, then confirm addition.
 * *   **Process Next:** If queue is empty, print error to `System.err`. If not empty, show the item being processed, ask if it succeeded (y/n), validate input, update status, and move. Print result to `System.out`. Handle invalid y/n input with `System.err`.
 * *   **View Status:** Print counts for waiting, completed, and failed items, and details of the next waiting item if available.
 * *   **Exit:** Terminate the program gracefully.
 * *   **Invalid Choice:** Print error to `System.err`.
 * *   **Unexpected Error:** Print error details to `System.err` using the class-wide `try-catch`.
 * 
 * **Constraints:**
 * 
 * *   Must use `java.util.Queue`, `java.util.ArrayList`, `java.util.List`, `java.util.Scanner`, `switch`, `System.err`, `System.out`, and class-wide `try-catch`.
 * *   Focus on demonstrating the required components and error handling.
 * 
 * ---
 *
 * EXPLANATION:
 * This solution implements a `ProductionLine` simulation that meets all the specified requirements.
 * 
 * 1.  **`Product` Class:** A simple POJO (Plain Old Java Object) representing the product. It has private fields (`id`, `name`, `status`), a constructor for initialization, public getters, and a public setter for status. Input validation is included in the constructor to prevent creation of products with empty IDs or names.
 * 
 * 2.  **`ProductionLine` Class:** This is the core class managing the simulation logic.
 *     *   **Collections:**
 *         *   `waitingQueue`: Declared as `Queue<Product>` and instantiated as `LinkedList<Product>`. `LinkedList` is a common implementation of the `Queue` interface, suitable for FIFO operations (add to end, remove from front). The `offer()` method is used for adding, and `poll()` for removing from the front. `peek()` is used to view the next item without removing it.
 *         *   `completedItems`: Declared as `List<Product>` and instantiated as `ArrayList<Product>`. `ArrayList` is a standard dynamic array implementation of the `List` interface, suitable for storing and accessing completed items.
 *         *   `failedItems`: Also declared as `List<Product>` and instantiated as `ArrayList<Product>`, serving the same purpose as `completedItems` for failed items.
 *     *   **`Scanner`:** An instance of `Scanner` is created in the constructor to read user input from `System.in`.
 *     *   **Methods:**
 *         *   `addProduct`: Takes a `Product` object and adds it to the `waitingQueue` using `offer()`.
 *         *   `processNextItem`: Checks if the `waitingQueue` is empty. If so, it prints an error to `System.err` and returns, satisfying the requirement to handle this case gracefully. Otherwise, it uses `peek()` to see the next item, prompts the user for success/failure input, validates the input loop, uses `poll()` to remove the item *only after* valid input is received, updates the product's status, and adds it to the appropriate `completedItems` or `failedItems` list. Invalid 'y'/'n' input results in an error message on `System.err`.
 *         *   `viewStatus`: Prints the sizes of the three collections (`waitingQueue`, `completedItems`, `failedItems`) and uses `peek()` to show details of the next waiting item if the queue is not empty. Output is directed to `System.out`.
 *         *   `runSimulation`: This method contains the main application loop (`while(running)`). It repeatedly prints the menu, reads the user's choice using the `Scanner`, and uses a `switch` statement to execute the corresponding action (`addProduct`, `processNextItem`, `viewStatus`, or exit).
 * 
 * 3.  **Input Handling and Validation:**
 *     *   The `runSimulation` method includes a nested `try-catch(InputMismatchException)` block specifically for handling non-integer input when the user is prompted for a menu choice. It prints an error to `System.err` and consumes the invalid input using `scanner.nextLine()` to prevent an infinite loop.
 *     *   Input validation for product creation (non-empty ID/Name) is handled in the `Product` constructor using an `IllegalArgumentException`. This exception is caught in the `runSimulation` method's case 1 block, and the error is printed to `System.err`.
 *     *   Input validation for the 'y'/'n' prompt in `processNextItem` is handled with a `while` loop that continues until valid input ('y' or 'n') is received. Invalid input results in an error message on `System.err`.
 * 
 * 4.  **Error Handling (`try-catch` and `System.err`):**
 *     *   **Class-wide `try-catch`:** The main `while` loop in `runSimulation` is wrapped in a `try-catch(Exception e)`. This block serves as the class-wide exception handler, catching any unexpected `Exception` that might occur during the execution of the simulation loop (e.g., issues beyond simple input validation or empty queue checks). Caught exceptions are reported to `System.err` along with their stack trace.
 *     *   **Specific Error Handling:** `processNextItem` explicitly checks `waitingQueue.isEmpty()` and reports the error to `System.err`. Invalid user input within `processNextItem` and the main menu loop are also reported to `System.err`.
 *     *   **`System.out` vs `System.err`:** Normal program output (menu, prompts, status updates, successful operations) goes to `System.out`. All error messages and caught exception details go to `System.err`.
 * 
 * 5.  **Best Practices:**
 *     *   **Encapsulation:** Fields in `Product` and `ProductionLine` are private, accessed via public methods.
 *     *   **Meaningful Names:** Classes, variables, and methods have descriptive names (`waitingQueue`, `processNextItem`, `completedItems`, `runSimulation`).
 *     *   **Comments and Documentation:** Javadoc comments are provided for classes and public methods, explaining their purpose.
 *     *   **Resource Management:** The `Scanner` resource is closed in a `finally` block within `runSimulation` to ensure it's released regardless of whether the loop finishes normally or an exception is caught.
 * 
 * This solution effectively combines the required Java components within a practical simulation, demonstrating robust handling of user input, different program states, and potential errors.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.InputMismatchException;

/**
 * Represents a product in the production line simulation.
 */
class Product {
    private String id;
    private String name;
    private String status; // e.g., "Waiting", "Processing", "Completed", "Failed"

    /**
     * Constructs a new Product with initial status "Waiting".
     * @param id The unique identifier for the product.
     * @param name The name of the product.
     */
    public Product(String id, String name) {
        if (id == null || id.trim().isEmpty() || name == null || name.trim().isEmpty()) {
            throw new IllegalArgumentException("Product ID and Name cannot be null or empty.");
        }
        this.id = id.trim();
        this.name = name.trim();
        this.status = "Waiting";
    }

    /**
     * Gets the product ID.
     * @return The product ID.
     */
    public String getId() {
        return id;
    }

    /**
     * Gets the product name.
     * @return The product name.
     */
    public String getName() {
        return name;
    }

    /**
     * Gets the current status of the product.
     * @return The status string.
     */
    public String getStatus() {
        return status;
    }

    /**
     * Sets the status of the product.
     * @param status The new status string.
     */
    public void setStatus(String status) {
        if (status == null || status.trim().isEmpty()) {
             System.err.println("Warning: Attempted to set empty status for product " + id);
             return; // Or throw exception depending on desired strictness
        }
        this.status = status.trim();
    }

    /**
     * Provides a string representation of the product.
     * @return A string containing product details.
     */
    @Override
    public String toString() {
        return "Product [ID=" + id + ", Name=" + name + ", Status=" + status + "]";
    }
}

/**
 * Simulates a production line managing products through different stages.
 */
public class ProductionLine {

    private Queue<Product> waitingQueue;
    private List<Product> completedItems;
    private List<Product> failedItems;
    private Scanner scanner;

    /**
     * Constructs a new ProductionLine, initializing collections and scanner.
     */
    public ProductionLine() {
        waitingQueue = new LinkedList<>(); // LinkedList implements Queue
        completedItems = new ArrayList<>(); // ArrayList implements List
        failedItems = new ArrayList<>(); // ArrayList implements List
        scanner = new Scanner(System.in);
    }

    /**
     * Adds a product to the waiting queue.
     * @param product The product to add.
     */
    public void addProduct(Product product) {
        if (product != null) {
            waitingQueue.offer(product); // offer is preferred over add for queues
            System.out.println("Product '" + product.getName() + "' (ID: " + product.getId() + ") added to waiting queue.");
        } else {
            System.err.println("Error: Cannot add a null product.");
        }
    }

    /**
     * Processes the next item from the waiting queue.
     * Prompts the user for processing success/failure.
     */
    public void processNextItem() {
        if (waitingQueue.isEmpty()) {
            System.err.println("Error: Waiting queue is empty. No items to process.");
            return;
        }

        Product currentItem = waitingQueue.peek(); // Peek first without removing
        System.out.println("\nProcessing item: " + currentItem.getName() + " (ID: " + currentItem.getId() + ")");
        currentItem.setStatus("Processing"); // Optional: mark as processing while asking

        boolean validInput = false;
        while (!validInput) {
            System.out.print("Did processing succeed for " + currentItem.getName() + "? (y/n): ");
            String input = scanner.nextLine().trim().toLowerCase();

            if (input.equals("y")) {
                currentItem = waitingQueue.poll(); // Now remove it
                currentItem.setStatus("Completed");
                completedItems.add(currentItem);
                System.out.println("Product '" + currentItem.getName() + "' marked as Completed.");
                validInput = true;
            } else if (input.equals("n")) {
                currentItem = waitingQueue.poll(); // Now remove it
                currentItem.setStatus("Failed");
                failedItems.add(currentItem);
                System.out.println("Product '" + currentItem.getName() + "' marked as Failed.");
                validInput = true;
            } else {
                System.err.println("Invalid input. Please enter 'y' or 'n'.");
            }
        }
    }

    /**
     * Displays the current status of the production line.
     */
    public void viewStatus() {
        System.out.println("\n--- Production Line Status ---");
        System.out.println("Items Waiting: " + waitingQueue.size());
        System.out.println("Items Completed: " + completedItems.size());
        System.out.println("Items Failed: " + failedItems.size());

        Product nextItem = waitingQueue.peek();
        if (nextItem != null) {
            System.out.println("Next Item to Process: " + nextItem.getName() + " (ID: " + nextItem.getId() + ")");
        } else {
            System.out.println("Next Item to Process: None");
        }
        System.out.println("-----------------------------");
    }

    /**
     * Runs the main simulation loop, handling user interaction.
     * Includes class-wide exception handling.
     */
    public void runSimulation() {
        System.out.println("Production Line Simulation Started.");
        boolean running = true;

        // Class-wide exception handling for the main simulation loop
        try {
            while (running) {
                printMenu();
                int choice = -1;
                try {
                    System.out.print("Enter choice: ");
                    choice = scanner.nextInt();
                    scanner.nextLine(); // Consume newline left-over

                    switch (choice) {
                        case 1:
                            System.out.print("Enter Product ID: ");
                            String id = scanner.nextLine().trim();
                            System.out.print("Enter Product Name: ");
                            String name = scanner.nextLine().trim();
                            try {
                                Product newProduct = new Product(id, name);
                                addProduct(newProduct);
                            } catch (IllegalArgumentException e) {
                                System.err.println("Error creating product: " + e.getMessage());
                            }
                            break;
                        case 2:
                            processNextItem();
                            break;
                        case 3:
                            viewStatus();
                            break;
                        case 4:
                            running = false;
                            System.out.println("Exiting Production Line Simulation.");
                            break;
                        default:
                            System.err.println("Invalid choice. Please enter a number between 1 and 4.");
                    }
                } catch (InputMismatchException e) {
                    System.err.println("Invalid input. Please enter a number.");
                    scanner.nextLine(); // Consume the invalid input to prevent infinite loop
                }
                 System.out.println(); // Add a newline for better readability between operations
            }
        } catch (Exception e) {
            // Class-wide catch for any unexpected exceptions during the simulation
            System.err.println("\nAn unexpected error occurred during simulation:");
            e.printStackTrace(System.err); // Print stack trace to System.err
        } finally {
            // Ensure scanner is closed regardless of how the loop exits
            if (scanner != null) {
                scanner.close();
                System.out.println("Scanner closed.");
            }
        }
    }

    /**
     * Prints the main menu options to System.out.
     */
    private void printMenu() {
        System.out.println("--- Production Line Menu ---");
        System.out.println("1. Add New Product");
        System.out.println("2. Process Next Item");
        System.out.println("3. View Status");
        System.out.println("4. Exit");
    }

    /**
     * Main method to start the simulation.
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        ProductionLine simulation = new ProductionLine();
        simulation.runSimulation();
    }
}
