/*
 * Exam Question #378
 * Generated on: 2025-05-11 23:02:25
 * Generated by: Account 5
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Print Shop Order Management System
 * 
 * **Scenario:**
 * 
 * You are tasked with developing a simplified order management system for a small print shop. The shop offers a predefined catalog of print services, each with a name and a price. Customer orders arrive and need to be processed in the order they are received (First-In, First-Out). Each order can contain multiple print jobs from the catalog.
 * 
 * Your system should allow the shop operator to perform the following actions via a command-line interface:
 * 
 * 1.  **Place New Order:** Create a new order by specifying a list of print job names from the catalog. The system should validate that the entered job names exist in the catalog. The new order is then added to a queue for processing.
 * 2.  **Process Next Order:** Take the next available order from the processing queue, calculate its total cost based on the catalog prices, and display the order details and total cost.
 * 3.  **View Order Queue:** Display the list of orders currently waiting in the processing queue.
 * 4.  **View Print Catalog:** Display the list of available print jobs and their prices.
 * 5.  **Exit:** Terminate the application.
 * 
 * **Technical Requirements:**
 * 
 * Your solution must be a single Java application and demonstrate proficiency in using the following Java concepts and components:
 * 
 * -   `java.util.Queue`: To manage the sequence of orders waiting for processing (FIFO).
 * -   `java.util.ArrayList`: To store the initial print job catalog.
 * -   `java.util.List`: To represent the list of print jobs within an order and to refer to the catalog.
 * -   `java.util.Scanner`: To read user input from the console (menu choices and order details).
 * -   `switch` statement: To handle the main menu selections.
 * -   `System.err`: To output error messages (e.g., invalid input, job not found).
 * -   `System.out`: To output all normal information (menu, catalog, order details, queue status, processing results).
 * -   Class-wide exception handling with `try-catch` blocks: To gracefully handle potential runtime errors, especially related to user input.
 * 
 * **Implementation Requirements:**
 * 
 * -   Structure your code using appropriate classes (e.g., `PrintJob`, `Order`, `PrintShop`).
 * -   Apply best practices for encapsulation (private fields, public getters/methods).
 * -   Use meaningful variable and method names.
 * -   Include basic input validation (e.g., valid menu choice, valid print job names when placing an order).
 * -   Provide comments where necessary to explain complex logic.
 * -   The initial print catalog should be hardcoded within your application. Example catalog items: "Document Print" ($0.10), "Poster Print" ($5.00), "Photo Print" ($1.50).
 * -   Orders should be assigned a simple sequential ID starting from 1.
 * 
 * **Expected Output:**
 * 
 * Your program should display a main menu, accept user input for menu options, and produce output similar to the examples below:
 * 
 * ```
 * --- Print Shop Menu ---
 * 1. Place New Order
 * 2. Process Next Order
 * 3. View Order Queue
 * 4. View Print Catalog
 * 5. Exit
 * Enter your choice: 1
 * --- Place New Order ---
 * Enter print job names (type 'done' when finished):
 * Document Print
 * Photo Print
 * Invalid Job
 * Poster Print
 * done
 * Order 1 placed with 2 valid items.
 * --- Print Shop Menu ---
 * ...
 * Enter your choice: 3
 * --- Current Order Queue ---
 * Order 1 [Document Print, Photo Print, Poster Print]
 * --- Print Shop Menu ---
 * ...
 * Enter your choice: 2
 * --- Processing Order 1 ---
 * Items: [Document Print, Photo Print, Poster Print]
 * Total Cost: $6.60
 * Order 1 processed.
 * --- Print Shop Menu ---
 * ...
 * Enter your choice: 2
 * --- Processing Next Order ---
 * No orders in the queue.
 * --- Print Shop Menu ---
 * ...
 * Enter your choice: 4
 * --- Print Catalog ---
 * Document Print: $0.10
 * Poster Print: $5.00
 * Photo Print: $1.50
 * --- Print Shop Menu ---
 * ...
 * Enter your choice: 5
 * Exiting Print Shop system.
 * ```
 * 
 * **Evaluation Criteria:**
 * 
 * -   Correct implementation of all required functionalities.
 * -   Proper usage of `Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.err`, `System.out`.
 * -   Effective use of `try-catch` for exception handling.
 * -   Adherence to best practices (encapsulation, naming, comments).
 * -   Robustness in handling invalid input and edge cases (e.g., processing an empty queue).
 * 
 * Good luck!
 *
 * EXPLANATION:
 * This solution implements the Print Shop Order Management System as described in the exam question, utilizing all required Java components and following best practices.
 * 
 * **Class Structure:**
 * 
 * 1.  **`PrintJob` Class:** A simple class representing an item in the print shop's catalog. It holds the `name` (String) and `price` (double) of a print job. It includes a constructor, public getter methods for encapsulation, and an overridden `toString()` method for easy display.
 * 2.  **`Order` Class:** Represents a customer order. It has an `orderId` (int) and a `List<String>` called `jobNames` to store the names of the print jobs requested in this specific order. The constructor takes the ID and a list of names. A new `ArrayList` is created from the input list (`new ArrayList<>(jobNames)`) to ensure the internal state (`this.jobNames`) is not directly modifiable from outside, demonstrating good encapsulation. A getter for `jobNames` also returns a copy for the same reason. The `toString()` method provides a convenient representation of the order.
 * 3.  **`PrintShop` Class:** This is the main class that orchestrates the application.
 *     -   It holds the core data structures: a `Queue<Order>` named `orderQueue` (implemented using `LinkedList` for FIFO behavior) and a `List<PrintJob>` named `printCatalog` (implemented using `ArrayList`).
 *     -   `nextOrderId` is an integer counter to assign unique IDs to new orders.
 *     -   A `Scanner` object is used for reading user input.
 *     -   The constructor initializes these fields and calls `initializeCatalog()` to populate the catalog.
 *     -   `initializeCatalog()` populates the `printCatalog` with predefined `PrintJob` objects using `printCatalog.add()`. This demonstrates the use of `ArrayList` to store a collection of objects implementing the `List` interface.
 *     -   `displayMenu()` prints the options to `System.out`.
 *     -   `run()` contains the main application loop. It repeatedly displays the menu, reads user input using the `Scanner`, and uses a `switch` statement to delegate execution based on the user's choice.
 *     -   `placeOrder()` prompts the user for print job names. It reads input line by line until "done" is entered. For each entered name, it calls `findJobPrice()` to validate if the job exists in the catalog. If valid, the name is added to a temporary `List<String>`. If invalid, an error message is printed to `System.err`. After input finishes, if the temporary list is not empty, a new `Order` object is created with the next available ID and the list of valid job names, and this order is added to the `orderQueue` using `orderQueue.add()`.
 *     -   `processNextOrder()` uses `orderQueue.poll()` to retrieve and remove the next order from the queue. If `poll()` returns `null`, it means the queue is empty, and a message is printed. Otherwise, it iterates through the order's job names, uses `findJobPrice()` to get the cost for each, calculates the `totalCost`, and prints the order details and total cost to `System.out`.
 *     -   `viewOrderQueue()` iterates through the `orderQueue` using a `for-each` loop (which doesn't remove elements) and prints each `Order`'s `toString()` representation to `System.out`. It checks if the queue is empty first.
 *     -   `viewPrintCatalog()` iterates through the `printCatalog` `List` and prints each `PrintJob`'s `toString()` representation to `System.out`.
 *     -   `findJobPrice(String jobName)` is a helper method that searches the `printCatalog` (an `ArrayList` referenced by the `List` interface) for a `PrintJob` with a matching name (case-insensitive). It returns the price if found, and -1 if not found.
 *     -   `main()` is the entry point of the application, creating a `PrintShop` instance and calling its `run()` method.
 * 
 * **Required Component Usage:**
 * 
 * -   `Queue`: Used for `orderQueue` (`LinkedList` implementation). `add()` is used to enqueue new orders, and `poll()` is used to dequeue and process orders. Iteration is used in `viewOrderQueue`.
 * -   `ArrayList`: Used for `printCatalog` and the internal list of job names in the `Order` class.
 * -   `List`: Used as the interface type for `printCatalog` and for the list of job names within an `Order`.
 * -   `Scanner`: Used in the `run()` method for menu input and in `placeOrder()` for reading job names.
 * -   `switch`: Used in the `run()` method to handle the user's menu choice.
 * -   `System.err`: Used in `run()` for invalid menu input, and in `placeOrder()` for invalid print job names entered by the user.
 * -   `System.out`: Used for all normal output, including the menu, catalog display, order confirmation, processing results, and queue contents.
 * -   `try-catch`: A `try-catch` block is used in the `run()` method to catch `InputMismatchException` when reading the menu choice (handling non-integer input) and a general `Exception` for any other unexpected errors. This provides robust handling for user input errors.
 * 
 * **Best Practices:**
 * 
 * -   **Encapsulation:** Fields in `PrintJob` and `Order` are private with public getters. The `Order` class's constructor and getter for `jobNames` create copies to protect the internal list.
 * -   **Meaningful Names:** Variables and methods have descriptive names (e.g., `orderQueue`, `placeOrder`, `findJobPrice`).
 * -   **Comments:** Comments explain the purpose of classes, methods, and specific logic blocks.
 * -   **Input Validation:** `placeOrder()` validates job names against the catalog. The `run()` method handles non-integer input for the menu choice.
 * -   **Error Handling:** `try-catch` handles input errors. `System.err` is used for error messages. `processNextOrder()` handles the case of an empty queue. `findJobPrice` returns a sentinel value (-1) for not found, which is checked by the caller.
 * -   **Clean Code Structure:** The code is divided into logical classes and methods, making it readable and maintainable. The main loop in `run()` clearly separates different functionalities using the `switch`.
 * 
 * This solution effectively demonstrates the required Java concepts in a practical, albeit simplified, application context, fulfilling all the requirements of the exam task.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.InputMismatchException;

// Represents a single type of print job available in the catalog
class PrintJob {
    private String name;
    private double price;

    public PrintJob(String name, double price) {
        this.name = name;
        this.price = price;
    }

    public String getName() {
        return name;
    }

    public double getPrice() {
        return price;
    }

    @Override
    public String toString() {
        return name + ": $" + String.format("%.2f", price);
    }
}

// Represents a customer order containing multiple print jobs
class Order {
    private int orderId;
    private List<String> jobNames; // Stores the names of the requested jobs

    public Order(int orderId, List<String> jobNames) {
        this.orderId = orderId;
        this.jobNames = new ArrayList<>(jobNames); // Create a copy to ensure encapsulation
    }

    public int getOrderId() {
        return orderId;
    }

    public List<String> getJobNames() {
        // Return a copy to prevent external modification of the internal list
        return new ArrayList<>(jobNames);
    }

    @Override
    public String toString() {
        return "Order " + orderId + " " + jobNames.toString();
    }
}

// Main class managing the print shop operations
public class PrintShop {

    private Queue<Order> orderQueue;
    private List<PrintJob> printCatalog;
    private int nextOrderId;
    private Scanner scanner;

    public PrintShop() {
        orderQueue = new LinkedList<>(); // LinkedList implements Queue
        printCatalog = new ArrayList<>();
        nextOrderId = 1;
        scanner = new Scanner(System.in);

        // Initialize the print catalog
        initializeCatalog();
    }

    // Hardcode the available print jobs and their prices
    private void initializeCatalog() {
        printCatalog.add(new PrintJob("Document Print", 0.10));
        printCatalog.add(new PrintJob("Poster Print", 5.00));
        printCatalog.add(new PrintJob("Photo Print", 1.50));
        printCatalog.add(new PrintJob("Business Cards", 20.00));
        printCatalog.add(new PrintJob("Brochure", 1.20));
    }

    // Displays the main menu options
    private void displayMenu() {
        System.out.println("\n--- Print Shop Menu ---");
        System.out.println("1. Place New Order");
        System.out.println("2. Process Next Order");
        System.out.println("3. View Order Queue");
        System.out.println("4. View Print Catalog");
        System.out.println("5. Exit");
        System.out.print("Enter your choice: ");
    }

    // Runs the main application loop
    public void run() {
        boolean running = true;
        while (running) {
            displayMenu();
            try {
                int choice = scanner.nextInt();
                scanner.nextLine(); // Consume the newline character

                switch (choice) {
                    case 1:
                        placeOrder();
                        break;
                    case 2:
                        processNextOrder();
                        break;
                    case 3:
                        viewOrderQueue();
                        break;
                    case 4:
                        viewPrintCatalog();
                        break;
                    case 5:
                        running = false;
                        System.out.println("Exiting Print Shop system.");
                        break;
                    default:
                        System.err.println("Invalid choice. Please enter a number between 1 and 5.");
                }
            } catch (InputMismatchException e) {
                System.err.println("Invalid input. Please enter a number.");
                scanner.nextLine(); // Consume the invalid input
            } catch (Exception e) {
                // Catch any other unexpected exceptions
                System.err.println("An unexpected error occurred: " + e.getMessage());
                // e.printStackTrace(); // Uncomment for debugging
            }
        }
        scanner.close(); // Close the scanner when exiting
    }

    // Handles placing a new order
    private void placeOrder() {
        System.out.println("\n--- Place New Order ---");
        List<String> requestedJobNames = new ArrayList<>();
        System.out.println("Enter print job names (type 'done' when finished):");

        String jobName;
        while (true) {
            System.out.print("> ");
            jobName = scanner.nextLine().trim();
            if (jobName.equalsIgnoreCase("done")) {
                break;
            }

            // Validate if the job name exists in the catalog (case-insensitive check)
            if (findJobPrice(jobName) >= 0) { // findJobPrice returns -1 if not found
                requestedJobNames.add(jobName);
            } else {
                System.err.println("Error: '" + jobName + "' is not a valid print job in the catalog.");
            }
        }

        if (!requestedJobNames.isEmpty()) {
            Order newOrder = new Order(nextOrderId++, requestedJobNames);
            orderQueue.add(newOrder);
            System.out.println("Order " + newOrder.getOrderId() + " placed with " + requestedJobNames.size() + " valid item(s).");
        } else {
            System.out.println("No valid items entered. Order not placed.");
        }
    }

    // Handles processing the next order in the queue
    private void processNextOrder() {
        System.out.println("\n--- Processing Next Order ---");
        Order orderToProcess = orderQueue.poll(); // Retrieve and remove the head of the queue

        if (orderToProcess == null) {
            System.out.println("No orders in the queue.");
            return;
        }

        System.out.println("Processing " + orderToProcess);
        double totalCost = 0.0;
        List<String> itemsProcessed = new ArrayList<>(); // Keep track of items actually processed for cost calculation

        for (String jobName : orderToProcess.getJobNames()) {
            double price = findJobPrice(jobName);
            if (price >= 0) { // Should always be true if validation worked during placing, but good practice
                totalCost += price;
                itemsProcessed.add(jobName);
            } else {
                 // This case should ideally not happen if validation on input is correct,
                 // but handle defensively.
                 System.err.println("Warning: Could not find price for job '" + jobName + "' during processing.");
            }
        }

        System.out.println("Items: " + itemsProcessed);
        System.out.println("Total Cost: $" + String.format("%.2f", totalCost));
        System.out.println("Order " + orderToProcess.getOrderId() + " processed.");
    }

    // Displays the current orders in the queue
    private void viewOrderQueue() {
        System.out.println("\n--- Current Order Queue ---");
        if (orderQueue.isEmpty()) {
            System.out.println("The order queue is empty.");
        } else {
            // Iterate through the queue without removing elements
            for (Order order : orderQueue) {
                System.out.println(order);
            }
        }
    }

    // Displays the available print jobs and their prices
    private void viewPrintCatalog() {
        System.out.println("\n--- Print Catalog ---");
        if (printCatalog.isEmpty()) {
            System.out.println("The print catalog is empty.");
        } else {
            for (PrintJob job : printCatalog) {
                System.out.println(job);
            }
        }
    }

    // Helper method to find the price of a job by name (case-insensitive)
    // Returns the price if found, -1 otherwise.
    private double findJobPrice(String jobName) {
        for (PrintJob job : printCatalog) {
            if (job.getName().equalsIgnoreCase(jobName.trim())) {
                return job.getPrice();
            }
        }
        return -1; // Not found
    }

    // Main method to start the application
    public static void main(String[] args) {
        PrintShop shop = new PrintShop();
        shop.run();
    }
}
