/*
 * Exam Question #393
 * Generated on: 2025-05-11 23:04:38
 * Generated by: Account 2
 * 
 * QUESTION:
 * **Java Programming Exam Task: Event Attendee Management System**
 * 
 * You are tasked with developing a simple console-based system to manage attendees for an event. The system needs to handle attendee registration, queuing for check-in, and the check-in process itself.
 * 
 * Your solution must demonstrate a strong understanding of core Java data structures and control flow mechanisms.
 * 
 * **Requirements:**
 * 
 * 1.  **Data Structures:**
 *     *   Maintain a master list of *all* registered attendees using a `java.util.ArrayList`.
 *     *   Manage attendees waiting to be checked in using a `java.util.Queue`. A `java.util.LinkedList` is a suitable implementation for the `Queue`.
 *     *   Use the `java.util.List` interface type when declaring variables that hold `ArrayList` instances.
 * 
 * 2.  **Attendee Representation:**
 *     *   Create a simple `Attendee` class with a name and a status (e.g., REGISTERED, IN_QUEUE, CHECKED_IN). An `enum` for status is recommended.
 * 
 * 3.  **Functionality:** Implement the following commands via user input:
 *     *   `register <name>`: Registers a new attendee. Add them to the master list with status REGISTERED. Prevent duplicate names.
 *     *   `enqueue <name>`: Finds a registered attendee by name and adds them to the check-in queue. Only attendees with REGISTERED status can be enqueued. Update their status to IN_QUEUE.
 *     *   `checkin`: Processes the *next* attendee from the front of the queue. Update their status to CHECKED_IN. Add them to a list of checked-in attendees (or update their status in the master list, ensuring the master list is the source of truth). Handle the case where the queue is empty.
 *     *   `list`: Displays all registered attendees along with their current status (REGISTERED, IN_QUEUE, CHECKED_IN). Also show the current size of the check-in queue and the total count of checked-in attendees.
 *     *   `exit`: Terminates the program.
 * 
 * 4.  **Input/Output:**
 *     *   Use `java.util.Scanner` to read user commands from `System.in`.
 *     *   Use `System.out` for prompts, successful operations, and the list output.
 *     *   Use `System.err` for all error messages (e.g., duplicate registration, attendee not found, invalid command, empty queue for check-in, incorrect command arguments).
 * 
 * 5.  **Control Flow:**
 *     *   Use a `switch` statement to process the different user commands.
 *     *   Implement input validation (e.g., check for empty names, check if attendee exists before enqueueing, check for correct command format).
 * 
 * 6.  **Error Handling:**
 *     *   Implement class-wide exception handling using `try-catch` blocks. Wrap the main command processing loop in a `try-catch` to catch any unexpected runtime errors and print an informative message and stack trace to `System.err`. Handle specific operational errors (like attendee not found) with specific error messages via `System.err` without necessarily throwing exceptions, but demonstrating robust validation.
 * 
 * 7.  **Best Practices:**
 *     *   Employ proper encapsulation (private fields, public methods).
 *     *   Use meaningful variable and method names.
 *     *   Include appropriate comments and documentation (e.g., Javadoc for classes/methods).
 *     *   Ensure resources like `Scanner` are closed properly.
 * 
 * **Expected Output:**
 * 
 * The program should run interactively, prompting the user for commands. Output should clearly indicate the results of each command, including success messages, lists, and specific error messages using the appropriate output stream (`System.out` or `System.err`).
 * 
 * Example Interaction Snippet:
 * 
 * ```
 * Event Management System
 * Commands: register <name>, enqueue <name>, checkin, list, exit
 * > register Alice
 * Attendee 'Alice' registered successfully.
 * > register Bob
 * Attendee 'Bob' registered successfully.
 * > register Alice
 * Error: Attendee 'Alice' is already registered.
 * > enqueue Bob
 * Attendee 'Bob' added to check-in queue.
 * > enqueue Charlie
 * Error: Attendee 'Charlie' is not registered.
 * > list
 * 
 * --- Registered Attendee List ---
 * - Alice [REGISTERED]
 * - Bob [IN_QUEUE]
 * --------------------------------
 * Attendees in Check-in Queue: 1
 * Attendees Checked In: 0
 * --------------------------------
 * 
 * > checkin
 * Attendee 'Bob' checked in successfully.
 * > list
 * 
 * --- Registered Attendee List ---
 * - Alice [REGISTERED]
 * - Bob [CHECKED_IN]
 * --------------------------------
 * Attendees in Check-in Queue: 0
 * Attendees Checked In: 1
 * --------------------------------
 * 
 * > checkin
 * Error: Check-in queue is empty.
 * > exit
 * Exiting system. Goodbye!
 * Scanner closed.
 * ```
 * 
 * Implement the complete Java code for this system.
 *
 * EXPLANATION:
 * This solution implements a basic Event Attendee Management System demonstrating the required Java concepts.
 * 
 * 1.  **Attendee Class and Enum:** The `Attendee` class holds the attendee's `name` and their current `AttendeeStatus`. The `AttendeeStatus` enum clearly defines the possible states (REGISTERED, IN_QUEUE, CHECKED_IN), making the code more readable and preventing invalid status values. Encapsulation is used by making fields private and providing public getter/setter methods.
 * 
 * 2.  **Data Structures:**
 *     *   `registeredAttendees`: Declared as `List<Attendee>` and initialized as an `ArrayList`. This list serves as the single source of truth for all attendees who have ever registered. Using the `List` interface promotes flexibility.
 *     *   `checkInQueue`: Declared as `Queue<Attendee>` and initialized as a `LinkedList`. `LinkedList` is a common implementation for `Queue` and provides the necessary FIFO (First-In, First-Out) behavior for the check-in line.
 *     *   `checkedInAttendees`: Declared as `List<Attendee>` and initialized as an `ArrayList`. This list keeps track of attendees who have successfully checked in. While their status is also updated in the `registeredAttendees` list, this provides a simple way to get the count of checked-in individuals.
 * 
 * 3.  **Functionality Implementation:**
 *     *   `registerAttendee(String name)`: Adds a new attendee to `registeredAttendees` after validating the name and checking for duplicates using the `findAttendee` helper method.
 *     *   `enqueueAttendee(String name)`: Finds the attendee. If found and their status is `REGISTERED`, their status is updated to `IN_QUEUE`, and they are added to the `checkInQueue` using `offer()`. Error messages are printed via `System.err` for invalid names, unregistered attendees, or attendees already in queue/checked in.
 *     *   `checkInNextAttendee()`: Uses `poll()` to retrieve and remove the head of the `checkInQueue`. If the queue is not empty, the attendee's status is updated to `CHECKED_IN`, and they are added to the `checkedInAttendees` list. An error is printed to `System.err` if the queue is empty.
 *     *   `listAttendees()`: Iterates through the `registeredAttendees` list and prints each attendee's name and status using the `Attendee.toString()` method. It also prints the current size of the queue and the checked-in count. Output goes to `System.out`.
 *     *   `findAttendee(String name)`: A private helper method using `Optional` to safely return an attendee from the `registeredAttendees` list based on a case-insensitive name match.
 * 
 * 4.  **Input/Output:**
 *     *   A `Scanner` reads lines from `System.in`.
 *     *   `System.out` is used for prompts, success messages, and the `list` output.
 *     *   `System.err` is specifically used for all validation and operational error messages, separating them from normal program output.
 * 
 * 5.  **Control Flow:**
 *     *   The main logic runs inside a `while(running)` loop.
 *     *   User input is parsed to extract the command and potential argument.
 *     *   A `switch` statement efficiently directs execution to the appropriate method based on the command string.
 *     *   Basic validation is included within the `switch` cases (e.g., checking if the `checkin` or `list` commands received unexpected arguments).
 * 
 * 6.  **Error Handling:**
 *     *   Specific validation checks within methods print informative error messages to `System.err` for expected issues (e.g., duplicate names, attendee not found, empty queue).
 *     *   A `try-catch(Exception e)` block wraps the entire `while` loop in the `main` method. This serves as a "class-wide" handler for any unexpected exceptions that might occur during the program's execution, printing the error message and stack trace to `System.err`.
 *     *   A `finally` block ensures the `scanner` resource is closed, preventing resource leaks.
 * 
 * 7.  **Best Practices:**
 *     *   Private fields and public methods ensure proper encapsulation.
 *     *   Method and variable names are descriptive (e.g., `registerAttendee`, `checkInQueue`, `attendeeOpt`).
 *     *   Comments and Javadoc explain the purpose of classes, methods, and key logic sections.
 *     *   Input validation prevents the system from processing invalid commands or data.
 *     *   Error handling is implemented using both specific `System.err` messages for known issues and a general `try-catch` for unexpected errors.
 *     *   The code is structured into logical methods and a main execution loop.
 * 
 * This solution effectively combines the required Java components to simulate a practical scenario, demonstrating understanding of data structures, control flow, object-oriented principles, and robust error handling.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.Optional; // Used for finding attendees safely

/**
 * Represents the possible statuses of an attendee.
 */
enum AttendeeStatus {
    REGISTERED, // Registered but not yet in queue or checked in
    IN_QUEUE,   // Registered and currently in the check-in queue
    CHECKED_IN  // Registered and successfully checked in
}

/**
 * Represents an attendee for the event.
 */
class Attendee {
    private String name;
    private AttendeeStatus status;

    /**
     * Constructs a new Attendee with initial status REGISTERED.
     * @param name The name of the attendee.
     */
    public Attendee(String name) {
        this.name = name;
        this.status = AttendeeStatus.REGISTERED;
    }

    /**
     * Gets the name of the attendee.
     * @return The attendee's name.
     */
    public String getName() {
        return name;
    }

    /**
     * Gets the current status of the attendee.
     * @return The attendee's status.
     */
    public AttendeeStatus getStatus() {
        return status;
    }

    /**
     * Sets the status of the attendee.
     * @param status The new status.
     */
    public void setStatus(AttendeeStatus status) {
        this.status = status;
    }

    /**
     * Provides a string representation of the attendee including status.
     * @return A string formatted as "Name [STATUS]".
     */
    @Override
    public String toString() {
        return name + " [" + status + "]";
    }

    // Note: For simplicity, equality is not based on status changes in this model.
    // Finding attendees is done by iterating the list and comparing names.
}

/**
 * Manages attendees for an event, handling registration, queuing, and check-in.
 */
public class EventManager {
    // Master list of all registered attendees
    private List<Attendee> registeredAttendees;
    // Queue for attendees waiting to check in
    private Queue<Attendee> checkInQueue;
    // List of attendees who have successfully checked in
    private List<Attendee> checkedInAttendees; // Kept for count/clarity, status is in Attendee object

    /**
     * Constructs a new EventManager with empty lists and queue.
     */
    public EventManager() {
        // Use ArrayList for lists as required
        registeredAttendees = new ArrayList<>();
        // Use LinkedList as a Queue implementation as required
        checkInQueue = new LinkedList<>();
        checkedInAttendees = new ArrayList<>();
    }

    /**
     * Finds an attendee by name in the registered attendees list.
     * Case-insensitive name search.
     * @param name The name to search for.
     * @return An Optional containing the Attendee if found, otherwise empty.
     */
    private Optional<Attendee> findAttendee(String name) {
        for (Attendee attendee : registeredAttendees) {
            if (attendee.getName().equalsIgnoreCase(name)) {
                return Optional.of(attendee);
            }
        }
        return Optional.empty();
    }

    /**
     * Registers a new attendee.
     * @param name The name of the attendee to register.
     */
    public void registerAttendee(String name) {
        if (name == null || name.trim().isEmpty()) {
            System.err.println("Error: Attendee name cannot be empty.");
            return;
        }
        String cleanName = name.trim();

        if (findAttendee(cleanName).isPresent()) {
            System.err.println("Error: Attendee '" + cleanName + "' is already registered.");
        } else {
            Attendee newAttendee = new Attendee(cleanName);
            registeredAttendees.add(newAttendee);
            System.out.println("Attendee '" + cleanName + "' registered successfully.");
        }
    }

    /**
     * Adds a registered attendee to the check-in queue.
     * @param name The name of the attendee to enqueue.
     */
    public void enqueueAttendee(String name) {
        if (name == null || name.trim().isEmpty()) {
            System.err.println("Error: Attendee name cannot be empty.");
            return;
        }
        String cleanName = name.trim();

        Optional<Attendee> attendeeOpt = findAttendee(cleanName);

        if (!attendeeOpt.isPresent()) {
            System.err.println("Error: Attendee '" + cleanName + "' is not registered.");
        } else {
            Attendee attendee = attendeeOpt.get();
            if (attendee.getStatus() == AttendeeStatus.REGISTERED) {
                attendee.setStatus(AttendeeStatus.IN_QUEUE);
                checkInQueue.offer(attendee); // Add to the end of the queue
                System.out.println("Attendee '" + cleanName + "' added to check-in queue.");
            } else if (attendee.getStatus() == AttendeeStatus.IN_QUEUE) {
                 System.err.println("Error: Attendee '" + cleanName + "' is already in the check-in queue.");
            } else { // AttendeeStatus.CHECKED_IN
                 System.err.println("Error: Attendee '" + cleanName + "' has already checked in.");
            }
        }
    }

    /**
     * Processes the next attendee in the check-in queue.
     * Moves them from IN_QUEUE status to CHECKED_IN status.
     */
    public void checkInNextAttendee() {
        Attendee nextAttendee = checkInQueue.poll(); // Get and remove head of queue

        if (nextAttendee == null) {
            System.err.println("Error: Check-in queue is empty. No one to check in.");
        } else {
            nextAttendee.setStatus(AttendeeStatus.CHECKED_IN);
            checkedInAttendees.add(nextAttendee); // Add to checked-in list for count
            System.out.println("Attendee '" + nextAttendee.getName() + "' checked in successfully.");
        }
    }

    /**
     * Lists all registered attendees and their current status.
     */
    public void listAttendees() {
        if (registeredAttendees.isEmpty()) {
            System.out.println("No attendees registered yet.");
            return;
        }
        System.out.println("\n--- Registered Attendee List ---");
        for (Attendee attendee : registeredAttendees) {
            // Attendee.toString() includes the status
            System.out.println("- " + attendee);
        }
        System.out.println("--------------------------------");
        System.out.println("Attendees in Check-in Queue: " + checkInQueue.size());
        System.out.println("Attendees Checked In: " + checkedInAttendees.size());
        System.out.println("--------------------------------\n");
    }

    /**
     * Main method to run the Event Management System.
     * Handles user input and command processing.
     */
    public static void main(String[] args) {
        EventManager manager = new EventManager();
        Scanner scanner = new Scanner(System.in);
        boolean running = true;

        System.out.println("Event Management System");
        System.out.println("Commands: register <name>, enqueue <name>, checkin, list, exit");

        // Class-wide exception handling: Wrap the main execution loop
        try {
            while (running) {
                System.out.print("> ");
                String inputLine = scanner.nextLine().trim();

                if (inputLine.isEmpty()) {
                    continue; // Skip empty input
                }

                // Split command and argument (if any)
                String[] parts = inputLine.split(" ", 2);
                String command = parts[0].toLowerCase();
                String argument = parts.length > 1 ? parts[1].trim() : "";

                // Use switch statement for command processing
                switch (command) {
                    case "register":
                        manager.registerAttendee(argument);
                        break;
                    case "enqueue":
                        manager.enqueueAttendee(argument);
                        break;
                    case "checkin":
                        if (!argument.isEmpty()) {
                             System.err.println("Error: 'checkin' command does not take arguments.");
                        } else {
                            manager.checkInNextAttendee();
                        }
                        break;
                    case "list":
                         if (!argument.isEmpty()) {
                             System.err.println("Error: 'list' command does not take arguments.");
                        } else {
                            manager.listAttendees();
                        }
                        break;
                    case "exit":
                        running = false;
                        System.out.println("Exiting system. Goodbye!");
                        break;
                    default:
                        System.err.println("Error: Unknown command. Use register, enqueue, checkin, list, or exit.");
                        break;
                }
            }
        } catch (Exception e) {
            // Catch any unexpected exceptions during the program execution
            System.err.println("\nAn unexpected error occurred during program execution:");
            System.err.println("Error message: " + e.getMessage());
            // Print stack trace to standard error stream for debugging
            e.printStackTrace(System.err);
        } finally {
            // Ensure the scanner resource is closed regardless of how the loop ends
            scanner.close();
            System.out.println("Scanner resource closed.");
        }
    }
}
