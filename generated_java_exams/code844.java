/*
 * Exam Question #844
 * Generated on: 2025-05-12 16:49:24
 * Generated by: Account 1
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Advanced Task Processing System
 * 
 * **Scenario:**
 * 
 * You are tasked with developing a command-line based Task Processing System. This system manages tasks submitted by users, placing them in a queue for processing and archiving them once completed.
 * 
 * **Requirements:**
 * 
 * Implement a Java program that fulfills the following requirements:
 * 
 * 1.  **Task Representation:** Create a `Task` class with the following private attributes:
 *     *   `id`: An integer representing a unique task ID (should be automatically generated).
 *     *   `description`: A String describing the task.
 *     *   `status`: An enum `TaskStatus` (PENDING, COMPLETED) indicating the task's state.
 *     *   Provide a constructor to create new PENDING tasks with a description.
 *     *   Include public getter methods for all attributes.
 *     *   Include a public setter method for the `status`.
 *     *   Override the `toString()` method to provide a user-friendly representation of the task.
 * 
 * 2.  **System Core:** Create a main class (e.g., `TaskProcessingSystem`) that manages the tasks.
 *     *   It must have a private `Queue<Task>` to hold tasks waiting for processing.
 *     *   It must have a private `List<Task>` (implemented using `ArrayList`) to store completed tasks.
 *     *   It must use a `Scanner` to read user commands from the console.
 * 
 * 3.  **Functionality:** The system should support the following commands entered by the user:
 *     *   `ADD`: Prompts the user for a task description and adds a new `Task` object with status PENDING to the processing queue.
 *     *   `PROCESS`: Removes the next task from the queue, changes its status to COMPLETED, and adds it to the list of completed tasks.
 *     *   `VIEW_PENDING`: Displays all tasks currently in the processing queue.
 *     *   `VIEW_COMPLETED`: Displays all tasks in the completed tasks list.
 *     *   `MENU`: Displays the list of available commands.
 *     *   `EXIT`: Terminates the program.
 * 
 * 4.  **Implementation Details & Constraints:**
 *     *   Use a `java.util.Queue` implementation (e.g., `LinkedList`) for the pending tasks.
 *     *   Use a `java.util.ArrayList` for completed tasks, but declare the field using the `java.util.List` interface (`List<Task> completedTasks = new ArrayList<>();`).
 *     *   Use a `switch` statement to handle the different user commands.
 *     *   Use `System.out.println()` for all normal output (prompts, menus, task details, success messages).
 *     *   Use `System.err.println()` for all error messages (e.g., invalid command, empty queue when processing, empty task description).
 *     *   Implement class-wide exception handling using `try-catch` blocks in the main execution loop to catch potential errors during command processing (e.g., issues with input, unexpected errors). Ensure the `Scanner` is closed properly.
 *     *   Implement input validation for the task description (must not be empty). Report an error using `System.err` if validation fails.
 *     *   Handle the case where the user tries to `PROCESS` when the queue is empty. Report an error using `System.err`.
 *     *   Ensure proper encapsulation by making fields private and providing public methods where necessary.
 *     *   Use meaningful names for classes, variables, and methods.
 *     *   Include appropriate comments to explain complex parts or logic.
 * 
 * **Expected Output:**
 * 
 * The program should run interactively. It should display a menu upon startup (or when `MENU` is typed), prompt the user for commands, and produce output based on the commands. Error messages should be clearly distinct from normal output.
 * 
 * Example Interaction (illustrative):
 * 
 * ```
 * Task Processing System
 * --- Commands ---
 * ADD - Add a new task
 * ... (full menu)
 * ----------------
 * Enter command: ADD
 * Enter task description: Write exam question
 * Task added: Task [ID=1, Description='Write exam question', Status=PENDING]
 * 
 * Enter command: ADD
 * Enter task description: Create solution code
 * Task added: Task [ID=2, Description='Create solution code', Status=PENDING]
 * 
 * Enter command: VIEW_PENDING
 * --- Pending Tasks ---
 * Task [ID=1, Description='Write exam question', Status=PENDING]
 * Task [ID=2, Description='Create solution code', Status=PENDING]
 * ---------------------
 * 
 * Enter command: PROCESS
 * Task processed: Task [ID=1, Description='Write exam question', Status=COMPLETED]
 * 
 * Enter command: VIEW_PENDING
 * --- Pending Tasks ---
 * Task [ID=2, Description='Create solution code', Status=PENDING]
 * ---------------------
 * 
 * Enter command: VIEW_COMPLETED
 * --- Completed Tasks ---
 * Task [ID=1, Description='Write exam question', Status=COMPLETED]
 * -----------------------
 * 
 * Enter command: PROCESS
 * Task processed: Task [ID=2, Description='Create solution code', Status=COMPLETED]
 * 
 * Enter command: PROCESS
 * Error: No tasks in the queue to process.
 * 
 * Enter command: VIEW_COMPLETED
 * --- Completed Tasks ---
 * Task [ID=1, Description='Write exam question', Status=COMPLETED]
 * Task [ID=2, Description='Create solution code', Status=COMPLETED]
 * -----------------------
 * 
 * Enter command: INVALID_COMMAND
 * Error: Unknown command. Type 'MENU' for options.
 * 
 * Enter command: EXIT
 * Exiting Task Processing System. Goodbye!
 * ```
 * 
 * Your code should compile and run, demonstrating the correct usage of all specified Java components and adherence to best practices.
 *
 * EXPLANATION:
 * This solution implements the `Task Processing System` as described in the exam question, demonstrating the required Java concepts and best practices.
 * 
 * 1.  **`Task` Class and `TaskStatus` Enum:**
 *     *   The `Task` class encapsulates task data (`id`, `description`, `status`).
 *     *   It uses a static counter (`nextId`) to ensure each new task gets a unique ID, simulating an auto-incrementing identifier.
 *     *   `TaskStatus` is an enum, providing a clear and type-safe way to represent the state of a task (PENDING or COMPLETED).
 *     *   Getters and a setter for `status` are provided, adhering to encapsulation principles.
 *     *   The `toString()` method is overridden for convenient printing of task details.
 * 
 * 2.  **`TaskProcessingSystem` Class:**
 *     *   This is the main class containing the system's logic.
 *     *   **`Queue<Task> pendingTasks`**: Declared using the `Queue` interface and initialized with a `LinkedList`. This correctly models the "waiting line" behavior where tasks are processed in the order they are added (FIFO - First-In, First-Out).
 *     *   **`List<Task> completedTasks`**: Declared using the `List` interface and initialized with an `ArrayList`. This stores completed tasks, allowing access by index (though not used in this simple example) and easy iteration, demonstrating the use of the interface type for the variable.
 *     *   **`Scanner scanner`**: Used to read command-line input from `System.in`.
 *     *   **`run()` method**: Contains the main program loop.
 *         *   It prompts the user for commands continuously until `EXIT` is entered.
 *         *   **`try-catch` block**: The entire command processing loop is wrapped in a `try-catch (Exception e)`. This fulfills the requirement for class-wide exception handling, catching any unexpected errors that might occur during the execution of commands or input processing. A `finally` block ensures the `Scanner` is closed, releasing the system resource.
 *         *   Input is read using `scanner.nextLine()`, which is robust against different input types compared to reading integers directly. The input is trimmed and converted to uppercase for case-insensitive command matching.
 *         *   **`switch (command)`**: This statement efficiently directs the program flow based on the user's input command, fulfilling the requirement to use a switch statement.
 *         *   Each case calls a dedicated private helper method (`addTask`, `processNextTask`, etc.) to keep the `run` method clean and focused on command dispatching.
 *         *   `System.out.println()` is used for standard user interaction and output.
 *         *   `System.err.println()` is used specifically for printing error messages, making them distinguishable from normal output.
 * 
 * 3.  **Helper Methods (`addTask`, `processNextTask`, `viewPendingTasks`, `viewCompletedTasks`, `printMenu`):**
 *     *   These private methods encapsulate the logic for each specific operation, improving code organization and readability.
 *     *   **`addTask()`**: Reads the description, performs **input validation** (checks if description is empty) using `System.err` for errors, creates a new `Task` object, and adds it to the `pendingTasks` queue using `offer()`.
 *     *   **`processNextTask()`**: Uses `pendingTasks.poll()` to retrieve and remove the next task. `poll()` is used because it returns `null` if the queue is empty, allowing for graceful handling of the **empty queue scenario** with a message to `System.err`, instead of throwing a `NoSuchElementException` like `remove()` would. If a task is retrieved, its status is updated, and it's added to the `completedTasks` list.
 *     *   **`viewPendingTasks()`**: Iterates through the `pendingTasks` queue using a for-each loop. This iterates over the elements without removing them.
 *     *   **`viewCompletedTasks()`**: Iterates through the `completedTasks` list using a for-each loop.
 *     *   **`printMenu()`**: Displays the available commands.
 * 
 * 4.  **`main()` Method:**
 *     *   The entry point of the program. It simply creates an instance of `TaskProcessingSystem` and calls its `run()` method to start the system.
 * 
 * This solution effectively combines object-oriented principles (encapsulation, classes, enums), Java Collections Framework (`Queue`, `List`, `ArrayList`, `LinkedList`), basic I/O (`Scanner`, `System.out`, `System.err`), control flow (`switch`, loops), and robust error handling (`try-catch`, input validation, specific empty queue check) to create a functional and well-structured program that meets all specified requirements.
 */

import java.util.Queue;
import java.util.LinkedList;
import java.util.List;
import java.util.ArrayList;
import java.util.Scanner;
import java.util.InputMismatchException; // Although reading lines, good practice for scanner errors
import java.util.NoSuchElementException; // poll() handles empty queue, but useful to know

// Enum for Task Status
enum TaskStatus {
    PENDING,
    COMPLETED
}

// Represents a single task in the system
class Task {
    // Static counter to generate unique task IDs
    private static int nextId = 1;

    private int id;
    private String description;
    private TaskStatus status;

    /**
     * Constructs a new Task with a description.
     * Automatically assigns a unique ID and sets status to PENDING.
     * @param description The description of the task.
     */
    public Task(String description) {
        this.id = nextId++; // Assign unique ID and increment counter
        this.description = description;
        this.status = TaskStatus.PENDING;
    }

    // --- Getters ---
    public int getId() {
        return id;
    }

    public String getDescription() {
        return description;
    }

    public TaskStatus getStatus() {
        return status;
    }

    // --- Setter ---
    public void setStatus(TaskStatus status) {
        this.status = status;
    }

    /**
     * Provides a string representation of the Task object.
     * @return Formatted string including ID, Description, and Status.
     */
    @Override
    public String toString() {
        return "Task [ID=" + id + ", Description='" + description + "', Status=" + status + "]";
    }
}

// Main class for the Task Processing System
public class TaskProcessingSystem {

    // Queue to hold tasks waiting to be processed
    private Queue<Task> pendingTasks;
    // List to hold tasks that have been completed
    private List<Task> completedTasks;
    // Scanner for reading user input
    private Scanner scanner;

    /**
     * Constructs a new TaskProcessingSystem.
     * Initializes the task collections and the scanner.
     */
    public TaskProcessingSystem() {
        // Use LinkedList as a concrete implementation of Queue
        this.pendingTasks = new LinkedList<>();
        // Use ArrayList as a concrete implementation of List for completed tasks
        this.completedTasks = new ArrayList<>();
        this.scanner = new Scanner(System.in);
    }

    /**
     * Runs the main loop of the task processing system, handling user commands.
     * Includes class-wide exception handling.
     */
    public void run() {
        System.out.println("--- Welcome to the Task Processing System ---");
        printMenu();

        // Class-wide exception handling wrapper for the main loop
        try {
            while (true) {
                System.out.print("\nEnter command (type MENU for options): ");
                // Read the entire line and convert to uppercase for case-insensitive command matching
                String command = scanner.nextLine().trim().toUpperCase();

                // Use switch statement to handle different commands
                switch (command) {
                    case "ADD":
                        addTask();
                        break;
                    case "PROCESS":
                        processNextTask();
                        break;
                    case "VIEW_PENDING":
                        viewPendingTasks();
                        break;
                    case "VIEW_COMPLETED":
                        viewCompletedTasks();
                        break;
                    case "MENU":
                        printMenu();
                        break;
                    case "EXIT":
                        System.out.println("Exiting Task Processing System. Goodbye!");
                        return; // Exit the run method, terminating the application loop
                    default:
                        // Handle unknown commands
                        System.err.println("Error: Unknown command. Type 'MENU' for options.");
                        break;
                }
            }
        } catch (Exception e) {
            // Catch any unexpected exceptions that occur within the command loop
            System.err.println("An unexpected system error occurred: " + e.getMessage());
            // e.printStackTrace(); // Uncomment for detailed debugging
        } finally {
            // Ensure the scanner is closed when the program exits or an unhandled exception occurs
            if (scanner != null) {
                scanner.close();
                //System.out.println("Scanner closed."); // Optional: for debugging
            }
        }
    }

    /**
     * Prints the list of available commands to System.out.
     */
    private void printMenu() {
        System.out.println("\n--- Commands ---");
        System.out.println("ADD            - Add a new task to the queue");
        System.out.println("PROCESS        - Process the next task in the queue");
        System.out.println("VIEW_PENDING   - View tasks waiting in the queue");
        System.out.println("VIEW_COMPLETED - View tasks that have been completed");
        System.out.println("MENU           - Show this menu");
        System.out.println("EXIT           - Exit the system");
        System.out.println("----------------");
    }

    /**
     * Prompts the user for a task description and adds a new task to the pending queue.
     * Includes input validation for the description.
     */
    private void addTask() {
        System.out.print("Enter task description: ");
        String description = scanner.nextLine().trim(); // Read the description

        // Input validation: check if description is empty
        if (description.isEmpty()) {
            System.err.println("Error: Task description cannot be empty.");
            return; // Exit the method if validation fails
        }

        Task newTask = new Task(description);
        // offer() is generally preferred over add() in queues as it handles capacity restrictions gracefully (though LinkedList is unbounded)
        if (pendingTasks.offer(newTask)) {
            System.out.println("Success: Task added to the queue: " + newTask);
        } else {
            // This case is unlikely with LinkedList but good practice with Queue interface
            System.err.println("Error: Failed to add task to the queue.");
        }
    }

    /**
     * Processes the next task from the pending queue.
     * Removes it from the queue, updates its status, and moves it to the completed list.
     * Handles the case where the queue is empty.
     */
    private void processNextTask() {
        // poll() retrieves and removes the head of the queue, or returns null if the queue is empty
        Task taskToProcess = pendingTasks.poll();

        if (taskToProcess == null) {
            // Handle the case where the queue is empty
            System.err.println("Error: No tasks in the queue to process.");
        } else {
            // Update task status and add to completed list
            taskToProcess.setStatus(TaskStatus.COMPLETED);
            completedTasks.add(taskToProcess); // Add to the List (ArrayList) of completed tasks
            System.out.println("Success: Task processed and moved to completed: " + taskToProcess);
        }
    }

    /**
     * Displays all tasks currently in the pending queue.
     * Iterates through the queue without removing elements.
     */
    private void viewPendingTasks() {
        if (pendingTasks.isEmpty()) {
            System.out.println("No tasks currently pending.");
        } else {
            System.out.println("--- Pending Tasks ---");
            // Iterate over the queue elements (order is preserved)
            for (Task task : pendingTasks) {
                System.out.println(task);
            }
            System.out.println("---------------------");
        }
    }

    /**
     * Displays all tasks that have been completed.
     * Iterates through the completed tasks list.
     */
    private void viewCompletedTasks() {
        if (completedTasks.isEmpty()) {
            System.out.println("No tasks have been completed yet.");
        } else {
            System.out.println("--- Completed Tasks ---");
            // Iterate over the List (ArrayList) elements
            for (Task task : completedTasks) {
                System.out.println(task);
            }
            System.out.println("-----------------------");
        }
    }

    /**
     * Main method to start the Task Processing System.
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        // Create an instance of the system and run it
        TaskProcessingSystem system = new TaskProcessingSystem();
        system.run();
    }
}
