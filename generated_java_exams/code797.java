/*
 * Exam Question #797
 * Generated on: 2025-05-12 16:42:11
 * Generated by: Account 3
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Advanced Banking Transaction Processor
 * 
 * **Scenario:**
 * 
 * You are tasked with building a simplified banking transaction processing system. The system needs to manage a set of bank accounts and process transactions (deposits and withdrawals) in the order they are received.
 * 
 * **Requirements:**
 * 
 * 1.  **Account Management:**
 *     *   Create an `Account` class with private fields for `accountNumber` (String) and `balance` (double).
 *     *   Provide public methods for depositing (`deposit(double amount)`) and withdrawing (`withdraw(double amount)`). The `withdraw` method should return a boolean indicating success (true) or failure (false) due to insufficient funds.
 *     *   Include a getter for `accountNumber` and `balance`.
 *     *   Implement validation within `deposit` and `withdraw` to ensure the amount is positive.
 * 
 * 2.  **Transaction Management:**
 *     *   Create a `Transaction` class with private fields for `accountNumber` (String), `amount` (double), and `type` (enum `TransactionType`: `DEPOSIT`, `WITHDRAW`).
 *     *   Include getters for these fields.
 * 
 * 3.  **System Core (`BankingSystem` Class):**
 *     *   Maintain a collection of `Account` objects. Use an `ArrayList` referenced by the `List` interface. Initialize this list with a few sample accounts in the constructor.
 *     *   Maintain a queue of `Transaction` objects waiting to be processed. Use a `Queue`.
 *     *   Implement a menu-driven interface using `Scanner` for user interaction.
 *     *   Use a `switch` statement to handle user menu choices.
 *     *   The menu options should be:
 *         1.  **Add Transaction:** Prompt the user for transaction type (deposit/withdraw), account number, and amount. Create a `Transaction` object and add it to the transaction queue. Perform basic input validation (positive amount, valid type).
 *         2.  **Process Next Transaction:** Take the next transaction from the queue (FIFO). Find the corresponding account. Attempt to perform the deposit or withdrawal. Report success or failure (account not found, insufficient funds, etc.).
 *         3.  **View Accounts:** Display the details (account number and balance) of all accounts in the system.
 *         4.  **Exit:** Terminate the program.
 * 
 * 4.  **Error Handling & Output:**
 *     *   Use `System.out` for all normal output (menu, prompts, successful transaction messages, account details).
 *     *   Use `System.err` for all error messages (invalid input, account not found, insufficient funds, queue empty, etc.).
 *     *   Implement input validation for user inputs (menu choice, transaction details). Handle potential `InputMismatchException` from `Scanner`.
 *     *   Implement a class-wide `try-catch` block in the main loop of the `BankingSystem` to catch any unexpected exceptions during the execution of a menu option and prevent the program from crashing abruptly. Print a generic error message using `System.err`.
 * 
 * 5.  **Best Practices:**
 *     *   Use meaningful variable and method names.
 *     *   Provide basic comments explaining key parts of the code.
 *     *   Ensure proper encapsulation (private fields, public methods).
 *     *   Close the `Scanner` resource when exiting.
 * 
 * **Sample Initial Accounts:**
 * 
 * *   Account 1: Number "101", Balance 1000.0
 * *   Account 2: Number "202", Balance 500.0
 * *   Account 3: Number "303", Balance 200.0
 * 
 * **Expected Output Structure:**
 * 
 * ```
 * ### Banking Transaction Processor ###
 * Choose an action:
 * 1. Add Transaction
 * 2. Process Next Transaction
 * 3. View Accounts
 * 4. Exit
 * Enter choice: [User Input]
 * 
 * [System Output based on choice]
 * 
 * [If error, output to System.err]
 * 
 * ### Banking Transaction Processor ###
 * Choose an action:
 * ... (repeats until Exit)
 * ```
 * 
 * **Evaluation:**
 * 
 * Your solution will be evaluated on:
 * *   Correct implementation and usage of ALL required Java components (`Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.err`, `System.out`, `try-catch`).
 * *   Accuracy of the banking logic (deposits, withdrawals, balance updates).
 * *   Robustness of error handling and input validation.
 * *   Adherence to best practices (encapsulation, naming, comments).
 * *   Overall code structure and clarity.
 * 
 * **Note:** You do not need to make the data persistent (saving to file/database). The system can reset on each run.
 *
 * EXPLANATION:
 * The solution implements a simple banking transaction processor as requested, demonstrating the required Java concepts and best practices.
 * 
 * 1.  **Class Structure:**
 *     *   `Account` class: Encapsulates account data (`accountNumber`, `balance`) and behavior (`deposit`, `withdraw`). Private fields and public methods ensure proper encapsulation. Input validation for positive amounts is included in deposit/withdraw methods.
 *     *   `Transaction` class: Represents a transaction request, holding the target account, amount, and type. It's a simple data holder.
 *     *   `TransactionType` enum: Defines the possible types of transactions (`DEPOSIT`, `WITHDRAW`), making the code more readable and preventing invalid type strings.
 *     *   `BankingSystem` class: The main class that orchestrates the system. It holds the collections of accounts and pending transactions and manages user interaction.
 * 
 * 2.  **Required Component Usage:**
 *     *   `Queue`: A `LinkedList` is used to implement the `Queue` interface (`transactionQueue`). Transactions are added using `offer()` and processed FIFO using `poll()`. This correctly simulates a queue of pending tasks.
 *     *   `ArrayList`: Used to store the `Account` objects.
 *     *   `List interface`: The `accounts` collection is declared as `List<Account> accounts = new ArrayList<>();`, demonstrating programming to the interface.
 *     *   `Scanner`: An instance is created (`scanner`) to read user input from `System.in` for menu choices and transaction details. `scanner.nextLine()` is used after `nextInt()` or `nextDouble()` to consume the leftover newline character.
 *     *   `switch statement`: Used in the `start()` method to direct the program flow based on the user's menu choice.
 *     *   `System.err`: Exclusively used for printing error messages, such as invalid input, account not found, insufficient funds, queue empty, and unexpected exceptions caught by the general `try-catch`.
 *     *   `System.out`: Used for all other output, including the menu, prompts, successful operation messages, and account details.
 *     *   Class-wide `try-catch`: A `try-catch(Exception e)` block is placed inside the main `while` loop in the `start()` method, surrounding the `switch` statement. This catches any unhandled exceptions that might occur during the execution of a specific menu option (like a logic error or an unexpected runtime exception) and prints an error message to `System.err`, preventing the program from crashing and allowing the menu loop to continue. Specific input validation (like `InputMismatchException` for `Scanner`) is handled separately *before* the main `try-catch` block to allow the program to recover gracefully from bad input.
 * 
 * 3.  **Error Handling and Validation:**
 *     *   Input validation: The code checks if the menu choice is an integer (`InputMismatchException` handled). It validates transaction type using `TransactionType.valueOf()`. It validates transaction amount is a positive number and handles `InputMismatchException` if non-numeric input is given.
 *     *   Transaction processing errors:
 *         *   `processNextTransaction()` checks if the queue is empty.
 *         *   It calls `findAccountByNumber()` and checks for a `null` return to indicate the account was not found.
 *         *   The `withdraw()` method in `Account` handles insufficient funds and returns a boolean indicating success/failure, printing an error message to `System.err` on failure.
 *         *   `IllegalArgumentException` is used in `Account` methods to enforce positive amounts, although the `addTransaction` method already validates this before adding to the queue.
 * 
 * 4.  **Best Practices:**
 *     *   Meaningful names: Class names (`Account`, `Transaction`, `BankingSystem`), method names (`addTransaction`, `processNextTransaction`, `findAccountByNumber`), and variable names (`accountNumber`, `balance`, `transactionQueue`) are descriptive.
 *     *   Encapsulation: Fields in `Account` and `Transaction` are private with public getters (and mutators where appropriate like `deposit`/`withdraw`).
 *     *   Comments: Basic comments explain the purpose of classes, key methods, and important sections of code. Javadoc-style comments are used for public methods and constructors.
 *     *   Resource Management: The `scanner.close()` call ensures the `Scanner` resource is released when the application exits.
 * 
 * This solution effectively integrates the required Java components within a practical scenario, demonstrating understanding of data structures, object-oriented principles, user interaction, and robust error handling.
 */

import java.util.ArrayList;
import java.util.LinkedList; // LinkedList implements Queue
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.InputMismatchException;

// Enum for transaction types
enum TransactionType {
    DEPOSIT, WITHDRAW
}

// Represents a bank account
class Account {
    private String accountNumber;
    private double balance;

    /**
     * Constructs a new Account.
     * @param accountNumber The unique account number.
     * @param initialBalance The starting balance.
     */
    public Account(String accountNumber, double initialBalance) {
        this.accountNumber = accountNumber;
        this.balance = initialBalance;
    }

    /**
     * Gets the account number.
     * @return The account number.
     */
    public String getAccountNumber() {
        return accountNumber;
    }

    /**
     * Gets the current balance.
     * @return The current balance.
     */
    public double getBalance() {
        return balance;
    }

    /**
     * Deposits funds into the account.
     * @param amount The amount to deposit. Must be positive.
     * @throws IllegalArgumentException if amount is not positive.
     */
    public void deposit(double amount) {
        if (amount <= 0) {
            throw new IllegalArgumentException("Deposit amount must be positive.");
        }
        this.balance += amount;
        System.out.println("Deposit of " + String.format("%.2f", amount) + " successful for account " + accountNumber);
    }

    /**
     * Withdraws funds from the account.
     * @param amount The amount to withdraw. Must be positive.
     * @return true if withdrawal was successful, false otherwise (insufficient funds).
     * @throws IllegalArgumentException if amount is not positive.
     */
    public boolean withdraw(double amount) {
        if (amount <= 0) {
            throw new IllegalArgumentException("Withdrawal amount must be positive.");
        }
        if (this.balance >= amount) {
            this.balance -= amount;
            System.out.println("Withdrawal of " + String.format("%.2f", amount) + " successful for account " + accountNumber);
            return true;
        } else {
            System.err.println("Error: Insufficient funds for account " + accountNumber + ". Current balance: " + String.format("%.2f", this.balance));
            return false;
        }
    }

    @Override
    public String toString() {
        return "Account " + accountNumber + " | Balance: " + String.format("%.2f", balance);
    }
}

// Represents a transaction request
class Transaction {
    private String accountNumber;
    private double amount;
    private TransactionType type;

    /**
     * Constructs a new Transaction.
     * @param accountNumber The target account number.
     * @param amount The transaction amount.
     * @param type The type of transaction (DEPOSIT or WITHDRAW).
     */
    public Transaction(String accountNumber, double amount, TransactionType type) {
        this.accountNumber = accountNumber;
        this.amount = amount;
        this.type = type;
    }

    /**
     * Gets the target account number.
     * @return The account number.
     */
    public String getAccountNumber() {
        return accountNumber;
    }

    /**
     * Gets the transaction amount.
     * @return The amount.
     */
    public double getAmount() {
        return amount;
    }

    /**
     * Gets the transaction type.
     * @return The type (DEPOSIT or WITHDRAW).
     */
    public TransactionType getType() {
        return type;
    }

    @Override
    public String toString() {
        return type + " transaction for account " + accountNumber + " with amount " + String.format("%.2f", amount);
    }
}

// The main banking system processor
public class BankingSystem {

    // Use List interface, implemented by ArrayList
    private List<Account> accounts;
    // Use Queue interface, implemented by LinkedList
    private Queue<Transaction> transactionQueue;
    private Scanner scanner;

    /**
     * Constructs the BankingSystem and initializes accounts and queue.
     */
    public BankingSystem() {
        // Initialize accounts using ArrayList
        accounts = new ArrayList<>();
        // Add sample accounts
        accounts.add(new Account("101", 1000.0));
        accounts.add(new Account("202", 500.0));
        accounts.add(new Account("303", 200.0));

        // Initialize transaction queue using LinkedList
        transactionQueue = new LinkedList<>();
        scanner = new Scanner(System.in);
    }

    /**
     * Finds an account by its account number.
     * @param accountNumber The account number to search for.
     * @return The Account object if found, null otherwise.
     */
    private Account findAccountByNumber(String accountNumber) {
        for (Account account : accounts) {
            if (account.getAccountNumber().equals(accountNumber)) {
                return account;
            }
        }
        return null; // Account not found
    }

    /**
     * Adds a transaction to the queue based on user input.
     */
    private void addTransaction() {
        System.out.println("\n--- Add Transaction ---");
        System.out.print("Enter account number: ");
        String accNumber = scanner.nextLine();

        System.out.print("Enter transaction type (DEPOSIT/WITHDRAW): ");
        String typeStr = scanner.nextLine().trim().toUpperCase();
        TransactionType type;
        try {
            type = TransactionType.valueOf(typeStr);
        } catch (IllegalArgumentException e) {
            System.err.println("Error: Invalid transaction type. Please enter DEPOSIT or WITHDRAW.");
            return;
        }

        System.out.print("Enter amount: ");
        double amount;
        try {
            amount = scanner.nextDouble();
            scanner.nextLine(); // Consume newline left-over
        } catch (InputMismatchException e) {
            System.err.println("Error: Invalid amount. Please enter a number.");
            scanner.nextLine(); // Consume the invalid input
            return;
        }

        // Validate amount positive
        if (amount <= 0) {
             System.err.println("Error: Amount must be positive.");
             return;
        }


        // Optional: Check if account exists before adding transaction?
        // For this task, we'll add it and handle account not found during processing.

        Transaction transaction = new Transaction(accNumber, amount, type);
        transactionQueue.offer(transaction); // Add to the end of the queue
        System.out.println("Transaction added to queue: " + transaction);
    }

    /**
     * Processes the next transaction from the queue.
     */
    private void processNextTransaction() {
        System.out.println("\n--- Processing Transaction ---");
        Transaction nextTransaction = transactionQueue.poll(); // Get and remove the head of the queue

        if (nextTransaction == null) {
            System.out.println("Transaction queue is empty. Nothing to process.");
            return;
        }

        System.out.println("Processing: " + nextTransaction);

        Account targetAccount = findAccountByNumber(nextTransaction.getAccountNumber());

        if (targetAccount == null) {
            System.err.println("Error: Account " + nextTransaction.getAccountNumber() + " not found.");
            return;
        }

        try {
            if (nextTransaction.getType() == TransactionType.DEPOSIT) {
                targetAccount.deposit(nextTransaction.getAmount());
            } else { // WITHDRAW
                // withdraw method handles insufficient funds internally and prints error
                targetAccount.withdraw(nextTransaction.getAmount());
            }
        } catch (IllegalArgumentException e) {
             // This catches negative amounts if somehow they bypassed initial validation
             System.err.println("Processing Error: " + e.getMessage());
        }
    }

    /**
     * Displays details of all accounts.
     */
    private void viewAccounts() {
        System.out.println("\n--- Account Details ---");
        if (accounts.isEmpty()) {
            System.out.println("No accounts in the system.");
        } else {
            for (Account account : accounts) {
                System.out.println(account);
            }
        }
        System.out.println("-----------------------");
    }

    /**
     * Starts the banking system application loop.
     */
    public void start() {
        int choice = -1;

        while (choice != 4) {
            printMenu();
            try {
                System.out.print("Enter choice: ");
                choice = scanner.nextInt();
                scanner.nextLine(); // Consume newline left-over

                // Class-wide try-catch around the core logic of each menu choice
                try {
                    switch (choice) {
                        case 1:
                            addTransaction();
                            break;
                        case 2:
                            processNextTransaction();
                            break;
                        case 3:
                            viewAccounts();
                            break;
                        case 4:
                            System.out.println("Exiting Banking System. Goodbye!");
                            break;
                        default:
                            System.err.println("Invalid choice. Please enter a number between 1 and 4.");
                    }
                } catch (Exception e) {
                    // Catch any unexpected exceptions during an operation
                    System.err.println("An unexpected error occurred during operation: " + e.getMessage());
                    // e.printStackTrace(); // Uncomment for debugging purposes
                }

            } catch (InputMismatchException e) {
                System.err.println("Invalid input. Please enter a number.");
                scanner.nextLine(); // Consume the invalid input to prevent infinite loop
                choice = -1; // Reset choice to stay in loop
            }
            System.out.println(); // Add a blank line for readability
        }

        // Close the scanner resource
        scanner.close();
    }

    /**
     * Prints the main menu options.
     */
    private void printMenu() {
        System.out.println("### Banking Transaction Processor ###");
        System.out.println("Choose an action:");
        System.out.println("1. Add Transaction");
        System.out.println("2. Process Next Transaction");
        System.out.println("3. View Accounts");
        System.out.println("4. Exit");
    }

    // Main method to run the application
    public static void main(String[] args) {
        BankingSystem system = new BankingSystem();
        system.start();
    }
}
