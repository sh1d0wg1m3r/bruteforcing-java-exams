/*
 * Exam Question #875
 * Generated on: 2025-05-12 16:53:45
 * Generated by: Account 3
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Restaurant Order Management System
 * 
 * **Objective:**
 * 
 * Design and implement a simplified command-line based restaurant order management system. The system should allow users to view a menu, place new orders, process the next order in the queue, and view the current order queue. This task requires demonstrating proficiency in using core Java collections, control flow, input/output, and exception handling.
 * 
 * **Requirements:**
 * 
 * 1.  **Menu:** The system must have a pre-defined menu of food items.
 * 2.  **Orders:** Customers can place orders consisting of one or more menu items. Orders should be processed in the order they were received.
 * 3.  **User Interface:** A command-line interface using `java.util.Scanner` to interact with the user. The user should be presented with options (e.g., View Menu, Place Order, Process Order, View Queue, Exit).
 * 4.  **Core Components:** Your solution MUST utilize ALL of the following Java components:
 *     *   `java.util.Queue`: To hold orders waiting to be processed.
 *     *   `java.util.ArrayList`: To store the menu items.
 *     *   `java.util.List`: Use the `List` interface when referring to the menu collection where appropriate (e.g., method parameters or variable types).
 *     *   `java.util.Scanner`: For reading user input.
 *     *   `switch` statement: To handle the different user menu options.
 *     *   `System.err`: For displaying error messages (e.g., invalid input, queue empty).
 *     *   `System.out`: For displaying normal output (menu, order details, prompts).
 *     *   Class-wide `try-catch` blocks: To handle potential exceptions during program execution, particularly around the main user interaction loop.
 * 
 * 5.  **Data Structures:**
 *     *   Create a `MenuItem` class (or equivalent structure) to represent a menu item with properties like ID, name, and price.
 *     *   Create an `Order` class (or equivalent structure) to represent a customer order, containing a list of `MenuItem`s and a unique order identifier.
 * 
 * 6.  **Functionality:**
 *     *   **View Menu:** Display the list of available menu items with their IDs and prices.
 *     *   **Place Order:**
 *         *   Prompt the user to enter the IDs of the menu items they wish to order, one by one. Allow adding multiple items until the user indicates they are done.
 *         *   Validate that the entered item ID exists in the menu. If not, display an error using `System.err` and allow re-entry or skipping.
 *         *   Create a new `Order` object containing the selected items.
 *         *   Add the new `Order` to the order queue.
 *         *   Display a confirmation message using `System.out`.
 *     *   **Process Order:**
 *         *   Remove the next order from the front of the queue.
 *         *   Display the details of the processed order (Order ID, items, total price).
 *         *   If the queue is empty, display an error message using `System.err`.
 *     *   **View Order Queue:**
 *         *   Display the number of orders currently waiting in the queue.
 *         *   Optionally, display the IDs of the orders in the queue (without removing them).
 *         *   If the queue is empty, display a message using `System.out`.
 *     *   **Exit:** Terminate the program.
 * 
 * 7.  **Best Practices:**
 *     *   Implement proper encapsulation for your classes (`MenuItem`, `Order`).
 *     *   Use meaningful variable and method names.
 *     *   Include comments where necessary to explain complex logic.
 *     *   Perform input validation (e.g., checking if input is a number, if item ID is valid).
 *     *   Implement robust error handling using `try-catch` and `System.err`.
 *     *   Structure your code logically.
 * 
 * **Expected Output Structure:**
 * 
 * The program should start by displaying the menu options. Based on user input, it should perform the requested action, displaying results or errors appropriately using `System.out` and `System.err`.
 * 
 * Example interaction flow:
 * 
 * ```
 * --- Restaurant Order Management ---
 * 1. View Menu
 * 2. Place Order
 * 3. Process Next Order
 * 4. View Order Queue
 * 5. Exit
 * Enter your choice: 1
 * --- Menu ---
 * ID: 1, Name: Burger, Price: 8.99
 * ID: 2, Name: Fries, Price: 3.49
 * ID: 3, Name: Soda, Price: 1.99
 * --------------------
 * Enter your choice: 2
 * Enter menu item ID to add (or 0 to finish): 1
 * Added: Burger
 * Enter menu item ID to add (or 0 to finish): 2
 * Added: Fries
 * Enter menu item ID to add (or 0 to finish): 0
 * Order #1 placed. Total items: 2
 * Enter your choice: 4
 * Orders in queue: 1
 * Queue: [Order #1]
 * Enter your choice: 3
 * Processing Order #1:
 * - Burger (8.99)
 * - Fries (3.49)
 * Total: 12.48
 * Order #1 processed.
 * Enter your choice: 4
 * Orders in queue: 0
 * Queue is empty.
 * Enter your choice: 3
 * No orders in the queue to process.
 * Enter your choice: 5
 * Exiting system.
 * ```
 * 
 * **Evaluation:**
 * 
 * Your solution will be evaluated based on:
 * *   Correctness and completeness of functionality.
 * *   Adherence to all specified component requirements.
 * *   Implementation of best practices (encapsulation, naming, comments, validation, error handling).
 * *   Code structure and readability.
 * *   Proper use of `System.out` and `System.err`.
 *
 * EXPLANATION:
 * This solution implements a basic restaurant order management system demonstrating the required Java concepts.
 * 
 * 1.  **Class Structure:**
 *     *   `MenuItem`: A simple class encapsulating the properties of a menu item (`id`, `name`, `price`) with private fields and public getter methods. This follows encapsulation principles.
 *     *   `Order`: Represents an order with a unique `orderId` (generated using a static counter) and a `List` of `MenuItem`s. It includes a method to calculate the total price. Encapsulation is used here as well.
 *     *   `RestaurantSystem`: The main class containing the `main` method and static fields for the `menu` (`List<MenuItem>`) and `orderQueue` (`Queue<Order>`). Static fields are used for simplicity in this single-file exam context, allowing direct access from `main` and helper methods without instance creation.
 * 
 * 2.  **Required Components Usage:**
 *     *   `java.util.ArrayList`: Used to implement the `menu` list, allowing dynamic resizing and easy access to menu items.
 *     *   `java.util.List`: The `menu` is declared as `List<MenuItem>`, demonstrating the use of the interface type, which is good practice. The `Order` class also uses `List<MenuItem>` for its items.
 *     *   `java.util.Queue`: Implemented using `java.util.LinkedList` (`LinkedList` implements `Queue`). This is used to store `Order` objects in a First-In, First-Out (FIFO) manner, simulating orders waiting to be processed by the kitchen. `offer()` is used to add orders, and `poll()` is used to remove and retrieve the next order.
 *     *   `java.util.Scanner`: Used in the `main` method and `getUserChoice`, `placeOrder` methods to read user input from the console.
 *     *   `switch` statement: Located in the `main` method, it controls the program flow by executing different code blocks based on the user's menu choice.
 *     *   `System.err`: Used specifically for displaying error messages, such as invalid menu choices, non-numeric input, menu items not found, or attempting to process an order when the queue is empty. This separates error output from normal program output (`System.out`).
 *     *   `System.out`: Used for all normal program output, including displaying the menu, menu options, prompts, order details, and success messages.
 *     *   Class-wide `try-catch`: A `try-catch` block wraps the entire `do-while` loop in the `main` method. This provides a high-level safety net to catch any unexpected exceptions that might occur during the program's execution, preventing it from crashing abruptly. More specific `try-catch` blocks are also used within `placeOrder` to handle expected input issues (`InputMismatchException`).
 * 
 * 3.  **Functionality Implementation:**
 *     *   **Menu Initialization:** The `menu` `ArrayList` is populated with `MenuItem` objects in a static initializer block, ensuring the menu is ready when the class is loaded.
 *     *   **User Interaction Loop:** The `do-while` loop in `main` continuously displays options and processes user input until the user chooses to exit (option 5).
 *     *   **Input Validation:**
 *         *   `getUserChoice()` validates that the input is an integer using `hasNextInt()` and consumes invalid input lines.
 *         *   `placeOrder()` uses a `try-catch` block to handle `InputMismatchException` if the user enters non-numeric input for item IDs. It also checks if the entered item ID exists in the `menu` list by iterating through it.
 *     *   **Place Order:** Collects item IDs from the user, validates them, creates an `Order` object, and adds it to the `orderQueue` using `offer()`.
 *     *   **Process Order:** Retrieves and removes the next order from the `orderQueue` using `poll()`. It handles the case where the queue is empty by checking if `poll()` returns `null`.
 *     *   **View Order Queue:** Displays the size of the queue using `orderQueue.size()`. It also shows the default `toString()` representation of the queue, which lists the elements (using the `Order` class's `toString()`).
 *     *   **Error Handling:** Specific error messages are printed to `System.err` for validation failures and empty queue conditions. The main `try-catch` provides a general fallback.
 * 
 * 4.  **Best Practices:**
 *     *   **Encapsulation:** Private fields and public getters are used in `MenuItem` and `Order`.
 *     *   **Naming:** Variables and methods have clear, descriptive names (e.g., `orderQueue`, `placeOrder`, `findMenuItemById`).
 *     *   **Readability:** The code is structured into logical methods, and comments explain key parts like the static initializer block and the purpose of `System.err`.
 *     *   **Error Handling:** Input validation is performed, specific exceptions (`InputMismatchException`) are caught where appropriate, and a general `try-catch` is used around the main loop. `System.err` differentiates error output.
 * 
 * This solution effectively integrates all required components into a practical scenario, demonstrating key Java programming skills suitable for an advanced exam task.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.InputMismatchException;

// Represents a single item on the menu
class MenuItem {
    private int id;
    private String name;
    private double price;

    public MenuItem(int id, String name, double price) {
        this.id = id;
        this.name = name;
        this.price = price;
    }

    public int getId() {
        return id;
    }

    public String getName() {
        return name;
    }

    public double getPrice() {
        return price;
    }

    @Override
    public String toString() {
        return "ID: " + id + ", Name: " + name + ", Price: " + String.format("%.2f", price);
    }
}

// Represents a customer order
class Order {
    private static int nextOrderId = 1; // Static counter for unique order IDs
    private int orderId;
    private List<MenuItem> items;

    public Order(List<MenuItem> items) {
        this.orderId = nextOrderId++;
        this.items = new ArrayList<>(items); // Create a copy to avoid external modification
    }

    public int getOrderId() {
        return orderId;
    }

    public List<MenuItem> getItems() {
        return new ArrayList<>(items); // Return a copy
    }

    public double getTotalPrice() {
        double total = 0;
        for (MenuItem item : items) {
            total += item.getPrice();
        }
        return total;
    }

    @Override
    public String toString() {
        return "Order #" + orderId;
    }
}

// Main class for the Restaurant Order Management System
public class RestaurantSystem {

    // Use List interface, implement with ArrayList
    private static final List<MenuItem> menu = new ArrayList<>();
    // Use Queue interface, implement with LinkedList for FIFO behavior
    private static final Queue<Order> orderQueue = new LinkedList<>();
    private static Scanner scanner = new Scanner(System.in);

    // Static block to initialize the menu
    static {
        menu.add(new MenuItem(1, "Burger", 8.99));
        menu.add(new MenuItem(2, "Fries", 3.49));
        menu.add(new MenuItem(3, "Soda", 1.99));
        menu.add(new MenuItem(4, "Pizza Slice", 5.50));
        menu.add(new MenuItem(5, "Salad", 7.00));
    }

    public static void main(String[] args) {
        System.out.println("--- Restaurant Order Management ---");

        // Class-wide exception handling for the main loop
        try {
            int choice;
            do {
                displayMenuOptions();
                choice = getUserChoice();

                // Use switch statement for flow control
                switch (choice) {
                    case 1:
                        displayMenu();
                        break;
                    case 2:
                        placeOrder();
                        break;
                    case 3:
                        processOrder();
                        break;
                    case 4:
                        viewOrderQueue();
                        break;
                    case 5:
                        System.out.println("Exiting system.");
                        break;
                    default:
                        // Use System.err for invalid input messages
                        System.err.println("Invalid choice. Please enter a number between 1 and 5.");
                        break;
                }
                System.out.println(); // Add a newline for better readability

            } while (choice != 5);

        } catch (Exception e) {
            // Catch any unexpected exceptions during the main program flow
            System.err.println("An unexpected error occurred: " + e.getMessage());
            // e.printStackTrace(); // Optional: for debugging
        } finally {
            // Ensure the scanner is closed
            if (scanner != null) {
                scanner.close();
            }
        }
    }

    // Displays the main menu options to the user
    private static void displayMenuOptions() {
        System.out.println("1. View Menu");
        System.out.println("2. Place Order");
        System.out.println("3. Process Next Order");
        System.out.println("4. View Order Queue");
        System.out.println("5. Exit");
        System.out.print("Enter your choice: ");
    }

    // Reads and validates the user's menu choice
    private static int getUserChoice() {
        while (!scanner.hasNextInt()) {
            System.err.println("Invalid input. Please enter a number.");
            scanner.next(); // Consume the invalid input
            System.out.print("Enter your choice: ");
        }
        int choice = scanner.nextInt();
        scanner.nextLine(); // Consume the newline character left by nextInt()
        return choice;
    }

    // Displays the restaurant menu
    private static void displayMenu() {
        System.out.println("--- Menu ---");
        if (menu.isEmpty()) {
            System.out.println("Menu is currently empty.");
        } else {
            for (MenuItem item : menu) {
                System.out.println(item); // MenuItem's toString is used here
            }
        }
        System.out.println("------------");
    }

    // Allows the user to place a new order
    private static void placeOrder() {
        List<MenuItem> currentOrderItems = new ArrayList<>();
        System.out.println("--- Place New Order ---");
        System.out.println("Enter menu item ID to add (or 0 to finish):");

        while (true) {
            System.out.print("> ");
            int itemId;
            try {
                itemId = scanner.nextInt();
                scanner.nextLine(); // Consume newline

                if (itemId == 0) {
                    break; // User finished adding items
                }

                // Find the menu item by ID
                MenuItem selectedItem = findMenuItemById(itemId);

                if (selectedItem != null) {
                    currentOrderItems.add(selectedItem);
                    System.out.println("Added: " + selectedItem.getName());
                } else {
                    // Use System.err for item not found
                    System.err.println("Error: Menu item with ID " + itemId + " not found.");
                }
            } catch (InputMismatchException e) {
                // Use System.err for non-integer input
                System.err.println("Invalid input. Please enter a number.");
                scanner.nextLine(); // Consume the invalid input line
            } catch (Exception e) {
                // Catch other potential errors during item selection
                System.err.println("An error occurred while adding item: " + e.getMessage());
                scanner.nextLine(); // Consume the invalid input line if any
            }
        }

        if (currentOrderItems.isEmpty()) {
            System.out.println("No items added to the order.");
        } else {
            Order newOrder = new Order(currentOrderItems);
            orderQueue.offer(newOrder); // Add order to the queue
            System.out.println("Order #" + newOrder.getOrderId() + " placed. Total items: " + newOrder.getItems().size());
        }
    }

    // Finds a MenuItem by its ID
    private static MenuItem findMenuItemById(int id) {
        for (MenuItem item : menu) {
            if (item.getId() == id) {
                return item;
            }
        }
        return null; // Item not found
    }

    // Processes the next order in the queue
    private static void processOrder() {
        System.out.println("--- Process Next Order ---");
        // Use poll() which returns null if queue is empty, safer than remove()
        Order nextOrder = orderQueue.poll();

        if (nextOrder == null) {
            // Use System.err when queue is empty
            System.err.println("No orders in the queue to process.");
        } else {
            System.out.println("Processing " + nextOrder + ":"); // Order's toString is used
            for (MenuItem item : nextOrder.getItems()) {
                System.out.println("- " + item.getName() + " (" + String.format("%.2f", item.getPrice()) + ")");
            }
            System.out.println("Total: " + String.format("%.2f", nextOrder.getTotalPrice()));
            System.out.println(nextOrder + " processed.");
        }
    }

    // Displays the current state of the order queue
    private static void viewOrderQueue() {
        System.out.println("--- Order Queue Status ---");
        System.out.println("Orders in queue: " + orderQueue.size());

        if (orderQueue.isEmpty()) {
            System.out.println("Queue is empty.");
        } else {
            // Iterate through the queue without removing elements (e.g., using peek or iterator)
            // This simple example just shows the Order objects using the queue's toString
            // Note: Default Queue toString might not be ideal, iterating is better for details
             System.out.println("Queue: " + orderQueue); // Shows default representation like [Order #1, Order #2]

            // Alternative: Iterate and print details (more complex, but better info)
            /*
            System.out.print("Queue (Order IDs): [");
            boolean first = true;
            for (Order order : orderQueue) { // Iterating over a Queue
                if (!first) {
                    System.out.print(", ");
                }
                System.out.print(order.getOrderId());
                first = false;
            }
            System.out.println("]");
            */
        }
        System.out.println("--------------------");
    }
}
