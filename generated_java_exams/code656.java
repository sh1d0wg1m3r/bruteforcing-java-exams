/*
 * Exam Question #656
 * Generated on: 2025-05-12 16:20:49
 * Generated by: Account 5
 * 
 * QUESTION:
 * ## Advanced Java Programming Exam Task: Event Management System
 * 
 * **Problem Description:**
 * 
 * You are tasked with developing a simplified Event Management System in Java. This system should allow users to manage multiple events, register attendees for these events, and handle a queue of tasks associated with each event (e.g., sending confirmations, processing payments).
 * 
 * Your solution must demonstrate a strong understanding of fundamental Java data structures, object-oriented principles, user interaction, and error handling.
 * 
 * **Requirements:**
 * 
 * 1.  **Core Functionality:**
 *     *   The system must manage a collection of events. Each event should have a name, date, a list of registered attendees, and a queue of pending tasks.
 *     *   Users should be able to interact with the system via a command-line interface.
 *     *   The system should support the following operations through a menu:
 *         *   **Create Event:** Add a new event with a unique name and date.
 *         *   **Register Attendee:** Register an attendee (with name and email) for an existing event.
 *         *   **List Attendees:** Display all registered attendees for a specific event.
 *         *   **Add Event Task:** Add a new task description to the task queue of a specific event.
 *         *   **Process Event Tasks:** Process (simulate execution) all tasks currently in the queue for a specific event.
 *         *   **List Events:** Display the names and dates of all existing events.
 *         *   **Exit:** Terminate the program.
 * 
 * 2.  **Required Java Components:** Your solution *must* use the following Java components:
 *     *   `java.util.Queue` (for event tasks)
 *     *   `java.util.ArrayList` (for storing attendees within an event)
 *     *   `java.util.List` interface (used for declaring variables or method return types where applicable, e.g., storing events or attendees)
 *     *   `java.util.Scanner` (for reading user input)
 *     *   `switch` statement (for handling menu options)
 *     *   `System.err` (for outputting error messages, e.g., event not found, invalid input)
 *     *   `System.out` (for outputting normal information, e.g., menu, lists, confirmations)
 *     *   Class-wide exception handling with `try-catch` blocks (at least in the main interaction loop)
 * 
 * 3.  **Best Practices:**
 *     *   Implement proper encapsulation using private fields and public methods in your classes (`Attendee`, `Event`, `EventManager`).
 *     *   Use meaningful variable and method names.
 *     *   Include appropriate comments and documentation (basic Javadoc style is sufficient for key classes/methods).
 *     *   Implement input validation (e.g., checking if an event exists before performing operations on it, handling non-numeric input for menu selection).
 *     *   Ensure proper error handling using `System.err` for user-friendly error messages.
 *     *   Maintain a clean and logical code structure.
 * 
 * **Classes to Consider (Recommended Structure):**
 * 
 * *   `Attendee` class: Represents an attendee with name and email.
 * *   `Event` class: Represents an event with name, date, a `List` of `Attendee` objects, and a `Queue` of `String` task descriptions.
 * *   `EventManager` class: Manages a `List` of `Event` objects and provides methods for interacting with events and attendees.
 * *   `Main` class: Contains the `main` method, handles user interaction, menu display, input reading using `Scanner`, and delegates operations to the `EventManager`.
 * 
 * **Expected Output:**
 * 
 * The program should present a menu to the user. Based on the user's input, it should perform the requested operation and print relevant output to `System.out` or error messages to `System.err`.
 * 
 * Example Interaction Flow:
 * 
 * ```
 * --- Event Management Menu ---
 * 1. Create Event
 * 2. List Events
 * 3. Register Attendee
 * 4. List Attendees for Event
 * 5. Add Event Task
 * 6. Process Event Tasks
 * 7. Exit
 * Enter your choice: 1
 * Enter event name: JavaCon
 * Enter event date (e.g., 2024-10-27): 2024-10-27
 * Event 'JavaCon' created.
 * 
 * --- Event Management Menu ---
 * ...
 * Enter your choice: 2
 * --- All Events ---
 * Name: JavaCon, Date: 2024-10-27
 * 
 * --- Event Management Menu ---
 * ...
 * Enter your choice: 3
 * Enter event name to register attendee: JavaCon
 * Enter attendee name: Alice
 * Enter attendee email: alice@example.com
 * Attendee Alice registered for JavaCon.
 * 
 * --- Event Management Menu ---
 * ...
 * Enter your choice: 4
 * Enter event name to list attendees: JavaCon
 * --- Attendees for JavaCon ---
 * - Name: Alice, Email: alice@example.com
 * 
 * --- Event Management Menu ---
 * ...
 * Enter your choice: 5
 * Enter event name to add task: JavaCon
 * Enter task description: Send confirmation email to new attendees
 * Task added to JavaCon queue.
 * 
 * --- Event Management Menu ---
 * ...
 * Enter your choice: 6
 * Enter event name to process tasks: JavaCon
 * Processing tasks for JavaCon...
 * Task processed: Send confirmation email to new attendees
 * No more tasks in queue for JavaCon.
 * 
 * --- Event Management Menu ---
 * ...
 * Enter your choice: 7
 * Exiting Event Management System.
 * ```
 * 
 * Error handling examples:
 * 
 * ```
 * Enter your choice: 9
 * System.err: Invalid choice. Please enter a number between 1 and 7.
 * 
 * Enter your choice: 3
 * Enter event name to register attendee: NonExistentEvent
 * System.err: Error: Event 'NonExistentEvent' not found.
 * 
 * Enter your choice: 6
 * Enter event name to process tasks: JavaCon
 * (If queue is empty)
 * System.out: No tasks in queue for JavaCon.
 * ```
 * 
 * Your solution should be a single Java file containing all necessary classes.
 * 
 * **Evaluation Criteria:**
 * 
 * *   Correct implementation of all required Java components.
 * *   Correct implementation of core functionality.
 * *   Adherence to best practices (encapsulation, naming, comments).
 * *   Robust input validation and error handling using `System.err`.
 * *   Clean and well-structured code.
 * 
 * Good luck!
 *
 * EXPLANATION:
 * This solution implements a basic Event Management System demonstrating the required Java concepts and best practices.
 * 
 * 1.  **Class Structure:**
 *     *   `Attendee`: A simple Plain Old Java Object (POJO) representing an attendee with private fields (`name`, `email`) and public getters, demonstrating encapsulation.
 *     *   `Event`: Represents an event. It holds event details (`name`, `date`) and manages its associated data structures: a `List` of `Attendee` objects (`ArrayList` implementation) and a `Queue` of task `String`s (`LinkedList` implementation). This showcases using interfaces (`List`, `Queue`) and concrete implementations (`ArrayList`, `LinkedList`). It also uses encapsulation for its fields.
 *     *   `EventManager`: Acts as the central controller. It manages a `List` of `Event` objects (`ArrayList` implementation). It contains methods for all the core business logic (adding events, finding events, registering attendees, adding tasks, processing tasks, listing events). This class encapsulates the collection of events and the operations on them.
 *     *   `EventManagementSystem` (Main class): Contains the `main` method. This class is responsible for user interaction: displaying the menu, reading input using `Scanner`, validating basic input, and calling the appropriate methods in the `EventManager` based on the user's choice.
 * 
 * 2.  **Required Component Usage:**
 *     *   `Queue`: Used in the `Event` class (`tasks` field) to store task descriptions. Tasks are added using `offer()` and processed (removed) using `poll()`, adhering to the FIFO (First-In, First-Out) principle of a queue.
 *     *   `ArrayList`: Used in the `Event` class (`attendees` field) and the `EventManager` class (`events` field) to store dynamic lists of objects.
 *     *   `List interface`: Used in the declarations `private List<Attendee> attendees;` and `private List<Event> events;`. This is a good practice as it allows the underlying implementation (`ArrayList` in this case) to be changed later without affecting the code that uses the `List` interface.
 *     *   `Scanner`: Used in the `main` method to read user input from the console.
 *     *   `switch statement`: Used in the `main` method to select the appropriate action based on the user's numeric menu choice.
 *     *   `System.err`: Used throughout the `main` method and `EventManager` to print error messages (e.g., "Event not found", "Invalid input").
 *     *   `System.out`: Used for printing the menu, confirmation messages, lists of events and attendees, and task processing output.
 *     *   `try-catch`: A `try-catch` block wraps the main `while` loop in the `main` method to catch potential unexpected exceptions during the program's execution, demonstrating class-wide (or method-wide) handling. A more specific `try-catch` is used around `scanner.nextInt()` to handle `InputMismatchException` gracefully when the user enters non-numeric input for the menu choice.
 * 
 * 3.  **Best Practices:**
 *     *   **Encapsulation:** Private fields and public getters/methods are used in `Attendee`, `Event`, and `EventManager`.
 *     *   **Naming:** Variable names (`eventName`, `attendeeName`, `taskDescription`, `events`, `attendees`, `tasks`) and method names (`addEvent`, `registerAttendee`, `processTasks`) are descriptive.
 *     *   **Comments/Documentation:** Basic Javadoc-style comments are provided for classes and key methods explaining their purpose.
 *     *   **Input Validation:** Checks are performed for empty input strings and for the existence of events before attempting operations on them. The `InputMismatchException` for numeric input is specifically caught.
 *     *   **Error Handling:** Error conditions (like event not found, invalid menu choice, invalid input type) are explicitly checked, and informative messages are printed to `System.err`.
 *     *   **Clean Code Structure:** The logic is separated into distinct classes with specific responsibilities. The `main` method is kept relatively clean by delegating complex operations to the `EventManager`. The `printMenu` method further separates presentation logic.
 * 
 * This solution effectively integrates the required components into a functional, albeit simplified, system, demonstrating core Java programming skills suitable for an advanced exam.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.InputMismatchException;

/**
 * Represents an attendee for an event.
 */
class Attendee {
    private String name;
    private String email;

    /**
     * Constructs an Attendee object.
     * @param name The name of the attendee.
     * @param email The email of the attendee.
     */
    public Attendee(String name, String email) {
        this.name = name;
        this.email = email;
    }

    /**
     * Gets the attendee's name.
     * @return The attendee's name.
     */
    public String getName() {
        return name;
    }

    /**
     * Gets the attendee's email.
     * @return The attendee's email.
     */
    public String getEmail() {
        return email;
    }

    @Override
    public String toString() {
        return "- Name: " + name + ", Email: " + email;
    }
}

/**
 * Represents an event with attendees and a task queue.
 */
class Event {
    private String name;
    private String date;
    // Using List interface for flexibility, implemented by ArrayList
    private List<Attendee> attendees;
    // Using Queue interface, implemented by LinkedList
    private Queue<String> tasks;

    /**
     * Constructs an Event object.
     * @param name The name of the event.
     * @param date The date of the event.
     */
    public Event(String name, String date) {
        this.name = name;
        this.date = date;
        this.attendees = new ArrayList<>(); // Use ArrayList for attendees
        this.tasks = new LinkedList<>(); // Use LinkedList as a Queue implementation
    }

    /**
     * Gets the event name.
     * @return The event name.
     */
    public String getName() {
        return name;
    }

    /**
     * Gets the event date.
     * @return The event date.
     */
    public String getDate() {
        return date;
    }

    /**
     * Adds an attendee to the event.
     * @param attendee The Attendee object to add.
     */
    public void addAttendee(Attendee attendee) {
        attendees.add(attendee);
    }

    /**
     * Gets the list of attendees.
     * @return The List of Attendee objects.
     */
    public List<Attendee> getAttendees() {
        return attendees;
    }

    /**
     * Adds a task description to the event's task queue.
     * @param taskDescription The description of the task.
     */
    public void addTask(String taskDescription) {
        tasks.offer(taskDescription); // offer is preferred over add for queues
    }

    /**
     * Gets the event's task queue.
     * @return The Queue of task descriptions.
     */
    public Queue<String> getTasks() {
        return tasks;
    }

    @Override
    public String toString() {
        return "Name: " + name + ", Date: " + date;
    }
}

/**
 * Manages a collection of events.
 */
class EventManager {
    // Using List interface for flexibility, implemented by ArrayList
    private List<Event> events;

    /**
     * Constructs an EventManager object.
     */
    public EventManager() {
        this.events = new ArrayList<>(); // Use ArrayList for storing events
    }

    /**
     * Adds a new event to the manager.
     * Checks for duplicate event names.
     * @param name The name of the event.
     * @param date The date of the event.
     * @return true if the event was added successfully, false otherwise (e.g., duplicate name).
     */
    public boolean addEvent(String name, String date) {
        if (findEvent(name) != null) {
            return false; // Event with this name already exists
        }
        Event newEvent = new Event(name, date);
        events.add(newEvent);
        return true;
    }

    /**
     * Finds an event by its name.
     * @param name The name of the event to find.
     * @return The Event object if found, otherwise null.
     */
    public Event findEvent(String name) {
        for (Event event : events) {
            if (event.getName().equalsIgnoreCase(name)) {
                return event;
            }
        }
        return null; // Event not found
    }

    /**
     * Registers an attendee for a specific event.
     * @param eventName The name of the event.
     * @param attendeeName The name of the attendee.
     * @param attendeeEmail The email of the attendee.
     * @return true if attendee was registered successfully, false if event not found.
     */
    public boolean registerAttendee(String eventName, String attendeeName, String attendeeEmail) {
        Event event = findEvent(eventName);
        if (event == null) {
            return false; // Event not found
        }
        Attendee newAttendee = new Attendee(attendeeName, attendeeEmail);
        event.addAttendee(newAttendee);
        return true;
    }

    /**
     * Displays attendees for a specific event.
     * @param eventName The name of the event.
     * @return true if event was found and attendees listed, false if event not found.
     */
    public boolean listAttendees(String eventName) {
        Event event = findEvent(eventName);
        if (event == null) {
            return false; // Event not found
        }
        System.out.println("--- Attendees for " + event.getName() + " ---");
        List<Attendee> attendees = event.getAttendees();
        if (attendees.isEmpty()) {
            System.out.println("No attendees registered yet.");
        } else {
            for (Attendee attendee : attendees) {
                System.out.println(attendee);
            }
        }
        return true;
    }

    /**
     * Adds a task to an event's task queue.
     * @param eventName The name of the event.
     * @param taskDescription The description of the task.
     * @return true if task was added successfully, false if event not found.
     */
    public boolean addTask(String eventName, String taskDescription) {
        Event event = findEvent(eventName);
        if (event == null) {
            return false; // Event not found
        }
        event.addTask(taskDescription);
        return true;
    }

    /**
     * Processes all tasks in an event's task queue.
     * @param eventName The name of the event.
     * @return true if event was found and tasks processed, false if event not found.
     */
    public boolean processTasks(String eventName) {
        Event event = findEvent(eventName);
        if (event == null) {
            return false; // Event not found
        }
        System.out.println("Processing tasks for " + event.getName() + "...");
        Queue<String> tasks = event.getTasks();
        if (tasks.isEmpty()) {
            System.out.println("No tasks in queue for " + event.getName() + ".");
        } else {
            while (!tasks.isEmpty()) {
                String task = tasks.poll(); // poll retrieves and removes the head of the queue
                System.out.println("Task processed: " + task);
                // Simulate work if needed, e.g., Thread.sleep(100);
            }
            System.out.println("Finished processing tasks for " + event.getName() + ".");
        }
        return true;
    }

    /**
     * Lists all events managed by the system.
     */
    public void listEvents() {
        System.out.println("--- All Events ---");
        if (events.isEmpty()) {
            System.out.println("No events created yet.");
        } else {
            for (Event event : events) {
                System.out.println(event);
            }
        }
    }
}

/**
 * Main class for the Event Management System application.
 * Handles user interaction and the main application loop.
 */
public class EventManagementSystem {

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        EventManager eventManager = new EventManager();
        boolean running = true;

        // Class-wide exception handling for the main loop
        try {
            while (running) {
                printMenu();
                int choice = -1;
                try {
                    System.out.print("Enter your choice: ");
                    choice = scanner.nextInt();
                    // Consume the newline character left by nextInt()
                    scanner.nextLine();
                } catch (InputMismatchException e) {
                    System.err.println("Invalid input. Please enter a number.");
                    scanner.nextLine(); // Consume the invalid input line
                    continue; // Skip to the next iteration
                }

                // Use switch statement for flow control based on user choice
                switch (choice) {
                    case 1: // Create Event
                        System.out.print("Enter event name: ");
                        String eventName = scanner.nextLine();
                        System.out.print("Enter event date (e.g., 2024-10-27): ");
                        String eventDate = scanner.nextLine();
                        if (eventName.trim().isEmpty() || eventDate.trim().isEmpty()) {
                             System.err.println("Event name and date cannot be empty.");
                        } else if (eventManager.addEvent(eventName, eventDate)) {
                            System.out.println("Event '" + eventName + "' created.");
                        } else {
                            System.err.println("Error: Event '" + eventName + "' already exists.");
                        }
                        break;

                    case 2: // List Events
                        eventManager.listEvents();
                        break;

                    case 3: // Register Attendee
                        System.out.print("Enter event name to register attendee: ");
                        String regEventName = scanner.nextLine();
                        System.out.print("Enter attendee name: ");
                        String attendeeName = scanner.nextLine();
                        System.out.print("Enter attendee email: ");
                        String attendeeEmail = scanner.nextLine();
                         if (regEventName.trim().isEmpty() || attendeeName.trim().isEmpty() || attendeeEmail.trim().isEmpty()) {
                             System.err.println("Event name, attendee name, and email cannot be empty.");
                         } else if (eventManager.registerAttendee(regEventName, attendeeName, attendeeEmail)) {
                            System.out.println("Attendee " + attendeeName + " registered for " + regEventName + ".");
                        } else {
                            System.err.println("Error: Event '" + regEventName + "' not found.");
                        }
                        break;

                    case 4: // List Attendees for Event
                        System.out.print("Enter event name to list attendees: ");
                        String listEventName = scanner.nextLine();
                         if (listEventName.trim().isEmpty()) {
                             System.err.println("Event name cannot be empty.");
                         } else if (!eventManager.listAttendees(listEventName)) {
                            System.err.println("Error: Event '" + listEventName + "' not found.");
                        }
                        break;

                    case 5: // Add Event Task
                        System.out.print("Enter event name to add task: ");
                        String taskEventName = scanner.nextLine();
                        System.out.print("Enter task description: ");
                        String taskDescription = scanner.nextLine();
                         if (taskEventName.trim().isEmpty() || taskDescription.trim().isEmpty()) {
                             System.err.println("Event name and task description cannot be empty.");
                         } else if (eventManager.addTask(taskEventName, taskDescription)) {
                            System.out.println("Task added to " + taskEventName + " queue.");
                        } else {
                            System.err.println("Error: Event '" + taskEventName + "' not found.");
                        }
                        break;

                    case 6: // Process Event Tasks
                        System.out.print("Enter event name to process tasks: ");
                        String processEventName = scanner.nextLine();
                         if (processEventName.trim().isEmpty()) {
                             System.err.println("Event name cannot be empty.");
                         } else if (!eventManager.processTasks(processEventName)) {
                            System.err.println("Error: Event '" + processEventName + "' not found.");
                        }
                        break;

                    case 7: // Exit
                        running = false;
                        System.out.println("Exiting Event Management System.");
                        break;

                    default:
                        System.err.println("Invalid choice. Please enter a number between 1 and 7.");
                }
            }
        } catch (Exception e) {
            // Catch any unexpected exceptions during execution
            System.err.println("An unexpected error occurred: " + e.getMessage());
            e.printStackTrace(System.err); // Print stack trace to System.err
        } finally {
            // Ensure the scanner is closed
            scanner.close();
        }
    }

    /**
     * Prints the main menu options to the console.
     */
    private static void printMenu() {
        System.out.println("\n--- Event Management Menu ---");
        System.out.println("1. Create Event");
        System.out.println("2. List Events");
        System.out.println("3. Register Attendee");
        System.out.println("4. List Attendees for Event");
        System.out.println("5. Add Event Task");
        System.out.println("6. Process Event Tasks");
        System.out.println("7. Exit");
    }
}
