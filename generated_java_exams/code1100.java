/*
 * Exam Question #1100
 * Generated on: 2025-05-12 17:24:56
 * Generated by: Account 4
 * 
 * QUESTION:
 * **Java Programming Exam Task: Software Update Deployment System**
 * 
 * You are tasked with developing a simplified system to manage software updates waiting for deployment to servers and track their deployment history. This system should allow users to add new updates, trigger the deployment of the next pending update, and view the list of pending and deployed updates.
 * 
 * Your solution must adhere to the following requirements:
 * 
 * 1.  **Data Structures:**
 *     *   Use a `java.util.Queue` to store updates that are pending deployment. Updates should be processed in a First-In, First-Out (FIFO) manner.
 *     *   Use a `java.util.List` (specifically an `ArrayList`) to store a history of updates that have been deployed (successfully or not).
 * 
 * 2.  **Classes:**
 *     *   Create a class `Update` to represent a software update. It should have private fields for `id` (int), `name` (String), `version` (String), and `status` (an enum `UpdateStatus`). Include a constructor and public getter methods for all fields.
 *     *   Create an enum `UpdateStatus` with values like `PENDING`, `DEPLOYING`, `COMPLETED`, `FAILED`.
 *     *   Create a class `DeploymentSystem` that manages the `Queue` of pending updates and the `List` of history. It should have methods for:
 *         *   `addUpdate(Update update)`: Adds a new update to the pending queue.
 *         *   `deployNextUpdate()`: Removes the next update from the pending queue, simulates deployment (you can just change its status), and adds it to the history list. This method should handle the case where the queue is empty.
 *         *   `getPendingUpdates()`: Returns a `List` view of the current pending updates (without removing them from the queue).
 *         *   `getHistory()`: Returns the `List` of deployed updates.
 *     *   Create a main class (e.g., `DeploymentConsole`) with a `main` method to handle user interaction.
 * 
 * 3.  **User Interface (Console):**
 *     *   Use `java.util.Scanner` to get user input.
 *     *   Present a menu of options to the user:
 *         1.  Add New Update
 *         2.  Deploy Next Update
 *         3.  View Pending Updates
 *         4.  View Deployment History
 *         5.  Exit
 *     *   Use a `switch` statement to process the user's menu choice.
 *     *   Prompt the user for necessary details when adding an update (ID, Name, Version). Ensure ID is a positive integer.
 *     *   Use `System.out` for menu, prompts, successful operation messages, and listing updates/history.
 *     *   Use `System.err` for displaying error messages (e.g., invalid input, queue empty error).
 * 
 * 4.  **Error Handling:**
 *     *   Implement input validation for user-provided data (e.g., ID must be a positive integer). Use `System.err` for validation errors.
 *     *   Use `try-catch` blocks to handle potential exceptions, such as `java.util.InputMismatchException` when reading integer input or attempting to deploy from an empty queue. You may define a simple custom exception like `EmptyQueueException` for the latter.
 *     *   Include a general `try-catch` in the main loop to catch unexpected errors and report them using `System.err`.
 * 
 * 5.  **Best Practices:**
 *     *   Use meaningful variable and method names.
 *     *   Apply proper encapsulation (private fields, public methods).
 *     *   Include basic comments explaining the purpose of classes and complex logic sections.
 *     *   Ensure clean code structure.
 * 
 * **Expected Output Snippets:**
 * 
 * *   **Menu:**
 *     ```
 *     --- Deployment System Menu ---
 *     1. Add New Update
 *     2. Deploy Next Update
 *     3. View Pending Updates
 *     4. View Deployment History
 *     5. Exit
 *     Enter your choice:
 *     ```
 * *   **Adding Update:**
 *     ```
 *     Enter Update ID (positive integer): 101
 *     Enter Update Name: Security Patch
 *     Enter Update Version: 1.0.5
 *     Update added to pending queue: Update{id=101, name='Security Patch', version='1.0.5', status=PENDING}
 *     ```
 * *   **Deploying Update:**
 *     ```
 *     Deploying update: Update{id=101, name='Security Patch', version='1.0.5', status=PENDING}
 *     Update deployed and moved to history: Update{id=101, name='Security Patch', version='1.0.5', status=COMPLETED}
 *     ```
 *     (If queue is empty):
 *     ```
 *     Error: No updates pending deployment.
 *     ```
 * *   **Viewing Pending:**
 *     ```
 *     --- Pending Updates ---
 *     Update{id=102, name='Feature X', version='2.0', status=PENDING}
 *     Update{id=103, name='Bug Fix', version='1.1', status=PENDING}
 *     -----------------------
 *     ```
 * *   **Viewing History:**
 *     ```
 *     --- Deployment History ---
 *     Update{id=101, name='Security Patch', version='1.0.5', status=COMPLETED}
 *     ------------------------
 *     ```
 * *   **Error Message (Example - invalid input):**
 *     ```
 *     Error: Invalid input. Please enter a positive integer for ID.
 *     ```
 * *   **Error Message (Example - Empty Queue):**
 *     ```
 *     Error: No updates pending deployment.
 *     ```
 * 
 * Implement the complete Java code for this system.
 *
 * EXPLANATION:
 * This solution implements a simplified software update deployment system, fulfilling all the specified requirements and demonstrating the use of the required Java components and best practices.
 * 
 * 1.  **Required Components Usage:**
 *     *   `Queue`: Used in `DeploymentSystem` as `pendingUpdates` (specifically `LinkedList` which implements `Queue`) to manage updates awaiting deployment in FIFO order. `offer()` is used for adding and `poll()` for removing.
 *     *   `ArrayList`: Used in `DeploymentSystem` as `history` to store updates after they have been processed.
 *     *   `List interface`: The `history` field is declared as `List<Update>`, demonstrating programming to the interface. Methods like `getPendingUpdates()` and `getHistory()` return `List`.
 *     *   `Scanner`: Used in the `main` method of `DeploymentConsole` to read user input from the console.
 *     *   `switch` statement: Used in the `main` method to handle the different menu options selected by the user.
 *     *   `System.err`: Used to print error messages, such as invalid input, empty queue errors, or unexpected exceptions.
 *     *   `System.out`: Used for printing the menu, prompts, successful operation messages, and the lists of pending and historical updates.
 *     *   `try-catch`: Used extensively for exception handling:
 *         *   In `main`, a `try-catch` block surrounds the main loop's core logic to catch `InputMismatchException` from `scanner.nextInt()` and a general `Exception` for any other unexpected issues.
 *         *   In `addNewUpdate`, a `try-catch` handles `InputMismatchException` for reading the ID and `IllegalArgumentException` thrown by the `Update` constructor if the ID is invalid.
 *         *   In `deployNextUpdate`, a `try-catch` handles the custom `EmptyQueueException`.
 * 
 * 2.  **Creativity and Practicality:** The Software Update Deployment System simulates a common IT scenario where tasks (updates) are queued for processing (deployment) and a record is kept. This provides a practical context for using queues and lists together.
 * 
 * 3.  **Best Practices:**
 *     *   **Encapsulation:** The `Update` class fields (`id`, `name`, `version`, `status`) are private, with public getter methods. The `DeploymentSystem` fields (`pendingUpdates`, `history`) are private, with public methods (`addUpdate`, `deployNextUpdate`, `getPendingUpdates`, `getHistory`) controlling access and modification.
 *     *   **Meaningful Names:** Class names (`Update`, `DeploymentSystem`, `DeploymentConsole`), method names (`addUpdate`, `deployNextUpdate`, `viewPendingUpdates`), variable names (`pendingUpdates`, `history`, `updateToDeploy`, `choice`), and the enum (`UpdateStatus`) are descriptive.
 *     *   **Comments/Documentation:** Javadoc-style comments are used for key methods in `DeploymentSystem`. Inline comments explain specific logic points.
 *     *   **Input Validation:** The `addNewUpdate` method checks if the entered ID is positive. The `Update` constructor also validates the ID. `InputMismatchException` is caught for non-integer input.
 *     *   **Error Handling:** Specific exceptions (`InputMismatchException`, `IllegalArgumentException`, `EmptyQueueException`) are handled where appropriate. `System.err` is used for error reporting. A general `catch` in `main` provides robustness.
 *     *   **Clean Code Structure:** The code is organized into logical classes (`Update`, `DeploymentSystem`, `DeploymentConsole`). The `main` method is kept clean by delegating specific tasks (adding, deploying, viewing) to separate private methods.
 * 
 * 4.  **Challenge Level:** The task requires integrating multiple data structures and control flow mechanisms (`Queue`, `List`, `Scanner`, `switch`) within an object-oriented structure (`Update`, `DeploymentSystem`). Implementing robust error handling with specific and general `try-catch` blocks and input validation adds complexity suitable for an advanced exam question. The simulation of state change (PENDING to COMPLETED) and managing items moving between collections (Queue to List) are key challenges. The custom `EmptyQueueException` demonstrates creating and handling user-defined exceptions.
 * 
 * The solution provides a clear, well-structured implementation that meets all the requirements and demonstrates a solid understanding of core and advanced Java concepts.
 */

import java.util.ArrayList;
import java.util.LinkedList; // LinkedList implements Queue
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.InputMismatchException;

// Custom exception for empty queue
class EmptyQueueException extends Exception {
    public EmptyQueueException(String message) {
        super(message);
    }
}

// Enum for Update Status
enum UpdateStatus {
    PENDING,
    DEPLOYING, // Could be used for a more complex simulation, but simple transition is fine
    COMPLETED,
    FAILED // Could be added for more complex simulation
}

// Class representing a software update
class Update {
    private int id;
    private String name;
    private String version;
    private UpdateStatus status;

    // Constructor
    public Update(int id, String name, String version) {
        if (id <= 0) {
            throw new IllegalArgumentException("Update ID must be a positive integer.");
        }
        this.id = id;
        this.name = name;
        this.version = version;
        this.status = UpdateStatus.PENDING; // New updates start as PENDING
    }

    // Getters
    public int getId() {
        return id;
    }

    public String getName() {
        return name;
    }

    public String getVersion() {
        return version;
    }

    public UpdateStatus getStatus() {
        return status;
    }

    // Method to change status (for simulation)
    public void setStatus(UpdateStatus status) {
        this.status = status;
    }

    @Override
    public String toString() {
        return "Update{id=" + id + ", name='" + name + '\'' + ", version='" + version + '\'' + ", status=" + status + '}';
    }
}

// Class managing the deployment system
class DeploymentSystem {
    // Use Queue for pending updates (FIFO)
    private Queue<Update> pendingUpdates;
    // Use List for deployment history
    private List<Update> history;

    // Constructor
    public DeploymentSystem() {
        this.pendingUpdates = new LinkedList<>(); // LinkedList implements Queue
        this.history = new ArrayList<>();
    }

    /**
     * Adds a new update to the pending queue.
     * @param update The update to add.
     */
    public void addUpdate(Update update) {
        if (update != null) {
            pendingUpdates.offer(update); // offer is preferred over add in queues
        }
    }

    /**
     * Deploys the next update from the pending queue.
     * @return The deployed update.
     * @throws EmptyQueueException if the pending queue is empty.
     */
    public Update deployNextUpdate() throws EmptyQueueException {
        // poll() retrieves and removes the head of the queue, returns null if empty
        Update updateToDeploy = pendingUpdates.poll();

        if (updateToDeploy == null) {
            throw new EmptyQueueException("No updates pending deployment.");
        }

        // Simulate deployment
        System.out.println("Deploying update: " + updateToDeploy);
        updateToDeploy.setStatus(UpdateStatus.COMPLETED); // Assume successful deployment

        // Add to history
        history.add(updateToDeploy);

        return updateToDeploy;
    }

    /**
     * Returns a list of updates currently in the pending queue without removing them.
     * @return A new List containing pending updates.
     */
    public List<Update> getPendingUpdates() {
        // Return a copy or an unmodifiable list to prevent external modification
        return new ArrayList<>(pendingUpdates); // Simple copy for exam purposes
    }

    /**
     * Returns the list of updates in the history.
     * @return The List of historical updates.
     */
    public List<Update> getHistory() {
        return history; // Return the actual list for exam purposes
    }
}

// Main class for console interaction
public class DeploymentConsole {

    private static DeploymentSystem deploymentSystem = new DeploymentSystem();
    private static Scanner scanner = new Scanner(System.in);

    public static void main(String[] args) {
        System.out.println("--- Software Update Deployment System ---");

        boolean running = true;
        while (running) {
            printMenu();
            try {
                System.out.print("Enter your choice: ");
                int choice = scanner.nextInt();
                scanner.nextLine(); // Consume newline

                switch (choice) {
                    case 1:
                        addNewUpdate();
                        break;
                    case 2:
                        deployNextUpdate();
                        break;
                    case 3:
                        viewPendingUpdates();
                        break;
                    case 4:
                        viewDeploymentHistory();
                        break;
                    case 5:
                        running = false;
                        System.out.println("Exiting system. Goodbye!");
                        break;
                    default:
                        System.err.println("Error: Invalid choice. Please enter a number between 1 and 5.");
                }
            } catch (InputMismatchException e) {
                System.err.println("Error: Invalid input. Please enter a number.");
                scanner.nextLine(); // Consume the invalid input to prevent infinite loop
            } catch (Exception e) {
                // Catch any other unexpected exceptions
                System.err.println("An unexpected error occurred: " + e.getMessage());
                e.printStackTrace(System.err); // Print stack trace to error stream
            }
            System.out.println(); // Add a blank line for readability
        }

        scanner.close(); // Close the scanner when exiting
    }

    private static void printMenu() {
        System.out.println("--- Deployment System Menu ---");
        System.out.println("1. Add New Update");
        System.out.println("2. Deploy Next Update");
        System.out.println("3. View Pending Updates");
        System.out.println("4. View Deployment History");
        System.out.println("5. Exit");
        System.out.println("------------------------------");
    }

    private static void addNewUpdate() {
        int id = -1;
        try {
            System.out.print("Enter Update ID (positive integer): ");
            id = scanner.nextInt();
            scanner.nextLine(); // Consume newline

            if (id <= 0) {
                 System.err.println("Error: Update ID must be a positive integer.");
                 return; // Exit method if ID is not positive
            }

            System.out.print("Enter Update Name: ");
            String name = scanner.nextLine();

            System.out.print("Enter Update Version: ");
            String version = scanner.nextLine();

            Update newUpdate = new Update(id, name, version);
            deploymentSystem.addUpdate(newUpdate);
            System.out.println("Update added to pending queue: " + newUpdate);

        } catch (InputMismatchException e) {
            System.err.println("Error: Invalid input. Please enter a positive integer for ID.");
            scanner.nextLine(); // Consume invalid input
        } catch (IllegalArgumentException e) {
             System.err.println("Error creating update: " + e.getMessage());
        } catch (Exception e) {
             System.err.println("An error occurred while adding update: " + e.getMessage());
        }
    }

    private static void deployNextUpdate() {
        try {
            Update deployed = deploymentSystem.deployNextUpdate();
            System.out.println("Update deployed and moved to history: " + deployed);
        } catch (EmptyQueueException e) {
            System.err.println("Error: " + e.getMessage());
        } catch (Exception e) {
            System.err.println("An error occurred during deployment: " + e.getMessage());
        }
    }

    private static void viewPendingUpdates() {
        List<Update> pending = deploymentSystem.getPendingUpdates();
        System.out.println("--- Pending Updates ---");
        if (pending.isEmpty()) {
            System.out.println("No updates pending.");
        } else {
            for (Update update : pending) {
                System.out.println(update);
            }
        }
        System.out.println("-----------------------");
    }

    private static void viewDeploymentHistory() {
        List<Update> history = deploymentSystem.getHistory();
        System.out.println("--- Deployment History ---");
        if (history.isEmpty()) {
            System.out.println("No deployment history yet.");
        } else {
            for (Update update : history) {
                System.out.println(update);
            }
        }
        System.out.println("------------------------");
    }
}
