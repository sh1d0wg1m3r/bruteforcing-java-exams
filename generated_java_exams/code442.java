/*
 * Exam Question #442
 * Generated on: 2025-05-11 23:11:54
 * Generated by: Account 1
 * 
 * QUESTION:
 * ## Advanced Java Programming Exam Task: Prioritized Help Desk Ticket System
 * 
 * **Objective:** Design and implement a simple Help Desk Ticket System that manages support requests using queues and lists, incorporating robust user interaction, error handling, and best practices.
 * 
 * **Scenario:** You need to build a console-based application that simulates a basic help desk. The system should allow users (simulating support staff or administrators) to add new support tickets, process the oldest waiting ticket, view the list of waiting tickets, and view a history of completed tickets.
 * 
 * **Requirements:**
 * 
 * 1.  **Ticket Representation:** Create a `Ticket` class with the following attributes:
 *     *   `id`: A unique integer identifier (automatically generated by the system).
 *     *   `description`: A String describing the issue.
 *     *   `severity`: A String representing the ticket's severity (e.g., "Low", "Medium", "High", "Critical").
 *     *   The class should have a constructor, appropriate getters, and a `toString()` method for easy display. Attributes should be private.
 * 
 * 2.  **System Management:** Create a `HelpDeskSystem` class responsible for managing the tickets. It should contain:
 *     *   A `Queue<Ticket>` to store tickets that are waiting to be processed.
 *     *   A `List<Ticket>` to store tickets that have been completed.
 *     *   A mechanism to generate unique ticket IDs.
 * 
 * 3.  **Functionality:** Implement the following operations within the `HelpDeskSystem`:
 *     *   **Add Ticket:** Prompt the user for the ticket description and severity. Validate that the severity is one of the allowed values ("Low", "Medium", "High", "Critical"). If valid, create a new `Ticket` object with a unique ID and add it to the waiting queue. Use `System.out` for prompts and success messages.
 *     *   **Process Next Ticket:** Take the ticket from the front of the waiting queue. If the queue is not empty, move the ticket to the completed list and display a success message using `System.out`. If the queue is empty, display an error message using `System.err`.
 *     *   **View Waiting Queue:** Display all tickets currently in the waiting queue in their current order. If the queue is empty, display a message indicating that. Use `System.out`.
 *     *   **View Completed History:** Display all tickets that have been processed and moved to the completed list. If the history is empty, display a message indicating that. Use `System.out`.
 *     *   **Exit:** Terminate the application.
 * 
 * 4.  **User Interface:** Implement a simple menu-driven interface using `Scanner` to get user input for selecting operations and providing ticket details. Use a `switch` statement to handle the different menu options.
 * 
 * 5.  **Error Handling:**
 *     *   Implement input validation for severity level.
 *     *   Use `System.err` to display error messages (e.g., invalid input, trying to process an empty queue).
 *     *   Implement **class-wide** exception handling using `try-catch` blocks within the main operational logic (e.g., wrapping the main menu loop) to catch unexpected errors and prevent the program from crashing abruptly.
 * 
 * 6.  **Required Java Components:** Your solution MUST utilize all of the following:
 *     *   `java.util.Queue`
 *     *   `java.util.ArrayList`
 *     *   `java.util.List` (as a variable type)
 *     *   `java.util.Scanner`
 *     *   `switch` statement
 *     *   `System.err`
 *     *   `System.out`
 *     *   `try-catch` blocks (demonstrating class-wide handling)
 * 
 * 7.  **Best Practices:**
 *     *   Employ proper encapsulation (private fields, public methods).
 *     *   Use meaningful variable and method names.
 *     *   Include appropriate comments and documentation (e.g., Javadoc).
 *     *   Ensure clean code structure (separate classes for Ticket and System, main method).
 * 
 * **Expected Output:**
 * The program should display a menu, prompt for user input, and provide clear output based on the selected operation. Error messages should be distinguishable using `System.err`. Example interaction might look like:
 * 
 * ```
 * --- Help Desk Menu ---
 * 1. Add New Ticket
 * 2. Process Next Ticket
 * 3. View Waiting Queue
 * 4. View Completed History
 * 5. Exit
 * Enter your choice: 1
 * Enter ticket description: Network connectivity issue
 * Enter severity (Low, Medium, High, Critical): High
 * Ticket 1 (High) added to the queue.
 * 
 * --- Help Desk Menu ---
 * ...
 * Enter your choice: 3
 * --- Waiting Queue ---
 * [Ticket ID: 1, Description: Network connectivity issue, Severity: High]
 * --- End Waiting Queue ---
 * 
 * --- Help Desk Menu ---
 * ...
 * Enter your choice: 2
 * Processing ticket: [Ticket ID: 1, Description: Network connectivity issue, Severity: High]
 * Ticket 1 processed and moved to history.
 * 
 * --- Help Desk Menu ---
 * ...
 * Enter your choice: 2
 * Error: No tickets in the waiting queue to process.
 * 
 * --- Help Desk Menu ---
 * ...
 * Enter your choice: 4
 * --- Completed History ---
 * [Ticket ID: 1, Description: Network connectivity issue, Severity: High]
 * --- End Completed History ---
 * 
 * --- Help Desk Menu ---
 * ...
 * Enter your choice: 5
 * Exiting Help Desk System.
 * ```
 * 
 * **Evaluation:** Your solution will be evaluated based on correctness, adherence to all requirements (including the use of specified components and best practices), and robustness in handling different scenarios and potential errors.
 * 
 * **Submission:** Provide the complete Java source code for all necessary classes.
 *
 * EXPLANATION:
 * This solution implements a console-based Help Desk Ticket System, fulfilling all the requirements of the exam task.
 * 
 * 1.  **`Ticket` Class:** Represents a single ticket with encapsulated `id`, `description`, and `severity` fields. It provides a constructor, getters, and a `toString()` method for convenient object creation and display.
 * 2.  **`HelpDeskSystem` Class:**
 *     *   **Collections:** It uses a `java.util.Queue<Ticket>` (`LinkedList` implementation) for the `waitingQueue` to maintain tickets in a First-In, First-Out (FIFO) order, simulating a processing queue. It uses a `java.util.ArrayList<Ticket>` assigned to a `java.util.List<Ticket>` variable (`completedTickets`) to store processed tickets, demonstrating the use of the `List` interface.
 *     *   **ID Generation:** A simple `nextTicketId` counter ensures unique IDs for new tickets.
 *     *   **`addTicket`:** Takes description and severity, validates the severity against a predefined list, creates a `Ticket`, and adds it to the `waitingQueue` using `queue.add()`. Uses `System.out` for success.
 *     *   **`processNextTicket`:** Uses `queue.poll()` to retrieve and remove the head of the `waitingQueue`. If `poll()` returns `null` (queue is empty), it prints an error to `System.err`. Otherwise, it adds the ticket to the `completedTickets` list and prints success messages to `System.out`.
 *     *   **`viewWaitingQueue` and `viewCompletedHistory`:** These methods iterate through the respective collections (`waitingQueue` and `completedTickets`) and print each ticket's details using its `toString()` method. They check for emptiness and print appropriate messages to `System.out`.
 *     *   **`displayMenu`:** Prints the interactive menu options to `System.out`.
 *     *   **`run`:** This is the main operational method.
 *         *   It contains the required **class-wide `try-catch` block** wrapping the main `while` loop. This block is designed to catch any unexpected `Exception` that might occur during the program's execution flow within the `run` method, preventing the application from crashing and printing an error message to `System.err`. A `finally` block ensures the `Scanner` is closed.
 *         *   It uses a `Scanner` to read user input.
 *         *   It uses a `switch` statement to execute the corresponding method based on the user's menu choice.
 *         *   It includes a nested `try-catch` specifically for parsing the user's menu input (`Integer.parseInt`) to handle `NumberFormatException` if the user enters non-numeric input, printing the error to `System.err`.
 * 
 * 3.  **`HelpDeskApp` Class:** A simple class with a `main` method to create an instance of `HelpDeskSystem` and call its `run` method to start the application.
 * 
 * **Key Concepts Demonstrated:**
 * 
 * *   **Object-Oriented Programming:** Use of classes (`Ticket`, `HelpDeskSystem`) with encapsulation.
 * *   **Collections Framework:** Practical use of `Queue` (FIFO behavior) and `List` (`ArrayList` implementation) for managing collections of objects.
 * *   **Polymorphism:** Using the `List` interface type for the `completedTickets` variable.
 * *   **User Input:** Handling console input using `Scanner`.
 * *   **Control Flow:** Using `switch` for menu navigation and `while` for the main loop.
 * *   **Error Handling:**
 *     *   Specific input validation (severity).
 *     *   Conditional error messages using `System.err` (empty queue, invalid input).
 *     *   Robust exception handling with `try-catch` blocks, including a broader catch for unexpected errors in the main execution flow (`run` method).
 * *   **Input/Output:** Using `System.out` for standard output and `System.err` for error output.
 * *   **Best Practices:** Meaningful names, comments, and logical code separation contribute to code readability and maintainability.
 * 
 * The solution effectively integrates the required Java components into a practical, albeit simplified, simulation, demonstrating understanding of fundamental data structures, user interaction, and error management in Java.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.Arrays; // Added for severity validation

/**
 * Represents a single support ticket in the Help Desk system.
 */
class Ticket {
    private int id;
    private String description;
    private String severity;

    /**
     * Constructs a new Ticket.
     *
     * @param id The unique ID for the ticket.
     * @param description The description of the issue.
     * @param severity The severity level of the ticket.
     */
    public Ticket(int id, String description, String severity) {
        this.id = id;
        this.description = description;
        this.severity = severity;
    }

    // Getters
    public int getId() {
        return id;
    }

    public String getDescription() {
        return description;
    }

    public String getSeverity() {
        return severity;
    }

    /**
     * Provides a string representation of the Ticket.
     * @return Formatted string of ticket details.
     */
    @Override
    public String toString() {
        return "[Ticket ID: " + id + ", Description: " + description + ", Severity: " + severity + "]";
    }
}

/**
 * Manages the Help Desk operations, including ticket queue and history.
 */
class HelpDeskSystem {
    // Required: Queue for waiting tickets
    private Queue<Ticket> waitingQueue;
    // Required: List for completed tickets (using List interface with ArrayList implementation)
    private List<Ticket> completedTickets;
    private int nextTicketId;
    private final List<String> allowedSeverities = Arrays.asList("Low", "Medium", "High", "Critical"); // For validation

    /**
     * Constructs a new HelpDeskSystem, initializing collections and ID counter.
     */
    public HelpDeskSystem() {
        this.waitingQueue = new LinkedList<>(); // LinkedList implements Queue
        this.completedTickets = new ArrayList<>(); // ArrayList implements List
        this.nextTicketId = 1; // Start IDs from 1
    }

    /**
     * Adds a new ticket to the waiting queue after validating input.
     *
     * @param description The ticket description.
     * @param severity The ticket severity.
     * @return true if the ticket was added successfully, false otherwise.
     */
    public boolean addTicket(String description, String severity) {
        // Input validation for severity
        if (!allowedSeverities.contains(severity)) {
            System.err.println("Error: Invalid severity level. Please use one of: " + allowedSeverities);
            return false;
        }

        Ticket newTicket = new Ticket(nextTicketId++, description, severity);
        waitingQueue.add(newTicket); // Add to the end of the queue
        System.out.println("Ticket " + newTicket.getId() + " (" + newTicket.getSeverity() + ") added to the queue.");
        return true;
    }

    /**
     * Processes the next ticket from the waiting queue, moving it to history.
     *
     * @return The processed Ticket object, or null if the queue was empty.
     */
    public Ticket processNextTicket() {
        Ticket processedTicket = waitingQueue.poll(); // Retrieve and remove the head of the queue
        if (processedTicket != null) {
            completedTickets.add(processedTicket); // Add to the completed list
            System.out.println("Processing ticket: " + processedTicket);
            System.out.println("Ticket " + processedTicket.getId() + " processed and moved to history.");
            return processedTicket;
        } else {
            System.err.println("Error: No tickets in the waiting queue to process.");
            return null;
        }
    }

    /**
     * Displays all tickets currently in the waiting queue.
     */
    public void viewWaitingQueue() {
        System.out.println("--- Waiting Queue ---");
        if (waitingQueue.isEmpty()) {
            System.out.println("The waiting queue is empty.");
        } else {
            // Iterate over the queue without removing elements
            for (Ticket ticket : waitingQueue) {
                System.out.println(ticket);
            }
        }
        System.out.println("--- End Waiting Queue ---");
    }

    /**
     * Displays all tickets in the completed history.
     */
    public void viewCompletedHistory() {
        System.out.println("--- Completed History ---");
        if (completedTickets.isEmpty()) {
            System.out.println("The completed history is empty.");
        } else {
            // Iterate over the list
            for (Ticket ticket : completedTickets) {
                System.out.println(ticket);
            }
        }
        System.out.println("--- End Completed History ---");
    }

    /**
     * Displays the main menu options to the user.
     */
    public void displayMenu() {
        System.out.println("\n--- Help Desk Menu ---");
        System.out.println("1. Add New Ticket");
        System.out.println("2. Process Next Ticket");
        System.out.println("3. View Waiting Queue");
        System.out.println("4. View Completed History");
        System.out.println("5. Exit");
        System.out.print("Enter your choice: ");
    }

    /**
     * Runs the main application loop, handling user input and operations.
     * Includes class-wide exception handling.
     */
    public void run() {
        Scanner scanner = new Scanner(System.in);
        boolean running = true;

        // Required: Class-wide try-catch block wrapping the main operational loop
        try {
            while (running) {
                displayMenu();
                int choice = -1;
                try {
                    choice = Integer.parseInt(scanner.nextLine()); // Read entire line to avoid issues
                } catch (NumberFormatException e) {
                    System.err.println("Error: Invalid input. Please enter a number.");
                    continue; // Skip to next iteration
                }

                // Required: Switch statement for menu control
                switch (choice) {
                    case 1:
                        System.out.print("Enter ticket description: ");
                        String description = scanner.nextLine();
                        System.out.print("Enter severity (Low, Medium, High, Critical): ");
                        String severity = scanner.nextLine();
                        addTicket(description, severity);
                        break;
                    case 2:
                        processNextTicket();
                        break;
                    case 3:
                        viewWaitingQueue();
                        break;
                    case 4:
                        viewCompletedHistory();
                        break;
                    case 5:
                        System.out.println("Exiting Help Desk System.");
                        running = false;
                        break;
                    default:
                        System.err.println("Error: Invalid choice. Please enter a number between 1 and 5.");
                }
            }
        } catch (Exception e) {
            // Required: Class-wide catch for unexpected exceptions
            System.err.println("\nAn unexpected error occurred: " + e.getMessage());
            e.printStackTrace(System.err); // Print stack trace to System.err
        } finally {
            // Ensure scanner is closed
            if (scanner != null) {
                scanner.close();
            }
        }
    }
}

/**
 * Main class to start the Help Desk Ticket System application.
 */
public class HelpDeskApp {
    public static void main(String[] args) {
        HelpDeskSystem system = new HelpDeskSystem();
        system.run();
    }
}
