/*
 * Exam Question #636
 * Generated on: 2025-05-12 16:18:09
 * Generated by: Account 5
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Simple Task Processing System
 * 
 * **Scenario:**
 * 
 * You are tasked with developing a simple command-line application that simulates a basic task processing system. The system manages a queue of tasks waiting to be processed and a separate list of tasks that have been completed. Users interact with the system via a menu to add tasks, process the next task, list pending tasks, or list completed tasks.
 * 
 * **Task Details:**
 * 
 * Each task should be represented by a Java object containing:
 * *   A `name` (String)
 * *   A `type` (String, e.g., "CPU", "IO", "NET")
 * 
 * **System Operations:**
 * 
 * The application must provide the following functionality through a command-line menu:
 * 
 * 1.  **Add Task:** Prompt the user for a task name and type, create a new task object, and add it to the queue of pending tasks.
 * 2.  **Process Next Task:** Remove the task at the front of the pending queue, simulate processing it, and add it to the list of completed tasks. If the queue is empty, report an error.
 * 3.  **List Pending Tasks:** Display all tasks currently in the pending queue in their waiting order.
 * 4.  **List Completed Tasks:** Display all tasks that have been processed and are in the completed list.
 * 5.  **Exit:** Terminate the application gracefully.
 * 
 * **Requirements:**
 * 
 * Your solution must adhere to the following requirements:
 * 
 * 1.  **Data Structures:**
 *     *   Use `java.util.Queue` (specifically, an implementation like `java.util.LinkedList`) for storing tasks waiting to be processed.
 *     *   Use `java.util.ArrayList` for storing tasks that have been completed.
 *     *   Use the `java.util.List` interface type where appropriate (e.g., for method return types representing collections of tasks).
 * 2.  **User Input:** Use `java.util.Scanner` to read user input for menu choices and task details.
 * 3.  **Control Flow:** Use a `switch` statement to handle the different menu options.
 * 4.  **Output:**
 *     *   Use `System.out` for displaying the menu, prompts, task lists, and success messages.
 *     *   Use `System.err` for displaying error messages (e.g., invalid input, attempting to process an empty queue).
 * 5.  **Exception Handling:**
 *     *   Implement exception handling using `try-catch` blocks.
 *     *   Handle potential `NumberFormatException` if the user enters non-numeric input for the menu choice.
 *     *   Handle the case where the user attempts to process a task from an empty queue by throwing and catching an appropriate exception (e.g., `IllegalStateException`).
 *     *   Include a general catch-all `try-catch` block in the main application logic to handle any other unexpected runtime errors.
 * 6.  **Object-Oriented Design & Best Practices:**
 *     *   Create separate classes (`Task`, `TaskScheduler`, and a main application class).
 *     *   Implement proper encapsulation using private fields and public methods (getters).
 *     *   Use meaningful names for classes, variables, and methods.
 *     *   Include basic comments explaining key sections or complex logic.
 *     *   Implement basic input validation (e.g., for menu choice).
 *     *   Ensure clear and informative error messages.
 * 
 * **Expected Output:**
 * 
 * The application should present a clear menu, prompt the user for input, display results or status messages for each operation, and display error messages on `System.err` when necessary. The interaction should resemble the example flow provided in the problem description (see thought block above for example flow).
 * 
 * Your solution should be a single Java file containing all necessary classes.
 *
 * EXPLANATION:
 * The provided solution implements a simple task processing system, demonstrating the required Java concepts and best practices.
 * 
 * **Overall Structure:**
 * The solution is organized into three classes:
 * 1.  `Task`: A simple class representing a task with private fields (`name`, `type`) and public getter methods, adhering to encapsulation principles. It also overrides `toString()` for easy printing.
 * 2.  `TaskScheduler`: This class manages the core logic. It holds the collection of pending tasks (`pendingTasks`) and completed tasks (`completedTasks`). It provides methods (`addTask`, `processNextTask`, `getPendingTasks`, `getCompletedTasks`) to interact with these collections.
 * 3.  `SchedulerApp`: This class contains the `main` method, which serves as the entry point and handles the user interface loop, reading input, calling `TaskScheduler` methods, and managing exceptions.
 * 
 * **Required Components Usage:**
 * -   **`java.util.Queue`**: The `pendingTasks` field in `TaskScheduler` is declared as a `Queue<Task>` and initialized with `new LinkedList<>()`. Tasks are added using `offer()` and removed from the front using `poll()`, demonstrating standard Queue operations.
 * -   **`java.util.ArrayList`**: The `completedTasks` field in `TaskScheduler` is initialized with `new ArrayList<>()`. Processed tasks are added to this list using `add()`.
 * -   **`java.util.List` interface**: The `completedTasks` field is declared using the `List` interface type (`List<Task>`). The methods `getPendingTasks()` and `getCompletedTasks()` are defined to return `List<Task>`, showcasing the use of the interface type for flexibility and good practice.
 * -   **`java.util.Scanner`**: A `Scanner` object is created in the `main` method (`try (Scanner scanner = new Scanner(System.in))`) to read user input from the console. `nextLine()` is used to read input lines, which is generally safer when mixing string and numeric input.
 * -   **`switch` statement**: A `switch` statement in the `main` method is used to direct the program flow based on the user's menu choice. Each case corresponds to a specific operation.
 * -   **`System.err`**: Used specifically for printing error messages, such as invalid menu input (`NumberFormatException`), attempting to process an empty queue (`IllegalStateException`), and any other unexpected exceptions caught by the general `catch` block. This separates error output from normal program output.
 * -   **`System.out`**: Used for all standard output, including displaying the menu, prompts for input, confirmation messages (task added, task processed), and listing the contents of the pending and completed task collections.
 * -   **Class-wide exception handling with `try-catch`**:
 *     *   The `main` method's core logic (the `while` loop) is wrapped in a broad `try-catch (Exception e)` block to catch any unhandled exceptions that might occur during execution.
 *     *   Specific operations known to throw exceptions are handled with dedicated `try-catch` blocks:
 *         *   `Integer.parseInt(input)` is wrapped in a `try-catch (NumberFormatException)` to handle non-numeric menu input.
 *         *   `scheduler.processNextTask()` is wrapped in a `try-catch (IllegalStateException)` to handle the specific error condition where the pending queue is empty, as thrown by the `processNextTask` method itself. This demonstrates catching exceptions thrown by other objects/methods.
 * 
 * **Best Practices:**
 * -   **Encapsulation**: Fields in `Task` and `TaskScheduler` are `private`, accessed only through public methods (`getters`, `addTask`, `processNextTask`).
 * -   **Meaningful Names**: Classes (`Task`, `TaskScheduler`, `SchedulerApp`), variables (`pendingTasks`, `completedTasks`, `taskName`, `processedTask`), and methods (`addTask`, `processNextTask`, `displayMenu`) have clear, descriptive names.
 * -   **Comments and Documentation**: Basic comments explain the purpose of classes, methods, and key code sections. Javadoc-style comments are included for methods in `Task` and `TaskScheduler`.
 * -   **Input Validation**: The code checks if the menu input is a valid integer and handles non-numeric input gracefully using `NumberFormatException`. It also handles the logical error of trying to process an empty queue.
 * -   **Proper Error Handling**: Different types of errors (input format, business logic error like empty queue, unexpected errors) are identified and handled with specific messages printed to `System.err`.
 * -   **Clean Code Structure**: The separation of concerns into different classes makes the code modular and easier to understand. The `main` method focuses on the interaction loop and error handling, delegating core task management to `TaskScheduler`. Using try-with-resources ensures the `Scanner` is closed.
 * 
 * This solution effectively integrates the required Java components into a functional program that simulates a practical scenario, demonstrating advanced understanding of data structures, control flow, object-oriented principles, and robust exception handling.
 */

import java.util.Queue;
import java.util.LinkedList;
import java.util.List;
import java.util.ArrayList;
import java.util.Scanner;
import java.util.InputMismatchException; // Although using nextLine() then parsing avoids this

// Represents a single task with a name and type.
class Task {
    private String name;
    private String type;

    /**
     * Constructs a new Task.
     * @param name The name of the task.
     * @param type The type of the task (e.g., "CPU", "IO").
     */
    public Task(String name, String type) {
        this.name = name;
        this.type = type;
    }

    /**
     * Gets the name of the task.
     * @return The task name.
     */
    public String getName() {
        return name;
    }

    /**
     * Gets the type of the task.
     * @return The task type.
     */
    public String getType() {
        return type;
    }

    /**
     * Returns a string representation of the task.
     * @return Formatted string for the task.
     */
    @Override
    public String toString() {
        return "Task [Name: " + name + ", Type: " + type + "]";
    }
}

// Manages the collection of pending and completed tasks.
class TaskScheduler {
    // Queue to hold tasks waiting to be processed (FIFO behavior)
    private Queue<Task> pendingTasks;
    // List to hold tasks that have been completed
    private List<Task> completedTasks;

    /**
     * Constructs a new TaskScheduler, initializing the task collections.
     */
    public TaskScheduler() {
        // Use LinkedList as an implementation of Queue
        this.pendingTasks = new LinkedList<>();
        // Use ArrayList as an implementation of List
        this.completedTasks = new ArrayList<>();
    }

    /**
     * Adds a task to the pending queue.
     * @param task The task to add.
     */
    public void addTask(Task task) {
        if (task != null) {
            // offer() is the preferred way to add to a queue, returns true on success
            pendingTasks.offer(task);
        }
    }

    /**
     * Processes the next task from the pending queue, moving it to the completed list.
     * @return The task that was processed.
     * @throws IllegalStateException if the pending queue is empty when processNextTask is called.
     */
    public Task processNextTask() {
        // poll() retrieves and removes the head of this queue, or returns null if this queue is empty.
        Task nextTask = pendingTasks.poll();
        if (nextTask == null) {
            // Throw an exception if there are no tasks to process
            throw new IllegalStateException("No tasks in the pending queue to process.");
        }
        // Add the processed task to the completed list
        completedTasks.add(nextTask);
        return nextTask;
    }

    /**
     * Gets a list of all pending tasks.
     * Returns a copy to prevent external modification of the internal queue state.
     * @return A List of pending tasks.
     */
    public List<Task> getPendingTasks() {
        // Return a new ArrayList containing elements from the pending queue.
        // This list is typed as the List interface.
        return new ArrayList<>(pendingTasks);
    }

    /**
     * Gets a list of all completed tasks.
     * Returns the internal list, typed as the List interface.
     * @return A List of completed tasks.
     */
    public List<Task> getCompletedTasks() {
        // Return the completedTasks list. Typed as the List interface.
        return completedTasks;
    }
}

// Main application class to run the Task Scheduler simulation.
public class SchedulerApp {

    public static void main(String[] args) {
        // Use try-with-resources for Scanner to ensure it's automatically closed
        try (Scanner scanner = new Scanner(System.in)) {
            TaskScheduler scheduler = new TaskScheduler();
            int choice = 0;

            // Outer try-catch block to handle any unexpected exceptions during the application lifecycle
            try {
                // Main application loop
                while (choice != 5) {
                    displayMenu(); // Display menu options

                    System.out.print("Enter your choice: ");
                    String input = scanner.nextLine(); // Read the entire line of input

                    try {
                        // Attempt to parse the input string into an integer
                        choice = Integer.parseInt(input);
                    } catch (NumberFormatException e) {
                        // Catch specific exception if input is not a valid number
                        System.err.println("Error: Invalid input. Please enter a number between 1 and 5.");
                        choice = 0; // Reset choice to prevent processing an invalid number like 0
                        continue; // Skip the rest of the loop and show menu again
                    }

                    // Use switch statement to handle different valid menu choices
                    switch (choice) {
                        case 1: // Add Task
                            System.out.print("Enter task name: ");
                            String taskName = scanner.nextLine();
                            System.out.print("Enter task type: ");
                            String taskType = scanner.nextLine();
                            Task newTask = new Task(taskName, taskType);
                            scheduler.addTask(newTask);
                            System.out.println("Task '" + taskName + "' added to the pending queue.");
                            break;

                        case 2: // Process Next Task
                            try {
                                // Attempt to process the next task
                                Task processedTask = scheduler.processNextTask();
                                System.out.println("Processed task: " + processedTask);
                            } catch (IllegalStateException e) {
                                // Catch exception if the queue is empty
                                System.err.println("Error: " + e.getMessage());
                            }
                            break;

                        case 3: // List Pending Tasks
                            List<Task> pending = scheduler.getPendingTasks(); // Get pending tasks as a List
                            System.out.println("--- Pending Tasks ---");
                            if (pending.isEmpty()) {
                                System.out.println("  (No pending tasks)");
                            } else {
                                for (Task task : pending) {
                                    System.out.println("  " + task); // Print each task using System.out
                                }
                            }
                            break;

                        case 4: // List Completed Tasks
                            List<Task> completed = scheduler.getCompletedTasks(); // Get completed tasks as a List
                            System.out.println("--- Completed Tasks ---");
                            if (completed.isEmpty()) {
                                System.out.println("  (No completed tasks)");
                            } else {
                                for (Task task : completed) {
                                    System.out.println("  " + task); // Print each task using System.out
                                }
                            }
                            break;

                        case 5: // Exit
                            System.out.println("Exiting Task Scheduler."); // Inform user before exiting
                            break; // Loop condition will terminate

                        default: // Handle choices that are numbers but not 1-5
                            System.err.println("Error: Invalid choice. Please enter a number between 1 and 5."); // Use System.err for invalid option error
                    }
                    System.out.println(); // Add a newline for better readability between operations
                }
            } catch (Exception e) {
                // Generic catch-all for any other unexpected runtime errors
                System.err.println("An unexpected error occurred: " + e.getMessage()); // Use System.err for unexpected errors
                // e.printStackTrace(System.err); // Uncomment for detailed debugging stack trace
            }

        } // The scanner is automatically closed here by the try-with-resources block
    }

    /**
     * Displays the main menu options to the console using System.out.
     */
    private static void displayMenu() {
        System.out.println("--- Task Scheduler Menu ---");
        System.out.println("1. Add Task");
        System.out.println("2. Process Next Task");
        System.out.println("3. List Pending Tasks");
        System.out.println("4. List Completed Tasks");
        System.out.println("5. Exit");
    }
}
