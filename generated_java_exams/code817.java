/*
 * Exam Question #817
 * Generated on: 2025-05-12 16:45:27
 * Generated by: Account 4
 * 
 * QUESTION:
 * **Java Programming Exam Task: Server Task Processor Simulation**
 * 
 * **Problem Description:**
 * 
 * You are tasked with simulating a simplified server task processing system. The system manages incoming tasks, processes them in order, and keeps a record of completed tasks. Your program should interact with the user via the console, allowing them to add new tasks, process the next waiting task, view the queue of waiting tasks, and view the list of processed tasks.
 * 
 * Each task has a unique integer ID, a description (string), and a priority (LOW, MEDIUM, HIGH). Tasks are added to a waiting queue. The server always processes the task that has been waiting the longest (First-In, First-Out behavior, though priority could be a future enhancement, for this problem stick to FIFO). Processed tasks are moved to a separate list.
 * 
 * Your solution must adhere to the following requirements:
 * 
 * 1.  **Data Structures:**
 *     *   Use `java.util.Queue` to manage the waiting tasks.
 *     *   Use `java.util.ArrayList` to store the processed tasks.
 *     *   Declare the collection for processed tasks using the `java.util.List` interface.
 * 2.  **User Interaction:**
 *     *   Use `java.util.Scanner` to read user input from the console.
 *     *   Provide a menu of options to the user.
 * 3.  **Control Flow:**
 *     *   Use a `switch` statement to handle different user commands based on their menu selection.
 * 4.  **Output:**
 *     *   Use `System.out` for all normal output (menu, task details, queue/list contents).
 *     *   Use `System.err` for displaying error messages (e.g., invalid input, attempting to process when the queue is empty).
 * 5.  **Error Handling:**
 *     *   Implement robust error handling using `try-catch` blocks. This should include handling potential issues like invalid user input (e.g., non-integer where an integer is expected) and attempting operations on empty collections. The `try-catch` mechanism should demonstrate class-wide or significant operational scope error handling.
 * 6.  **Task Management Logic:**
 *     *   Assign unique, sequential IDs to tasks starting from 1.
 *     *   Validate the priority input (accept "LOW", "MEDIUM", "HIGH", case-insensitive). Reject tasks with invalid priority and inform the user using `System.err`.
 *     *   When processing, remove the task from the queue and add it to the processed list.
 *     *   Handle the case where the queue is empty when the user tries to process a task.
 * 7.  **Best Practices:**
 *     *   Employ proper encapsulation (private fields, public methods).
 *     *   Use meaningful names for variables, methods, and classes.
 *     *   Include appropriate comments to explain key parts of the code.
 *     *   Structure the code cleanly into appropriate classes (e.g., a `Task` class and a `ServerProcessor` class).
 * 
 * **Menu Options:**
 * 
 * 1.  Add New Task
 * 2.  Process Next Task
 * 3.  View Waiting Tasks Queue
 * 4.  View Processed Tasks List
 * 5.  Exit
 * 
 * **Expected Output:**
 * 
 * *   The program should display the menu clearly.
 * *   When adding a task, it should prompt for description and priority. Confirmation messages should be displayed.
 * *   When processing a task, it should indicate which task was processed or state that the queue is empty.
 * *   Viewing queues/lists should print the details of each task.
 * *   Error messages should be distinct (using `System.err`).
 * *   The program should continue until the user chooses to exit.
 * 
 * **Example Interaction Snippet:**
 * 
 * ```
 * --- Server Task Processor ---
 * 1. Add New Task
 * 2. Process Next Task
 * 3. View Waiting Tasks Queue
 * 4. View Processed Tasks List
 * 5. Exit
 * Enter your choice: 1
 * Enter task description: Clean server room
 * Enter task priority (LOW, MEDIUM, HIGH): MEDIUM
 * Task ID 1 added to the queue.
 * 
 * --- Server Task Processor ---
 * 1. Add New Task
 * 2. Process Next Task
 * 3. View Waiting Tasks Queue
 * 4. View Processed Tasks List
 * 5. Exit
 * Enter your choice: 1
 * Enter task description: Deploy new service
 * Enter task priority (LOW, MEDIUM, HIGH): HIGH
 * Task ID 2 added to the queue.
 * 
 * --- Server Task Processor ---
 * 1. Add New Task
 * 2. Process Next Task
 * 3. View Waiting Tasks Queue
 * 4. View Processed Tasks List
 * 5. Exit
 * Enter your choice: 3
 * Waiting Tasks Queue:
 * Task ID: 1, Description: Clean server room, Priority: MEDIUM
 * Task ID: 2, Description: Deploy new service, Priority: HIGH
 * 
 * --- Server Task Processor ---
 * 1. Add New Task
 * 2. Process Next Task
 * 3. View Waiting Tasks Queue
 * 4. View Processed Tasks List
 * 5. Exit
 * Enter your choice: 2
 * Processing task: Task ID: 1, Description: Clean server room, Priority: MEDIUM
 * Task ID 1 processed.
 * 
 * --- Server Task Processor ---
 * 1. Add New Task
 * 2. Process Next Task
 * 3. View Waiting Tasks Queue
 * 4. View Processed Tasks List
 * 5. Exit
 * Enter your choice: 4
 * Processed Tasks List:
 * Task ID: 1, Description: Clean server room, Priority: MEDIUM
 * 
 * --- Server Task Processor ---
 * 1. Add New Task
 * 2. Process Next Task
 * 3. View Waiting Tasks Queue
 * 4. View Processed Tasks List
 * 5. Exit
 * Enter your choice: 5
 * Exiting server processor.
 * ```
 * 
 * **Submission:** Provide the complete Java code for the simulation.
 *
 * EXPLANATION:
 * The provided solution implements the Server Task Processor Simulation as requested, demonstrating the required Java concepts and best practices.
 * 
 * 1.  **Task Class:**
 *     *   Represents a single task with `id`, `description`, and `priority`.
 *     *   Uses `private` fields for encapsulation.
 *     *   Provides public getter methods to access the task's properties.
 *     *   Includes a `toString()` method for easy printing of task details.
 * 
 * 2.  **ServerProcessor Class:**
 *     *   This class manages the core logic of the simulation.
 *     *   It holds two key data structures:
 *         *   `taskQueue`: Declared as `Queue<Task>` and implemented using `LinkedList`. This adheres to the requirement of using `Queue` and demonstrates using an implementation class (`LinkedList`) via the interface. `Queue` methods like `offer()` (to add) and `poll()` (to retrieve and remove) are used, providing FIFO behavior.
 *         *   `processedTasks`: Declared as `List<Task>` and implemented using `ArrayList`. This meets the requirement of using both `ArrayList` and declaring it using the `List` interface, showcasing polymorphism.
 *     *   `nextTaskId`: A private integer keeps track of the next ID to assign, ensuring unique, sequential IDs.
 *     *   `addTask()`: Creates a new `Task` object, validates the priority input (case-insensitive check), and adds it to the `taskQueue` using `offer()`. Returns boolean indicating success/failure based on validation. Uses `System.err` for invalid priority.
 *     *   `processNextTask()`: Uses `taskQueue.poll()` to get the next task. If `poll()` returns `null` (meaning the queue is empty), it prints an error using `System.err`. Otherwise, it removes the task from the queue and adds it to the `processedTasks` list.
 *     *   `viewTaskQueue()` and `viewProcessedTasks()`: Iterate through the respective collections (`taskQueue` and `processedTasks`) and print the details of each task using their `toString()` method. Checks if the collections are empty before iterating.
 * 
 * 3.  **ServerSimulation Class (Main Class):**
 *     *   Contains the `main` method where the program execution begins.
 *     *   **Scanner:** A `Scanner` object is created to read input from `System.in`. A `try-with-resources` block is used to ensure the `Scanner` is automatically closed, which is a best practice.
 *     *   **ServerProcessor Instance:** An instance of `ServerProcessor` is created to manage the tasks.
 *     *   **Main Loop:** A `while(running)` loop keeps the program active until the user chooses to exit.
 *     *   **Menu and Switch:** Inside the loop, `printMenu()` displays options. The program reads the user's integer choice using `scanner.nextInt()`. A `switch` statement is used to direct the program flow based on the user's input, calling the appropriate methods of the `ServerProcessor`.
 *     *   **Input Consumption:** `scanner.nextLine()` is called after `scanner.nextInt()` to consume the leftover newline character, preventing issues with subsequent `nextLine()` calls.
 *     *   **Error Handling (`try-catch`):**
 *         *   An outer `try-catch` around the `Scanner` initialization handles potential issues there (though less common for `System.in`).
 *         *   An inner `try-catch` block wraps the user interaction logic within the main `while` loop. This demonstrates handling exceptions that occur during the main operation cycle.
 *         *   `catch (InputMismatchException e)` specifically handles cases where the user enters non-integer input when an integer (the menu choice) is expected. It prints an error using `System.err` and consumes the invalid input using `scanner.nextLine()` to prevent an infinite loop.
 *         *   `catch (Exception e)` acts as a general catch-all for any other unexpected runtime exceptions that might occur within the loop, printing a generic error message using `System.err`. This fulfills the requirement for broader exception handling.
 *     *   **System.out and System.err:** `System.out.println` is used for displaying the menu, task details, confirmations, and list/queue contents. `System.err.println` is used exclusively for error messages as required.
 * 
 * This solution effectively integrates the required Java components within a practical simulation, demonstrates core OOP principles like encapsulation, uses appropriate data structures for the task (Queue for waiting, List for processed), implements user interaction via `Scanner` and `switch`, and includes essential error handling using `try-catch` and distinct output streams.
 */

import java.util.Queue;
import java.util.LinkedList;
import java.util.List;
import java.util.ArrayList;
import java.util.Scanner;
import java.util.InputMismatchException;

// Represents a single task in the system
class Task {
    private int id;
    private String description;
    private String priority; // Storing as String as per requirement, could use Enum

    public Task(int id, String description, String priority) {
        this.id = id;
        this.description = description;
        this.priority = priority;
    }

    // Getters
    public int getId() {
        return id;
    }

    public String getDescription() {
        return description;
    }

    public String getPriority() {
        return priority;
    }

    @Override
    public String toString() {
        return "Task ID: " + id + ", Description: " + description + ", Priority: " + priority;
    }
}

// Manages the task queue and processed tasks list
class ServerProcessor {
    // Queue to hold tasks waiting to be processed (FIFO)
    private Queue<Task> taskQueue;
    // List to hold tasks that have been processed
    private List<Task> processedTasks;
    // Counter for generating unique task IDs
    private int nextTaskId;

    public ServerProcessor() {
        // Use LinkedList as a Queue implementation
        this.taskQueue = new LinkedList<>();
        // Use ArrayList as a List implementation
        this.processedTasks = new ArrayList<>();
        this.nextTaskId = 1; // Start task IDs from 1
    }

    /**
     * Adds a new task to the waiting queue after validation.
     * @param description The description of the task.
     * @param priority The priority of the task (LOW, MEDIUM, HIGH).
     * @return true if the task was added successfully, false otherwise.
     */
    public boolean addTask(String description, String priority) {
        // Validate priority input
        String upperPriority = priority.toUpperCase();
        if (!upperPriority.equals("LOW") && !upperPriority.equals("MEDIUM") && !upperPriority.equals("HIGH")) {
            System.err.println("Error: Invalid priority. Please use LOW, MEDIUM, or HIGH.");
            return false;
        }

        // Create a new task with the next available ID
        Task newTask = new Task(nextTaskId, description, upperPriority);
        taskQueue.offer(newTask); // offer() is preferred over add() for capacity-constrained queues, but works here too
        System.out.println("Task ID " + nextTaskId + " added to the queue.");
        nextTaskId++; // Increment the ID counter for the next task
        return true;
    }

    /**
     * Processes the next task from the queue.
     * Removes the task from the queue and adds it to the processed list.
     */
    public void processNextTask() {
        // Use poll() to retrieve and remove the head of the queue, returns null if queue is empty
        Task taskToProcess = taskQueue.poll();

        if (taskToProcess != null) {
            System.out.println("Processing task: " + taskToProcess);
            processedTasks.add(taskToProcess); // Add the processed task to the list
            System.out.println("Task ID " + taskToProcess.getId() + " processed.");
        } else {
            System.err.println("Error: Task queue is empty. Nothing to process.");
        }
    }

    /**
     * Displays all tasks currently in the waiting queue.
     */
    public void viewTaskQueue() {
        System.out.println("\nWaiting Tasks Queue:");
        if (taskQueue.isEmpty()) {
            System.out.println("The queue is empty.");
        } else {
            // Iterate through the queue without removing elements
            for (Task task : taskQueue) {
                System.out.println(task);
            }
        }
    }

    /**
     * Displays all tasks that have been processed.
     */
    public void viewProcessedTasks() {
        System.out.println("\nProcessed Tasks List:");
        if (processedTasks.isEmpty()) {
            System.out.println("No tasks have been processed yet.");
        } else {
            // Iterate through the list
            for (Task task : processedTasks) {
                System.out.println(task);
            }
        }
    }
}

// Main class to run the simulation
public class ServerSimulation {

    public static void main(String[] args) {
        // Use try-with-resources for Scanner to ensure it's closed
        try (Scanner scanner = new Scanner(System.in)) {
            ServerProcessor processor = new ServerProcessor();
            boolean running = true;

            // Main application loop
            while (running) {
                printMenu(); // Display the menu

                try {
                    // Read user choice
                    System.out.print("Enter your choice: ");
                    int choice = scanner.nextInt();
                    // Consume the newline character left by nextInt()
                    scanner.nextLine();

                    // Use switch statement to handle user commands
                    switch (choice) {
                        case 1: // Add New Task
                            System.out.print("Enter task description: ");
                            String description = scanner.nextLine();
                            System.out.print("Enter task priority (LOW, MEDIUM, HIGH): ");
                            String priority = scanner.nextLine();
                            processor.addTask(description, priority);
                            break;

                        case 2: // Process Next Task
                            processor.processNextTask();
                            break;

                        case 3: // View Waiting Tasks Queue
                            processor.viewTaskQueue();
                            break;

                        case 4: // View Processed Tasks List
                            processor.viewProcessedTasks();
                            break;

                        case 5: // Exit
                            System.out.println("Exiting server processor.");
                            running = false;
                            break;

                        default: // Invalid choice
                            System.err.println("Error: Invalid choice. Please enter a number between 1 and 5.");
                            break;
                    }
                } catch (InputMismatchException e) {
                    // Handle non-integer input for menu choice
                    System.err.println("Error: Invalid input. Please enter a number.");
                    scanner.nextLine(); // Consume the invalid input to prevent infinite loop
                } catch (Exception e) {
                    // Catch any other unexpected exceptions during the loop iteration
                    System.err.println("An unexpected error occurred: " + e.getMessage());
                    // e.printStackTrace(); // Uncomment for debugging details
                }
                System.out.println(); // Add a newline for better readability between operations
            }

        } catch (Exception e) {
            // Catch any exceptions during Scanner setup or initialisation
            System.err.println("A critical error occurred during setup: " + e.getMessage());
            // e.printStackTrace(); // Uncomment for debugging details
        }
    }

    /**
     * Helper method to print the main menu options.
     */
    private static void printMenu() {
        System.out.println("--- Server Task Processor ---");
        System.out.println("1. Add New Task");
        System.out.println("2. Process Next Task");
        System.out.println("3. View Waiting Tasks Queue");
        System.out.println("4. View Processed Tasks List");
        System.out.println("5. Exit");
    }
}
