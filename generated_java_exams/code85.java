/*
 * Exam Question #85
 * Generated on: 2025-05-11 22:11:15
 * Generated by: Account 5
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Advanced Task Management System
 * 
 * **Scenario:**
 * 
 * You are tasked with developing a simplified Task Management System for a small team. The system should allow users to add new tasks, manage the workflow of tasks through different states (Pending, In Progress, Completed), and view the tasks in each state.
 * 
 * **Requirements:**
 * 
 * Implement a Java application that fulfills the following criteria:
 * 
 * 1.  **Task Representation:** Create a class (e.g., `Task`) to represent a task. Each task should have:
 *     *   A unique integer ID.
 *     *   A String description.
 *     *   A status indicating its current state (Pending, In Progress, or Completed). Use an `enum` for the status.
 *     *   Implement appropriate encapsulation (private fields, public getters, a controlled method to update status).
 *     *   Override the `toString()` method for easy printing of task details.
 * 
 * 2.  **Task Management Logic:** Create a class (e.g., `TaskManager`) that manages the tasks using the following data structures:
 *     *   A `Queue<Task>` to store tasks that are waiting to be started (Pending state).
 *     *   A `List<Task>` (specifically, an `ArrayList<Task>`) to store tasks that have been completed.
 *     *   A single variable (e.g., `private Task currentTask;`) to hold the task that is currently being worked on (In Progress state). Only one task can be in the "In Progress" state at any given time.
 * 
 * 3.  **Core Functionality:** Implement the following operations within the `TaskManager` class:
 *     *   `addTask(String description)`: Creates a new `Task` with a unique ID and `PENDING` status, adding it to the pending queue.
 *     *   `startNextTask()`: Removes the next task from the pending queue and sets it as the `currentTask`, changing its status to `IN_PROGRESS`. This operation should only be possible if there are pending tasks AND no task is currently in progress.
 *     *   `completeCurrentTask()`: Changes the status of the `currentTask` to `COMPLETED` and moves it from the `currentTask` variable to the completed tasks list. This operation should only be possible if a task is currently in progress.
 *     *   `viewPendingTasks()`: Displays all tasks currently in the pending queue without removing them.
 *     *   `viewCurrentTask()`: Displays the task currently in progress, if any.
 *     *   `viewCompletedTasks()`: Displays all tasks in the completed list.
 * 
 * 4.  **User Interface:** Implement a main application loop (e.g., in a `main` method or a `run` method called from `main`) that:
 *     *   Uses `Scanner` to read user input from the console.
 *     *   Presents a menu of options to the user (Add Task, Start Next Task, Complete Current Task, View Pending, View Current, View Completed, Exit).
 *     *   Uses a `switch` statement to process the user's menu choice.
 * 
 * 5.  **Error Handling:** Implement robust error handling:
 *     *   Use `System.err` to print error messages (e.g., for invalid menu choices, attempting to start a task when none is pending, attempting to start a task when one is already in progress, attempting to complete a task when none is in progress, invalid input format).
 *     *   Use `System.out` for all normal output (menu, prompts, success messages, task listings).
 *     *   Implement class-wide exception handling using `try-catch` blocks in the main application loop to handle potential runtime errors (e.g., `InputMismatchException` for invalid input) and exceptions thrown by your `TaskManager` methods (e.g., use `IllegalStateException` or custom exceptions for invalid operation attempts like starting a task when one is running).
 *     *   Validate input where appropriate (e.g., ensure task description is not empty).
 * 
 * 6.  **Best Practices:** Adhere to Java best practices:
 *     *   Meaningful variable and method names.
 *     *   Appropriate comments and documentation (e.g., Javadoc).
 *     *   Clean code structure.
 * 
 * **Expected Output:**
 * 
 * The application should run interactively, presenting a menu, accepting user input, performing the requested operations, and displaying results or errors clearly on the console using `System.out` for normal output and `System.err` for error messages. Error conditions should prevent the invalid operation and inform the user.
 * 
 * **Example Interaction Flow (Partial):**
 * 
 * ```
 * --- Task Management System ---
 * 
 * --- Menu ---
 * 1. Add New Task
 * 2. Start Next Pending Task
 * 3. Complete Current Task
 * 4. View Pending Tasks
 * 5. View Current Task
 * 6. View Completed Tasks
 * 0. Exit
 * ------------
 * Enter your choice: 1
 * Enter task description: Implement login feature
 * Added task: Implement login feature (ID: 1)
 * 
 * --- Menu ---
 * ...
 * Enter your choice: 1
 * Enter task description: Design database schema
 * Added task: Design database schema (ID: 2)
 * 
 * --- Menu ---
 * ...
 * Enter your choice: 4
 * 
 * --- Pending Tasks ---
 * Task [ID=1, Desc='Implement login feature', Status=PENDING]
 * Task [ID=2, Desc='Design database schema', Status=PENDING]
 * Total pending: 2
 * ---------------------
 * 
 * --- Menu ---
 * ...
 * Enter your choice: 2
 * Started task: Implement login feature (ID: 1)
 * 
 * --- Menu ---
 * ...
 * Enter your choice: 2
 * Operation failed: A task (ID: 1) is already in progress.
 * 
 * --- Menu ---
 * ...
 * Enter your choice: 5
 * 
 * --- Current Task ---
 * Task [ID=1, Desc='Implement login feature', Status=IN_PROGRESS]
 * --------------------
 * 
 * --- Menu ---
 * ...
 * Enter your choice: 3
 * Completed task: Implement login feature (ID: 1)
 * 
 * --- Menu ---
 * ...
 * Enter your choice: 6
 * 
 * --- Completed Tasks ---
 * Task [ID=1, Desc='Implement login feature', Status=COMPLETED]
 * Total completed: 1
 * -----------------------
 * 
 * --- Menu ---
 * ...
 * Enter your choice: 0
 * Exiting Task Management System. Goodbye!
 * ```
 *
 * EXPLANATION:
 * This solution implements a simple Task Management System demonstrating the required Java concepts and best practices.
 * 
 * 1.  **`Task` Class:**
 *     *   Defines the structure of a task with `id`, `description`, and `status`.
 *     *   Uses an `enum` (`Task.Status`) for task states, providing type safety and readability.
 *     *   Employs encapsulation with private fields and public getters. The `setStatus` method provides a controlled way to change the state.
 *     *   The `toString()` method allows for easy printing of task details.
 * 
 * 2.  **`TaskManager` Class:**
 *     *   Manages the collections of tasks.
 *     *   `pendingTasks`: A `Queue<Task>` (implemented using `LinkedList`) stores tasks waiting to be processed. The Queue's FIFO nature is suitable here for a basic "next task" logic.
 *     *   `completedTasks`: A `List<Task>` (implemented using `ArrayList`) stores tasks that have finished. A List is appropriate as completed tasks are typically viewed or archived, and order/access by index might be useful in a more advanced system.
 *     *   `currentTask`: A single `Task` variable represents the task actively being worked on. This enforces the requirement that only one task is "In Progress" at a time.
 *     *   `nextTaskId`: An integer counter ensures each task gets a unique ID.
 * 
 * 3.  **Core Functionality Methods (`addTask`, `startNextTask`, `completeCurrentTask`, `view...Tasks`):**
 *     *   Each method performs a specific operation related to task lifecycle or viewing.
 *     *   `addTask` uses `pendingTasks.offer()` to add to the queue.
 *     *   `startNextTask` uses `pendingTasks.poll()` to remove the head of the queue and sets it as `currentTask`. It includes checks using `IllegalStateException` to ensure an operation is only attempted when the system is in a valid state (no task currently running, and pending tasks exist).
 *     *   `completeCurrentTask` moves the `currentTask` to the `completedTasks` list and resets `currentTask` to `null`. It also uses `IllegalStateException` to ensure a task is actually in progress before attempting to complete it.
 *     *   The `view` methods iterate through the respective collections (`pendingTasks` using a for-each loop which doesn't remove elements, `completedTasks` using a standard for-each loop) and print task details.
 * 
 * 4.  **User Interface and Control Flow (`run`, `printMenu`):**
 *     *   The `run()` method contains the main application loop.
 *     *   `Scanner` is used to get input from `System.in`.
 *     *   A `while` loop keeps the application running until the user chooses to exit.
 *     *   A `switch` statement handles the menu options, directing control to the appropriate `TaskManager` method.
 * 
 * 5.  **Error Handling (`try-catch`, `System.err`):**
 *     *   A large `try-catch` block wraps the core logic inside the `while` loop. This provides a central place to catch exceptions occurring during user input processing or method calls.
 *     *   `InputMismatchException` is specifically caught when the user enters non-integer input for the menu choice, preventing the program from crashing and informing the user via `System.err`. `scanner.nextLine()` is called within the catch block to clear the invalid input from the scanner buffer, preventing an infinite loop.
 *     *   `IllegalArgumentException` (used in `addTask` for empty description) and `IllegalStateException` (used in `startNextTask` and `completeCurrentTask` for invalid state transitions) are caught specifically, printing informative messages to `System.err`.
 *     *   A general `catch (Exception e)` is included as a fallback for any other unexpected runtime errors, printing the error message to `System.err` and the stack trace for debugging.
 *     *   `System.out` is used for all normal output like the menu, prompts, and successful operation messages. `System.err` is strictly used for error reporting.
 *     *   Input validation for the task description (checking for empty string) is done in `addTask`.
 * 
 * 6.  **Best Practices:**
 *     *   Private fields and public methods ensure encapsulation.
 *     *   Method and variable names are descriptive (e.g., `pendingTasks`, `startNextTask`).
 *     *   Basic comments and Javadoc-style comments explain the purpose of classes and methods.
 *     *   The code is structured into logical units (`Task` class, `TaskManager` class with distinct methods).
 * 
 * This solution effectively integrates the required Java components to build a functional, albeit simple, task management system with proper structure, error handling, and adherence to best practices, making it a suitable challenging exam task.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.InputMismatchException;

/**
 * Represents a single task with an ID, description, and status.
 */
class Task {
    /**
     * Enumeration for the different states a task can be in.
     */
    public enum Status {
        PENDING, IN_PROGRESS, COMPLETED
    }

    private int id;
    private String description;
    private Status status;

    /**
     * Constructs a new Task.
     *
     * @param id The unique identifier for the task.
     * @param description The description of the task.
     */
    public Task(int id, String description) {
        this.id = id;
        this.description = description;
        this.status = Status.PENDING; // New tasks start as PENDING
    }

    // --- Getters ---
    public int getId() {
        return id;
    }

    public String getDescription() {
        return description;
    }

    public Status getStatus() {
        return status;
    }

    /**
     * Sets the status of the task.
     * Note: In a more complex system, this might have state transition checks.
     *
     * @param status The new status for the task.
     */
    public void setStatus(Status status) {
        this.status = status;
    }

    /**
     * Provides a string representation of the task.
     *
     * @return A formatted string describing the task.
     */
    @Override
    public String toString() {
        return "Task [ID=" + id + ", Desc='" + description + "', Status=" + status + "]";
    }
}

/**
 * Manages a collection of tasks, handling their lifecycle through different states.
 */
public class TaskManager {
    // Queue for tasks waiting to be started
    private Queue<Task> pendingTasks;
    // List for tasks that have been completed
    private List<Task> completedTasks;
    // Variable for the single task currently in progress
    private Task currentTask;
    // Counter for generating unique task IDs
    private int nextTaskId;

    /**
     * Constructs a new TaskManager, initializing task collections and ID counter.
     */
    public TaskManager() {
        // LinkedList is a common implementation of Queue
        pendingTasks = new LinkedList<>();
        // ArrayList is a common implementation of List
        completedTasks = new ArrayList<>();
        currentTask = null; // Initially no task is in progress
        nextTaskId = 1; // Start task IDs from 1
    }

    /**
     * Adds a new task to the pending queue with PENDING status.
     *
     * @param description The description of the task.
     * @throws IllegalArgumentException if the description is null or empty.
     */
    public void addTask(String description) {
        if (description == null || description.trim().isEmpty()) {
            // Use IllegalArgumentException for invalid method arguments
            throw new IllegalArgumentException("Task description cannot be empty.");
        }
        Task newTask = new Task(nextTaskId++, description.trim());
        // offer() is preferred over add() in queues as it handles capacity restrictions gracefully (though LinkedList is unbounded)
        pendingTasks.offer(newTask);
        System.out.println("Added task: " + newTask.getDescription() + " (ID: " + newTask.getId() + ")");
    }

    /**
     * Starts the next available task from the pending queue.
     * Moves the task to the 'current' task slot and updates its status.
     *
     * @throws IllegalStateException if a task is already in progress or no tasks are pending.
     */
    public void startNextTask() {
        if (currentTask != null) {
            // Use IllegalStateException for operations attempted when the object is not in an appropriate state
            throw new IllegalStateException("A task (ID: " + currentTask.getId() + ") is already in progress.");
        }

        // poll() retrieves and removes the head of the queue, or returns null if the queue is empty
        Task taskToStart = pendingTasks.poll();
        if (taskToStart == null) {
            throw new IllegalStateException("No tasks are pending to start.");
        }

        currentTask = taskToStart;
        currentTask.setStatus(Task.Status.IN_PROGRESS);
        System.out.println("Started task: " + currentTask.getDescription() + " (ID: " + currentTask.getId() + ")");
    }

    /**
     * Completes the task currently in progress.
     * Moves the task to the completed list and clears the 'current' task slot.
     *
     * @throws IllegalStateException if no task is currently in progress.
     */
    public void completeCurrentTask() {
        if (currentTask == null) {
            throw new IllegalStateException("No task is currently in progress to complete.");
        }

        currentTask.setStatus(Task.Status.COMPLETED);
        completedTasks.add(currentTask);
        System.out.println("Completed task: " + currentTask.getDescription() + " (ID: " + currentTask.getId() + ")");
        currentTask = null; // Clear the current task slot
    }

    /**
     * Displays all tasks currently residing in the pending queue.
     */
    public void viewPendingTasks() {
        System.out.println("\n--- Pending Tasks ---");
        if (pendingTasks.isEmpty()) {
            System.out.println("No tasks pending.");
        } else {
            // Iterate over the queue using a for-each loop (does not remove elements)
            int count = 0;
            for (Task task : pendingTasks) {
                System.out.println(task);
                count++;
            }
            System.out.println("Total pending: " + count);
        }
        System.out.println("---------------------\n");
    }

    /**
     * Displays the task that is currently in progress.
     */
    public void viewCurrentTask() {
        System.out.println("\n--- Current Task ---");
        if (currentTask == null) {
            System.out.println("No task currently in progress.");
        } else {
            System.out.println(currentTask);
        }
        System.out.println("--------------------\n");
    }

    /**
     * Displays all tasks that have been moved to the completed list.
     */
    public void viewCompletedTasks() {
        System.out.println("\n--- Completed Tasks ---");
        if (completedTasks.isEmpty()) {
            System.out.println("No tasks completed yet.");
        } else {
            // Iterate over the List
            for (Task task : completedTasks) {
                System.out.println(task);
            }
            System.out.println("Total completed: " + completedTasks.size());
        }
        System.out.println("-----------------------\n");
    }

    /**
     * Prints the main menu options to the console.
     */
    private void printMenu() {
        System.out.println("\n--- Menu ---");
        System.out.println("1. Add New Task");
        System.out.println("2. Start Next Pending Task");
        System.out.println("3. Complete Current Task");
        System.out.println("4. View Pending Tasks");
        System.out.println("5. View Current Task");
        System.out.println("6. View Completed Tasks");
        System.out.println("0. Exit");
        System.out.println("------------");
    }

    /**
     * Runs the main application loop, handling user interaction and task management.
     */
    public void run() {
        Scanner scanner = new Scanner(System.in);
        int choice = -1; // Initialize choice to a non-exit value

        System.out.println("--- Task Management System ---");

        // Main loop continues until the user chooses to exit (choice 0)
        while (choice != 0) {
            printMenu();
            System.out.print("Enter your choice: ");

            // Class-wide exception handling using try-catch block around the core logic
            try {
                // Read the integer choice
                choice = scanner.nextInt();
                // Consume the newline character left by nextInt()
                scanner.nextLine();

                // Use switch statement for menu-driven control flow
                switch (choice) {
                    case 1: // Add Task
                        System.out.print("Enter task description: ");
                        String description = scanner.nextLine();
                        addTask(description); // Call method, potential IllegalArgumentException
                        break;
                    case 2: // Start Next Task
                        startNextTask(); // Call method, potential IllegalStateException
                        break;
                    case 3: // Complete Current Task
                        completeCurrentTask(); // Call method, potential IllegalStateException
                        break;
                    case 4: // View Pending Tasks
                        viewPendingTasks();
                        break;
                    case 5: // View Current Task
                         viewCurrentTask();
                         break;
                    case 6: // View Completed Tasks
                        viewCompletedTasks();
                        break;
                    case 0: // Exit
                        System.out.println("Exiting Task Management System. Goodbye!");
                        break;
                    default:
                        // Handle invalid integer choices
                        System.err.println("Invalid choice. Please enter a number between 0 and 6.");
                }
            } catch (InputMismatchException e) {
                // Catch exception if user enters non-integer input for menu choice
                System.err.println("Invalid input. Please enter a number.");
                // Consume the invalid input to prevent an infinite loop
                scanner.nextLine();
                choice = -1; // Reset choice to ensure the loop continues
            } catch (IllegalArgumentException | IllegalStateException e) {
                // Catch specific exceptions thrown by our TaskManager methods
                System.err.println("Operation failed: " + e.getMessage());
            } catch (Exception e) {
                // Catch any other unexpected exceptions that might occur
                System.err.println("An unexpected error occurred: " + e.getMessage());
                e.printStackTrace(); // Print stack trace for debugging unexpected issues
            }
            System.out.println(); // Add a blank line for readability between interactions
        }

        // Close the scanner when the application exits
        scanner.close();
    }

    /**
     * The main method to start the Task Management System application.
     *
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        TaskManager manager = new TaskManager();
        manager.run(); // Start the main application loop
    }
}
