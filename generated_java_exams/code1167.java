/*
 * Exam Question #1167
 * Generated on: 2025-05-12 17:34:08
 * Generated by: Account 2
 * 
 * QUESTION:
 * **Advanced Java Programming Exam: Task Processing System Simulation**
 * 
 * **Problem Description:**
 * 
 * You are tasked with building a simple simulation of a system that processes tasks. Tasks are submitted and placed in a queue. A "processor" can pick the next task from the queue and mark it as completed, moving it to a list of finished tasks. Users interact with the system via a command-line interface to add tasks, process tasks, view pending tasks, and view completed tasks.
 * 
 * Your solution must demonstrate a strong understanding of core Java collections, control flow, input/output, and exception handling.
 * 
 * **Requirements:**
 * 
 * 1.  **Task Representation:** Create a `Task` class with private fields for a unique task ID (integer), a description (String), and a status (e.g., PENDING, COMPLETED - use an enum or simple String, but an enum is preferred for robustness). Include a constructor, getters, and a meaningful `toString()` method.
 * 2.  **Task Management:** Create a `TaskProcessor` class that manages the task lifecycle.
 *     *   It must internally use a `java.util.Queue` to hold tasks awaiting processing.
 *     *   It must internally use a `java.util.ArrayList` declared using the `java.util.List` interface (`List<Task> completedTasks = new ArrayList<>();`) to hold completed tasks.
 *     *   It must have public methods:
 *         *   `addTask(String description)`: Creates a new `Task` with status PENDING and adds it to the queue. Assign a unique ID (start from 1 and increment).
 *         *   `processNextTask()`: Removes the next task from the queue, updates its status to COMPLETED, and adds it to the completed list. If the queue is empty, it should handle this gracefully (e.g., throw a specific exception or return a status indicating failure).
 *         *   `getPendingTasks()`: Returns the queue of pending tasks (consider returning a copy or unmodifiable view if you want to prevent external modification, but for this exam, returning the collection directly is acceptable).
 *         *   `getCompletedTasks()`: Returns the list of completed tasks.
 * 3.  **User Interface:** Implement a command-line interface in a main application class (`TaskSystemApp`).
 *     *   Use `java.util.Scanner` to read user input.
 *     *   Present a menu of options:
 *         *   `a`: Add new task
 *         *   `p`: Process next task
 *         *   `v`: View pending tasks
 *         *   `c`: View completed tasks
 *         *   `x`: Exit
 *     *   Use a `switch` statement to handle the different command inputs.
 *     *   Prompt the user for necessary input (e.g., task description).
 * 4.  **Error Handling:**
 *     *   Use `System.err` to print error messages (e.g., "Invalid command", "Queue is empty, no task to process").
 *     *   Use `System.out` for all other output (menu, prompts, success messages, task listings).
 *     *   Implement class-wide exception handling using `try-catch` blocks in the main application loop to catch potential issues (e.g., exceptions thrown by `processNextTask`, unexpected input issues).
 *     *   Validate user input where appropriate (e.g., task description should not be empty).
 * 5.  **Best Practices:**
 *     *   Apply proper encapsulation (private fields, public methods).
 *     *   Use meaningful variable and method names.
 *     *   Include appropriate comments and documentation (basic Javadoc is a plus).
 *     *   Ensure clean code structure.
 * 
 * **Expected Output:**
 * 
 * The program should run in a loop, presenting the menu, accepting commands, and performing actions. Example interaction:
 * 
 * ```
 * Task Processing System Menu:
 * a: Add new task
 * p: Process next task
 * v: View pending tasks
 * c: View completed tasks
 * x: Exit
 * Enter command: a
 * Enter task description: Write report
 * Task added: Task #1 (PENDING) - Write report
 * Enter command: a
 * Enter task description: Review code
 * Task added: Task #2 (PENDING) - Review code
 * Enter command: v
 * Pending Tasks:
 * Task #1 (PENDING) - Write report
 * Task #2 (PENDING) - Review code
 * Enter command: p
 * Processed task: Task #1 (COMPLETED) - Write report
 * Enter command: v
 * Pending Tasks:
 * Task #2 (PENDING) - Review code
 * Enter command: c
 * Completed Tasks:
 * Task #1 (COMPLETED) - Write report
 * Enter command: p
 * Processed task: Task #2 (COMPLETED) - Review code
 * Enter command: v
 * Pending Tasks:
 * (Queue is empty)
 * Enter command: c
 * Completed Tasks:
 * Task #1 (COMPLETED) - Write report
 * Task #2 (COMPLETED) - Review code
 * Enter command: p
 * Error: Queue is empty, no task to process.
 * Enter command: invalid
 * Error: Invalid command.
 * Enter command: x
 * Exiting Task Processing System.
 * ```
 * 
 * **Submission:**
 * 
 * Provide the complete Java code for all necessary classes (`Task`, `TaskProcessor`, `TaskSystemApp`).
 *
 * EXPLANATION:
 * This solution simulates a simple task processing system using several core Java concepts and collections.
 * 
 * 1.  **`Task` Class:**
 *     *   Represents the data structure for a single task, encapsulating its `id`, `description`, and `status`.
 *     *   Uses an `enum` (`TaskStatus`) for the status, providing type safety and readability compared to simple strings.
 *     *   Private fields and public getters/setters demonstrate encapsulation.
 *     *   The `toString()` method provides a convenient way to display task information.
 * 
 * 2.  **`TaskProcessor` Class:**
 *     *   Acts as the central manager for tasks.
 *     *   It holds the two primary collections:
 *         *   `pendingTasks`: A `Queue<Task>` (specifically implemented using `LinkedList`) to maintain the order of tasks waiting to be processed (FIFO - First-In, First-Out).
 *         *   `completedTasks`: A `List<Task>` (specifically implemented using `ArrayList`) to store tasks that have finished processing. Note the use of the `List` interface type for the variable, demonstrating polymorphism.
 *     *   `addTask()`: Creates a new `Task` with a unique ID (managed by `nextTaskId`) and adds it to the `pendingTasks` queue using `offer()`. Includes input validation for the description.
 *     *   `processNextTask()`: Removes the head of the queue using `poll()`. If `poll()` returns `null` (meaning the queue was empty), it throws a custom `EmptyQueueException`. Otherwise, it updates the task's status and adds it to the `completedTasks` list.
 *     *   `getPendingTasks()` and `getCompletedTasks()`: Provide access to the internal collections.
 * 
 * 3.  **`EmptyQueueException` Class:**
 *     *   A simple custom exception class extending `Exception`. This allows `TaskProcessor` to signal a specific error condition (trying to process from an empty queue) which the calling code (`TaskSystemApp`) can catch and handle appropriately.
 * 
 * 4.  **`TaskSystemApp` Class:**
 *     *   Contains the `main` method, serving as the application entry point.
 *     *   Uses `java.util.Scanner` to read user input from the console.
 *     *   Implements the main application loop (`while(running)`).
 *     *   **Class-wide Exception Handling:** The core logic within the `while` loop is wrapped in a `try-catch` block. This catches `IllegalArgumentException` (thrown by `addTask` for invalid input), the custom `EmptyQueueException` (thrown by `processNextTask`), and a general `Exception` for any other unexpected runtime errors. This provides robustness, preventing the application from crashing on common errors.
 *     *   **`switch` Statement:** Used effectively to direct execution based on the user's single-character command ('a', 'p', 'v', 'c', 'x'). The `default` case handles invalid commands.
 *     *   **`System.out` vs. `System.err`:**
 *         *   `System.out.println()` is used for normal output like the menu, prompts, task details, and success messages.
 *         *   `System.err.println()` is used specifically for printing error messages (invalid command, empty queue, input errors, unexpected exceptions). This is a best practice for separating standard output from error streams.
 *     *   **Input Validation:** The `addTask` method explicitly checks if the description is empty or null, throwing an `IllegalArgumentException`. This is caught in the main loop.
 *     *   **Collection Usage:** Demonstrates iterating through both the `Queue` (for pending tasks) and the `List` (for completed tasks) to display their contents.
 * 
 * This solution effectively integrates the required Java components (`Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.err`, `System.out`, `try-catch`) into a practical, albeit simple, task management simulation, adhering to best practices like encapsulation, meaningful names, and error handling.
 */

import java.util.ArrayList;
import java.util.LinkedList; // LinkedList implements Queue
import java.util.List;
import java.util.Queue;
import java.util.Scanner;

// Enum for Task Status
enum TaskStatus {
    PENDING,
    COMPLETED
}

// Represents a single task
class Task {
    private int id;
    private String description;
    private TaskStatus status;

    /**
     * Constructs a new Task.
     * @param id The unique ID of the task.
     * @param description The description of the task.
     */
    public Task(int id, String description) {
        this.id = id;
        this.description = description;
        this.status = TaskStatus.PENDING; // New tasks are always pending
    }

    // Getters
    public int getId() {
        return id;
    }

    public String getDescription() {
        return description;
    }

    public TaskStatus getStatus() {
        return status;
    }

    // Setter for status (used by processor)
    public void setStatus(TaskStatus status) {
        this.status = status;
    }

    /**
     * Provides a string representation of the Task.
     * @return String representation.
     */
    @Override
    public String toString() {
        return "Task #" + id + " (" + status + ") - " + description;
    }
}

// Manages the queue of pending tasks and list of completed tasks
class TaskProcessor {
    private Queue<Task> pendingTasks;
    private List<Task> completedTasks;
    private int nextTaskId; // Counter for unique task IDs

    /**
     * Constructs a new TaskProcessor.
     */
    public TaskProcessor() {
        this.pendingTasks = new LinkedList<>(); // LinkedList is a common Queue implementation
        this.completedTasks = new ArrayList<>(); // ArrayList implements List
        this.nextTaskId = 1; // Start task IDs from 1
    }

    /**
     * Adds a new task to the pending queue.
     * @param description The description of the task.
     * @throws IllegalArgumentException if description is null or empty.
     */
    public void addTask(String description) {
        if (description == null || description.trim().isEmpty()) {
            throw new IllegalArgumentException("Task description cannot be empty.");
        }
        Task newTask = new Task(nextTaskId++, description.trim());
        pendingTasks.offer(newTask); // offer is preferred for queues, returns false if failed (rare for LinkedList)
        System.out.println("Task added: " + newTask);
    }

    /**
     * Processes the next task in the queue.
     * @return The task that was just processed.
     * @throws EmptyQueueException if the pending task queue is empty.
     */
    public Task processNextTask() throws EmptyQueueException {
        Task taskToProcess = pendingTasks.poll(); // poll removes and returns the head, or null if empty

        if (taskToProcess == null) {
            throw new EmptyQueueException("Queue is empty, no task to process.");
        }

        taskToProcess.setStatus(TaskStatus.COMPLETED);
        completedTasks.add(taskToProcess);
        return taskToProcess;
    }

    /**
     * Gets the queue of pending tasks.
     * @return The queue of pending tasks.
     */
    public Queue<Task> getPendingTasks() {
        return pendingTasks;
    }

    /**
     * Gets the list of completed tasks.
     * @return The list of completed tasks.
     */
    public List<Task> getCompletedTasks() {
        return completedTasks;
    }
}

// Custom exception for an empty queue scenario
class EmptyQueueException extends Exception {
    /**
     * Constructs an EmptyQueueException with the specified detail message.
     * @param message The detail message.
     */
    public EmptyQueueException(String message) {
        super(message);
    }
}

// Main application class
public class TaskSystemApp {

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        TaskProcessor processor = new TaskProcessor();
        boolean running = true;

        System.out.println("--- Task Processing System ---");

        // Main application loop with class-wide exception handling
        while (running) {
            printMenu();
            System.out.print("Enter command: ");
            String input = scanner.nextLine().trim().toLowerCase();

            // Use try-catch for potential exceptions during command processing
            try {
                // Use switch statement for command handling
                switch (input) {
                    case "a": // Add task
                        System.out.print("Enter task description: ");
                        String description = scanner.nextLine();
                        processor.addTask(description);
                        break;

                    case "p": // Process task
                        try {
                            Task processedTask = processor.processNextTask();
                            System.out.println("Processed task: " + processedTask);
                        } catch (EmptyQueueException e) {
                            // Specific handling for empty queue using System.err
                            System.err.println("Error: " + e.getMessage());
                        }
                        break;

                    case "v": // View pending tasks
                        System.out.println("Pending Tasks:");
                        Queue<Task> pending = processor.getPendingTasks();
                        if (pending.isEmpty()) {
                            System.out.println("(Queue is empty)");
                        } else {
                            // Iterate and print tasks from the queue
                            for (Task task : pending) {
                                System.out.println(task);
                            }
                        }
                        break;

                    case "c": // View completed tasks
                        System.out.println("Completed Tasks:");
                        List<Task> completed = processor.getCompletedTasks(); // Using the List interface
                        if (completed.isEmpty()) {
                            System.out.println("(No tasks completed yet)");
                        } else {
                            // Iterate and print tasks from the list
                            for (Task task : completed) {
                                System.out.println(task);
                            }
                        }
                        break;

                    case "x": // Exit
                        System.out.println("Exiting Task Processing System.");
                        running = false;
                        break;

                    default: // Invalid command
                        System.err.println("Error: Invalid command. Please try again.");
                        break;
                }
            } catch (IllegalArgumentException e) {
                // Handle invalid input errors (e.g., empty description) using System.err
                System.err.println("Input Error: " + e.getMessage());
            } catch (Exception e) {
                // Catch any other unexpected exceptions during the loop iteration
                System.err.println("An unexpected error occurred: " + e.getMessage());
                // e.printStackTrace(); // Uncomment for debugging
            }
            System.out.println(); // Add a blank line for readability
        }

        scanner.close(); // Close the scanner when done
    }

    /**
     * Prints the main menu options to the console.
     */
    private static void printMenu() {
        System.out.println("Task Processing System Menu:");
        System.out.println("a: Add new task");
        System.out.println("p: Process next task");
        System.out.println("v: View pending tasks");
        System.out.println("c: View completed tasks");
        System.out.println("x: Exit");
    }
}
