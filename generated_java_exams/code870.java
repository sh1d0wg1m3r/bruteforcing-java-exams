/*
 * Exam Question #870
 * Generated on: 2025-05-12 16:53:08
 * Generated by: Account 3
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Task Management System
 * 
 * **Scenario:**
 * 
 * You are tasked with developing a simple command-line application to simulate a task processing pipeline. The system should allow users to add new tasks, process the next available task, and view both pending and completed tasks. Tasks are processed in the order they are added (First-In, First-Out).
 * 
 * **Requirements:**
 * 
 * 1.  **Task Representation:** Create a `Task` class with private fields for `description` (String) and `status` (String, e.g., "PENDING", "PROCESSED"). Include a constructor and appropriate public getter methods. Add a method or way to update the status. Override the `toString()` method for easy printing.
 * 
 * 2.  **System Core:** Create a `TaskProcessingSystem` class that manages the task flow.
 *     *   It must contain a `Queue<Task>` to hold tasks that are waiting to be processed.
 *     *   It must contain an `ArrayList<Task>` declared using the `List<Task>` interface type to hold tasks that have been processed.
 *     *   Use a `Scanner` object to read user input from the console.
 * 
 * 3.  **User Interface:** Implement a menu-driven interface within the `TaskProcessingSystem`. The menu should present the following options:
 *     *   1. Add New Task
 *     *   2. Process Next Task
 *     *   3. View Task Queue
 *     *   4. View Processed Tasks
 *     *   5. Exit
 * 
 * 4.  **Functionality:**
 *     *   **Add New Task:** Prompt the user for a task description, create a new `Task` object with "PENDING" status, and add it to the task queue. Implement input validation to ensure the description is not empty.
 *     *   **Process Next Task:** Take the next task from the front of the queue, update its status to "PROCESSED", and move it to the list of processed tasks. Handle the case where the queue is empty.
 *     *   **View Task Queue:** Display all tasks currently in the queue in their waiting order.
 *     *   **View Processed Tasks:** Display all tasks that have been processed.
 *     *   **Exit:** Terminate the application.
 * 
 * 5.  **Control Flow:** Use a `switch` statement to handle the different menu options.
 * 
 * 6.  **Output:**
 *     *   Use `System.out.println()` for the menu, prompts, success messages, and displaying task lists.
 *     *   Use `System.err.println()` for all error messages (e.g., invalid menu choice, empty task description, attempting to process an empty queue, invalid input type).
 * 
 * 7.  **Error Handling:** Implement robust exception handling.
 *     *   Wrap the main menu interaction loop (or the input reading/processing logic within it) with a `try-catch` block.
 *     *   Specifically handle `InputMismatchException` if the user enters non-integer input for the menu choice.
 *     *   Include a general `catch (Exception e)` block to catch any other unexpected runtime errors and print an informative message using `System.err`.
 *     *   Ensure the application doesn't crash on invalid input and allows the user to try again.
 * 
 * 8.  **Best Practices:**
 *     *   Adhere to proper encapsulation (private fields, public methods).
 *     *   Use meaningful variable and method names.
 *     *   Include appropriate comments explaining key parts of the code.
 *     *   Ensure clean code structure (separate classes, methods for distinct operations).
 * 
 * **Expected Output:**
 * 
 * The output should demonstrate the menu, user prompts, successful task additions, processing, viewing of queues and processed lists, and appropriate error messages for invalid input or operations (like processing an empty queue). See the example interaction flow provided in the problem brainstorming phase (not required to replicate exactly, but shows the expected behavior).
 * 
 * **Evaluation Criteria:**
 * 
 * *   Correct implementation and usage of `Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.err`, `System.out`, and `try-catch`.
 * *   Correct implementation of the Task class and its state management.
 * *   Accurate implementation of the menu operations (Add, Process, View Queue, View Processed, Exit).
 * *   Effective input validation and error handling, including specific handling for `InputMismatchException` and general exception handling.
 * *   Adherence to best practices (encapsulation, naming, comments, structure).
 *
 * EXPLANATION:
 * This solution implements a simple Task Management System using the required Java components and best practices.
 * 
 * 1.  **`Task` Class:** A basic POJO (`Plain Old Java Object`) representing a task. It encapsulates the `description` and `status` fields, making them private and providing public getters. A `setStatus` method allows changing the task's state upon processing. The `toString()` method provides a convenient way to print task details.
 * 
 * 2.  **`TaskProcessingSystem` Class:** This is the core class managing the application state and logic.
 *     *   `taskQueue`: A `Queue<Task>` is used, specifically a `LinkedList` which implements the `Queue` interface. This ensures tasks are processed in the order they are added (FIFO). `offer()` is used for adding tasks, and `poll()` for removing and retrieving the head of the queue.
 *     *   `processedTasks`: An `ArrayList<Task>` is used, declared with the `List<Task>` interface type. This list stores tasks after they have been processed. `ArrayList` is suitable here as we might need to iterate through it or access elements by index (though iteration is primarily used in this solution). Using `List` as the type promotes programming to the interface.
 *     *   `scanner`: A `Scanner` object is initialized to read user input from `System.in`.
 * 
 * 3.  **Menu and `switch`:** The `run()` method contains the main application loop. It repeatedly prints a menu using `printMenu()` and reads the user's integer choice using the `scanner`. A `switch` statement directs the program flow to the appropriate method (`addTask`, `processNextTask`, `viewTaskQueue`, `viewProcessedTasks`) based on the user's input.
 * 
 * 4.  **`System.out` and `System.err`:** `System.out.println()` is used for standard output like the menu, prompts, confirmation messages, and displaying the contents of the queue and processed list. `System.err.println()` is used exclusively for error messages, making them visually distinct in the console output (often appearing in red or a different style depending on the environment).
 * 
 * 5.  **Error Handling and `try-catch`:**
 *     *   The `run()` method contains a `try-catch` block that wraps the code which reads the user's choice and the subsequent `switch` statement. This provides class-wide handling for potential issues during the main interaction loop.
 *     *   `InputMismatchException` is specifically caught. This exception occurs if the user enters something that is not a valid integer when `scanner.nextInt()` is called. The `catch` block prints an error message to `System.err` and crucially calls `scanner.nextLine()` to consume the invalid input left in the buffer, preventing an infinite loop.
 *     *   A general `catch (Exception e)` block is included to catch any other unexpected runtime exceptions that might occur within the `try` block. It prints a generic error message using `System.err`.
 *     *   Specific operational errors, like attempting to process a task when the queue is empty, are handled with `if` checks and error messages printed to `System.err` directly within the relevant methods (`processNextTask`), as these are expected conditions rather than unexpected exceptions.
 *     *   Input validation for the task description (checking for empty/whitespace-only string) is done within the `addTask` method, also using `System.err` for the error message.
 * 
 * 6.  **Best Practices:**
 *     *   **Encapsulation:** Fields in both `Task` and `TaskProcessingSystem` are private, accessed via public methods.
 *     *   **Naming:** Variable names (`taskQueue`, `processedTasks`, `description`, `status`, `choice`) and method names (`addTask`, `processNextTask`, `viewTaskQueue`, `run`) are descriptive.
 *     *   **Comments:** Javadoc-style comments explain the purpose of classes, constructors, and key methods. Inline comments clarify important logic points (like consuming the newline after `nextInt`).
 *     *   **Structure:** The code is organized into two logical classes (`Task` and `TaskProcessingSystem`). The `TaskProcessingSystem` has dedicated methods for each menu operation, making the `run` method clean and focused on the main loop and error handling.
 * 
 * This solution effectively integrates the required Java components to build a functional, menu-driven application with appropriate error handling and adherence to standard practices, demonstrating a solid understanding of core Java concepts.
 */

import java.util.ArrayList;
import java.util.LinkedList; // LinkedList implements Queue
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.InputMismatchException;

// Represents a single task with a description and status.
class Task {
    private String description;
    private String status; // e.g., "PENDING", "PROCESSED"

    /**
     * Constructs a new Task with a description and initial status "PENDING".
     * @param description The description of the task.
     */
    public Task(String description) {
        this.description = description;
        this.status = "PENDING";
    }

    // --- Getters ---
    public String getDescription() {
        return description;
    }

    public String getStatus() {
        return status;
    }

    // --- Setter ---
    /**
     * Sets the status of the task.
     * @param status The new status (e.g., "PROCESSED").
     */
    public void setStatus(String status) {
        this.status = status;
    }

    /**
     * Provides a string representation of the Task.
     * @return A formatted string showing the task description and status.
     */
    @Override
    public String toString() {
        return "Task [Description: " + description + ", Status: " + status + "]";
    }
}

// Manages the task processing system, including the queue and processed list.
public class TaskProcessingSystem {
    // Queue for tasks waiting to be processed (FIFO)
    private Queue<Task> taskQueue;
    // List for tasks that have been processed
    private List<Task> processedTasks;
    // Scanner for reading user input
    private Scanner scanner;

    /**
     * Constructs a new TaskProcessingSystem, initializing the queue,
     * processed tasks list, and scanner.
     */
    public TaskProcessingSystem() {
        taskQueue = new LinkedList<>(); // LinkedList is a common Queue implementation
        processedTasks = new ArrayList<>(); // ArrayList implements List
        scanner = new Scanner(System.in);
    }

    /**
     * Adds a new task to the processing queue based on user input.
     * Validates that the task description is not empty.
     */
    public void addTask() {
        System.out.print("Enter task description: ");
        String description = scanner.nextLine(); // Read the whole line

        // Input validation
        if (description == null || description.trim().isEmpty()) {
            System.err.println("Error: Task description cannot be empty.");
            return; // Exit the method if validation fails
        }

        Task newTask = new Task(description.trim());
        taskQueue.offer(newTask); // Use offer() which is recommended for capacity-constrained queues, though LinkedList isn't capacity-constrained. It returns boolean.
        System.out.println("Task added to queue.");
    }

    /**
     * Processes the next task from the front of the queue.
     * Moves the task to the processed list after updating its status.
     * Handles the case where the queue is empty.
     */
    public void processNextTask() {
        // Check if the queue is empty before attempting to process
        if (taskQueue.isEmpty()) {
            System.err.println("Error: Task queue is empty. No tasks to process.");
            return; // Exit the method
        }

        // poll() retrieves and removes the head of the queue, returns null if empty
        Task nextTask = taskQueue.poll();

        if (nextTask != null) {
            nextTask.setStatus("PROCESSED"); // Update the task status
            processedTasks.add(nextTask); // Add to the processed list
            System.out.println("Processed task: " + nextTask.getDescription());
        } else {
             // This case should theoretically not be reached due to the isEmpty check,
             // but included for robustness if poll() somehow returned null unexpectedly.
             System.err.println("Error: Failed to retrieve task from queue.");
        }
    }

    /**
     * Displays all tasks currently waiting in the queue.
     */
    public void viewTaskQueue() {
        System.out.println("\n--- Current Task Queue ---");
        if (taskQueue.isEmpty()) {
            System.out.println("Queue is empty.");
        } else {
            // Iterate through the queue without removing elements
            int i = 1;
            for (Task task : taskQueue) {
                System.out.println(i++ + ". " + task);
            }
        }
        System.out.println("------------------------\n");
    }

    /**
     * Displays all tasks that have been moved to the processed list.
     */
    public void viewProcessedTasks() {
        System.out.println("\n--- Processed Tasks ---");
        if (processedTasks.isEmpty()) {
            System.out.println("No tasks have been processed yet.");
        } else {
            // Iterate through the list using index or enhanced for loop
            for (int i = 0; i < processedTasks.size(); i++) {
                System.out.println((i + 1) + ". " + processedTasks.get(i));
            }
        }
        System.out.println("-----------------------\n");
    }

    /**
     * Prints the main menu options to the console.
     */
    private void printMenu() {
        System.out.println("\nSelect an option:");
        System.out.println("1. Add New Task");
        System.out.println("2. Process Next Task");
        System.out.println("3. View Task Queue");
        System.out.println("4. View Processed Tasks");
        System.out.println("5. Exit");
    }

    /**
     * Runs the main application loop, handling user input and menu selection.
     * Includes robust exception handling for input errors.
     */
    public void run() {
        System.out.println("--- Task Processing System ---");
        int choice = -1;

        // Main application loop continues until the user chooses to exit (option 5)
        while (choice != 5) {
            printMenu(); // Display the menu

            // Use try-catch to handle potential exceptions during input reading and processing
            try {
                System.out.print("Enter your choice: ");
                choice = scanner.nextInt(); // Read integer input for choice
                scanner.nextLine(); // Consume the leftover newline character after reading int

                // Use a switch statement to perform actions based on user choice
                switch (choice) {
                    case 1:
                        addTask(); // Call method to add a task
                        break;
                    case 2:
                        processNextTask(); // Call method to process the next task
                        break;
                    case 3:
                        viewTaskQueue(); // Call method to view the queue
                        break;
                    case 4:
                        viewProcessedTasks(); // Call method to view processed tasks
                        break;
                    case 5:
                        System.out.println("Exiting system. Goodbye!"); // Exit message
                        break;
                    default:
                        // Handle invalid integer input (outside 1-5 range)
                        System.err.println("Invalid choice. Please enter a number between 1 and 5.");
                }
            } catch (InputMismatchException e) {
                // Catch exception if the user enters non-integer input
                System.err.println("Invalid input. Please enter a number.");
                scanner.nextLine(); // IMPORTANT: Consume the invalid input to prevent infinite loop
                choice = -1; // Reset choice to ensure loop continues after error
            } catch (Exception e) {
                // Catch any other unexpected exceptions during the loop
                System.err.println("An unexpected error occurred: " + e.getMessage());
                // e.printStackTrace(); // Uncomment for detailed debugging if needed in a real scenario
                choice = -1; // Reset choice to ensure loop continues after error
            }
        }

        // Close the scanner when the application exits
        scanner.close();
    }

    /**
     * The main method to start the Task Processing System application.
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        TaskProcessingSystem system = new TaskProcessingSystem();
        system.run(); // Start the main application loop
    }
}
