/*
 * Exam Question #1160
 * Generated on: 2025-05-12 17:33:21
 * Generated by: Account 5
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Customer Service Simulation
 * 
 * **Scenario:**
 * 
 * You are tasked with building a simple simulation for a customer service center. Customers arrive and join a waiting queue. Service agents process customers one by one from the front of the queue. The system needs to track both the customers currently waiting for service and those who have already been served.
 * 
 * **Task:**
 * 
 * Implement a Java program that simulates this customer service system. Your program should allow users to:
 * 
 * 1.  Add a new customer to the waiting queue.
 * 2.  Serve the next customer from the waiting queue.
 * 3.  View the list of customers currently waiting.
 * 4.  View the list of customers who have been served.
 * 5.  Exit the application.
 * 
 * **Requirements:**
 * 
 * 1.  Create a `Customer` class to represent a customer. It should have a private field for the customer's name and appropriate getter methods.
 * 2.  Create a `CustomerServiceSystem` class to manage the simulation state.
 *     *   This class must use a `java.util.Queue<Customer>` to represent the waiting line.
 *     *   This class must use a `java.util.List<Customer>` (implemented with `java.util.ArrayList`) to store the history of served customers.
 *     *   Implement methods `addCustomer(String name)`, `serveNextCustomer()`, `getWaitingCustomers()`, and `getServedCustomers()`.
 *     *   `addCustomer` should add a new `Customer` to the waiting queue. It must validate that the name is not null or empty.
 *     *   `serveNextCustomer` should remove the customer at the front of the queue and add them to the served customers list. It should return the served `Customer` object or `null` if the queue was empty.
 *     *   `getWaitingCustomers` and `getServedCustomers` should return a `List<Customer>` representing the current state of the respective collections (ideally, a copy to prevent external modification).
 * 3.  Implement the main application logic in a class (e.g., `ServiceSimulator`).
 *     *   Use `java.util.Scanner` to read user input from the console.
 *     *   Implement a menu-driven interface for the user to choose actions (Add, Serve, View Waiting, View Served, Exit).
 *     *   Use a `switch` statement to handle the different menu options.
 *     *   Use `System.out.println()` for displaying the menu, prompts, and successful operation outputs (e.g., "Customer added", "Customer served", lists of customers).
 *     *   Use `System.err.println()` for displaying error messages (e.g., invalid menu choice, trying to serve from an empty queue, invalid customer name input).
 *     *   Implement class-wide exception handling using a `try-catch` block around the main application loop to catch any unexpected runtime exceptions.
 * 4.  Adhere to Java best practices:
 *     *   Proper encapsulation (private fields, public methods).
 *     *   Meaningful variable and method names.
 *     *   Include basic comments where necessary to explain complex logic (though the logic is relatively straightforward here, focus on clear code).
 *     *   Basic input validation as specified (non-empty name, valid menu choice).
 *     *   Proper error handling using `System.err` for user-level errors and `try-catch` for unexpected system errors.
 *     *   Clean code structure with separate classes for different responsibilities.
 * 
 * **Expected Output:**
 * 
 * The program should display a menu and respond to user commands. Examples:
 * 
 * ```
 * --- Customer Service Menu ---
 * 1. Add Customer
 * 2. Serve Next Customer
 * 3. View Waiting Queue
 * 4. View Served Customers
 * 5. Exit
 * Enter your choice: 1
 * Enter customer name: Alice
 * Customer 'Alice' added to the waiting queue.
 * 
 * --- Customer Service Menu ---
 * 1. Add Customer
 * 2. Serve Next Customer
 * 3. View Waiting Queue
 * 4. View Served Customers
 * 5. Exit
 * Enter your choice: 1
 * Enter customer name: Bob
 * Customer 'Bob' added to the waiting queue.
 * 
 * --- Customer Service Menu ---
 * 1. Add Customer
 * 2. Serve Next Customer
 * 3. View Waiting Queue
 * 4. View Served Customers
 * 5. Exit
 * Enter your choice: 3
 * Waiting Queue:
 * 1. Alice
 * 2. Bob
 * 
 * --- Customer Service Menu ---
 * 1. Add Customer
 * 2. Serve Next Customer
 * 3. View Waiting Queue
 * 4. View Served Customers
 * 5. Exit
 * Enter your choice: 2
 * Customer 'Alice' served.
 * 
 * --- Customer Service Menu ---
 * 1. Add Customer
 * 2. Serve Next Customer
 * 3. View Waiting Queue
 * 4. View Served Customers
 * 5. Exit
 * Enter your choice: 3
 * Waiting Queue:
 * 1. Bob
 * 
 * --- Customer Service Menu ---
 * 1. Add Customer
 * 2. Serve Next Customer
 * 3. View Waiting Queue
 * 4. View Served Customers
 * 5. Exit
 * Enter your choice: 4
 * Served Customers:
 * 1. Alice
 * 
 * --- Customer Service Menu ---
 * 1. Add Customer
 * 2. Serve Next Customer
 * 3. View Waiting Queue
 * 4. View Served Customers
 * 5. Exit
 * Enter your choice: 2
 * Customer 'Bob' served.
 * 
 * --- Customer Service Menu ---
 * 1. Add Customer
 * 2. Serve Next Customer
 * 3. View Waiting Queue
 * 4. View Served Customers
 * 5. Exit
 * Enter your choice: 2
 * System.err: No customers in the waiting queue to serve.
 * 
 * --- Customer Service Menu ---
 * ...
 * Enter your choice: 6
 * System.err: Invalid choice. Please enter a number between 1 and 5.
 * 
 * --- Customer Service Menu ---
 * ...
 * Enter your choice: 5
 * Exiting Customer Service Simulator.
 * ```
 * 
 * **Evaluation:**
 * 
 * Your solution will be evaluated based on:
 * *   Correct implementation of all required components (`Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.err`, `System.out`, `try-catch`).
 * *   Accuracy in simulating the customer service flow (adding to queue, serving from queue, moving to served list).
 * *   Adherence to best practices (encapsulation, naming, validation, error handling).
 * *   Clear and readable code.
 * 
 * Good luck!
 *
 * EXPLANATION:
 * This solution implements a simple customer service simulation demonstrating the required Java concepts and best practices.
 * 
 * 1.  **`Customer` Class:** A basic class representing a customer with a `private` `name` field and a public getter (`getName()`) for encapsulation. The `toString()` method is overridden for easy printing.
 * 
 * 2.  **`CustomerServiceSystem` Class:**
 *     *   This class holds the core state of the simulation: a `Queue<Customer>` named `waitingQueue` and a `List<Customer>` named `servedCustomers`. `LinkedList` is used to implement `Queue` because it provides efficient additions and removals from both ends, suitable for a queue. `ArrayList` is used for the `servedCustomers` list for efficient storage and retrieval by index (though iteration is used here).
 *     *   `addCustomer(String name)`: Takes a customer name, performs basic validation (checks if null or empty), creates a `Customer` object, and adds it to the `waitingQueue` using `offer()`. `offer()` is part of the `Queue` interface and is designed for adding elements.
 *     *   `serveNextCustomer()`: Uses `waitingQueue.poll()`. The `poll()` method is the standard way to remove and return the head of a queue; it returns `null` if the queue is empty, which is handled to report the "No customers" error. If a customer is retrieved, they are added to the `servedCustomers` list.
 *     *   `getWaitingCustomers()` and `getServedCustomers()`: These methods return `List<Customer>`. Crucially, they return *new* `ArrayList` instances populated with the elements from the internal collections. This prevents external code from directly modifying the internal `waitingQueue` or `servedCustomers` list, adhering to good encapsulation principles.
 * 
 * 3.  **`ServiceSimulator` Class (Main Application):**
 *     *   The `main` method contains the primary application logic.
 *     *   **Class-wide `try-catch`:** The entire main execution loop and resource setup (`Scanner`, `CustomerServiceSystem`) are wrapped in a `try-catch(Exception e)` block. This fulfills the requirement for class-wide exception handling, catching any unexpected runtime errors that might occur during the program's execution and printing an error message and stack trace to `System.err`.
 *     *   **`Scanner`:** An instance of `Scanner` is created to read input from `System.in`. It's closed using `scanner.close()` when the main loop finishes.
 *     *   **Main Loop:** A `while(running)` loop keeps the application running until the user chooses to exit.
 *     *   **Menu and `switch`:** Inside the loop, `displayMenu()` prints the options to `System.out`. User input is read using `scanner.nextLine()`. Basic validation checks if the input is a single digit before parsing it to an integer. A `switch` statement then directs the program flow based on the parsed choice.
 *     *   **Handling Menu Options:**
 *         *   Case 1 (`Add Customer`): Prompts for a name, calls `system.addCustomer()`, and prints a success message to `System.out` if successful (validation is done within `addCustomer`).
 *         *   Case 2 (`Serve Next`): Calls `system.serveNextCustomer()`. If the returned customer is not `null`, it prints a success message to `System.out`. If it's `null` (queue was empty), it prints an error to `System.err`.
 *         *   Case 3 (`View Waiting`): Calls `system.getWaitingCustomers()`, iterates through the returned `List`, and prints customer names to `System.out`. Handles the case of an empty list.
 *         *   Case 4 (`View Served`): Calls `system.getServedCustomers()`, iterates through the returned `List`, and prints customer names to `System.out`. Handles the case of an empty list.
 *         *   Case 5 (`Exit`): Sets the `running` flag to `false` to terminate the loop and prints an exit message to `System.out`.
 *         *   `default`: For any invalid menu input, an error message is printed to `System.err`.
 *     *   **`System.out` vs. `System.err`:** `System.out` is used for normal program output (menu, prompts, success messages, lists). `System.err` is used specifically for error conditions (invalid input, empty queue operations, unexpected exceptions caught by the `try-catch`).
 * 
 * This solution effectively uses all the required Java components in a practical scenario, demonstrating understanding of collections, input/output, control flow, encapsulation, validation, and error handling.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;

// Represents a customer
class Customer {
    private String name;

    /**
     * Constructs a new Customer with the given name.
     * @param name The name of the customer.
     */
    public Customer(String name) {
        this.name = name;
    }

    /**
     * Gets the name of the customer.
     * @return The customer's name.
     */
    public String getName() {
        return name;
    }

    @Override
    public String toString() {
        return name;
    }
}

// Manages the customer service simulation state
class CustomerServiceSystem {
    // Queue for customers waiting for service
    private Queue<Customer> waitingQueue;
    // List for customers who have been served
    private List<Customer> servedCustomers;

    /**
     * Constructs a new CustomerServiceSystem.
     * Initializes the waiting queue and served customers list.
     */
    public CustomerServiceSystem() {
        // Using LinkedList as a Queue implementation
        this.waitingQueue = new LinkedList<>();
        // Using ArrayList as a List implementation for served customers
        this.servedCustomers = new ArrayList<>();
    }

    /**
     * Adds a new customer to the waiting queue.
     * @param name The name of the customer to add.
     * @return true if the customer was successfully added, false otherwise (e.g., invalid name).
     */
    public boolean addCustomer(String name) {
        if (name == null || name.trim().isEmpty()) {
            System.err.println("Customer name cannot be empty.");
            return false;
        }
        Customer customer = new Customer(name.trim());
        waitingQueue.offer(customer); // offer is generally preferred over add for capacity-constrained queues, but safe here.
        return true;
    }

    /**
     * Serves the next customer from the waiting queue.
     * The served customer is moved to the served customers list.
     * @return The Customer object that was served, or null if the waiting queue is empty.
     */
    public Customer serveNextCustomer() {
        Customer served = waitingQueue.poll(); // poll retrieves and removes the head of the queue, returns null if empty
        if (served != null) {
            servedCustomers.add(served);
        }
        return served;
    }

    /**
     * Gets a list of customers currently in the waiting queue.
     * Returns a copy to prevent external modification of the internal queue.
     * @return A List containing the waiting customers.
     */
    public List<Customer> getWaitingCustomers() {
        // Return a new ArrayList based on the current queue elements
        return new ArrayList<>(waitingQueue);
    }

    /**
     * Gets a list of customers who have been served.
     * Returns a copy to prevent external modification of the internal list.
     * @return A List containing the served customers.
     */
    public List<Customer> getServedCustomers() {
        // Return a new ArrayList based on the current served customers
        return new ArrayList<>(servedCustomers);
    }
}

// Main class to run the simulation and handle user interaction
public class ServiceSimulator {

    /**
     * Displays the main menu options to the user.
     */
    private static void displayMenu() {
        System.out.println("\n--- Customer Service Menu ---");
        System.out.println("1. Add Customer");
        System.out.println("2. Serve Next Customer");
        System.out.println("3. View Waiting Queue");
        System.out.println("4. View Served Customers");
        System.out.println("5. Exit");
        System.out.print("Enter your choice: ");
    }

    public static void main(String[] args) {
        // Class-wide exception handling for the main execution flow
        try {
            CustomerServiceSystem system = new CustomerServiceSystem();
            Scanner scanner = new Scanner(System.in);
            boolean running = true;

            while (running) {
                displayMenu();
                String input = scanner.nextLine();

                // Basic input validation for menu choice
                if (input.length() != 1 || !Character.isDigit(input.charAt(0))) {
                     System.err.println("Invalid input. Please enter a single digit menu number.");
                     continue; // Skip to next iteration
                }

                int choice = Integer.parseInt(input); // Safe to parse after digit check

                // Using switch for flow control based on user choice
                switch (choice) {
                    case 1: // Add Customer
                        System.out.print("Enter customer name: ");
                        String name = scanner.nextLine();
                        if (system.addCustomer(name)) {
                            System.out.println("Customer '" + name.trim() + "' added to the waiting queue.");
                        }
                        // Error message handled within addCustomer if name is invalid
                        break;

                    case 2: // Serve Next Customer
                        Customer servedCustomer = system.serveNextCustomer();
                        if (servedCustomer != null) {
                            System.out.println("Customer '" + servedCustomer.getName() + "' served.");
                        } else {
                            System.err.println("No customers in the waiting queue to serve.");
                        }
                        break;

                    case 3: // View Waiting Queue
                        List<Customer> waitingList = system.getWaitingCustomers();
                        System.out.println("Waiting Queue:");
                        if (waitingList.isEmpty()) {
                            System.out.println("  (Empty)");
                        } else {
                            for (int i = 0; i < waitingList.size(); i++) {
                                System.out.println("  " + (i + 1) + ". " + waitingList.get(i).getName());
                            }
                        }
                        break;

                    case 4: // View Served Customers
                        List<Customer> servedList = system.getServedCustomers();
                        System.out.println("Served Customers:");
                        if (servedList.isEmpty()) {
                            System.out.println("  (None yet)");
                        } else {
                            for (int i = 0; i < servedList.size(); i++) {
                                System.out.println("  " + (i + 1) + ". " + servedList.get(i).getName());
                            }
                        }
                        break;

                    case 5: // Exit
                        running = false;
                        System.out.println("Exiting Customer Service Simulator.");
                        break;

                    default: // Invalid choice
                        System.err.println("Invalid choice. Please enter a number between 1 and 5.");
                        break;
                }
            }

            scanner.close(); // Close the scanner when done

        } catch (Exception e) {
            // Catch any unexpected exceptions during execution
            System.err.println("\nAn unexpected system error occurred:");
            e.printStackTrace(); // Print stack trace for debugging
            System.err.println("Simulation terminated due to an error.");
        }
    }
}
