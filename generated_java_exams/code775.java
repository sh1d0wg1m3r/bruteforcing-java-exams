/*
 * Exam Question #775
 * Generated on: 2025-05-12 16:38:51
 * Generated by: Account 2
 * 
 * QUESTION:
 * ## Advanced Java Programming Exam Task: Package Delivery Routing Simulator
 * 
 * **Problem Description:**
 * 
 * You are tasked with developing a simple console-based application for a package delivery service. The system needs to manage packages waiting for delivery and simulate the processing of these packages. This task requires demonstrating your understanding of core Java data structures, control flow, exception handling, and object-oriented principles.
 * 
 * **System Requirements:**
 * 
 * The application should allow users to perform the following operations via a command-line interface:
 * 
 * 1.  **Add a new package:** Prompt the user for package details (Tracking ID, Destination Address) and add it to a queue of packages waiting for delivery.
 * 2.  **Process next package:** Take the next package from the waiting queue, mark it as "Processed", and move it to a list of processed packages. If the queue is empty, report an error.
 * 3.  **View system status:** Display the number of packages currently waiting in the queue and list all packages that have been processed, including their details and status.
 * 4.  **Exit:** Terminate the application.
 * 
 * **Technical Requirements:**
 * 
 * Your solution *must* utilize the following Java components:
 * 
 * *   `java.util.Queue` (for managing packages waiting for delivery)
 * *   `java.util.ArrayList` (as the concrete implementation for the list of processed packages)
 * *   `java.util.List` (as the declared type for the list of processed packages, demonstrating polymorphism)
 * *   `java.util.Scanner` (for reading user input from the console)
 * *   `switch` statement (for handling user menu choices)
 * *   `System.err` (for printing error messages, e.g., when trying to process a package from an empty queue)
 * *   `System.out` (for printing normal output, menus, status updates, etc.)
 * *   Class-wide exception handling using `try-catch` blocks to gracefully handle unexpected issues during the main application loop.
 * 
 * **Best Practices Requirements:**
 * 
 * Your code should adhere to the following best practices:
 * 
 * *   **Encapsulation:** Use private fields and public methods for your classes.
 * *   **Meaningful Names:** Use descriptive names for variables, methods, and classes.
 * *   **Comments & Documentation:** Include appropriate comments (especially Javadoc for classes/methods) explaining the purpose of code sections.
 * *   **Input Validation:** Perform basic validation on user input (e.g., checking if required fields like Tracking ID are empty).
 * *   **Error Handling:** Implement checks for potential issues (like an empty queue) and handle them gracefully, reporting errors using `System.err`.
 * *   **Clean Code Structure:** Organize your code into logical classes and methods.
 * 
 * **Expected Output:**
 * 
 * The program should present a menu to the user, accept commands, and produce output similar to the following interaction flow:
 * 
 * ```
 * --- Package Delivery Simulator ---
 * 1. Add New Package
 * 2. Process Next Package
 * 3. View System Status
 * 4. Exit
 * Enter your choice: 1
 * Enter Tracking ID: PKG123
 * Enter Destination Address: 101 Main St
 * Package PKG123 added to queue.
 * 
 * --- Package Delivery Simulator ---
 * 1. Add New Package
 * 2. Process Next Package
 * 3. View System Status
 * 4. Exit
 * Enter your choice: 1
 * Enter Tracking ID: PKG456
 * Enter Destination Address: 202 Oak Ave
 * Package PKG456 added to queue.
 * 
 * --- Package Delivery Simulator ---
 * 1. Add New Package
 * 2. Process Next Package
 * 3. View System Status
 * 4. Exit
 * Enter your choice: 2
 * Processing package: PKG123 to 101 Main St. Status: Processed.
 * 
 * --- Package Delivery Simulator ---
 * 1. Add New Package
 * 2. Process Next Package
 * 3. View System Status
 * 4. Exit
 * Enter your choice: 3
 * --- System Status ---
 * Packages waiting: 1
 * Processed Packages:
 * - Tracking ID: PKG123, Destination: 101 Main St, Status: Processed
 * 
 * --- Package Delivery Simulator ---
 * 1. Add New Package
 * 2. Process Next Package
 * 3. View System Status
 * 4. Exit
 * Enter your choice: 2
 * Processing package: PKG456 to 202 Oak Ave. Status: Processed.
 * 
 * --- Package Delivery Simulator ---
 * 1. Add New Package
 * 2. Process Next Package
 * 3. View System Status
 * 4. Exit
 * Enter your choice: 2
 * Error: No packages waiting in the queue.
 * 
 * --- Package Delivery Simulator ---
 * 1. Add New Package
 * 2. Process Next Package
 * 3. View System Status
 * 4. Exit
 * Enter your choice: 3
 * --- System Status ---
 * Packages waiting: 0
 * Processed Packages:
 * - Tracking ID: PKG123, Destination: 101 Main St, Status: Processed
 * - Tracking ID: PKG456, Destination: 202 Oak Ave, Status: Processed
 * 
 * --- Package Delivery Simulator ---
 * 1. Add New Package
 * 2. Process Next Package
 * 3. View System Status
 * 4. Exit
 * Enter your choice: 4
 * Exiting simulator.
 * ```
 * 
 * Your solution should be a single Java file containing all necessary classes.
 *
 * EXPLANATION:
 * The provided solution implements the Package Delivery Routing Simulator as requested, demonstrating the required Java concepts and best practices.
 * 
 * 1.  **Class Structure:**
 *     *   `Package` class: A simple POJO (Plain Old Java Object) representing a package. It encapsulates package data (`trackingId`, `destinationAddress`, `status`) using private fields and provides public getter and setter methods. The `toString()` method is overridden for easy printing of package details.
 *     *   `DeliveryServiceSimulator` class: This is the main class containing the application logic. It manages the collection of packages and handles user interaction.
 * 
 * 2.  **Data Structures (`Queue`, `List`, `ArrayList`):**
 *     *   `Queue<Package> waitingPackages`: A `Queue` is used to store packages that are waiting to be processed. The `Queue` interface guarantees FIFO (First-In, First-Out) order, which is suitable for processing packages in the order they were received. `LinkedList` is used as the concrete implementation, a common choice for implementing `Queue`. Packages are added using `offer()` and removed using `poll()`.
 *     *   `List<Package> processedPackages`: A `List` is used to store packages that have been processed. `List` provides an ordered collection, allowing us to keep track of processed packages in the order they were completed. The variable is declared as `List` but instantiated as `new ArrayList<>()`, fulfilling the requirement to use both `List` and `ArrayList` and demonstrating polymorphism. Packages are added using `add()`.
 * 
 * 3.  **User Input (`Scanner`):**
 *     *   A `java.util.Scanner` object is used to read input from `System.in` (the console). It's initialized in the `DeliveryServiceSimulator` constructor and used in methods like `getUserChoice()` and `addPackage()`. The scanner is properly closed in the `finally` block of the `runSimulation()` method to release system resources.
 * 
 * 4.  **Control Flow (`switch`, `while`):**
 *     *   The main application loop runs within a `while(running)` loop in the `runSimulation()` method.
 *     *   A `switch` statement in `handleUserChoice()` is used to direct the program flow based on the integer choice entered by the user, handling each menu option separately.
 * 
 * 5.  **Output (`System.out`, `System.err`):**
 *     *   `System.out.println()` is used for displaying the menu, success messages, status updates, and the list of processed packages.
 *     *   `System.err.println()` is used specifically for printing error messages, such as when the user enters invalid input or attempts to process a package when the queue is empty.
 * 
 * 6.  **Exception Handling (`try-catch`, `finally`):**
 *     *   A `try-catch(Exception e)` block is wrapped around the main `while` loop in `runSimulation()`. This provides class-wide exception handling, catching any unexpected runtime exceptions that might occur during the execution of the simulation logic and preventing the program from crashing abruptly. A simple error message is printed to `System.err`.
 *     *   A `finally` block is used to ensure that the `scanner` is closed regardless of whether an exception occurred or the loop finished normally (when `running` becomes `false`).
 * 
 * 7.  **Best Practices:**
 *     *   **Encapsulation:** Achieved in the `Package` class with private fields and public access methods. The `DeliveryServiceSimulator` also keeps its data structures private.
 *     *   **Meaningful Names:** Variable names like `waitingPackages`, `processedPackages`, `trackingId`, method names like `runSimulation`, `displayMenu`, `processNextPackage`, and class names like `Package`, `DeliveryServiceSimulator` are descriptive.
 *     *   **Comments & Documentation:** Javadoc comments are provided for classes and key methods, explaining their purpose, parameters, and return values. Inline comments are used where necessary.
 *     *   **Input Validation:** Basic validation is performed in `addPackage()` to check if tracking ID and destination address are empty. `getUserChoice()` handles non-integer input specifically. The `handleUserChoice()` method includes a `default` case for invalid menu numbers.
 *     *   **Error Handling:** Specific checks are implemented for business logic errors, such as checking if `waitingPackages.poll()` returns `null` in `processNextPackage()`. These errors are reported using `System.err`.
 *     *   **Clean Code Structure:** The logic is divided into small, focused methods (`displayMenu`, `getUserChoice`, `handleUserChoice`, `addPackage`, `processNextPackage`, `viewSystemStatus`), making the code readable and maintainable.
 * 
 * This solution effectively integrates all the required components within a practical scenario, demonstrating a solid understanding of fundamental and intermediate Java programming concepts.
 */

import java.util.LinkedList;
import java.util.Queue;
import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;

/**
 * Represents a package in the delivery system.
 */
class Package {
    private String trackingId;
    private String destinationAddress;
    private String status;

    /**
     * Constructs a new Package object.
     * Initially, the status is set to "Waiting".
     *
     * @param trackingId The unique tracking identifier for the package.
     * @param destinationAddress The delivery address for the package.
     */
    public Package(String trackingId, String destinationAddress) {
        this.trackingId = trackingId;
        this.destinationAddress = destinationAddress;
        this.status = "Waiting"; // Initial status
    }

    // --- Getters ---
    public String getTrackingId() {
        return trackingId;
    }

    public String getDestinationAddress() {
        return destinationAddress;
    }

    public String getStatus() {
        return status;
    }

    // --- Setters ---
    public void setStatus(String status) {
        this.status = status;
    }

    /**
     * Provides a string representation of the Package object.
     *
     * @return A formatted string describing the package.
     */
    @Override
    public String toString() {
        return "Tracking ID: " + trackingId + ", Destination: " + destinationAddress + ", Status: " + status;
    }
}

/**
 * Simulates a package delivery routing system.
 * Manages a queue of waiting packages and a list of processed packages.
 */
public class DeliveryServiceSimulator {

    // Use Queue for waiting packages (FIFO)
    private Queue<Package> waitingPackages;
    // Use List (implemented by ArrayList) for processed packages
    private List<Package> processedPackages;
    private Scanner scanner;
    private boolean running;

    /**
     * Constructs a DeliveryServiceSimulator.
     * Initializes the data structures and the scanner.
     */
    public DeliveryServiceSimulator() {
        // LinkedList is a common implementation for Queue
        this.waitingPackages = new LinkedList<>();
        // ArrayList implements the List interface
        this.processedPackages = new ArrayList<>();
        this.scanner = new Scanner(System.in);
        this.running = true;
    }

    /**
     * Starts the simulation, running the main application loop.
     * Includes class-wide exception handling.
     */
    public void runSimulation() {
        System.out.println("--- Package Delivery Simulator ---");

        // Class-wide try-catch block for the main simulation loop
        try {
            while (running) {
                displayMenu();
                int choice = getUserChoice();
                handleUserChoice(choice);
            }
        } catch (Exception e) {
            // Catch any unexpected exceptions during the simulation
            System.err.println("An unexpected error occurred: " + e.getMessage());
            // e.printStackTrace(); // Uncomment for detailed debugging
        } finally {
            // Ensure scanner is closed when the simulation ends
            if (scanner != null) {
                scanner.close();
            }
            System.out.println("Simulator shutdown complete.");
        }
    }

    /**
     * Displays the main menu options to the user.
     */
    private void displayMenu() {
        System.out.println("\n--- Package Delivery Simulator ---");
        System.out.println("1. Add New Package");
        System.out.println("2. Process Next Package");
        System.out.println("3. View System Status");
        System.out.println("4. Exit");
        System.out.print("Enter your choice: ");
    }

    /**
     * Reads and validates the user's menu choice.
     * Handles non-integer input gracefully.
     *
     * @return The valid integer choice entered by the user.
     */
    private int getUserChoice() {
        while (!scanner.hasNextInt()) {
            System.err.println("Invalid input. Please enter a number between 1 and 4.");
            scanner.next(); // Consume the invalid input
            displayMenu(); // Redisplay menu
            System.out.print("Enter your choice: ");
        }
        int choice = scanner.nextInt();
        scanner.nextLine(); // Consume the newline character left by nextInt()
        return choice;
    }

    /**
     * Handles the user's choice using a switch statement.
     *
     * @param choice The integer choice entered by the user.
     */
    private void handleUserChoice(int choice) {
        switch (choice) {
            case 1:
                addPackage();
                break;
            case 2:
                processNextPackage();
                break;
            case 3:
                viewSystemStatus();
                break;
            case 4:
                running = false; // Set flag to exit the loop
                System.out.println("Exiting simulator.");
                break;
            default:
                // Handle choices outside the valid range
                System.err.println("Invalid choice. Please enter a number between 1 and 4.");
        }
    }

    /**
     * Prompts the user for package details and adds a new package to the queue.
     * Includes basic input validation.
     */
    private void addPackage() {
        System.out.print("Enter Tracking ID: ");
        String trackingId = scanner.nextLine().trim();

        if (trackingId.isEmpty()) {
            System.err.println("Error: Tracking ID cannot be empty. Package not added.");
            return;
        }

        System.out.print("Enter Destination Address: ");
        String destinationAddress = scanner.nextLine().trim();

        if (destinationAddress.isEmpty()) {
             System.err.println("Error: Destination address cannot be empty. Package not added.");
             return;
        }

        Package newPackage = new Package(trackingId, destinationAddress);
        waitingPackages.offer(newPackage); // offer() is preferred over add() for capacity-constrained queues (though LinkedList is not)
        System.out.println("Package " + trackingId + " added to queue.");
    }

    /**
     * Processes the next package in the queue.
     * Removes it from the queue, updates its status, and adds it to the processed list.
     * Handles the case where the queue is empty.
     */
    private void processNextPackage() {
        // poll() retrieves and removes the head of the queue, returns null if queue is empty
        Package packageToProcess = waitingPackages.poll();

        if (packageToProcess == null) {
            System.err.println("Error: No packages waiting in the queue.");
        } else {
            packageToProcess.setStatus("Processed");
            processedPackages.add(packageToProcess); // Add to the processed list
            System.out.println("Processing package: " + packageToProcess.getTrackingId() +
                               " to " + packageToProcess.getDestinationAddress() +
                               ". Status: " + packageToProcess.getStatus() + ".");
        }
    }

    /**
     * Displays the current status of the system, including waiting and processed packages.
     */
    private void viewSystemStatus() {
        System.out.println("\n--- System Status ---");
        System.out.println("Packages waiting: " + waitingPackages.size());

        System.out.println("Processed Packages:");
        if (processedPackages.isEmpty()) {
            System.out.println("No packages have been processed yet.");
        } else {
            // Iterate through the List of processed packages
            for (Package p : processedPackages) {
                System.out.println("- " + p); // Uses Package.toString() implicitly
            }
        }
    }

    /**
     * The main entry point of the application.
     *
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        DeliveryServiceSimulator simulator = new DeliveryServiceSimulator();
        simulator.runSimulation();
    }
}
