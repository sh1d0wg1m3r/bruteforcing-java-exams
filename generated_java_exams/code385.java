/*
 * Exam Question #385
 * Generated on: 2025-05-11 23:03:23
 * Generated by: Account 1
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Advanced Document Processing System
 * 
 * **Scenario:**
 * 
 * You are tasked with building a simple command-line based system to manage documents awaiting processing. Documents have a name and a priority level. The system should allow users to add documents to a processing queue, process the next document based on arrival order, and view the current queue and the history of processed documents.
 * 
 * **Requirements:**
 * 
 * Implement a Java program that simulates this document processing system. Your solution must adhere to the following specific requirements:
 * 
 * 1.  **Core Functionality:**
 *     *   Allow users to add new documents to a processing queue. Each document should have a name (String) and a priority (integer).
 *     *   Implement a command to process the next document. This should remove the oldest document from the processing queue and move it to a history list.
 *     *   Implement a command to display the current documents in the processing queue.
 *     *   Implement a command to display the history of processed documents.
 *     *   Implement a command to exit the application.
 * 
 * 2.  **Mandatory Java Components:** Your solution **must** use ALL of the following:
 *     *   `java.util.Queue` (as the type for the processing queue)
 *     *   `java.util.ArrayList` (as the concrete implementation for the processed history)
 *     *   `java.util.List` (as the declared type for the processed history variable)
 *     *   `java.util.Scanner` (for reading user input from the console)
 *     *   `switch` statement (for handling user command selection)
 *     *   `System.err` (for printing error messages)
 *     *   `System.out` (for printing normal output, menus, prompts, and results)
 *     *   Class-wide exception handling using `try-catch` blocks (specifically for input parsing and potentially queue operations).
 * 
 * 3.  **Best Practices:**
 *     *   Use proper encapsulation (private fields, public methods) within classes.
 *     *   Use meaningful variable, method, and class names.
 *     *   Include appropriate comments and documentation (e.g., Javadoc for classes/methods).
 *     *   Implement input validation (e.g., ensuring priority is an integer, document name is not empty, command is valid).
 *     *   Implement robust error handling using `try-catch` and `System.err`.
 *     *   Structure your code cleanly with logical separation.
 * 
 * **User Interface (Command-Line):**
 * 
 * The system should present a menu of options to the user:
 * 1.  Add Document
 * 2.  Process Next Document
 * 3.  View Processing Queue
 * 4.  View Processed History
 * 5.  Exit
 * 
 * The user enters a number corresponding to their choice.
 * 
 * **Input/Output:**
 * 
 * *   When adding a document, prompt for the document name and priority.
 * *   When processing, confirm which document was processed or indicate if the queue was empty.
 * *   When viewing lists, display the documents clearly.
 * *   Use `System.out` for all successful operations, menus, and prompts.
 * *   Use `System.err` for all error messages (e.g., invalid command, invalid priority input, processing an empty queue).
 * 
 * **Example Interaction:**
 * 
 * ```
 * --- Document Processing System ---
 * Choose an option:
 * 1. Add Document
 * 2. Process Next Document
 * 3. View Processing Queue
 * 4. View Processed History
 * 5. Exit
 * Enter choice: 1
 * Enter document name: Report A
 * Enter priority: 5
 * 
 * Document 'Report A' added to the queue.
 * 
 * --- Document Processing System ---
 * Choose an option:
 * 1. Add Document
 * 2. Process Next Document
 * 3. View Processing Queue
 * 4. View Processed History
 * 5. Exit
 * Enter choice: 1
 * Enter document name: Memo B
 * Enter priority: 3
 * 
 * Document 'Memo B' added to the queue.
 * 
 * --- Document Processing System ---
 * Choose an option:
 * 1. Add Document
 * 2. Process Next Document
 * 3. View Processing Queue
 * 4. View Processed History
 * 5. Exit
 * Enter choice: 3
 * 
 * --- Processing Queue ---
 * 1. Report A (Priority: 5)
 * 2. Memo B (Priority: 3)
 * --------------------------
 * 
 * --- Document Processing System ---
 * Choose an option:
 * 1. Add Document
 * 2. Process Next Document
 * 3. View Processing Queue
 * 4. View Processed History
 * 5. Exit
 * Enter choice: 2
 * 
 * Processed document: Report A (Priority: 5)
 * 
 * --- Document Processing System ---
 * Choose an option:
 * 1. Add Document
 * 2. Process Next Document
 * 3. View Processing Queue
 * 4. View Processed History
 * 5. Exit
 * Enter choice: 3
 * 
 * --- Processing Queue ---
 * 1. Memo B (Priority: 3)
 * --------------------------
 * 
 * --- Document Processing System ---
 * Choose an option:
 * 1. Add Document
 * 2. Process Next Document
 * 3. View Processing Queue
 * 4. View Processed History
 * 5. Exit
 * Enter choice: 4
 * 
 * --- Processed History ---
 * 1. Report A (Priority: 5)
 * ---------------------------
 * 
 * --- Document Processing System ---
 * Choose an option:
 * 1. Add Document
 * 2. Process Next Document
 * 3. View Processing Queue
 * 4. View Processed History
 * 5. Exit
 * Enter choice: 6
 * 
 * Error: Invalid choice. Please enter a number between 1 and 5.
 * 
 * --- Document Processing System ---
 * Choose an option:
 * 1. Add Document
 * 2. Process Next Document
 * 3. View Processing Queue
 * 4. View Processed History
 * 5. Exit
 * Enter choice: 2
 * 
 * Processed document: Memo B (Priority: 3)
 * 
 * --- Document Processing System ---
 * Choose an option:
 * 1. Add Document
 * 2. Process Next Document
 * 3. View Processing Queue
 * 4. View Processed History
 * 5. Exit
 * Enter choice: 2
 * 
 * Error: Processing queue is empty.
 * 
 * --- Document Processing System ---
 * Choose an option:
 * 1. Add Document
 * 2. Process Next Document
 * 3. View Processing Queue
 * 4. View Processed History
 * 5. Exit
 * Enter choice: 5
 * 
 * Exiting Document Processing System.
 * ```
 * 
 * **Evaluation:**
 * 
 * Your solution will be evaluated based on:
 * *   Correct implementation of all required functionalities.
 * *   Proper and effective use of ALL specified Java components (`Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.err`, `System.out`, `try-catch`).
 * *   Adherence to best practices (encapsulation, naming, comments, validation, error handling, code structure).
 * *   Correct handling of edge cases (e.g., processing an empty queue, invalid input).
 * *   Clear and correct output format.
 * 
 * Good luck!
 *
 * EXPLANATION:
 * This solution implements the `DocumentProcessingSystem` as requested, demonstrating the required Java concepts and best practices.
 * 
 * 1.  **`Document` Class:** A simple class encapsulating document data (`name`, `priority`) with private fields and public getters, demonstrating encapsulation. Includes a `toString()` method for easy printing.
 * 
 * 2.  **`DocumentProcessingSystem` Class:**
 *     *   **Fields:**
 *         *   `processingQueue`: Declared as `Queue<Document>` and initialized with `new LinkedList<>()`. `LinkedList` is chosen because it implements the `Queue` interface and is efficient for adding/removing elements from the ends, suitable for a queue. This fulfills the `Queue` requirement.
 *         *   `processedHistory`: Declared as `List<Document>` and initialized with `new ArrayList<>()`. This demonstrates programming to the `List` interface while using the concrete `ArrayList` implementation, fulfilling both `List` and `ArrayList` requirements. `ArrayList` is suitable for storing a history where elements are added to the end and viewed sequentially.
 *         *   `scanner`: An instance of `Scanner` is created to handle user input, fulfilling the `Scanner` requirement.
 * 
 *     *   **`displayMenu()`:** A helper method to print the user options using `System.out`.
 * 
 *     *   **`addDocument()`:**
 *         *   Prompts the user for document name and priority.
 *         *   Uses `scanner.nextLine()` to read input.
 *         *   Includes basic input validation (`name.isEmpty()`).
 *         *   Uses a `try-catch` block specifically for parsing the priority input using `Integer.parseInt()`. If a `NumberFormatException` occurs (user enters non-integer text), an error message is printed to `System.err`.
 *         *   If successful, a new `Document` object is created and added to the `processingQueue` using `offer()`. `offer()` is used as it's the standard `Queue` method for adding and is safer than `add()` in capacity-constrained queues (though `LinkedList` is not capacity-constrained, `offer` is good practice for `Queue`).
 * 
 *     *   **`processNextDocument()`:**
 *         *   Uses `processingQueue.poll()` to retrieve and remove the head of the queue. `poll()` is used because it returns `null` if the queue is empty, preventing an exception (`remove()` would throw `NoSuchElementException`).
 *         *   Checks if `processedDoc` is not `null`.
 *         *   If a document was retrieved, it's added to the `processedHistory` list using `add()`.
 *         *   Prints a success message using `System.out`.
 *         *   If `processedDoc` is `null` (queue was empty), an error message is printed to `System.err`.
 * 
 *     *   **`viewProcessingQueue()`:** Iterates through the `processingQueue` and prints each document using `System.out`. Includes a check for an empty queue.
 * 
 *     *   **`viewProcessedHistory()`:** Iterates through the `processedHistory` list and prints each document using `System.out`. Includes a check for an empty history.
 * 
 *     *   **`start()`:**
 *         *   Contains the main application loop (`while(running)`).
 *         *   Calls `displayMenu()`.
 *         *   Uses a `try-catch` block that wraps the input reading and `switch` statement. This provides class-wide exception handling. It catches `NumberFormatException` specifically for the menu choice input and a general `Exception` for any other unexpected issues during the loop iteration. Error messages are printed to `System.err`.
 *         *   Reads the user's choice using `scanner.nextLine()` and parses it. Reading the whole line and parsing is crucial to consume the newline character after reading the number, preventing issues with subsequent `scanner.nextLine()` calls in methods like `addDocument()`.
 *         *   Uses a `switch` statement based on the parsed choice to call the appropriate method (`addDocument`, `processNextDocument`, etc.). This fulfills the `switch` requirement.
 *         *   Handles the "Exit" case by setting `running` to `false`.
 *         *   Includes a `default` case in the `switch` to handle invalid integer choices, printing an error to `System.err`.
 *         *   The `scanner` is closed when the loop exits.
 * 
 *     *   **`main()`:** The entry point of the application. Creates an instance of `DocumentProcessingSystem` and calls its `start()` method.
 * 
 * **Best Practices Demonstrated:**
 * 
 * *   **Encapsulation:** `Document` fields are private.
 * *   **Naming:** Clear names like `processingQueue`, `processedHistory`, `addDocument`, `processNextDocument`.
 * *   **Comments/Documentation:** Javadoc-style comments explain the purpose of classes and methods.
 * *   **Input Validation:** Checks for empty document name and uses `try-catch` for `NumberFormatException` during input parsing.
 * *   **Error Handling:** Uses `try-catch` extensively for potential input and runtime errors, printing messages to `System.err`. Handles specific cases like processing an empty queue.
 * *   **Clean Code Structure:** Logic is separated into distinct methods (`addDocument`, `processNextDocument`, etc.), making the `start()` method readable and focused on flow control. Using `List` as the interface type for `processedHistory` is also a best practice.
 * 
 * This solution effectively integrates all required components and demonstrates robust error handling and clean coding principles within the context of a practical simulation.
 */

import java.util.LinkedList;
import java.util.Queue;
import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;
import java.util.InputMismatchException; // Specific exception for non-integer input

/**
 * Represents a document with a name and priority.
 */
class Document {
    private String name;
    private int priority;

    /**
     * Constructs a new Document.
     * @param name The name of the document.
     * @param priority The priority level of the document.
     */
    public Document(String name, int priority) {
        this.name = name;
        this.priority = priority;
    }

    /**
     * Gets the name of the document.
     * @return The document name.
     */
    public String getName() {
        return name;
    }

    /**
     * Gets the priority of the document.
     * @return The document priority.
     */
    public int getPriority() {
        return priority;
    }

    /**
     * Returns a string representation of the document.
     * @return String format: "Name (Priority: X)".
     */
    @Override
    public String toString() {
        return name + " (Priority: " + priority + ")";
    }
}

/**
 * Manages a queue of documents for processing and keeps a history of processed documents.
 */
public class DocumentProcessingSystem {

    // Required: java.util.Queue
    private Queue<Document> processingQueue;

    // Required: java.util.List (as type) and java.util.ArrayList (as implementation)
    private List<Document> processedHistory;

    // Required: java.util.Scanner
    private Scanner scanner;

    /**
     * Constructs a new DocumentProcessingSystem, initializing the queue, history, and scanner.
     */
    public DocumentProcessingSystem() {
        // LinkedList implements Queue
        this.processingQueue = new LinkedList<>();
        // ArrayList is a concrete implementation of List
        this.processedHistory = new ArrayList<>();
        this.scanner = new Scanner(System.in);
    }

    /**
     * Displays the main menu to the user.
     * Required: System.out
     */
    private void displayMenu() {
        System.out.println("\n--- Document Processing System ---");
        System.out.println("Choose an option:");
        System.out.println("1. Add Document");
        System.out.println("2. Process Next Document");
        System.out.println("3. View Processing Queue");
        System.out.println("4. View Processed History");
        System.out.println("5. Exit");
        System.out.print("Enter choice: ");
    }

    /**
     * Adds a new document to the processing queue based on user input.
     * Required: Scanner, try-catch, System.out, System.err
     */
    private void addDocument() {
        System.out.print("Enter document name: ");
        String name = scanner.nextLine().trim(); // Use nextLine() after nextInt() to consume newline

        if (name.isEmpty()) {
            System.err.println("Error: Document name cannot be empty.");
            return;
        }

        System.out.print("Enter priority: ");
        int priority;
        // Required: try-catch for input parsing
        try {
            priority = Integer.parseInt(scanner.nextLine()); // Use nextLine() to get the whole line then parse
            Document doc = new Document(name, priority);
            processingQueue.offer(doc); // offer() is preferred over add() in queues as it doesn't throw exception on capacity limits
            System.out.println("\nDocument '" + name + "' added to the queue.");
        } catch (NumberFormatException e) {
            // Required: System.err for error messages
            System.err.println("Error: Invalid priority input. Please enter an integer.");
        }
    }

    /**
     * Processes the next document in the queue, moving it to history.
     * Required: Queue, List, try-catch, System.out, System.err
     */
    private void processNextDocument() {
        Document processedDoc = processingQueue.poll(); // poll() returns null if queue is empty

        if (processedDoc != null) {
            processedHistory.add(processedDoc); // Add to history list
            System.out.println("\nProcessed document: " + processedDoc);
        } else {
            // Required: System.err for error messages
            System.err.println("Error: Processing queue is empty.");
        }
    }

    /**
     * Displays the current contents of the processing queue.
     * Required: Queue, System.out
     */
    private void viewProcessingQueue() {
        System.out.println("\n--- Processing Queue ---");
        if (processingQueue.isEmpty()) {
            System.out.println("Queue is empty.");
        } else {
            int index = 1;
            for (Document doc : processingQueue) {
                System.out.println(index++ + ". " + doc);
            }
        }
        System.out.println("--------------------------");
    }

    /**
     * Displays the history of processed documents.
     * Required: List, System.out
     */
    private void viewProcessedHistory() {
        System.out.println("\n--- Processed History ---");
        if (processedHistory.isEmpty()) {
            System.out.println("History is empty.");
        } else {
            int index = 1;
            for (Document doc : processedHistory) {
                System.out.println(index++ + ". " + doc);
            }
        }
        System.out.println("---------------------------");
    }

    /**
     * Starts the main application loop.
     * Required: Scanner, switch, try-catch, System.out, System.err
     */
    public void start() {
        boolean running = true;
        while (running) {
            displayMenu();
            int choice = -1; // Default invalid choice

            // Required: Class-wide exception handling for the main loop's input
            try {
                // Read the whole line to prevent newline issues with subsequent nextLine()
                String inputLine = scanner.nextLine();
                choice = Integer.parseInt(inputLine);

                // Required: switch statement for flow control
                switch (choice) {
                    case 1:
                        addDocument();
                        break;
                    case 2:
                        processNextDocument();
                        break;
                    case 3:
                        viewProcessingQueue();
                        break;
                    case 4:
                        viewProcessedHistory();
                        break;
                    case 5:
                        running = false;
                        System.out.println("\nExiting Document Processing System.");
                        break;
                    default:
                        // Required: System.err for error messages
                        System.err.println("Error: Invalid choice. Please enter a number between 1 and 5.");
                        break;
                }
            } catch (NumberFormatException e) {
                // Required: System.err for error messages
                System.err.println("Error: Invalid input. Please enter a number.");
            } catch (Exception e) {
                // Catch any other unexpected exceptions
                System.err.println("An unexpected error occurred: " + e.getMessage());
                // e.printStackTrace(); // Uncomment for debugging
            }
        }
        scanner.close(); // Close the scanner when done
    }

    /**
     * Main method to run the Document Processing System.
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        DocumentProcessingSystem system = new DocumentProcessingSystem();
        system.start();
    }
}
