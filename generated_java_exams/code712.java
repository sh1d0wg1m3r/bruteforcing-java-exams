/*
 * Exam Question #712
 * Generated on: 2025-05-12 16:29:15
 * Generated by: Account 1
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Team Task Management System
 * 
 * **Scenario:**
 * 
 * You are tasked with developing a simple console-based application for managing tasks within a small team. The system should allow for adding new tasks, adding team members, assigning pending tasks to members, and marking tasks as completed. The system needs to maintain a queue of pending tasks and lists of all tasks and team members.
 * 
 * **Requirements:**
 * 
 * 1.  **Data Structures:**
 *     *   Use a `Queue<Integer>` to store the IDs of tasks that are currently pending and available for assignment. The queue should follow a First-In, First-Out (FIFO) order.
 *     *   Use a `List<Task>` to store all tasks created in the system.
 *     *   Use a `List<TeamMember>` to store all registered team members.
 *     *   Use `ArrayList` as the concrete implementation for the `List` interfaces.
 * 
 * 2.  **Classes:**
 *     *   Create a `Task` class with private fields for `taskId` (int), `description` (String), `status` (use an enum `TaskStatus`: `PENDING`, `ASSIGNED`, `COMPLETED`), and `assignedToMemberId` (int, 0 if not assigned). Include a constructor, public getters, and appropriate methods (possibly package-private setters) to manage the status and assignment. Override `toString()` for easy printing.
 *     *   Create a `TeamMember` class with private fields for `memberId` (int) and `name` (String). Include a constructor, public getters, and override `toString()`.
 *     *   Create a `TaskManager` class that contains the main logic and the collections (`Queue`, `List`s). This class should have methods for each menu operation.
 * 
 * 3.  **Functionality (Menu-driven):** Implement the following options using a `switch` statement in the main application loop:
 *     *   **1. Add New Task:** Prompt for task description. Create a new `Task` object, add it to the list of all tasks, and add its ID to the queue of pending tasks. Assign unique IDs starting from 1.
 *     *   **2. List Pending Tasks:** Display tasks whose IDs are currently in the pending queue. Iterate the queue (without removing elements) to find and print the corresponding tasks from the all-tasks list.
 *     *   **3. Add Team Member:** Prompt for member name. Create a new `TeamMember` object and add it to the list of team members. Assign unique IDs starting from 1.
 *     *   **4. List Team Members:** Display all registered team members.
 *     *   **5. Assign Next Pending Task:** Take the next task ID from the front of the pending queue. Prompt for a Team Member ID. If the member ID is valid and the queue was not empty, update the task's status to `ASSIGNED` and set its `assignedToMemberId`. Report errors if the queue is empty or the member ID is invalid.
 *     *   **6. Mark Task as Completed:** Prompt for a Task ID. Find the task. If found and its status is `ASSIGNED`, update the status to `COMPLETED` and clear the `assignedToMemberId`. Report errors if the task is not found, is pending, or is already completed.
 *     *   **7. List All Tasks:** Display all tasks in the system, including their status and assignee (if assigned).
 *     *   **8. Exit:** Terminate the application.
 * 
 * 4.  **Input Handling:**
 *     *   Use `java.util.Scanner` to read user input (menu choice, task description, member name, IDs).
 *     *   Validate user input where necessary (e.g., ensuring integer input is provided when expected, checking if IDs exist).
 * 
 * 5.  **Error Handling:**
 *     *   Use `System.err.println()` to display error messages (e.g., "Queue is empty", "Member not found", "Invalid input").
 *     *   Use `System.out.println()` for all normal output (menu, prompts, lists, success messages).
 *     *   Implement class-wide exception handling using `try-catch` blocks. At a minimum, handle `InputMismatchException` when reading integers from the scanner in the main loop and potentially other runtime exceptions that could occur during operations. Place a `try-catch` block around the main loop's operation execution or input reading to catch common runtime errors.
 * 
 * 6.  **Best Practices:**
 *     *   Adhere to proper encapsulation (private fields, public/package-private methods).
 *     *   Use meaningful variable and method names.
 *     *   Include appropriate comments and documentation (e.g., Javadoc for classes/methods).
 *     *   Structure the code logically into classes and methods.
 * 
 * **Expected Output:**
 * 
 * The program should present a menu, accept user input, perform the requested operations, and display results or error messages accordingly. Example interactions might include:
 * - Adding tasks and members.
 * - Listing pending tasks (showing tasks added).
 * - Assigning a task (dequeueing from pending, updating status).
 * - Listing all tasks (showing pending and assigned tasks).
 * - Attempting to assign when the queue is empty (error to `System.err`).
 * - Attempting to assign to a non-existent member (error to `System.err`).
 * - Marking an assigned task complete.
 * - Listing all tasks again (showing completed task).
 * - Handling non-integer input for menu choice (`InputMismatchException` caught, error to `System.err`).
 * 
 * **Note:** Focus on demonstrating the correct usage and integration of all required Java components and best practices within the given scenario.
 *
 * EXPLANATION:
 * This solution implements a simple console-based Task Management System, demonstrating the required Java concepts and best practices.
 * 
 * 1.  **Required Components Usage:**
 *     *   `Queue (java.util.Queue)`: The `pendingTaskIds` field is declared as a `Queue<Integer>` and instantiated with `LinkedList`. It is used to store task IDs in a FIFO manner, ensuring tasks are assigned in the order they become pending (`offer` to add, `poll` to remove from the front, iteration for listing).
 *     *   `ArrayList (java.util.ArrayList)`: `allTasks` and `teamMembers` are instantiated as `ArrayList`, providing dynamic arrays to store `Task` and `TeamMember` objects respectively.
 *     *   `List interface (java.util.List)`: `allTasks` and `teamMembers` are declared using the `List` interface type, promoting good practice by programming to interfaces rather than concrete implementations.
 *     *   `Scanner (java.util.Scanner)`: A `Scanner` object is created in the `run` method and passed to methods like `addTask`, `addTeamMember`, `assignNextTask`, and `completeTask` to read various types of user input (integers, strings).
 *     *   `Switch statement`: A `switch` statement in the `run` method is used to control the application flow based on the user's menu choice.
 *     *   `System.err`: Used extensively throughout the `TaskManager` class to print error messages when invalid operations are attempted (e.g., assigning from an empty queue, completing a non-assigned task, invalid IDs, invalid input format caught by `try-catch`).
 *     *   `System.out`: Used for printing the menu, prompts for input, success messages after operations, and listing the tasks and team members.
 *     *   `Class-wide exception handling with try-catch`: The main `run` method contains a `try-catch` block wrapping the input reading (`scanner.nextInt()`) and the subsequent `switch` statement logic. This block catches potential `InputMismatchException` if the user enters non-numeric input for the menu choice, preventing the program from crashing and allowing it to recover by prompting the user again. It also includes a general `catch (Exception e)` to handle any other unexpected runtime errors that might occur during the execution of the chosen action. Additionally, specific methods like `assignNextTask` and `completeTask` have their own `try-catch` blocks to handle `InputMismatchException` when reading *their specific* integer inputs (member ID, task ID), providing more localized input validation.
 * 
 * 2.  **Creativity and Practicality:** The Task Management System is a practical, simplified model of real-world task assignment scenarios, making the problem relatable while effectively using the required data structures.
 * 
 * 3.  **Best Practices:**
 *     *   **Encapsulation:** Fields in `Task` and `TeamMember` classes are `private`. Access is provided via public getters. Setters in `Task` are package-private, allowing `TaskManager` (in the same package) to control state changes while preventing arbitrary external modification.
 *     *   **Meaningful Names:** Classes (`Task`, `TeamMember`, `TaskManager`), fields (`pendingTaskIds`, `allTasks`, `description`, `assignedToMemberId`), methods (`addTask`, `listPendingTasks`, `findTaskById`, `assignNextTask`), and the `TaskStatus` enum have descriptive names.
 *     *   **Comments and Documentation:** Javadoc-style comments are included for classes and methods explaining their purpose, parameters, and return values. Inline comments clarify specific logic points.
 *     *   **Input Validation:** Checks are performed for empty strings (task description, member name). `try-catch` blocks validate integer input format. Helper methods (`findTaskById`, `findMemberById`) validate the existence of IDs entered by the user before performing operations.
 *     *   **Error Handling:** Error conditions (empty queue/list, item not found, incorrect task status for an operation) are explicitly checked, and descriptive messages are printed to `System.err`. Exceptions are caught using `try-catch` for input format errors and potential runtime issues.
 *     *   **Clean Code Structure:** The problem is broken down into logical classes (`Task`, `TeamMember`, `TaskManager`). The `TaskManager` class separates concerns into dedicated methods for each menu operation and helper functions (`findTaskById`, `findMemberById`, `printMenu`). The `run` method orchestrates the main loop and interaction.
 * 
 * This solution effectively integrates the specified Java components into a functional and well-structured application, demonstrating an advanced understanding of Java programming concepts including collections, object-oriented design, user input handling, and robust error management.
 */

import java.util.*;
import java.util.concurrent.ConcurrentLinkedQueue; // Or use LinkedList

// Enum to represent the status of a task
enum TaskStatus {
    PENDING, ASSIGNED, COMPLETED
}

/**
 * Represents a single task in the task management system.
 */
class Task {
    private int taskId;
    private String description;
    private TaskStatus status;
    private int assignedToMemberId; // 0 if not assigned

    /**
     * Constructs a new Task.
     * Tasks are initially in PENDING status.
     * @param taskId The unique identifier for the task.
     * @param description A brief description of the task.
     */
    public Task(int taskId, String description) {
        this.taskId = taskId;
        this.description = description;
        this.status = TaskStatus.PENDING;
        this.assignedToMemberId = 0; // Default to 0 (not assigned)
    }

    // --- Getters ---
    public int getTaskId() {
        return taskId;
    }

    public String getDescription() {
        return description;
    }

    public TaskStatus getStatus() {
        return status;
    }

    public int getAssignedToMemberId() {
        return assignedToMemberId;
    }

    // --- Setters (Used by TaskManager to update state) ---
    // Using package-private visibility as TaskManager is expected to be in the same package
    void setStatus(TaskStatus status) {
        this.status = status;
    }

    void setAssignedToMemberId(int assignedToMemberId) {
        this.assignedToMemberId = assignedToMemberId;
    }

    /**
     * Provides a string representation of the Task, including its status and assignee if applicable.
     * @return String representation of the task.
     */
    @Override
    public String toString() {
        String statusString = status.toString();
        if (status == TaskStatus.ASSIGNED) {
            statusString += " (to Member ID: " + assignedToMemberId + ")";
        }
        return "Task ID: " + taskId + ", Description: '" + description + "', Status: " + statusString;
    }
}

/**
 * Represents a team member who can be assigned tasks.
 */
class TeamMember {
    private int memberId;
    private String name;

    /**
     * Constructs a new TeamMember.
     * @param memberId The unique identifier for the team member.
     * @param name The name of the team member.
     */
    public TeamMember(int memberId, String name) {
        this.memberId = memberId;
        this.name = name;
    }

    // --- Getters ---
    public int getMemberId() {
        return memberId;
    }

    public String getName() {
        return name;
    }

    /**
     * Provides a string representation of the TeamMember.
     * @return String representation of the team member.
     */
    @Override
    public String toString() {
        return "Member ID: " + memberId + ", Name: '" + name + "'";
    }
}

/**
 * Manages tasks and team members, handling operations like adding, assigning, and completing tasks.
 * Uses a Queue for pending tasks and Lists for all tasks and members.
 */
public class TaskManager {
    // Queue to hold IDs of tasks that are pending assignment (FIFO)
    private Queue<Integer> pendingTaskIds;
    // List to hold all tasks created in the system
    private List<Task> allTasks;
    // List to hold all registered team members
    private List<TeamMember> teamMembers;

    private int nextTaskId;
    private int nextMemberId;

    /**
     * Constructs a new TaskManager and initializes collections and counters.
     */
    public TaskManager() {
        // Use LinkedList as a Queue implementation
        this.pendingTaskIds = new LinkedList<>();
        // Use ArrayList as a List implementation
        this.allTasks = new ArrayList<>();
        this.teamMembers = new ArrayList<>();

        this.nextTaskId = 1; // Start task IDs from 1
        this.nextMemberId = 1; // Start member IDs from 1
    }

    // --- Helper Methods ---

    /**
     * Finds a Task by its ID from the list of all tasks.
     * @param taskId The ID of the task to find.
     * @return The Task object if found, otherwise null.
     */
    private Task findTaskById(int taskId) {
        for (Task task : allTasks) {
            if (task.getTaskId() == taskId) {
                return task;
            }
        }
        return null; // Task not found
    }

    /**
     * Finds a TeamMember by their ID from the list of team members.
     * @param memberId The ID of the team member to find.
     * @return The TeamMember object if found, otherwise null.
     */
    private TeamMember findMemberById(int memberId) {
        for (TeamMember member : teamMembers) {
            if (member.getMemberId() == memberId) {
                return member;
            }
        }
        return null; // Member not found
    }

    /**
     * Prints the main menu options to the console.
     */
    private void printMenu() {
        System.out.println("--- Team Task Management System Menu ---");
        System.out.println("1. Add New Task");
        System.out.println("2. List Pending Tasks");
        System.out.println("3. Add Team Member");
        System.out.println("4. List Team Members");
        System.out.println("5. Assign Next Pending Task");
        System.out.println("6. Mark Task as Completed");
        System.out.println("7. List All Tasks");
        System.out.println("8. Exit");
        System.out.println("----------------------------------------");
    }

    // --- Public Methods for Menu Actions ---

    /**
     * Prompts the user for task details and adds a new task to the system.
     * The new task is added to the list of all tasks and its ID is added to the pending queue.
     * @param scanner The Scanner object to read user input.
     */
    public void addTask(Scanner scanner) {
        System.out.print("Enter task description: ");
        String description = scanner.nextLine();

        if (description == null || description.trim().isEmpty()) {
            System.err.println("Error: Task description cannot be empty.");
            return;
        }

        Task newTask = new Task(nextTaskId, description.trim());
        allTasks.add(newTask); // Add to the list of all tasks
        pendingTaskIds.offer(nextTaskId); // Add task ID to the end of the pending queue (FIFO)

        System.out.println("Task added successfully: " + newTask);
        nextTaskId++; // Increment for the next task
    }

    /**
     * Lists all tasks currently in the pending queue.
     * Iterates through the queue without removing elements (using a for-each loop).
     */
    public void listPendingTasks() {
        if (pendingTaskIds.isEmpty()) {
            System.out.println("No tasks are currently pending.");
            return;
        }

        System.out.println("--- Pending Tasks ---");
        // Iterate through the queue's elements. The queue contains task IDs.
        for (Integer taskId : pendingTaskIds) {
            Task task = findTaskById(taskId); // Find the actual task object by ID
            if (task != null) { // This check should ideally always pass if logic is sound
                 System.out.println(task); // Task.toString() includes status
            }
        }
        System.out.println("---------------------");
    }

    /**
     * Prompts the user for member details and adds a new team member to the system.
     * @param scanner The Scanner object to read user input.
     */
    public void addTeamMember(Scanner scanner) {
        System.out.print("Enter team member name: ");
        String name = scanner.nextLine();

        if (name == null || name.trim().isEmpty()) {
            System.err.println("Error: Member name cannot be empty.");
            return;
        }

        TeamMember newMember = new TeamMember(nextMemberId, name.trim());
        teamMembers.add(newMember); // Add to the list of team members

        System.out.println("Team member added successfully: " + newMember);
        nextMemberId++; // Increment for the next member
    }

    /**
     * Lists all registered team members.
     */
    public void listTeamMembers() {
        if (teamMembers.isEmpty()) {
            System.out.println("No team members are registered.");
            return;
        }

        System.out.println("--- Team Members ---");
        for (TeamMember member : teamMembers) {
            System.out.println(member);
        }
        System.out.println("--------------------");
    }

    /**
     * Assigns the next task from the pending queue to a specified team member.
     * Dequeues the task ID from the pending queue.
     * @param scanner The Scanner object to read user input (member ID).
     */
    public void assignNextTask(Scanner scanner) {
        if (pendingTaskIds.isEmpty()) {
            System.err.println("Error: No tasks are pending for assignment.");
            return;
        }
         if (teamMembers.isEmpty()) {
             System.err.println("Error: No team members available for assignment.");
             return;
        }

        // Peek to get the next task ID without removing it yet
        Integer nextTaskIdToAssign = pendingTaskIds.peek();
        Task taskToAssign = findTaskById(nextTaskIdToAssign);

        if (taskToAssign == null) {
             // This indicates an internal logic error if a task ID in the queue isn't in allTasks
             System.err.println("Internal Error: Pending task ID " + nextTaskIdToAssign + " not found in task list.");
             pendingTaskIds.poll(); // Remove potentially bad ID from queue
             return;
        }

        System.out.print("Enter Member ID to assign Task " + nextTaskIdToAssign + " ('" + taskToAssign.getDescription() + "') to: ");
        int memberId;
        try {
            memberId = scanner.nextInt();
            scanner.nextLine(); // Consume the rest of the line after reading int
        } catch (InputMismatchException e) {
            System.err.println("Error: Invalid Member ID format. Please enter a number.");
            scanner.nextLine(); // Consume invalid input to prevent infinite loop
            return; // Exit the method without assigning
        }

        TeamMember assignee = findMemberById(memberId);

        if (assignee == null) {
            System.err.println("Error: Team Member with ID " + memberId + " not found.");
            // Do NOT poll the task ID from the queue if assignment fails due to invalid member
            return;
        }

        // If member found, proceed with assignment
        pendingTaskIds.poll(); // Remove the task ID from the front of the queue
        taskToAssign.setStatus(TaskStatus.ASSIGNED);
        taskToAssign.setAssignedToMemberId(memberId);

        System.out.println("Success: Task ID " + taskToAssign.getTaskId() + " assigned to " + assignee.getName() + " (Member ID: " + assignee.getMemberId() + ").");
    }

    /**
     * Marks an assigned task as completed.
     * Prompts the user for the Task ID to complete.
     * @param scanner The Scanner object to read user input (task ID).
     */
    public void completeTask(Scanner scanner) {
        System.out.print("Enter Task ID to mark as completed: ");
        int taskId;
        try {
            taskId = scanner.nextInt();
            scanner.nextLine(); // Consume the rest of the line after reading int
        } catch (InputMismatchException e) {
            System.err.println("Error: Invalid Task ID format. Please enter a number.");
            scanner.nextLine(); // Consume invalid input to prevent infinite loop
            return; // Exit the method without completing
        }

        Task task = findTaskById(taskId);

        if (task == null) {
            System.err.println("Error: Task with ID " + taskId + " not found.");
            return;
        }

        // Validate task status for completion
        if (task.getStatus() == TaskStatus.PENDING) {
             System.err.println("Error: Task ID " + taskId + " is pending and cannot be completed directly. It must be assigned first.");
             return;
        } else if (task.getStatus() == TaskStatus.COMPLETED) {
             System.err.println("Error: Task ID " + taskId + " is already completed.");
             return;
        }

        // If status is ASSIGNED, proceed to complete
        task.setStatus(TaskStatus.COMPLETED);
        task.setAssignedToMemberId(0); // Reset assigned member ID

        System.out.println("Success: Task ID " + taskId + " marked as completed.");
    }

    /**
     * Lists all tasks in the system, regardless of their status.
     */
    public void listAllTasks() {
        if (allTasks.isEmpty()) {
            System.out.println("No tasks have been created yet.");
            return;
        }

        System.out.println("--- All Tasks ---");
        for (Task task : allTasks) {
            System.out.println(task); // Task.toString() handles status and assignee
        }
        System.out.println("-----------------");
    }

    /**
     * Runs the main application loop, handling user input and menu selection.
     * Includes a try-catch block to handle potential exceptions during input reading
     * or method execution within the main loop.
     */
    public void run() {
        Scanner scanner = new Scanner(System.in);
        int choice = -1;

        // Main application loop
        while (choice != 8) {
            printMenu();
            System.out.print("Enter your choice: ");

            // Class-wide exception handling demonstration:
            // This try-catch block wraps the core logic within the loop,
            // catching potential exceptions that might occur during input reading
            // or the execution of the chosen menu option's method call.
            // This provides a robust layer of error handling for the main application flow.
            try {
                choice = scanner.nextInt();
                scanner.nextLine(); // Consume the newline character left by nextInt()

                switch (choice) {
                    case 1:
                        addTask(scanner);
                        break;
                    case 2:
                        listPendingTasks();
                        break;
                    case 3:
                        addTeamMember(scanner);
                        break;
                    case 4:
                        listTeamMembers();
                        break;
                    case 5:
                        assignNextTask(scanner);
                        break;
                    case 6:
                        completeTask(scanner);
                        break;
                    case 7:
                        listAllTasks();
                        break;
                    case 8:
                        System.out.println("Exiting Team Task Management System. Goodbye!");
                        break;
                    default:
                        System.err.println("Error: Invalid choice. Please enter a number between 1 and 8.");
                }
            } catch (InputMismatchException e) {
                // Handle cases where the user enters non-integer input for the menu choice
                System.err.println("Error: Invalid input. Please enter a number corresponding to the menu option.");
                scanner.nextLine(); // Consume the invalid input to prevent an infinite loop
                choice = -1; // Reset choice to re-display the menu
            } catch (NoSuchElementException e) {
                 // Handle potential issues if the input source is closed unexpectedly
                 System.err.println("Error: Input source exhausted. Exiting.");
                 choice = 8; // Force exit
            } catch (IllegalStateException e) {
                 // Handle potential issues if the scanner is used after being closed
                 System.err.println("Error: Scanner is closed. Exiting.");
                 choice = 8; // Force exit
            } catch (Exception e) {
                // Catch any other unexpected runtime exceptions that might occur
                System.err.println("An unexpected error occurred: " + e.getMessage());
                // e.printStackTrace(); // Uncomment for detailed debugging stack trace if needed
            }

            System.out.println(); // Print a blank line for better readability between menu interactions
        }

        scanner.close(); // Close the scanner when the application exits
    }

    /**
     * The main method to start the Task Management System application.
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        TaskManager manager = new TaskManager();
        manager.run(); // Start the main application loop
    }
}
