/*
 * Exam Question #715
 * Generated on: 2025-05-12 16:29:40
 * Generated by: Account 5
 * 
 * QUESTION:
 * ## Advanced Java Programming Exam Task: Package Processing Simulation
 * 
 * **Scenario:**
 * 
 * You are tasked with building a simplified simulation system for a package processing center. Packages arrive and are placed in an incoming queue. A processing unit takes packages from the queue one by one, updates their status, and moves them to a list of processed packages ready for shipment.
 * 
 * **Task:**
 * 
 * Design and implement a Java program that simulates this process. Your program should provide a command-line interface for interacting with the system.
 * 
 * **Requirements:**
 * 
 * 1.  **Package Representation:** Create a `Package` class with the following private attributes:
 *     *   `packageId` (String)
 *     *   `destination` (String)
 *     *   `status` (String - e.g., "PENDING", "SHIPPED")
 *     Include a constructor that initializes these attributes (setting status to "PENDING"), public getter methods for all attributes, a method to update the status (e.g., `setStatus(String status)`), and a `toString()` method that provides a user-friendly representation of a package.
 * 
 * 2.  **Processing System:** Create a `PackageProcessor` class that manages the package flow. This class should have:
 *     *   A private `Queue<Package>` to store incoming packages awaiting processing.
 *     *   A private `List<Package>` (implemented using `ArrayList`) to store processed packages.
 *     *   A private `Scanner` for handling user input within the processing loop.
 * 
 * 3.  **Functionality:** Implement the following operations within the `PackageProcessor` class:
 *     *   `addPackage()`: Prompts the user for package ID and destination, creates a `Package` object with status "PENDING", and adds it to the incoming queue. Implement input validation to ensure ID and destination are not empty strings.
 *     *   `processNextPackage()`: Retrieves the next package from the incoming queue (using `poll()`), updates its status to "SHIPPED", and adds it to the processed packages list. If the queue is empty, print an appropriate error message using `System.err`.
 *     *   `viewPendingPackages()`: Displays all packages currently in the incoming queue. If the queue is empty, print a message indicating that to `System.out`.
 *     *   `viewProcessedPackages()`: Displays all packages in the processed packages list. If the list is empty, print a message indicating that to `System.out`.
 *     *   `runSystem()`: Implements the main application loop. It should repeatedly:
 *         *   Display a menu of options (Add Package, Process Next, View Pending, View Processed, Exit).
 *         *   Read the user's choice using the `Scanner`.
 *         *   Use a `switch` statement to handle user choices, calling the appropriate methods.
 *         *   Include a case for invalid menu options.
 * 
 * 4.  **Required Java Components:** Your solution *must* utilize all of the following Java components:
 *     *   `java.util.Queue`
 *     *   `java.util.ArrayList`
 *     *   `java.util.List` interface
 *     *   `java.util.Scanner` for user input
 *     *   `switch` statement for menu handling
 *     *   `System.err` for printing error messages (e.g., invalid input, queue empty during processing)
 *     *   `System.out` for printing menu, prompts, status messages, and package lists
 *     *   Class-wide exception handling using `try-catch` blocks within `runSystem()` and potentially other methods to manage potential runtime issues like invalid input format (`InputMismatchException`) or unexpected errors during operations.
 * 
 * 5.  **Best Practices:**
 *     *   Apply proper encapsulation (`private` fields, `public` methods).
 *     *   Use meaningful variable and method names.
 *     *   Include appropriate comments and Javadoc where necessary (basic comments are sufficient for an exam setting).
 *     *   Implement input validation (e.g., non-empty strings for ID/destination, handling non-integer menu input).
 *     *   Handle errors gracefully using `try-catch` and informative messages via `System.err`.
 *     *   Ensure a clean and organized code structure.
 *     *   Close the `Scanner` resource properly when the program exits.
 * 
 * **Expected Output:**
 * 
 * The program should present a menu and interact with the user via the console. Normal informational messages and lists should go to `System.out`, while error conditions should be reported to `System.err`.
 * 
 * Example interaction flow (simplified):
 * 
 * ```
 * --- Welcome to the Package Processing System ---
 * --- Package Processing System Menu ---
 * 1. Add New Package
 * ... (menu options)
 * Enter your choice: 1
 * --- Add New Package ---
 * Enter Package ID: PKG123
 * Enter Destination: City A
 * Package PKG123 added to queue.
 * 
 * --- Package Processing System Menu ---
 * ... (menu options)
 * Enter your choice: 2
 * --- Process Next Package ---
 * Processing package PKG123...
 * Package PKG123 status updated to SHIPPED and moved to processed list.
 * 
 * --- Package Processing System Menu ---
 * ... (menu options)
 * Enter your choice: 2
 * --- Process Next Package ---
 * No packages in the incoming queue to process. (This line should go to System.err)
 * 
 * --- Package Processing System Menu ---
 * ... (menu options)
 * Enter your choice: 4
 * --- Processed Packages ---
 * Package ID: PKG123, Destination: City A, Status: SHIPPED
 * --- End of Processed Packages ---
 * 
 * --- Package Processing System Menu ---
 * ... (menu options)
 * Enter your choice: invalid_input
 * Invalid input. Please enter a number. (This line should go to System.err)
 * 
 * --- Package Processing System Menu ---
 * ... (menu options)
 * Enter your choice: 5
 * Exiting Package Processing System. Goodbye!
 * ```
 * 
 * Your solution should compile and run, demonstrating the correct usage of all required components and adherence to best practices.
 *
 * EXPLANATION:
 * The solution is structured into two main classes: `Package` and `PackageProcessor`, demonstrating a basic model-controller separation.
 * 
 * 1.  **`Package` Class:**
 *     *   This class serves as a simple data structure representing a package.
 *     *   It uses `private` fields (`packageId`, `destination`, `status`) to enforce encapsulation, ensuring that the internal state of a `Package` object can only be modified through its methods.
 *     *   The constructor initializes the package with mandatory details (ID and destination) and sets the initial status to "PENDING". It includes basic input validation within the constructor itself, throwing an `IllegalArgumentException` if ID or destination are provided as null or empty strings. This promotes creating valid `Package` objects from the start.
 *     *   Public getter methods (`getPackageId`, `getDestination`, `getStatus`) provide read-only access to the package's attributes.
 *     *   A public `setStatus(String status)` method allows controlled modification of the package's status, used specifically to mark a package as "SHIPPED".
 *     *   The `toString()` method is overridden to provide a convenient and user-friendly string representation of a `Package` object, making it easy to print package details.
 * 
 * 2.  **`PackageProcessor` Class:**
 *     *   This class contains the core logic for managing the package processing workflow.
 *     *   It utilizes a `private Queue<Package>` named `incomingQueue`, implemented using `java.util.LinkedList`. The `Queue` interface guarantees a First-In, First-Out (FIFO) order, which is essential for processing packages in the order they arrive. Packages are added to the tail (`add()`) and removed from the head (`poll()`).
 *     *   It uses a `private List<Package>` named `processedPackages`, implemented using `java.util.ArrayList`. The `List` interface provides a flexible collection to store packages once they have been processed. `ArrayList` was chosen as a concrete implementation as required.
 *     *   A `private Scanner` object (`java.util.Scanner`) is used to read user input from the console (`System.in`).
 *     *   The `runSystem()` method implements the main application loop. It repeatedly displays a menu to the user via `System.out` and reads their choice using the `Scanner`.
 *     *   A `switch` statement is used within `runSystem()` to handle the user's input, directing the program flow to the appropriate processing method (`addPackage`, `processNextPackage`, `viewPendingPackages`, `viewProcessedPackages`) or exiting the system.
 *     *   **`addPackage()`:** This method prompts the user for the necessary details, performs input validation to ensure ID and destination are not empty. It then attempts to create a `Package` object and adds it to the `incomingQueue`. A `try-catch` block is used to handle potential `IllegalArgumentException` thrown by the `Package` constructor during validation, and also catches general `Exception` for unexpected issues during input. Error messages are printed to `System.err`.
 *     *   **`processNextPackage()`:** This method first checks if the `incomingQueue` is empty. If it is, an error message is printed to `System.err`, and the method returns. If the queue is not empty, it uses `incomingQueue.poll()` to retrieve and remove the next package. The package's status is updated to "SHIPPED", and it's added to the `processedPackages` list. A `try-catch` block is included to handle potential unexpected errors during the processing steps.
 *     *   **`viewPendingPackages()`:** This method iterates through the `incomingQueue` using an enhanced for loop (which traverses the elements without removing them) and prints the details of each package using `System.out`. It includes a check to print a message if the queue is empty.
 *     *   **`viewProcessedPackages()`:** This method iterates through the `processedPackages` list and prints the details of each processed package using `System.out`. It also includes a check for an empty list.
 *     *   **Exception Handling (`try-catch`):**
 *         *   The `runSystem()` method contains a `try-catch` block that specifically handles `InputMismatchException`. This occurs if the user enters non-integer text when prompted for a menu choice. Catching this prevents the program from crashing and allows for graceful error reporting via `System.err`. Crucially, `scanner.nextLine()` is called within the catch block to consume the invalid input line, preventing an infinite loop.
 *         *   A general `catch (Exception e)` is also present in `runSystem()` as a fallback for any other unexpected runtime errors during the main loop execution.
 *         *   Specific `try-catch` blocks are also used in `addPackage()` and `processNextPackage()` to handle exceptions more localized to those operations (e.g., validation errors, issues during list/queue operations).
 *         *   All error messages are directed to `System.err`, while normal output (menu, prompts, lists, success messages) goes to `System.out`, adhering to standard practice.
 *     *   **Resource Management:** The `Scanner` resource is explicitly closed using `scanner.close()` when the `runSystem()` method finishes (i.e., when the user chooses to exit), releasing the underlying system resource.
 *     *   The `main` method simply creates an instance of `PackageProcessor` and calls `runSystem()` to start the application.
 * 
 * This solution effectively integrates all the required Java components (`Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.err`, `System.out`, `try-catch`) into a cohesive, practical simulation. It demonstrates best practices such as encapsulation, input validation, and robust error handling, making it a challenging yet solvable task for evaluating advanced Java understanding.
 */

import java.util.Queue;
import java.util.LinkedList; // Common Queue implementation
import java.util.List;
import java.util.ArrayList;
import java.util.Scanner;
import java.util.InputMismatchException; // Specific exception for Scanner

// Represents a package in the system
class Package {
    private String packageId;
    private String destination;
    private String status; // e.g., "PENDING", "SHIPPED"

    /**
     * Constructs a new Package with initial status PENDING.
     * @param packageId The unique identifier for the package.
     * @param destination The destination address for the package.
     * @throws IllegalArgumentException if packageId or destination are null or empty.
     */
    public Package(String packageId, String destination) {
        // Input validation in constructor
        if (packageId == null || packageId.trim().isEmpty()) {
            throw new IllegalArgumentException("Package ID cannot be empty.");
        }
        if (destination == null || destination.trim().isEmpty()) {
            throw new IllegalArgumentException("Destination cannot be empty.");
        }
        this.packageId = packageId.trim();
        this.destination = destination.trim();
        this.status = "PENDING"; // Initial status
    }

    // --- Getters ---
    public String getPackageId() {
        return packageId;
    }

    public String getDestination() {
        return destination;
    }

    public String getStatus() {
        return status;
    }

    // --- Setter for Status ---
    public void setStatus(String status) {
        this.status = status;
    }

    /**
     * Provides a user-friendly string representation of the Package.
     */
    @Override
    public String toString() {
        return "Package ID: " + packageId + ", Destination: " + destination + ", Status: " + status;
    }
}

// Manages the package processing flow
public class PackageProcessor {
    private Queue<Package> incomingQueue;
    private List<Package> processedPackages;
    private Scanner scanner;

    /**
     * Constructs a new PackageProcessor system.
     */
    public PackageProcessor() {
        // Initialize the queue using LinkedList (implements Queue)
        this.incomingQueue = new LinkedList<>();
        // Initialize the list using ArrayList (implements List)
        this.processedPackages = new ArrayList<>();
        // Initialize the scanner for user input
        this.scanner = new Scanner(System.in);
    }

    /**
     * Prompts user for package details and adds a new package to the incoming queue.
     * Handles input validation and potential exceptions.
     */
    public void addPackage() {
        System.out.println("\n--- Add New Package ---");
        try {
            System.out.print("Enter Package ID: ");
            String id = scanner.nextLine(); // Read entire line

            System.out.print("Enter Destination: ");
            String destination = scanner.nextLine(); // Read entire line

            // Input validation before creating Package object
            if (id.trim().isEmpty() || destination.trim().isEmpty()) {
                System.err.println("Error: Package ID and Destination cannot be empty.");
                return; // Exit method if validation fails
            }

            // Create package - constructor validation might throw IllegalArgumentException
            Package newPackage = new Package(id, destination);
            incomingQueue.add(newPackage); // Add to the end of the queue
            System.out.println("Package " + newPackage.getPackageId() + " added to queue.");

        } catch (IllegalArgumentException e) {
            // Catch validation errors thrown by the Package constructor
            System.err.println("Error creating package: " + e.getMessage());
        } catch (Exception e) {
            // Catch any other unexpected errors during input reading or package creation
            System.err.println("An unexpected error occurred while adding package: " + e.getMessage());
            // In a real application, e.printStackTrace() might be useful for debugging
        }
    }

    /**
     * Processes the next package from the incoming queue, updates its status,
     * and moves it to the processed packages list. Handles empty queue case.
     */
    public void processNextPackage() {
        System.out.println("\n--- Process Next Package ---");
        // Check if the queue is empty before attempting to poll
        if (incomingQueue.isEmpty()) {
            System.err.println("No packages in the incoming queue to process.");
            return; // Exit method if queue is empty
        }

        try {
            // Retrieve and remove the head of the queue
            Package packageToProcess = incomingQueue.poll();

            // poll() returns null if queue is empty, but we checked isEmpty() above.
            // This check adds robustness.
            if (packageToProcess != null) {
                System.out.println("Processing package " + packageToProcess.getPackageId() + "...");
                packageToProcess.setStatus("SHIPPED"); // Update status
                processedPackages.add(packageToProcess); // Add to the processed list
                System.out.println("Package " + packageToProcess.getPackageId() + " status updated to SHIPPED and moved to processed list.");
            } else {
                 // This case should ideally not be reached due to the isEmpty() check
                 System.err.println("Failed to retrieve package from queue (unexpected null).");
            }
        } catch (Exception e) {
            // Catch any unexpected errors during the processing logic
            System.err.println("An unexpected error occurred while processing package: " + e.getMessage());
        }
    }

    /**
     * Displays all packages currently in the incoming queue.
     */
    public void viewPendingPackages() {
        System.out.println("\n--- Pending Packages ---");
        // Check if the queue is empty
        if (incomingQueue.isEmpty()) {
            System.out.println("No packages currently in the incoming queue.");
        } else {
            // Iterate through the queue elements (order matters for display)
            for (Package pkg : incomingQueue) {
                System.out.println(pkg); // Uses Package.toString()
            }
        }
        System.out.println("--- End of Pending Packages ---");
    }

    /**
     * Displays all packages in the processed packages list.
     */
    public void viewProcessedPackages() {
        System.out.println("\n--- Processed Packages ---");
        // Check if the list is empty
        if (processedPackages.isEmpty()) {
            System.out.println("No packages have been processed yet.");
        } else {
            // Iterate through the list elements
            for (Package pkg : processedPackages) {
                System.out.println(pkg); // Uses Package.toString()
            }
        }
        System.out.println("--- End of Processed Packages ---");
    }

    /**
     * Displays the main menu options to the user.
     */
    private void displayMenu() {
        System.out.println("\n--- Package Processing System Menu ---");
        System.out.println("1. Add New Package");
        System.out.println("2. Process Next Package");
        System.out.println("3. View Pending Packages");
        System.out.println("4. View Processed Packages");
        System.out.println("5. Exit");
    }

    /**
     * Runs the main package processing system loop.
     * Handles user interaction and calls appropriate methods based on choice.
     * Includes main exception handling for the loop.
     */
    public void runSystem() {
        int choice = -1; // Initialize choice to a value that won't exit the loop immediately
        System.out.println("--- Welcome to the Package Processing System ---");

        // Main application loop continues until user chooses to exit (option 5)
        while (choice != 5) {
            displayMenu(); // Show menu
            try {
                System.out.print("Enter your choice: ");
                choice = scanner.nextInt(); // Read integer input for choice
                scanner.nextLine(); // Consume the newline character left by nextInt()

                // Use a switch statement to handle different menu options
                switch (choice) {
                    case 1:
                        addPackage(); // Call method to add a package
                        break;
                    case 2:
                        processNextPackage(); // Call method to process next package
                        break;
                    case 3:
                        viewPendingPackages(); // Call method to view pending packages
                        break;
                    case 4:
                        viewProcessedPackages(); // Call method to view processed packages
                        break;
                    case 5:
                        System.out.println("Exiting Package Processing System. Goodbye!");
                        break; // Exit the switch and the loop condition will be met
                    default:
                        // Handle invalid integer choices
                        System.err.println("Invalid choice. Please enter a number between 1 and 5.");
                }
            } catch (InputMismatchException e) {
                // Catch exception if user enters non-integer input for the menu choice
                System.err.println("Invalid input. Please enter a number.");
                scanner.nextLine(); // Consume the invalid input line to prevent infinite loop
                choice = -1; // Reset choice to ensure the loop continues and re-prompts
            } catch (Exception e) {
                // Catch any other unexpected exceptions that might occur within the loop
                System.err.println("An unexpected error occurred: " + e.getMessage());
                // e.printStackTrace(); // Useful for debugging unexpected issues
            }
            System.out.println(); // Add a blank line for better readability between interactions
        }

        // Close the scanner resource when the program exits
        scanner.close();
    }

    /**
     * Main method to start the application.
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        // Create an instance of the PackageProcessor and run the system
        PackageProcessor system = new PackageProcessor();
        system.runSystem();
    }
}
