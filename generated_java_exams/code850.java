/*
 * Exam Question #850
 * Generated on: 2025-05-12 16:50:27
 * Generated by: Account 3
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Project Task Prioritization and Execution System
 * 
 * **Objective:** Design and implement a command-line application in Java that simulates a simple task management system for a project. The system should allow users to add new tasks, view existing tasks, prioritize a task by moving it to an execution queue, and execute the next task from the queue.
 * 
 * **Requirements:**
 * 
 * 1.  **Task Representation:** Create a class `Task` with the following properties:
 *     *   `int id`: A unique identifier for the task (auto-generated).
 *     *   `String description`: A brief description of the task.
 *     *   `String priority`: The priority level ("High", "Medium", "Low").
 *     *   `String status`: The current status ("Pending", "Queued", "Completed").
 *     *   Include a constructor, getters, and a `toString()` method.
 * 
 * 2.  **Task Management:** Create a class `TaskManager` to manage the collection of tasks.
 *     *   It should hold all tasks in a `List`.
 *     *   It should hold tasks ready for execution in a `Queue`.
 *     *   Implement methods:
 *         *   `addTask(String description, String priority)`: Creates a new `Task` with a unique ID, adds it to the main list, sets status to "Pending", and returns the created task.
 *         *   `getAllTasks()`: Returns the `List` of all tasks.
 *         *   `queueTask(int taskId)`: Finds the task by ID. If found and its status is "Pending", change its status to "Queued" and add it to the execution `Queue`. If not found or status is not "Pending", print an error message to `System.err`.
 *         *   `executeNextTask()`: Removes the task at the front of the execution `Queue`. If the queue is not empty, change the task's status to "Completed" and print a success message to `System.out`. If the queue is empty, print an error message to `System.err`.
 *         *   `findTaskById(int taskId)`: A helper method to find a task in the main list by its ID.
 * 
 * 3.  **User Interface:** Create a main class (e.g., `ProjectManagerApp`) with a `main` method to interact with the user via the console.
 *     *   Use `java.util.Scanner` to read user input.
 *     *   Present a menu of options to the user:
 *         1.  Add New Task
 *         2.  View All Tasks
 *         3.  Queue Task for Execution
 *         4.  Execute Next Queued Task
 *         5.  Exit
 *     *   Use a `switch` statement to handle the user's menu selection.
 *     *   Use `System.out` for menu display, prompts, and successful operation messages.
 *     *   Use `System.err` for error messages (e.g., invalid input, task not found, queue empty).
 * 
 * 4.  **Error Handling and Validation:**
 *     *   Implement input validation for task priority (must be "High", "Medium", or "Low"). Print an error to `System.err` for invalid priority and do not add the task.
 *     *   Handle cases where a user enters non-integer input when an integer (like task ID or menu choice) is expected, using `try-catch` blocks.
 *     *   Handle cases where a task ID provided for queuing does not exist or the task is not in "Pending" status.
 *     *   Handle the case where the execution queue is empty when `executeNextTask` is called.
 *     *   Include a `try-catch` block in the `main` method that wraps the core application loop to catch any unexpected exceptions, printing an error message to `System.err`.
 * 
 * 5.  **Best Practices:**
 *     *   Use meaningful variable and method names.
 *     *   Apply proper encapsulation (private fields, public methods where necessary).
 *     *   Include appropriate comments and documentation (e.g., Javadoc).
 *     *   Ensure clean code structure.
 *     *   Use the `List` interface when declaring variables that hold `ArrayList` instances.
 *     *   Use the `Queue` interface when declaring variables that hold queue implementations (like `LinkedList`).
 * 
 * **Expected Output:**
 * 
 * The program should run continuously until the user chooses to exit. It should display a menu, prompt for input, and provide feedback on operations using `System.out` for success and `System.err` for errors.
 * 
 * Example interaction flow:
 * ```
 * --- Project Task Manager ---
 * 1. Add New Task
 * 2. View All Tasks
 * 3. Queue Task for Execution
 * 4. Execute Next Queued Task
 * 5. Exit
 * Enter your choice: 1
 * Enter task description: Implement login feature
 * Enter priority (High, Medium, Low): High
 * Task added: Task{id=1, description='Implement login feature', priority='High', status='Pending'}
 * 
 * --- Project Task Manager ---
 * ... (menu)
 * Enter your choice: 1
 * Enter task description: Design database schema
 * Enter priority (High, Medium, Low): Medium
 * Task added: Task{id=2, description='Design database schema', priority='Medium', status='Pending'}
 * 
 * --- Project Task Manager ---
 * ... (menu)
 * Enter your choice: 2
 * All Tasks:
 * Task{id=1, description='Implement login feature', priority='High', status='Pending'}
 * Task{id=2, description='Design database schema', priority='Medium', status='Pending'}
 * 
 * --- Project Task Manager ---
 * ... (menu)
 * Enter your choice: 3
 * Enter Task ID to queue: 1
 * Task 1 queued for execution.
 * 
 * --- Project Task Manager ---
 * ... (menu)
 * Enter your choice: 2
 * All Tasks:
 * Task{id=1, description='Implement login feature', priority='High', status='Queued'}
 * Task{id=2, description='Design database schema', priority='Medium', status='Pending'}
 * 
 * --- Project Task Manager ---
 * ... (menu)
 * Enter your choice: 4
 * Executing task: Task{id=1, description='Implement login feature', priority='High', status='Queued'}
 * Task 1 completed.
 * 
 * --- Project Task Manager ---
 * ... (menu)
 * Enter your choice: 2
 * All Tasks:
 * Task{id=1, description='Implement login feature', priority='High', status='Completed'}
 * Task{id=2, description='Design database schema', priority='Medium', status='Pending'}
 * 
 * --- Project Task Manager ---
 * ... (menu)
 * Enter your choice: 4
 * Error: No tasks in the execution queue.
 * ```
 *
 * EXPLANATION:
 * This solution implements the `ProjectManagerApp` as described, demonstrating the required Java concepts and best practices.
 * 
 * 1.  **Task Class:** The `Task` class encapsulates the properties of a task (`id`, `description`, `priority`, `status`). It has a constructor and getter methods. A setter is provided for the `status` field, as the status changes throughout the task lifecycle ("Pending" -> "Queued" -> "Completed"). The `toString()` method provides a convenient string representation for printing.
 * 
 * 2.  **TaskManager Class:**
 *     *   It uses an `ArrayList` to store *all* tasks created (`allTasks`), declared using the `List` interface as required.
 *     *   It uses a `LinkedList` to implement the `Queue` interface (`executionQueue`), storing tasks that are ready to be processed.
 *     *   `addTask`: Generates a unique ID, validates the priority input (using `equalsIgnoreCase` for case-insensitivity), creates a `Task` object, and adds it to the `allTasks` list. It returns `null` and prints an error to `System.err` if the priority is invalid.
 *     *   `getAllTasks`: Provides access to the list of all tasks.
 *     *   `findTaskById`: A private helper method to search the `allTasks` list for a task with a specific ID. This promotes code reusability.
 *     *   `queueTask`: Uses `findTaskById` to locate the task. It checks if the task exists and is in the "Pending" status before changing its status to "Queued" and adding it to the `executionQueue` using `offer()`. Error messages are printed to `System.err` if the task is not found or not pending. Success messages are printed to `System.out`.
 *     *   `executeNextTask`: Checks if the `executionQueue` is empty. If not, it uses `poll()` to remove and retrieve the task at the head of the queue. It then updates the task's status to "Completed" and prints messages to `System.out`. If the queue is empty, it prints an error to `System.err`.
 * 
 * 3.  **ProjectManagerApp (Main Class):**
 *     *   The `main` method is the entry point.
 *     *   It initializes a `Scanner` for user input and a `TaskManager`.
 *     *   **Class-wide Exception Handling:** The core application loop (`while(running)`) is wrapped in a `try-catch(Exception e)` block. This fulfills the requirement for class-wide exception handling, catching any unexpected runtime errors that might occur within the main logic and printing an error to `System.err`. A `finally` block ensures the `Scanner` is closed properly.
 *     *   The main loop repeatedly displays a menu using `System.out`.
 *     *   It reads the user's choice using `scanner.nextInt()`. A `try-catch(InputMismatchException)` is used specifically around reading the integer choice and the task ID inputs (in case 3) to handle cases where the user enters non-numeric text, printing an error to `System.err` and consuming the invalid input. `scanner.nextLine()` is used after `nextInt()` to consume the leftover newline character.
 *     *   **Switch Statement:** A `switch` statement is used to direct the program flow based on the user's valid integer choice, calling the appropriate methods of the `TaskManager`.
 *     *   `System.out` is used for the menu, prompts, task listings, and success messages.
 *     *   `System.err` is used for invalid menu choices (in the `default` case of the switch), invalid input errors caught by `InputMismatchException`, and errors reported by the `TaskManager` (like task not found or queue empty).
 * 
 * This solution effectively demonstrates the use of `Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.err`, `System.out`, and `try-catch` blocks within a practical, albeit simplified, task management context, adhering to good programming practices.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.InputMismatchException;

/**
 * Represents a single task in the project.
 */
class Task {
    private int id;
    private String description;
    private String priority; // "High", "Medium", "Low"
    private String status;     // "Pending", "Queued", "Completed"

    /**
     * Constructs a new Task.
     *
     * @param id The unique task ID.
     * @param description The task description.
     * @param priority The task priority.
     */
    public Task(int id, String description, String priority) {
        this.id = id;
        this.description = description;
        this.priority = priority;
        this.status = "Pending"; // Default status
    }

    // --- Getters ---
    public int getId() {
        return id;
    }

    public String getDescription() {
        return description;
    }

    public String getPriority() {
        return priority;
    }

    public String getStatus() {
        return status;
    }

    // --- Setter for status (needed for state changes) ---
    public void setStatus(String status) {
        this.status = status;
    }

    @Override
    public String toString() {
        return "Task{id=" + id +
               ", description='" + description + '\'' +
               ", priority='" + priority + '\'' +
               ", status='" + status + '\'' +
               '}';
    }
}

/**
 * Manages a collection of tasks and an execution queue.
 */
class TaskManager {
    // List to hold all tasks created
    private List<Task> allTasks;
    // Queue to hold tasks ready for execution (FIFO)
    private Queue<Task> executionQueue;
    private int nextTaskId; // Counter for unique task IDs

    /**
     * Constructs a new TaskManager.
     */
    public TaskManager() {
        // Requirement: Use List interface for ArrayList
        this.allTasks = new ArrayList<>();
        // Requirement: Use Queue interface for LinkedList
        this.executionQueue = new LinkedList<>();
        this.nextTaskId = 1; // Start IDs from 1
    }

    /**
     * Adds a new task to the system.
     *
     * @param description The task description.
     * @param priority The task priority ("High", "Medium", "Low").
     * @return The created Task object, or null if priority is invalid.
     */
    public Task addTask(String description, String priority) {
        // Input validation for priority
        if (!priority.equalsIgnoreCase("High") &&
            !priority.equalsIgnoreCase("Medium") &&
            !priority.equalsIgnoreCase("Low")) {
            System.err.println("Error: Invalid priority. Must be High, Medium, or Low.");
            return null; // Indicate failure
        }

        Task newTask = new Task(nextTaskId++, description, priority);
        allTasks.add(newTask);
        return newTask;
    }

    /**
     * Returns an unmodifiable list of all tasks.
     * (Returning a copy enhances encapsulation, but for simplicity
     * in an exam context, returning the list directly might be acceptable
     * if modifying the returned list doesn't break system state).
     * Let's return the list directly for simplicity here.
     *
     * @return The list of all tasks.
     */
    public List<Task> getAllTasks() {
        return allTasks;
    }

    /**
     * Finds a task by its ID.
     *
     * @param taskId The ID of the task to find.
     * @return The Task object if found, null otherwise.
     */
    private Task findTaskById(int taskId) {
        for (Task task : allTasks) {
            if (task.getId() == taskId) {
                return task;
            }
        }
        return null; // Task not found
    }

    /**
     * Moves a pending task to the execution queue.
     *
     * @param taskId The ID of the task to queue.
     */
    public void queueTask(int taskId) {
        Task taskToQueue = findTaskById(taskId);

        if (taskToQueue == null) {
            // Requirement: Use System.err for error messages
            System.err.println("Error: Task with ID " + taskId + " not found.");
        } else if (!taskToQueue.getStatus().equals("Pending")) {
             // Requirement: Use System.err for error messages
            System.err.println("Error: Task with ID " + taskId + " is not in 'Pending' status (Current status: " + taskToQueue.getStatus() + ").");
        } else {
            taskToQueue.setStatus("Queued");
            executionQueue.offer(taskToQueue); // Add to the end of the queue
            // Requirement: Use System.out for normal output
            System.out.println("Task " + taskId + " queued for execution.");
        }
    }

    /**
     * Executes the next task from the queue.
     */
    public void executeNextTask() {
        // Check if the queue is empty
        if (executionQueue.isEmpty()) {
            // Requirement: Use System.err for error messages
            System.err.println("Error: No tasks in the execution queue.");
        } else {
            // Remove the task from the front of the queue
            Task taskToExecute = executionQueue.poll();
            // Requirement: Use System.out for normal output
            System.out.println("Executing task: " + taskToExecute);
            taskToExecute.setStatus("Completed");
            System.out.println("Task " + taskToExecute.getId() + " completed.");
        }
    }
}

/**
 * Main application class for the Project Task Manager.
 */
public class ProjectManagerApp {

    public static void main(String[] args) {
        // Requirement: Use Scanner for user input
        Scanner scanner = new Scanner(System.in);
        TaskManager taskManager = new TaskManager();

        // Requirement: Class-wide exception handling with try-catch
        // Wrap the main application loop in a try-catch block
        try {
            boolean running = true;
            while (running) {
                // Requirement: Use System.out for normal output (menu)
                System.out.println("\n--- Project Task Manager ---");
                System.out.println("1. Add New Task");
                System.out.println("2. View All Tasks");
                System.out.println("3. Queue Task for Execution");
                System.out.println("4. Execute Next Queued Task");
                System.out.println("5. Exit");
                System.out.print("Enter your choice: ");

                int choice = -1;
                try {
                    choice = scanner.nextInt();
                    // Consume the newline character left by nextInt()
                    scanner.nextLine();
                } catch (InputMismatchException e) {
                    // Requirement: Use System.err for error messages
                    System.err.println("Invalid input. Please enter a number.");
                    scanner.nextLine(); // Consume the invalid input
                    continue; // Skip to the next iteration
                }

                // Requirement: Use Switch statement for flow control
                switch (choice) {
                    case 1:
                        System.out.print("Enter task description: ");
                        String description = scanner.nextLine();
                        System.out.print("Enter priority (High, Medium, Low): ");
                        String priority = scanner.nextLine();
                        Task newTask = taskManager.addTask(description, priority);
                        if (newTask != null) {
                            System.out.println("Task added: " + newTask);
                        }
                        // Error message for invalid priority is handled inside TaskManager
                        break;

                    case 2:
                        System.out.println("All Tasks:");
                        List<Task> tasks = taskManager.getAllTasks();
                        if (tasks.isEmpty()) {
                            System.out.println("No tasks available.");
                        } else {
                            for (Task task : tasks) {
                                System.out.println(task);
                            }
                        }
                        break;

                    case 3:
                        System.out.print("Enter Task ID to queue: ");
                        try {
                            int taskIdToQueue = scanner.nextInt();
                            scanner.nextLine(); // Consume newline
                            taskManager.queueTask(taskIdToQueue);
                        } catch (InputMismatchException e) {
                            System.err.println("Invalid input. Please enter a valid Task ID (number).");
                            scanner.nextLine(); // Consume invalid input
                        }
                        break;

                    case 4:
                        taskManager.executeNextTask();
                        break;

                    case 5:
                        System.out.println("Exiting Project Task Manager.");
                        running = false;
                        break;

                    default:
                        System.err.println("Invalid choice. Please enter a number between 1 and 5.");
                }
            }
        } catch (Exception e) {
            // Requirement: Class-wide exception handling
            // Catch any unexpected exceptions during the application execution
            System.err.println("An unexpected error occurred: " + e.getMessage());
            e.printStackTrace(); // Print stack trace for debugging
        } finally {
            // Close the scanner resource
            scanner.close();
            System.out.println("Application shut down.");
        }
    }
}
