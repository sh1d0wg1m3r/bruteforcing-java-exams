/*
 * Exam Question #180
 * Generated on: 2025-05-11 22:26:57
 * Generated by: Account 5
 * 
 * QUESTION:
 * **Java Programming Exam Task: Warehouse Task Management System**
 * 
 * **Problem Description:**
 * 
 * You are tasked with developing a console-based application to simulate a simple Warehouse Task Management System. The system manages tasks (picking items for orders, restocking items) that need to be processed by warehouse workers. Tasks are processed in a First-In, First-Out (FIFO) manner. The system also needs to track the warehouse inventory.
 * 
 * Your application must allow users to perform the following operations via a menu:
 * 
 * 1.  **Add Pick Task:** Create a new task to pick a specified quantity of a given SKU (Stock Keeping Unit). Add this task to the queue of pending tasks.
 * 2.  **Add Restock Task:** Create a new task to restock a specified quantity of a given SKU. Add this task to the queue of pending tasks.
 * 3.  **Process Next Task:** Take the next task from the front of the pending queue and process it.
 *     *   For a **PICK** task: Check if sufficient inventory exists for the specified SKU and quantity. If yes, reduce the inventory quantity and mark the task as completed. If no, report an insufficient inventory error, and the task should remain in the pending queue.
 *     *   For a **RESTOCK** task: Increase the inventory quantity for the specified SKU. If the SKU does not exist in inventory, add it. Mark the task as completed.
 *     *   If the pending queue is empty, report that there are no tasks to process.
 * 4.  **View Pending Tasks:** Display all tasks currently in the pending queue, in their processing order.
 * 5.  **View Completed Tasks:** Display all tasks that have been successfully processed.
 * 6.  **View Inventory:** Display the current quantities for all SKUs in the inventory.
 * 7.  **Exit:** Terminate the application.
 * 
 * **Technical Requirements:**
 * 
 * Your solution must demonstrate advanced understanding of Java concepts and adhere to best practices. Specifically, it must utilize **ALL** of the following components:
 * 
 * *   `java.util.Queue` (for managing pending tasks in FIFO order)
 * *   `java.util.ArrayList` (for managing completed tasks and inventory)
 * *   `java.util.List` interface (used in method signatures or declarations)
 * *   `java.util.Scanner` (for reading user input from the console)
 * *   `switch` statement (for handling menu options)
 * *   `System.err` (for displaying error messages, e.g., invalid input, processing failures)
 * *   `System.out` (for displaying the menu, prompts, task details, inventory, success messages)
 * *   Class-wide exception handling with `try-catch` blocks (wrap the main operational logic to handle potential runtime errors gracefully). Define and use a custom exception class for application-specific errors (e.g., `WarehouseException`).
 * 
 * **Best Practices:**
 * 
 * *   Implement proper encapsulation using `private` fields and `public` methods.
 * *   Use meaningful names for classes, variables, and methods.
 * *   Include basic comments explaining key parts of the code.
 * *   Implement input validation (e.g., positive quantity, non-empty SKU) and report validation errors using `System.err`.
 * *   Implement robust error handling using `try-catch` blocks, catching specific exceptions where appropriate.
 * *   Structure the code into logical classes (`Task`, `InventoryItem`, `Warehouse`, main application class).
 * 
 * **Initial State:**
 * 
 * The system should start with some initial inventory items. For example:
 * *   SKU001: 100 items
 * *   SKU002: 50 items
 * *   SKU003: 200 items
 * 
 * **Expected Output:**
 * 
 * The output should be console-based, displaying a menu, prompts for input, task and inventory listings, and appropriate messages for successful operations or errors.
 * 
 * **Example Interaction Flow (Illustrative):**
 * 
 * ```
 * --- Warehouse Task Management System ---
 * Select an option:
 * 1. Add Pick Task
 * ... (menu options)
 * Enter choice: 1
 * Enter SKU for PICK task: SKU001
 * Enter quantity for PICK task: 10
 * Added task to queue: TASK-1
 * 
 * Select an option:
 * ... (menu options)
 * Enter choice: 3
 * Processing task: TASK-1
 * Successfully processed PICK task: TASK-1
 * 
 * Select an option:
 * ... (menu options)
 * Enter choice: 6
 * --- Current Inventory ---
 * SKU: SKU001, Qty: 90
 * SKU: SKU002, Qty: 50
 * SKU: SKU003, Qty: 200
 * -------------------------
 * 
 * Select an option:
 * ... (menu options)
 * Enter choice: 3
 * Task processing failed: No tasks currently in the queue.
 * 
 * Select an option:
 * ... (menu options)
 * Enter choice: 1
 * Enter SKU for PICK task: SKU001
 * Enter quantity for PICK task: 200
 * Added task to queue: TASK-2
 * 
 * Select an option:
 * ... (menu options)
 * Enter choice: 3
 * Processing task: TASK-2
 * Failed to process task TASK-2: Insufficient inventory for SKU SKU001. Required: 200, Available: 90
 * Task processing failed: Insufficient inventory for SKU SKU001. Required: 200, Available: 90
 * 
 * Select an option:
 * ... (menu options)
 * Enter choice: 4
 * --- Pending Tasks ---
 * TASK-2 [PICK] SKU: SKU001, Qty: 200
 * ---------------------
 * 
 * Select an option:
 * ... (menu options)
 * Enter choice: 7
 * Exiting system. Goodbye!
 * ```
 * 
 * You need to provide the complete, runnable Java code for this system.
 *
 * EXPLANATION:
 * The provided solution implements a simple Warehouse Task Management System demonstrating the required Java concepts and best practices.
 * 
 * **Structure:**
 * The system is structured into four classes:
 * 1.  `WarehouseException`: A custom exception class to signify application-specific errors like insufficient inventory or invalid input data.
 * 2.  `TaskType`: An enum defining the possible types of tasks (PICK, RESTOCK).
 * 3.  `Task`: Represents a single task with a unique ID, type, SKU, and quantity. It includes input validation in its constructor.
 * 4.  `InventoryItem`: Represents an item in the warehouse inventory with an SKU and quantity. It also includes input validation.
 * 5.  `Warehouse`: The core class managing the task queue (`pendingTasks`), completed tasks list (`completedTasks`), and inventory list (`inventory`). It contains the logic for adding and processing tasks.
 * 6.  `WarehouseTaskSystem`: The main class containing the `main` method, responsible for the user interface, reading input using `Scanner`, presenting the menu using a `switch` statement, and orchestrating calls to the `Warehouse` object.
 * 
 * **Required Components Usage:**
 * 
 * *   **`java.util.Queue`**: The `pendingTasks` field in the `Warehouse` class is declared as a `Queue<Task>` and initialized with a `LinkedList`. This structure naturally handles tasks in a FIFO (First-In, First-Out) order. The `offer()` method is used to add tasks to the end of the queue, `peek()` is used to inspect the task at the front without removing it (useful for checking task type/inventory before committing to processing), and `poll()` is used to remove and return the task from the front after successful validation/processing.
 * *   **`java.util.ArrayList`**: Used to implement the `completedTasks` and `inventory` lists in the `Warehouse` class. `ArrayList` is suitable here as we primarily add items to the end (`completedTasks`) or iterate through the list to find/update items (`inventory`).
 * *   **`java.util.List` interface**: The methods `getPendingTasks()`, `getCompletedTasks()`, and `getInventory()` in the `Warehouse` class return objects implementing the `List` interface. This adheres to the principle of programming to interfaces, providing flexibility if the underlying implementation changes (e.g., to `LinkedList` for inventory).
 * *   **`java.util.Scanner`**: An instance of `Scanner` is created in the `main` method of `WarehouseTaskSystem` to read user input from `System.in`. `nextLine()` is used to read entire lines, which is then parsed (`Integer.parseInt`) to avoid common pitfalls with `nextInt()`.
 * *   **`switch` statement**: The `main` method uses a `switch` statement based on the user's integer input to control the program flow, directing execution to the code block corresponding to the selected menu option.
 * *   **`System.err`**: Used throughout the code to print error messages. This includes invalid menu choices, `NumberFormatException` during input parsing, `WarehouseException` messages (e.g., insufficient inventory, empty queue), and messages for unexpected errors caught by the top-level `try-catch`.
 * *   **`System.out`**: Used for all normal output, such as printing the menu, prompting the user for input, confirming successful operations (task added, task processed), and displaying the contents of the pending tasks list, completed tasks list, and inventory list.
 * *   **Class-wide exception handling with `try-catch`**: The main `while` loop in the `main` method is wrapped in a `try-catch(Exception e)` block. This serves as a top-level handler for any exceptions that might not be specifically caught elsewhere, preventing the program from crashing unexpectedly. More specific `try-catch` blocks are used around operations known to throw certain exceptions, such as `NumberFormatException` during input parsing and `WarehouseException` during task creation or processing. A `finally` block ensures the `Scanner` is closed.
 * 
 * **Best Practices Implementation:**
 * 
 * *   **Encapsulation**: Fields in `Task`, `InventoryItem`, and `Warehouse` are declared `private`. Public methods (`getters`, `addTask`, `processNextTask`, etc.) provide controlled access to the data.
 * *   **Meaningful Names**: Class names (`Task`, `Warehouse`), variable names (`pendingTasks`, `completedTasks`, `sku`, `quantity`), method names (`addTask`, `processNextTask`, `findInventoryItem`), and the custom exception name (`WarehouseException`) are descriptive and indicate their purpose.
 * *   **Comments**: Basic comments are included to explain the purpose of classes, key methods, constructors, and important code blocks.
 * *   **Input Validation**: The constructors of `Task` and `InventoryItem` validate that SKUs are non-empty and quantities are positive (for Task) or non-negative (for InventoryItem), throwing a `WarehouseException` if validation fails. The main loop validates that menu input is an integer.
 * *   **Error Handling**: A custom `WarehouseException` provides specific error information. `try-catch` blocks handle potential `NumberFormatException` during input and `WarehouseException` during task operations. Errors are reported clearly using `System.err`. The `processNextTask` method is designed to `peek` and validate *before* `poll`ing the task if possible (specifically for PICK tasks needing inventory check), ensuring the task isn't lost from the queue on a validation failure.
 * *   **Clean Code Structure**: The code is divided into logical units (classes) with clear responsibilities, making it more organized and easier to understand. The menu logic is separated from the core warehouse operations.
 * 
 * This solution effectively integrates the required Java components into a functional system, demonstrating practical application of fundamental data structures, object-oriented principles, and robust error handling techniques.
 */

import java.util.*;
import java.util.concurrent.LinkedBlockingQueue; // Using LinkedList as a Queue implementation

// Custom Exception for warehouse-specific errors
class WarehouseException extends Exception {
    public WarehouseException(String message) {
        super(message);
    }
}

// Enum to define the types of tasks
enum TaskType {
    PICK, RESTOCK
}

// Represents a Task in the warehouse system
class Task {
    private String taskId;
    private TaskType type;
    private String sku;
    private int quantity;
    private static int nextTaskId = 1; // Static counter for unique task IDs

    /**
     * Constructs a new Task.
     * @param type The type of task (PICK or RESTOCK).
     * @param sku The SKU the task relates to.
     * @param quantity The quantity of items for the task.
     * @throws WarehouseException if input validation fails (SKU empty, quantity non-positive).
     */
    public Task(TaskType type, String sku, int quantity) throws WarehouseException {
        if (sku == null || sku.trim().isEmpty()) {
            throw new WarehouseException("SKU cannot be empty.");
        }
        if (quantity <= 0) {
             throw new WarehouseException("Quantity must be positive.");
        }
        this.taskId = "TASK-" + nextTaskId++;
        this.type = type;
        this.sku = sku.trim().toUpperCase(); // Standardize SKU format
        this.quantity = quantity;
    }

    // --- Getters ---
    public String getTaskId() { return taskId; }
    public TaskType getType() { return type; }
    public String getSku() { return sku; }
    public int getQuantity() { return quantity; }

    @Override
    public String toString() {
        return String.format("%s [%s] SKU: %s, Qty: %d", taskId, type, sku, quantity);
    }
}

// Represents an Inventory Item
class InventoryItem {
    private String sku;
    private int quantity;

    /**
     * Constructs a new InventoryItem.
     * @param sku The SKU of the item.
     * @param quantity The initial quantity.
     * @throws WarehouseException if input validation fails (SKU empty, quantity negative).
     */
    public InventoryItem(String sku, int quantity) throws WarehouseException {
         if (sku == null || sku.trim().isEmpty()) {
            throw new WarehouseException("SKU cannot be empty.");
        }
        if (quantity < 0) {
             throw new WarehouseException("Quantity cannot be negative.");
        }
        this.sku = sku.trim().toUpperCase(); // Standardize SKU format
        this.quantity = quantity;
    }

    // --- Getters and Setter ---
    public String getSku() { return sku; }
    public int getQuantity() { return quantity; }

    /**
     * Sets the quantity of the inventory item.
     * @param quantity The new quantity.
     * @throws WarehouseException if the new quantity is negative.
     */
    public void setQuantity(int quantity) throws WarehouseException {
         if (quantity < 0) {
             throw new WarehouseException("Quantity cannot be negative.");
        }
        this.quantity = quantity;
    }

    @Override
    public String toString() {
        return String.format("SKU: %s, Qty: %d", sku, quantity);
    }
}

// The core class managing warehouse operations, tasks, and inventory
class Warehouse {
    // Queue for tasks waiting to be processed (FIFO)
    private Queue<Task> pendingTasks;
    // List for tasks that have been successfully processed
    private List<Task> completedTasks;
    // List for managing the current inventory
    private List<InventoryItem> inventory;

    /**
     * Constructs a new Warehouse and initializes it with sample inventory.
     */
    public Warehouse() {
        // Using LinkedList as an implementation of the Queue interface
        this.pendingTasks = new LinkedList<>();
        // Using ArrayList for dynamic lists of completed tasks and inventory
        this.completedTasks = new ArrayList<>();
        this.inventory = new ArrayList<>();

        // Initialize some sample inventory items
        try {
            inventory.add(new InventoryItem("SKU001", 100));
            inventory.add(new InventoryItem("SKU002", 50));
            inventory.add(new InventoryItem("SKU003", 200));
            System.out.println("Initial inventory loaded.");
        } catch (WarehouseException e) {
            // This should ideally not happen with hardcoded valid initial data
            System.err.println("Error initializing inventory: " + e.getMessage());
        }
    }

    /**
     * Adds a task to the pending tasks queue.
     * @param task The task to add.
     */
    public void addTask(Task task) {
        pendingTasks.offer(task); // offer() is preferred over add() for queues as it doesn't throw exception if queue is full (though LinkedList is unbounded)
        System.out.println("Added task to queue: " + task.getTaskId());
    }

    /**
     * Processes the next task from the pending queue.
     * Handles PICK and RESTOCK logic and updates inventory.
     * @return The task that was processed.
     * @throws WarehouseException if the queue is empty, inventory is insufficient,
     *                            or another processing error occurs.
     */
    public Task processNextTask() throws WarehouseException {
        // Peek at the next task to decide processing logic before removing it
        Task nextTask = pendingTasks.peek();

        if (nextTask == null) {
            throw new WarehouseException("No tasks currently in the queue.");
        }

        System.out.println("Attempting to process task: " + nextTask.getTaskId());

        try {
            if (nextTask.getType() == TaskType.PICK) {
                InventoryItem item = findInventoryItem(nextTask.getSku());
                // Check if item exists and has sufficient quantity
                if (item == null || item.getQuantity() < nextTask.getQuantity()) {
                    throw new WarehouseException("Insufficient inventory for SKU " + nextTask.getSku() +
                                                 ". Required: " + nextTask.getQuantity() +
                                                 ", Available: " + (item == null ? 0 : item.getQuantity()));
                }
                // If inventory is sufficient, remove the task from the queue
                Task processedTask = pendingTasks.poll();
                // Update inventory quantity
                item.setQuantity(item.getQuantity() - processedTask.getQuantity());
                // Add the processed task to the completed list
                completedTasks.add(processedTask);
                System.out.println("Successfully processed PICK task: " + processedTask.getTaskId());
                return processedTask;

            } else if (nextTask.getType() == TaskType.RESTOCK) {
                // Remove the task from the queue
                Task processedTask = pendingTasks.poll();
                InventoryItem item = findInventoryItem(processedTask.getSku());

                if (item == null) {
                    // If SKU doesn't exist, create a new inventory item
                     inventory.add(new InventoryItem(processedTask.getSku(), processedTask.getQuantity()));
                     System.out.println("Added new inventory item for SKU: " + processedTask.getSku());
                } else {
                    // If SKU exists, update its quantity
                    item.setQuantity(item.getQuantity() + processedTask.getQuantity());
                }
                // Add the processed task to the completed list
                completedTasks.add(processedTask);
                System.out.println("Successfully processed RESTOCK task: " + processedTask.getTaskId());
                return processedTask;
            } else {
                 // Should not happen with current TaskType enum, but good for robustness
                 throw new WarehouseException("Unknown task type encountered: " + nextTask.getType());
            }
        } catch (WarehouseException e) {
             // Catch specific warehouse exceptions (like insufficient inventory)
             // Print the error and re-throw so the main loop can handle it
             System.err.println("Processing failed for task " + nextTask.getTaskId() + ": " + e.getMessage());
             throw e; // Re-throw the exception
        } catch (Exception e) {
            // Catch any other unexpected runtime exceptions during processing
            System.err.println("An unexpected error occurred during task processing for task " + nextTask.getTaskId() + ": " + e.getMessage());
            e.printStackTrace(System.err); // Print stack trace for debugging
            // Wrap and re-throw as a WarehouseException to be caught by the main loop
            throw new WarehouseException("Unexpected internal error during processing.");
        }
    }

    /**
     * Helper method to find an InventoryItem by its SKU.
     * @param sku The SKU to search for.
     * @return The InventoryItem object if found, null otherwise.
     */
    private InventoryItem findInventoryItem(String sku) {
        String searchSku = sku.trim().toUpperCase(); // Standardize search SKU
        for (InventoryItem item : inventory) {
            if (item.getSku().equals(searchSku)) {
                return item;
            }
        }
        return null; // Item not found
    }

    // --- Public methods to view data ---
    // Returning a new list derived from the queue to prevent external modification
    public List<Task> getPendingTasks() {
        return new ArrayList<>(pendingTasks); // Return a copy
    }

     // Returning the internal list directly for viewing (ArrayList is safe for iteration)
     public List<Task> getCompletedTasks() {
        return completedTasks;
    }

    // Returning the internal list directly for viewing (ArrayList is safe for iteration)
    public List<InventoryItem> getInventory() {
        return inventory;
    }
}


// The main application class containing the user interface and main loop
public class WarehouseTaskSystem {

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        Warehouse warehouse = new Warehouse();
        boolean running = true;

        System.out.println("--- Warehouse Task Management System ---");

        // Class-wide exception handling: Wrap the main operational loop
        try {
            while (running) {
                printMenu();
                System.out.print("Enter choice: ");

                int choice = -1;
                try {
                    // Use nextLine() and parse to avoid issues with nextInt() and line breaks
                    choice = Integer.parseInt(scanner.nextLine());
                } catch (NumberFormatException e) {
                    System.err.println("Invalid input. Please enter a number.");
                    continue; // Skip the rest of the loop and show menu again
                }

                // Using switch statement for menu navigation
                switch (choice) {
                    case 1: // Add Pick Task
                        try {
                            System.out.print("Enter SKU for PICK task: ");
                            String pickSku = scanner.nextLine();
                            System.out.print("Enter quantity for PICK task: ");
                            int pickQty = Integer.parseInt(scanner.nextLine()); // Read and parse quantity
                            Task pickTask = new Task(TaskType.PICK, pickSku, pickQty);
                            warehouse.addTask(pickTask);
                        } catch (NumberFormatException e) {
                            System.err.println("Invalid quantity entered. Please enter a valid whole number.");
                        } catch (WarehouseException e) {
                            // Catches errors from Task constructor validation
                            System.err.println("Error creating PICK task: " + e.getMessage());
                        }
                        break;

                    case 2: // Add Restock Task
                        try {
                            System.out.print("Enter SKU for RESTOCK task: ");
                            String restockSku = scanner.nextLine();
                            System.out.print("Enter quantity for RESTOCK task: ");
                            int restockQty = Integer.parseInt(scanner.nextLine()); // Read and parse quantity
                            Task restockTask = new Task(TaskType.RESTOCK, restockSku, restockQty);
                            warehouse.addTask(restockTask);
                        } catch (NumberFormatException e) {
                            System.err.println("Invalid quantity entered. Please enter a valid whole number.");
                        } catch (WarehouseException e) {
                             // Catches errors from Task constructor validation
                            System.err.println("Error creating RESTOCK task: " + e.getMessage());
                        }
                        break;

                    case 3: // Process Next Task
                        try {
                            warehouse.processNextTask();
                        } catch (WarehouseException e) {
                            // This catch specifically handles exceptions thrown by processNextTask
                            // (e.g., empty queue, insufficient inventory, internal processing errors)
                            // The error message is already printed inside processNextTask,
                            // but we catch it here to prevent the program from crashing
                            // and allow the loop to continue.
                             // System.err.println("Processing failed: " + e.getMessage()); // Avoid double printing if already printed in warehouse
                        }
                        break;

                    case 4: // View Pending Tasks
                        List<Task> pending = warehouse.getPendingTasks(); // Uses List interface
                        System.out.println("\n--- Pending Tasks ---");
                        if (pending.isEmpty()) {
                            System.out.println("No pending tasks.");
                        } else {
                            // Iterate and print using forEach or a traditional loop
                            pending.forEach(System.out::println);
                        }
                        System.out.println("---------------------\n");
                        break;

                    case 5: // View Completed Tasks
                         List<Task> completed = warehouse.getCompletedTasks(); // Uses List interface
                        System.out.println("\n--- Completed Tasks ---");
                        if (completed.isEmpty()) {
                            System.out.println("No completed tasks.");
                        } else {
                            completed.forEach(System.out::println);
                        }
                        System.out.println("---------------------\n");
                        break;

                    case 6: // View Inventory
                        List<InventoryItem> inventory = warehouse.getInventory(); // Uses List interface
                        System.out.println("\n--- Current Inventory ---");
                         if (inventory.isEmpty()) {
                            System.out.println("No inventory items.");
                        } else {
                            inventory.forEach(System.out::println);
                        }
                        System.out.println("-------------------------\n");
                        break;

                    case 7: // Exit
                        System.out.println("Exiting system. Goodbye!");
                        running = false;
                        break;

                    default: // Handle invalid menu choices
                        System.err.println("Invalid choice. Please enter a number between 1 and 7.");
                }
            }
        } catch (Exception e) {
            // This is the top-level catch block for class-wide handling.
            // It catches any unexpected exceptions that might propagate up.
            System.err.println("\nAn unexpected critical error occurred: " + e.getMessage());
            e.printStackTrace(System.err); // Print stack trace for debugging purposes
        } finally {
             // Ensure the scanner resource is closed when the program exits
             if (scanner != null) {
                 scanner.close();
             }
             System.out.println("Scanner closed.");
        }
    }

    /**
     * Prints the main menu options to the console.
     */
    private static void printMenu() {
        System.out.println("\nSelect an option:");
        System.out.println("1. Add Pick Task");
        System.out.println("2. Add Restock Task");
        System.out.println("3. Process Next Task");
        System.out.println("4. View Pending Tasks");
        System.out.println("5. View Completed Tasks");
        System.out.println("6. View Inventory");
        System.out.println("7. Exit");
    }
}
