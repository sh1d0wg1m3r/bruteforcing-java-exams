/*
 * Exam Question #595
 * Generated on: 2025-05-12 16:12:23
 * Generated by: Account 5
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Customer Support Ticket System
 * 
 * **Scenario:**
 * 
 * You are tasked with building a simplified command-line application to simulate a customer support ticket system. The system needs to manage incoming support requests, track their status, and allow assignment to support agents.
 * 
 * **Requirements:**
 * 
 * 1.  **Ticket Management:**
 *     *   Create a `Ticket` class with the following attributes:
 *         *   `id` (int): Unique identifier, auto-generated.
 *         *   `description` (String): The problem description.
 *         *   `status` (String): Current status (e.g., "OPEN", "ASSIGNED", "RESOLVED").
 *         *   `assignee` (String): Name of the agent assigned, or "None" if unassigned.
 *     *   Tickets are initially created with "OPEN" status and "None" assignee.
 * 
 * 2.  **Support System Core:**
 *     *   Create a `SupportSystem` class to manage the tickets and agents.
 *     *   This class must use:
 *         *   A `java.util.Queue<Ticket>` to hold tickets that are currently "OPEN" and waiting to be assigned.
 *         *   A `java.util.List<Ticket>` (implemented using `java.util.ArrayList`) to store *all* tickets created in the system, regardless of status.
 *         *   A `java.util.List<String>` (implemented using `java.util.ArrayList`) to store the names of available support agents. Initialize this list with at least 3 agent names.
 * 
 * 3.  **Functionality:**
 *     *   Implement the following operations within the `SupportSystem` class:
 *         *   `submitTicket(String description)`: Creates a new `Ticket`, adds it to the list of all tickets, and adds it to the open ticket queue.
 *         *   `viewOpenTickets()`: Displays details of all tickets currently in the open ticket queue.
 *         *   `assignNextTicket(String agentName)`: Removes the next ticket from the open ticket queue, updates its status to "ASSIGNED", sets the assignee, and prints a confirmation. This method should validate if the agent exists and if there are tickets in the queue.
 *         *   `viewAgents()`: Displays the list of available agents.
 *         *   `resolveTicket(int ticketId)`: Finds a ticket by its ID in the list of all tickets. If found and its status is "ASSIGNED", updates its status to "RESOLVED" and prints a confirmation. This method should validate the ticket ID and its status.
 * 
 * 4.  **User Interface:**
 *     *   Create a `Main` class with a `main` method to run the application.
 *     *   Use `java.util.Scanner` to get user input from the console.
 *     *   Present a menu with options corresponding to the `SupportSystem` operations (Submit Ticket, View Open Queue, Assign Next Ticket, View Agents, Resolve Ticket, Exit).
 *     *   Use a `switch` statement to process the user's menu choice.
 * 
 * 5.  **Error Handling and Output:**
 *     *   Use `System.out` for displaying the menu, successful operation messages, and lists of tickets/agents.
 *     *   Use `System.err` for displaying error messages (e.g., invalid menu choice, invalid input format, queue is empty, ticket not found, agent not found, ticket not in ASSIGNED status for resolving).
 *     *   Implement class-wide exception handling in the `main` method's interaction loop using `try-catch` blocks to gracefully handle potential runtime errors, including `InputMismatchException` for invalid input types and custom exceptions you might define for business logic errors (e.g., trying to assign from an empty queue).
 * 
 * 6.  **Best Practices:**
 *     *   Apply proper encapsulation (private fields, public methods).
 *     *   Use meaningful variable and method names.
 *     *   Include basic comments to explain complex parts.
 *     *   Perform necessary input validation (e.g., checking if agent exists, checking ticket status before resolving).
 *     *   Ensure resources like `Scanner` are closed.
 * 
 * **Expected Output Examples:**
 * 
 * ```
 * --- Support Ticket System Menu ---
 * 1. Submit New Ticket
 * 2. View Open Tickets Queue
 * 3. Assign Next Open Ticket to Agent
 * 4. View All Agents
 * 5. Mark Ticket as Resolved
 * 6. Exit
 * Enter your choice: 1
 * Enter ticket description: My printer is not working.
 * Ticket 1 submitted successfully.
 * 
 * --- Support Ticket System Menu ---
 * ...
 * Enter your choice: 2
 * Open Tickets Queue:
 * Ticket ID: 1, Description: My printer is not working., Status: OPEN, Assignee: None
 * 
 * --- Support Ticket System Menu ---
 * ...
 * Enter your choice: 3
 * Available Agents: [Alice, Bob, Charlie]
 * Enter agent name to assign: Bob
 * Ticket 1 assigned to Bob.
 * 
 * --- Support Ticket System Menu ---
 * ...
 * Enter your choice: 5
 * Enter Ticket ID to resolve: 1
 * Ticket 1 marked as RESOLVED.
 * 
 * --- Support Ticket System Menu ---
 * ...
 * Enter your choice: 3
 * Available Agents: [Alice, Bob, Charlie]
 * Enter agent name to assign: Charlie
 * System.err: Error: No tickets in the open queue to assign.
 * 
 * --- Support Ticket System Menu ---
 * ...
 * Enter your choice: 5
 * Enter Ticket ID to resolve: 99
 * System.err: Error: Ticket with ID 99 not found.
 * 
 * --- Support Ticket System Menu ---
 * ...
 * Enter your choice: 5
 * Enter Ticket ID to resolve: 1
 * System.err: Error: Ticket with ID 1 is already RESOLVED.
 * 
 * --- Support Ticket System Menu ---
 * ...
 * Enter your choice: 7
 * System.err: Error: Invalid choice. Please enter a number between 1 and 6.
 * 
 * --- Support Ticket System Menu ---
 * ...
 * Enter your choice: abc
 * System.err: Error: Invalid input. Please enter a number.
 * (and the menu is displayed again)
 * ```
 * 
 * Your solution should provide the complete Java code for the `Ticket`, `SupportSystem`, and `Main` classes, demonstrating correct usage of all required components and adherence to best practices.
 *
 * EXPLANATION:
 * This solution implements a simplified customer support ticket system using the required Java components and best practices.
 * 
 * **Key Components Used and Demonstrated:**
 * 
 * 1.  **`java.util.Queue`:** The `openTicketQueue` in the `SupportSystem` class is a `Queue` (specifically implemented using `LinkedList`). This is ideal for managing incoming tickets because a queue processes elements in a First-In, First-Out (FIFO) manner, simulating a waiting line where the oldest ticket is processed first (`poll()` method).
 * 2.  **`java.util.ArrayList`:**
 *     *   The `allTickets` list in `SupportSystem` is an `ArrayList`. It stores every ticket created, providing a way to look up tickets by ID regardless of whether they are currently in the open queue.
 *     *   The `availableAgents` list is also an `ArrayList`, used to store and manage the names of agents.
 * 3.  **`java.util.List` interface:** Both `allTickets` and `availableAgents` are declared using the `List` interface type, promoting good practice by programming to the interface rather than the concrete implementation (`ArrayList`).
 * 4.  **`java.util.Scanner`:** Used in the `Main` class to read user input from the console for menu choices, ticket descriptions, and agent names/ticket IDs.
 * 5.  **`switch` statement:** Used in the `Main` class to control the program flow based on the user's integer menu choice, directing execution to the appropriate `SupportSystem` method.
 * 6.  **`System.err`:** Used throughout the `Main` class within the `catch` blocks and `default` case of the `switch` statement to print error messages to the standard error stream, distinguishing them from normal output.
 * 7.  **`System.out`:** Used for displaying the menu, prompts, success messages, and the contents of the ticket queue and agent list.
 * 8.  **Class-wide exception handling with `try-catch`:** The main interaction loop in the `main` method is wrapped in a `try-catch` block. This block handles `InputMismatchException` (for incorrect input types) and custom `SupportSystemException`s thrown by `SupportSystem` methods when business logic constraints are violated (e.g., queue is empty, ticket not found, invalid status). A general `Exception` catch is also included for unexpected issues.
 * 
 * **Code Structure and Best Practices:**
 * 
 * *   **Encapsulation:** The `Ticket` and `SupportSystem` classes use private fields and public methods (getters, setters where necessary, and operational methods) to control access to their internal state.
 * *   **Meaningful Names:** Classes (`Ticket`, `SupportSystem`, `Main`), variables (`openTicketQueue`, `allTickets`, `availableAgents`, `description`, `agentName`, `ticketId`), and methods (`submitTicket`, `viewOpenTickets`, `assignNextTicket`, `resolveTicket`) have descriptive names that clearly indicate their purpose.
 * *   **Comments:** Basic comments are included to explain the purpose of classes, significant methods, and key logic points (like the static ID counter or the use of `scanner.nextLine()` after `nextInt()`).
 * *   **Input Validation:** The `assignNextTicket` and `resolveTicket` methods validate input (agent existence, ticket ID existence, ticket status) before proceeding, throwing custom exceptions handled in `main`. The `main` method also handles `InputMismatchException` for numerical inputs.
 * *   **Error Handling:** Custom exceptions (`SupportSystemException`) are used for specific business logic errors, making the error types clear. The `try-catch` blocks in `main` provide a robust way to handle expected input and system state errors, printing informative messages to `System.err`.
 * *   **Clean Code Structure:** The code is divided into logical classes (`Ticket` for data, `SupportSystem` for logic, `Main` for UI), promoting modularity. The `main` loop is clean, using a switch for control flow and delegating complex operations to the `SupportSystem` class.
 * *   **Resource Management:** The `Scanner` object is closed using `scanner.close()` when the application exits, releasing the system resource.
 * 
 * This solution effectively demonstrates the required Java concepts in a practical, menu-driven application, incorporating essential software engineering principles like encapsulation, validation, and robust error handling.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.NoSuchElementException; // Used by Queue.poll() but we handle empty queue explicitly
import java.util.InputMismatchException; // For Scanner input errors

// Custom Exception Class
class SupportSystemException extends Exception {
    public SupportSystemException(String message) {
        super(message);
    }
}

// Ticket Class
class Ticket {
    private int id;
    private String description;
    private String status; // e.g., "OPEN", "ASSIGNED", "RESOLVED"
    private String assignee;

    // Static counter for unique ticket IDs
    private static int nextId = 1;

    public Ticket(String description) {
        this.id = nextId++;
        this.description = description;
        this.status = "OPEN";
        this.assignee = "None";
    }

    // Getters
    public int getId() {
        return id;
    }

    public String getDescription() {
        return description;
    }

    public String getStatus() {
        return status;
    }

    public String getAssignee() {
        return assignee;
    }

    // Setters (for status and assignee updates)
    public void setStatus(String status) {
        this.status = status;
    }

    public void setAssignee(String assignee) {
        this.assignee = assignee;
    }

    @Override
    public String toString() {
        return String.format("Ticket ID: %d, Description: %s, Status: %s, Assignee: %s",
                             id, description, status, assignee);
    }
}

// Support System Class
class SupportSystem {
    private Queue<Ticket> openTicketQueue;
    private List<Ticket> allTickets; // Stores all tickets ever created
    private List<String> availableAgents;

    public SupportSystem() {
        // Use LinkedList as an implementation of Queue
        openTicketQueue = new LinkedList<>();
        // Use ArrayList as an implementation of List
        allTickets = new ArrayList<>();
        availableAgents = new ArrayList<>();

        // Initialize with some agents
        availableAgents.add("Alice");
        availableAgents.add("Bob");
        availableAgents.add("Charlie");
    }

    /**
     * Submits a new ticket to the system.
     * @param description The description of the ticket.
     */
    public void submitTicket(String description) {
        Ticket newTicket = new Ticket(description);
        allTickets.add(newTicket); // Add to the list of all tickets
        openTicketQueue.offer(newTicket); // Add to the open queue (offer is preferred over add for capacity-constrained queues, though not strictly needed here)
        System.out.println("Ticket " + newTicket.getId() + " submitted successfully.");
    }

    /**
     * Displays all tickets currently in the open queue.
     */
    public void viewOpenTickets() {
        if (openTicketQueue.isEmpty()) {
            System.out.println("No tickets in the open queue.");
        } else {
            System.out.println("--- Open Tickets Queue ---");
            // Iterate without removing elements
            for (Ticket ticket : openTicketQueue) {
                System.out.println(ticket);
            }
        }
    }

    /**
     * Assigns the next ticket in the queue to an agent.
     * @param agentName The name of the agent to assign the ticket to.
     * @throws SupportSystemException if no tickets are open or agent is not found.
     */
    public void assignNextTicket(String agentName) throws SupportSystemException {
        if (openTicketQueue.isEmpty()) {
            throw new SupportSystemException("No tickets in the open queue to assign.");
        }

        if (!availableAgents.contains(agentName)) {
            throw new SupportSystemException("Agent '" + agentName + "' not found.");
        }

        // Get and remove the head of the queue
        Ticket nextTicket = openTicketQueue.poll();

        // Update ticket status and assignee
        nextTicket.setStatus("ASSIGNED");
        nextTicket.setAssignee(agentName);

        System.out.println("Ticket " + nextTicket.getId() + " assigned to " + agentName + ".");
    }

    /**
     * Displays the list of available agents.
     */
    public void viewAgents() {
        System.out.println("Available Agents: " + availableAgents);
    }

    /**
     * Finds a ticket by ID and marks it as resolved if it's assigned.
     * @param ticketId The ID of the ticket to resolve.
     * @throws SupportSystemException if the ticket is not found or not in ASSIGNED status.
     */
    public void resolveTicket(int ticketId) throws SupportSystemException {
        // Find the ticket in the list of all tickets
        Ticket ticketToResolve = null;
        for (Ticket ticket : allTickets) {
            if (ticket.getId() == ticketId) {
                ticketToResolve = ticket;
                break;
            }
        }

        if (ticketToResolve == null) {
            throw new SupportSystemException("Ticket with ID " + ticketId + " not found.");
        }

        if (!ticketToResolve.getStatus().equals("ASSIGNED")) {
             throw new SupportSystemException("Ticket with ID " + ticketId + " cannot be resolved. Current status is " + ticketToResolve.getStatus() + ". It must be ASSIGNED.");
        }

        // Update status
        ticketToResolve.setStatus("RESOLVED");
        System.out.println("Ticket " + ticketId + " marked as RESOLVED.");
    }
}

// Main Class for User Interaction
public class Main {

    private static void displayMenu() {
        System.out.println("\n--- Support Ticket System Menu ---");
        System.out.println("1. Submit New Ticket");
        System.out.println("2. View Open Tickets Queue");
        System.out.println("3. Assign Next Open Ticket to Agent");
        System.out.println("4. View All Agents");
        System.out.println("5. Mark Ticket as Resolved");
        System.out.println("6. Exit");
        System.out.print("Enter your choice: ");
    }

    public static void main(String[] args) {
        SupportSystem system = new SupportSystem();
        Scanner scanner = new Scanner(System.in);
        boolean running = true;

        while (running) {
            displayMenu();

            try {
                int choice = scanner.nextInt();
                scanner.nextLine(); // Consume newline left-over

                switch (choice) {
                    case 1:
                        System.out.print("Enter ticket description: ");
                        String description = scanner.nextLine();
                        system.submitTicket(description);
                        break;
                    case 2:
                        system.viewOpenTickets();
                        break;
                    case 3:
                        system.viewAgents();
                        System.out.print("Enter agent name to assign: ");
                        String agentName = scanner.nextLine();
                        system.assignNextTicket(agentName); // This might throw an exception
                        break;
                    case 4:
                        system.viewAgents();
                        break;
                    case 5:
                        System.out.print("Enter Ticket ID to resolve: ");
                        int ticketId = scanner.nextInt();
                        scanner.nextLine(); // Consume newline
                        system.resolveTicket(ticketId); // This might throw an exception
                        break;
                    case 6:
                        running = false;
                        System.out.println("Exiting Support Ticket System. Goodbye!");
                        break;
                    default:
                        System.err.println("Error: Invalid choice. Please enter a number between 1 and 6.");
                        break;
                }
            } catch (InputMismatchException e) {
                // Handle non-integer input for the menu choice or ticket ID
                System.err.println("Error: Invalid input. Please enter a number.");
                scanner.nextLine(); // Consume the invalid input to prevent infinite loop
            } catch (SupportSystemException e) {
                // Handle custom business logic errors from SupportSystem methods
                System.err.println("Error: " + e.getMessage());
            } catch (Exception e) {
                // Catch any other unexpected exceptions
                System.err.println("An unexpected error occurred: " + e.getMessage());
                e.printStackTrace(System.err); // Print stack trace to error stream for debugging
            }
        }

        scanner.close(); // Close the scanner when done
    }
}
