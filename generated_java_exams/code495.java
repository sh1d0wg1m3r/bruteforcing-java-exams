/*
 * Exam Question #495
 * Generated on: 2025-05-11 23:19:40
 * Generated by: Account 3
 * 
 * QUESTION:
 * **Advanced Java Programming Exam: Service Desk Simulation**
 * 
 * **Problem Description:**
 * 
 * You are tasked with developing a Java program to simulate a basic technical support service desk. The service desk manages customers waiting for support in a queue and maintains a historical record of customers who have been successfully served.
 * 
 * Your program should provide a command-line menu-driven interface for an administrator to interact with the service desk.
 * 
 * **Requirements:**
 * 
 * 1.  **Customer Representation:** Create a simple class named `Customer` to represent a customer. This class must minimally store the customer's name (`String`). Implement a constructor and a public getter for the name. Basic validation for the name (e.g., not null or empty) should be included in the constructor.
 * 2.  **Service Desk Management:** Create a class named `ServiceDesk` that encapsulates the logic for managing the waiting and served customers. This class must contain:
 *     *   A private data structure to hold customers currently waiting in line. This must use `java.util.Queue<Customer>`. Customers should be processed in a First-In, First-Out (FIFO) manner.
 *     *   A private data structure to hold customers who have been served. This must use `java.util.ArrayList<Customer>` and be declared using the `java.util.List` interface (`private List<Customer> servedCustomers = new ArrayList<>();`).
 *     *   Public methods for the following operations:
 *         *   `addCustomer(String name)`: Creates a new `Customer` object and adds it to the waiting queue.
 *         *   `serveNextCustomer()`: Removes the next customer from the front of the waiting queue and adds them to the served customers list. This method must handle the case where the waiting queue is empty.
 *         *   `viewWaitingQueue()`: Displays the names of all customers currently in the waiting queue, in their order.
 *         *   `viewServedCustomers()`: Displays the names of all customers who have been served.
 * 3.  **User Interface:** Implement the main application logic in a `main` method (either within `ServiceDesk` or a separate `Main` class). This method must use `java.util.Scanner` to read user input from the console. Present a menu with the following options:
 *     *   1. Add Customer
 *     *   2. Serve Next Customer
 *     *   3. View Waiting Queue
 *     *   4. View Served Customers
 *     *   5. Exit
 * 4.  **Flow Control:** Use a `switch` statement within a loop in the `main` method to process the user's menu choice.
 * 5.  **Output:**
 *     *   Use `System.out` for displaying the menu, user prompts, successful operation messages, and lists of customers.
 *     *   Use `System.err` for displaying all error messages (e.g., invalid menu choice, invalid customer name, attempting to serve from an empty queue).
 * 6.  **Exception Handling:** Implement `try-catch` blocks for robust error handling. This must include:
 *     *   Handling potential `InputMismatchException` when reading the menu choice using `Scanner`.
 *     *   Handling the specific operational error that occurs when attempting to serve a customer from an empty queue. This should be caught using a specific exception related to queue operations (like `NoSuchElementException` thrown by `Queue.remove()`).
 *     *   A general `try-catch` block wrapping the main application loop to catch any other unexpected runtime exceptions that might occur.
 *     *   Handle the `IllegalArgumentException` potentially thrown by the `Customer` constructor in the `addCustomer` method.
 * 7.  **Best Practices:** Adhere to best practices, including:
 *     *   Proper encapsulation (private fields, public methods).
 *     *   Meaningful variable and method names.
 *     *   Appropriate comments explaining the purpose of classes, methods, and key logic.
 *     *   Input validation (as described in requirements 1 and 6).
 *     *   Proper error handling using `try-catch` and `System.err`.
 *     *   Clean code structure with separate classes for different concerns.
 *     *   Ensure the `Scanner` resource is closed properly.
 * 
 * **Expected Output:**
 * 
 * The program should run interactively, displaying the menu, reading user input, and performing the requested actions. It should display informative messages using `System.out` for success and `System.err` for errors. When viewing queues or lists, clearly label them and list customers one per line. If a queue or list is empty, state that clearly.
 * 
 * Example Interaction Snippet:
 * 
 * ```
 * Welcome to the Service Desk Simulation!
 * 
 * --- Service Desk Menu ---
 * 1. Add Customer
 * 2. Serve Next Customer
 * 3. View Waiting Queue
 * 4. View Served Customers
 * 5. Exit
 * -------------------------
 * 
 * Enter your choice: 1
 * Enter customer name: Alice
 * Alice added to the queue.
 * 
 * --- Service Desk Menu ---
 * ...
 * Enter your choice: 3
 * --- Waiting Queue ---
 * 1. Alice
 * --- End Queue ---
 * 
 * --- Service Desk Menu ---
 * ...
 * Enter your choice: 2
 * Alice has been served.
 * 
 * --- Service Desk Menu ---
 * ...
 * Enter your choice: 3
 * --- Waiting Queue ---
 * The waiting queue is empty.
 * --- End Queue ---
 * 
 * --- Service Desk Menu ---
 * ...
 * Enter your choice: 4
 * --- Served Customers ---
 * 1. Alice
 * --- End Served ---
 * 
 * --- Service Desk Menu ---
 * ...
 * Enter your choice: 2
 * Error: The waiting queue is empty. No customer to serve.
 * 
 * --- Service Desk Menu ---
 * ...
 * Enter your choice: invalid_input
 * Invalid input. Please enter a number.
 * 
 * --- Service Desk Menu ---
 * ...
 * Enter your choice: 1
 * Enter customer name:
 * Error adding customer: Customer name cannot be empty.
 * 
 * --- Service Desk Menu ---
 * ...
 * Enter your choice: 5
 * Exiting Service Desk. Goodbye!
 * Application terminated.
 * ```
 * 
 * Implement the complete Java program including the `Customer`, `ServiceDesk`, and a main execution class (`Main`).
 *
 * EXPLANATION:
 * This solution implements a `ServiceDesk` simulation adhering to all specified requirements.
 * 
 * 1.  **Class Structure:** The problem is broken down into logical components:
 *     *   `Customer`: A simple class representing the data entity. It includes a constructor with basic validation for the name, demonstrating encapsulation with a private field and a public getter.
 *     *   `ServiceDesk`: This class contains the core logic and data structures (`waitingQueue` and `servedCustomers`). Its methods (`addCustomer`, `serveNextCustomer`, `viewWaitingQueue`, `viewServedCustomers`) provide the public interface for managing the service desk, following encapsulation principles.
 *     *   `Main`: This class contains the `main` method, serving as the application's entry point. It handles user interaction, the main application loop, menu display, and overall exception handling.
 * 
 * 2.  **Data Structures:**
 *     *   `java.util.Queue`: A `LinkedList` is used to implement the `waitingQueue`. `LinkedList` is a common `Queue` implementation that supports efficient FIFO operations (`add` and `remove`).
 *     *   `java.util.List` and `java.util.ArrayList`: An `ArrayList` is used to store `servedCustomers`, and it is correctly declared using the `List` interface (`List<Customer> servedCustomers = new ArrayList<>();`), demonstrating polymorphism and good practice by programming to the interface.
 * 
 * 3.  **User Interaction and Flow Control:**
 *     *   `java.util.Scanner`: Used in the `main` method to read user input from `System.in`. The program correctly handles the newline character left by `scanner.nextInt()` by calling `scanner.nextLine()` immediately after, preventing issues with subsequent `nextLine()` calls.
 *     *   `switch` statement: Used in the main loop to direct execution based on the user's numeric menu choice, providing clear and readable flow control for the menu system.
 *     *   The main application runs in a `while` loop that continues until the user chooses the "Exit" option (choice 5).
 * 
 * 4.  **Output:**
 *     *   `System.out`: Used for printing the menu, prompts, confirmation messages (e.g., "Alice added to the queue."), and the contents of the queues/lists when viewed.
 *     *   `System.err`: Used exclusively for displaying error messages (e.g., "Invalid choice.", "Error: The waiting queue is empty.", "Invalid input."). This separation helps distinguish normal output from critical errors.
 * 
 * 5.  **Exception Handling (`try-catch`):** Exception handling is implemented at multiple levels as required:
 *     *   **Input Validation (`InputMismatchException`):** A nested `try-catch` block within the main loop specifically handles the `InputMismatchException` that occurs if the user enters non-integer input when prompted for a menu choice. It prints an error using `System.err` and consumes the invalid input using `scanner.next()` to prevent an infinite loop.
 *     *   **Specific Operational Error (`NoSuchElementException`):** The `serveNextCustomer` method uses `waitingQueue.remove()`. If the queue is empty, `remove()` throws `NoSuchElementException`. A `try-catch` block within this method catches this specific exception, prints an informative error message using `System.err`, and handles the empty queue scenario gracefully without crashing the program.
 *     *   **Constructor Validation (`IllegalArgumentException`):** The `Customer` constructor throws `IllegalArgumentException` for invalid names. The `ServiceDesk.addCustomer` method wraps the customer creation and queue addition in a `try-catch` to catch this specific exception and report the validation error using `System.err`.
 *     *   **General Catch-all (`Exception`):** The outermost `try-catch` block in the `main` method wraps the entire application logic. This block catches any other unexpected `Exception` that might occur during runtime, prints a general error message using `System.err`, and includes `e.printStackTrace()` which is helpful for debugging in an exam context to understand the root cause of unexpected issues.
 *     *   **Resource Management (`finally`):** A `finally` block is used in `main` to ensure that the `Scanner` object is closed properly, releasing the system resource, regardless of whether an exception occurred or the loop exited normally.
 * 
 * 6.  **Best Practices:**
 *     *   Fields in `Customer` and `ServiceDesk` are `private`, accessed via public methods (`getName`, `addCustomer`, etc.), demonstrating encapsulation.
 *     *   Variable and method names (`waitingQueue`, `serveNextCustomer`, `viewWaitingQueue`, `displayMenu`) are descriptive and follow Java conventions.
 *     *   Comments are included to explain the purpose of classes, methods, constructor validation, and specific error handling logic.
 *     *   Input validation is performed for customer names and menu choices.
 *     *   Error handling directs error output to `System.err`.
 *     *   The code is structured into distinct classes with clear responsibilities.
 * 
 * This solution effectively demonstrates the required Java concepts and best practices in a cohesive, practical scenario.
 */

import java.util.Queue;
import java.util.LinkedList;
import java.util.List;
import java.util.ArrayList;
import java.util.Scanner;
import java.util.InputMismatchException;
import java.util.NoSuchElementException;

/**
 * Represents a customer waiting for or receiving service.
 */
class Customer {
    private String name;

    /**
     * Constructs a new Customer with the given name.
     * @param name The name of the customer. Must not be null or empty.
     * @throws IllegalArgumentException if the name is null or empty.
     */
    public Customer(String name) {
        // Input validation for customer name
        if (name == null || name.trim().isEmpty()) {
            throw new IllegalArgumentException("Customer name cannot be empty.");
        }
        this.name = name.trim();
    }

    /**
     * Gets the name of the customer.
     * @return The customer's name.
     */
    public String getName() {
        return name;
    }

    @Override
    public String toString() {
        return name;
    }
}

/**
 * Manages the waiting queue and served customers for a service desk.
 */
class ServiceDesk {
    // Queue to hold customers waiting for service (FIFO)
    private Queue<Customer> waitingQueue;
    // List to hold customers who have been served
    private List<Customer> servedCustomers;

    /**
     * Constructs a new ServiceDesk, initializing the waiting queue and served list.
     */
    public ServiceDesk() {
        // Use LinkedList as a concrete implementation of Queue
        this.waitingQueue = new LinkedList<>();
        // Use ArrayList as a concrete implementation of List
        this.servedCustomers = new ArrayList<>();
    }

    /**
     * Adds a new customer to the waiting queue.
     * Handles potential errors during customer creation.
     * @param name The name of the customer to add.
     */
    public void addCustomer(String name) {
        try {
            Customer customer = new Customer(name);
            waitingQueue.add(customer); // add() throws IllegalStateException if queue is full (unlikely for LinkedList)
            System.out.println(customer.getName() + " added to the queue.");
        } catch (IllegalArgumentException e) {
            // Catch validation errors from Customer constructor
            System.err.println("Error adding customer: " + e.getMessage());
        } catch (Exception e) {
             // Catch any other unexpected errors during addition
             System.err.println("An unexpected error occurred while adding customer: " + e.getMessage());
             // e.printStackTrace(); // Optional: for debugging
        }
    }

    /**
     * Serves the next customer from the waiting queue.
     * Moves the customer from the waiting queue to the served list.
     * Handles the case where the queue is empty using try-catch.
     */
    public void serveNextCustomer() {
        // Use remove() which throws NoSuchElementException if the queue is empty.
        // This allows us to demonstrate specific exception handling for this case.
        try {
            Customer served = waitingQueue.remove();
            servedCustomers.add(served);
            System.out.println(served.getName() + " has been served.");
        } catch (NoSuchElementException e) {
            // Catch the specific exception thrown when remove() is called on an empty queue
            System.err.println("Error: The waiting queue is empty. No customer to serve.");
        } catch (Exception e) {
             // Catch any other unexpected errors during serving
             System.err.println("An unexpected error occurred while serving customer: " + e.getMessage());
             // e.printStackTrace(); // Optional: for debugging
        }
    }

    /**
     * Displays the names of customers currently in the waiting queue.
     * Iterates through the queue without removing elements.
     */
    public void viewWaitingQueue() {
        System.out.println("\n--- Waiting Queue ---");
        if (waitingQueue.isEmpty()) {
            System.out.println("The waiting queue is empty.");
        } else {
            int i = 1;
            // Iterate using the enhanced for loop, which works for Queue
            for (Customer customer : waitingQueue) {
                System.out.println(i++ + ". " + customer.getName());
            }
        }
        System.out.println("--- End Queue ---\n");
    }

    /**
     * Displays the names of customers who have been served.
     * Iterates through the served customers list.
     */
    public void viewServedCustomers() {
        System.out.println("\n--- Served Customers ---");
        if (servedCustomers.isEmpty()) {
            System.out.println("No customers have been served yet.");
        } else {
            int i = 1;
            // Iterate through the List
            for (Customer customer : servedCustomers) {
                System.out.println(i++ + ". " + customer.getName());
            }
        }
        System.out.println("--- End Served ---\n");
    }
}

/**
 * Main class to run the Service Desk simulation.
 * Contains the main application loop, menu handling, and overall exception handling.
 */
public class Main {

    public static void main(String[] args) {
        Scanner scanner = null; // Declare scanner outside try to ensure it can be closed in finally

        // Class-wide exception handling for the main application execution flow
        try {
            scanner = new Scanner(System.in);
            ServiceDesk serviceDesk = new ServiceDesk();
            int choice = -1; // Initialize choice to a non-menu value

            System.out.println("Welcome to the Service Desk Simulation!");

            // Main application loop
            while (choice != 5) {
                displayMenu();

                try {
                    // Nested try-catch specifically for handling input errors from Scanner
                    System.out.print("Enter your choice: ");
                    choice = scanner.nextInt();
                    // Consume the newline character left by nextInt()
                    // This is crucial before the next nextLine() call
                    scanner.nextLine();

                    // Use switch statement to handle different menu options
                    switch (choice) {
                        case 1:
                            System.out.print("Enter customer name: ");
                            String name = scanner.nextLine();
                            serviceDesk.addCustomer(name);
                            break;
                        case 2:
                            serviceDesk.serveNextCustomer();
                            break;
                        case 3:
                            serviceDesk.viewWaitingQueue();
                            break;
                        case 4:
                            serviceDesk.viewServedCustomers();
                            break;
                        case 5:
                            System.out.println("Exiting Service Desk. Goodbye!");
                            break;
                        default:
                            // Handle integer inputs that are not valid menu options
                            System.err.println("Invalid choice. Please enter a number between 1 and 5.");
                            break;
                    }
                } catch (InputMismatchException e) {
                    // Catch non-integer input specifically
                    System.err.println("Invalid input. Please enter a number.");
                    // Consume the invalid input from the scanner to prevent an infinite loop
                    scanner.next();
                    choice = -1; // Reset choice to ensure the loop continues
                }
                // Specific operational exceptions (like NoSuchElementException from Queue.remove())
                // are handled within the ServiceDesk methods as required by the problem.

            } // End of while loop

        } catch (Exception e) {
            // General catch-all block for any other unexpected runtime exceptions
            System.err.println("An unexpected error occurred during application execution: " + e.getMessage());
            // Print stack trace for debugging purposes in an exam scenario
            e.printStackTrace();
        } finally {
            // Ensure the scanner resource is closed properly regardless of exceptions
            if (scanner != null) {
                scanner.close();
            }
            System.out.println("Application terminated."); // Indicate final state
        }
    }

    /**
     * Displays the main menu options to the console.
     */
    private static void displayMenu() {
        System.out.println("\n--- Service Desk Menu ---");
        System.out.println("1. Add Customer");
        System.out.println("2. Serve Next Customer");
        System.out.println("3. View Waiting Queue");
        System.out.println("4. View Served Customers");
        System.out.println("5. Exit");
        System.out.println("-------------------------\n");
    }
}
