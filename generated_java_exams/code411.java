/*
 * Exam Question #411
 * Generated on: 2025-05-11 23:07:10
 * Generated by: Account 1
 * 
 * QUESTION:
 * ## Java Programming Exam: Project Task Management System
 * 
 * **Scenario:**
 * You are tasked with developing a simple console-based Project Task Management System. This system should allow users to add new development tasks, view all tasks, view tasks that are currently ready for work (in a queue), and mark tasks as completed.
 * 
 * **Requirements:**
 * 
 * 1.  **Task Representation:**
 *     *   Create a class `Task` with private fields: `id` (int), `description` (String), `priority` (int), and `status` (enum).
 *     *   Create an enum `Status` with values `READY` and `COMPLETED`.
 *     *   The `Task` class should have a constructor, appropriate getters, a setter for the `status`, and a `toString()` method for easy printing.
 *     *   New tasks should be initialized with `Status.READY`.
 * 
 * 2.  **System Core Logic:**
 *     *   Create a class `ProjectManager` that contains the main logic.
 *     *   It must have the following private fields:
 *         *   A `java.util.Queue<Task>` to hold tasks that are ready for processing (implement using `java.util.LinkedList`).
 *         *   A `java.util.List<Task>` (declared as `List`) to store all tasks ever created (implement using `java.util.ArrayList`).
 *         *   An integer `nextTaskId` to generate unique IDs for new tasks, starting from 1.
 *         *   A `java.util.Scanner` for user input.
 * 
 *     *   Implement the following methods in `ProjectManager`:
 *         *   `addTask(String description, int priority)`: Creates a new `Task` object, assigns a unique ID, adds it to the `allTasksList`, and adds the *same* task object to the `readyTasksQueue`. Prints a confirmation message to `System.out`.
 *         *   `completeTask(int taskId)`: Finds the task with the given ID in `allTasksList`. If found and its status is `READY`, update its status to `COMPLETED`. Print a success message to `System.out`. If the task is not found or is already completed, print an error message to `System.err`. Note: Updating the status of the `Task` object in `allTasksList` should automatically reflect in the `readyTasksQueue` as they hold references to the same object. You do *not* need to explicitly remove the task from the queue upon completion; the `viewReadyTasks` method will filter based on the updated status.
 *         *   `viewAllTasks()`: Iterates through `allTasksList` and prints details of each task using its `toString()` method to `System.out`. Print a message if the list is empty.
 *         *   `viewReadyTasks()`: Iterates through the `readyTasksQueue`. For each task in the queue, check its current status. If the status is `READY`, print the task details to `System.out`. Print a message if the queue is empty or if no tasks in the queue are currently `READY`.
 *         *   `run()`: This method should contain the main application loop. It should:
 *             *   Display a menu of options (Add Task, View All, View Ready, Complete Task, Exit).
 *             *   Use a `java.util.Scanner` to read user input.
 *             *   Use a `switch` statement to process the user's choice.
 *             *   Call the appropriate methods based on the user's choice.
 *             *   Handle invalid menu choices by printing an error to `System.err`.
 *             *   Handle `InputMismatchException` specifically when reading integer inputs (like choice, priority, or task ID) using a `try-catch` block around the input reading, printing an error to `System.err`, and allowing the user to try again or continue.
 *             *   Implement class-wide exception handling by wrapping the main application loop (the `while(true)` loop) within a single `try-catch(Exception e)` block. If any unexpected exception occurs, catch it and print an error message and the stack trace to `System.err` before exiting or attempting to continue (exiting is simpler for this exam).
 *             *   Ensure the `Scanner` is closed properly when the program exits.
 * 
 * 3.  **Constraints & Best Practices:**
 *     *   Adhere to proper encapsulation (private fields, public methods where necessary).
 *     *   Use meaningful variable and method names.
 *     *   Include appropriate comments (especially Javadoc for public methods) and documentation.
 *     *   Implement input validation for user inputs where appropriate (handled via `InputMismatchException` and checks in `completeTask`).
 *     *   Use `System.out` for normal output (menu, task lists, success messages).
 *     *   Use `System.err` for error messages (invalid input, task not found, etc.).
 * 
 * **Expected Output/Behavior:**
 * 
 * *   The program should present a clear menu upon startup and after each operation (unless exiting).
 * *   Adding a task should prompt for description and priority, then confirm the task details including its new ID.
 * *   Viewing all tasks should list all tasks created with their current status.
 * *   Viewing ready tasks should list only tasks currently in the queue whose status is `READY`.
 * *   Completing a task should prompt for an ID, validate the ID and task status, and update the status if valid.
 * *   Invalid menu choices or invalid input types (e.g., entering text when a number is expected) should result in an error message on `System.err` and the program should continue running, prompting for input again.
 * *   If a task ID is not found or the task is already completed when trying to complete it, an error should be printed to `System.err`.
 * *   Any unexpected runtime error should be caught by the class-wide `try-catch`, print an error to `System.err`, and the program should terminate gracefully.
 * 
 * **Grading:** Your solution will be evaluated based on:
 * *   Correct implementation of all functional requirements.
 * *   Proper usage of *all* specified Java components (`Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.err`, `System.out`, `try-catch`).
 * *   Adherence to best practices (encapsulation, naming, comments, validation, error handling).
 * *   Code clarity and structure.
 * 
 * ```java
 * // Your solution code will go here
 * ```
 * 
 * **Good luck!**
 *
 * EXPLANATION:
 * The provided solution implements the `Project Task Management System` as described in the exam question, demonstrating the required Java concepts and best practices.
 * 
 * 1.  **`Task` Class and `Status` Enum:**
 *     *   The `Task` class encapsulates the data for a single task (`id`, `description`, `priority`, `status`) using private fields, adhering to encapsulation principles.
 *     *   Getters provide controlled access to the data. A specific setter is provided for `status` as it's the only field that changes after creation.
 *     *   The `Status` enum clearly defines the possible states of a task (`READY`, `COMPLETED`).
 *     *   The `toString()` method provides a convenient way to print task details.
 * 
 * 2.  **`ProjectManager` Class:**
 *     *   **Data Structures:**
 *         *   `readyTasksQueue`: Declared as `Queue<Task>` and implemented using `LinkedList`. This structure is suitable for managing tasks in a FIFO (First-In, First-Out) manner, representing tasks waiting to be processed. `offer()` is used for adding tasks to the queue.
 *         *   `allTasksList`: Declared as `List<Task>` and implemented using `ArrayList`. This structure stores all tasks created, allowing easy access by index or iteration, and serving as the central repository for task data and definitive status. Using the `List` interface type is a good practice for flexibility.
 *     *   **`addTask` Method:** Creates a new `Task` object, adds it to *both* `allTasksList` and `readyTasksQueue`. This is key: both collections hold references to the *same* `Task` object.
 *     *   **`findTaskById` Method:** A private helper method used by `completeTask` to locate a task in `allTasksList` based on its ID.
 *     *   **`completeTask` Method:** Finds the task in `allTasksList`. It includes validation to check if the task exists and if it's already completed, printing errors to `System.err`. If valid, it updates the `status` field of the `Task` object. Because the `readyTasksQueue` holds a reference to the *same* object, its status is also implicitly updated, which is leveraged by `viewReadyTasks`.
 *     *   **`viewAllTasks` Method:** Iterates through the `allTasksList` and prints every task's details to `System.out`.
 *     *   **`viewReadyTasks` Method:** Iterates through the `readyTasksQueue`. For each `Task` object in the queue, it checks its current status using `task.getStatus()`. Only tasks whose status is `READY` are printed to `System.out`. This correctly shows tasks that were added to the queue and haven't been marked as completed in the `allTasksList` (since both point to the same object).
 *     *   **`run` Method:**
 *         *   Contains the main application loop (`while(true)`).
 *         *   Displays the menu using `printMenu()`.
 *         *   Reads user input using the `Scanner`.
 *         *   Uses a `switch` statement to direct execution based on the user's choice, fulfilling the requirement for flow control.
 *         *   Calls the appropriate methods (`addTask`, `viewAllTasks`, `viewReadyTasks`, `completeTask`).
 *         *   **Input Validation (`InputMismatchException`)**: Specific `try-catch` blocks are used around `scanner.nextInt()` calls within the loop to catch `InputMismatchException`. If caught, an error is printed to `System.err`, the invalid input is consumed (`scanner.nextLine()`), and `continue` is used to restart the loop iteration, prompting the user again. This provides robust handling for incorrect input types without crashing.
 *         *   **Class-Wide Exception Handling:** The entire `while` loop is wrapped in a `try-catch(Exception e)` block. This serves as a fallback to catch any other unexpected runtime exceptions that might occur anywhere within the loop's execution. If such an exception occurs, an error message and the stack trace are printed to `System.err`, and the program exits the `run` method.
 *         *   **`finally` Block:** A `finally` block is used to ensure that the `scanner.close()` method is called, releasing the system resource, regardless of whether the loop exits normally (via the `return` in case 5) or due to an unexpected exception caught by the outer `try-catch`.
 *     *   **`main` Method:** The entry point of the application, creating a `ProjectManager` instance and calling its `run` method.
 * 
 * This solution effectively integrates all the required Java components within a practical scenario, demonstrating competence in object-oriented design, data structures, user interaction, and robust error handling.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.InputMismatchException;

// Enum for Task Status
enum Status {
    READY, COMPLETED
}

/**
 * Represents a single task in the project management system.
 */
class Task {
    private int id;
    private String description;
    private int priority; // Simple integer priority
    private Status status;

    /**
     * Constructs a new Task.
     *
     * @param id The unique ID for the task.
     * @param description The description of the task.
     * @param priority The priority level of the task.
     */
    public Task(int id, String description, int priority) {
        this.id = id;
        this.description = description;
        this.priority = priority;
        this.status = Status.READY; // New tasks are ready by default
    }

    // Getters
    public int getId() {
        return id;
    }

    public String getDescription() {
        return description;
    }

    public int getPriority() {
        return priority;
    }

    public Status getStatus() {
        return status;
    }

    /**
     * Sets the status of the task.
     *
     * @param status The new status for the task.
     */
    public void setStatus(Status status) {
        this.status = status;
    }

    /**
     * Returns a string representation of the task.
     */
    @Override
    public String toString() {
        return String.format("ID: %d, Desc: \"%s\", Priority: %d, Status: %s",
                             id, description, priority, status);
    }
}

/**
 * Manages tasks using a queue for ready tasks and a list for all tasks.
 */
public class ProjectManager {
    private Queue<Task> readyTasksQueue;
    private List<Task> allTasksList; // Declared as List interface
    private int nextTaskId;
    private Scanner scanner;

    /**
     * Constructs a new ProjectManager.
     * Initializes the task collections and scanner.
     */
    public ProjectManager() {
        // Use LinkedList as a Queue implementation
        this.readyTasksQueue = new LinkedList<>();
        // Use ArrayList for storing all tasks, referencing List interface
        this.allTasksList = new ArrayList<>();
        this.nextTaskId = 1; // Start task IDs from 1
        this.scanner = new Scanner(System.in);
    }

    /**
     * Adds a new task to the system.
     * The task is assigned a unique ID, added to the list of all tasks,
     * and added to the queue of ready tasks.
     *
     * @param description The description of the task.
     * @param priority The priority of the task.
     */
    public void addTask(String description, int priority) {
        Task newTask = new Task(nextTaskId++, description, priority);
        allTasksList.add(newTask);
        readyTasksQueue.offer(newTask); // Add to the end of the queue
        System.out.println("Task added: " + newTask);
    }

    /**
     * Finds a task by its ID in the list of all tasks.
     *
     * @param taskId The ID of the task to find.
     * @return The Task object if found, null otherwise.
     */
    private Task findTaskById(int taskId) {
        for (Task task : allTasksList) {
            if (task.getId() == taskId) {
                return task;
            }
        }
        return null; // Task not found
    }

    /**
     * Marks a task as completed.
     * Finds the task by ID and updates its status if it's currently READY.
     * Prints messages to System.out on success or System.err on failure.
     *
     * @param taskId The ID of the task to complete.
     */
    public void completeTask(int taskId) {
        Task taskToComplete = findTaskById(taskId);

        if (taskToComplete == null) {
            System.err.println("Error: Task with ID " + taskId + " not found.");
            return;
        }

        if (taskToComplete.getStatus() == Status.COMPLETED) {
            System.err.println("Error: Task with ID " + taskId + " is already completed.");
            return;
        }

        // Update status. Since queue holds reference, status is updated there too.
        taskToComplete.setStatus(Status.COMPLETED);
        System.out.println("Task marked as completed: " + taskToComplete);
    }

    /**
     * Displays all tasks in the system from the allTasksList.
     * Prints messages to System.out.
     */
    public void viewAllTasks() {
        if (allTasksList.isEmpty()) {
            System.out.println("No tasks in the system.");
            return;
        }
        System.out.println("\n--- All Tasks ---");
        for (Task task : allTasksList) {
            System.out.println(task);
        }
        System.out.println("-----------------\n");
    }

    /**
     * Displays tasks currently in the ready queue that are not completed.
     * Iterates the queue and checks the status of each task object.
     * Prints messages to System.out.
     */
    public void viewReadyTasks() {
        if (readyTasksQueue.isEmpty()) {
            System.out.println("The ready tasks queue is empty.");
            return;
        }

        System.out.println("\n--- Ready Tasks Queue (FIFO Order) ---");
        boolean foundReady = false;
        // Iterate through the queue without removing elements
        for (Task task : readyTasksQueue) {
             // Check the actual status of the Task object reference held in the queue
             if (task.getStatus() == Status.READY) {
                 System.out.println(task);
                 foundReady = true;
             }
        }
        if (!foundReady) {
             System.out.println("No tasks currently ready in the queue (all might be completed).");
        }
        System.out.println("------------------------------------\n");
    }

    /**
     * Prints the main menu options to the console (System.out).
     */
    private void printMenu() {
        System.out.println("\n--- Menu ---");
        System.out.println("1. Add New Task");
        System.out.println("2. View All Tasks");
        System.out.println("3. View Ready Tasks (Queue)");
        System.out.println("4. Complete Task");
        System.out.println("5. Exit");
        System.out.println("------------");
    }

    /**
     * Runs the main application loop, handling user input and menu choices.
     * Includes input validation and class-wide exception handling.
     */
    public void run() {
        System.out.println("--- Project Task Management System ---");

        // Class-wide exception handling for unexpected runtime errors
        try {
            while (true) {
                printMenu();
                int choice = -1; // Initialize choice outside try-catch

                // Input validation for menu choice
                try {
                    System.out.print("Enter your choice: ");
                    choice = scanner.nextInt();
                    scanner.nextLine(); // Consume newline left-over
                } catch (InputMismatchException e) {
                    System.err.println("Invalid input. Please enter a number for your choice.");
                    scanner.nextLine(); // Consume the invalid input
                    continue; // Skip to the next iteration of the main loop
                }

                // Process user choice using switch statement
                switch (choice) {
                    case 1: // Add New Task
                        System.out.print("Enter task description: ");
                        String description = scanner.nextLine();
                        int priority = 0;

                        // Input validation loop for priority
                        boolean validPriority = false;
                        while (!validPriority) {
                            try {
                                System.out.print("Enter task priority (integer, e.g., 1=High, 5=Low): ");
                                priority = scanner.nextInt();
                                scanner.nextLine(); // Consume newline
                                validPriority = true; // Input was valid
                            } catch (InputMismatchException e) {
                                System.err.println("Invalid priority input. Please enter an integer.");
                                scanner.nextLine(); // Consume invalid input
                            }
                        }
                        addTask(description, priority);
                        break;

                    case 2: // View All Tasks
                        viewAllTasks();
                        break;

                    case 3: // View Ready Tasks (Queue)
                        viewReadyTasks();
                        break;

                    case 4: // Complete Task
                        int taskIdToComplete = -1;
                        boolean validTaskId = false;
                         // Input validation loop for task ID
                         while (!validTaskId) {
                            try {
                                System.out.print("Enter ID of task to complete: ");
                                taskIdToComplete = scanner.nextInt();
                                scanner.nextLine(); // Consume newline
                                validTaskId = true; // Input was valid
                            } catch (InputMismatchException e) {
                                System.err.println("Invalid task ID input. Please enter an integer.");
                                scanner.nextLine(); // Consume invalid input
                            }
                        }
                        completeTask(taskIdToComplete);
                        break;

                    case 5: // Exit
                        System.out.println("Exiting Project Task Management System. Goodbye!");
                        return; // Exit the run method

                    default: // Invalid choice
                        System.err.println("Invalid choice. Please enter a number between 1 and 5.");
                        break;
                }
            }
        } catch (Exception e) {
            // Catch any unexpected runtime exceptions and print to System.err
            System.err.println("\nAn unexpected critical error occurred:");
            e.printStackTrace(System.err); // Print stack trace to System.err
        } finally {
             // Ensure scanner is closed whether loop exits normally or by exception
             if (scanner != null) {
                 scanner.close();
             }
             System.out.println("Scanner closed."); // Optional confirmation
        }
    }

    /**
     * Main method to start the Project Task Management System.
     *
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        ProjectManager manager = new ProjectManager();
        manager.run();
    }
}
