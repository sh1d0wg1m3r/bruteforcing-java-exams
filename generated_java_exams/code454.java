/*
 * Exam Question #454
 * Generated on: 2025-05-11 23:13:44
 * Generated by: Account 5
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Advanced Task Management System
 * 
 * **Problem Description:**
 * 
 * You are tasked with developing a simple console-based Task Management System for a small project team. The system should allow users to create tasks, assign them to a processing queue, process tasks from the queue, and view the status of all tasks.
 * 
 * Tasks have a unique ID, a description, and a status (e.g., CREATED, ASSIGNED, COMPLETED). Initially, tasks are in the CREATED state. A task can only be moved to the ASSIGNED state and added to the processing queue if it is currently in the CREATED state. Processing a task involves taking it from the front of the queue and marking it as COMPLETED.
 * 
 * Your implementation must adhere to the following requirements:
 * 
 * 1.  **Core Functionality:**
 *     *   Allow users to create new tasks by providing a description. Each task must receive a unique ID automatically.
 *     *   Allow users to assign a created task to a processing queue using its ID. This should change the task's status to ASSIGNED and add it to the queue.
 *     *   Allow users to process the next task from the front of the queue. This should remove the task from the queue and change its status to COMPLETED.
 *     *   Allow users to list all tasks created in the system, showing their ID, description, and current status.
 *     *   Allow users to list the tasks currently waiting in the assigned processing queue (without removing them).
 *     *   Provide a menu-driven interface for user interaction.
 *     *   Allow the user to exit the application.
 * 
 * 2.  **Mandatory Java Components:** Your solution **must** use ALL of the following Java components:
 *     *   `java.util.Queue`
 *     *   `java.util.ArrayList`
 *     *   `java.util.List` (used as a type, e.g., for method parameters or return types)
 *     *   `java.util.Scanner` (for reading user input from the console)
 *     *   `switch` statement (for handling menu choices)
 *     *   `System.err` (for printing error messages)
 *     *   `System.out` (for printing normal output like menus, prompts, success messages, task lists)
 *     *   Class-wide exception handling using `try-catch` blocks (at least for handling invalid user input like non-numeric entries).
 * 
 * 3.  **Best Practices:**
 *     *   Implement proper encapsulation (private fields, public methods) for task data and task management logic.
 *     *   Use meaningful variable and method names.
 *     *   Include appropriate comments to explain complex parts.
 *     *   Implement input validation (e.g., ensure task ID exists, ensure task is in correct state for assignment).
 *     *   Implement proper error handling (inform the user about invalid operations or inputs using `System.err`).
 *     *   Structure your code into appropriate classes (e.g., a `Task` class and a `TaskManager` class).
 * 
 * **Expected Output:**
 * 
 * Your program should interact with the user via the console, presenting a menu and responding to choices. Error messages should be clearly distinguishable using `System.err`.
 * 
 * A sample interaction might look like this:
 * 
 * ```
 * Task Management System
 * Choose an action:
 * 1. Create Task
 * 2. Assign Task to Queue (by ID)
 * 3. Process Next Task from Queue
 * 4. List All Tasks
 * 5. List Assigned Task Queue
 * 6. Exit
 * Enter choice: 1
 * Enter task description: Implement login screen
 * Task created: Task [ID=1, Description='Implement login screen', Status=CREATED]
 * 
 * Choose an action:
 * ... (menu) ...
 * Enter choice: 1
 * Enter task description: Design database schema
 * Task created: Task [ID=2, Description='Design database schema', Status=CREATED]
 * 
 * Choose an action:
 * ... (menu) ...
 * Enter choice: 4
 * --- All Tasks ---
 * Task [ID=1, Description='Implement login screen', Status=CREATED]
 * Task [ID=2, Description='Design database schema', Status=CREATED]
 * -----------------
 * 
 * Choose an action:
 * ... (menu) ...
 * Enter choice: 2
 * Enter Task ID to assign: 1
 * Task 1 assigned to queue.
 * 
 * Choose an action:
 * ... (menu) ...
 * Enter choice: 5
 * --- Assigned Task Queue ---
 * Task [ID=1, Description='Implement login screen', Status=ASSIGNED]
 * ---------------------------
 * 
 * Choose an action:
 * ... (menu) ...
 * Enter choice: 2
 * Enter Task ID to assign: 1
 * Error: Task 1 is already ASSIGNED and cannot be assigned.
 * 
 * Choose an action:
 * ... (menu) ...
 * Enter choice: 3
 * Task processed: Task [ID=1, Description='Implement login screen', Status=COMPLETED]
 * 
 * Choose an action:
 * ... (menu) ...
 * Enter choice: 5
 * --- Assigned Task Queue ---
 * Assigned queue is empty.
 * ---------------------------
 * 
 * Choose an action:
 * ... (menu) ...
 * Enter choice: 3
 * Error: The assigned task queue is empty. No tasks to process.
 * 
 * Choose an action:
 * ... (menu) ...
 * Enter choice: abc
 * Error: Invalid input. Please enter a number for the menu choice or task ID.
 * 
 * Choose an action:
 * ... (menu) ...
 * Enter choice: 6
 * Exiting Task Management System. Goodbye!
 * ```
 * 
 * Implement the complete Java code for this system.
 *
 * EXPLANATION:
 * This solution implements a simple console-based Task Management System demonstrating the required Java concepts.
 * 
 * 1.  **Task Class:** Represents the data structure for a single task, encapsulating its `id`, `description`, and `status`. An `enum` `TaskStatus` is used for clear state representation (`CREATED`, `ASSIGNED`, `COMPLETED`). An `AtomicInteger` is used to generate unique IDs for tasks automatically upon creation. Getters and a controlled setter for status are provided, adhering to encapsulation principles. The `toString()` method is overridden for convenient printing.
 * 
 * 2.  **TaskManager Class:** This class manages the collection of tasks and the processing queue.
 *     *   `private List<Task> allTasks = new ArrayList<>();`: An `ArrayList` is used to store *all* tasks created in the system. The variable is declared using the `List` interface type, demonstrating polymorphism and adherence to the requirement. `ArrayList` is suitable here for storing and iterating through a dynamic list of tasks.
 *     *   `private Queue<Task> assignedTasksQueue = new LinkedList<>();`: A `LinkedList` is used here, which implements the `Queue` interface. This structure is ideal for the processing queue as it provides efficient FIFO (First-In, First-Out) operations (`offer` to add to the end, `poll` to remove from the front), which is required for processing tasks in the order they are assigned. The variable is declared using the `Queue` interface type.
 *     *   Methods like `createTask`, `assignTask`, and `processNextTask` implement the core business logic, modifying the state of tasks and managing their presence in the `allTasks` list and `assignedTasksQueue`.
 *     *   Input validation is performed within `assignTask` and `processNextTask` (checking if the task exists, if its status is correct for the operation, or if the queue is empty). Error messages for these validation failures are printed to `System.err`.
 *     *   Helper method `findTaskById` iterates through the `ArrayList` (`allTasks`) to locate a specific task, demonstrating iteration over the `List`.
 *     *   `getAllTasks()` and `getAssignedTasksQueue()` methods provide access to the underlying collections, returning them as `List` and `Queue` interfaces respectively.
 * 
 * 3.  **TaskManagementApp Class (Main):** This class contains the `main` method and handles the user interaction loop.
 *     *   `Scanner scanner = new Scanner(System.in);`: A `Scanner` is used to read input from the standard input stream (`System.in`).
 *     *   A `while` loop keeps the application running until the user chooses to exit.
 *     *   The `printMenu()` method displays the available options using `System.out`.
 *     *   A `try-catch` block is wrapped around the input reading (`scanner.nextInt()`, `scanner.nextLine()`) and the main `switch` statement.
 *         *   `catch (InputMismatchException e)` specifically catches cases where the user enters non-numeric input when an integer is expected (e.g., for the menu choice or task ID). It prints an error to `System.err` and consumes the invalid input using `scanner.nextLine()` to prevent an infinite loop.
 *         *   `catch (Exception e)` is a general catch block to handle any other unexpected runtime exceptions that might occur within the loop, printing an error to `System.err`. This fulfills the requirement for class-wide exception handling.
 *     *   `switch (choice)`: A `switch` statement is used to direct the program flow based on the user's valid menu choice, calling the appropriate methods in the `TaskManager`.
 *     *   `System.out.println()` is used for displaying the menu, prompts, success messages, and task details.
 *     *   `System.err.println()` is used for printing error messages resulting from invalid operations or input format errors caught by the `try-catch`.
 *     *   When listing tasks (cases 4 and 5), the code retrieves the collections from the `TaskManager` using the `List` and `Queue` interface types and then iterates through them using enhanced for loops (`for (Task task : collection)`), which is a common and clean way to iterate over collections.
 * 
 * This solution effectively integrates all required components (`Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.err`, `System.out`, `try-catch`) into a practical scenario, demonstrates key object-oriented principles (encapsulation, class separation), and includes basic error handling and input validation, fulfilling the requirements of a challenging exam task.
 */

import java.util.ArrayList;
import java.util.InputMismatchException;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.concurrent.atomic.AtomicInteger;

// Class representing a single Task
class Task {
    // AtomicInteger to generate unique IDs safely (even in concurrent scenarios, though not strictly needed here)
    private static final AtomicInteger count = new AtomicInteger(0);
    private int id;
    private String description;
    private TaskStatus status;

    // Enum to represent the possible states of a task
    public enum TaskStatus {
        CREATED, ASSIGNED, COMPLETED
    }

    // Constructor
    public Task(String description) {
        this.id = count.incrementAndGet(); // Generate unique ID
        this.description = description;
        this.status = TaskStatus.CREATED; // Initial status
    }

    // Getters for task properties
    public int getId() {
        return id;
    }

    public String getDescription() {
        return description;
    }

    public TaskStatus getStatus() {
        return status;
    }

    // Setter to update the task status (controlled access)
    public void setStatus(TaskStatus status) {
        this.status = status;
    }

    // Override toString for easy printing of task details
    @Override
    public String toString() {
        return "Task [ID=" + id + ", Description='" + description + "', Status=" + status + "]";
    }
}

// Class managing the collection of tasks and the processing queue
class TaskManager {
    // ArrayList to store all tasks ever created (List interface used as variable type)
    private List<Task> allTasks;
    // Queue to store tasks that are assigned and waiting for processing (Queue interface used)
    private Queue<Task> assignedTasksQueue;

    // Constructor
    public TaskManager() {
        this.allTasks = new ArrayList<>(); // Initialize ArrayList
        this.assignedTasksQueue = new LinkedList<>(); // Initialize LinkedList as Queue
    }

    /**
     * Creates a new task and adds it to the list of all tasks.
     * @param description The description of the new task.
     */
    public void createTask(String description) {
        if (description == null || description.trim().isEmpty()) {
            System.err.println("Error: Task description cannot be empty.");
            return;
        }
        Task newTask = new Task(description);
        allTasks.add(newTask); // Add to ArrayList
        System.out.println("Task created: " + newTask);
    }

    /**
     * Finds a task by its ID, changes its status to ASSIGNED, and adds it to the queue.
     * Validates if the task exists and is in the CREATED state.
     * @param taskId The ID of the task to assign.
     */
    public void assignTask(int taskId) {
        Task taskToAssign = findTaskById(taskId); // Use helper to find task

        if (taskToAssign == null) {
            System.err.println("Error: Task with ID " + taskId + " not found.");
            return;
        }

        if (taskToAssign.getStatus() != Task.TaskStatus.CREATED) {
            System.err.println("Error: Task " + taskId + " is already " + taskToAssign.getStatus() + " and cannot be assigned.");
            return;
        }

        taskToAssign.setStatus(Task.TaskStatus.ASSIGNED); // Update status
        assignedTasksQueue.offer(taskToAssign); // Add to the Queue
        System.out.println("Task " + taskId + " assigned to queue.");
    }

    /**
     * Processes the next task from the assigned queue.
     * Removes the task from the queue and changes its status to COMPLETED.
     * Validates if the queue is empty.
     */
    public void processNextTask() {
        if (assignedTasksQueue.isEmpty()) {
            System.err.println("Error: The assigned task queue is empty. No tasks to process.");
            return;
        }

        Task taskToProcess = assignedTasksQueue.poll(); // Get and remove from Queue
        // The object reference in the queue is the same as in the allTasks list,
        // so updating the status here updates the object in the list as well.
        taskToProcess.setStatus(Task.TaskStatus.COMPLETED); // Update status
        System.out.println("Task processed: " + taskToProcess);
    }

    /**
     * Returns the list of all tasks created in the system.
     * @return A List containing all Task objects.
     */
    public List<Task> getAllTasks() {
        return allTasks; // Return the ArrayList as a List
    }

    /**
     * Returns the queue of tasks currently assigned and waiting for processing.
     * @return A Queue containing assigned Task objects.
     */
    public Queue<Task> getAssignedTasksQueue() {
        return assignedTasksQueue; // Return the Queue
    }

    /**
     * Helper method to find a task by its ID in the allTasks list.
     * @param id The ID of the task to find.
     * @return The Task object if found, otherwise null.
     */
    private Task findTaskById(int id) {
        // Iterate through the ArrayList to find the task
        for (Task task : allTasks) {
            if (task.getId() == id) {
                return task;
            }
        }
        return null; // Task not found
    }
}

// Main application class handling user interaction
public class TaskManagementApp {

    public static void main(String[] args) {
        TaskManager manager = new TaskManager();
        Scanner scanner = new Scanner(System.in); // Scanner for user input
        boolean running = true;

        System.out.println("Task Management System");

        // Main application loop
        while (running) {
            printMenu(); // Display menu
            int choice = -1;

            // Exception handling for user input and potential runtime errors
            try {
                System.out.print("Enter choice: ");
                choice = scanner.nextInt(); // Read integer choice
                scanner.nextLine(); // Consume the leftover newline character

                // Switch statement to handle different menu options
                switch (choice) {
                    case 1: // Create Task
                        System.out.print("Enter task description: ");
                        String description = scanner.nextLine(); // Read task description
                        manager.createTask(description); // Call TaskManager method
                        break;
                    case 2: // Assign Task to Queue
                        System.out.print("Enter Task ID to assign: ");
                        int assignId = scanner.nextInt(); // Read task ID
                        scanner.nextLine(); // Consume newline
                        manager.assignTask(assignId); // Call TaskManager method
                        break;
                    case 3: // Process Next Task
                        manager.processNextTask(); // Call TaskManager method
                        break;
                    case 4: // List All Tasks
                        System.out.println("\n--- All Tasks ---");
                        // Get all tasks using the List interface return type
                        List<Task> allTasks = manager.getAllTasks();
                        if (allTasks.isEmpty()) {
                            System.out.println("No tasks created yet.");
                        } else {
                            // Iterate and print tasks from the ArrayList via List reference
                            for (Task task : allTasks) {
                                System.out.println(task); // Uses Task's toString()
                            }
                        }
                        System.out.println("-----------------");
                        break;
                    case 5: // List Assigned Task Queue
                        System.out.println("\n--- Assigned Task Queue ---");
                        // Get the assigned queue using the Queue interface return type
                        Queue<Task> assignedQueue = manager.getAssignedTasksQueue();
                        if (assignedQueue.isEmpty()) {
                            System.out.println("Assigned queue is empty.");
                        } else {
                            // Iterate through the Queue without removing elements
                            for (Task task : assignedQueue) {
                                System.out.println(task); // Uses Task's toString()
                            }
                        }
                        System.out.println("---------------------------");
                        break;
                    case 6: // Exit
                        running = false; // Set running flag to false to exit loop
                        System.out.println("Exiting Task Management System. Goodbye!");
                        break;
                    default:
                        // Handle invalid menu numbers
                        System.err.println("Error: Invalid choice. Please enter a number between 1 and 6.");
                }
            } catch (InputMismatchException e) {
                // Catch exception if user enters non-integer where an integer is expected
                System.err.println("Error: Invalid input. Please enter a number for the menu choice or task ID.");
                scanner.nextLine(); // Consume the invalid input to prevent infinite loop
            } catch (Exception e) {
                // Catch any other unexpected runtime exceptions
                System.err.println("An unexpected error occurred: " + e.getMessage());
                // e.printStackTrace(); // Uncomment for detailed debugging stack trace
            }
            System.out.println(); // Print a newline for better formatting between interactions
        }

        scanner.close(); // Close the scanner resource
    }

    // Helper method to print the main menu options
    private static void printMenu() {
        System.out.println("Choose an action:");
        System.out.println("1. Create Task");
        System.out.println("2. Assign Task to Queue (by ID)");
        System.out.println("3. Process Next Task from Queue");
        System.out.println("4. List All Tasks");
        System.out.println("5. List Assigned Task Queue");
        System.out.println("6. Exit");
    }
}
