/*
 * Exam Question #1032
 * Generated on: 2025-05-12 17:15:35
 * Generated by: Account 2
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Background Task Management System
 * 
 * **Objective:**
 * Design and implement a simple console-based system to manage background tasks. The system should allow users to add tasks to a queue, process the next task from the queue, and view the current queue and a history of processed tasks. This task requires demonstrating proficiency in core Java collections, input handling, control flow, and exception management.
 * 
 * **Scenario:**
 * You are developing a basic simulation of a server's task processing unit. Tasks arrive and are placed in a queue. A worker process picks tasks from the front of the queue for execution. The system needs to maintain a record of all tasks that have gone through the processing stage, regardless of whether they succeeded or failed.
 * 
 * **Functionality Requirements:**
 * 
 * 1.  **Add Task:** Prompt the user for a task name and add it to the queue of pending tasks.
 * 2.  **Process Next Task:** Take the task at the front of the queue, simulate its processing (include a chance of failure), and move it to a history list, marking its status as "Completed" or "Failed".
 * 3.  **View Pending Tasks:** Display all tasks currently waiting in the queue.
 * 4.  **View Task History:** Display all tasks that have been processed (completed or failed).
 * 5.  **Exit:** Terminate the application.
 * 
 * **Technical Requirements:**
 * 
 * *   Use `java.util.Queue` (specifically, a suitable implementation like `java.util.LinkedList`) to manage the pending tasks.
 * *   Use `java.util.ArrayList` to store the history of completed/failed tasks.
 * *   Use the `java.util.List` interface when returning collections of tasks from methods where appropriate (e.g., viewing tasks).
 * *   Use `java.util.Scanner` to read user input from the console (menu choice, task name).
 * *   Implement the main application loop and menu handling using a `switch` statement.
 * *   Use `System.err` to display error messages (e.g., invalid menu input, empty queue when processing, invalid task name).
 * *   Use `System.out` to display the menu, prompts, success messages, and the contents of the queue and history lists.
 * *   Implement robust exception handling using `try-catch` blocks, particularly for input operations and potential issues during task processing (e.g., trying to process from an empty queue). The main application loop should include `try-catch` to handle potential runtime issues gracefully.
 * *   Design the system using at least two classes: a `Task` class to represent individual tasks and a `TaskManager` class to manage the collections and operations. A main class (e.g., `TaskSystem`) will contain the `main` method and the user interface loop.
 * *   Follow best practices:
 *     *   Proper encapsulation (private fields, public methods).
 *     *   Meaningful variable and method names.
 *     *   Appropriate comments explaining complex logic.
 *     *   Basic input validation (e.g., ensuring task names are not empty).
 *     *   Simulate task processing failure (e.g., using `Math.random()`).
 * 
 * **Output Format:**
 * 
 * The program should display a clear menu upon startup and after each operation (except exit). Output for viewing tasks should list each task with its name and status. Error messages should be distinct (using `System.err`).
 * 
 * **Example Interaction Flow (Illustrative):**
 * 
 * ```
 * Task Management System
 * 1. Add Task
 * 2. Process Next Task
 * 3. View Pending Tasks
 * 4. View Task History
 * 5. Exit
 * Enter choice: 1
 * Enter task name: Task A
 * Task 'Task A' added to the queue.
 * 
 * Task Management System
 * ... menu ...
 * Enter choice: 1
 * Enter task name: Task B
 * Task 'Task B' added to the queue.
 * 
 * Task Management System
 * ... menu ...
 * Enter choice: 3
 * Pending Tasks:
 * - Task A (Pending)
 * - Task B (Pending)
 * 
 * Task Management System
 * ... menu ...
 * Enter choice: 2
 * Processing task 'Task A'...
 * Task 'Task A' completed successfully.
 * 
 * Task Management System
 * ... menu ...
 * Enter choice: 4
 * Task History:
 * - Task A (Completed)
 * 
 * Task Management System
 * ... menu ...
 * Enter choice: 2
 * Processing task 'Task B'...
 * Task 'Task B' processing failed.
 * 
 * Task Management System
 * ... menu ...
 * Enter choice: 4
 * Task History:
 * - Task A (Completed)
 * - Task B (Failed)
 * 
 * Task Management System
 * ... menu ...
 * Enter choice: 3
 * Pending Tasks:
 * No pending tasks.
 * 
 * Task Management System
 * ... menu ...
 * Enter choice: 6
 * Invalid choice. Please enter a number between 1 and 5.
 * 
 * Task Management System
 * ... menu ...
 * Enter choice: exit // User types non-integer
 * Invalid input. Please enter a number.
 * 
 * Task Management System
 * ... menu ...
 * Enter choice: 5
 * Exiting Task Management System.
 * ```
 * 
 * **Evaluation:**
 * 
 * Your solution will be evaluated based on:
 * *   Correct implementation of all required functionalities.
 * *   Proper use of `Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.err`, `System.out`, and `try-catch`.
 * *   Adherence to best practices (encapsulation, naming, comments, validation, error handling).
 * *   Clean and readable code structure.
 * 
 * ```java
 * // Your solution code goes here
 * ```
 * 
 * **GOOD LUCK!**
 *
 * EXPLANATION:
 * This solution implements a simple Background Task Management System using the specified Java components and best practices.
 * 
 * 1.  **`Task` Class:**
 *     *   Represents a single task with a `name` and `status`.
 *     *   Uses private fields (`name`, `status`) and public getters for encapsulation.
 *     *   The constructor includes basic input validation for the task name, throwing an `IllegalArgumentException` if it's null or empty.
 *     *   Includes a `toString()` method for easy printing of task details.
 * 
 * 2.  **`TaskManager` Class:**
 *     *   Manages the core data structures: a `Queue<Task>` named `pendingTasks` (implemented using `LinkedList`) and a `List<Task>` named `completedTasksHistory` (implemented using `ArrayList`).
 *     *   `addTask(String taskName)`: Creates a new `Task` object and adds it to the `pendingTasks` queue using `offer()`. It delegates input validation to the `Task` constructor and catches the `IllegalArgumentException`, printing an error to `System.err`.
 *     *   `processNextTask()`: Checks if the `pendingTasks` queue is empty. If so, it prints an error to `System.err`. Otherwise, it retrieves and removes the next task using `poll()`. It then simulates processing, randomly assigning "Completed" or "Failed" status, prints the result (`System.out` for success, `System.err` for failure), and adds the task to the `completedTasksHistory` list.
 *     *   `getPendingTasks()` and `getCompletedTasksHistory()`: These methods return `List<Task>` instances. They create new `ArrayList` copies of the internal collections before returning them. This is a good practice to prevent external code from directly modifying the internal state of the `TaskManager`.
 * 
 * 3.  **`TaskSystem` Class:**
 *     *   Contains the `main` method and the main application loop.
 *     *   Uses a `Scanner` for reading user input.
 *     *   The `run()` method contains the main loop (`while (!exit)`).
 *     *   `displayMenu()` prints the options to `System.out`.
 *     *   The core logic within the loop is wrapped in a `try-catch` block.
 *         *   It reads the user's choice using `scanner.nextInt()`.
 *         *   A `switch` statement is used to handle the different menu options.
 *         *   Case 1: Reads the task name and calls `taskManager.addTask()`.
 *         *   Case 2: Calls `taskManager.processNextTask()`.
 *         *   Case 3: Calls `taskManager.getPendingTasks()`, checks if the returned `List` is empty, and iterates through it, printing each task to `System.out`.
 *         *   Case 4: Calls `taskManager.getCompletedTasksHistory()`, checks if the returned `List` is empty, and iterates through it, printing each task to `System.out`.
 *         *   Case 5: Sets the `exit` flag to true.
 *         *   `default`: Handles invalid integer choices, printing an error to `System.err`.
 *     *   **Exception Handling:**
 *         *   A `catch (InputMismatchException e)` block specifically handles cases where the user enters non-integer input for the menu choice, printing an error to `System.err` and consuming the invalid input from the scanner.
 *         *   A general `catch (Exception e)` block is included as class-wide exception handling to catch any other unexpected runtime errors that might occur within the loop, printing a generic error message to `System.err`.
 *     *   The `Scanner` is closed using `scanner.close()` after the loop finishes, releasing system resources.
 * 
 * This solution effectively demonstrates the required components (`Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.err`, `System.out`, `try-catch`) within a practical, encapsulated structure, incorporating input validation and error handling.
 */

import java.util.Queue;
import java.util.LinkedList;
import java.util.List;
import java.util.ArrayList;
import java.util.Scanner;
import java.util.InputMismatchException;
import java.util.Collections; // Optional, for unmodifiable lists

/**
 * Represents a single task in the system.
 */
class Task {
    private String name;
    private String status; // e.g., "Pending", "Completed", "Failed"

    /**
     * Constructs a new Task with a given name.
     * Status is initialized to "Pending".
     * @param name The name of the task.
     */
    public Task(String name) {
        if (name == null || name.trim().isEmpty()) {
            throw new IllegalArgumentException("Task name cannot be null or empty.");
        }
        this.name = name.trim();
        this.status = "Pending";
    }

    // Getters
    public String getName() {
        return name;
    }

    public String getStatus() {
        return status;
    }

    // Setter for status - package-private or protected might be better
    // in a larger system, but public for simplicity here.
    public void setStatus(String status) {
        this.status = status;
    }

    @Override
    public String toString() {
        return "- " + name + " (" + status + ")";
    }
}

/**
 * Manages the collection of tasks: pending queue and history list.
 */
class TaskManager {
    private Queue<Task> pendingTasks;
    private List<Task> completedTasksHistory;

    /**
     * Constructs a new TaskManager.
     */
    public TaskManager() {
        this.pendingTasks = new LinkedList<>(); // LinkedList implements Queue
        this.completedTasksHistory = new ArrayList<>();
    }

    /**
     * Adds a new task to the pending queue.
     * @param taskName The name of the task to add.
     * @return true if the task was successfully added, false otherwise (e.g., invalid name).
     */
    public boolean addTask(String taskName) {
        try {
            Task newTask = new Task(taskName);
            pendingTasks.offer(newTask); // offer is generally preferred over add for queues
            System.out.println("Task '" + taskName + "' added to the queue.");
            return true;
        } catch (IllegalArgumentException e) {
            System.err.println("Error adding task: " + e.getMessage());
            return false;
        }
    }

    /**
     * Processes the next task from the queue.
     * Simulates processing with a chance of failure.
     * Moves the task to the history list.
     * @return true if a task was processed, false if the queue was empty.
     */
    public boolean processNextTask() {
        if (pendingTasks.isEmpty()) {
            System.err.println("No tasks in the queue to process.");
            return false;
        }

        Task taskToProcess = pendingTasks.poll(); // poll retrieves and removes the head of the queue
        System.out.println("Processing task '" + taskToProcess.getName() + "'...");

        // Simulate processing failure (e.g., 20% chance)
        if (Math.random() < 0.2) {
            taskToProcess.setStatus("Failed");
            System.err.println("Task '" + taskToProcess.getName() + "' processing failed.");
        } else {
            taskToProcess.setStatus("Completed");
            System.out.println("Task '" + taskToProcess.getName() + "' completed successfully.");
        }

        completedTasksHistory.add(taskToProcess);
        return true;
    }

    /**
     * Gets a list of tasks currently in the pending queue.
     * Returns a new ArrayList containing the elements from the queue.
     * @return A List of pending tasks.
     */
    public List<Task> getPendingTasks() {
        // Return a copy to prevent external modification of the internal queue state
        return new ArrayList<>(pendingTasks);
        // Alternatively, return an unmodifiable list:
        // return Collections.unmodifiableList(new ArrayList<>(pendingTasks));
    }

    /**
     * Gets a list of tasks in the history.
     * Returns a new ArrayList containing the elements from the history list.
     * @return A List of completed/failed tasks.
     */
    public List<Task> getCompletedTasksHistory() {
        // Return a copy to prevent external modification of the internal list state
        return new ArrayList<>(completedTasksHistory);
        // Alternatively, return an unmodifiable list:
        // return Collections.unmodifiableList(completedTasksHistory);
    }
}

/**
 * Main class to run the Task Management System user interface.
 */
public class TaskSystem {

    private TaskManager taskManager;
    private Scanner scanner;

    /**
     * Constructs the TaskSystem.
     */
    public TaskSystem() {
        taskManager = new TaskManager();
        scanner = new Scanner(System.in);
    }

    /**
     * Displays the main menu to the user.
     */
    private void displayMenu() {
        System.out.println("\nTask Management System");
        System.out.println("1. Add Task");
        System.out.println("2. Process Next Task");
        System.out.println("3. View Pending Tasks");
        System.out.println("4. View Task History");
        System.out.println("5. Exit");
        System.out.print("Enter choice: ");
    }

    /**
     * Runs the main application loop.
     */
    public void run() {
        boolean exit = false;
        while (!exit) {
            displayMenu();
            try {
                int choice = scanner.nextInt();
                scanner.nextLine(); // Consume newline left-over

                // Using switch statement for flow control based on user choice
                switch (choice) {
                    case 1:
                        System.out.print("Enter task name: ");
                        String taskName = scanner.nextLine();
                        taskManager.addTask(taskName); // addTask handles validation and output
                        break;
                    case 2:
                        taskManager.processNextTask(); // processNextTask handles empty queue and output
                        break;
                    case 3:
                        List<Task> pending = taskManager.getPendingTasks(); // Uses List interface
                        System.out.println("\nPending Tasks:");
                        if (pending.isEmpty()) {
                            System.out.println("No pending tasks.");
                        } else {
                            for (Task task : pending) {
                                System.out.println(task); // Task's toString is used
                            }
                        }
                        break;
                    case 4:
                        List<Task> history = taskManager.getCompletedTasksHistory(); // Uses List interface
                        System.out.println("\nTask History:");
                        if (history.isEmpty()) {
                            System.out.println("No tasks in history.");
                        } else {
                            for (Task task : history) {
                                System.out.println(task); // Task's toString is used
                            }
                        }
                        break;
                    case 5:
                        System.out.println("Exiting Task Management System.");
                        exit = true;
                        break;
                    default:
                        // Invalid choice handling using System.err
                        System.err.println("Invalid choice. Please enter a number between 1 and 5.");
                }
            } catch (InputMismatchException e) {
                // Class-wide exception handling for non-integer input
                System.err.println("Invalid input. Please enter a number.");
                scanner.nextLine(); // Consume the invalid input to prevent infinite loop
            } catch (Exception e) {
                // Catch any other unexpected exceptions
                System.err.println("An unexpected error occurred: " + e.getMessage());
                // Optional: e.printStackTrace(System.err); // For debugging
            }
        }

        // Close the scanner when exiting
        scanner.close();
    }

    /**
     * Main method to start the application.
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        TaskSystem app = new TaskSystem();
        app.run();
    }
}
