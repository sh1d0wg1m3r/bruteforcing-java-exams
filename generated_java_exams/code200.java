/*
 * Exam Question #200
 * Generated on: 2025-05-11 22:30:43
 * Generated by: Account 3
 * 
 * QUESTION:
 * **Java Programming Exam Task: Simulated Build Farm Request Management System**
 * 
 * **Problem Description:**
 * 
 * You are tasked with developing a simplified simulation of a software build farm request management system. The system should allow users to submit build requests, process them, and view the status of pending and completed builds, as well as the available build processors.
 * 
 * The system will manage:
 * 1.  A queue of pending build requests.
 * 2.  A list of completed build requests.
 * 3.  A list of available build processor names.
 * 
 * Users will interact with the system via a command-line interface, choosing actions from a menu.
 * 
 * **Requirements:**
 * 
 * 1.  **Data Structures:**
 *     *   Use `java.util.Queue` to manage the pending build requests (First-In, First-Out).
 *     *   Use `java.util.ArrayList` to store completed build requests and available processor names.
 *     *   Declare variables that hold the completed build requests and available processor names using the `java.util.List` interface type.
 * 
 * 2.  **User Input:**
 *     *   Use `java.util.Scanner` to read user input from the console.
 * 
 * 3.  **Control Flow:**
 *     *   Use a `switch` statement to handle the different menu options selected by the user.
 *     *   The program should run in a loop until the user chooses to exit.
 * 
 * 4.  **Output:**
 *     *   Use `System.out` for displaying the menu, prompts, and normal status information (e.g., lists of requests, confirmation messages).
 *     *   Use `System.err` for displaying error messages (e.g., invalid input, attempting to process when the queue is empty).
 * 
 * 5.  **Error Handling:**
 *     *   Implement input validation to ensure the user enters a valid integer for menu choices. Handle cases where non-integer input is provided.
 *     *   Implement class-wide exception handling using a `try-catch` block that wraps the main command processing loop to catch unexpected runtime errors. Include specific error handling for invalid user input where appropriate.
 * 
 * 6.  **Object-Oriented Design:**
 *     *   Create a `BuildRequest` class to represent a build request. It should have private fields for a unique `id` (integer), `description` (String), and `status` (enum).
 *     *   Create an enum `BuildStatus` with states like `PENDING` and `COMPLETED`.
 *     *   Implement proper encapsulation for the `BuildRequest` class (private fields, public getters).
 * 
 * 7.  **Processing Logic:**
 *     *   The "Process Next Build Request" action should:
 *         *   Check if the pending queue is empty. If so, display an error using `System.err`.
 *         *   If the queue is not empty, take the next request from the queue (`poll`).
 *         *   Change the status of the dequeued request to `COMPLETED`.
 *         *   Add the completed request to the list of completed builds.
 *         *   Simulate assigning the build to an available processor by cycling through the list of `availableProcessors` and printing which processor handled it (you don't need to manage processor availability state, just cycle through the names for output).
 * 
 * 8.  **Best Practices:**
 *     *   Use meaningful variable and method names.
 *     *   Include appropriate comments and documentation (e.g., Javadoc for classes/methods).
 *     *   Maintain a clean code structure.
 * 
 * **Initial Setup:**
 * 
 * *   Initialize the `availableProcessors` list with a few sample processor names (e.g., "BuildServer-1", "BuildServer-2", "BuildServer-3").
 * *   The system should start with an empty pending queue and an empty completed list.
 * 
 * **Menu Options:**
 * 
 * 1.  Add New Build Request
 * 2.  Process Next Build Request
 * 3.  View Pending Requests
 * 4.  View Completed Requests
 * 5.  View Available Processors
 * 6.  Exit
 * 
 * **Expected Output:**
 * 
 * The program should display the menu, prompt the user for input, and display results or errors based on the chosen action. Example interactions might look like:
 * 
 * ```
 * --- Build Farm Simulator ---
 * 1. Add New Build Request
 * 2. Process Next Build Request
 * 3. View Pending Requests
 * 4. View Completed Requests
 * 5. View Available Processors
 * 6. Exit
 * Enter your choice: 1
 * Enter build description: Compile core module
 * Build request #1 added.
 * 
 * --- Build Farm Simulator ---
 * ... (menu repeats)
 * Enter your choice: 3
 * --- Pending Build Requests ---
 * ID: 1, Description: Compile core module, Status: PENDING
 * 
 * --- Build Farm Simulator ---
 * ... (menu repeats)
 * Enter your choice: 2
 * Processing request #1: Compile core module
 * Assigned to processor: BuildServer-1
 * Request #1 completed.
 * 
 * --- Build Farm Simulator ---
 * ... (menu repeats)
 * Enter your choice: 4
 * --- Completed Build Requests ---
 * ID: 1, Description: Compile core module, Status: COMPLETED
 * 
 * --- Build Farm Simulator ---
 * ... (menu repeats)
 * Enter your choice: 6
 * Exiting Build Farm Simulator.
 * ```
 * 
 * Handle invalid integer input gracefully using `System.err` and reprompting. Handle attempting to process an empty queue with `System.err`.
 * 
 * Your solution should be a single Java file containing the main class and any necessary helper classes/enums (can be nested static classes for simplicity in an exam context).
 *
 * EXPLANATION:
 * The provided Java code implements the `BuildFarmSimulator` as described in the exam question, demonstrating the required concepts and best practices.
 * 
 * **Key Components and Concepts Demonstrated:**
 * 
 * 1.  **`Queue` (`java.util.Queue`):** The `buildQueue` is declared as a `Queue<BuildRequest>` and initialized with `LinkedList`. This is used to store `BuildRequest` objects that are waiting to be processed, ensuring they are handled in a First-In, First-Out manner. The `offer()` method is used to add requests to the tail, and `poll()` is used to remove requests from the head during processing.
 * 2.  **`ArrayList` (`java.util.ArrayList`):** `completedBuilds` and `availableProcessors` are instantiated as `ArrayList`. `completedBuilds` stores `BuildRequest` objects that have finished processing, and `availableProcessors` stores `String` names of the build servers. `ArrayList` provides dynamic resizing and efficient element access/addition, suitable for these lists.
 * 3.  **`List` interface (`java.util.List`):** The variables `completedBuilds` and `availableProcessors` are declared using the `List` interface type (`List<BuildRequest>` and `List<String>`). This promotes good practice by programming to the interface rather than the specific implementation (`ArrayList`), making the code more flexible if a different `List` implementation were needed later.
 * 4.  **`Scanner` (`java.util.Scanner`):** A `Scanner` object is used to read user input from `System.in`. The `nextInt()` method is used to read the menu choice, and `nextLine()` is used to read the build description. Input validation and consumption of leftover newline characters are handled carefully in `getUserChoice` and `addBuildRequest`.
 * 5.  **`switch` statement:** The `switch` statement in the `main` method is used to direct program flow based on the integer value of the user's menu choice, providing a clear and structured way to handle multiple options.
 * 6.  **`System.err`:** Used specifically in the `getUserChoice` method for invalid integer input and in the `processNextBuildRequest` method when the queue is empty, fulfilling the requirement to use `System.err` for error messages.
 * 7.  **`System.out`:** Used for all normal program output, including the menu, prompts, confirmation messages, and displaying the contents of the pending, completed, and processor lists.
 * 8.  **Class-wide exception handling (`try-catch`):** A `try-catch(Exception e)` block wraps the main `while` loop in the `main` method. This provides a top-level catch-all for any unexpected exceptions that might occur during the execution of the command processing loop, printing an error message and the stack trace to `System.err`. Additionally, a specific `try-catch(InputMismatchException)` is used within `getUserChoice` to handle non-integer input gracefully, demonstrating more targeted error handling for expected input issues. A `finally` block ensures the `Scanner` is closed.
 * 9.  **`BuildRequest` Class and `BuildStatus` Enum:** These custom types model the core data of the system. `BuildRequest` uses private fields (`id`, `description`, `status`) and public getters, demonstrating encapsulation. The `BuildStatus` enum provides type-safe representation of the request's state.
 * 10. **Input Validation and Error Handling:** The `getUserChoice` method explicitly catches `InputMismatchException` for non-integer input and consumes the invalid token. The `processNextBuildRequest` method checks if the queue is empty before attempting to `poll()`, preventing a `NoSuchElementException` and providing a user-friendly error message via `System.err`. Empty description input is also validated.
 * 11. **Best Practices:**
 *     *   Meaningful names (`buildQueue`, `completedBuilds`, `processNextBuildRequest`, `BuildStatus`, etc.) are used throughout the code.
 *     *   Basic Javadoc-style comments explain the purpose of the class and key methods.
 *     *   The code is structured logically with separate methods for different actions (`addBuildRequest`, `processNextBuildRequest`, etc.), improving readability and maintainability.
 *     *   The `Scanner` resource is closed when the program exits.
 * 
 * The solution provides a functional command-line application that correctly implements the specified requirements within the context of the build farm simulation scenario.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.InputMismatchException;

/**
 * Simulates a simple build farm request management system.
 * Demonstrates usage of Queue, List (ArrayList), Scanner, switch,
 * System.out/err, and exception handling.
 */
public class BuildFarmSimulator {

    // Enum for build request status
    private enum BuildStatus {
        PENDING,
        COMPLETED
    }

    /**
     * Represents a build request.
     */
    private static class BuildRequest {
        private int id;
        private String description;
        private BuildStatus status;

        public BuildRequest(int id, String description) {
            this.id = id;
            this.description = description;
            this.status = BuildStatus.PENDING;
        }

        // Getters
        public int getId() {
            return id;
        }

        public String getDescription() {
            return description;
        }

        public BuildStatus getStatus() {
            return status;
        }

        // Setter for status (used when processing)
        public void setStatus(BuildStatus status) {
            this.status = status;
        }

        @Override
        public String toString() {
            return "ID: " + id + ", Description: " + description + ", Status: " + status;
        }
    }

    // Data structures for the system
    private static Queue<BuildRequest> buildQueue = new LinkedList<>(); // Pending requests
    private static List<BuildRequest> completedBuilds = new ArrayList<>(); // Completed requests
    private static List<String> availableProcessors = new ArrayList<>(); // Available processor names

    private static int nextRequestId = 1; // Counter for unique request IDs
    private static int nextProcessorIndex = 0; // Index to cycle through processors

    // Scanner for user input
    private static Scanner scanner = new Scanner(System.in);

    public static void main(String[] args) {
        // Initialize available processors
        availableProcessors.add("BuildServer-1");
        availableProcessors.add("BuildServer-2");
        availableProcessors.add("BuildServer-3");

        System.out.println("--- Build Farm Simulator ---");

        // Main command processing loop wrapped in try-catch
        try {
            while (true) {
                printMenu();
                int choice = getUserChoice();

                // Handle user choice using switch statement
                switch (choice) {
                    case 1:
                        addBuildRequest();
                        break;
                    case 2:
                        processNextBuildRequest();
                        break;
                    case 3:
                        viewPendingRequests();
                        break;
                    case 4:
                        viewCompletedRequests();
                        break;
                    case 5:
                        viewAvailableProcessors();
                        break;
                    case 6:
                        System.out.println("Exiting Build Farm Simulator.");
                        scanner.close(); // Close the scanner
                        return; // Exit the program
                    default:
                        System.err.println("Invalid choice. Please enter a number between 1 and 6.");
                }
                System.out.println(); // Add a newline for better readability
            }
        } catch (Exception e) {
            // Class-wide exception handling for unexpected errors
            System.err.println("An unexpected error occurred: " + e.getMessage());
            e.printStackTrace(System.err); // Print stack trace to error stream
        } finally {
             // Ensure scanner is closed even if an exception occurs before the exit case
             if (scanner != null) {
                 scanner.close();
             }
        }
    }

    /**
     * Prints the main menu options to the console.
     */
    private static void printMenu() {
        System.out.println("--- Build Farm Simulator ---");
        System.out.println("1. Add New Build Request");
        System.out.println("2. Process Next Build Request");
        System.out.println("3. View Pending Requests");
        System.out.println("4. View Completed Requests");
        System.out.println("5. View Available Processors");
        System.out.println("6. Exit");
        System.out.print("Enter your choice: ");
    }

    /**
     * Reads and validates the user's menu choice.
     * Handles non-integer input using try-catch.
     * @return The valid integer choice.
     */
    private static int getUserChoice() {
        int choice = -1;
        try {
            choice = scanner.nextInt();
        } catch (InputMismatchException e) {
            // Handle non-integer input specifically
            System.err.println("Invalid input. Please enter a number.");
            scanner.next(); // Consume the invalid input to prevent infinite loop
        } finally {
             // Consume the rest of the line after reading the integer
             // This is important if the user enters number followed by text (e.g., "1 abc")
             // or just presses Enter after the number. nextInt() only reads the integer,
             // leaving the newline character in the buffer, which can cause issues
             // with subsequent scanner.nextLine() calls.
             if (scanner.hasNextLine()) {
                 scanner.nextLine();
             }
        }
        return choice;
    }

    /**
     * Adds a new build request to the pending queue.
     */
    private static void addBuildRequest() {
        System.out.print("Enter build description: ");
        // Consume potential leftover newline from previous nextInt()
        // Note: getUserChoice() now handles this, but it's good practice
        // to be aware of nextLine() behavior after other next methods.
        // If getUserChoice didn't consume the newline, we'd need: scanner.nextLine();
        String description = scanner.nextLine();

        if (description == null || description.trim().isEmpty()) {
             System.err.println("Build description cannot be empty.");
             return;
        }

        BuildRequest newRequest = new BuildRequest(nextRequestId++, description);
        buildQueue.offer(newRequest); // Add to the end of the queue
        System.out.println("Build request #" + newRequest.getId() + " added.");
    }

    /**
     * Processes the next build request from the queue.
     * Moves the request to the completed list and simulates assignment to a processor.
     */
    private static void processNextBuildRequest() {
        if (buildQueue.isEmpty()) {
            System.err.println("No pending build requests in the queue.");
            return;
        }

        BuildRequest requestToProcess = buildQueue.poll(); // Take from the head of the queue

        System.out.println("Processing request #" + requestToProcess.getId() + ": " + requestToProcess.getDescription());

        // Simulate assigning to a processor by cycling through the list
        if (!availableProcessors.isEmpty()) {
             String processorName = availableProcessors.get(nextProcessorIndex);
             System.out.println("Assigned to processor: " + processorName);
             nextProcessorIndex = (nextProcessorIndex + 1) % availableProcessors.size(); // Cycle index
        } else {
             System.out.println("No processors available to assign."); // Should not happen with initial setup, but good practice
        }


        requestToProcess.setStatus(BuildStatus.COMPLETED); // Update status
        completedBuilds.add(requestToProcess); // Add to completed list

        System.out.println("Request #" + requestToProcess.getId() + " completed.");
    }

    /**
     * Displays all pending build requests in the queue.
     */
    private static void viewPendingRequests() {
        System.out.println("--- Pending Build Requests ---");
        if (buildQueue.isEmpty()) {
            System.out.println("No pending requests.");
        } else {
            // Iterate through the queue without removing elements
            for (BuildRequest request : buildQueue) {
                System.out.println(request);
            }
        }
    }

    /**
     * Displays all completed build requests in the list.
     */
    private static void viewCompletedRequests() {
        System.out.println("--- Completed Build Requests ---");
        if (completedBuilds.isEmpty()) {
            System.out.println("No completed requests.");
        } else {
            // Iterate through the list
            for (BuildRequest request : completedBuilds) {
                System.out.println(request);
            }
        }
    }

    /**
     * Displays the list of available build processor names.
     */
    private static void viewAvailableProcessors() {
        System.out.println("--- Available Processors ---");
        if (availableProcessors.isEmpty()) {
            System.out.println("No processors configured.");
        } else {
            // Iterate through the list of processor names
            for (String processor : availableProcessors) {
                System.out.println("- " + processor);
            }
        }
    }
}
