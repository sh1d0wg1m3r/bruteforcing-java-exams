/*
 * Exam Question #489
 * Generated on: 2025-05-11 23:18:47
 * Generated by: Account 2
 * 
 * QUESTION:
 * **Java Programming Exam Task: Simple Help Desk Ticket System**
 * 
 * **Objective:** Design and implement a console-based application for a simplified help desk system. The system should allow users to submit new support tickets, and support staff to view pending tickets, resolve the next pending ticket, and view resolved tickets.
 * 
 * **Requirements:**
 * 
 * 1.  **Ticket Representation:** Create a class `Ticket` with appropriate fields (e.g., unique ID, description, status) and methods (constructor, getters, possibly a method to mark as resolved). Status should distinguish between "Pending" and "Resolved".
 * 2.  **System Core:** Create a class `HelpDeskSystem` to manage the tickets.
 *     *   It must maintain a collection of *pending* tickets using a `java.util.Queue`. New tickets are added to this queue.
 *     *   It must maintain a collection of *resolved* tickets using a `java.util.List` (specifically, an `ArrayList`). Resolved tickets are moved here from the pending queue.
 *     *   Include methods to:
 *         *   `addTicket(String description)`: Creates a new `Ticket` with a unique ID and adds it to the pending queue.
 *         *   `resolveNextTicket()`: Removes the next ticket from the pending queue, marks it as resolved, and adds it to the resolved list. This method must handle the case where there are no pending tickets.
 *         *   `viewPendingTickets()`: Returns a `List` containing the current pending tickets (without removing them from the queue).
 *         *   `viewResolvedTickets()`: Returns the `List` of resolved tickets.
 * 3.  **User Interface:** Implement a main application class with a `main` method.
 *     *   Use `java.util.Scanner` to get user input from the console.
 *     *   Present a menu of options to the user (e.g., Add Ticket, Resolve Next Ticket, View Pending Tickets, View Resolved Tickets, Exit).
 *     *   Use a `switch` statement to handle the user's menu choice.
 *     *   Display appropriate output to the user using `System.out`.
 *     *   Display error messages using `System.err`.
 * 4.  **Error Handling:**
 *     *   Implement input validation for the menu choice (ensure it's a valid number within the range). Use `System.err` for invalid input messages.
 *     *   Implement robust error handling for the `resolveNextTicket()` operation. If there are no tickets in the pending queue when this option is chosen, catch the appropriate condition/exception and print an error message using `System.err`. Consider using a custom exception for this specific scenario or handling the collection's behavior (e.g., `poll()` returning null).
 *     *   Include a class-wide `try-catch` block in the `main` method to catch any unexpected exceptions during the application's execution.
 * 5.  **Best Practices:**
 *     *   Apply proper encapsulation (private fields, public getters/methods).
 *     *   Use meaningful variable and method names.
 *     *   Include comments where necessary to explain complex logic.
 *     *   Ensure clean code structure.
 *     *   Handle potential resource leaks (e.g., close the `Scanner`).
 * 
 * **Expected Output:**
 * 
 * The program should display a menu, accept user input, perform the requested action, and provide feedback. Examples:
 * 
 * ```
 * Help Desk Menu:
 * 1. Add New Ticket
 * 2. Resolve Next Pending Ticket
 * 3. View Pending Tickets
 * 4. View Resolved Tickets
 * 5. Exit
 * Enter your choice: 1
 * Enter ticket description: My printer is not working.
 * Ticket #1 added: My printer is not working.
 * 
 * Help Desk Menu:
 * 1. Add New Ticket
 * 2. Resolve Next Pending Ticket
 * 3. View Pending Tickets
 * 4. View Resolved Tickets
 * 5. Exit
 * Enter your choice: 1
 * Enter ticket description: Software installation failed.
 * Ticket #2 added: Software installation failed.
 * 
 * Help Desk Menu:
 * 1. Add New Ticket
 * 2. Resolve Next Pending Ticket
 * 3. View Pending Tickets
 * 4. View Resolved Tickets
 * 5. Exit
 * Enter your choice: 3
 * --- Pending Tickets ---
 * [Ticket #1 (Pending): My printer is not working.]
 * [Ticket #2 (Pending): Software installation failed.]
 * -------------------------
 * 
 * Help Desk Menu:
 * 1. Add New Ticket
 * 2. Resolve Next Pending Ticket
 * 3. View Pending Tickets
 * 4. View Resolved Tickets
 * 5. Exit
 * Enter your choice: 2
 * Ticket #1 resolved: My printer is not working.
 * 
 * Help Desk Menu:
 * 1. Add New Ticket
 * 2. Resolve Next Pending Ticket
 * 3. View Pending Tickets
 * 4. View Resolved Tickets
 * 5. Exit
 * Enter your choice: 3
 * --- Pending Tickets ---
 * [Ticket #2 (Pending): Software installation failed.]
 * -------------------------
 * 
 * Help Desk Menu:
 * 1. Add New Ticket
 * 2. Resolve Next Pending Ticket
 * 3. View Pending Tickets
 * 4. View Resolved Tickets
 * 5. Exit
 * Enter your choice: 4
 * --- Resolved Tickets ---
 * [Ticket #1 (Resolved): My printer is not working.]
 * --------------------------
 * 
 * Help Desk Menu:
 * 1. Add New Ticket
 * 2. Resolve Next Pending Ticket
 * 3. View Pending Tickets
 * 4. View Resolved Tickets
 * 5. Exit
 * Enter your choice: 2
 * Ticket #2 resolved: Software installation failed.
 * 
 * Help Desk Menu:
 * 1. Add New Ticket
 * 2. Resolve Next Pending Ticket
 * 3. View Pending Tickets
 * 4. View Resolved Tickets
 * 5. Exit
 * Enter your choice: 2
 * System.err: No pending tickets to resolve.
 * 
 * Help Desk Menu:
 * 1. Add New Ticket
 * 2. Resolve Next Pending Ticket
 * 3. View Pending Tickets
 * 4. View Resolved Tickets
 * 5. Exit
 * Enter your choice: 6
 * System.err: Invalid choice. Please enter a number between 1 and 5.
 * 
 * Help Desk Menu:
 * 1. Add New Ticket
 * 2. Resolve Next Pending Ticket
 * 3. View Pending Tickets
 * 4. View Resolved Tickets
 * 5. Exit
 * Enter your choice: abc
 * System.err: Invalid input. Please enter a number.
 * 
 * Help Desk Menu:
 * 1. Add New Ticket
 * 2. Resolve Next Pending Ticket
 * 3. View Pending Tickets
 * 4. View Resolved Tickets
 * 5. Exit
 * Enter your choice: 5
 * Exiting Help Desk System. Goodbye!
 * ```
 * 
 * Your solution should be a single Java file containing all necessary classes.
 *
 * EXPLANATION:
 * This solution implements a simple Help Desk Ticket System demonstrating the required Java concepts and best practices.
 * 
 * 1.  **`NoPendingTicketsException`:** A custom checked exception is created to specifically signal the condition when a user attempts to resolve a ticket but the pending queue is empty. This provides a clear and type-safe way to handle this specific business logic error.
 * 
 * 2.  **`Ticket` Class:** This class represents a single help desk ticket. It encapsulates the `id`, `description`, and `status` (using `String` constants for simplicity). It provides a constructor, public getters for accessing its state, and a `resolve()` method to change its status. The `toString()` method is overridden for easy printing of ticket details. Encapsulation is achieved by making fields private and providing controlled access via public methods.
 * 
 * 3.  **`HelpDeskSystem` Class:** This is the core class managing the ticket collections.
 *     *   It uses a `java.util.Queue<Ticket>` implemented by `java.util.LinkedList` for `pendingTickets`. The `Queue` interface is appropriate here because tickets are processed in a First-In, First-Out (FIFO) manner (`poll()` and `offer()`).
 *     *   It uses a `java.util.List<Ticket>` implemented by `java.util.ArrayList` for `resolvedTickets`. The `List` interface is suitable for storing resolved tickets where order might be maintained (order of resolution) and random access or iteration is needed.
 *     *   `addTicket()`: Creates a new `Ticket` with an auto-incrementing ID and adds it to the `pendingTickets` queue using `offer()`.
 *     *   `resolveNextTicket()`: Attempts to remove the head of the queue using `poll()`. If `poll()` returns `null` (meaning the queue is empty), it throws the `NoPendingTicketsException`. Otherwise, it marks the retrieved ticket as resolved and adds it to the `resolvedTickets` list.
 *     *   `viewPendingTickets()`: Returns a *copy* of the tickets currently in the `pendingTickets` queue as an `ArrayList`. This is a good practice for encapsulation, preventing external code from modifying the internal state of the queue directly.
 *     *   `viewResolvedTickets()`: Returns the internal `resolvedTickets` `ArrayList`. For this simple case, returning the list directly is acceptable, though returning a copy or an unmodifiable list would be more robust in a larger application.
 * 
 * 4.  **`HelpDeskApp` Class (`main` method):**
 *     *   This class contains the `main` method, which serves as the application's entry point and user interface handler.
 *     *   A `java.util.Scanner` is used to read input from `System.in`. It is declared outside the `try` block and initialized inside, allowing it to be closed in the `finally` block.
 *     *   The main logic runs inside a `while(running)` loop, controlled by user input.
 *     *   `displayMenu()`: A helper method to print the menu options to `System.out`.
 *     *   Input Reading and Validation: User choice is read as a `String` using `scanner.nextLine()`. A `try-catch(NumberFormatException)` block is used to attempt parsing the string into an integer. If parsing fails (e.g., user enters text), an error is printed to `System.err`, and the loop continues using `continue`. This handles invalid non-numeric input robustly.
 *     *   `switch` Statement: The parsed integer choice is used in a `switch` statement to direct the program flow to the appropriate action (Add, Resolve, View Pending, View Resolved, Exit, Default for invalid numbers).
 *     *   Action Handling:
 *         *   Case 1 (`Add Ticket`): Prompts for description, reads it, performs a basic check for empty description, and calls `system.addTicket()`.
 *         *   Case 2 (`Resolve Next`): Calls `system.resolveNextTicket()`. This call is wrapped in a `try-catch(NoPendingTicketsException)` block. If the exception is caught, the specific error message is printed to `System.err`.
 *         *   Case 3 (`View Pending`): Calls `system.viewPendingTickets()`, iterates through the returned `List`, and prints each ticket to `System.out`. Handles the case of an empty list.
 *         *   Case 4 (`View Resolved`): Calls `system.viewResolvedTickets()`, iterates through the returned `List`, and prints each ticket to `System.out`. Handles the case of an empty list.
 *         *   Case 5 (`Exit`): Sets `running` to `false` to terminate the loop and prints an exit message to `System.out`.
 *         *   `default`: Catches integer inputs that are not valid menu options and prints an error to `System.err`.
 *     *   Class-wide `try-catch`: The main `while` loop and its contents are wrapped in a top-level `try-catch(Exception e)` block. This catches any unexpected `RuntimeException` or other `Exception` that might occur, prints a generic error message and the stack trace to `System.err`, preventing the program from crashing abruptly and demonstrating a fallback error handling mechanism.
 *     *   `finally` Block: Ensures that the `scanner.close()` method is called when the `try` block is exited, whether normally or due to an exception, preventing resource leaks.
 * 
 * This solution effectively utilizes `Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.err`, `System.out`, and `try-catch` blocks in a practical scenario, adhering to best practices like encapsulation, meaningful names, and error handling, making it a suitable challenging exam task.
 */

import java.util.Queue;
import java.util.LinkedList;
import java.util.List;
import java.util.ArrayList;
import java.util.Scanner;
import java.util.Collections; // For unmodifiable list if needed, or just return copy

// Custom exception for specific help desk errors
class NoPendingTicketsException extends Exception {
    public NoPendingTicketsException(String message) {
        super(message);
    }
}

// Represents a single help desk ticket
class Ticket {
    private int id;
    private String description;
    private String status; // Could use enum, but String is simpler for this example

    private static final String STATUS_PENDING = "Pending";
    private static final String STATUS_RESOLVED = "Resolved";

    /**
     * Constructs a new Ticket.
     * @param id The unique ID for the ticket.
     * @param description A brief description of the issue.
     */
    public Ticket(int id, String description) {
        this.id = id;
        this.description = description;
        this.status = STATUS_PENDING; // New tickets are always pending
    }

    // --- Getters ---
    public int getId() {
        return id;
    }

    public String getDescription() {
        return description;
    }

    public String getStatus() {
        return status;
    }

    /**
     * Marks the ticket as resolved.
     */
    public void resolve() {
        this.status = STATUS_RESOLVED;
    }

    /**
     * Checks if the ticket is currently pending.
     * @return true if the ticket is pending, false otherwise.
     */
    public boolean isPending() {
        return this.status.equals(STATUS_PENDING);
    }

    @Override
    public String toString() {
        return "[Ticket #" + id + " (" + status + "): " + description + "]";
    }
}

// Manages the collection of help desk tickets
class HelpDeskSystem {
    private Queue<Ticket> pendingTickets;
    private List<Ticket> resolvedTickets;
    private int nextTicketId;

    /**
     * Constructs a new HelpDeskSystem.
     */
    public HelpDeskSystem() {
        // Use LinkedList as an implementation of Queue
        this.pendingTickets = new LinkedList<>();
        // Use ArrayList as an implementation of List
        this.resolvedTickets = new ArrayList<>();
        this.nextTicketId = 1; // Start ticket IDs from 1
    }

    /**
     * Adds a new ticket to the pending queue.
     * @param description The description for the new ticket.
     */
    public void addTicket(String description) {
        Ticket newTicket = new Ticket(nextTicketId++, description);
        pendingTickets.offer(newTicket); // offer() is standard Queue add method
        System.out.println("Ticket #" + newTicket.getId() + " added: " + newTicket.getDescription());
    }

    /**
     * Resolves the next ticket in the pending queue.
     * Moves the ticket from pending to resolved state.
     * @throws NoPendingTicketsException if there are no tickets in the pending queue.
     */
    public void resolveNextTicket() throws NoPendingTicketsException {
        // poll() retrieves and removes the head of the queue, returns null if queue is empty
        Ticket ticketToResolve = pendingTickets.poll();

        if (ticketToResolve == null) {
            throw new NoPendingTicketsException("No pending tickets to resolve.");
        }

        ticketToResolve.resolve();
        resolvedTickets.add(ticketToResolve);
        System.out.println("Ticket #" + ticketToResolve.getId() + " resolved: " + ticketToResolve.getDescription());
    }

    /**
     * Returns a list of all currently pending tickets.
     * Note: Returns a new list containing the elements, not the internal queue itself,
     * to maintain encapsulation.
     * @return A List of pending tickets.
     */
    public List<Ticket> viewPendingTickets() {
        // Create a new list from the elements in the queue for viewing
        // This prevents external modification of the internal queue
        return new ArrayList<>(pendingTickets);
    }

    /**
     * Returns a list of all resolved tickets.
     * Note: Returns the internal list reference. For stricter encapsulation,
     * one might return a copy or an unmodifiable list. Returning the list
     * directly is acceptable for simpler scenarios like this exam.
     * @return A List of resolved tickets.
     */
    public List<Ticket> viewResolvedTickets() {
        return resolvedTickets; // Returns the actual list of resolved tickets
    }
}

// Main application class
public class HelpDeskApp {

    /**
     * Displays the main menu options to the console.
     */
    private static void displayMenu() {
        System.out.println("\nHelp Desk Menu:");
        System.out.println("1. Add New Ticket");
        System.out.println("2. Resolve Next Pending Ticket");
        System.out.println("3. View Pending Tickets");
        System.out.println("4. View Resolved Tickets");
        System.out.println("5. Exit");
        System.out.print("Enter your choice: ");
    }

    /**
     * Main method to run the Help Desk application.
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        Scanner scanner = null; // Declare scanner outside try-catch for finally block
        HelpDeskSystem system = new HelpDeskSystem();
        boolean running = true;

        try { // Class-wide exception handling block
            scanner = new Scanner(System.in);

            while (running) {
                displayMenu();
                String choiceStr = scanner.nextLine(); // Read choice as string to handle non-numeric input
                int choice = -1; // Default invalid choice

                try {
                    choice = Integer.parseInt(choiceStr);
                } catch (NumberFormatException e) {
                    System.err.println("Invalid input. Please enter a number.");
                    continue; // Skip the rest of the loop and show menu again
                }

                // Use switch statement for menu navigation
                switch (choice) {
                    case 1: // Add New Ticket
                        System.out.print("Enter ticket description: ");
                        String description = scanner.nextLine();
                        if (description == null || description.trim().isEmpty()) {
                             System.err.println("Ticket description cannot be empty.");
                        } else {
                            system.addTicket(description.trim());
                        }
                        break;

                    case 2: // Resolve Next Pending Ticket
                        try {
                            system.resolveNextTicket();
                        } catch (NoPendingTicketsException e) {
                            // Catch the specific exception for no pending tickets
                            System.err.println(e.getMessage());
                        }
                        break;

                    case 3: // View Pending Tickets
                        List<Ticket> pending = system.viewPendingTickets();
                        System.out.println("--- Pending Tickets ---");
                        if (pending.isEmpty()) {
                            System.out.println("No pending tickets.");
                        } else {
                            for (Ticket ticket : pending) {
                                System.out.println(ticket);
                            }
                        }
                        System.out.println("-------------------------");
                        break;

                    case 4: // View Resolved Tickets
                        List<Ticket> resolved = system.viewResolvedTickets();
                        System.out.println("--- Resolved Tickets ---");
                        if (resolved.isEmpty()) {
                            System.out.println("No resolved tickets yet.");
                        } else {
                            for (Ticket ticket : resolved) {
                                System.out.println(ticket);
                            }
                        }
                        System.out.println("--------------------------");
                        break;

                    case 5: // Exit
                        running = false;
                        System.out.println("Exiting Help Desk System. Goodbye!");
                        break;

                    default: // Invalid choice number
                        System.err.println("Invalid choice. Please enter a number between 1 and 5.");
                        break;
                }
            }
        } catch (Exception e) {
            // Catch any unexpected runtime exceptions
            System.err.println("An unexpected error occurred: " + e.getMessage());
            e.printStackTrace(); // Print stack trace for debugging in exam context
        } finally {
            // Ensure scanner is closed even if an exception occurs
            if (scanner != null) {
                scanner.close();
            }
        }
    }
}
