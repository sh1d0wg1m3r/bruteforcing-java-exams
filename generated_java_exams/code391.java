/*
 * Exam Question #391
 * Generated on: 2025-05-11 23:04:05
 * Generated by: Account 5
 * 
 * QUESTION:
 * **Java Programming Exam Task: Customer Support Ticket System**
 * 
 * You are tasked with developing a simplified Customer Support Ticket System. This system manages incoming support requests, allows agents to process tickets in the order they were received, and provides views of both waiting and processed tickets.
 * 
 * Your solution must demonstrate advanced understanding of core Java concepts by fulfilling the following requirements:
 * 
 * 1.  **Implement the System Logic:** Create a class (e.g., `SupportSystem`) that encapsulates the ticket management logic.
 * 2.  **Ticket Representation:** Define a class (e.g., `Ticket`) to represent a support ticket. Each ticket should have a unique ID, a description of the issue, and a status (e.g., "WAITING", "PROCESSED").
 * 3.  **Data Structures:**
 *     *   Use a `java.util.Queue` to store tickets that are waiting to be processed. Tickets should be processed in a First-In, First-Out (FIFO) manner.
 *     *   Use a `java.util.ArrayList` to store tickets that have been processed.
 *     *   Declare the variable for processed tickets using the `java.util.List` interface.
 * 4.  **User Interaction:**
 *     *   Use `java.util.Scanner` to read user commands from the console.
 *     *   Present a menu of options to the user (e.g., Add Ticket, Process Next Ticket, View Waiting Tickets, View Processed Tickets, Exit).
 *     *   Use a `switch` statement to handle the different user commands.
 * 5.  **Input and Output:**
 *     *   Use `System.out` for displaying the menu, prompts, ticket information, and confirmation messages.
 *     *   Use `System.err` to display error messages (e.g., invalid input, attempting to process a ticket when none are waiting).
 * 6.  **Exception Handling:**
 *     *   Implement class-wide exception handling using `try-catch` blocks to gracefully handle potential issues, such as invalid user input or unexpected errors during system operation.
 * 7.  **Best Practices:**
 *     *   Apply proper encapsulation (private fields, public methods).
 *     *   Use meaningful names for classes, variables, and methods.
 *     *   Include appropriate comments and documentation (e.g., Javadoc).
 *     *   Implement input validation (e.g., ensure ticket description is not empty).
 *     *   Handle edge cases (e.g., processing an empty queue).
 *     *   Ensure the `Scanner` resource is properly managed (closed).
 * 
 * **User Commands:**
 * *   `1`: Add New Ticket (prompts for description)
 * *   `2`: Process Next Ticket
 * *   `3`: View Waiting Tickets
 * *   `4`: View Processed Tickets
 * *   `5`: Exit
 * 
 * **Expected Output:**
 * The program should run continuously, displaying the menu, processing commands, and providing feedback until the user chooses to exit. Output should be clear and informative, distinguishing between normal messages (`System.out`) and errors (`System.err`).
 * 
 * **Example Interaction Snippet:**
 * 
 * ```
 * --- Support Ticket System Menu ---
 * 1. Add New Ticket
 * 2. Process Next Ticket
 * 3. View Waiting Tickets
 * 4. View Processed Tickets
 * 5. Exit
 * Enter your choice: 1
 * Enter ticket description: Internet connection issue
 * Ticket #1 added: Internet connection issue
 * 
 * --- Support Ticket System Menu ---
 * 1. Add New Ticket
 * 2. Process Next Ticket
 * 3. View Waiting Tickets
 * 4. View Processed Tickets
 * 5. Exit
 * Enter your choice: 1
 * Enter ticket description: Software crash on startup
 * Ticket #2 added: Software crash on startup
 * 
 * --- Support Ticket System Menu ---
 * 1. Add New Ticket
 * 2. Process Next Ticket
 * 3. View Waiting Tickets
 * 4. View Processed Tickets
 * 5. Exit
 * Enter your choice: 3
 * --- Waiting Tickets ---
 * Ticket #1 [WAITING]: Internet connection issue
 * Ticket #2 [WAITING]: Software crash on startup
 * 
 * --- Support Ticket System Menu ---
 * ... (user continues) ...
 * ```
 * 
 * **Constraints:**
 * *   The solution must be a single Java file for submission simplicity (Ticket class can be nested or separate public class within the file).
 * *   Focus on demonstrating the required Java components and concepts.
 *
 * EXPLANATION:
 * This solution implements a simple customer support ticket system demonstrating the required Java components and best practices.
 * 
 * 1.  **`Ticket` Class:**
 *     *   Represents a single ticket with `ticketId`, `description`, and `status`.
 *     *   Uses private fields and public getter/setter methods, adhering to **encapsulation**.
 *     *   Includes a `toString()` method for easy printing.
 * 
 * 2.  **`SupportSystem` Class:**
 *     *   This is the main class containing the system logic.
 *     *   **`Queue<Ticket> waitingTickets`**: A `java.util.Queue` (specifically `LinkedList` which implements `Queue`) is used to store tickets awaiting processing. The `poll()` method naturally enforces the **FIFO** requirement of a queue, retrieving the oldest ticket first.
 *     *   **`List<Ticket> processedTickets`**: A `java.util.ArrayList` is used to store tickets once they are processed. The variable is declared using the **`java.util.List` interface**, demonstrating good practice by programming to the interface rather than the concrete implementation.
 *     *   **`nextTicketId`**: A simple counter to generate unique ticket IDs.
 *     *   **`addTicket(String description)`**: Creates a new `Ticket` object and adds it to the `waitingTickets` queue using `offer()`. Includes **input validation** to ensure the description is not empty, throwing an `IllegalArgumentException`.
 *     *   **`processNextTicket()`**: Uses `waitingTickets.poll()` to get and remove the head of the queue. If `poll()` returns `null` (queue is empty), it prints an error using **`System.err`**. Otherwise, it updates the ticket's status and adds it to the `processedTickets` list. This handles the **edge case** of an empty queue gracefully.
 *     *   **`viewWaitingTickets()` and `viewProcessedTickets()`**: Iterate through the respective collections and print ticket details using **`System.out`**. They also check if the collections are empty and print appropriate messages.
 *     *   **`displayMenu()`**: A helper method to print the menu options using **`System.out`**.
 *     *   **`run()`**: This method contains the main application loop.
 *         *   It uses **`java.util.Scanner`** within a **try-with-resources** block to read user input from `System.in`, ensuring the scanner is automatically closed.
 *         *   A `while` loop keeps the system running until the user chooses to exit (option 5).
 *         *   Inside the loop, a **`switch` statement** is used to direct the flow based on the user's integer input, calling the appropriate methods (`addTicket`, `processNextTicket`, etc.).
 *         *   **Class-wide exception handling** is implemented using nested `try-catch` blocks within the `run` method.
 *             *   It specifically catches `InputMismatchException` for non-integer input, printing an error to **`System.err`** and consuming the invalid input.
 *             *   It catches `IllegalArgumentException` thrown by `addTicket` for empty descriptions, also printing to **`System.err`**.
 *             *   A general `catch (Exception e)` block provides a **catch-all** for any other unexpected runtime errors, demonstrating class-wide handling by reporting the error via **`System.err`**.
 *     *   **`main(String[] args)`**: The entry point of the program, creating a `SupportSystem` instance and calling its `run()` method.
 * 
 * This solution effectively integrates all required components (`Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.err`, `System.out`, `try-catch`) within a practical scenario, adhering to best practices like encapsulation, meaningful names, input validation, and error handling.
 */

import java.util.Queue;
import java.util.LinkedList;
import java.util.List;
import java.util.ArrayList;
import java.util.Scanner;
import java.util.InputMismatchException;

/**
 * Represents a customer support ticket.
 */
class Ticket {
    private int ticketId;
    private String description;
    private String status; // e.g., "WAITING", "PROCESSED"

    /**
     * Constructs a new Ticket.
     *
     * @param ticketId The unique ID for the ticket.
     * @param description The description of the issue.
     */
    public Ticket(int ticketId, String description) {
        this.ticketId = ticketId;
        this.description = description;
        this.status = "WAITING"; // New tickets are always waiting
    }

    /**
     * Gets the ticket ID.
     * @return The ticket ID.
     */
    public int getTicketId() {
        return ticketId;
    }

    /**
     * Gets the ticket description.
     * @return The ticket description.
     */
    public String getDescription() {
        return description;
    }

    /**
     * Gets the ticket status.
     * @return The ticket status.
     */
    public String getStatus() {
        return status;
    }

    /**
     * Sets the ticket status.
     * @param status The new status.
     */
    public void setStatus(String status) {
        this.status = status;
    }

    /**
     * Returns a string representation of the ticket.
     * @return A formatted string for the ticket.
     */
    @Override
    public String toString() {
        return String.format("Ticket #%d [%s]: %s", ticketId, status, description);
    }
}

/**
 * Manages customer support tickets using a queue for waiting tickets
 * and a list for processed tickets.
 */
public class SupportSystem {

    // Use Queue for waiting tickets (FIFO)
    private Queue<Ticket> waitingTickets;

    // Use List interface for processed tickets, implemented by ArrayList
    private List<Ticket> processedTickets;

    private int nextTicketId;

    /**
     * Constructs a new SupportSystem.
     * Initializes the waiting and processed ticket collections.
     */
    public SupportSystem() {
        this.waitingTickets = new LinkedList<>(); // LinkedList implements Queue
        this.processedTickets = new ArrayList<>(); // ArrayList implements List
        this.nextTicketId = 1;
    }

    /**
     * Adds a new ticket to the waiting queue.
     *
     * @param description The description of the ticket issue.
     * @throws IllegalArgumentException if the description is null or empty.
     */
    public void addTicket(String description) {
        if (description == null || description.trim().isEmpty()) {
            throw new IllegalArgumentException("Ticket description cannot be empty.");
        }
        Ticket newTicket = new Ticket(nextTicketId++, description.trim());
        waitingTickets.offer(newTicket); // offer is preferred over add for capacity-constrained queues, but works here too
        System.out.println("Ticket #" + newTicket.getTicketId() + " added: " + newTicket.getDescription());
    }

    /**
     * Processes the next ticket in the waiting queue.
     * Moves the ticket from the waiting queue to the processed list.
     */
    public void processNextTicket() {
        Ticket ticketToProcess = waitingTickets.poll(); // poll retrieves and removes the head
        if (ticketToProcess == null) {
            System.err.println("No tickets waiting to be processed.");
        } else {
            ticketToProcess.setStatus("PROCESSED");
            processedTickets.add(ticketToProcess);
            System.out.println("Processed ticket #" + ticketToProcess.getTicketId() + ": " + ticketToProcess.getDescription());
        }
    }

    /**
     * Displays all tickets currently in the waiting queue.
     */
    public void viewWaitingTickets() {
        System.out.println("--- Waiting Tickets ---");
        if (waitingTickets.isEmpty()) {
            System.out.println("No tickets currently waiting.");
        } else {
            // Iterate without removing elements
            for (Ticket ticket : waitingTickets) {
                System.out.println(ticket);
            }
        }
    }

    /**
     * Displays all tickets that have been processed.
     */
    public void viewProcessedTickets() {
        System.out.println("--- Processed Tickets ---");
        if (processedTickets.isEmpty()) {
            System.out.println("No tickets have been processed yet.");
        } else {
            for (Ticket ticket : processedTickets) {
                System.out.println(ticket);
            }
        }
    }

    /**
     * Displays the main menu options to the user.
     */
    private void displayMenu() {
        System.out.println("\n--- Support Ticket System Menu ---");
        System.out.println("1. Add New Ticket");
        System.out.println("2. Process Next Ticket");
        System.out.println("3. View Waiting Tickets");
        System.out.println("4. View Processed Tickets");
        System.out.println("5. Exit");
        System.out.print("Enter your choice: ");
    }

    /**
     * Runs the main loop of the Support System, handling user interaction.
     * Includes class-wide exception handling.
     */
    public void run() {
        // Use try-with-resources for Scanner to ensure it's closed
        try (Scanner scanner = new Scanner(System.in)) {
            int choice = 0;
            while (choice != 5) {
                displayMenu();
                try {
                    choice = scanner.nextInt();
                    scanner.nextLine(); // Consume newline left-over

                    // Switch statement for flow control
                    switch (choice) {
                        case 1:
                            System.out.print("Enter ticket description: ");
                            String description = scanner.nextLine();
                            addTicket(description); // addTicket handles empty description validation
                            break;
                        case 2:
                            processNextTicket();
                            break;
                        case 3:
                            viewWaitingTickets();
                            break;
                        case 4:
                            viewProcessedTickets();
                            break;
                        case 5:
                            System.out.println("Exiting Support Ticket System. Goodbye!");
                            break;
                        default:
                            System.err.println("Invalid choice. Please enter a number between 1 and 5.");
                    }
                } catch (InputMismatchException e) {
                    // Catch specific exception for non-integer input
                    System.err.println("Invalid input. Please enter a number.");
                    scanner.nextLine(); // Consume the invalid input to prevent infinite loop
                } catch (IllegalArgumentException e) {
                    // Catch specific exception from addTicket validation
                    System.err.println("Error: " + e.getMessage());
                } catch (Exception e) {
                    // General catch-all for unexpected errors (class-wide handling)
                    System.err.println("An unexpected error occurred: " + e.getMessage());
                    e.printStackTrace(); // Optional: print stack trace for debugging
                }
            }
        } // Scanner is automatically closed here by try-with-resources
    }

    /**
     * Main method to start the Support System application.
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        SupportSystem system = new SupportSystem();
        system.run();
    }
}
