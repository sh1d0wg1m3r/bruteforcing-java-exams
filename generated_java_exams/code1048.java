/*
 * Exam Question #1048
 * Generated on: 2025-05-12 17:17:33
 * Generated by: Account 2
 * 
 * QUESTION:
 * ## Advanced Java Programming Exam Task: Simple Task Management System
 * 
 * **Scenario:**
 * 
 * You are tasked with building a command-line application for a small team to manage their work tasks. The system needs to handle task creation, track tasks in a pending queue, allow starting the next task from the queue, and mark tasks as completed. The system should be robust against common user input errors.
 * 
 * **Requirements:**
 * 
 * 1.  **Task Representation:** Create a `Task` class with private fields for `id` (int), `description` (String), and `status` (use an `enum` like `TaskStatus { PENDING, IN_PROGRESS, COMPLETED }`). Include a constructor, appropriate getters, and a setter for the status. Implement a meaningful `toString()` method.
 * 2.  **Task Management:** Create a `TaskManager` class.
 *     *   It must maintain **two** main collections:
 *         *   A `List<Task>` (implemented using `ArrayList`) to store *all* tasks ever created.
 *         *   A `Queue<Task>` (implemented using a class that implements `Queue`, like `LinkedList`) to store tasks that are currently in the `PENDING` state and waiting to be started.
 *     *   Implement methods:
 *         *   `addTask(String description)`: Creates a new `Task` (assigning a unique ID), adds it to the `ArrayList` and the `Queue`.
 *         *   `startNextPendingTask()`: Retrieves and removes the next task from the `Queue`. If successful, find this task in the `ArrayList` and update its status to `IN_PROGRESS`. Handle the case where the queue is empty. If a task retrieved from the queue is found to be already completed or in progress in the main list, skip it and try the next one in the queue until a truly pending task is found or the queue is exhausted.
 *         *   `completeTask(int taskId)`: Finds the task with the given ID in the `ArrayList` and updates its status to `COMPLETED`. Handle the case where the task ID is not found or is already completed.
 *         *   `displayAllTasks()`: Prints details of all tasks in the `ArrayList`.
 *         *   `displayPendingTasks()`: Prints details of all tasks currently in the `Queue` (without removing them).
 * 3.  **User Interface:** Implement a command-line interface in the `main` method of the `TaskManager` class.
 *     *   Use `java.util.Scanner` to read user input from the console.
 *     *   Present a menu of options to the user (Add Task, Start Next Pending, Complete Task, View All, View Pending, Exit).
 *     *   Use a `switch` statement to handle the user's menu choice.
 *     *   Use `System.out` for displaying the menu, prompts, and successful operation messages/task listings.
 *     *   Use `System.err` for displaying error messages (e.g., invalid input, task not found, queue empty).
 * 4.  **Error Handling:**
 *     *   Implement input validation for menu choices and task IDs (ensure they are numbers).
 *     *   Handle cases where the user tries to start a task when the queue is empty.
 *     *   Handle cases where the user tries to complete a task with an ID that does not exist or is already completed.
 *     *   Implement **class-wide exception handling** using `try-catch` blocks in the `main` method to gracefully handle potential runtime errors, such as `InputMismatchException` during input reading.
 * 5.  **Best Practices:**
 *     *   Use private fields and public methods for proper encapsulation.
 *     *   Use meaningful variable and method names.
 *     *   Include appropriate comments and documentation (e.g., Javadoc for classes and methods).
 *     *   Ensure clean code structure.
 * 
 * **Expected Output:**
 * 
 * The program should run interactively, displaying a menu, accepting user input, performing the requested action, and providing feedback or error messages as appropriate. Task listings should clearly show the ID, description, and status. Error messages must be printed to standard error (`System.err`).
 * 
 * Example interaction snippets:
 * 
 * ```
 * --- Simple Task Management System ---
 * 
 * Choose an action:
 * 1. Add New Task
 * 2. Start Next Pending Task
 * 3. Complete Task by ID
 * 4. View All Tasks
 * 5. View Pending Tasks Queue
 * 6. Exit
 * Enter choice: 1
 * Enter task description: Implement Task Class
 * Task added: Task [ID=1, Description='Implement Task Class', Status=PENDING]
 * 
 * Choose an action:
 * ... menu options ...
 * Enter choice: 1
 * Enter task description: Create TaskManager
 * Task added: Task [ID=2, Description='Create TaskManager', Status=PENDING]
 * 
 * Choose an action:
 * ... menu options ...
 * Enter choice: 5
 * --- Pending Tasks Queue ---
 * Task [ID=1, Description='Implement Task Class', Status=PENDING]
 * Task [ID=2, Description='Create TaskManager', Status=PENDING]
 * ---------------------------
 * 
 * Choose an action:
 * ... menu options ...
 * Enter choice: 2
 * Started next pending task: Task [ID=1, Description='Implement Task Class', Status=IN_PROGRESS]
 * 
 * Choose an action:
 * ... menu options ...
 * Enter choice: 5
 * --- Pending Tasks Queue ---
 * Task [ID=2, Description='Create TaskManager', Status=PENDING]
 * ---------------------------
 * 
 * Choose an action:
 * ... menu options ...
 * Enter choice: 4
 * --- All Tasks ---
 * Task [ID=1, Description='Implement Task Class', Status=IN_PROGRESS]
 * Task [ID=2, Description='Create TaskManager', Status=PENDING]
 * -----------------
 * 
 * Choose an action:
 * ... menu options ...
 * Enter choice: 3
 * Enter ID of task to complete: 1
 * Task completed: Task [ID=1, Description='Implement Task Class', Status=COMPLETED]
 * 
 * Choose an action:
 * ... menu options ...
 * Enter choice: 4
 * --- All Tasks ---
 * Task [ID=1, Description='Implement Task Class', Status=COMPLETED]
 * Task [ID=2, Description='Create TaskManager', Status=PENDING]
 * -----------------
 * 
 * Choose an action:
 * ... menu options ...
 * Enter choice: 3
 * Enter ID of task to complete: 99
 * Error: Task with ID 99 not found. // Printed to System.err
 * 
 * Choose an action:
 * ... menu options ...
 * Enter choice: 2
 * Started next pending task: Task [ID=2, Description='Create TaskManager', Status=IN_PROGRESS]
 * 
 * Choose an action:
 * ... menu options ...
 * Enter choice: 2
 * Error: No pending tasks in the queue to start. // Printed to System.err
 * 
 * Choose an action:
 * ... menu options ...
 * Enter choice: invalid_input
 * Error: Invalid input. Please enter a number from the menu. // Printed to System.err
 * 
 * Choose an action:
 * ... menu options ...
 * Enter choice: 6
 * Exiting Task Management System. Goodbye!
 * System terminated.
 * ```
 * 
 * Your solution should be provided as a single Java file containing all necessary classes and the `main` method.
 *
 * EXPLANATION:
 * The provided solution implements a simple command-line Task Management System, demonstrating the required Java concepts and best practices.
 * 
 * **Key Components and Concepts Demonstrated:**
 * 
 * 1.  **`java.util.Queue`:** The `pendingTasks` field in the `TaskManager` class is declared as a `Queue<Task>` and initialized using `java.util.LinkedList`. `LinkedList` is a common implementation of the `Queue` interface. The `addTask` method uses `offer()` to add tasks to the end of the queue, and `startNextPendingTask` uses `poll()` to retrieve and remove tasks from the front of the queue, simulating a FIFO (First-In, First-Out) processing order for pending tasks. The `displayPendingTasks` method iterates through the queue using an enhanced for loop, which utilizes the queue's iterator without removing elements.
 * 2.  **`java.util.ArrayList`:** The `allTasks` field in the `TaskManager` class is declared as a `List<Task>` and initialized using `java.util.ArrayList`. This list is used to store a record of every task created in the system, regardless of its current status.
 * 3.  **`java.util.List` interface:** The `allTasks` variable is explicitly declared using the `List` interface type (`List<Task>`), demonstrating polymorphism and programming to interfaces, which is a core Java best practice.
 * 4.  **`java.util.Scanner`:** A `Scanner` object is used in the `main` method to read user input from `System.in`, enabling interactive use of the command-line application. The `try-with-resources` statement ensures the scanner is properly closed.
 * 5.  **`switch` statement:** A `switch` statement in the `main` method is used to control the program flow based on the user's integer choice from the menu, directing execution to the appropriate task management method.
 * 6.  **`System.err`:** `System.err.println()` is used to output error messages, such as invalid menu choices, non-integer inputs, attempting operations on non-existent tasks, or trying to start a task when the queue is empty. This distinguishes error output from normal program output.
 * 7.  **`System.out`:** `System.out.println()` is used for all standard program output, including the menu, prompts for input, confirmation messages for successful operations, and task listings.
 * 8.  **Class-wide exception handling with `try-catch` blocks:** The main `while` loop containing the program's core logic is wrapped in a `try-catch` block within the `try-with-resources` statement for the `Scanner`. This block catches `InputMismatchException` (for invalid numerical input) and a general `Exception` (for any other unexpected runtime errors), providing a robust, top-level safety net for the application's main execution flow as required.
 * 
 * **Best Practices Implementation:**
 * 
 * *   **Encapsulation:** The `Task` and `TaskManager` classes use private fields (`id`, `description`, `status`, `allTasks`, `pendingTasks`, `nextTaskId`) and provide public methods (`getId`, `getDescription`, `getStatus`, `setStatus`, `addTask`, etc.) to control access and modification of their internal state. The `findTaskById` helper method is private as it's only used internally by `TaskManager`.
 * *   **Meaningful Variable and Method Names:** Names like `allTasks`, `pendingTasks`, `addTask`, `startNextPendingTask`, `completeTask`, `displayAllTasks`, `displayPendingTasks`, `nextTaskId`, `taskToComplete`, etc., clearly indicate the purpose of each element.
 * *   **Appropriate Comments and Documentation:** Javadoc comments are used for classes and public methods to explain their purpose, parameters, and return values. Inline comments clarify specific logic points (e.g., the `startNextPendingTask` loop or the `completeTask` queue note).
 * *   **Input Validation:** The code checks if user input is an integer using `scanner.hasNextInt()` before attempting to read it with `nextInt()`. It also validates that the task description is not empty and that a task ID exists and is not already completed before attempting to complete it.
 * *   **Proper Error Handling:** Specific conditions (empty queue, task not found, invalid input format, invalid menu choice) are checked, and informative error messages are printed to `System.err`. The refined `startNextPendingTask` logic robustly handles tasks that might be completed while still in the queue by skipping them.
 * *   **Clean Code Structure:** The code is organized into separate classes (`Task`, `TaskManager`) and an enum (`TaskStatus`), each with a clear responsibility. The `main` method orchestrates the user interaction by calling methods on a `TaskManager` instance.
 * 
 * This solution effectively combines fundamental data structures (`List`, `Queue`), control flow (`switch`, loops), user interaction (`Scanner`, `System.out`, `System.err`), object-oriented principles (classes, encapsulation, enums), and robust error handling (`try-catch`, input validation) to solve a practical problem within a command-line environment, meeting all the specified requirements for the exam task.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.InputMismatchException;

// Enum to represent the status of a task.
enum TaskStatus {
    PENDING,      // Task is waiting to be started
    IN_PROGRESS,  // Task is currently being worked on
    COMPLETED     // Task has been finished
}

/**
 * Represents a single task in the task management system.
 */
class Task {
    private int id;
    private String description;
    private TaskStatus status;

    /**
     * Constructs a new Task with a unique ID and description.
     * New tasks are initialized with PENDING status.
     *
     * @param id The unique identifier for the task.
     * @param description A brief description of the task.
     */
    public Task(int id, String description) {
        this.id = id;
        this.description = description;
        this.status = TaskStatus.PENDING; // New tasks start as PENDING
    }

    // --- Getters ---
    public int getId() {
        return id;
    }

    public String getDescription() {
        return description;
    }

    public TaskStatus getStatus() {
        return status;
    }

    // --- Setter ---
    /**
     * Sets the status of the task.
     *
     * @param status The new status for the task.
     */
    public void setStatus(TaskStatus status) {
        this.status = status;
    }

    /**
     * Provides a string representation of the Task object.
     *
     * @return A formatted string showing task ID, description, and status.
     */
    @Override
    public String toString() {
        return "Task [ID=" + id + ", Description='" + description + "', Status=" + status + "]";
    }
}

/**
 * Manages a collection of tasks using a List for all tasks
 * and a Queue for tasks that are pending.
 */
public class TaskManager {
    // List to hold all tasks ever created. Using ArrayList as required.
    private List<Task> allTasks;
    // Queue to hold tasks that are currently pending and ready to be started.
    // Using LinkedList which implements Queue.
    private Queue<Task> pendingTasks;
    // Counter for assigning unique task IDs.
    private int nextTaskId;

    /**
     * Constructs a new TaskManager, initializing the task collections
     * and the task ID counter.
     */
    public TaskManager() {
        this.allTasks = new ArrayList<>();
        this.pendingTasks = new LinkedList<>(); // LinkedList implements Queue
        this.nextTaskId = 1; // Start task IDs from 1
    }

    /**
     * Adds a new task to the system.
     * The task is added to the list of all tasks and the pending queue.
     *
     * @param description The description of the task. Must not be null or empty.
     */
    public void addTask(String description) {
        if (description == null || description.trim().isEmpty()) {
            System.err.println("Error: Task description cannot be empty.");
            return;
        }
        Task newTask = new Task(nextTaskId++, description.trim());
        allTasks.add(newTask); // Add to the list of all tasks
        pendingTasks.offer(newTask); // Add to the end of the pending queue
        System.out.println("Task added: " + newTask);
    }

    /**
     * Attempts to start the next task from the pending queue.
     * If a task is retrieved from the queue, its status is updated to IN_PROGRESS
     * in the main list. Skips tasks in the queue that are no longer PENDING
     * in the main list.
     */
    public void startNextPendingTask() {
        Task taskToProcessFromQueue = null;
        Task actualTaskInList = null;

        // Poll tasks from the queue until a truly PENDING task is found or the queue is empty
        while (true) {
            taskToProcessFromQueue = pendingTasks.poll(); // Get and remove the head of the queue

            if (taskToProcessFromQueue == null) {
                // Queue is empty, no pending tasks to start
                System.err.println("Error: No pending tasks in the queue to start.");
                return;
            }

            // Find the corresponding task in the allTasks list to check its current status
            actualTaskInList = findTaskById(taskToProcessFromQueue.getId());

            if (actualTaskInList == null) {
                // This indicates an inconsistency (task in queue but not in list)
                // Should ideally not happen with correct logic, but handle defensively.
                System.err.println("Internal Error: Task polled from queue (ID " + taskToProcessFromQueue.getId() + ") not found in all tasks list.");
                // Continue the loop to try the next task in the queue
            } else if (actualTaskInList.getStatus() == TaskStatus.PENDING) {
                // Found a task in the queue that is genuinely PENDING in the main list
                break; // Exit the while loop, this is the task to start
            } else {
                // The task is in the queue, but its status in the main list is
                // already IN_PROGRESS or COMPLETED (e.g., completed directly).
                // Skip this task and continue polling the next one from the queue.
                System.out.println("Skipping task ID " + actualTaskInList.getId() + " from queue as its status is " + actualTaskInList.getStatus());
            }
        }

        // 'actualTaskInList' is now a valid PENDING task retrieved from the queue
        actualTaskInList.setStatus(TaskStatus.IN_PROGRESS); // Update its status in the main list
        System.out.println("Started next pending task: " + actualTaskInList);
    }

    /**
     * Marks a task as completed by its ID.
     * Finds the task in the main list and updates its status.
     *
     * @param taskId The ID of the task to complete.
     */
    public void completeTask(int taskId) {
        Task taskToComplete = findTaskById(taskId); // Find the task in the main list

        if (taskToComplete == null) {
            System.err.println("Error: Task with ID " + taskId + " not found.");
            return;
        }

        if (taskToComplete.getStatus() == TaskStatus.COMPLETED) {
             System.out.println("Task with ID " + taskId + " is already completed.");
             return;
        }

        taskToComplete.setStatus(TaskStatus.COMPLETED); // Update status
        System.out.println("Task completed: " + taskToComplete);

        // Note: A task is removed from the 'pendingTasks' queue only when
        // startNextPendingTask() is called. If a task is completed directly
        // while still in the queue, it will remain in the queue until polled,
        // but startNextPendingTask() is designed to skip such tasks.
    }

    /**
     * Finds a task in the allTasks list by its ID.
     * This is a helper method for internal use.
     *
     * @param taskId The ID to search for.
     * @return The Task object if found, otherwise null.
     */
    private Task findTaskById(int taskId) {
        // Iterate through the ArrayList to find the task by ID
        for (Task task : allTasks) {
            if (task.getId() == taskId) {
                return task;
            }
        }
        return null; // Task not found
    }

    /**
     * Displays all tasks currently in the system (from the main list).
     */
    public void displayAllTasks() {
        System.out.println("\n--- All Tasks ---");
        if (allTasks.isEmpty()) {
            System.out.println("No tasks created yet.");
        } else {
            // Iterate and print all tasks from the ArrayList
            for (Task task : allTasks) {
                System.out.println(task);
            }
        }
        System.out.println("-----------------");
    }

    /**
     * Displays tasks currently residing in the pending queue.
     * Iterates through the queue without removing elements.
     */
    public void displayPendingTasks() {
        System.out.println("\n--- Pending Tasks Queue ---");
        if (pendingTasks.isEmpty()) {
            System.out.println("Pending queue is empty.");
        } else {
            // Iterate through the Queue using an enhanced for loop (uses iterator internally)
            // This allows viewing elements without removing them (unlike poll/remove).
            for (Task task : pendingTasks) {
                System.out.println(task);
            }
        }
        System.out.println("---------------------------");
    }

    /**
     * The main entry point for the Task Management System application.
     * Handles the user interface and interaction loop.
     *
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        TaskManager manager = new TaskManager();
        // Using try-with-resources to ensure scanner is closed.
        // This structure provides the "class-wide" try-catch around the main logic loop.
        try (Scanner scanner = new Scanner(System.in)) {
            boolean running = true;

            System.out.println("--- Simple Task Management System ---");

            while (running) {
                System.out.println("\nChoose an action:");
                System.out.println("1. Add New Task");
                System.out.println("2. Start Next Pending Task");
                System.out.println("3. Complete Task by ID");
                System.out.println("4. View All Tasks");
                System.out.println("5. View Pending Tasks Queue");
                System.out.println("6. Exit");
                System.out.print("Enter choice: ");

                try {
                    // Check if the next input is an integer before reading
                    if (!scanner.hasNextInt()) {
                        System.err.println("Error: Invalid input. Please enter a number from the menu.");
                        scanner.next(); // Consume the invalid non-integer input
                        continue; // Skip the rest of the loop iteration
                    }

                    int choice = scanner.nextInt();
                    // Consume the rest of the line, including the newline character
                    // left after reading the integer. This is crucial before
                    // reading a full line description later.
                    scanner.nextLine();

                    // Use a switch statement to handle different menu options
                    switch (choice) {
                        case 1:
                            System.out.print("Enter task description: ");
                            String description = scanner.nextLine();
                            manager.addTask(description); // addTask handles empty check
                            break;
                        case 2:
                            manager.startNextPendingTask();
                            break;
                        case 3:
                            System.out.print("Enter ID of task to complete: ");
                            // Validate if the next input for ID is an integer
                            if (!scanner.hasNextInt()) {
                                System.err.println("Error: Invalid input. Please enter a task ID (a number).");
                                scanner.next(); // Consume invalid input
                                scanner.nextLine(); // Consume rest of the line
                            } else {
                                int taskIdToComplete = scanner.nextInt();
                                scanner.nextLine(); // Consume newline
                                manager.completeTask(taskIdToComplete);
                            }
                            break;
                        case 4:
                            manager.displayAllTasks();
                            break;
                        case 5:
                            manager.displayPendingTasks();
                            break;
                        case 6:
                            System.out.println("Exiting Task Management System. Goodbye!");
                            running = false; // Set flag to exit the loop
                            break;
                        default:
                            // Handle choices outside the valid range
                            System.err.println("Error: Invalid choice. Please enter a number between 1 and 6.");
                    }
                } catch (InputMismatchException e) {
                    // This catch block is primarily for demonstrating the requirement
                    // of class-wide try-catch. The specific hasNextInt() checks
                    // inside the switch handle most input mismatches more granularly.
                    System.err.println("Error: Invalid input type encountered. Please follow the input instructions.");
                    // Consume the invalid input if it wasn't consumed by hasNextInt check
                    if (scanner.hasNext()) { // Prevent NoSuchElementException if stream is empty
                         scanner.next();
                    }
                } catch (Exception e) {
                    // Catch any other unexpected exceptions during operation processing
                    System.err.println("An unexpected error occurred: " + e.getMessage());
                    e.printStackTrace(); // Print stack trace for debugging unexpected issues
                }
            }
        } // Scanner is automatically closed here by try-with-resources
        System.out.println("System terminated."); // Optional: indicate program end
    }
}
