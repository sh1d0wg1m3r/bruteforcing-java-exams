/*
 * Exam Question #801
 * Generated on: 2025-05-12 16:42:47
 * Generated by: Account 3
 * 
 * QUESTION:
 * ## Advanced Java Programming Exam: Task Management System
 * 
 * **Scenario:**
 * 
 * You are tasked with building a simplified command-line Task Management System for a small project team. The system needs to handle tasks with different priorities and manage their lifecycle. High-priority tasks must be addressed before low-priority tasks. The system should allow users to add tasks, process the next available task, view all tasks, and exit.
 * 
 * **Requirements:**
 * 
 * 1.  **Task Representation:** Create a `Task` class with the following attributes:
 *     *   `taskId` (int): A unique identifier, automatically generated.
 *     *   `description` (String): A brief description of the task.
 *     *   `priority` (enum `Priority`): Can be `HIGH` or `LOW`.
 *     *   `status` (enum `Status`): Can be `PENDING`, `IN_PROGRESS`, or `COMPLETED`.
 *     *   Implement proper encapsulation (private fields, public getters).
 * 
 * 2.  **Task Management:** Create a `TaskManager` class responsible for managing the tasks.
 *     *   It must use a `java.util.Queue<Task>` to hold high-priority tasks that are ready for processing.
 *     *   It must use a `java.util.List<Task>` (specifically, an `ArrayList`) to store *all* tasks created in the system, regardless of their current status or whether they are in the processing queue. The reference should be declared as the `List` interface type.
 *     *   Implement methods for:
 *         *   `addTask(String description, Priority priority)`: Creates a new `Task`, adds it to the main `ArrayList`. If the priority is `HIGH`, also add it to the `Queue`. Assign a unique `taskId`.
 *         *   `processNextTask()`:
 *             *   Check the `Queue` first. If it's not empty, poll the next `Task` from the queue.
 *             *   If the `Queue` is empty, find the *oldest* `PENDING` task in the `ArrayList`. "Oldest" here means the one with the smallest `taskId` among the `PENDING` tasks.
 *             *   If a task is found (either from the queue or the list), update its `status` to `IN_PROGRESS` within the main `ArrayList`. Return the processed `Task` object.
 *             *   If no tasks are available for processing (queue empty and no PENDING tasks in the list), return `null`.
 *         *   `getAllTasks()`: Returns the `List` containing all tasks.
 *         *   `getHighPriorityQueue()`: Returns the `Queue` of high-priority tasks waiting.
 * 
 * 3.  **User Interface:** Implement a command-line interface in a `main` method (e.g., in a class named `TaskManagementApp`).
 *     *   Use `java.util.Scanner` to read user input.
 *     *   Present a menu of options:
 *         *   `1. Add New Task`
 *         *   `2. Process Next Task`
 *         *   `3. View All Tasks`
 *         *   `4. Exit`
 *     *   Use a `switch` statement to handle the user's choice.
 *     *   Implement input validation:
 *         *   For adding a task, ensure the description is not empty and the priority input is valid (`HIGH` or `LOW`). Use `System.err` for invalid input messages.
 *     *   Use `System.out` for menu prompts, successful operations, and displaying task information.
 *     *   Use `System.err` for displaying error messages (e.g., invalid input, no tasks to process).
 *     *   Implement class-wide exception handling using a `try-catch` block around the main application loop to catch unexpected errors and print an error message to `System.err`.
 * 
 * 4.  **Best Practices:**
 *     *   Use meaningful variable and method names.
 *     *   Include appropriate comments and documentation (JavaDocs where suitable).
 *     *   Ensure resources like `Scanner` are closed properly.
 * 
 * **Expected Output:**
 * 
 * The program should interact with the user, displaying prompts and output based on their choices. Examples:
 * 
 * ```
 * Task Management System Menu:
 * 1. Add New Task
 * 2. Process Next Task
 * 3. View All Tasks
 * 4. Exit
 * Enter your choice: 1
 * Enter task description: Implement login feature
 * Enter priority (HIGH/LOW): HIGH
 * Task added: [ID: 1, Desc: Implement login feature, Priority: HIGH, Status: PENDING]
 * 
 * Task Management System Menu:
 * ...
 * Enter your choice: 2
 * Processing next task...
 * Processed Task: [ID: 1, Desc: Implement login feature, Priority: HIGH, Status: IN_PROGRESS]
 * 
 * Task Management System Menu:
 * ...
 * Enter your choice: 3
 * --- All Tasks ---
 * [ID: 1, Desc: Implement login feature, Priority: HIGH, Status: IN_PROGRESS]
 * [ID: 2, Desc: Write documentation, Priority: LOW, Status: PENDING]
 * --- High Priority Queue ---
 * (Empty)
 * 
 * Task Management System Menu:
 * ...
 * Enter your choice: 2
 * Processing next task...
 * Processed Task: [ID: 2, Desc: Write documentation, Priority: LOW, Status: IN_PROGRESS]
 * 
 * Task Management System Menu:
 * ...
 * Enter your choice: 2
 * System.err: No tasks available for processing.
 * 
 * Task Management System Menu:
 * ...
 * Enter your choice: 5
 * System.err: Invalid choice. Please enter a number between 1 and 4.
 * 
 * Task Management System Menu:
 * ...
 * Enter your choice: 4
 * Exiting Task Management System.
 * ```
 * 
 * **Constraints:**
 * 
 * *   You must use `java.util.Queue`, `java.util.ArrayList`, `java.util.List`, `java.util.Scanner`, `switch`, `System.err`, `System.out`, and `try-catch` as specified.
 * *   The solution should be contained within one or more `.java` files that compile and run together.
 * 
 * Good luck!
 *
 * EXPLANATION:
 * This solution implements a simple command-line Task Management System using the specified Java components and best practices.
 * 
 * 1.  **Task Class:**
 *     *   Represents the core data unit (`Task`).
 *     *   Uses `private` fields (`taskId`, `description`, `priority`, `status`) for encapsulation.
 *     *   Provides `public` getter methods.
 *     *   Includes a `static` counter (`nextId`) to ensure unique task IDs are generated automatically.
 *     *   Uses `enum`s (`Priority`, `Status`) for clear and type-safe state representation.
 *     *   The constructor includes basic input validation for the description.
 *     *   `toString()` is overridden for easy printing of task details.
 * 
 * 2.  **TaskManager Class:**
 *     *   Manages the collection of `Task` objects.
 *     *   Uses a `java.util.List<Task>` declared as the `List` interface type (`allTasks`) to store *all* tasks ever created. An `ArrayList` is used as the concrete implementation.
 *     *   Uses a `java.util.Queue<Task>` declared as the `Queue` interface type (`highPriorityQueue`) specifically for `HIGH` priority tasks waiting to be processed. `LinkedList` is a common `Queue` implementation used here.
 *     *   `addTask`: Creates a new `Task`, adds it to `allTasks`, and conditionally adds it to `highPriorityQueue` if its priority is `HIGH`.
 *     *   `processNextTask`: Implements the core processing logic. It first attempts to `poll()` a task from `highPriorityQueue`. If the queue is empty, it iterates through `allTasks`, filters for `PENDING` tasks, and uses a `Comparator` to find the one with the smallest `taskId` (the oldest). If a task is found (from either source), its `status` is updated to `IN_PROGRESS` directly on the `Task` object reference stored in `allTasks`.
 *     *   `getAllTasks` and `getHighPriorityQueue`: Provide access to the internal data structures. (Note: In a more robust system, these might return copies or unmodifiable views).
 *     *   `displayAllTasks`: A helper method to print the contents of both the main list and the high-priority queue.
 * 
 * 3.  **TaskManagementApp Class (main method):**
 *     *   Contains the main application logic and user interface.
 *     *   Uses `java.util.Scanner` to get input from the console. A `try-with-resources` block ensures the scanner is closed automatically.
 *     *   The main application loop (`while(running)`) is wrapped in a `try-catch(Exception e)` block, fulfilling the "class-wide exception handling" requirement. This catches any unexpected runtime errors that might occur within the loop.
 *     *   A `switch` statement handles the different menu options provided to the user.
 *     *   **Input Validation:**
 *         *   It checks if the user's menu choice is an integer using `scanner.hasNextInt()`.
 *         *   It checks if the task description is empty using `trim().isEmpty()`.
 *         *   It uses a loop and `try-catch(IllegalArgumentException)` around `Priority.valueOf()` to validate the priority input, prompting the user until valid input is received.
 *     *   `System.out` is used for normal program output (menu, prompts, success messages, task details).
 *     *   `System.err` is used specifically for error messages (invalid input, no tasks to process, unexpected exceptions).
 *     *   The `scanner.nextLine()` call after `scanner.nextInt()` is crucial to consume the leftover newline character, preventing issues in subsequent `scanner.nextLine()` calls.
 * 
 * **Key Concepts Demonstrated:**
 * 
 * *   **Object-Oriented Programming:** Using classes (`Task`, `TaskManager`) to model real-world entities and their responsibilities.
 * *   **Encapsulation:** Protecting internal state using `private` fields and providing controlled access via `public` methods.
 * *   **Data Structures:** Effective use of `ArrayList` (implementing `List`) for general storage and `LinkedList` (implementing `Queue`) for specific processing order requirements (FIFO for high priority, or as a priority queue). Demonstrating the use of interface types (`List`, `Queue`).
 * *   **Enums:** Using `enum`s for defining a fixed set of constants (`Priority`, `Status`), improving code readability and preventing invalid values.
 * *   **Control Flow:** Using `switch` statements for multi-way branching based on user input. Using `while` loops for continuous operation and input validation.
 * *   **Input/Output:** Reading user input with `Scanner` and writing output to `System.out` and `System.err`.
 * *   **Exception Handling:** Using `try-catch` blocks for both specific input validation errors (`IllegalArgumentException` caught internally or propagated) and general class-wide error handling for robustness. Using `try-with-resources` for resource management (`Scanner`).
 * *   **Stream API (Optional but used):** The `processNextTask` method uses Java Streams (`allTasks.stream().filter(...).min(...)`) to concisely find the oldest pending task. This demonstrates a more modern Java feature for collection processing.
 * *   **Comparator:** Used with the Stream API to define the criteria for finding the "oldest" task based on `taskId`.
 * 
 * This solution effectively integrates the required Java components into a functional application, demonstrating understanding of data structures, control flow, object-oriented principles, and error handling.
 */

import java.util.ArrayList;
import java.util.LinkedList; // LinkedList is a common implementation for Queue
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.Comparator; // Needed for finding the oldest PENDING task

// Enum for Task Priority
enum Priority {
    HIGH, LOW
}

// Enum for Task Status
enum Status {
    PENDING, IN_PROGRESS, COMPLETED // Added COMPLETED for potential future use, but IN_PROGRESS is key here
}

// Represents a single task
class Task {
    private static int nextId = 1; // Static counter for unique IDs

    private int taskId;
    private String description;
    private Priority priority;
    private Status status;

    public Task(String description, Priority priority) {
        // Input validation for description
        if (description == null || description.trim().isEmpty()) {
            throw new IllegalArgumentException("Task description cannot be empty.");
        }
        this.taskId = nextId++; // Assign unique ID and increment counter
        this.description = description.trim(); // Trim whitespace
        this.priority = priority;
        this.status = Status.PENDING; // New tasks start as PENDING
    }

    // Getters
    public int getTaskId() {
        return taskId;
    }

    public String getDescription() {
        return description;
    }

    public Priority getPriority() {
        return priority;
    }

    public Status getStatus() {
        return status;
    }

    // Setter for status (used by TaskManager)
    public void setStatus(Status status) {
        this.status = status;
    }

    @Override
    public String toString() {
        return "[ID: " + taskId + ", Desc: " + description + ", Priority: " + priority + ", Status: " + status + "]";
    }
}

// Manages the collection and processing of tasks
class TaskManager {
    // Use List interface type, implemented by ArrayList
    private List<Task> allTasks;
    // Use Queue interface type, implemented by LinkedList
    private Queue<Task> highPriorityQueue;

    public TaskManager() {
        this.allTasks = new ArrayList<>();
        this.highPriorityQueue = new LinkedList<>(); // LinkedList implements Queue
    }

    /**
     * Adds a new task to the system.
     * If high priority, also adds it to the processing queue.
     *
     * @param description The task description.
     * @param priority    The task priority (HIGH or LOW).
     * @throws IllegalArgumentException if description is empty.
     */
    public void addTask(String description, Priority priority) {
        try {
            Task newTask = new Task(description, priority);
            allTasks.add(newTask); // Always add to the main list
            if (priority == Priority.HIGH) {
                highPriorityQueue.offer(newTask); // Add to queue if high priority
                System.out.println("Task added to list and high priority queue: " + newTask);
            } else {
                System.out.println("Task added to list: " + newTask);
            }
        } catch (IllegalArgumentException e) {
            // Re-throw or handle as appropriate; here we'll let the caller handle it
            throw e;
        }
    }

    /**
     * Processes the next available task.
     * Prioritizes tasks in the high priority queue.
     * If queue is empty, finds the oldest PENDING task in the main list.
     * Updates the status of the processed task in the main list.
     *
     * @return The task that was processed, or null if no tasks are available.
     */
    public Task processNextTask() {
        Task taskToProcess = null;

        // 1. Check the high priority queue first
        if (!highPriorityQueue.isEmpty()) {
            taskToProcess = highPriorityQueue.poll(); // Get and remove from queue
            System.out.println("Processing task from high priority queue...");
        } else {
            // 2. If queue is empty, find the oldest PENDING task in the list
            System.out.println("High priority queue is empty. Searching for oldest PENDING task...");
            // Find the oldest PENDING task (smallest taskId)
            taskToProcess = allTasks.stream()
                                    .filter(t -> t.getStatus() == Status.PENDING)
                                    .min(Comparator.comparingInt(Task::getTaskId))
                                    .orElse(null); // Returns null if no PENDING tasks found
            if (taskToProcess != null) {
                 System.out.println("Found oldest PENDING task in list.");
            }
        }

        // 3. If a task was found, update its status in the main list
        if (taskToProcess != null) {
            // Find the task in the allTasks list by its ID and update its status
            // (Note: Since we retrieved the object reference, updating the object
            // directly updates it in the list as well. No need to re-find and replace.)
            taskToProcess.setStatus(Status.IN_PROGRESS); // Update status
            // Optional: In a real system, you might move it to a 'completed' list
            // or update more status fields here.
            return taskToProcess;
        } else {
            // No tasks available for processing
            return null;
        }
    }

    /**
     * Returns an unmodifiable view of all tasks in the system.
     *
     * @return A List of all tasks.
     */
    public List<Task> getAllTasks() {
        // Returning the list directly allows external modification.
        // For a robust system, return a copy or an unmodifiable list.
        // For this exam, returning the reference is acceptable per implied scope.
        return allTasks;
    }

     /**
     * Returns the current high priority queue.
     *
     * @return The Queue of high priority tasks.
     */
    public Queue<Task> getHighPriorityQueue() {
         // Returning the queue directly allows external modification.
        // For a robust system, return a copy or an unmodifiable queue.
        // For this exam, returning the reference is acceptable per implied scope.
        return highPriorityQueue;
     }

    /**
     * Prints all tasks currently in the system.
     */
    public void displayAllTasks() {
        System.out.println("--- All Tasks ---");
        if (allTasks.isEmpty()) {
            System.out.println("(No tasks created yet)");
        } else {
            allTasks.forEach(System.out::println);
        }
        System.out.println("--- High Priority Queue ---");
        if (highPriorityQueue.isEmpty()) {
            System.out.println("(Queue is empty)");
        } else {
            highPriorityQueue.forEach(task -> System.out.println(task.getTaskId() + ": " + task.getDescription()));
        }
        System.out.println("-----------------");
    }
}

// Main application class
public class TaskManagementApp {

    public static void main(String[] args) {
        // Use try-with-resources for Scanner to ensure it's closed
        try (Scanner scanner = new Scanner(System.in)) {
            TaskManager taskManager = new TaskManager();
            boolean running = true;

            // Class-wide exception handling for the main loop
            try {
                while (running) {
                    printMenu();
                    int choice = -1; // Default to invalid choice

                    // Validate integer input
                    if (scanner.hasNextInt()) {
                        choice = scanner.nextInt();
                    } else {
                        System.err.println("Invalid input. Please enter a number.");
                        scanner.next(); // Consume the invalid input
                        continue; // Skip to the next iteration
                    }
                    scanner.nextLine(); // Consume the newline character after reading the integer

                    // Use switch for flow control
                    switch (choice) {
                        case 1: // Add New Task
                            System.out.print("Enter task description: ");
                            String description = scanner.nextLine();

                            // Input validation for description
                            if (description.trim().isEmpty()) {
                                System.err.println("Task description cannot be empty.");
                                break; // Exit switch, go back to menu
                            }

                            Priority priority = null;
                            boolean validPriority = false;
                            while (!validPriority) {
                                System.out.print("Enter priority (HIGH/LOW): ");
                                String priorityInput = scanner.nextLine().trim().toUpperCase();
                                try {
                                    priority = Priority.valueOf(priorityInput);
                                    validPriority = true;
                                } catch (IllegalArgumentException e) {
                                    System.err.println("Invalid priority. Please enter HIGH or LOW.");
                                }
                            }
                            // Add task via TaskManager (TaskManager handles its own validation/exceptions)
                            taskManager.addTask(description, priority);
                            break;

                        case 2: // Process Next Task
                            System.out.println("Processing next task...");
                            Task processedTask = taskManager.processNextTask();
                            if (processedTask != null) {
                                System.out.println("Processed Task: " + processedTask);
                            } else {
                                System.err.println("No tasks available for processing.");
                            }
                            break;

                        case 3: // View All Tasks
                            taskManager.displayAllTasks();
                            break;

                        case 4: // Exit
                            running = false;
                            System.out.println("Exiting Task Management System.");
                            break;

                        default: // Invalid choice
                            System.err.println("Invalid choice. Please enter a number between 1 and 4.");
                            break;
                    }
                }
            } catch (Exception e) {
                // Catch any unexpected exceptions during the application loop
                System.err.println("An unexpected error occurred: " + e.getMessage());
                e.printStackTrace(); // Print stack trace for debugging
            }

        } // Scanner is automatically closed here by try-with-resources
    }

    // Helper method to print the menu
    private static void printMenu() {
        System.out.println("\nTask Management System Menu:");
        System.out.println("1. Add New Task");
        System.out.println("2. Process Next Task");
        System.out.println("3. View All Tasks");
        System.out.println("4. Exit");
        System.out.print("Enter your choice: ");
    }
}
