/*
 * Exam Question #620
 * Generated on: 2025-05-12 16:15:58
 * Generated by: Account 1
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Hospital Appointment Scheduling System
 * 
 * **Scenario:**
 * 
 * You are tasked with developing a simplified Hospital Appointment Scheduling System. The system needs to manage registered patients and handle a waiting list for scheduling appointments based on a first-come, first-served principle.
 * 
 * **Requirements:**
 * 
 * Implement a Java program that fulfills the following requirements:
 * 
 * 1.  **`Patient` Class:** Create a class named `Patient` with private fields for `patientId` (an integer) and `name` (a String). Include a constructor, public getter methods for both fields, and an appropriate `toString()` method. Ensure proper encapsulation.
 * 2.  **`AppointmentScheduler` Class:** Create a class named `AppointmentScheduler` to manage the hospital's patients and the appointment waiting list.
 *     *   It must use a `java.util.ArrayList` to store *all* registered `Patient` objects.
 *     *   It must use a `java.util.Queue` (you can use `LinkedList` which implements `Queue`) to manage the waiting list of `Patient` objects for appointments. Patients are added to the end of the queue and scheduled from the front.
 *     *   Implement the following public methods with appropriate input validation and error handling:
 *         *   `registerPatient(int patientId, String name)`: Registers a new patient. Patient IDs must be unique. If a patient with the same ID already exists, print an error message to `System.err` and do not add.
 *         *   `addToWaitingList(int patientId)`: Adds a *registered* patient to the appointment waiting list queue. If the patient ID is not found in the registered list, print an error message to `System.err`. If the patient is already in the waiting list (optional but good practice, though the Queue might allow duplicates depending on implementation, assume for this problem adding an already waiting patient is an error), print an error to `System.err`.
 *         *   `scheduleNextAppointment()`: Schedules the next patient from the front of the waiting list queue. If the waiting list is empty, print an error message to `System.err`. Otherwise, print a confirmation message to `System.out` indicating which patient was scheduled. Return the scheduled `Patient` object, or `null` if the queue was empty.
 *         *   `getAllRegisteredPatients()`: Returns a `java.util.List` containing all registered patients.
 *         *   `getWaitingList()`: Returns a `java.util.List` representing the current patients in the waiting list queue (in order).
 * 3.  **Main Program (`Main` class or similar):**
 *     *   Use `java.util.Scanner` to get user input from the console.
 *     *   Present a menu of options to the user:
 *         1.  Register Patient
 *         2.  Add Patient to Waiting List
 *         3.  Schedule Next Appointment
 *         4.  List All Registered Patients
 *         5.  List Waiting List
 *         6.  Exit
 *     *   Use a `switch` statement to handle the user's choice.
 *     *   Implement robust input handling:
 *         *   Handle potential `InputMismatchException` if the user enters non-integer input when an integer is expected (e.g., for menu choice or patient ID). Use a `try-catch` block around the input reading.
 *         *   Handle other potential exceptions thrown by the `AppointmentScheduler` methods or other parts of the program using `try-catch` blocks where appropriate, demonstrating class-wide exception handling. Print informative error messages to `System.err`.
 *     *   Use `System.out` for all normal output (menu, confirmations, lists).
 *     *   Use `System.err` for all error messages.
 *     *   The program should loop until the user chooses to exit.
 * 4.  **General Requirements:**
 *     *   Adhere to Java coding standards and best practices (meaningful names, indentation, comments).
 *     *   Use private fields and public methods (encapsulation).
 *     *   Include comments explaining complex parts of the code.
 * 
 * **Expected Output:**
 * 
 * The program should interact with the user via the console, displaying a menu, prompting for input, and printing results or error messages as described above.
 * 
 * Example Interaction Snippet:
 * 
 * ```
 * --- Hospital Scheduling System ---
 * 1. Register Patient
 * 2. Add Patient to Waiting List
 * 3. Schedule Next Appointment
 * 4. List All Registered Patients
 * 5. List Waiting List
 * 6. Exit
 * Enter your choice: 1
 * Enter Patient ID: 101
 * Enter Patient Name: Alice
 * Patient 101 (Alice) registered successfully.
 * 
 * --- Hospital Scheduling System ---
 * 1. Register Patient
 * 2. Add Patient to Waiting List
 * 3. Schedule Next Appointment
 * 4. List All Registered Patients
 * 5. List Waiting List
 * 6. Exit
 * Enter your choice: 2
 * Enter Patient ID to add to waiting list: 101
 * Patient 101 added to waiting list.
 * 
 * --- Hospital Scheduling System ---
 * 1. Register Patient
 * 2. Add Patient to Waiting List
 * 3. Schedule Next Appointment
 * 4. List All Registered Patients
 * 5. List Waiting List
 * 6. Exit
 * Enter your choice: 3
 * Scheduling appointment for: Patient ID: 101, Name: Alice
 * 
 * --- Hospital Scheduling System ---
 * 1. Register Patient
 * 2. Add Patient to Waiting List
 * 3. Schedule Next Appointment
 * 4. List All Registered Patients
 * 5. List Waiting List
 * 6. Exit
 * Enter your choice: 3
 * Error: Waiting list is empty.
 * 
 * --- Hospital Scheduling System ---
 * 1. Register Patient
 * 2. Add Patient to Waiting List
 * 3. Schedule Next Appointment
 * 4. List All Registered Patients
 * 5. List Waiting List
 * 6. Exit
 * Enter your choice: 7
 * Error: Invalid choice. Please enter a number between 1 and 6.
 * 
 * --- Hospital Scheduling System ---
 * ... (more interactions) ...
 * Enter your choice: 6
 * Exiting system.
 * ```
 * 
 * Your solution must demonstrate a clear understanding of the required Java components and how to use them together effectively in a structured, error-resistant program.
 *
 * EXPLANATION:
 * This solution implements a simplified Hospital Appointment Scheduling System demonstrating the required Java concepts.
 * 
 * 1.  **`Patient` Class:**
 *     *   This is a simple Plain Old Java Object (POJO) representing a patient.
 *     *   It uses `private` fields (`patientId`, `name`) and `public` getter methods (`getPatientId`, `getName`), adhering to **encapsulation**.
 *     *   The `toString()` method provides a convenient string representation for printing.
 *     *   `equals()` and `hashCode()` are overridden based on `patientId` to correctly check for patient uniqueness in collections like `ArrayList` and `Queue`.
 * 
 * 2.  **`AppointmentScheduler` Class:**
 *     *   This class acts as the core logic handler.
 *     *   It uses a `private ArrayList<Patient> registeredPatients` to store all patients ever registered. `ArrayList` is suitable here because we need to efficiently add patients and iterate through the list to check for uniqueness or find a patient by ID.
 *     *   It uses a `private Queue<Patient> waitingList`. We instantiate it using `new LinkedList<>()` because `LinkedList` implements the `Queue` interface and provides the necessary methods (`offer` to add, `poll` to remove from the front). The `Queue` perfectly models the first-come, first-served nature of a waiting list.
 *     *   The `registerPatient` method adds a new patient to the `registeredPatients` list after checking for duplicate IDs using a loop. It throws an `IllegalArgumentException` if a duplicate is found.
 *     *   The `findRegisteredPatient` is a helper method (kept `private` as it's internal logic) that searches the `registeredPatients` list by ID and throws a `NoSuchElementException` if not found. This promotes code reuse.
 *     *   The `addToWaitingList` method first uses `findRegisteredPatient` to ensure the patient is registered. It then checks if the patient is already in the `waitingList` using `contains()` (relying on the overridden `equals()` method in `Patient`) and throws `IllegalArgumentException` if they are. Finally, it adds the patient to the `waitingList` using `offer()`.
 *     *   The `scheduleNextAppointment` method uses `poll()` to retrieve and remove the patient at the front of the `waitingList`. `poll()` returns `null` if the queue is empty, which is handled by printing an error message to `System.err`. If a patient is scheduled, a success message is printed to `System.out`.
 *     *   `getAllRegisteredPatients` and `getWaitingList` return copies of the internal lists (`ArrayList` and `LinkedList` converted to `ArrayList` respectively) using `new ArrayList<>(collection)`, preventing external code from directly modifying the internal state of the `AppointmentScheduler`. They return `List` interfaces, demonstrating polymorphic usage of the collection types.
 * 
 * 3.  **`HospitalSchedulerApp` (Main Class):**
 *     *   This class contains the `main` method, which is the entry point of the application.
 *     *   A `Scanner` object is used to read user input from `System.in`.
 *     *   A `while` loop keeps the application running until the user chooses to exit.
 *     *   Inside the loop, a menu is printed, and the user's choice is read.
 *     *   A **`switch` statement** is used to direct the program flow based on the user's integer choice.
 *     *   **Class-wide exception handling** is implemented using `try-catch` blocks:
 *         *   The main `while` loop's core logic (reading choice and the `switch` statement) is wrapped in a `try-catch` block to catch potential `InputMismatchException` if the user enters non-integer input for the menu choice, and other `Exception` types.
 *         *   Specific methods like `registerPatient` and `addToWaitingList` also have their own `try-catch` blocks in the calling methods (`registerPatient()`, `addToWaitingList()`) within the `main` class to handle exceptions (`IllegalArgumentException`, `NoSuchElementException`, `InputMismatchException`) thrown by the `AppointmentScheduler` or input reading, allowing for more specific error messages printed to **`System.err`**.
 *         *   `System.out` is used for printing the menu, successful operations, and list contents.
 *     *   Input validation is implicitly handled by the `Scanner` methods combined with `try-catch` for type errors, and explicitly in `AppointmentScheduler` methods (e.g., checking for duplicate IDs or if a patient is registered/already waiting).
 *     *   The `scanner.nextLine()` calls after reading an integer (`nextInt()`) are crucial to consume the leftover newline character, preventing issues with subsequent `nextLine()` calls.
 * 
 * This solution effectively integrates all the required Java components (`Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.err`, `System.out`, `try-catch`) into a practical, structured program that demonstrates key object-oriented principles and error handling.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.InputMismatchException;
import java.util.NoSuchElementException; // For Queue operations

/**
 * Represents a patient in the hospital system.
 * Encapsulates patient ID and name.
 */
class Patient {
    private int patientId;
    private String name;

    /**
     * Constructs a new Patient object.
     * @param patientId The unique ID of the patient.
     * @param name The name of the patient.
     */
    public Patient(int patientId, String name) {
        this.patientId = patientId;
        this.name = name;
    }

    /**
     * Gets the patient's ID.
     * @return The patient ID.
     */
    public int getPatientId() {
        return patientId;
    }

    /**
     * Gets the patient's name.
     * @return The patient name.
     */
    public String getName() {
        return name;
    }

    /**
     * Provides a string representation of the Patient.
     * @return A string formatted as "Patient ID: [ID], Name: [Name]".
     */
    @Override
    public String toString() {
        return "Patient ID: " + patientId + ", Name: " + name;
    }

    /**
     * Basic equals check based on patientId for uniqueness checks.
     * @param o The object to compare with.
     * @return true if the objects are considered equal (same patientId), false otherwise.
     */
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Patient patient = (Patient) o;
        return patientId == patient.patientId;
    }

    /**
     * Basic hashCode based on patientId.
     * @return The hash code.
     */
    @Override
    public int hashCode() {
        return Integer.hashCode(patientId);
    }
}

/**
 * Manages patient registration and appointment waiting list.
 * Uses ArrayList for all patients and Queue for the waiting list.
 */
class AppointmentScheduler {
    private List<Patient> registeredPatients; // Stores all registered patients
    private Queue<Patient> waitingList;      // Stores patients waiting for appointments

    /**
     * Constructs a new AppointmentScheduler.
     * Initializes the patient list and waiting list.
     */
    public AppointmentScheduler() {
        registeredPatients = new ArrayList<>();
        waitingList = new LinkedList<>(); // LinkedList implements Queue
    }

    /**
     * Registers a new patient in the system.
     * @param patientId The unique ID for the patient.
     * @param name The name of the patient.
     * @throws IllegalArgumentException if a patient with the same ID already exists.
     */
    public void registerPatient(int patientId, String name) throws IllegalArgumentException {
        // Check if patient ID already exists
        for (Patient p : registeredPatients) {
            if (p.getPatientId() == patientId) {
                throw new IllegalArgumentException("Patient with ID " + patientId + " already registered.");
            }
        }
        Patient newPatient = new Patient(patientId, name);
        registeredPatients.add(newPatient);
        System.out.println("Patient " + patientId + " (" + name + ") registered successfully.");
    }

    /**
     * Finds a registered patient by their ID.
     * @param patientId The ID of the patient to find.
     * @return The Patient object if found.
     * @throws NoSuchElementException if no patient with the given ID is registered.
     */
    private Patient findRegisteredPatient(int patientId) throws NoSuchElementException {
        for (Patient p : registeredPatients) {
            if (p.getPatientId() == patientId) {
                return p;
            }
        }
        throw new NoSuchElementException("Patient with ID " + patientId + " not found in registered list.");
    }

    /**
     * Adds a registered patient to the appointment waiting list.
     * Patient must be registered first.
     * @param patientId The ID of the registered patient to add.
     * @throws NoSuchElementException if the patient is not registered.
     * @throws IllegalArgumentException if the patient is already in the waiting list.
     */
    public void addToWaitingList(int patientId) throws NoSuchElementException, IllegalArgumentException {
        Patient patientToAdd = findRegisteredPatient(patientId); // Throws NoSuchElementException if not found

        // Check if patient is already in the waiting list
        if (waitingList.contains(patientToAdd)) {
             throw new IllegalArgumentException("Patient with ID " + patientId + " is already in the waiting list.");
        }

        waitingList.offer(patientToAdd); // offer() is generally preferred for queues as it returns boolean instead of throwing exception on failure, but here we control capacity so it won't fail.
        System.out.println("Patient " + patientId + " added to waiting list.");
    }

    /**
     * Schedules the next patient from the front of the waiting list.
     * Removes the patient from the waiting list.
     * @return The Patient object that was scheduled, or null if the waiting list was empty.
     */
    public Patient scheduleNextAppointment() {
        Patient scheduledPatient = waitingList.poll(); // poll() retrieves and removes, returns null if empty
        if (scheduledPatient == null) {
            System.err.println("Error: Waiting list is empty. No appointments to schedule.");
        } else {
            System.out.println("Scheduling appointment for: " + scheduledPatient);
        }
        return scheduledPatient;
    }

    /**
     * Gets a list of all registered patients.
     * @return A List of Patient objects. Returns an empty list if none registered.
     */
    public List<Patient> getAllRegisteredPatients() {
        return new ArrayList<>(registeredPatients); // Return a copy to prevent external modification
    }

    /**
     * Gets a list of patients currently in the waiting list queue, in order.
     * @return A List of Patient objects from the waiting list. Returns an empty list if waiting list is empty.
     */
    public List<Patient> getWaitingList() {
        return new ArrayList<>(waitingList); // Return a copy
    }
}

/**
 * Main class to run the Hospital Appointment Scheduling System.
 * Handles user interaction and exception handling.
 */
public class HospitalSchedulerApp {

    private static AppointmentScheduler scheduler = new AppointmentScheduler();
    private static Scanner scanner = new Scanner(System.in);

    public static void main(String[] args) {
        System.out.println("--- Hospital Scheduling System ---");

        boolean running = true;
        while (running) {
            printMenu();
            try {
                System.out.print("Enter your choice: ");
                int choice = scanner.nextInt();
                scanner.nextLine(); // Consume newline

                switch (choice) {
                    case 1:
                        registerPatient();
                        break;
                    case 2:
                        addToWaitingList();
                        break;
                    case 3:
                        scheduler.scheduleNextAppointment(); // Method already prints output/error
                        break;
                    case 4:
                        listAllRegisteredPatients();
                        break;
                    case 5:
                        listWaitingList();
                        break;
                    case 6:
                        running = false;
                        System.out.println("Exiting system.");
                        break;
                    default:
                        System.err.println("Error: Invalid choice. Please enter a number between 1 and 6.");
                }
            } catch (InputMismatchException e) {
                System.err.println("Error: Invalid input. Please enter a number.");
                scanner.nextLine(); // Consume the invalid input to prevent infinite loop
            } catch (NoSuchElementException e) {
                 // Catch exceptions from scheduler methods
                 System.err.println("Operation failed: " + e.getMessage());
            } catch (IllegalArgumentException e) {
                 // Catch exceptions from scheduler methods
                 System.err.println("Operation failed: " + e.getMessage());
            } catch (Exception e) {
                // Generic catch for any other unexpected errors
                System.err.println("An unexpected error occurred: " + e.getMessage());
                e.printStackTrace(); // Optional: for debugging unexpected errors
            }
            System.out.println(); // Add a newline for better readability between operations
        }

        scanner.close();
    }

    /**
     * Prints the main menu options to the console.
     */
    private static void printMenu() {
        System.out.println("--- Hospital Scheduling System ---");
        System.out.println("1. Register Patient");
        System.out.println("2. Add Patient to Waiting List");
        System.out.println("3. Schedule Next Appointment");
        System.out.println("4. List All Registered Patients");
        System.out.println("5. List Waiting List");
        System.out.println("6. Exit");
    }

    /**
     * Handles user input for registering a new patient and calls the scheduler.
     */
    private static void registerPatient() {
        try {
            System.out.print("Enter Patient ID: ");
            int id = scanner.nextInt();
            scanner.nextLine(); // Consume newline

            System.out.print("Enter Patient Name: ");
            String name = scanner.nextLine();

            scheduler.registerPatient(id, name);
        } catch (InputMismatchException e) {
             System.err.println("Error: Invalid input for Patient ID. Please enter a number.");
             scanner.nextLine(); // Consume invalid input
        } catch (IllegalArgumentException e) {
             System.err.println("Registration failed: " + e.getMessage());
        } catch (Exception e) {
            System.err.println("An unexpected error occurred during registration: " + e.getMessage());
        }
    }

    /**
     * Handles user input for adding a patient to the waiting list and calls the scheduler.
     */
    private static void addToWaitingList() {
        try {
            System.out.print("Enter Patient ID to add to waiting list: ");
            int id = scanner.nextInt();
            scanner.nextLine(); // Consume newline

            scheduler.addToWaitingList(id);
        } catch (InputMismatchException e) {
            System.err.println("Error: Invalid input for Patient ID. Please enter a number.");
            scanner.nextLine(); // Consume invalid input
        } catch (NoSuchElementException | IllegalArgumentException e) {
             System.err.println("Adding to waiting list failed: " + e.getMessage());
        } catch (Exception e) {
             System.err.println("An unexpected error occurred adding to waiting list: " + e.getMessage());
        }
    }

    /**
     * Retrieves and prints all registered patients.
     */
    private static void listAllRegisteredPatients() {
        List<Patient> patients = scheduler.getAllRegisteredPatients();
        if (patients.isEmpty()) {
            System.out.println("No patients registered yet.");
        } else {
            System.out.println("--- Registered Patients ---");
            for (Patient p : patients) {
                System.out.println(p);
            }
        }
    }

    /**
     * Retrieves and prints patients in the waiting list.
     */
    private static void listWaitingList() {
        List<Patient> waiting = scheduler.getWaitingList();
        if (waiting.isEmpty()) {
            System.out.println("Waiting list is empty.");
        } else {
            System.out.println("--- Appointment Waiting List ---");
            // The List returned by getWaitingList() will be in queue order
            for (Patient p : waiting) {
                System.out.println(p);
            }
        }
    }
}
