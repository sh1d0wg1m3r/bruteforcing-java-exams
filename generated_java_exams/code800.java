/*
 * Exam Question #800
 * Generated on: 2025-05-12 16:42:30
 * Generated by: Account 5
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Resource Processing System Simulation
 * 
 * **Objective:** Design and implement a command-line application that simulates a system processing requests using a queue. The system manages a queue of incoming requests and a history of successfully processed requests.
 * 
 * **Scenario:** Imagine a simplified resource processing unit (like a shared server, printer pool, or computation cluster). Requests for this resource arrive and are placed in a queue. An operator can interact with the system to add new requests, process the next available request, view the queue, or view the history of processed requests.
 * 
 * **Requirements:**
 * 
 * 1.  **Request Class:** Create a class `Request` with the following attributes:
 *     *   `id`: An integer, automatically assigned sequentially starting from 1 for each new request.
 *     *   `type`: A `String` representing the type of request (e.g., "Print", "Compute", "Scan").
 *     *   `description`: A `String` detailing the request.
 *     *   Implement a `toString()` method for easy display of request information.
 *     *   Ensure proper encapsulation (private fields, public getters).
 * 
 * 2.  **Resource Processing System Class:** Create a class `ResourceProcessingSystem` that manages the application logic. It must contain:
 *     *   A `java.util.Queue<Request>` to hold pending requests. Use a concrete implementation like `java.util.LinkedList`.
 *     *   A `java.util.List<Request>` (declared as the interface `List`) to hold successfully processed requests. Use a concrete implementation like `java.util.ArrayList`.
 *     *   A `java.util.Scanner` to read user input from the console.
 *     *   Methods for:
 *         *   Adding a new request to the queue (`addRequest(String type, String description)`). Validate that type and description are not empty.
 *         *   Processing the next request from the queue (`processNextRequest()`). This method should:
 *             *   Remove the head of the queue.
 *             *   Simulate processing based on the request's `type` using a `switch` statement.
 *             *   Simulate potential processing errors (e.g., if the description contains specific keywords like "error", "fail", or "jam").
 *             *   If processing is successful, add the request to the processed history list.
 *             *   If processing fails (simulated error), report the failure using `System.err` and do **not** add the request to the history.
 *             *   Throw a custom exception (`EmptyQueueException`) if `processNextRequest` is called when the queue is empty.
 *         *   Viewing the current requests in the queue (`viewQueue()`). Display requests in order without removing them.
 *         *   Viewing the history of successfully processed requests (`viewProcessedHistory()`).
 *         *   A main `run()` method that contains the application loop, reads commands from the user, and dispatches to the appropriate methods using a `switch` statement.
 *     *   Implement a custom exception class `EmptyQueueException` that extends `Exception` to signal when a processing operation is requested on an empty queue.
 * 
 * 3.  **User Interface and Control Flow:**
 *     *   The system should present a command prompt (`> `) and accept commands:
 *         *   `add <type> <description>`: Adds a new request to the queue.
 *         *   `process`: Processes the next request in the queue.
 *         *   `viewq`: Displays the current queue contents.
 *         *   `viewh`: Displays the processed history contents.
 *         *   `exit`: Terminates the application.
 *     *   Use a `switch` statement in the `run()` method to handle different commands.
 *     *   Use `System.out` for normal output (menus, prompts, successful operations, queue/history display).
 *     *   Use `System.err` for reporting errors (invalid input format, simulated processing failures).
 * 
 * 4.  **Exception Handling:**
 *     *   Implement class-wide exception handling using `try-catch` blocks within the `run()` method to catch potential errors during command processing, including the custom `EmptyQueueException`.
 *     *   Handle potential errors during simulated processing within the `processNextRequest()` method using `try-catch`.
 * 
 * 5.  **Best Practices:**
 *     *   Follow proper encapsulation.
 *     *   Use meaningful variable and method names.
 *     *   Include appropriate comments explaining key parts of the code.
 *     *   Implement input validation where necessary (e.g., for `add` command arguments).
 *     *   Ensure resources like `Scanner` are properly closed.
 * 
 * **Expected Output Examples:**
 * 
 * ```
 * Resource Processing System
 * Enter command (add, process, viewq, viewh, exit):
 * > add Print Document1.pdf
 * Added: Request [ID=1, Type=Print, Desc='Document1.pdf']
 * > add Compute DataAnalysis
 * Added: Request [ID=2, Type=Compute, Desc='DataAnalysis']
 * > viewq
 * --- Current Request Queue ---
 * 1. Request [ID=1, Type=Print, Desc='Document1.pdf']
 * 2. Request [ID=2, Type=Compute, Desc='DataAnalysis']
 * -----------------------------
 * > process
 * Processing: Request [ID=1, Type=Print, Desc='Document1.pdf']
 * Simulating printing task for Request ID 1
 * Successfully processed Request ID 1
 * > process
 * Processing: Request [ID=2, Type=Compute, Desc='DataAnalysis']
 * Simulating computation task for Request ID 2
 * Successfully processed Request ID 2
 * > process
 * No requests in the queue to process.
 * > viewh
 * --- Processed Request History ---
 * 1. Request [ID=1, Type=Print, Desc='Document1.pdf']
 * 2. Request [ID=2, Type=Compute, Desc='DataAnalysis']
 * ---------------------------------
 * > add Scan Image.jpg with error
 * Added: Request [ID=3, Type=Scan, Desc='Image.jpg with error']
 * > process
 * Processing: Request [ID=3, Type=Scan, Desc='Image.jpg with error']
 * Simulating scanning task for Request ID 3
 * Error: Processing failed for Request ID 3: Simulated scanner jam!
 * > viewq
 * The request queue is empty.
 * > viewh
 * --- Processed Request History ---
 * 1. Request [ID=1, Type=Print, Desc='Document1.pdf']
 * 2. Request [ID=2, Type=Compute, Desc='DataAnalysis']
 * ---------------------------------
 * > invalid_command
 * Unknown command. Available commands: add, process, viewq, viewh, exit
 * > add Print
 * Error: 'add' command requires type and description. Usage: add <type> <description>
 * > exit
 * Exiting system. Pending requests will be lost.
 * ```
 * 
 * **Evaluation:** Your solution will be evaluated based on correctness, adherence to all requirements (including using the specified Java components), code quality, error handling, and clarity.
 *
 * EXPLANATION:
 * This solution implements a simplified Resource Processing System simulation, demonstrating the required Java concepts in a practical context.
 * 
 * **Class Structure:**
 * - `Request`: A simple class representing a request object, demonstrating encapsulation with private fields (`id`, `type`, `description`) and public getters. The static `nextId` ensures unique IDs for each request.
 * - `EmptyQueueException`: A custom checked exception used specifically to indicate that an operation (like `processNextRequest`) was attempted on an empty queue. This provides a clear, specific error type.
 * - `ResourceProcessingSystem`: The main class containing the system's state (`requestQueue`, `processedHistory`) and logic (`addRequest`, `processNextRequest`, `viewQueue`, `viewProcessedHistory`, `run`).
 * 
 * **Required Components Usage:**
 * - **`Queue` (`java.util.Queue`)**: The `requestQueue` is declared as `Queue<Request>` and instantiated using `LinkedList`. Requests are added using `offer()` and removed using `poll()`, adhering to the FIFO (First-In, First-Out) nature of a queue.
 * - **`ArrayList` (`java.util.ArrayList`)**: The `processedHistory` is instantiated using `ArrayList`. Successfully processed requests are added to this list using `add()`.
 * - **`List` interface (`java.util.List`)**: The `processedHistory` is declared using the `List<Request>` interface, promoting good practice by coding to the interface rather than the specific implementation.
 * - **`Scanner` (`java.util.Scanner`)**: The `scanner` object is used in the `run()` method to read command lines entered by the user from `System.in`. It is closed when the application exits.
 * - **`Switch` statement**: Used in two key places:
 *     - In the `run()` method, it dispatches actions based on the user-entered command (`add`, `process`, `viewq`, `viewh`, `exit`).
 *     - In the `processNextRequest()` method, it simulates different processing logic based on the `Request`'s `type`.
 * - **`System.err`**: Used to report critical errors, specifically invalid command input format and simulated processing failures. These are distinct from normal output messages.
 * - **`System.out`**: Used for all normal interactions: displaying the menu, prompts, success messages, the contents of the queue, and the processed history. It's also used for the `EmptyQueueException` message, as an empty queue is an expected state rather than a critical system failure.
 * - **Class-wide exception handling with `try-catch` blocks**:
 *     - The `run()` method has a large `try-catch` block wrapping the command processing logic within the `while` loop. This catches potential exceptions thrown by the command handlers (like `EmptyQueueException` from `processNextRequest`) or other unexpected runtime issues (`Exception`).
 *     - The `processNextRequest()` method has its own `try-catch` block specifically to handle the simulated `RuntimeException` that might occur during processing based on the request description. This allows the system to gracefully report a processing failure for a single request without crashing the entire application loop. The custom `EmptyQueueException` is declared to be thrown by `processNextRequest` but caught in the `run` method.
 * 
 * **Best Practices Implementation:**
 * - **Encapsulation:** Fields in both `Request` and `ResourceProcessingSystem` are private, accessed via public methods where necessary.
 * - **Meaningful Names:** Variable and method names (`requestQueue`, `processNextRequest`, `viewProcessedHistory`, `EmptyQueueException`) clearly indicate their purpose.
 * - **Comments:** Key parts of the code, methods, and data structures are commented to explain their role.
 * - **Input Validation:** The `addRequest` method checks for empty type or description. The command parsing in `run()` checks if the `add` command has enough arguments and warns about extra arguments for commands that don't expect them.
 * - **Proper Error Handling:** Differentiates between normal output (`System.out`) and error output (`System.err`). Uses specific exception (`EmptyQueueException`) and general catch-all (`Exception`) for different error scenarios. Handles simulated processing errors gracefully.
 * - **Clean Code Structure:** The code is divided into logical classes, and methods are focused on specific tasks, making the code readable and maintainable. The `Scanner` resource is properly closed upon application exit.
 * 
 * This solution effectively integrates all the required Java components into a cohesive, functional application that simulates a real-world processing flow, while adhering to best practices for robust and clean code.
 */

import java.util.Queue;
import java.util.LinkedList;
import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;

// Custom exception for operations on an empty queue
class EmptyQueueException extends Exception {
    public EmptyQueueException(String message) {
        super(message);
    }
}

// Represents a single request in the system
class Request {
    private static int nextId = 1; // For auto-generating unique request IDs
    private int id;
    private String type;
    private String description;

    // Constructor
    public Request(String type, String description) {
        this.id = nextId++; // Assign and increment ID
        this.type = type;
        this.description = description;
    }

    // Getters for encapsulation
    public int getId() {
        return id;
    }

    public String getType() {
        return type;
    }

    public String getDescription() {
        return description;
    }

    // String representation of the request
    @Override
    public String toString() {
        return "Request [ID=" + id + ", Type=" + type + ", Desc='" + description + "']";
    }
}

// Main class managing the request processing system
public class ResourceProcessingSystem {

    // Queue to hold pending requests
    private Queue<Request> requestQueue;
    // List to hold successfully processed requests
    private List<Request> processedHistory;
    // Scanner for reading user input
    private Scanner scanner;

    // Constructor
    public ResourceProcessingSystem() {
        // Use LinkedList as a Queue implementation
        requestQueue = new LinkedList<>();
        // Use ArrayList as a List implementation
        processedHistory = new ArrayList<>();
        scanner = new Scanner(System.in);
    }

    // Adds a new request to the queue
    public void addRequest(String type, String description) {
        // Input validation
        if (type == null || type.trim().isEmpty() || description == null || description.trim().isEmpty()) {
            System.err.println("Error: Request type and description cannot be empty.");
            return;
        }
        Request newRequest = new Request(type.trim(), description.trim());
        // offer is preferred over add for queues as it returns false on failure (though unlikely for LinkedList)
        requestQueue.offer(newRequest);
        System.out.println("Added: " + newRequest);
    }

    // Processes the next request from the queue
    public void processNextRequest() throws EmptyQueueException {
        // poll retrieves and removes the head of the queue, returns null if empty
        Request requestToProcess = requestQueue.poll();

        if (requestToProcess == null) {
            // Throw custom exception if queue is empty
            throw new EmptyQueueException("No requests in the queue to process.");
        }

        System.out.println("Processing: " + requestToProcess);

        // Simulate processing and handle potential errors
        try {
            // Use switch statement based on request type
            switch (requestToProcess.getType().toLowerCase()) {
                case "print":
                    System.out.println("Simulating printing task for Request ID " + requestToProcess.getId());
                    // Simulate failure based on description content
                    if (requestToProcess.getDescription().toLowerCase().contains("error")) {
                        throw new RuntimeException("Simulated print error!");
                    }
                    break;
                case "compute":
                    System.out.println("Simulating computation task for Request ID " + requestToProcess.getId());
                    // Simulate failure based on description content
                    if (requestToProcess.getDescription().toLowerCase().contains("fail")) {
                        throw new RuntimeException("Simulated computation failure!");
                    }
                    break;
                case "scan":
                    System.out.println("Simulating scanning task for Request ID " + requestToProcess.getId());
                    // Simulate failure based on description content
                    if (requestToProcess.getDescription().toLowerCase().contains("jam")) {
                        throw new RuntimeException("Simulated scanner jam!");
                    }
                    break;
                default:
                    // Handle unknown types gracefully
                    System.out.println("Warning: Unknown request type '" + requestToProcess.getType() + "' for Request ID " + requestToProcess.getId() + ". Processing generically.");
                    break; // Continue processing flow even for unknown types
            }
            // If simulation completes without throwing exception
            System.out.println("Successfully processed Request ID " + requestToProcess.getId());
            // Add to history only upon successful processing
            processedHistory.add(requestToProcess);

        } catch (RuntimeException e) {
            // Catch simulated processing errors (RuntimeExceptions)
            // Report critical processing failure using System.err
            System.err.println("Error: Processing failed for Request ID " + requestToProcess.getId() + ": " + e.getMessage());
            // Request is not added to processedHistory in case of failure
        }
    }

    // Displays the current requests in the queue
    public void viewQueue() {
        if (requestQueue.isEmpty()) {
            System.out.println("The request queue is empty.");
        } else {
            System.out.println("--- Current Request Queue ---");
            // Iterate through the queue without removing elements
            int index = 1;
            for (Request request : requestQueue) {
                System.out.println(index++ + ". " + request);
            }
            System.out.println("-----------------------------");
        }
    }

    // Displays the history of successfully processed requests
    public void viewProcessedHistory() {
        if (processedHistory.isEmpty()) {
            System.out.println("No requests have been processed yet.");
        } else {
            System.out.println("--- Processed Request History ---");
            // Iterate through the list
            for (int i = 0; i < processedHistory.size(); i++) {
                System.out.println((i + 1) + ". " + processedHistory.get(i));
            }
            System.out.println("---------------------------------");
        }
    }

    // Main application loop
    public void run() {
        System.out.println("Resource Processing System");
        System.out.println("Enter command (add, process, viewq, viewh, exit):");

        // Loop until the user enters 'exit'
        while (true) {
            System.out.print("> ");
            // Read the entire line of input and trim whitespace
            String commandLine = scanner.nextLine().trim();

            // Use a class-wide try-catch to handle exceptions during command processing
            try {
                // Check for exit command first
                if (commandLine.equalsIgnoreCase("exit")) {
                    System.out.println("Exiting system. Pending requests will be lost.");
                    break; // Exit the loop
                }

                // Split the command line into parts: command [arg1] [arg2...]
                // Limit split to 3 parts to handle descriptions with spaces
                String[] parts = commandLine.split(" ", 3);
                String command = parts[0].toLowerCase(); // Get the command part

                // Use switch statement for command dispatch
                switch (command) {
                    case "add":
                        // Validate number of arguments for 'add'
                        if (parts.length < 3) {
                            System.err.println("Error: 'add' command requires type and description. Usage: add <type> <description>");
                        } else {
                            String type = parts[1];
                            String description = parts[2];
                            addRequest(type, description); // Call add method
                        }
                        break;
                    case "process":
                        // Warn if extra arguments are provided for 'process'
                         if (parts.length > 1) {
                             System.out.println("Warning: 'process' command does not take arguments. Ignoring extra input.");
                        }
                        processNextRequest(); // Call process method (may throw EmptyQueueException)
                        break;
                    case "viewq":
                         // Warn if extra arguments are provided for 'viewq'
                         if (parts.length > 1) {
                             System.out.println("Warning: 'viewq' command does not take arguments. Ignoring extra input.");
                        }
                        viewQueue(); // Call view queue method
                        break;
                    case "viewh":
                         // Warn if extra arguments are provided for 'viewh'
                         if (parts.length > 1) {
                             System.out.println("Warning: 'viewh' command does not take arguments. Ignoring extra input.");
                        }
                        viewProcessedHistory(); // Call view history method
                        break;
                    default:
                        // Handle unknown commands
                        System.out.println("Unknown command. Available commands: add, process, viewq, viewh, exit");
                        break;
                }
            } catch (EmptyQueueException e) {
                // Catch and handle the specific EmptyQueueException
                // Use System.out as this is an expected state, not a critical system error
                System.out.println(e.getMessage());
            } catch (Exception e) {
                // Catch any other unexpected exceptions during command processing
                // Report critical errors using System.err
                System.err.println("An unexpected error occurred during command processing: " + e.getMessage());
                // Optional: e.printStackTrace(); for detailed debugging
            }
        }
        // Close the scanner when the application exits
        scanner.close();
    }

    // Main method to start the application
    public static void main(String[] args) {
        ResourceProcessingSystem system = new ResourceProcessingSystem();
        system.run();
    }
}
