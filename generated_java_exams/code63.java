/*
 * Exam Question #63
 * Generated on: 2025-05-11 22:07:39
 * Generated by: Account 3
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Event Session Management
 * 
 * **Problem Description:**
 * 
 * Design and implement a simplified Event Management System in Java. The system should manage multiple sessions, each with a limited capacity. Attendees can register for sessions, and due to capacity constraints, some attendees may be placed on a waiting list. The system should allow checking in attendees from the waiting list when space becomes available.
 * 
 * Your solution must demonstrate proficiency in using core Java collections and control flow mechanisms.
 * 
 * **Requirements:**
 * 
 * 1.  **Core Data Structures:**
 *     *   Create a `Session` class to represent an event session.
 *         *   Each `Session` must have a unique integer ID, a name (String), and a maximum capacity (int).
 *         *   It must maintain a list of attendees who have successfully checked in. Use `java.util.ArrayList` for this. Declare the field using the `java.util.List` interface.
 *         *   It must maintain a waiting list of attendees who are registered but could not be checked in due to capacity limits. Use `java.util.Queue` for this. A `LinkedList` can be used to implement the `Queue`.
 *         *   Implement methods within `Session` to:
 *             *   Add an attendee to the waiting list (`addAttendeeToWaitingList`).
 *             *   Attempt to check in an attendee from the waiting list (`checkInAttendee`). This method should move the attendee from the waiting list to the checked-in list if space is available. It should return an indicator of the outcome (e.g., success, still waiting, not found).
 *             *   Check if the session is full (`isFull`).
 *             *   Display session details, including checked-in attendees and the waiting list.
 *     *   Create an `EventManager` class to manage multiple `Session` objects.
 *         *   It must hold a collection of `Session` objects. Use `java.util.ArrayList` for this, declared using the `java.util.List` interface.
 *         *   Implement a method to find a `Session` by its ID.
 *         *   Implement a main loop that interacts with the user.
 * 
 * 2.  **User Interaction:**
 *     *   Use `java.util.Scanner` to get user input from the console.
 *     *   Present a menu of options to the user:
 *         1.  Add Attendee to Waiting List
 *         2.  Check-in Attendee
 *         3.  View Session Info
 *         4.  Exit
 *     *   Use a `switch` statement to process the user's menu choice.
 * 
 * 3.  **Output and Error Handling:**
 *     *   Use `System.out` for displaying the menu, prompts, session information, and successful operation messages.
 *     *   Use `System.err` for displaying error messages (e.g., invalid input, session not found, attendee not found in waiting list).
 *     *   Implement robust input validation (e.g., ensure session ID is a number, handle empty attendee names).
 *     *   Implement class-wide exception handling using `try-catch` blocks within the `EventManager`'s main loop to catch unexpected errors and prevent the program from crashing. Also handle specific exceptions like `InputMismatchException` during input reading.
 * 
 * 4.  **Best Practices:**
 *     *   Adhere to proper encapsulation (private fields, public methods).
 *     *   Use meaningful variable and method names.
 *     *   Include appropriate comments and documentation for classes and methods.
 *     *   Structure the code logically across the `Session` and `EventManager` classes.
 * 
 * **Initial State:**
 * 
 * The `EventManager` should be initialized with at least two sample `Session` objects with different capacities.
 * 
 * **Expected Output:**
 * 
 * The program should run continuously, presenting the menu, accepting input, and performing the requested operations. Output should clearly indicate the result of each operation, using `System.out` for success/info and `System.err` for errors.
 * 
 * **Example Interaction Flow (Illustrative):**
 * 
 * ```
 * --- Event Management Menu ---
 * 1. Add Attendee to Waiting List
 * 2. Check-in Attendee
 * 3. View Session Info
 * 4. Exit
 * -----------------------------
 * Enter your choice: 1
 * Enter Session ID: 101
 * Enter Attendee Name: Alice
 * Alice has been added to the waiting list for Java Basics (ID: 101).
 * 
 * --- Event Management Menu ---
 * ...
 * Enter your choice: 1
 * Enter Session ID: 101
 * Enter Attendee Name: Bob
 * Bob has been added to the waiting list for Java Basics (ID: 101).
 * 
 * --- Event Management Menu ---
 * ...
 * Enter your choice: 3
 * Enter Session ID: 101
 * 
 * --- Session Details ---
 * ID: 101
 * Name: Java Basics
 * Capacity: 2
 * Checked-in Attendees (0/2): []
 * Waiting List (2): [Alice, Bob]
 * -----------------------
 * 
 * --- Event Management Menu ---
 * ...
 * Enter your choice: 2
 * Enter Session ID: 101
 * Enter Attendee Name to Check In: Alice
 * Alice successfully checked in for Java Basics (ID: 101).
 * 
 * --- Event Management Menu ---
 * ...
 * Enter your choice: 2
 * Enter Session ID: 101
 * Enter Attendee Name to Check In: Charlie
 * Error: Attendee Charlie not found in the waiting list or already checked in for Java Basics (ID: 101).
 * 
 * --- Event Management Menu ---
 * ...
 * Enter your choice: 3
 * Enter Session ID: 101
 * 
 * --- Session Details ---
 * ID: 101
 * Name: Java Basics
 * Capacity: 2
 * Checked-in Attendees (1/2): [Alice]
 * Waiting List (1): [Bob]
 * -----------------------
 * 
 * --- Event Management Menu ---
 * ...
 * Enter your choice: 4
 * Exiting Event Management System. Goodbye!
 * ```
 * 
 * **Constraints:**
 * 
 * *   You must use all specified Java components.
 * *   The solution should be contained within standard Java classes (`.java` files).
 * 
 * **Deliverables:**
 * 
 * *   Complete Java code for the `Session` and `EventManager` classes.
 *
 * EXPLANATION:
 * This solution implements a simple Event Management System focusing on session capacity and waiting lists, demonstrating the required Java concepts.
 * 
 * 1.  **`Session` Class:**
 *     *   **Data Structures:** Uses `ArrayList` (via `List` interface) for `checkedInAttendees` because random access and iteration are common operations. Uses `LinkedList` (via `Queue` interface) for `waitingList` because it naturally supports FIFO (First-In, First-Out) operations (`offer` to add to the end, `remove` from the front, though here we use `remove(element)` to find and remove a specific attendee from anywhere in the queue when they check in).
 *     *   **Encapsulation:** Fields (`id`, `name`, `capacity`, `checkedInAttendees`, `waitingList`) are private. Access is provided through public getter methods and specific action methods (`addAttendeeToWaitingList`, `checkInAttendee`, `displaySessionInfo`). Copies of lists/queues are returned by getters to prevent external modification of the internal state.
 *     *   **Methods:** `addAttendeeToWaitingList` adds an attendee to the queue. `checkInAttendee` is the core logic; it checks if the attendee is in the waiting list *and* if there is capacity. If both conditions are met, the attendee is removed from the queue and added to the list. It returns status codes (1, 0, -1) to indicate the outcome. `isFull` and `getAvailableSpots` provide capacity status. `displaySessionInfo` formats and prints the session's details.
 * 
 * 2.  **`EventManager` Class:**
 *     *   **Data Structure:** Uses `ArrayList` (via `List` interface) to hold multiple `Session` objects.
 *     *   **User Interaction:** The `run()` method contains the main application loop. It uses `Scanner` to read input from `System.in`.
 *     *   **Control Flow:** A `while` loop keeps the program running until the user chooses to exit (choice 4). A `switch` statement inside the loop directs execution based on the user's integer choice.
 *     *   **Input Handling:** Helper methods (`handleAddAttendee`, `handleCheckInAttendee`, `handleViewSessionInfo`) are used to structure the logic for each menu option. `scanner.nextInt()` is used for reading the choice and session ID, followed by `scanner.nextLine()` to consume the leftover newline character, preventing input issues in subsequent `nextLine()` calls.
 *     *   **Error Handling (`System.err`, `try-catch`):**
 *         *   Specific `try-catch (InputMismatchException e)` blocks are used when reading integer input (`scanner.nextInt()`) to catch non-numeric input gracefully. The invalid input is consumed (`scanner.nextLine()`) to prevent an infinite loop.
 *         *   A broader `try-catch (Exception e)` block wraps the entire `while` loop in the `run()` method. This provides class-wide exception handling, catching any other unexpected runtime errors that might occur during the execution of any menu option and printing an error message to `System.err` before the program potentially terminates (or continues, depending on the error).
 *         *   `System.err` is used throughout the code to print error messages when sessions are not found, attendees aren't found in the waiting list, or input validation fails (e.g., empty name).
 *         *   `System.out` is used for normal output like the menu, prompts, success messages, and session details.
 *     *   **Best Practices:** Methods are broken down logically (`printMenu`, `findSession`, `handle...`). The `main` method simply creates an `EventManager` instance and calls `run()`. The `finally` block ensures the `Scanner` resource is closed.
 * 
 * This solution effectively integrates `Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.err`, `System.out`, and `try-catch` blocks within a practical, encapsulated, and error-aware structure. It demonstrates how these components can work together to manage dynamic data (attendees moving between waiting and checked-in states) based on user input and system constraints (session capacity).
 */

import java.util.ArrayList;
import java.util.InputMismatchException;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;

/**
 * Represents an event session with limited capacity, managing checked-in attendees and a waiting list.
 */
class Session {
    private int id;
    private String name;
    private int capacity;
    private List<String> checkedInAttendees; // List of attendees successfully checked in
    private Queue<String> waitingList;      // Queue of attendees waiting for a spot

    /**
     * Constructs a new Session.
     *
     * @param id       The unique ID of the session.
     * @param name     The name of the session.
     * @param capacity The maximum number of attendees that can be checked in.
     */
    public Session(int id, String name, int capacity) {
        this.id = id;
        this.name = name;
        this.capacity = capacity;
        this.checkedInAttendees = new ArrayList<>(); // Initialize ArrayList
        this.waitingList = new LinkedList<>();      // LinkedList implements Queue
    }

    // --- Getters ---
    public int getId() {
        return id;
    }

    public String getName() {
        return name;
    }

    public int getCapacity() {
        return capacity;
    }

    /**
     * Gets a copy of the list of attendees who are checked in.
     *
     * @return A new ArrayList containing the checked-in attendee names.
     */
    public List<String> getCheckedInAttendees() {
        // Return a copy to maintain encapsulation
        return new ArrayList<>(checkedInAttendees);
    }

    /**
     * Gets a copy of the list of attendees currently on the waiting list.
     *
     * @return A new ArrayList containing the waiting list attendee names (order preserved).
     */
    public List<String> getWaitingList() {
        // Convert Queue to List for easy display while preserving order
        return new ArrayList<>(waitingList);
    }

    // --- Core Functionality Methods ---

    /**
     * Adds an attendee to the waiting list for this session.
     * Performs basic validation and checks for duplicates.
     *
     * @param attendeeName The name of the attendee to add.
     */
    public void addAttendeeToWaitingList(String attendeeName) {
        // Input validation
        if (attendeeName == null || attendeeName.trim().isEmpty()) {
            System.err.println("Error: Attendee name cannot be empty.");
            return;
        }
        String trimmedName = attendeeName.trim();

        // Prevent duplicates or adding someone already checked in
        if (waitingList.contains(trimmedName)) {
            System.out.println(trimmedName + " is already on the waiting list for " + name + ".");
            return;
        }
        if (checkedInAttendees.contains(trimmedName)) {
            System.out.println(trimmedName + " is already checked in for " + name + ".");
            return;
        }

        // Add to the end of the waiting list queue
        waitingList.offer(trimmedName);
        System.out.println(trimmedName + " has been added to the waiting list for " + name + " (ID: " + id + ").");
    }

    /**
     * Attempts to check in an attendee from the waiting list.
     * If the attendee is on the waiting list and there is space, they are moved
     * from the waiting list to the checked-in list.
     *
     * @param attendeeName The name of the attendee to check in.
     * @return 1 if successfully checked in, 0 if still on waiting list (session full), -1 if attendee not found in waiting list.
     */
    public int checkInAttendee(String attendeeName) {
        // Input validation
        if (attendeeName == null || attendeeName.trim().isEmpty()) {
            System.err.println("Error: Attendee name cannot be empty.");
            return -1; // Indicate failure
        }
        String trimmedName = attendeeName.trim();

        // Check if attendee is on the waiting list
        if (!waitingList.contains(trimmedName)) {
            // Also check if they are already checked in before saying not found
            if (checkedInAttendees.contains(trimmedName)) {
                // System.out.println(trimmedName + " is already checked in for " + name + "."); // Output handled by caller based on return
                return -1; // Indicate already checked in (not found in waiting list)
            }
            return -1; // Attendee not found in waiting list
        }

        // Check if there is space available
        if (checkedInAttendees.size() < capacity) {
            // Remove from the waiting list (remove specific element)
            boolean removed = waitingList.remove(trimmedName);

            if (removed) {
                // Add to the checked-in list
                checkedInAttendees.add(trimmedName);
                return 1; // Successfully checked in
            } else {
                // This case should theoretically not happen if contains() returned true, but included for robustness
                System.err.println("Internal error: Could not remove " + trimmedName + " from waiting list during check-in attempt.");
                return -1;
            }
        } else {
            // Session is full, attendee remains on the waiting list
            return 0; // Still on waiting list (session full)
        }
    }

    /**
     * Checks if the session has reached its maximum capacity.
     *
     * @return true if the number of checked-in attendees is equal to or greater than the capacity, false otherwise.
     */
    public boolean isFull() {
        return checkedInAttendees.size() >= capacity;
    }

    /**
     * Calculates the number of available spots in the session.
     *
     * @return The number of spots remaining before capacity is reached.
     */
    public int getAvailableSpots() {
        return capacity - checkedInAttendees.size();
    }

    /**
     * Displays detailed information about the session, including attendees.
     */
    public void displaySessionInfo() {
        System.out.println("\n--- Session Details ---");
        System.out.println("ID: " + id);
        System.out.println("Name: " + name);
        System.out.println("Capacity: " + capacity);
        System.out.println("Checked-in Attendees (" + checkedInAttendees.size() + "/" + capacity + "): " + checkedInAttendees);
        System.out.println("Waiting List (" + waitingList.size() + "): " + new ArrayList<>(waitingList)); // Display queue contents as a list
        System.out.println("-----------------------");
    }
}


/**
 * Manages multiple event sessions and handles user interaction.
 */
public class EventManager {

    private List<Session> sessions; // Using List interface, implemented by ArrayList

    /**
     * Constructs the EventManager and initializes sample sessions.
     */
    public EventManager() {
        sessions = new ArrayList<>(); // Using ArrayList implementation
        // Add some sample sessions
        sessions.add(new Session(101, "Java Basics", 2));
        sessions.add(new Session(102, "Advanced Data Structures", 3));
        sessions.add(new Session(103, "Web Development Fundamentals", 5));
        System.out.println("EventManager initialized with sample sessions.");
    }

    /**
     * Finds a session by its unique ID.
     *
     * @param sessionId The ID of the session to find.
     * @return The Session object if found, otherwise null.
     */
    private Session findSession(int sessionId) {
        for (Session session : sessions) {
            if (session.getId() == sessionId) {
                return session;
            }
        }
        return null; // Session not found
    }

    /**
     * Runs the main event management system loop, handling user input and operations.
     * Includes class-wide exception handling.
     */
    public void run() {
        Scanner scanner = new Scanner(System.in);
        int choice = -1;

        // Class-wide exception handling around the main operational loop
        try {
            while (choice != 4) {
                printMenu();
                System.out.print("Enter your choice: ");

                try {
                    choice = scanner.nextInt(); // Read user choice
                    scanner.nextLine(); // Consume the rest of the line including the newline character

                    switch (choice) {
                        case 1: // Add Attendee to Waiting List
                            handleAddAttendee(scanner);
                            break;
                        case 2: // Check-in Attendee
                            handleCheckInAttendee(scanner);
                            break;
                        case 3: // View Session Info
                            handleViewSessionInfo(scanner);
                            break;
                        case 4: // Exit
                            System.out.println("Exiting Event Management System. Goodbye!");
                            break;
                        default:
                            System.err.println("Invalid choice. Please enter a number between 1 and 4.");
                    }
                } catch (InputMismatchException e) {
                    // Handle cases where non-integer input is given for the menu choice
                    System.err.println("Invalid input. Please enter a number.");
                    scanner.nextLine(); // Consume the invalid input line to prevent infinite loop
                    choice = -1; // Reset choice to ensure the loop continues
                }
                System.out.println(); // Add a newline for better formatting between operations
            }
        } catch (Exception e) {
            // Catch any other unexpected runtime exceptions that might occur
            System.err.println("An unexpected error occurred: " + e.getMessage());
            // e.printStackTrace(); // Uncomment for detailed debugging information
        } finally {
             // Ensure the scanner is closed when the application exits or an unhandled exception occurs
             if (scanner != null) {
                scanner.close();
                System.out.println("Scanner closed."); // Optional: confirmation
             }
        }
    }

    /**
     * Prints the main menu options to the console.
     */
    private void printMenu() {
        System.out.println("--- Event Management Menu ---");
        System.out.println("1. Add Attendee to Waiting List");
        System.out.println("2. Check-in Attendee");
        System.out.println("3. View Session Info");
        System.out.println("4. Exit");
        System.out.println("-----------------------------");
    }

    /**
     * Handles the process of adding an attendee to a session's waiting list.
     * Prompts user for session ID and attendee name.
     *
     * @param scanner The Scanner object for reading input.
     */
    private void handleAddAttendee(Scanner scanner) {
        System.out.print("Enter Session ID: ");
        try {
            int sessionId = scanner.nextInt();
            scanner.nextLine(); // Consume newline after reading int

            Session session = findSession(sessionId);
            if (session == null) {
                System.err.println("Error: Session with ID " + sessionId + " not found.");
                return;
            }

            System.out.print("Enter Attendee Name: ");
            String attendeeName = scanner.nextLine().trim();

            // Delegate adding to the Session class
            session.addAttendeeToWaitingList(attendeeName);

        } catch (InputMismatchException e) {
            System.err.println("Invalid input for Session ID. Please enter a number.");
            scanner.nextLine(); // Consume invalid input
        }
    }

    /**
     * Handles the process of checking in an attendee for a session.
     * Prompts user for session ID and attendee name.
     *
     * @param scanner The Scanner object for reading input.
     */
    private void handleCheckInAttendee(Scanner scanner) {
         System.out.print("Enter Session ID: ");
        try {
            int sessionId = scanner.nextInt();
            scanner.nextLine(); // Consume newline after reading int

            Session session = findSession(sessionId);
            if (session == null) {
                System.err.println("Error: Session with ID " + sessionId + " not found.");
                return;
            }

            System.out.print("Enter Attendee Name to Check In: ");
            String attendeeName = scanner.nextLine().trim();

            // Delegate check-in logic to the Session class
            int status = session.checkInAttendee(attendeeName);

            // Interpret the status returned by Session.checkInAttendee
            if (status == 1) {
                System.out.println(attendeeName + " successfully checked in for " + session.getName() + " (ID: " + sessionId + ").");
            } else if (status == 0) {
                System.out.println(attendeeName + " is still on the waiting list for " + session.getName() + " (ID: " + sessionId + "). Session is currently full.");
            } else { // status == -1
                 System.err.println("Error: Attendee " + attendeeName + " not found in the waiting list or already checked in for " + session.getName() + " (ID: " + sessionId + ").");
            }

        } catch (InputMismatchException e) {
            System.err.println("Invalid input for Session ID. Please enter a number.");
            scanner.nextLine(); // Consume invalid input
        }
    }

    /**
     * Handles the process of viewing details for a specific session.
     * Prompts user for session ID.
     *
     * @param scanner The Scanner object for reading input.
     */
    private void handleViewSessionInfo(Scanner scanner) {
        System.out.print("Enter Session ID: ");
        try {
            int sessionId = scanner.nextInt();
            scanner.nextLine(); // Consume newline after reading int

            Session session = findSession(sessionId);
            if (session == null) {
                System.err.println("Error: Session with ID " + sessionId + " not found.");
                return;
            }

            // Delegate displaying info to the Session class
            session.displaySessionInfo();

        } catch (InputMismatchException e) {
            System.err.println("Invalid input for Session ID. Please enter a number.");
            scanner.nextLine(); // Consume invalid input
        }
    }

    /**
     * The main method to start the Event Management System.
     *
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        EventManager manager = new EventManager();
        manager.run(); // Start the main application loop
    }
}
