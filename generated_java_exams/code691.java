/*
 * Exam Question #691
 * Generated on: 2025-05-12 16:26:30
 * Generated by: Account 2
 * 
 * QUESTION:
 * ## Advanced Java Programming Exam Task: Restaurant Order Management System
 * 
 * **Scenario:**
 * 
 * You are tasked with developing a simplified backend system for managing customer orders in a restaurant. The system needs to handle incoming orders, process them one by one, and keep track of completed orders.
 * 
 * **Requirements:**
 * 
 * Implement a Java application that simulates this process. Your solution must adhere to the following:
 * 
 * 1.  **Data Structures:**
 *     *   Use a `java.util.Queue` to store incoming orders that are waiting to be prepared.
 *     *   Use a `java.util.List` (specifically, a `java.util.ArrayList` as the concrete implementation) to store orders that have been completed.
 *     *   Create a custom class `Order` to represent an order, containing an order ID (integer) and a list of items (List<String>).
 * 
 * 2.  **Functionality:**
 *     *   **Add Order:** Allow the user to add a new order. The system should automatically assign a unique increasing order ID starting from 1. The user should input the items for the order (you can prompt for items one by one until the user enters a specific keyword like "done"). The new order is added to the waiting queue.
 *     *   **Process Next Order:** Take the next order from the waiting queue (if any) and mark it as completed. This order should then be moved to the list of completed orders. If the queue is empty, display an appropriate message.
 *     *   **View Waiting Orders:** Display all orders currently in the waiting queue, showing their ID and items.
 *     *   **View Completed Orders:** Display all orders that have been completed, showing their ID and items.
 *     *   **Exit:** Terminate the application.
 * 
 * 3.  **User Interface:**
 *     *   Provide a simple text-based menu using `System.out` for the user to choose actions (Add Order, Process Next Order, View Waiting Orders, View Completed Orders, Exit).
 *     *   Use `java.util.Scanner` to read user input for menu choices and order details.
 * 
 * 4.  **Control Flow & Error Handling:**
 *     *   Use a `switch` statement to handle the user's menu choice.
 *     *   Use `System.err` to display error messages (e.g., invalid menu choice, trying to process from an empty queue).
 *     *   Use `System.out` for all normal output (menu, prompts, order details, success messages).
 *     *   Implement class-wide exception handling using `try-catch` blocks to gracefully handle potential issues, such as invalid input format for the menu choice.
 * 
 * 5.  **Best Practices:**
 *     *   Apply proper encapsulation (private fields, public methods) in the `Order` class and the main management class.
 *     *   Use meaningful variable and method names.
 *     *   Include appropriate comments and documentation (basic Javadoc or inline comments).
 *     *   Implement input validation where necessary (e.g., handling non-numeric menu input).
 * 
 * **Expected Output Examples:**
 * 
 * *   **Menu Display:**
 *     ```
 *     Restaurant Order Management
 *     1. Add New Order
 *     2. Process Next Order
 *     3. View Waiting Orders
 *     4. View Completed Orders
 *     5. Exit
 *     Enter your choice: 
 *     ```
 * *   **Adding Order:**
 *     ```
 *     Enter item for Order 1 (type 'done' when finished): Burger
 *     Enter item for Order 1 (type 'done' when finished): Fries
 *     Enter item for Order 1 (type 'done' when finished): done
 *     Order 1 added to the waiting queue.
 *     ```
 * *   **Processing Order:**
 *     ```
 *     Processing next order...
 *     Order 1 (Items: [Burger, Fries]) has been completed.
 *     ```
 *     *Or if queue is empty:*
 *     ```
 *     No orders in the waiting queue to process.
 *     ```
 * *   **Viewing Waiting Orders:**
 *     ```
 *     --- Waiting Orders ---
 *     Order 2 (Items: [Pizza, Coke])
 *     Order 3 (Items: [Salad])
 *     ----------------------
 *     ```
 *     *Or if empty:*
 *     ```
 *     No orders currently waiting.
 *     ```
 * *   **Viewing Completed Orders:**
 *     ```
 *     --- Completed Orders ---
 *     Order 1 (Items: [Burger, Fries])
 *     ------------------------
 *     ```
 *     *Or if empty:*
 *     ```
 *     No orders have been completed yet.
 *     ```
 * *   **Invalid Input:**
 *     ```
 *     Invalid input. Please enter a number between 1 and 5.
 *     ```
 *     *Or if non-numeric:*
 *     ```
 *     Error: Invalid input format. Please enter a valid number.
 *     ```
 * 
 * Your solution should be contained within a single file for simplicity in an exam setting, but use appropriate classes.
 *
 * EXPLANATION:
 * The solution implements the `RestaurantOrderManagement` system as requested, demonstrating the required Java concepts.
 * 
 * 1.  **`Order` Class:** This class encapsulates the data for a single order: `orderId` (an integer) and `items` (a `List<String>`). It follows encapsulation principles with private fields and public getter methods. The `toString()` method provides a convenient way to print order details. Defensive copies are used in the constructor and `getItems()` to protect the internal state of the `items` list.
 * 
 * 2.  **`RestaurantOrderManager` Class:** This is the main class that orchestrates the system.
 *     *   **Data Structures:**
 *         *   `waitingOrders`: A `Queue<Order>` is declared and initialized with a `LinkedList`. The `Queue` is perfect for this scenario because it enforces a First-In, First-Out (FIFO) order, meaning the oldest order added is the next one to be processed.
 *         *   `completedOrders`: A `List<Order>` is declared and initialized with an `ArrayList`. The `List` is suitable for storing completed orders as we might need to iterate through them or potentially add/remove elements from anywhere (though in this simple case, we only add to the end).
 *         *   `nextOrderId`: An integer keeps track of the next available unique ID for a new order.
 *     *   **`scanner`:** A `Scanner` object is created to read input from `System.in`.
 *     *   **`displayMenu()`:** A helper method to print the options to the console using `System.out`.
 *     *   **`addOrder()`:**
 *         *   Prompts the user to enter items using `System.out`.
 *         *   Uses a loop and `scanner.nextLine()` to read items one by one until "done" is entered.
 *         *   Stores the entered items in a local `ArrayList<String>`.
 *         *   Creates a new `Order` object with the `nextOrderId` and the list of items.
 *         *   Adds the new order to the `waitingOrders` queue using `offer()`. `offer()` is preferred over `add()` for queues as it returns `false` if the element cannot be added (though for `LinkedList`, it typically always succeeds).
 *         *   Increments `nextOrderId`.
 *         *   Includes basic validation to prevent adding an order with no items and warns against empty item names.
 *         *   Includes `scanner.nextLine()` call after reading the integer choice in `run()` to consume the leftover newline before reading string items.
 *     *   **`processNextOrder()`:**
 *         *   Retrieves the next order from the `waitingOrders` queue using `poll()`. `poll()` is used because it returns `null` if the queue is empty, allowing for graceful handling. Using `remove()` would throw a `NoSuchElementException` if the queue is empty.
 *         *   If `poll()` returns `null`, an error message is printed to `System.err`.
 *         *   If an order is retrieved, it is added to the `completedOrders` list using `add()`. A success message is printed to `System.out`.
 *     *   **`viewWaitingOrders()`:**
 *         *   Checks if the `waitingOrders` queue is empty and prints a message to `System.out` if it is.
 *         *   If not empty, it iterates through the `waitingOrders` queue using a for-each loop. This iteration *does not* remove elements from the queue, allowing them to remain for processing. Prints each order using `System.out`.
 *     *   **`viewCompletedOrders()`:**
 *         *   Checks if the `completedOrders` list is empty and prints a message to `System.out` if it is.
 *         *   If not empty, it iterates through the `completedOrders` list and prints each order using `System.out`.
 *     *   **`run()`:**
 *         *   This method contains the main application loop (`while(running)`).
 *         *   Inside the loop, it displays the menu and attempts to read the user's integer choice using `scanner.nextInt()`.
 *         *   **`try-catch` Block:** A `try-catch` block is wrapped around the input reading and the `switch` statement.
 *             *   `catch (InputMismatchException e)`: Catches the specific error that occurs if the user enters non-numeric input when an integer is expected. An error message is printed to `System.err`, and `scanner.next()` is called to consume the invalid input, preventing an infinite loop.
 *             *   `catch (Exception e)`: This is a general catch block to handle any other unexpected runtime exceptions that might occur within the loop's logic. An error message including the exception's message is printed to `System.err`. This provides robust, class-wide handling for unforeseen issues.
 *         *   **`switch` Statement:** Controls the flow based on the user's valid integer choice, calling the appropriate private methods (`addOrder`, `processNextOrder`, etc.). A `default` case handles integer inputs that are outside the valid range (1-5), printing an error to `System.err`.
 *         *   The loop continues until the user chooses option 5 (`Exit`), setting `running` to `false`.
 *         *   Finally, `scanner.close()` is called to release the scanner resources.
 *     *   **`main()`:** The entry point of the application. It creates an instance of `RestaurantOrderManager` and calls its `run()` method to start the system.
 * 
 * This solution effectively integrates all the required Java components within a practical scenario, demonstrating proper data structure usage, flow control (`switch`), input/output (`Scanner`, `System.out`, `System.err`), and robust error handling (`try-catch`, input validation, empty collection checks).
 */

import java.util.Queue;
import java.util.LinkedList;
import java.util.List;
import java.util.ArrayList;
import java.util.Scanner;
import java.util.InputMismatchException;

/**
 * Represents a single customer order.
 */
class Order {
    private int orderId;
    private List<String> items;

    /**
     * Constructs a new Order.
     * @param orderId The unique ID for the order.
     * @param items The list of items included in the order.
     */
    public Order(int orderId, List<String> items) {
        this.orderId = orderId;
        // Create a defensive copy of the items list
        this.items = new ArrayList<>(items);
    }

    /**
     * Gets the order ID.
     * @return The order ID.
     */
    public int getOrderId() {
        return orderId;
    }

    /**
     * Gets the list of items in the order.
     * @return The list of items.
     */
    public List<String> getItems() {
        // Return a defensive copy to prevent external modification
        return new ArrayList<>(items);
    }

    /**
     * Provides a string representation of the order.
     * @return A formatted string showing order ID and items.
     */
    @Override
    public String toString() {
        return "Order " + orderId + " (Items: " + items + ")";
    }
}

/**
 * Manages restaurant orders using a waiting queue and a completed list.
 */
public class RestaurantOrderManager {

    private Queue<Order> waitingOrders;
    private List<Order> completedOrders;
    private int nextOrderId;
    private Scanner scanner;

    /**
     * Constructs a new RestaurantOrderManager.
     * Initializes the queues, lists, and scanner.
     */
    public RestaurantOrderManager() {
        waitingOrders = new LinkedList<>(); // LinkedList implements Queue
        completedOrders = new ArrayList<>(); // ArrayList implements List
        nextOrderId = 1;
        scanner = new Scanner(System.in);
    }

    /**
     * Displays the main menu to the user.
     */
    private void displayMenu() {
        System.out.println("\nRestaurant Order Management");
        System.out.println("1. Add New Order");
        System.out.println("2. Process Next Order");
        System.out.println("3. View Waiting Orders");
        System.out.println("4. View Completed Orders");
        System.out.println("5. Exit");
        System.out.print("Enter your choice: ");
    }

    /**
     * Adds a new order to the waiting queue based on user input.
     */
    private void addOrder() {
        System.out.println("--- Add New Order ---");
        List<String> items = new ArrayList<>();
        String item;
        System.out.println("Enter item for Order " + nextOrderId + " (type 'done' when finished):");

        // Consume the leftover newline character from previous input
        scanner.nextLine(); 

        while (true) {
            System.out.print("> ");
            item = scanner.nextLine().trim();
            if (item.equalsIgnoreCase("done")) {
                break;
            }
            if (!item.isEmpty()) {
                items.add(item);
            } else {
                System.err.println("Warning: Item cannot be empty.");
            }
        }

        if (items.isEmpty()) {
            System.err.println("Order cancelled: No items were added.");
        } else {
            Order newOrder = new Order(nextOrderId, items);
            waitingOrders.offer(newOrder); // offer is generally preferred over add for queues
            System.out.println("Order " + nextOrderId + " added to the waiting queue.");
            nextOrderId++;
        }
    }

    /**
     * Processes the next order from the waiting queue and moves it to completed.
     */
    private void processNextOrder() {
        System.out.println("--- Processing Next Order ---");
        Order orderToProcess = waitingOrders.poll(); // poll returns null if queue is empty

        if (orderToProcess == null) {
            System.err.println("No orders in the waiting queue to process.");
        } else {
            completedOrders.add(orderToProcess);
            System.out.println(orderToProcess + " has been completed.");
        }
    }

    /**
     * Displays all orders currently in the waiting queue.
     */
    private void viewWaitingOrders() {
        System.out.println("--- Waiting Orders ---");
        if (waitingOrders.isEmpty()) {
            System.out.println("No orders currently waiting.");
        } else {
            // Iterate through the queue without removing elements
            for (Order order : waitingOrders) {
                System.out.println(order);
            }
        }
        System.out.println("----------------------");
    }

    /**
     * Displays all orders that have been completed.
     */
    private void viewCompletedOrders() {
        System.out.println("--- Completed Orders ---");
        if (completedOrders.isEmpty()) {
            System.out.println("No orders have been completed yet.");
        } else {
            for (Order order : completedOrders) {
                System.out.println(order);
            }
        }
        System.out.println("------------------------");
    }

    /**
     * Runs the main application loop, handling user interaction.
     */
    public void run() {
        boolean running = true;
        while (running) {
            displayMenu();
            try {
                int choice = scanner.nextInt();

                switch (choice) {
                    case 1:
                        addOrder();
                        break;
                    case 2:
                        processNextOrder();
                        break;
                    case 3:
                        viewWaitingOrders();
                        break;
                    case 4:
                        viewCompletedOrders();
                        break;
                    case 5:
                        System.out.println("Exiting Restaurant Order Management. Goodbye!");
                        running = false;
                        break;
                    default:
                        System.err.println("Invalid choice. Please enter a number between 1 and 5.");
                }
            } catch (InputMismatchException e) {
                // Handle non-integer input
                System.err.println("Error: Invalid input format. Please enter a valid number.");
                scanner.next(); // Consume the invalid input to prevent infinite loop
            } catch (Exception e) {
                // Catch any other unexpected exceptions during processing
                System.err.println("An unexpected error occurred: " + e.getMessage());
                // Optionally print stack trace for debugging: e.printStackTrace();
            }
        }
        scanner.close(); // Close the scanner when exiting
    }

    /**
     * Main method to start the application.
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        RestaurantOrderManager manager = new RestaurantOrderManager();
        manager.run();
    }
}
