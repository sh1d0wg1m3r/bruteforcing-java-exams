/*
 * Exam Question #1165
 * Generated on: 2025-05-12 17:33:58
 * Generated by: Account 3
 * 
 * QUESTION:
 * ## Advanced Java Programming Exam Task: Team Task Management System
 * 
 * **Objective:** Design and implement a console-based task management system for a small team. The system should allow users to add new tasks, process the next pending task, view pending tasks, and view completed tasks. This task requires demonstrating a strong understanding of core Java collections, control flow, input/output, and exception handling.
 * 
 * **Scenario:** You are developing a simple command-line application to manage a queue of tasks for a development team. Tasks are added to a pending queue and processed in a First-In, First-Out (FIFO) manner. Once processed, tasks are moved to a list of completed tasks.
 * 
 * **Requirements:**
 * 
 * 1.  **Task Representation:** Create a `Task` class with private fields for `taskId` (String, unique identifier), `description` (String), and `status` (enum or String, e.g., "PENDING", "COMPLETED"). Include a constructor, getters, and a meaningful `toString()` method.
 * 2.  **Task Management Logic:** Create a `TaskManager` class that encapsulates the task management logic.
 *     *   Use a `java.util.Queue` (specifically, a `LinkedList` implementation) to store tasks that are currently pending.
 *     *   Use a `java.util.ArrayList` to store tasks that have been completed. Declare the field using the `java.util.List` interface.
 *     *   Implement methods:
 *         *   `addTask(String description)`: Adds a new task with a unique ID and "PENDING" status to the pending queue.
 *         *   `processNextTask()`: Removes the task at the front of the pending queue, updates its status to "COMPLETED", and adds it to the completed tasks list. Should handle the case where the pending queue is empty.
 *         *   `getPendingTasks()`: Returns a `List` of pending tasks.
 *         *   `getCompletedTasks()`: Returns the `List` of completed tasks.
 * 3.  **User Interface (in `main` method):**
 *     *   Use `java.util.Scanner` to read user input from the console.
 *     *   Present a menu of options to the user:
 *         1.  Add New Task
 *         2.  Process Next Task
 *         3.  View Pending Tasks
 *         4.  View Completed Tasks
 *         5.  Exit
 *     *   Use a `switch` statement to handle the user's menu choice.
 *     *   Implement a loop that continues until the user chooses to exit.
 * 4.  **Input Validation:**
 *     *   Validate user menu input to ensure it is a valid integer choice.
 *     *   Validate task description input to ensure it is not empty or null.
 * 5.  **Error Handling:**
 *     *   Use `try-catch` blocks to handle potential exceptions, such as `NumberFormatException` for invalid menu input or a custom exception (e.g., `NoTasksPendingException`) when `processNextTask` is called on an empty queue.
 *     *   Use `System.err.println()` to display error messages to the user.
 * 6.  **Output:**
 *     *   Use `System.out.println()` for displaying the menu, prompts, task details, and success messages.
 *     *   Format task output clearly using the `Task` class's `toString()` method.
 * 7.  **Best Practices:**
 *     *   Employ proper encapsulation (`private` fields, `public` methods).
 *     *   Use meaningful variable and method names.
 *     *   Include appropriate comments and documentation (basic Javadoc or inline comments).
 *     *   Ensure clean code structure.
 * 8.  **Required Components Checklist:** Ensure your solution explicitly uses: `java.util.Queue`, `java.util.ArrayList`, `java.util.List`, `java.util.Scanner`, `switch` statement, `System.err`, `System.out`, `try-catch` blocks.
 * 
 * **Expected Output Structure (Example):**
 * 
 * ```
 * --- Task Management System ---
 * 1. Add New Task
 * 2. Process Next Task
 * 3. View Pending Tasks
 * 4. View Completed Tasks
 * 5. Exit
 * Enter your choice: 1
 * Enter task description: Implement login feature
 * Task added successfully!
 * 
 * --- Task Management System ---
 * ... menu ...
 * Enter your choice: 1
 * Enter task description: Design database schema
 * Task added successfully!
 * 
 * --- Task Management System ---
 * ... menu ...
 * Enter your choice: 3
 * Pending Tasks:
 * Task ID: task-1 | Status: PENDING | Description: Implement login feature
 * Task ID: task-2 | Status: PENDING | Description: Design database schema
 * 
 * --- Task Management System ---
 * ... menu ...
 * Enter your choice: 2
 * Processing next task...
 * Task 'task-1' completed.
 * 
 * --- Task Management System ---
 * ... menu ...
 * Enter your choice: 3
 * Pending Tasks:
 * Task ID: task-2 | Status: PENDING | Description: Design database schema
 * 
 * --- Task Management System ---
 * ... menu ...
 * Enter your choice: 4
 * Completed Tasks:
 * Task ID: task-1 | Status: COMPLETED | Description: Implement login feature
 * 
 * --- Task Management System ---
 * ... menu ...
 * Enter your choice: 2
 * Processing next task...
 * Task 'task-2' completed.
 * 
 * --- Task Management System ---
 * ... menu ...
 * Enter your choice: 2
 * Processing next task...
 * Error: No tasks currently pending.
 * 
 * --- Task Management System ---
 * ... menu ...
 * Enter your choice: abc
 * Error: Invalid input. Please enter a number between 1 and 5.
 * 
 * --- Task Management System ---
 * ... menu ...
 * Enter your choice: 5
 * Exiting system.
 * ```
 * 
 * **Evaluation:** Your solution will be evaluated on correctness, adherence to all requirements (especially the use of specified Java components), code quality, error handling robustness, and clarity.
 *
 * EXPLANATION:
 * This solution implements a simple console-based task management system, fulfilling all the requirements of the exam question.
 * 
 * 1.  **Task Representation (`Task` class):**
 *     *   The `Task` class is a simple Plain Old Java Object (POJO) with private fields (`taskId`, `description`, `status`) demonstrating encapsulation.
 *     *   It includes a constructor, public getters, and a `toString()` method for easy representation of task data.
 *     *   A unique `taskId` is generated using `UUID` to differentiate tasks.
 * 
 * 2.  **Task Management Logic (`TaskManager` class):**
 *     *   `pendingTasks`: Declared as `Queue<Task>` and initialized with `new LinkedList<>()`. This correctly uses the `Queue` interface and a common implementation (`LinkedList`) to maintain the FIFO order required for processing tasks. `offer()` is used for adding, and `poll()` for removing, which are standard `Queue` operations that handle capacity issues gracefully (though not strictly necessary in this unbounded scenario, it's good practice).
 *     *   `completedTasks`: Declared as `List<Task>` and initialized with `new ArrayList<>()`. This correctly uses the `List` interface and the `ArrayList` implementation to store completed tasks in the order they were finished.
 *     *   `addTask()`: Creates a new `Task` and adds it to the `pendingTasks` queue.
 *     *   `processNextTask()`: Uses `pendingTasks.poll()` to get and remove the next task. It checks if the result is `null` (meaning the queue was empty) and throws a custom exception `NoTasksPendingException` if so. Otherwise, it updates the task status and adds it to the `completedTasks` list.
 *     *   `getPendingTasks()` and `getCompletedTasks()`: These methods return views of the internal collections. `getPendingTasks` returns a *new* `ArrayList` created from the queue to prevent external code from modifying the queue's structure directly. `getCompletedTasks` returns the internal `ArrayList`, adhering to the `List` interface return type.
 * 
 * 3.  **User Interface (`main` method):**
 *     *   A `Scanner` is used to read input from `System.in`.
 *     *   A `while` loop keeps the application running until the user chooses to exit.
 *     *   `printMenu()` displays the available options using `System.out.println()`.
 *     *   User input is read using `scanner.nextLine()` and then parsed. Reading as a string first is a common technique to prevent issues with the scanner leaving newline characters in the buffer when mixing `nextInt()` and `nextLine()`.
 *     *   A `switch` statement is used to direct the program flow based on the user's parsed integer choice, cleanly separating the logic for each menu option.
 * 
 * 4.  **Input Validation:**
 *     *   The `try-catch(NumberFormatException)` around the `Integer.parseInt(input)` call handles cases where the user enters non-numeric input for the menu choice.
 *     *   Inside `case 1`, a check `description == null || description.trim().isEmpty()` validates that the task description is not empty.
 * 
 * 5.  **Error Handling:**
 *     *   A custom exception `NoTasksPendingException` is defined and thrown by `processNextTask()` when the queue is empty, providing a specific error type for this scenario.
 *     *   `try-catch` blocks are used:
 *         *   Around the `Integer.parseInt()` call to catch `NumberFormatException`.
 *         *   Around the `taskManager.processNextTask()` call to catch the custom `NoTasksPendingException`.
 *         *   A broader `try-catch(Exception e)` wraps the main `while` loop to catch any other unexpected runtime exceptions that might occur, demonstrating a form of "class-wide" handling for the core operational loop.
 *     *   `System.err.println()` is used specifically for displaying error messages, distinguishing them from normal output.
 * 
 * 6.  **Output:**
 *     *   All standard program output (menu, prompts, success messages, task lists) is directed to `System.out.println()`.
 *     *   The `Task` class's `toString()` method ensures consistent and readable output for task details.
 * 
 * 7.  **Best Practices:**
 *     *   **Encapsulation:** `Task` and `TaskManager` classes have private fields and public methods to control access.
 *     *   **Naming:** Variables (`pendingTasks`, `completedTasks`, `description`, `choice`), methods (`addTask`, `processNextTask`, `getPendingTasks`), and classes (`Task`, `TaskManager`, `TaskManagementSystem`, `NoTasksPendingException`) have descriptive names.
 *     *   **Comments/Documentation:** Basic inline comments explain key parts, and method Javadoc describes their purpose and exceptions.
 *     *   **Clean Structure:** The code is organized into logical classes, and the `main` method clearly separates menu display, input handling, and calling `TaskManager` methods. The `printMenu` method is extracted for clarity.
 *     *   **Resource Management:** The `finally` block ensures the `Scanner` is closed when the application exits, preventing resource leaks.
 * 
 * This solution effectively demonstrates the required Java components within a practical application context, focusing on robust input handling and error management.
 */

import java.util.LinkedList;
import java.util.Queue;
import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;
import java.util.UUID; // To generate unique task IDs

// Custom exception for when no tasks are pending
class NoTasksPendingException extends Exception {
    public NoTasksPendingException(String message) {
        super(message);
    }
}

// Represents a single task
class Task {
    private String taskId;
    private String description;
    private String status; // Using String for simplicity, could be enum

    public Task(String taskId, String description) {
        this.taskId = taskId;
        this.description = description;
        this.status = "PENDING"; // Default status
    }

    // Getters
    public String getTaskId() {
        return taskId;
    }

    public String getDescription() {
        return description;
    }

    public String getStatus() {
        return status;
    }

    // Setter for status (used when processing)
    public void setStatus(String status) {
        this.status = status;
    }

    @Override
    public String toString() {
        return String.format("Task ID: %s | Status: %s | Description: %s",
                             taskId, status, description);
    }
}

// Manages the collection of tasks
class TaskManager {
    // Pending tasks are stored in a Queue (FIFO)
    private Queue<Task> pendingTasks;
    // Completed tasks are stored in a List
    private List<Task> completedTasks;

    public TaskManager() {
        this.pendingTasks = new LinkedList<>(); // LinkedList implements Queue
        this.completedTasks = new ArrayList<>(); // ArrayList implements List
    }

    /**
     * Adds a new task to the pending queue.
     * @param description The description of the task.
     */
    public void addTask(String description) {
        // Generate a unique ID for the task
        String taskId = "task-" + UUID.randomUUID().toString().substring(0, 6);
        Task newTask = new Task(taskId, description);
        pendingTasks.offer(newTask); // offer() is preferred over add() for queues
        System.out.println("Task added successfully!");
    }

    /**
     * Processes the next task from the pending queue.
     * Moves the task to the completed list.
     * @throws NoTasksPendingException if the pending queue is empty.
     */
    public void processNextTask() throws NoTasksPendingException {
        System.out.println("Processing next task...");
        Task nextTask = pendingTasks.poll(); // poll() retrieves and removes the head, returns null if empty

        if (nextTask == null) {
            throw new NoTasksPendingException("No tasks currently pending.");
        } else {
            nextTask.setStatus("COMPLETED");
            completedTasks.add(nextTask);
            System.out.println("Task '" + nextTask.getTaskId() + "' completed.");
        }
    }

    /**
     * Returns a list of all pending tasks.
     * @return A List of pending tasks.
     */
    public List<Task> getPendingTasks() {
        // Return a new list to prevent external modification of the internal queue
        return new ArrayList<>(pendingTasks);
    }

    /**
     * Returns a list of all completed tasks.
     * @return A List of completed tasks.
     */
    public List<Task> getCompletedTasks() {
        // Return the internal list (read-only access implied by returning List interface)
        // For true immutability, one might return Collections.unmodifiableList(completedTasks);
        return completedTasks;
    }
}

// Main class for the application
public class TaskManagementSystem {

    public static void main(String[] args) {
        TaskManager taskManager = new TaskManager();
        Scanner scanner = new Scanner(System.in);
        boolean running = true;

        // Class-wide exception handling for the main operational loop
        try {
            while (running) {
                printMenu();

                int choice = -1;
                // Try-catch for input reading and NumberFormatException
                try {
                    System.out.print("Enter your choice: ");
                    String input = scanner.nextLine(); // Read input as string first
                    choice = Integer.parseInt(input); // Attempt to parse as integer

                    // Switch statement to handle menu options
                    switch (choice) {
                        case 1:
                            System.out.print("Enter task description: ");
                            String description = scanner.nextLine();
                            // Input validation for description
                            if (description == null || description.trim().isEmpty()) {
                                System.err.println("Error: Task description cannot be empty.");
                            } else {
                                taskManager.addTask(description.trim());
                            }
                            break;

                        case 2:
                            // Try-catch specifically for processNextTask which can throw custom exception
                            try {
                                taskManager.processNextTask();
                            } catch (NoTasksPendingException e) {
                                System.err.println("Error: " + e.getMessage());
                            }
                            break;

                        case 3:
                            List<Task> pending = taskManager.getPendingTasks();
                            System.out.println("\n--- Pending Tasks ---");
                            if (pending.isEmpty()) {
                                System.out.println("No tasks pending.");
                            } else {
                                for (Task task : pending) {
                                    System.out.println(task);
                                }
                            }
                            System.out.println("---------------------");
                            break;

                        case 4:
                            List<Task> completed = taskManager.getCompletedTasks();
                            System.out.println("\n--- Completed Tasks ---");
                            if (completed.isEmpty()) {
                                System.out.println("No tasks completed yet.");
                            } else {
                                for (Task task : completed) {
                                    System.out.println(task);
                                }
                            }
                            System.out.println("-----------------------");
                            break;

                        case 5:
                            running = false; // Exit the loop
                            System.out.println("Exiting system.");
                            break;

                        default:
                            // Handles integers outside the valid range
                            System.err.println("Error: Invalid choice. Please enter a number between 1 and 5.");
                            break;
                    }
                } catch (NumberFormatException e) {
                    // Handles non-integer input for the menu choice
                    System.err.println("Error: Invalid input. Please enter a number.");
                }
                System.out.println(); // Add a newline for better formatting
            }
        } catch (Exception e) {
            // Catch any unexpected exceptions during the main loop execution
            System.err.println("An unexpected error occurred: " + e.getMessage());
            e.printStackTrace(); // Print stack trace for debugging
        } finally {
            scanner.close(); // Ensure scanner is closed when the program exits
        }
    }

    /**
     * Prints the main menu options to the console.
     */
    private static void printMenu() {
        System.out.println("--- Task Management System ---");
        System.out.println("1. Add New Task");
        System.out.println("2. Process Next Task");
        System.out.println("3. View Pending Tasks");
        System.out.println("4. View Completed Tasks");
        System.out.println("5. Exit");
    }
}
