/*
 * Exam Question #724
 * Generated on: 2025-05-12 16:31:29
 * Generated by: Account 4
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Advanced Task Management System
 * 
 * **Scenario:**
 * 
 * You are tasked with building a simple command-line task management system for a small team. The system needs to handle tasks with different priority levels. New tasks are added to a queue. When it's time to process a task, the system should prioritize tasks marked as HIGH priority. Once processed, tasks are moved to an archive.
 * 
 * **Requirements:**
 * 
 * Implement a Java application that fulfills the following:
 * 
 * 1.  **Data Structures:**
 *     *   Maintain a collection of *pending* tasks using the `java.util.Queue` interface. You should use `java.util.LinkedList` as the concrete implementation, as it also provides convenient list-like iteration capabilities needed for priority processing.
 *     *   Maintain a collection of *archived* tasks using the `java.util.List` interface. You should use `java.util.ArrayList` as the concrete implementation.
 * 
 * 2.  **Task Representation:**
 *     *   Create a `Task` class with private fields for `id` (integer, unique), `description` (String), and `priority` (an enum).
 *     *   Create a `Priority` enum with values `HIGH`, `MEDIUM`, `LOW`.
 *     *   Implement appropriate getters and a `toString()` method for the `Task` class.
 * 
 * 3.  **Task Management Logic (in a `TaskManager` class):**
 *     *   Implement a menu-driven interface using `java.util.Scanner` for user input.
 *     *   Use a `switch` statement to handle the user's menu choice.
 *     *   The menu options should include:
 *         1.  **Add New Task:** Prompt the user for a task description and priority (HIGH, MEDIUM, LOW). Assign a unique, incrementing ID to each new task. Add the new task to the *pending* queue. Validate the priority input; if invalid, use `System.err` to report the error and re-prompt or skip adding the task.
 *         2.  **Process Next Task:**
 *             *   Check if the *pending* queue is empty. If so, use `System.err` to report that there are no tasks to process.
 *             *   If not empty, find the *first* task in the queue with `Priority.HIGH`.
 *             *   If a `HIGH` priority task is found, remove it from the *pending* queue and move it to the *archived* list.
 *             *   If no `HIGH` priority task is found, remove the task at the front of the *pending* queue (standard FIFO behavior) and move it to the *archived* list.
 *             *   Use `System.out` to report which task was processed.
 *         3.  **View Pending Tasks:** Display all tasks currently in the *pending* queue using `System.out`. Do *not* remove them from the queue.
 *         4.  **View Archived Tasks:** Display all tasks currently in the *archived* list using `System.out`.
 *         5.  **Exit:** Terminate the program.
 *     *   Use `System.out` for all normal output (menu, prompts, task listings, success messages).
 *     *   Use `System.err` for all error messages (invalid input, empty queue for processing, unexpected errors).
 * 
 * 4.  **Exception Handling:**
 *     *   Implement input validation for priority using a `try-catch` block (e.g., catching `IllegalArgumentException` from `Priority.valueOf()`).
 *     *   Implement **class-wide exception handling** using a `try-catch` block that wraps the main operational loop (the loop that reads user input and uses the `switch` statement) to catch any unexpected runtime exceptions that might occur, printing an error message and stack trace to `System.err`.
 * 
 * 5.  **Best Practices:**
 *     *   Use proper encapsulation (private fields, public getters/methods).
 *     *   Use meaningful variable and method names.
 *     *   Include basic comments to explain complex logic (like priority processing).
 *     *   Ensure resources like `Scanner` are properly handled (e.g., closed).
 * 
 * **Expected Output:**
 * 
 * The program should present a menu and interact with the user via the console. Output will vary based on user input, but should adhere to the `System.out`/`System.err` requirements. Example interactions might include adding tasks, viewing lists, attempting to process tasks from an empty queue, processing tasks (demonstrating HIGH priority processing), and exiting.
 * 
 * **Evaluation:**
 * 
 * Your solution will be evaluated on:
 * *   Correct usage of all required Java components (`Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.err`, `System.out`, `try-catch`).
 * *   Correct implementation of the task management logic, especially the priority processing rule.
 * *   Robustness of input validation and error handling, including the class-wide `try-catch`.
 * *   Adherence to best practices (encapsulation, naming, comments).
 * *   Clean code structure.
 *
 * EXPLANATION:
 * The provided solution implements a simple Task Management System demonstrating the required Java concepts and best practices.
 * 
 * 1.  **Structure:** The application is structured into three main parts:
 *     *   `Priority` enum: Defines the possible priority levels (`HIGH`, `MEDIUM`, `LOW`).
 *     *   `Task` class: Represents a single task with an ID, description, and priority. It uses private fields and public getters for encapsulation and overrides `toString()` for convenient printing.
 *     *   `TaskManager` class: Contains the core logic and data structures. It manages the collection of pending and archived tasks and handles user interaction.
 * 
 * 2.  **Data Structures (`Queue`, `List`, `ArrayList`, `LinkedList`):**
 *     *   `pendingTasks` is declared as `Queue<Task>` and instantiated as `new LinkedList<>()`. This fulfills the requirement to use `Queue` and `LinkedList`. `LinkedList` is chosen because, in addition to implementing `Queue`, it also implements `List`, allowing for iteration and removal of elements based on criteria (finding the first HIGH priority task) which is slightly more complex with a pure `Queue` interface but necessary for the specific processing logic.
 *     *   `archivedTasks` is declared as `List<Task>` and instantiated as `new ArrayList<>()`. This fulfills the requirement to use `List` and `ArrayList`. `ArrayList` is suitable here as it provides dynamic resizing and efficient storage/retrieval of completed tasks.
 * 
 * 3.  **User Interaction (`Scanner`, `switch`, `System.out`, `System.err`):**
 *     *   A `Scanner` object (`scanner`) is used to read user input from the console (`System.in`).
 *     *   The `run()` method contains the main application loop, which repeatedly displays a menu using `System.out` and reads the user's choice.
 *     *   A `switch` statement is used to direct the program flow based on the user's numeric choice, calling the appropriate method (`addTask`, `processNextTask`, etc.).
 *     *   `System.out.println()` is used for displaying the menu, prompts, success messages, and the lists of tasks.
 *     *   `System.err.println()` is specifically used for displaying error messages, such as invalid menu choices, invalid priority input, or attempting to process tasks when the queue is empty.
 * 
 * 4.  **Task Management Logic:**
 *     *   `addTask()`: Prompts for description and priority, validates the priority input using a `try-catch` block around `Priority.valueOf(priorityString.toUpperCase())`, assigns a unique incrementing ID (`nextTaskId++`), creates a `Task` object, and adds it to the `pendingTasks` queue using `offer()`.
 *     *   `processNextTask()`: This method implements the core priority logic. It first checks if the queue is empty. If not, it iterates through the `pendingTasks` (`LinkedList`) using an `Iterator` to find the first `HIGH` priority task. If found, it removes the task using `iterator.remove()` (which is safe during iteration) and sets it as the `taskToProcess`. If no `HIGH` task is found after checking the entire queue, it falls back to standard FIFO by using `pendingTasks.poll()` to get and remove the task at the head of the queue. The selected task is then added to the `archivedTasks` list.
 *     *   `viewPendingTasks()` and `viewArchivedTasks()`: These methods simply iterate through the respective collections (`pendingTasks` and `archivedTasks`) and print the details of each task using `System.out`. They do not modify the collections.
 * 
 * 5.  **Exception Handling (`try-catch`):**
 *     *   **Input Validation:** In `addTask()`, a `try-catch(IllegalArgumentException)` block is used specifically to handle errors when converting the user's priority string input into a `Priority` enum value using `Priority.valueOf()`. Invalid input triggers an error message on `System.err` and prompts the user again.
 *     *   **Class-wide Handling:** A broad `try-catch(Exception e)` block is wrapped around the main `while` loop in the `run()` method. This serves as a safety net to catch any unexpected runtime exceptions that might occur during the execution of the program's main logic (e.g., within the switch cases or called methods) that weren't handled by more specific catches. It prints a general error message and the exception's stack trace to `System.err` before the program potentially terminates.
 *     *   A `finally` block is used to ensure the `Scanner` resource is closed when the `try` block (or the entire `run` method) finishes, regardless of whether an exception occurred or the loop exited normally.
 * 
 * 6.  **Best Practices:**
 *     *   Encapsulation is maintained by making fields private and providing public methods for access/modification where needed.
 *     *   Variable and method names are chosen to be descriptive (e.g., `pendingTasks`, `processNextTask`, `nextTaskId`).
 *     *   Basic comments are included, particularly in the `processNextTask` method, to explain the priority logic and the use of the iterator for removal.
 *     *   Input validation and error handling are explicitly implemented using `try-catch` and conditional checks (`isEmpty()`).
 *     *   The code is organized into logical classes and methods, contributing to a clean structure.
 * 
 * This solution effectively demonstrates the required components and techniques in a cohesive, practical application.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.Iterator; // Needed for safe removal while iterating

// Enum for Task Priority
enum Priority {
    HIGH, MEDIUM, LOW
}

// Task Class representing a single task
class Task {
    private int id;
    private String description;
    private Priority priority;

    // Constructor
    public Task(int id, String description, Priority priority) {
        this.id = id;
        this.description = description;
        this.priority = priority;
    }

    // Getters
    public int getId() {
        return id;
    }

    public String getDescription() {
        return description;
    }

    public Priority getPriority() {
        return priority;
    }

    // toString method for easy display
    @Override
    public String toString() {
        return String.format("ID: %d, Desc: \"%s\", Priority: %s", id, description, priority);
    }
}

// Task Management System Class
class TaskManager {
    // Queue for pending tasks (using LinkedList as implementation)
    private Queue<Task> pendingTasks;
    // List for archived tasks (using ArrayList as implementation)
    private List<Task> archivedTasks;
    // Scanner for user input
    private Scanner scanner;
    // Counter for unique task IDs
    private int nextTaskId = 1;

    // Constructor
    public TaskManager() {
        // LinkedList implements both Queue and List
        this.pendingTasks = new LinkedList<>();
        // ArrayList implements List
        this.archivedTasks = new ArrayList<>();
        this.scanner = new Scanner(System.in);
    }

    // Method to add a new task based on user input
    public void addTask() {
        System.out.println("\n--- Add New Task ---");
        System.out.print("Enter task description: ");
        String description = scanner.nextLine();

        Priority priority = null;
        boolean validPriority = false;
        while (!validPriority) {
            System.out.print("Enter priority (HIGH, MEDIUM, LOW): ");
            String priorityString = scanner.nextLine().trim(); // Read input
            try {
                // Attempt to convert string to Priority enum (case-insensitive)
                priority = Priority.valueOf(priorityString.toUpperCase());
                validPriority = true; // Input is valid
            } catch (IllegalArgumentException e) {
                // Catch exception if valueOf fails, indicating invalid priority string
                System.err.println("Invalid priority entered: '" + priorityString + "'. Please enter HIGH, MEDIUM, or LOW.");
            }
        }

        // Create new task with unique ID
        Task newTask = new Task(nextTaskId++, description, priority);
        // Add task to the end of the pending queue
        pendingTasks.offer(newTask);
        System.out.println("Task added successfully: " + newTask);
    }

    // Method to process the next task according to priority rules
    public void processNextTask() {
        System.out.println("\n--- Processing Task ---");
        // Check if the pending queue is empty
        if (pendingTasks.isEmpty()) {
            System.err.println("No tasks in the pending queue to process.");
            return;
        }

        Task taskToProcess = null;

        // Find the first HIGH priority task using an iterator for safe removal
        Iterator<Task> iterator = pendingTasks.iterator();
        while(iterator.hasNext()) {
            Task task = iterator.next();
            if (task.getPriority() == Priority.HIGH) {
                taskToProcess = task;
                iterator.remove(); // Remove the task found using the iterator
                break; // Found and removed the first HIGH priority task, stop searching
            }
        }

        // If no HIGH priority task was found, process the next task in FIFO order
        if (taskToProcess == null) {
            taskToProcess = pendingTasks.poll(); // Get and remove the head of the queue
        }

        // Move the processed task to the archived list
        if (taskToProcess != null) {
            archivedTasks.add(taskToProcess);
            System.out.println("Processed task: " + taskToProcess);
        } else {
             // This case should logically not be reached if pendingTasks was not empty,
             // but included as a safeguard.
             System.err.println("An error occurred while retrieving the task for processing.");
        }
    }

    // Method to view all pending tasks without removing them
    public void viewPendingTasks() {
        System.out.println("\n--- Pending Tasks ---");
        if (pendingTasks.isEmpty()) {
            System.out.println("No tasks currently pending.");
        } else {
            // Iterate through the queue to display tasks
            // LinkedList allows iteration
            int count = 1;
            for (Task task : pendingTasks) {
                System.out.println(count++ + ". " + task);
            }
        }
    }

    // Method to view all archived tasks
    public void viewArchivedTasks() {
        System.out.println("\n--- Archived Tasks ---");
        if (archivedTasks.isEmpty()) {
            System.out.println("No tasks have been archived yet.");
        } else {
            // Iterate through the list to display tasks
            int count = 1;
            for (Task task : archivedTasks) {
                System.out.println(count++ + ". " + task);
            }
        }
    }

    // Helper method to display the main menu
    private void displayMenu() {
        System.out.println("\n--- Task Manager Menu ---");
        System.out.println("1. Add New Task");
        System.out.println("2. Process Next Task");
        System.out.println("3. View Pending Tasks");
        System.out.println("4. View Archived Tasks");
        System.out.println("5. Exit");
        System.out.print("Enter your choice: ");
    }

    // Main method to run the task manager application loop
    public void run() {
        System.out.println("Task Manager Application Started.");
        boolean running = true;

        // Class-wide exception handling block wrapping the main loop
        try {
            while (running) {
                displayMenu();
                String choiceString = scanner.nextLine();
                int choice = -1; // Default invalid choice

                // Input validation for menu choice
                try {
                    choice = Integer.parseInt(choiceString);
                } catch (NumberFormatException e) {
                    System.err.println("Invalid input. Please enter a number.");
                    continue; // Skip the rest of the loop body and show menu again
                }

                // Switch statement to handle user choice
                switch (choice) {
                    case 1:
                        addTask();
                        break;
                    case 2:
                        processNextTask();
                        break;
                    case 3:
                        viewPendingTasks();
                        break;
                    case 4:
                        viewArchivedTasks();
                        break;
                    case 5:
                        running = false; // Set flag to exit the loop
                        System.out.println("Exiting Task Manager. Goodbye!");
                        break;
                    default:
                        // Handle choices outside the valid range
                        System.err.println("Invalid choice. Please enter a number between 1 and 5.");
                }
            }
        } catch (Exception e) {
            // Catch any unexpected runtime exceptions that might occur
            System.err.println("\nAn unexpected application error occurred:");
            e.printStackTrace(System.err); // Print the stack trace to standard error
            System.err.println("The application will now terminate.");
        } finally {
            // Ensure the scanner resource is closed when the application ends
            if (scanner != null) {
                scanner.close();
            }
            System.out.println("Scanner closed."); // Optional: Confirmation message
        }
    }

    // Main method to start the TaskManager
    public static void main(String[] args) {
        TaskManager manager = new TaskManager();
        manager.run();
    }
}
