/*
 * Exam Question #343
 * Generated on: 2025-05-11 22:57:58
 * Generated by: Account 1
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Simple Task Manager
 * 
 * **Problem Description:**
 * 
 * Design and implement a simple command-line Task Manager application. This application will simulate managing tasks that are added to a queue for processing and moved to a list once completed. Users will interact with the system by entering commands.
 * 
 * **Requirements:**
 * 
 * 1.  **Task Representation:** Create a class named `Task` with the following private fields:
 *     *   `int id`: A unique identifier for the task. Should be automatically generated starting from 1.
 *     *   `String name`: The name or description of the task.
 *     *   `int priority`: The priority of the task (lower number indicates higher priority, but sorting by priority is *not* required for this problem; simply store the value).
 *     *   Include a constructor, appropriate getter methods, and a `toString()` method that provides a clear representation of the task (e.g., "Task [ID=1, Name='Clean Room', Priority=5]").
 * 
 * 2.  **Task Manager Logic:** Create a class named `TaskManager` that manages the tasks. It must contain:
 *     *   A private field to store tasks waiting to be processed. This field **must** be declared as a `java.util.Queue`.
 *     *   A private field to store tasks that have been completed. This field **must** be declared as a `java.util.List`.
 *     *   A `java.util.Scanner` object for reading user input.
 *     *   A method to add a new task to the pending queue.
 *     *   A method to process the next task from the pending queue (dequeue it) and add it to the completed list. This method must handle the case where the pending queue is empty.
 *     *   A method to list all tasks currently in the pending queue.
 *     *   A method to list all tasks currently in the completed list.
 *     *   A main loop method (e.g., `run()`) that continuously prompts the user for commands, processes them using a `switch` statement, and continues until an "exit" command is given.
 * 
 * 3.  **User Interaction:** The `TaskManager`'s main loop (`run()` method) should support the following commands (case-insensitive, ignore leading/trailing whitespace):
 *     *   `add <Task Name>, <Priority>`: Adds a new task to the pending queue. `<Task Name>` can include spaces but is separated from `<Priority>` by a comma. `<Priority>` must be an integer.
 *     *   `process`: Takes the next task from the pending queue and moves it to the completed list.
 *     *   `list pending`: Displays all tasks in the pending queue.
 *     *   `list completed`: Displays all tasks in the completed list.
 *     *   `help`: Displays a list of available commands.
 *     *   `exit`: Terminates the application.
 * 
 * 4.  **Required Java Components:** Your solution **must** explicitly use and demonstrate the usage of:
 *     *   `java.util.Queue`
 *     *   `java.util.ArrayList` (as an implementation for the List)
 *     *   `java.util.List` (as the declared type for the completed tasks field)
 *     *   `java.util.Scanner`
 *     *   `switch` statement
 *     *   `System.err` (for error messages, e.g., invalid command, invalid input format, queue/list is empty when an operation is attempted)
 *     *   `System.out` (for normal output, e.g., confirmations, task details, help message)
 *     *   Class-wide exception handling with `try-catch` blocks within the main loop to handle potential issues like invalid input formats or unexpected errors during command processing.
 * 
 * 5.  **Best Practices:**
 *     *   Implement proper encapsulation (private fields, public methods).
 *     *   Use meaningful variable and method names.
 *     *   Include appropriate comments and documentation (e.g., JavaDocs for methods).
 *     *   Implement input validation (e.g., check for empty task name, non-integer priority, correct command format).
 *     *   Handle edge cases gracefully (e.g., attempting to process from an empty queue, listing empty lists).
 *     *   Ensure the `Scanner` is closed when the application exits.
 * 
 * **Expected Output:**
 * 
 * The output should be interactive based on user commands.
 * *   Successful commands should print confirmation or results to `System.out`.
 * *   Invalid commands, incorrect input formats, or operations on empty collections should print informative error messages to `System.err`.
 * *   Listing commands should print task details clearly.
 * *   The `help` command should list the available commands.
 * *   The `exit` command should print an exit message and terminate.
 * 
 * **Example Interaction Snippet:**
 * 
 * ```
 * Task Manager started. Type 'help' for commands.
 * > add Buy Milk, 3
 * Task added to pending queue: Buy Milk
 * > add Pay Bills, 1
 * Task added to pending queue: Pay Bills
 * > list pending
 * 
 * --- Pending Tasks ---
 * Task [ID=1, Name='Buy Milk', Priority=3]
 * Task [ID=2, Name='Pay Bills', Priority=1]
 * ---------------------
 * 
 * > process
 * Processed task: Buy Milk
 * > process
 * Processed task: Pay Bills
 * > process
 * No tasks in the pending queue to process.
 * > list completed
 * 
 * --- Completed Tasks ---
 * Task [ID=1, Name='Buy Milk', Priority=3]
 * Task [ID=2, Name='Pay Bills', Priority=1]
 * -----------------------
 * 
 * > add Read Book, abc
 * Invalid priority format. Please enter an integer.
 * > list unknown
 * Invalid 'list' command. Use: list pending or list completed
 * > exit
 * Exiting Task Manager. Goodbye!
 * ```
 * 
 * Implement the complete Java code for the `Task` and `TaskManager` classes in a single file.
 *
 * EXPLANATION:
 * This solution implements the `Simple Task Manager` application as requested, demonstrating the use of all specified Java components and adhering to best practices.
 * 
 * **Core Classes:**
 * 1.  **`Task` Class:** This class encapsulates the data for a single task: a unique `id`, a `name`, and a `priority`. It uses a static counter (`nextId`) to ensure each task gets a unique ID upon creation. Private fields and public getters enforce encapsulation. The `toString()` method provides a convenient way to print task details.
 * 2.  **`TaskManager` Class:** This is the central class managing the task workflow.
 *     *   It uses a `java.util.Queue<Task>` called `pendingTasks` to hold tasks waiting to be processed. The `LinkedList` class is used as a concrete implementation of the `Queue` interface, suitable for adding to the end and removing from the front.
 *     *   It uses a `java.util.List<Task>` called `completedTasks` to store tasks that have been processed. The `ArrayList` class is used as a concrete implementation of the `List` interface, providing dynamic array capabilities to store completed tasks.
 *     *   A `java.util.Scanner` reads user input from the console.
 * 
 * **Key Component Usage:**
 * *   **`Queue`:** The `pendingTasks` queue utilizes `offer()` to add tasks and `poll()` to remove and retrieve the next task to be processed. `isEmpty()` is used to check if there are tasks waiting.
 * *   **`List` & `ArrayList`:** The `completedTasks` list is declared using the `List` interface and instantiated as an `ArrayList`. It uses the `add()` method to store completed tasks and supports iteration (via `forEach` in this case) for listing. `isEmpty()` checks if the list is empty.
 * *   **`Scanner`:** An instance of `Scanner` is used in the `run()` method to read entire lines of user input (`scanner.nextLine()`). It is properly closed in a `finally` block to release system resources.
 * *   **`switch`:** The main command dispatch logic within the `run()` method is implemented using a `switch` statement, directing execution based on the first word of the user's input command (`command`).
 * *   **`System.err`:** Used specifically for printing error messages, such as invalid command formats, parsing errors (`NumberFormatException`), or attempting operations on empty collections. This distinguishes errors from normal application output.
 * *   **`System.out`:** Used for all standard output, including task confirmations, processed task notifications, list headers, task details when listing, help messages, and the exit message.
 * *   **`try-catch`:** A large `try-catch(Exception e)` block wraps the main `while` loop within the `run()` method. This provides a class-wide mechanism to catch any unexpected runtime exceptions that might occur during command processing, preventing the application from crashing abruptly. Additionally, a specific `try-catch(NumberFormatException e)` is used within the "add" command logic to handle errors when parsing the priority string into an integer, printing a user-friendly error message to `System.err`. The `finally` block ensures resources like the `Scanner` are cleaned up.
 * 
 * **Best Practices & Error Handling:**
 * *   **Encapsulation:** Both `Task` and `TaskManager` have private fields accessed and modified only through public methods.
 * *   **Meaningful Names:** Variables (`pendingTasks`, `completedTasks`, `commandLine`, `taskName`, `priority`), methods (`addTask`, `processNextTask`, `listPendingTasks`, `run`), and classes (`Task`, `TaskManager`) have descriptive names.
 * *   **Comments & Documentation:** JavaDocs are provided for classes and key methods, explaining their purpose, parameters, and behavior. Inline comments clarify specific logic points.
 * *   **Input Validation:** The code validates user input:
 *     *   Checks if the `add` command arguments match the expected `<Task Name>, <Priority>` format.
 *     *   Catches `NumberFormatException` if the priority is not a valid integer.
 *     *   Checks if the task name provided is empty.
 *     *   Validates arguments for the `list` command.
 *     *   Handles empty input lines.
 * *   **Error Handling:** Beyond the `try-catch` blocks, methods like `processNextTask`, `listPendingTasks`, and `listCompletedTasks` explicitly check if the collections are empty before attempting operations or listing, printing informative messages to `System.err` if they are.
 * *   **Clean Structure:** The logic is separated into distinct methods within the `TaskManager` class, making the code more organized and readable. The `main` method is kept simple, primarily responsible for creating the `TaskManager` instance and starting its `run` loop.
 * 
 * This solution effectively demonstrates the required Java concepts in a practical scenario, incorporating essential error handling and best practices suitable for evaluating advanced Java understanding.
 */

import java.util.Queue;
import java.util.LinkedList; // Common implementation for Queue
import java.util.List;
import java.util.ArrayList; // Common implementation for List
import java.util.Scanner;
import java.util.InputMismatchException;

/**
 * Represents a single task with an ID, name, and priority.
 */
class Task {
    private int id;
    private String name;
    private int priority;
    private static int nextId = 1; // Static counter for unique task IDs

    /**
     * Constructs a new Task.
     * @param name The name or description of the task.
     * @param priority The priority of the task (lower is higher).
     */
    public Task(String name, int priority) {
        this.id = nextId++; // Assign unique ID and increment counter
        this.name = name;
        this.priority = priority;
    }

    // --- Getters ---
    public int getId() {
        return id;
    }

    public String getName() {
        return name;
    }

    public int getPriority() {
        return priority;
    }

    /**
     * Provides a string representation of the Task.
     * @return A formatted string describing the task.
     */
    @Override
    public String toString() {
        return "Task [ID=" + id + ", Name='" + name + "', Priority=" + priority + "]";
    }
}

/**
 * Manages a collection of tasks, separating them into pending (Queue)
 * and completed (List). Handles user interaction via commands.
 */
public class TaskManager { // Made public for the main method
    private Queue<Task> pendingTasks;
    private List<Task> completedTasks;
    private Scanner scanner;

    /**
     * Constructs a TaskManager, initializing the task collections and scanner.
     */
    public TaskManager() {
        // Use LinkedList as an implementation of the Queue interface
        pendingTasks = new LinkedList<>();
        // Use ArrayList as an implementation of the List interface
        completedTasks = new ArrayList<>();
        scanner = new Scanner(System.in);
    }

    /**
     * Adds a new task to the pending queue.
     * @param task The task to add. Must not be null.
     */
    public void addTask(Task task) {
        if (task != null) {
            // offer() is generally preferred for queues as it handles capacity limits gracefully (though LinkedList is unbounded)
            pendingTasks.offer(task);
            System.out.println("Task added to pending queue: " + task.getName());
        } else {
            // Should not happen with current input validation, but good practice
            System.err.println("Error: Cannot add a null task.");
        }
    }

    /**
     * Processes the next task from the pending queue.
     * Removes the task from the queue and adds it to the completed list.
     * Prints an error if the queue is empty.
     */
    public void processNextTask() {
        // poll() retrieves and removes the head of the queue, returns null if queue is empty
        Task nextTask = pendingTasks.poll();
        if (nextTask != null) {
            completedTasks.add(nextTask);
            System.out.println("Processed task: " + nextTask.getName());
        } else {
            System.err.println("No tasks in the pending queue to process.");
        }
    }

    /**
     * Lists all tasks currently in the pending queue.
     * Iterates without removing elements.
     */
    public void listPendingTasks() {
        System.out.println("\n--- Pending Tasks ---");
        if (pendingTasks.isEmpty()) {
            System.out.println("No pending tasks.");
        } else {
            // Iterate through the queue using forEach (Java 8+) or an Iterator
            pendingTasks.forEach(System.out::println);
        }
        System.out.println("---------------------\n");
    }

    /**
     * Lists all tasks that have been completed.
     */
    public void listCompletedTasks() {
        System.out.println("\n--- Completed Tasks ---");
        if (completedTasks.isEmpty()) {
            System.out.println("No completed tasks.");
        } else {
            // Iterate through the list
            completedTasks.forEach(System.out::println);
        }
        System.out.println("-----------------------\n");
    }

    /**
     * Runs the main command loop for the Task Manager.
     * Prompts user for input, parses commands, and dispatches actions
     * using a switch statement. Includes robust error handling.
     */
    public void run() {
        System.out.println("Task Manager started. Type 'help' for commands.");
        boolean running = true;

        // Class-wide try-catch block wrapping the main command loop
        // Catches unexpected exceptions during command processing
        try {
            while (running) {
                System.out.print("> ");
                String commandLine = scanner.nextLine().trim(); // Read full line and trim whitespace

                if (commandLine.isEmpty()) {
                    continue; // Ignore empty input
                }

                // Split command from arguments (at most one split)
                String[] parts = commandLine.split("\\s+", 2);
                String command = parts[0].toLowerCase(); // Get command part and make lowercase
                String args = parts.length > 1 ? parts[1] : ""; // Get arguments part, if any

                // Use switch statement for command dispatch
                switch (command) {
                    case "add":
                        // Expected format: add <Task Name>, <Priority>
                        String[] taskArgs = args.split(",", 2); // Split arguments by comma
                        if (taskArgs.length == 2) {
                            String taskName = taskArgs[0].trim();
                            String priorityStr = taskArgs[1].trim();
                            try {
                                int priority = Integer.parseInt(priorityStr); // Attempt to parse priority

                                // Input validation for task details
                                if (taskName.isEmpty()) {
                                    System.err.println("Error: Task name cannot be empty.");
                                } else if (priority < 0) {
                                     System.err.println("Error: Priority cannot be negative.");
                                }
                                else {
                                    addTask(new Task(taskName, priority));
                                }
                            } catch (NumberFormatException e) {
                                // Specific catch for invalid priority format
                                System.err.println("Invalid priority format. Please enter an integer.");
                            }
                        } else {
                            System.err.println("Invalid 'add' command format. Use: add <Task Name>, <Priority>");
                        }
                        break; // End of 'add' case

                    case "process":
                        processNextTask();
                        break; // End of 'process' case

                    case "list":
                        if (args.equalsIgnoreCase("pending")) {
                            listPendingTasks();
                        } else if (args.equalsIgnoreCase("completed")) {
                            listCompletedTasks();
                        } else {
                            System.err.println("Invalid 'list' command. Use: list pending or list completed");
                        }
                        break; // End of 'list' case

                    case "help":
                        System.out.println("\nAvailable commands:");
                        System.out.println("  add <Task Name>, <Priority> - Adds a new task (e.g., add Clean Room, 5)");
                        System.out.println("  process                     - Processes the next task in the queue");
                        System.out.println("  list pending                - Lists tasks waiting in the queue");
                        System.out.println("  list completed              - Lists tasks that have been processed");
                        System.out.println("  exit                        - Exits the application");
                        System.out.println();
                        break; // End of 'help' case

                    case "exit":
                        System.out.println("Exiting Task Manager. Goodbye!");
                        running = false; // Set flag to exit loop
                        break; // End of 'exit' case

                    default:
                        // Handle unknown commands
                        System.err.println("Unknown command: '" + command + "'. Type 'help' for available commands.");
                        break; // End of default case
                }
            }
        } catch (Exception e) {
            // Generic catch for any other unexpected runtime exceptions
            System.err.println("An unexpected application error occurred: " + e.getMessage());
            // e.printStackTrace(); // Uncomment for detailed debugging
        } finally {
            // Ensure the scanner is closed when the loop finishes or an exception occurs
            if (scanner != null) {
                scanner.close();
            }
        }
    }

    /**
     * The main method to start the Task Manager application.
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        TaskManager manager = new TaskManager();
        manager.run();
    }
}
