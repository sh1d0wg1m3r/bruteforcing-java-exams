/*
 * Exam Question #1080
 * Generated on: 2025-05-12 17:22:09
 * Generated by: Account 4
 * 
 * QUESTION:
 * **Advanced Java Programming Exam Task: Hospital Appointment Management System**
 * 
 * **Problem Description:**
 * 
 * You are tasked with developing a simplified system for a hospital to manage patient appointments. The system should allow hospital staff to register new patients, schedule appointments for registered patients, process appointments from a waiting queue, and view lists of patients and the appointment queue.
 * 
 * Your solution must adhere to the following requirements and demonstrate advanced Java programming concepts:
 * 
 * 1.  **Patient Representation:** Create a `Patient` class with private fields for `patientId` (String), `name` (String), and `age` (int). Provide a constructor and public getter methods for these fields.
 * 2.  **System Core:** Create a main class (e.g., `AppointmentScheduler`) that manages two collections:
 *     *   A `List` (specifically using `ArrayList`) to store all registered patients.
 *     *   A `Queue` (from `java.util.Queue`) to store patients who are currently scheduled and waiting for their appointment.
 * 3.  **Functionality:** Implement the following operations via a command-line menu interface:
 *     *   **Add New Patient:** Prompt for patient details (ID, Name, Age). Add the new patient to the list of all registered patients. Ensure the Patient ID is unique (a simple check against existing IDs in the `ArrayList` is sufficient for this task). Validate age (must be positive).
 *     *   **Schedule Appointment:** Prompt for a patient ID. Find the patient in the list of all registered patients. If found and *not already* in the appointment queue, add them to the appointment queue. If not found or already in the queue, display an appropriate error message.
 *     *   **Process Next Appointment:** Remove and display the patient at the front of the appointment queue. If the queue is empty, display an error message.
 *     *   **View All Registered Patients:** Display details of all patients in the registered patients list.
 *     *   **View Appointment Queue:** Display details of all patients currently in the appointment queue.
 *     *   **Exit:** Terminate the program.
 * 4.  **User Input:** Use `java.util.Scanner` to read user input for menu choices and patient details.
 * 5.  **Flow Control:** Use a `switch` statement to handle the main menu options.
 * 6.  **Output:**
 *     *   Use `System.out` for all normal output (menu, successful operations, lists).
 *     *   Use `System.err` for displaying error messages (e.g., patient not found, invalid input, queue empty, duplicate ID).
 * 7.  **Exception Handling:**
 *     *   Implement `try-catch` blocks for specific anticipated errors (e.g., `InputMismatchException` when reading integers, handling cases where a patient is not found).
 *     *   Implement a class-wide `try-catch` block (wrapping the main application loop or core execution) to catch any unexpected runtime exceptions and provide a generic error message before exiting.
 * 8.  **Best Practices:**
 *     *   Use meaningful variable and method names.
 *     *   Include comments and basic documentation (e.g., Javadoc for classes/methods).
 *     *   Ensure proper encapsulation in the `Patient` class.
 *     *   Validate user input where appropriate (e.g., age, menu choice).
 *     *   Handle the `Scanner` resource properly (e.g., using try-with-resources or closing it).
 * 
 * **Expected Output:**
 * 
 * The program should present a menu to the user. Based on the user's choice, it should perform the corresponding action, providing feedback via `System.out` or `System.err`.
 * 
 * Example Interaction Snippet:
 * 
 * ```
 * --- Hospital Appointment System Menu ---
 * 1. Add New Patient
 * 2. Schedule Appointment
 * 3. Process Next Appointment
 * 4. View All Registered Patients
 * 5. View Appointment Queue
 * 6. Exit
 * Enter your choice: 1
 * Enter Patient ID: P101
 * Enter Patient Name: Alice
 * Enter Patient Age: 30
 * Patient P101 (Alice) registered successfully.
 * 
 * --- Hospital Appointment System Menu ---
 * ...
 * Enter your choice: 2
 * Enter Patient ID to schedule: P101
 * Patient P101 scheduled for appointment.
 * 
 * --- Hospital Appointment System Menu ---
 * ...
 * Enter your choice: 2
 * Enter Patient ID to schedule: P999
 * Error: Patient with ID P999 not found.
 * 
 * --- Hospital Appointment System Menu ---
 * ...
 * Enter your choice: 3
 * Processing appointment for Patient P101 (Alice)...
 * 
 * --- Hospital Appointment System Menu ---
 * ...
 * Enter your choice: 3
 * Error: Appointment queue is empty.
 * 
 * --- Hospital Appointment System Menu ---
 * ...
 * Enter your choice: 4
 * --- All Registered Patients ---
 * ID: P101, Name: Alice, Age: 30
 * ID: P102, Name: Bob, Age: 45
 * 
 * --- Hospital Appointment System Menu ---
 * ...
 * Enter your choice: 5
 * --- Appointment Queue ---
 * ID: P102, Name: Bob, Age: 45
 * 
 * --- Hospital Appointment System Menu ---
 * ...
 * Enter your choice: 6
 * Exiting system.
 * ```
 * 
 * Your solution should be a single `.java` file containing all necessary classes.
 *
 * EXPLANATION:
 * The solution provides a `Hospital Appointment System` simulation using the requested Java components.
 * 
 * **Key Concepts Demonstrated:**
 * 
 * 1.  **Object-Oriented Programming:** The `Patient` class encapsulates patient data (ID, name, age) using private fields and public getters, demonstrating encapsulation.
 * 2.  **Collections Framework:**
 *     *   `java.util.List` and `java.util.ArrayList`: An `ArrayList` is used to maintain a dynamic list of all registered `Patient` objects. This demonstrates the use of the `List` interface and its common `ArrayList` implementation for storing and iterating over a collection of objects.
 *     *   `java.util.Queue`: A `Queue` (implemented using `java.util.LinkedList`) is used to manage patients waiting for their appointment in a First-In, First-Out (FIFO) manner. This demonstrates the `Queue` interface methods like `offer()` (add) and `poll()` (retrieve and remove).
 * 3.  **User Input:** `java.util.Scanner` is used to read various types of input from the console, including integers for menu choices and strings for patient details.
 * 4.  **Control Flow:** A `switch` statement in the main loop efficiently handles the different menu options selected by the user. A `while` loop keeps the application running until the user chooses to exit.
 * 5.  **Error Handling:**
 *     *   `System.err`: Used consistently to output error messages to the standard error stream, distinguishing them from normal output.
 *     *   Specific `try-catch`: `InputMismatchException` is caught when reading integer input (age and menu choice) to handle non-numeric input gracefully and prevent program crashes. Checks are also performed for empty strings or invalid age values.
 *     *   Class-wide `try-catch`: The main `while` loop in the `main` method is wrapped in a `try-catch (Exception e)` block. This serves as a catch-all for any unexpected runtime exceptions that might occur during program execution, printing an error message and the stack trace for debugging, fulfilling the "class-wide" requirement by covering the main operational part of the class.
 * 6.  **Best Practices:**
 *     *   Meaningful names (`allRegisteredPatients`, `appointmentQueue`, `scheduleAppointment`, etc.) improve code readability.
 *     *   Basic Javadoc comments are included for classes and methods.
 *     *   Input validation checks are performed (e.g., age > 0, non-empty strings, unique ID).
 *     *   The `Scanner` resource is managed using a `try-with-resources` block in `main`, ensuring it is automatically closed when the program exits or an exception occurs.
 *     *   The `Patient` class overrides `equals()` and `hashCode()` based on `patientId` to ensure correct behavior when checking for duplicates or using methods like `appointmentQueue.contains()`.
 *     *   Proper consumption of the newline character after reading integers with `scanner.nextInt()` (`scanner.nextLine()`) is handled to prevent issues with subsequent `scanner.nextLine()` calls.
 * 
 * The solution effectively combines these elements to create a functional, robust, and well-structured application that meets all the requirements of the complex exam task.
 */

import java.util.ArrayList;
import java.util.LinkedList; // LinkedList implements Queue
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.InputMismatchException;

/**
 * Represents a patient in the hospital system.
 */
class Patient {
    private String patientId;
    private String name;
    private int age;

    /**
     * Constructs a new Patient object.
     *
     * @param patientId The unique ID of the patient.
     * @param name      The name of the patient.
     * @param age       The age of the patient.
     */
    public Patient(String patientId, String name, int age) {
        this.patientId = patientId;
        this.name = name;
        this.age = age;
    }

    // Public getter methods
    public String getPatientId() {
        return patientId;
    }

    public String getName() {
        return name;
    }

    public int getAge() {
        return age;
    }

    @Override
    public String toString() {
        return "ID: " + patientId + ", Name: " + name + ", Age: " + age;
    }

    // Simple equality check based on ID for searching
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Patient patient = (Patient) o;
        return patientId.equals(patient.patientId);
    }

    @Override
    public int hashCode() {
        return patientId.hashCode();
    }
}

/**
 * Manages patient registration and appointment scheduling.
 */
public class AppointmentScheduler {

    // Using List interface, implemented by ArrayList
    private List<Patient> allRegisteredPatients;
    // Using Queue interface, implemented by LinkedList
    private Queue<Patient> appointmentQueue;
    private Scanner scanner;

    /**
     * Constructs an AppointmentScheduler, initializing collections and scanner.
     */
    public AppointmentScheduler() {
        allRegisteredPatients = new ArrayList<>();
        appointmentQueue = new LinkedList<>(); // LinkedList is commonly used as a Queue implementation
        // Scanner will be initialized in main using try-with-resources
    }

    /**
     * Displays the main menu options to the user.
     */
    private void displayMenu() {
        System.out.println("\n--- Hospital Appointment System Menu ---");
        System.out.println("1. Add New Patient");
        System.out.println("2. Schedule Appointment");
        System.out.println("3. Process Next Appointment");
        System.out.println("4. View All Registered Patients");
        System.out.println("5. View Appointment Queue");
        System.out.println("6. Exit");
        System.out.print("Enter your choice: ");
    }

    /**
     * Adds a new patient to the system.
     * Validates input and checks for duplicate IDs.
     */
    private void addPatient() {
        System.out.print("Enter Patient ID: ");
        String id = scanner.nextLine().trim();
        if (id.isEmpty()) {
            System.err.println("Error: Patient ID cannot be empty.");
            return;
        }

        // Check for duplicate ID
        for (Patient p : allRegisteredPatients) {
            if (p.getPatientId().equals(id)) {
                System.err.println("Error: Patient with ID " + id + " already exists.");
                return;
            }
        }

        System.out.print("Enter Patient Name: ");
        String name = scanner.nextLine().trim();
        if (name.isEmpty()) {
            System.err.println("Error: Patient name cannot be empty.");
            return;
        }

        int age = -1;
        System.out.print("Enter Patient Age: ");
        try {
            age = scanner.nextInt();
            if (age <= 0) {
                System.err.println("Error: Patient age must be a positive number.");
                scanner.nextLine(); // Consume the invalid input line
                return;
            }
        } catch (InputMismatchException e) {
            System.err.println("Error: Invalid age input. Please enter a number.");
            scanner.nextLine(); // Consume the invalid input line
            return;
        } finally {
             // Consume the rest of the line after reading int, necessary if nextLine() follows
             // Only consume if nextInt() was successful, or if exception occurred.
             // If age was successfully read, a newline character is left.
             // If exception occurred, the invalid token is still there, nextLine() will consume it.
             // Let's consume it here to be safe before the method ends.
             // However, nextLine() after nextInt() inside the *same* method call is tricky.
             // A common pattern is to consume the newline immediately after nextInt().
             // Let's add scanner.nextLine() after the successful nextInt().
        }
        // Consume the leftover newline character after reading age (int)
        scanner.nextLine();


        Patient newPatient = new Patient(id, name, age);
        allRegisteredPatients.add(newPatient);
        System.out.println("Patient " + id + " (" + name + ") registered successfully.");
    }

    /**
     * Schedules an appointment for a registered patient by adding them to the queue.
     * Validates patient existence and checks if already in queue.
     */
    private void scheduleAppointment() {
        System.out.print("Enter Patient ID to schedule: ");
        String id = scanner.nextLine().trim();
        if (id.isEmpty()) {
            System.err.println("Error: Patient ID cannot be empty.");
            return;
        }

        Patient patientToSchedule = null;
        // Find patient in the registered list
        for (Patient p : allRegisteredPatients) {
            if (p.getPatientId().equals(id)) {
                patientToSchedule = p;
                break;
            }
        }

        if (patientToSchedule == null) {
            System.err.println("Error: Patient with ID " + id + " not found in registered patients.");
            return;
        }

        // Check if patient is already in the appointment queue
        if (appointmentQueue.contains(patientToSchedule)) {
             System.err.println("Error: Patient with ID " + id + " is already in the appointment queue.");
             return;
        }

        // Add patient to the queue
        appointmentQueue.offer(patientToSchedule); // offer() is preferred over add() for capacity-constrained queues, though LinkedList is not. It's good practice.
        System.out.println("Patient " + id + " scheduled for appointment.");
    }

    /**
     * Processes the next patient in the appointment queue.
     * Handles empty queue case.
     */
    private void processNextAppointment() {
        Patient nextPatient = appointmentQueue.poll(); // poll() retrieves and removes, returns null if empty

        if (nextPatient == null) {
            System.err.println("Error: Appointment queue is empty.");
        } else {
            System.out.println("Processing appointment for " + nextPatient + "...");
            // In a real system, more complex logic would follow here (e.g., assign doctor, update status)
        }
    }

    /**
     * Displays all patients currently registered in the system.
     */
    private void viewAllRegisteredPatients() {
        System.out.println("--- All Registered Patients ---");
        if (allRegisteredPatients.isEmpty()) {
            System.out.println("No patients registered yet.");
        } else {
            for (Patient p : allRegisteredPatients) {
                System.out.println(p);
            }
        }
    }

    /**
     * Displays all patients currently waiting in the appointment queue.
     */
    private void viewAppointmentQueue() {
        System.out.println("--- Appointment Queue ---");
        if (appointmentQueue.isEmpty()) {
            System.out.println("Appointment queue is empty.");
        } else {
            // Iterate without removing elements
            for (Patient p : appointmentQueue) {
                System.out.println(p);
            }
            // Alternatively, using toArray() or stream().forEach()
        }
    }

    /**
     * Main method to run the appointment scheduler application.
     * Includes class-wide exception handling.
     *
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        // Use try-with-resources to ensure the Scanner is closed
        try (Scanner consoleScanner = new Scanner(System.in)) {
            AppointmentScheduler scheduler = new AppointmentScheduler();
            scheduler.scanner = consoleScanner; // Assign the scanner instance

            boolean running = true;
            while (running) {
                try { // Specific try-catch for potential input issues within the loop
                    scheduler.displayMenu();
                    int choice = consoleScanner.nextInt();
                    consoleScanner.nextLine(); // Consume newline left-over

                    switch (choice) {
                        case 1:
                            scheduler.addPatient();
                            break;
                        case 2:
                            scheduler.scheduleAppointment();
                            break;
                        case 3:
                            scheduler.processNextAppointment();
                            break;
                        case 4:
                            scheduler.viewAllRegisteredPatients();
                            break;
                        case 5:
                            scheduler.viewAppointmentQueue();
                            break;
                        case 6:
                            running = false;
                            System.out.println("Exiting system.");
                            break;
                        default:
                            System.err.println("Error: Invalid choice. Please enter a number between 1 and 6.");
                    }
                } catch (InputMismatchException e) {
                    System.err.println("Error: Invalid input. Please enter a number for your choice.");
                    consoleScanner.nextLine(); // Consume the invalid input to prevent infinite loop
                } catch (Exception e) {
                    // Class-wide catch for any unexpected runtime errors
                    System.err.println("An unexpected error occurred: " + e.getMessage());
                    e.printStackTrace(); // Print stack trace for debugging
                    running = false; // Optionally exit on unexpected error
                }
            }
        } catch (Exception e) {
             // Catch potential exceptions during Scanner initialization or closing (less common)
             System.err.println("An error occurred during system startup or shutdown: " + e.getMessage());
             e.printStackTrace();
        }
    }
}
