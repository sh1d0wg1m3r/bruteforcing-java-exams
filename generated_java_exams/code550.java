/*
 * Exam Question #550
 * Generated on: 2025-05-11 23:28:04
 * Generated by: Account 1
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Print Job Management System
 * 
 * **Objective:** Design and implement a console-based Print Job Management System that simulates adding, processing, and viewing print jobs using core Java collections and control structures, incorporating robust error handling and best practices.
 * 
 * **Scenario:** You are building a simplified system to manage print jobs sent to a shared printer. Jobs are added to a queue, processed one by one, and then moved to a history log.
 * 
 * **Requirements:**
 * 
 * 1.  **Data Model:**
 *     *   Create an `enum` called `PrintJobStatus` with values `PENDING` and `PROCESSED`.
 *     *   Create a class `PrintJob` with the following private fields: `jobId` (int, auto-generated starting from 1), `description` (String), `pages` (int), and `status` (`PrintJobStatus`). Include a constructor, appropriate getters, and a setter for `status`. Override the `toString()` method for easy display.
 * 
 * 2.  **Manager Class:**
 *     *   Create a class `PrintQueueManager`.
 *     *   It must contain a private field `printQueue` declared as `java.util.Queue<PrintJob>`. Use a suitable concrete implementation (e.g., `LinkedList`).
 *     *   It must contain a private field `printHistory` declared as `java.util.List<PrintJob>`. Use `java.util.ArrayList` as the concrete implementation.
 *     *   Implement the following public methods:
 *         *   `addJob(PrintJob job)`: Adds a `PrintJob` to the `printQueue`. Print a confirmation message.
 *         *   `processNextJob()`: Removes the next job from the head of the `printQueue`. If a job is retrieved, update its status to `PROCESSED` and add it to the `printHistory` list. Print a message indicating which job was processed. If the queue is empty, throw a custom exception.
 *         *   `viewPendingJobs()`: Prints all jobs currently in the `printQueue` to `System.out`, indicating their position or just listing them.
 *         *   `viewProcessedJobs()`: Prints all jobs in the `printHistory` list to `System.out`.
 * 
 * 3.  **User Interface and Main Application:**
 *     *   Create a class `PrintSystem` with a `main` method.
 *     *   Use `java.util.Scanner` to get user input from the console.
 *     *   Implement a menu-driven interface with the following options:
 *         1.  Add New Print Job
 *         2.  Process Next Job
 *         3.  View Pending Queue
 *         4.  View Processed History
 *         5.  Exit
 *     *   Use a `switch` statement to handle the user's menu selection.
 *     *   **Input Validation:** For adding a job, ensure the number of pages is a positive integer. If not, print an error message using `System.err` and do not add the job. Handle `InputMismatchException` if the user enters non-numeric input when a number is expected.
 *     *   **Error Handling:**
 *         *   Create a custom exception class, e.g., `EmptyQueueException`, extending `Exception`.
 *         *   The `processNextJob()` method should throw `EmptyQueueException` if the queue is empty.
 *         *   In the `main` method's operational loop (where the menu is processed), implement class-wide exception handling using a `try-catch` block to catch `InputMismatchException`, `EmptyQueueException`, and potentially other unexpected exceptions. Print error messages for caught exceptions using `System.err`.
 *     *   Use `System.out` for the menu, prompts, and successful operation messages.
 *     *   Use `System.err` for all error messages.
 *     *   The program should loop, displaying the menu and processing input, until the user chooses the Exit option.
 * 
 * **Constraints:**
 * 
 * *   You must use `java.util.Queue`, `java.util.ArrayList`, `java.util.List`, `java.util.Scanner`, `switch`, `System.err`, `System.out`, and class-wide `try-catch` blocks as specified.
 * *   Adhere to Java coding standards: proper encapsulation (private fields, public methods), meaningful names, and basic comments/documentation.
 * 
 * **Expected Output:** The program should run interactively, allowing users to perform the specified operations. It should provide clear feedback for successful operations and informative error messages for failures or invalid input, directing errors to `System.err`.
 * 
 * **Example Interaction Flow (Illustrative):**
 * 
 * ```
 * --- Print Job Management System ---
 * Select an option:
 * 1. Add New Print Job
 * 2. Process Next Job
 * 3. View Pending Queue
 * 4. View Processed History
 * 5. Exit
 * Enter your choice: 1
 * Enter job description: Report
 * Enter number of pages: 15
 * Job added to queue: Report
 * 
 * Select an option:
 * ...menu...
 * Enter your choice: 1
 * Enter job description: Presentation
 * Enter number of pages: 20
 * Job added to queue: Presentation
 * 
 * Select an option:
 * ...menu...
 * Enter your choice: 3
 * 
 * --- Pending Print Queue ---
 * 1. Job ID: 1, Description: Report, Pages: 15, Status: PENDING
 * 2. Job ID: 2, Description: Presentation, Pages: 20, Status: PENDING
 * ---------------------------
 * 
 * 
 * Select an option:
 * ...menu...
 * Enter your choice: 2
 * Processed job: Report
 * 
 * Select an option:
 * ...menu...
 * Enter your choice: 3
 * 
 * --- Pending Print Queue ---
 * 1. Job ID: 2, Description: Presentation, Pages: 20, Status: PENDING
 * ---------------------------
 * 
 * Select an option:
 * ...menu...
 * Enter your choice: 4
 * 
 * --- Processed Print History ---
 * 1. Job ID: 1, Description: Report, Pages: 15, Status: PROCESSED
 * -------------------------------
 * 
 * Select an option:
 * ...menu...
 * Enter your choice: 2
 * Processed job: Presentation
 * 
 * Select an option:
 * ...menu...
 * Enter your choice: 2
 * Processing Error: Print queue is empty. No jobs to process.
 * 
 * Select an option:
 * ...menu...
 * Enter your choice: 6
 * Invalid choice. Please enter a number between 1 and 5.
 * 
 * Select an option:
 * ...menu...
 * Enter your choice: abc
 * Invalid input. Please enter a number.
 * 
 * Select an option:
 * ...menu...
 * Enter your choice: 5
 * Exiting Print Job Management System. Goodbye!
 * Scanner closed.
 * ```
 * 
 * This task requires integrating multiple concepts: object-oriented design, data structures (`Queue`, `List`, `ArrayList`), user interaction (`Scanner`, `switch`), and robust error handling (`try-catch`, custom exceptions, `System.err`).
 *
 * EXPLANATION:
 * This solution implements the Print Job Management System as requested, demonstrating the required Java concepts and best practices.
 * 
 * 1.  **`PrintJobStatus` Enum:** Defines the two possible states for a print job, providing type safety and readability compared to using raw strings or integers.
 * 2.  **`PrintJob` Class:** Encapsulates the data for a single print job.
 *     *   Private fields ensure data integrity.
 *     *   An auto-incrementing `jobId` using a static variable provides unique identifiers.
 *     *   Getters provide controlled access to the data.
 *     *   A specific setter `setStatus` allows the manager class to update the job's state.
 *     *   `toString()` provides a convenient way to display job details.
 * 3.  **`PrintQueueManager` Class:** Manages the collection of print jobs.
 *     *   `printQueue`: Declared as `Queue<PrintJob>` and instantiated with `LinkedList`. `Queue` is used because the core operation is adding to the end (`offer`) and removing from the front (`poll`), which are fundamental queue operations. `LinkedList` is a common and efficient implementation for queue operations.
 *     *   `printHistory`: Declared as `List<PrintJob>` and instantiated with `ArrayList`. `List` is used because we need to store a collection of processed jobs in order and potentially iterate through them or access them by index (though simple iteration is used here). `ArrayList` is a suitable general-purpose list implementation.
 *     *   Methods like `addJob`, `processNextJob`, `viewPendingJobs`, and `viewProcessedJobs` encapsulate the logic for managing the collections, adhering to the principle of separating concerns.
 *     *   `processNextJob` uses `printQueue.poll()` to retrieve and remove the head. It throws the custom `EmptyQueueException` if `poll()` returns `null`, indicating an empty queue.
 *     *   `viewPendingJobs` iterates over the `Queue` using an enhanced for loop, which is possible because `LinkedList` (and most collections) are `Iterable`.
 *     *   `viewProcessedJobs` iterates over the `List` using an indexed for loop.
 * 4.  **`EmptyQueueException` Class:** A simple custom exception is created to specifically signal the error condition of trying to process a job when the queue is empty. This makes the error handling in the calling code (`PrintSystem`) more specific and clearer than catching a generic `RuntimeException`.
 * 5.  **`PrintSystem` Class (`main` method):**
 *     *   Handles user interaction using `Scanner`.
 *     *   Presents a menu and uses a `switch` statement to direct control flow based on user choice.
 *     *   **Input Validation:**
 *         *   The `switch` statement's `default` case handles invalid menu numbers.
 *         *   A `while` loop with an inner `try-catch` is used when reading the number of pages to ensure the input is a positive integer.
 *         *   A `try-catch(InputMismatchException)` block is placed around the `scanner.nextInt()` calls (both for menu choice and pages) to gracefully handle cases where the user enters non-integer input, preventing the program from crashing and allowing the loop to continue after prompting the user to correct the input.
 *     *   **Error Handling:**
 *         *   The `processNextJob()` call is wrapped in a `try-catch(EmptyQueueException e)` block to specifically handle the case where the queue is empty, printing a user-friendly error message to `System.err`.
 *         *   A broader `catch (Exception e)` block inside the main `while` loop catches any other unexpected runtime errors that might occur during the processing of a menu option, printing a general error message to `System.err`.
 *         *   The entire `while(running)` loop is wrapped in an outer `try-catch(Exception mainLoopException)`. This serves as the "class-wide" or main application exception handler, catching any exceptions that might propagate out of the inner handling logic (though less likely with the current structure, it fulfills the requirement for a top-level handler).
 *     *   **Output:** `System.out` is used for the menu, prompts, and standard output like job confirmations and list displays. `System.err` is strictly used for error messages, as requested.
 *     *   The `finally` block ensures the `Scanner` resource is closed when the program exits, regardless of whether an exception occurred or the loop finished normally.
 * 
 * This structure effectively combines the required Java components to solve a practical problem, emphasizing object-oriented design, data structure usage, input handling, and comprehensive error management.
 */

import java.util.Queue;
import java.util.LinkedList;
import java.util.List;
import java.util.ArrayList;
import java.util.Scanner;
import java.util.InputMismatchException;

// Enum for job status
enum PrintJobStatus {
    PENDING,
    PROCESSED
}

// Custom Exception for Empty Queue
class EmptyQueueException extends Exception {
    public EmptyQueueException(String message) {
        super(message);
    }
}

/**
 * Represents a single print job with ID, description, pages, and status.
 */
class PrintJob {
    private static int nextJobId = 1; // Auto-incrementing ID
    private int jobId;
    private String description;
    private int pages;
    private PrintJobStatus status;

    /**
     * Constructs a new PrintJob.
     * @param description The description of the job.
     * @param pages The number of pages in the job.
     */
    public PrintJob(String description, int pages) {
        this.jobId = nextJobId++;
        this.description = description;
        this.pages = pages;
        this.status = PrintJobStatus.PENDING;
    }

    // --- Getters ---
    public int getJobId() {
        return jobId;
    }

    public String getDescription() {
        return description;
    }

    public int getPages() {
        return pages;
    }

    public PrintJobStatus getStatus() {
        return status;
    }

    // --- Setter for status (used by manager) ---
    /**
     * Sets the status of the print job.
     * @param status The new status.
     */
    public void setStatus(PrintJobStatus status) {
        this.status = status;
    }

    /**
     * Provides a string representation of the PrintJob.
     * @return A formatted string describing the job.
     */
    @Override
    public String toString() {
        return "Job ID: " + jobId + ", Description: " + description + ", Pages: " + pages + ", Status: " + status;
    }
}

/**
 * Manages the print queue and history of processed jobs.
 */
class PrintQueueManager {
    private Queue<PrintJob> printQueue;
    private List<PrintJob> printHistory;

    /**
     * Constructs a PrintQueueManager with empty queue and history.
     */
    public PrintQueueManager() {
        // LinkedList is a common implementation of the Queue interface
        this.printQueue = new LinkedList<>();
        // ArrayList is a common implementation of the List interface
        this.printHistory = new ArrayList<>();
    }

    /**
     * Adds a new print job to the pending queue.
     * @param job The PrintJob to add. Must not be null.
     */
    public void addJob(PrintJob job) {
        if (job != null) {
            // offer is generally preferred over add for queues as it handles capacity constraints
            printQueue.offer(job);
            System.out.println("Job added to queue: '" + job.getDescription() + "' (ID: " + job.getJobId() + ")");
        } else {
             System.err.println("Error: Cannot add a null job.");
        }
    }

    /**
     * Processes the next job in the queue.
     * Removes it from the queue, updates its status, and adds it to history.
     * @throws EmptyQueueException if the print queue is empty.
     * @return The processed PrintJob.
     */
    public PrintJob processNextJob() throws EmptyQueueException {
        // poll retrieves and removes the head of the queue, returns null if empty
        PrintJob jobToProcess = printQueue.poll();
        if (jobToProcess == null) {
            // Throw custom exception if queue was empty
            throw new EmptyQueueException("Print queue is empty. No jobs to process.");
        }
        jobToProcess.setStatus(PrintJobStatus.PROCESSED);
        printHistory.add(jobToProcess);
        System.out.println("Processed job: '" + jobToProcess.getDescription() + "' (ID: " + jobToProcess.getJobId() + ")");
        return jobToProcess;
    }

    /**
     * Displays all jobs currently in the pending queue to System.out.
     */
    public void viewPendingJobs() {
        System.out.println("\n--- Pending Print Queue ---");
        if (printQueue.isEmpty()) {
            System.out.println("Queue is empty.");
        } else {
            // Iterate over the queue without removing elements
            int index = 1;
            for (PrintJob job : printQueue) {
                System.out.println(index++ + ". " + job);
            }
        }
        System.out.println("---------------------------\n");
    }

    /**
     * Displays all jobs in the processed history list to System.out.
     */
    public void viewProcessedJobs() {
        System.out.println("\n--- Processed Print History ---");
        if (printHistory.isEmpty()) {
            System.out.println("History is empty.");
        } else {
            // Iterate using index or enhanced for loop
            for (int i = 0; i < printHistory.size(); i++) {
                 System.out.println((i + 1) + ". " + printHistory.get(i));
            }
        }
        System.out.println("-------------------------------\n");
    }
}

/**
 * Main class for the Print Job Management System console application.
 * Handles user interaction and exception management.
 */
public class PrintSystem {

    private static void printMenu() {
        System.out.println("Select an option:");
        System.out.println("1. Add New Print Job");
        System.out.println("2. Process Next Job");
        System.out.println("3. View Pending Queue");
        System.out.println("4. View Processed History");
        System.out.println("5. Exit");
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        PrintQueueManager manager = new PrintQueueManager();
        boolean running = true;

        System.out.println("--- Print Job Management System ---");

        // Class-wide exception handling for the main application loop
        try {
            while (running) {
                printMenu();

                int choice = -1;
                try {
                    System.out.print("Enter your choice: ");
                    // Read integer choice
                    choice = scanner.nextInt();
                    // Consume the rest of the line (newline character)
                    scanner.nextLine();

                    // Use switch for menu selection
                    switch (choice) {
                        case 1: // Add Job
                            System.out.print("Enter job description: ");
                            String description = scanner.nextLine();

                            int pages = 0;
                            boolean validPages = false;
                            while (!validPages) {
                                try {
                                    System.out.print("Enter number of pages: ");
                                    pages = scanner.nextInt();
                                    scanner.nextLine(); // Consume newline

                                    if (pages <= 0) {
                                        System.err.println("Error: Number of pages must be positive.");
                                    } else {
                                        validPages = true; // Input is valid
                                    }
                                } catch (InputMismatchException e) {
                                    System.err.println("Invalid input. Please enter a valid number for pages.");
                                    scanner.nextLine(); // Consume the invalid input
                                }
                            }

                            // If we reached here, pages is valid
                            PrintJob newJob = new PrintJob(description, pages);
                            manager.addJob(newJob);
                            break;

                        case 2: // Process Next Job
                            try {
                                manager.processNextJob();
                            } catch (EmptyQueueException e) {
                                // Catch the specific custom exception for empty queue
                                System.err.println("Processing Error: " + e.getMessage());
                            }
                            break;

                        case 3: // View Pending Queue
                            manager.viewPendingJobs();
                            break;

                        case 4: // View Processed History
                            manager.viewProcessedJobs();
                            break;

                        case 5: // Exit
                            running = false;
                            System.out.println("Exiting Print Job Management System. Goodbye!");
                            break;

                        default:
                            // Handle choices outside the 1-5 range
                            System.err.println("Invalid choice. Please enter a number between 1 and 5.");
                            break;
                    }
                } catch (InputMismatchException e) {
                    // Handle cases where the initial menu choice is not an integer
                    System.err.println("Invalid input. Please enter a number for your choice.");
                    scanner.nextLine(); // Consume the invalid input to prevent infinite loop
                } catch (Exception e) {
                    // Catch any other unexpected runtime exceptions during the operation handling
                    System.err.println("An unexpected error occurred: " + e.getMessage());
                    // e.printStackTrace(); // Uncomment for debugging detailed stack trace
                }
                 System.out.println(); // Add a blank line for readability between operations
            }
        } catch (Exception mainLoopException) {
            // This outer catch block serves as the final safety net for the main loop
            // It catches any exceptions that were not specifically handled inside the loop.
            System.err.println("A critical error occurred in the main application loop: " + mainLoopException.getMessage());
            mainLoopException.printStackTrace(); // Print stack trace for critical errors
        } finally {
            // Ensure the scanner resource is closed when the application exits
            scanner.close();
            System.out.println("Scanner closed.");
        }
    }
}
