/*
 * Exam Question #269
 * Generated on: 2025-05-11 22:47:27
 * Generated by: Account 4
 * 
 * QUESTION:
 * **Java Programming Exam Task: Simulated Print Job Management System**
 * 
 * You are tasked with building a simplified simulation of a print job management system. The system should allow users to add print jobs, process the next job in the queue, view the current queue of pending jobs, and view a history of completed jobs.
 * 
 * Your solution must adhere to the following requirements:
 * 
 * 1.  **Data Structures:**
 *     *   Maintain a waiting list of print jobs using a `java.util.Queue`. Jobs should be processed in the order they were added (FIFO).
 *     *   Maintain a history of completed print jobs using a `java.util.List`, specifically implemented with `java.util.ArrayList`.
 * 
 * 2.  **User Interface:**
 *     *   Use `java.util.Scanner` to get user input from the console.
 *     *   Present a menu of options to the user:
 *         1.  Add New Print Job
 *         2.  Process Next Job
 *         3.  View Current Queue
 *         4.  View Processed Job History
 *         5.  Exit
 *     *   Use a `switch` statement to handle the user's menu choice.
 *     *   Display normal output (menu, prompts, job details, status messages) using `System.out`.
 *     *   Display error messages (e.g., invalid input, queue empty) using `System.err`.
 * 
 * 3.  **Print Job Representation:**
 *     *   Create a `PrintJob` class with the following private fields:
 *         *   A unique integer ID (automatically generated).
 *         *   A `String` description of the job.
 *         *   A `String` representing the job's status (e.g., "Pending", "Completed").
 *     *   Include public getter methods for the ID, description, and status.
 *     *   Include a method to mark the job as completed.
 *     *   Override the `toString()` method to provide a convenient string representation of the job.
 * 
 * 4.  **Print Manager Logic:**
 *     *   Create a `PrintManager` class that encapsulates the `Queue` and `List`.
 *     *   Implement methods for each menu option (add, process, view queue, view history).
 *     *   The `addJob` method should create a new `PrintJob` and add it to the queue.
 *     *   The `processNextJob` method should take the next job from the queue, mark it as completed, and move it to the processed jobs list. Handle the case where the queue is empty.
 *     *   The `viewQueue` method should return the jobs currently in the queue as a `List<PrintJob>`.
 *     *   The `viewHistory` method should return the jobs in the processed history list as a `List<PrintJob>`.
 *     *   Implement a main loop that repeatedly displays the menu, gets user input, and performs the chosen action until the user chooses to exit.
 * 
 * 5.  **Error Handling & Best Practices:**
 *     *   Use `try-catch` blocks to handle potential exceptions, particularly for invalid user input (e.g., non-integer input for the menu choice). Use "class-wide" handling by placing `try-catch` blocks within the main loop where input is processed.
 *     *   Validate user input where appropriate (e.g., non-empty job description).
 *     *   Ensure proper encapsulation (private fields, public methods).
 *     *   Use meaningful variable and method names.
 *     *   Include appropriate comments and documentation (e.g., Javadoc).
 *     *   Manage resources properly (e.g., close the `Scanner`).
 * 
 * **Expected Output:**
 * 
 * The system should run interactively. Example interaction might look like this:
 * 
 * ```
 * --- Print Job Management System ---
 * 1. Add New Print Job
 * 2. Process Next Job
 * 3. View Current Queue
 * 4. View Processed Job History
 * 5. Exit
 * Enter your choice: 1
 * Enter job description: Document A
 * 
 * Added job to queue: Document A (ID: 1)
 * 
 * --- Print Job Management System ---
 * ... menu ...
 * Enter your choice: 1
 * Enter job description: Report B
 * 
 * Added job to queue: Report B (ID: 2)
 * 
 * --- Print Job Management System ---
 * ... menu ...
 * Enter your choice: 3
 * 
 * --- Current Print Queue (2 jobs) ---
 * 1. Job ID: 1, Description: "Document A", Status: Pending
 * 2. Job ID: 2, Description: "Report B", Status: Pending
 * 
 * --- Print Job Management System ---
 * ... menu ...
 * Enter your choice: 2
 * 
 * Processed job: Document A (ID: 1)
 * 
 * --- Print Job Management System ---
 * ... menu ...
 * Enter your choice: 3
 * 
 * --- Current Print Queue (1 jobs) ---
 * 1. Job ID: 2, Description: "Report B", Status: Pending
 * 
 * --- Print Job Management System ---
 * ... menu ...
 * Enter your choice: 4
 * 
 * --- Processed Job History (1 jobs) ---
 * 1. Job ID: 1, Description: "Document A", Status: Completed
 * 
 * --- Print Job Management System ---
 * ... menu ...
 * Enter your choice: abc
 * 
 * Invalid input. Please enter a number.
 * 
 * --- Print Job Management System ---
 * ... menu ...
 * Enter your choice: 2
 * 
 * Processed job: Report B (ID: 2)
 * 
 * --- Print Job Management System ---
 * ... menu ...
 * Enter your choice: 2
 * 
 * Print queue is empty. No jobs to process.
 * 
 * --- Print Job Management System ---
 * ... menu ...
 * Enter your choice: 5
 * 
 * Exiting Print Job Management System. Goodbye!
 * ```
 * 
 * Implement the `PrintJob` and `PrintManager` classes to fulfill these requirements.
 *
 * EXPLANATION:
 * The provided solution implements a `Simulated Print Job Management System` using the required Java components and best practices.
 * 
 * 1.  **`PrintJob` Class:**
 *     *   Encapsulates the data for a single print job (`jobId`, `description`, `status`) with private fields.
 *     *   Uses an `AtomicInteger` (`jobCounter`) to generate unique, sequential job IDs in a thread-safe manner (good practice).
 *     *   Provides public getter methods (`getJobId`, `getDescription`, `getStatus`).
 *     *   Includes a `markCompleted` method to change the job's status.
 *     *   Overrides `toString()` for easy printing of job details.
 * 
 * 2.  **`PrintManager` Class:**
 *     *   Acts as the central controller, holding the system's state.
 *     *   Uses a `java.util.Queue<PrintJob>` (`printQueue`) implemented by `java.util.LinkedList` to store pending jobs, ensuring FIFO processing.
 *     *   Uses a `java.util.List<PrintJob>` (`processedJobs`) implemented by `java.util.ArrayList` to store completed jobs, fulfilling the requirement to use both `List` interface and `ArrayList` implementation.
 *     *   Manages a `java.util.Scanner` for user input.
 *     *   **`addJob(String description)`:** Creates a new `PrintJob`, validates the description, and adds it to the `printQueue` using `queue.add()`.
 *     *   **`processNextJob()`:** Uses `queue.poll()` to retrieve and remove the head of the queue. `poll()` is preferred over `remove()` as it returns `null` if the queue is empty, avoiding an exception. If a job is retrieved, its status is updated, and it's added to the `processedJobs` list.
 *     *   **`viewQueue()`:** Returns the current jobs in the `printQueue` as a `List<PrintJob>`. It creates a new `ArrayList` initialized with the elements from the queue. This satisfies the requirement to return a `List` and avoids exposing the internal `Queue` object directly, promoting encapsulation.
 *     *   **`viewHistory()`:** Returns the `processedJobs` `ArrayList` as a `List<PrintJob>`. This directly returns the history list, which is common practice for history/log data structures.
 *     *   **`displayMenu()`:** A private helper method to print the menu options.
 *     *   **`runSimulation()`:** Contains the main application loop. It repeatedly displays the menu, reads user input using the `Scanner`, and uses a `switch` statement to execute the corresponding `PrintManager` method based on the user's choice.
 *     *   **Exception Handling:** A `try-catch` block is placed around the input reading (`scanner.nextInt()`) and the `switch` statement within the `runSimulation` loop. This handles `InputMismatchException` specifically if the user enters non-integer input for the menu choice, preventing the program from crashing and prompting the user to try again. A general `catch (Exception e)` is included as a fallback for any other unexpected runtime errors, printing the error message and stack trace to `System.err`. This demonstrates "class-wide" handling within the main operational method.
 *     *   **Resource Management:** The `Scanner` is initialized in the constructor and closed in the `runSimulation` method after the main loop finishes, releasing the system resource.
 *     *   **`main` Method:** The entry point of the application, which creates a `PrintManager` instance and calls `runSimulation()` to start the interactive system.
 * 
 * This solution effectively integrates all the required Java components, simulates a practical scenario, follows best practices for object-oriented design and error handling, and provides a challenging yet solvable task suitable for an exam.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.InputMismatchException;
import java.util.concurrent.atomic.AtomicInteger; // For unique job IDs

/**
 * Represents a single print job in the system.
 */
class PrintJob {
    // Use AtomicInteger for thread-safe unique ID generation, good practice even in single-threaded context
    private static final AtomicInteger jobCounter = new AtomicInteger(0);

    private final int jobId;
    private final String description;
    private String status;

    // Constants for job status
    public static final String STATUS_PENDING = "Pending";
    public static final String STATUS_COMPLETED = "Completed";

    /**
     * Constructs a new PrintJob with a unique ID and description.
     * Status is initialized to PENDING.
     * @param description The description of the print job.
     */
    public PrintJob(String description) {
        this.jobId = jobCounter.incrementAndGet(); // Assign unique ID
        this.description = description;
        this.status = STATUS_PENDING;
    }

    /**
     * Gets the unique ID of the print job.
     * @return The job ID.
     */
    public int getJobId() {
        return jobId;
    }

    /**
     * Gets the description of the print job.
     * @return The job description.
     */
    public String getDescription() {
        return description;
    }

    /**
     * Gets the current status of the print job.
     * @return The job status (e.g., "Pending", "Completed").
     */
    public String getStatus() {
        return status;
    }

    /**
     * Marks the print job as completed.
     */
    public void markCompleted() {
        this.status = STATUS_COMPLETED;
    }

    /**
     * Provides a string representation of the PrintJob.
     * @return A formatted string representing the job details.
     */
    @Override
    public String toString() {
        return String.format("Job ID: %d, Description: \"%s\", Status: %s",
                             jobId, description, status);
    }
}

/**
 * Manages the queue of print jobs and the history of processed jobs.
 */
public class PrintManager {

    // Queue to hold jobs waiting to be processed (FIFO)
    private Queue<PrintJob> printQueue;

    // List to hold jobs that have been processed
    private List<PrintJob> processedJobs; // Declared using List interface

    // Scanner for user input
    private Scanner scanner;

    /**
     * Constructs a new PrintManager, initializing the queue and history list.
     */
    public PrintManager() {
        // LinkedList implements both Queue and List, making it versatile.
        // We use it here primarily as a Queue.
        this.printQueue = new LinkedList<>();
        // ArrayList is explicitly required for the history list.
        this.processedJobs = new ArrayList<>();
        // Initialize the scanner for reading console input.
        this.scanner = new Scanner(System.in);
    }

    /**
     * Adds a new print job to the queue.
     * Validates that the description is not empty.
     * @param description The description of the job to add.
     */
    public void addJob(String description) {
        if (description == null || description.trim().isEmpty()) {
            System.err.println("Error: Job description cannot be empty. Job not added.");
            return;
        }
        PrintJob newJob = new PrintJob(description.trim());
        printQueue.add(newJob); // Add job to the end of the queue
        System.out.println("Added job to queue: " + newJob.getDescription() + " (ID: " + newJob.getJobId() + ")");
    }

    /**
     * Processes the next job from the front of the queue.
     * If a job is processed, it is marked completed and moved to the history list.
     * Handles the case where the queue is empty.
     * @return The job that was processed, or null if the queue was empty.
     */
    public PrintJob processNextJob() {
        // poll() retrieves and removes the head of the queue, returning null if empty.
        PrintJob jobToProcess = printQueue.poll();
        if (jobToProcess != null) {
            jobToProcess.markCompleted(); // Mark the job as completed
            processedJobs.add(jobToProcess); // Add the completed job to the history list
            System.out.println("Processed job: " + jobToProcess.getDescription() + " (ID: " + jobToProcess.getJobId() + ")");
            return jobToProcess;
        } else {
            System.out.println("Print queue is empty. No jobs to process.");
            return null;
        }
    }

    /**
     * Returns a list containing the jobs currently in the queue.
     * Creates a new ArrayList from the queue's elements to return as a List interface type.
     * This prevents external modification of the internal queue state.
     * @return A List of PrintJob objects currently in the queue.
     */
    public List<PrintJob> viewQueue() {
        // Create a new ArrayList and add all elements from the queue to it.
        // This fulfills the requirement of returning a List and uses ArrayList internally.
        return new ArrayList<>(printQueue);
    }

    /**
     * Returns the list of jobs that have been processed.
     * Returns the internal ArrayList as a List interface type.
     * @return A List of PrintJob objects that have been completed.
     */
    public List<PrintJob> viewHistory() {
        return processedJobs; // Return the history list
    }

    /**
     * Displays the main menu options to the console.
     */
    private void displayMenu() {
        System.out.println("\n--- Print Job Management System ---");
        System.out.println("1. Add New Print Job");
        System.out.println("2. Process Next Job");
        System.out.println("3. View Current Queue");
        System.out.println("4. View Processed Job History");
        System.out.println("5. Exit");
        System.out.print("Enter your choice: ");
    }

    /**
     * Runs the main simulation loop for the print job manager.
     * Handles user input, dispatches actions using a switch statement,
     * and includes exception handling for input errors.
     */
    public void runSimulation() {
        boolean running = true;

        // Main loop for the application
        while (running) {
            displayMenu();
            int choice = -1; // Default invalid choice

            try {
                // Attempt to read the integer choice from the user
                choice = scanner.nextInt();
                // Consume the leftover newline character after reading the integer
                scanner.nextLine();

                // Use a switch statement to handle different menu options
                switch (choice) {
                    case 1:
                        System.out.print("Enter job description: ");
                        String description = scanner.nextLine();
                        addJob(description); // Call method to add job
                        break;
                    case 2:
                        processNextJob(); // Call method to process next job
                        break;
                    case 3:
                        List<PrintJob> currentQueue = viewQueue(); // Get queue contents as a List
                        System.out.println("\n--- Current Print Queue (" + currentQueue.size() + " jobs) ---");
                        if (currentQueue.isEmpty()) {
                            System.out.println("Queue is empty.");
                        } else {
                            // Iterate through the List and print each job
                            for (int i = 0; i < currentQueue.size(); i++) {
                                System.out.println((i + 1) + ". " + currentQueue.get(i));
                            }
                        }
                        break;
                    case 4:
                        List<PrintJob> history = viewHistory(); // Get history as a List
                        System.out.println("\n--- Processed Job History (" + history.size() + " jobs) ---");
                         if (history.isEmpty()) {
                            System.out.println("History is empty.");
                        } else {
                            // Iterate through the List and print each job
                            for (int i = 0; i < history.size(); i++) {
                                System.out.println((i + 1) + ". " + history.get(i));
                            }
                        }
                        break;
                    case 5:
                        System.out.println("Exiting Print Job Management System. Goodbye!");
                        running = false; // Set flag to exit the loop
                        break;
                    default:
                        // Handle choices outside the valid range
                        System.err.println("Invalid choice. Please enter a number between 1 and 5.");
                }
            } catch (InputMismatchException e) {
                // Catch exception if the user enters non-integer input for the menu choice
                System.err.println("Invalid input. Please enter a number.");
                // Consume the invalid input line to prevent an infinite loop
                scanner.nextLine();
            } catch (Exception e) {
                 // Catch any other unexpected exceptions during execution
                 System.err.println("An unexpected error occurred: " + e.getMessage());
                 // Print stack trace for debugging purposes to standard error
                 e.printStackTrace(System.err);
            }
        }

        // Close the scanner resource when the simulation loop finishes
        scanner.close();
    }

    /**
     * Main method to start the Print Job Management System application.
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        PrintManager manager = new PrintManager();
        manager.runSimulation(); // Start the main simulation loop
    }
}
