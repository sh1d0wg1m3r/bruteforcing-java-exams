/*
 * Exam Question #1010
 * Generated on: 2025-05-12 17:12:27
 * Generated by: Account 2
 * 
 * QUESTION:
 * **Java Programming Exam Task: Advanced Task Management System**
 * 
 * **Problem Description:**
 * 
 * You are tasked with building a simple command-line application for managing tasks. The system should allow users to add new tasks, process the next pending task, and view both pending and completed tasks. Tasks have a description and a positive integer priority. The system should process tasks in the order they were added (FIFO) among tasks of equal implicit priority, but the priority concept is introduced for future expansion and input validation in this version.
 * 
 * Your solution must demonstrate a strong understanding of core Java data structures, object-oriented principles, user interaction, and error handling.
 * 
 * **Requirements:**
 * 
 * 1.  **Task Representation:** Create a `Task` class with private fields for `id` (unique, automatically generated), `description` (String), and `priority` (int). Include a constructor and public getter methods. Override the `toString()` method for easy display.
 * 2.  **Task Management:** Create a `TaskManager` class to manage the tasks.
 *     *   It must use a `java.util.Queue` to store pending tasks.
 *     *   It must use a `java.util.List` (specifically a `java.util.ArrayList`) to store completed tasks.
 *     *   Implement methods:
 *         *   `addTask(String description, int priority)`: Adds a new task to the pending queue. It must validate that the priority is a positive integer.
 *         *   `processNextTask()`: Removes the task at the front of the pending queue, moves it to the completed list, and prints a message indicating which task was processed. Handle the case where the queue is empty.
 *         *   `viewPendingTasks()`: Prints details of all tasks currently in the pending queue.
 *         *   `viewCompletedTasks()`: Prints details of all tasks currently in the completed list.
 * 3.  **User Interface:** Create a main application class (e.g., `TaskManagementApp`) with a `main` method that interacts with the user via the console.
 *     *   Use `java.util.Scanner` to read user input (commands and task details).
 *     *   Present a menu of options to the user (Add Task, Process Task, View Pending, View Completed, Exit).
 *     *   Use a `switch` statement to handle the user's command selection.
 *     *   Implement a loop to keep the application running until the user chooses to exit.
 * 4.  **Error Handling:**
 *     *   Use `System.err` to print error messages (e.g., invalid command, invalid priority input, invalid priority value).
 *     *   Use `System.out` for normal output and informational messages.
 *     *   Implement class-wide exception handling using `try-catch` blocks in the main application loop to catch potential unexpected errors. Additionally, handle specific expected errors like `InputMismatchException` during priority input and invalid priority values.
 * 5.  **Best Practices:**
 *     *   Apply proper encapsulation (private fields, public methods).
 *     *   Use meaningful variable and method names.
 *     *   Include appropriate comments explaining complex logic.
 *     *   Ensure input validation for priority.
 *     *   Structure the code clearly into classes.
 * 
 * **Expected Output:**
 * 
 * The application should display a menu, prompt for input, and provide feedback based on the user's actions. Examples of output include:
 * 
 * *   Menu display.
 * *   Confirmation messages for adding/processing tasks.
 * *   Lists of pending and completed tasks.
 * *   Messages when trying to process an empty queue.
 * *   Error messages printed to `System.err` for invalid inputs or commands.
 * *   A general error message printed to `System.err` for unexpected exceptions caught by the main `try-catch`.
 * 
 * **Constraints:**
 * 
 * *   You must use `java.util.Queue`, `java.util.ArrayList`, `java.util.List`, `java.util.Scanner`, `switch`, `System.err`, `System.out`, and `try-catch`.
 * *   Priority must be a positive integer (> 0).
 * 
 * **Deliverables:**
 * 
 * Provide the complete, runnable Java source code for the application.
 *
 * EXPLANATION:
 * The solution provides a command-line Task Management System that fulfills all the specified requirements.
 * 
 * 1.  **Task Representation (`Task` class):**
 *     *   The `Task` class encapsulates the properties of a task (`id`, `description`, `priority`) using private fields.
 *     *   A `static` variable `nextId` ensures each task gets a unique, automatically incremented ID upon creation.
 *     *   Public getter methods provide controlled access to the task's properties.
 *     *   The `toString()` method is overridden for a convenient and readable representation of a task object when printed.
 * 
 * 2.  **Task Management (`TaskManager` class):**
 *     *   `private Queue<Task> pendingTasks = new LinkedList<>();`: A `LinkedList` is used here because it implements the `Queue` interface and provides FIFO behavior, which is suitable for processing tasks in the order they were added. `Queue` ensures we use methods like `offer()` (add to tail) and `poll()` (remove from head).
 *     *   `private List<Task> completedTasks = new ArrayList<>();`: An `ArrayList` is used here because it implements the `List` interface and is efficient for storing and iterating over completed tasks. `List` provides indexed access (though not strictly needed here) and dynamic resizing.
 *     *   `addTask()`: Takes description and priority. It includes validation to ensure the priority is positive, throwing an `IllegalArgumentException` if not. It then creates a new `Task` object and adds it to the `pendingTasks` queue using `offer()`.
 *     *   `processNextTask()`: Checks if the `pendingTasks` queue is empty using `isEmpty()`. If not empty, it removes the head task using `poll()` and adds it to the `completedTasks` list using `add()`. If the queue is empty, it prints an informative message to `System.out`.
 *     *   `viewPendingTasks()`: Iterates through the `pendingTasks` queue using a for-each loop (which uses the queue's iterator) and prints each task's details.
 *     *   `viewCompletedTasks()`: Iterates through the `completedTasks` list and prints each task's details.
 * 
 * 3.  **User Interface (`TaskManagementApp` class):**
 *     *   The `main` method drives the application.
 *     *   `Scanner scanner = new Scanner(System.in);` is used to read input from the console.
 *     *   A `while(running)` loop keeps the application active until the user chooses to exit.
 *     *   `displayMenu()` is a helper method to print the available options.
 *     *   The main command input is read using `scanner.nextInt()`, and `scanner.nextLine()` is called immediately after to consume the leftover newline character, preventing issues with subsequent `nextLine()` calls.
 *     *   A `switch` statement handles the different integer commands entered by the user, directing the flow to the corresponding `TaskManager` methods or application logic.
 *     *   The "Add New Task" case specifically handles reading the description (`nextLine()`) and priority (`nextInt()`).
 * 
 * 4.  **Error Handling:**
 *     *   `System.err.println()` is used for all error messages, such as invalid commands, invalid priority input type (`InputMismatchException`), and invalid priority value (`IllegalArgumentException`).
 *     *   `System.out.println()` is used for normal output like menu display, task confirmations, processing messages, and task lists.
 *     *   A broad `try-catch(Exception e)` block is wrapped around the core logic inside the `while` loop in `main`. This provides class-wide handling for any unexpected exceptions that might occur during command processing, printing a general error message to `System.err`.
 *     *   Specific `try-catch(InputMismatchException e)` is used within the "Add New Task" case to handle non-integer input when the program expects an integer for the priority. This block also consumes the invalid input from the scanner (`scanner.nextLine()`) to prevent an infinite error loop.
 *     *   An `IllegalArgumentException` is explicitly thrown by `addTask` for non-positive priority values and caught in the "Add New Task" case to print a user-friendly error message using `System.err`.
 * 
 * 5.  **Best Practices:**
 *     *   Encapsulation is demonstrated in the `Task` and `TaskManager` classes by keeping data fields private and providing public methods for interaction.
 *     *   Variable names (`pendingTasks`, `completedTasks`, `description`, `priority`, `command`, etc.) and method names (`addTask`, `processNextTask`, `viewPendingTasks`, `displayMenu`) are descriptive.
 *     *   Comments explain the purpose of classes, methods, and specific code blocks (like the static ID counter or the scanner newline consumption).
 *     *   Input validation for priority is implemented in the `addTask` method.
 *     *   The code is structured into logical classes (`Task`, `TaskManager`, `TaskManagementApp`), promoting modularity and readability.
 * 
 * The solution effectively integrates the required Java components (`Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.err`, `System.out`, `try-catch`) within a practical task management simulation, demonstrating advanced understanding of Java programming concepts and best practices.
 */

import java.util.Queue;
import java.util.LinkedList;
import java.util.List;
import java.util.ArrayList;
import java.util.Scanner;
import java.util.InputMismatchException;

// Represents a single task with an ID, description, and priority.
class Task {
    private static int nextId = 1; // Auto-generated unique ID counter

    private int id;
    private String description;
    private int priority; // Positive integer

    /**
     * Constructs a new Task.
     * @param description The description of the task.
     * @param priority The priority of the task (must be positive).
     */
    public Task(String description, int priority) {
        this.id = nextId++; // Assign unique ID and increment counter
        this.description = description;
        this.priority = priority;
    }

    // --- Getters ---
    public int getId() {
        return id;
    }

    public String getDescription() {
        return description;
    }

    public int getPriority() {
        return priority;
    }

    /**
     * Provides a string representation of the Task.
     */
    @Override
    public String toString() {
        return "Task{id=" + id + ", description='" + description + "', priority=" + priority + '}';
    }
}

// Manages the collection of pending and completed tasks.
class TaskManager {
    // Using LinkedList as a Queue for pending tasks (FIFO order)
    private Queue<Task> pendingTasks;
    // Using ArrayList as a List for completed tasks
    private List<Task> completedTasks;

    /**
     * Constructs a new TaskManager.
     * Initializes the pending and completed task collections.
     */
    public TaskManager() {
        this.pendingTasks = new LinkedList<>();
        this.completedTasks = new ArrayList<>();
    }

    /**
     * Adds a new task to the pending queue.
     * @param description The description of the task.
     * @param priority The priority of the task.
     * @throws IllegalArgumentException if the priority is not positive.
     */
    public void addTask(String description, int priority) {
        // Input validation for priority
        if (priority <= 0) {
            throw new IllegalArgumentException("Priority must be a positive integer.");
        }
        Task newTask = new Task(description, priority);
        pendingTasks.offer(newTask); // offer adds to the end of the queue
        System.out.println("Task added: " + newTask);
    }

    /**
     * Processes the next task in the pending queue.
     * Removes the task from the queue and adds it to the completed list.
     */
    public void processNextTask() {
        // Check if the queue is empty before trying to poll
        if (pendingTasks.isEmpty()) {
            System.out.println("No pending tasks to process.");
            return;
        }

        Task processedTask = pendingTasks.poll(); // poll retrieves and removes the head of the queue
        completedTasks.add(processedTask); // Add to the completed list
        System.out.println("Processing task: " + processedTask);
    }

    /**
     * Displays all tasks currently in the pending queue.
     */
    public void viewPendingTasks() {
        System.out.println("\n--- Pending Tasks ---");
        if (pendingTasks.isEmpty()) {
            System.out.println("No pending tasks.");
        } else {
            // Iterate through the queue without removing elements
            for (Task task : pendingTasks) {
                System.out.println(task);
            }
        }
        System.out.println("---------------------");
    }

    /**
     * Displays all tasks currently in the completed list.
     */
    public void viewCompletedTasks() {
        System.out.println("\n--- Completed Tasks ---");
        if (completedTasks.isEmpty()) {
            System.out.println("No completed tasks.");
        } else {
            // Iterate through the list
            for (Task task : completedTasks) {
                System.out.println(task);
            }
        }
        System.out.println("-----------------------");
    }
}

// Main application class to handle user interaction.
public class TaskManagementApp {

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        TaskManager manager = new TaskManager();
        boolean running = true;

        System.out.println("--- Task Management System ---");

        // Main application loop
        while (running) {
            displayMenu();

            // Class-wide exception handling for unexpected errors
            try {
                System.out.print("Enter command: ");
                int command = scanner.nextInt(); // Read integer command
                scanner.nextLine(); // Consume the newline character left by nextInt()

                // Use switch statement for flow control based on command
                switch (command) {
                    case 1: // Add New Task
                        System.out.print("Enter task description: ");
                        String description = scanner.nextLine();
                        int priority = -1; // Initialize with an invalid value

                        // Specific exception handling for priority input
                        try {
                            System.out.print("Enter priority (positive integer): ");
                            priority = scanner.nextInt();
                            scanner.nextLine(); // Consume newline

                            manager.addTask(description, priority); // addTask has its own validation

                        } catch (InputMismatchException e) {
                            System.err.println("Invalid input for priority. Please enter an integer.");
                            scanner.nextLine(); // Consume the invalid input to prevent infinite loop
                        } catch (IllegalArgumentException e) {
                            System.err.println("Error: " + e.getMessage()); // Handle non-positive priority from addTask
                        }
                        break;

                    case 2: // Process Next Task
                        manager.processNextTask();
                        break;

                    case 3: // View Pending Tasks
                        manager.viewPendingTasks();
                        break;

                    case 4: // View Completed Tasks
                        manager.viewCompletedTasks();
                        break;

                    case 5: // Exit
                        running = false;
                        System.out.println("Exiting Task Manager.");
                        break;

                    default: // Invalid command
                        System.err.println("Invalid command. Please enter a number between 1 and 5.");
                        break;
                }
            } catch (InputMismatchException e) {
                // Catch non-integer input for the main command
                System.err.println("Invalid input. Please enter a number corresponding to the menu option.");
                scanner.nextLine(); // Consume the invalid input
            } catch (Exception e) {
                // Catch any other unexpected exceptions
                System.err.println("An unexpected error occurred: " + e.getMessage());
                // Optionally print stack trace for debugging: e.printStackTrace();
            }
            System.out.println(); // Add a newline for better readability between commands
        }

        scanner.close(); // Close the scanner when done
    }

    /**
     * Displays the main menu options to the user.
     */
    private static void displayMenu() {
        System.out.println("Task Manager Menu:");
        System.out.println("1. Add New Task");
        System.out.println("2. Process Next Task");
        System.out.println("3. View Pending Tasks");
        System.out.println("4. View Completed Tasks");
        System.out.println("5. Exit");
    }
}
