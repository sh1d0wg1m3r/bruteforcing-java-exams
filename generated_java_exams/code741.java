/*
 * Exam Question #741
 * Generated on: 2025-05-12 16:34:09
 * Generated by: Account 2
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Simple Command-Line Task Manager
 * 
 * **Scenario:**
 * 
 * You are tasked with building a simple command-line application to manage personal tasks. The application should allow users to add new tasks, view tasks that are pending completion, mark tasks as completed, and view tasks that have been completed.
 * 
 * **Requirements:**
 * 
 * 1.  **Task Representation:** Create a `Task` class to represent individual tasks. Each task must have a unique ID (a simple incrementing number is sufficient), a description (a `String`), and a status (pending/completed). Use proper encapsulation (private fields, public getters, a method to mark as completed).
 * 2.  **Task Storage:**
 *     *   Pending tasks must be stored in a `java.util.Queue`. Use `java.util.LinkedList` as the concrete implementation for the `Queue`.
 *     *   Completed tasks must be stored in a `java.util.List`. Use `java.util.ArrayList` as the concrete implementation for the `List`.
 * 3.  **User Interface:** The application must present a menu to the user via the console using `System.out`. Use `java.util.Scanner` to read user input.
 * 4.  **Menu Options:** The menu must include at least the following options:
 *     *   Add New Task
 *     *   View Pending Tasks
 *     *   Mark Task as Completed (requires user to input the task ID)
 *     *   View Completed Tasks
 *     *   Exit
 * 5.  **Flow Control:** Use a `switch` statement to handle the user's menu selection.
 * 6.  **Output:**
 *     *   Normal application output (menu, prompts, task lists, success messages) must be printed to `System.out`.
 *     *   Error messages must be printed to `System.err`.
 * 7.  **Error Handling:**
 *     *   Implement robust input validation for menu choices (e.g., handle non-numeric input).
 *     *   Handle cases where a user tries to complete a task using an ID that does not exist in the pending tasks. Define and use a custom exception (e.g., `TaskNotFoundException`) for this specific error.
 *     *   Implement class-wide exception handling using a `try-catch` block that wraps the main application loop to catch any unexpected runtime errors.
 * 8.  **Best Practices:** Adhere to Java best practices, including:
 *     *   Meaningful variable and method names.
 *     *   Appropriate comments (especially Javadoc for classes and methods) and inline comments for complex logic.
 *     *   Clean code structure (e.g., separate methods for different functionalities).
 * 
 * **Expected Output:**
 * 
 * The application should display a menu, prompt for input, perform the requested action, and display relevant output or error messages.
 * 
 * ```
 * --- Task Manager Menu ---
 * 1. Add New Task
 * 2. View Pending Tasks
 * 3. Mark Task as Completed
 * 4. View Completed Tasks
 * 5. Exit
 * Enter your choice:
 * ```
 * (Example interaction after adding tasks and completing one)
 * ```
 * --- Pending Tasks ---
 * [ID: 1] Buy groceries
 * [ID: 3] Call mom
 * -----------------------
 * Total pending: 2
 * 
 * --- Completed Tasks ---
 * [ID: 2] Finish report (Completed)
 * -----------------------
 * Total completed: 1
 * ```
 * (Example error output)
 * ```
 * Error: Task with ID '99' not found in pending tasks.
 * ```
 * ```
 * Invalid input. Please enter a number.
 * ```
 * 
 * Implement the solution in a single Java file containing the `Task` class, the custom exception class, and the main class (e.g., `TaskManager`) with the `main` method.
 * 
 * **Evaluation Criteria:**
 * 
 * *   Correct usage of `Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.out`, `System.err`.
 * *   Correct implementation of the `Task` class with encapsulation.
 * *   Proper handling of menu choices and task operations.
 * *   Effective input validation and error handling using `try-catch` and the custom exception.
 * *   Adherence to best practices (naming, comments, structure).
 *
 * EXPLANATION:
 * This solution implements a simple command-line task manager application, demonstrating the required Java concepts and best practices.
 * 
 * **Class Structure:**
 * 
 * 1.  **`Task` Class:** This class is a simple Plain Old Java Object (POJO) representing a single task. It encapsulates the task's `id`, `description`, and `isCompleted` status using private fields and public getter methods. The `markCompleted()` method provides a controlled way to change the task's status. The `toString()` method provides a convenient string representation for printing. The `equals()` and `hashCode()` methods are overridden based on the `id` to ensure tasks can be uniquely identified and correctly handled in collections, particularly when searching or removing.
 * 2.  **`TaskNotFoundException` Class:** This is a custom checked exception that extends `java.lang.Exception`. It is used specifically by the `completeTask` method to signal when a user attempts to complete a task using an ID that does not correspond to any task currently in the pending list. Using a custom exception makes the error handling more specific and readable than using a generic exception.
 * 3.  **`TaskManager` Class:** This is the main class that orchestrates the application logic.
 *     *   It holds the two primary collections: `pendingTasks` (declared as `Queue<Task>`, implemented as `LinkedList`) and `completedTasks` (declared as `List<Task>`, implemented as `ArrayList`).
 *     *   It manages a `Scanner` object for reading user input.
 *     *   `nextTaskId` is a simple counter to generate unique IDs for new tasks.
 *     *   The constructor initializes these fields.
 * 
 * **Core Functionality Implementation:**
 * 
 * *   **`addTask()`:** Prompts the user for a task description, performs a basic validation to ensure it's not empty, generates a unique ID using `nextTaskId`, creates a `Task` object, and adds it to the `pendingTasks` `Queue` using `offer()`.
 * *   **`viewPendingTasks()`:** Iterates through the `pendingTasks` `Queue` using a for-each loop (which uses the queue's iterator internally) and prints each task's string representation to `System.out`. It checks if the queue is empty first.
 * *   **`completeTask()`:** Prompts the user for a task ID. It validates the input is not empty. It then iterates through the `pendingTasks` `Queue` using an `Iterator`. This is crucial because modifying a collection (removing an element) while iterating using a simple for-each loop can lead to `ConcurrentModificationException`. The `Iterator`'s `remove()` method is the safe way to remove the element that was just returned by `next()`. If the task is found, it's removed from the queue, its `markCompleted()` method is called, and it's added to the `completedTasks` `List`. If the loop finishes without finding the task, a `TaskNotFoundException` is thrown.
 * *   **`viewCompletedTasks()`:** Iterates through the `completedTasks` `List` using a for-each loop and prints each completed task's string representation to `System.out`. It checks if the list is empty first.
 * *   **`displayMenu()`:** A simple helper method to print the menu options to `System.out`.
 * 
 * **Control Flow and Error Handling:**
 * 
 * *   **`run()` Method:** This method contains the main application loop (`while(running)`).
 *     *   **Class-wide `try-catch`:** The entire `while` loop is wrapped in a `try-catch(Exception e)` block. This serves as a safety net to catch any unexpected runtime exceptions that might occur anywhere within the application's main execution flow, preventing the program from crashing abruptly. Caught exceptions are printed to `System.err` along with their stack trace for debugging.
 *     *   **Input Handling:** Inside the loop, `displayMenu()` is called, and `scanner.nextLine()` is used to read the user's entire input line. `Integer.parseInt()` is used to convert the input string to an integer choice.
 *     *   **Input Validation (`NumberFormatException`):** The `Integer.parseInt()` call is wrapped in a `try-catch(NumberFormatException e)`. This specifically handles cases where the user enters non-numeric input for the menu choice. An error message is printed to `System.err`, and `continue` is used to restart the loop, showing the menu again.
 *     *   **`switch` Statement:** A `switch` statement is used to direct execution based on the valid integer choice. Each case calls the corresponding task management method.
 *     *   **Specific Error Handling (`TaskNotFoundException`):** The call to `completeTask()` is wrapped in its own `try-catch(TaskNotFoundException e)` block. This catches the specific exception thrown by `completeTask()` when an invalid ID is entered. The error message from the exception is printed to `System.err`.
 *     *   **`finally` Block:** A `finally` block is used within the main `try` block of `run()` to ensure that the `Scanner` resource is closed when the `run` method finishes (either by exiting the loop or due to an exception). This is important for resource management.
 * *   **`main()` Method:** The standard entry point which simply creates a `TaskManager` object and calls its `run()` method to start the application.
 * 
 * **Best Practices:**
 * 
 * *   **Encapsulation:** Fields in `Task` and `TaskManager` are private, accessed via public methods.
 * *   **Meaningful Names:** Class names (`Task`, `TaskManager`, `TaskNotFoundException`), method names (`addTask`, `viewPendingTasks`, `completeTask`, `run`), and variable names (`pendingTasks`, `completedTasks`, `taskIdToComplete`) are descriptive.
 * *   **Comments:** Javadoc comments are provided for classes and public methods, explaining their purpose. Inline comments are used to clarify specific logic, such as the use of the `Iterator` for safe removal.
 * *   **Input Validation:** Checks for empty strings and handles `NumberFormatException`.
 * *   **Error Handling:** Uses specific exceptions (`TaskNotFoundException`), catches expected input errors, and has a general catch for unexpected issues, directing errors to `System.err`.
 * *   **Clean Structure:** Code is organized into classes and methods with clear responsibilities.
 * 
 * This solution effectively integrates all the required Java components within a practical scenario, demonstrating fundamental data structures, control flow, object-oriented principles, and robust error handling.
 */

import java.util.Queue;
import java.util.LinkedList;
import java.util.List;
import java.util.ArrayList;
import java.util.Scanner;
import java.util.InputMismatchException;
import java.util.Iterator; // Needed for safe removal during iteration

/**
 * Custom exception for indicating a task was not found.
 */
class TaskNotFoundException extends Exception {
    /**
     * Constructs a TaskNotFoundException with the specified detail message.
     * @param message The detail message.
     */
    public TaskNotFoundException(String message) {
        super(message);
    }
}

/**
 * Represents a single task with an ID, description, and completion status.
 */
class Task {
    private String id;
    private String description;
    private boolean isCompleted;

    /**
     * Constructs a new Task.
     * @param id The unique ID of the task.
     * @param description The description of the task.
     */
    public Task(String id, String description) {
        this.id = id;
        this.description = description;
        this.isCompleted = false; // Tasks are initially not completed
    }

    /**
     * Gets the task ID.
     * @return The task ID.
     */
    public String getId() {
        return id;
    }

    /**
     * Gets the task description.
     * @return The task description.
     */
    public String getDescription() {
        return description;
    }

    /**
     * Checks if the task is completed.
     * @return true if the task is completed, false otherwise.
     */
    public boolean isCompleted() {
        return isCompleted;
    }

    /**
     * Marks the task as completed.
     */
    public void markCompleted() {
        this.isCompleted = true;
    }

    /**
     * Provides a string representation of the task.
     * @return A formatted string including ID, description, and status.
     */
    @Override
    public String toString() {
        return "[ID: " + id + "] " + description + (isCompleted ? " (Completed)" : "");
    }

    /**
     * Checks for equality based on task ID.
     * Necessary for methods like remove() if removing by object reference.
     * @param o The object to compare with.
     * @return true if the objects are equal based on ID, false otherwise.
     */
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Task task = (Task) o;
        return id.equals(task.id);
    }

    /**
     * Generates a hash code based on the task ID.
     * Necessary for consistency with equals().
     * @return The hash code.
     */
    @Override
    public int hashCode() {
        return id.hashCode();
    }
}

/**
 * Manages a collection of tasks, separating pending from completed.
 */
public class TaskManager {
    private Queue<Task> pendingTasks;
    private List<Task> completedTasks;
    private Scanner scanner;
    private int nextTaskId; // Simple counter for generating task IDs

    /**
     * Constructs a new TaskManager, initializing collections and scanner.
     */
    public TaskManager() {
        // Pending tasks stored in a Queue (LinkedList implementation)
        this.pendingTasks = new LinkedList<>();
        // Completed tasks stored in a List (ArrayList implementation)
        this.completedTasks = new ArrayList<>();
        this.scanner = new Scanner(System.in);
        this.nextTaskId = 1; // Start task IDs from 1
    }

    /**
     * Adds a new task based on user input.
     */
    public void addTask() {
        System.out.println("\nEnter Task Description:");
        String description = scanner.nextLine();

        if (description == null || description.trim().isEmpty()) {
             System.err.println("Error: Task description cannot be empty.");
             return; // Exit the method if description is invalid
        }

        String taskId = String.valueOf(nextTaskId++);
        Task newTask = new Task(taskId, description.trim());
        pendingTasks.offer(newTask); // Add the new task to the end of the pending queue
        System.out.println("Task added: " + newTask);
    }

    /**
     * Displays all pending tasks.
     */
    public void viewPendingTasks() {
        System.out.println("\n--- Pending Tasks ---");
        if (pendingTasks.isEmpty()) {
            System.out.println("No pending tasks.");
        } else {
            // Iterate through the queue to display tasks without removing them
            int count = 0;
            for (Task task : pendingTasks) {
                System.out.println(task);
                count++;
            }
            System.out.println("-----------------------");
            System.out.println("Total pending: " + count);
        }
    }

    /**
     * Marks a pending task as completed based on user-provided ID.
     * Removes the task from pending and adds it to completed.
     * @throws TaskNotFoundException if the task ID is not found in pending tasks.
     */
    public void completeTask() throws TaskNotFoundException {
        System.out.println("\nEnter ID of task to complete:");
        String taskIdToComplete = scanner.nextLine();

        if (taskIdToComplete == null || taskIdToComplete.trim().isEmpty()) {
            System.err.println("Error: Task ID cannot be empty.");
            // No exception needed here, just inform the user and return
            return;
        }

        Task taskToComplete = null;
        // Use an Iterator to safely find and remove the task from the Queue
        Iterator<Task> iterator = pendingTasks.iterator();
        while (iterator.hasNext()) {
            Task task = iterator.next();
            if (task.getId().equals(taskIdToComplete.trim())) {
                taskToComplete = task;
                iterator.remove(); // Safely remove the current task from the queue
                break; // Task found and removed, exit loop
            }
        }

        if (taskToComplete != null) {
            taskToComplete.markCompleted(); // Update the task's status
            completedTasks.add(taskToComplete); // Add the task to the completed list
            System.out.println("Task marked as completed: " + taskToComplete);
        } else {
            // If taskToComplete is still null, the ID was not found
            throw new TaskNotFoundException("Task with ID '" + taskIdToComplete + "' not found in pending tasks.");
        }
    }

    /**
     * Displays all completed tasks.
     */
    public void viewCompletedTasks() {
        System.out.println("\n--- Completed Tasks ---");
        if (completedTasks.isEmpty()) {
            System.out.println("No completed tasks.");
        } else {
            // Iterate through the List to display completed tasks
            int count = 0;
            for (Task task : completedTasks) {
                System.out.println(task);
                count++;
            }
            System.out.println("-----------------------");
            System.out.println("Total completed: " + count);
        }
    }

    /**
     * Displays the main menu to the user.
     */
    private void displayMenu() {
        System.out.println("\n--- Task Manager Menu ---");
        System.out.println("1. Add New Task");
        System.out.println("2. View Pending Tasks");
        System.out.println("3. Mark Task as Completed");
        System.out.println("4. View Completed Tasks");
        System.out.println("5. Exit");
        System.out.print("Enter your choice: ");
    }

    /**
     * Runs the main application loop, handling user interaction and menu choices.
     * Includes class-wide exception handling.
     */
    public void run() {
        boolean running = true;
        // Class-wide try-catch block to handle any unexpected exceptions
        try {
            while (running) {
                displayMenu();
                int choice = -1; // Default value for invalid input

                try {
                    // Read the whole line and parse it to avoid Scanner newline issues
                    String input = scanner.nextLine();
                    choice = Integer.parseInt(input);
                } catch (NumberFormatException e) {
                    // Handle non-integer input specifically
                    System.err.println("Invalid input. Please enter a number.");
                    continue; // Skip the rest of the loop and show menu again
                }

                // Use a switch statement for menu navigation
                switch (choice) {
                    case 1:
                        addTask();
                        break;
                    case 2:
                        viewPendingTasks();
                        break;
                    case 3:
                        try {
                            completeTask();
                        } catch (TaskNotFoundException e) {
                            // Handle the specific task not found error
                            System.err.println("Error: " + e.getMessage());
                        }
                        break;
                    case 4:
                        viewCompletedTasks();
                        break;
                    case 5:
                        System.out.println("Exiting Task Manager. Goodbye!");
                        running = false; // Set flag to exit loop
                        break;
                    default:
                        // Handle choices outside the valid range
                        System.err.println("Invalid choice. Please enter a number between 1 and 5.");
                }
            }
        } catch (Exception e) {
            // Catch any other unexpected exceptions that might occur
            System.err.println("An unexpected error occurred: " + e.getMessage());
            // Print stack trace to System.err for debugging
            e.printStackTrace(System.err);
        } finally {
            // Ensure the scanner resource is closed when the application exits
            if (scanner != null) {
                scanner.close();
            }
        }
    }

    /**
     * The main entry point of the application.
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        TaskManager manager = new TaskManager();
        manager.run(); // Start the application
    }
}
