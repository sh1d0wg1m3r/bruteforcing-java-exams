/*
 * Exam Question #143
 * Generated on: 2025-05-11 22:20:55
 * Generated by: Account 4
 * 
 * QUESTION:
 * ## Complex Java Programming Exam Task: Simple Team Task Manager
 * 
 * **Scenario:**
 * 
 * You are tasked with building a command-line application to help a small team manage their workflow. The application should allow users to add new tasks, process the next task needing attention, and view the lists of pending and completed tasks. This system simulates a basic queue-based workflow where tasks are processed in the order they are added.
 * 
 * **Requirements:**
 * 
 * Your solution must be a single Java application consisting of multiple classes and must demonstrate advanced understanding by incorporating ALL of the following Java components:
 * 
 * 1.  **`java.util.Queue`**: To manage tasks that are waiting to be processed (pending tasks). Tasks should be processed in First-In, First-Out (FIFO) order.
 * 2.  **`java.util.ArrayList`**: To store tasks that have been successfully completed.
 * 3.  **`java.util.List`**: The completed tasks collection must be declared using the `List` interface type, instantiated as an `ArrayList`.
 * 4.  **`java.util.Scanner`**: For reading user input from the console (menu choices and task descriptions).
 * 5.  **`switch` statement**: To control the program flow based on the user's menu selection.
 * 6.  **`System.err`**: To display error messages and warnings (e.g., invalid input, attempting an action when a collection is empty).
 * 7.  **`System.out`**: To display the main menu, prompts, task lists, and success messages.
 * 8.  **Class-wide Exception Handling with `try-catch`**: Implement robust error handling using `try-catch` blocks to gracefully handle potential runtime issues, such as invalid user input (non-integer where an integer is expected) or attempting to perform an action that is not possible (e.g., processing a task when the pending queue is empty).
 * 
 * **Application Structure & Functionality:**
 * 
 * 1.  **`Task` Class:**
 *     *   Represent a single task.
 *     *   Private fields: `int id` (unique identifier), `String description`.
 *     *   Constructor to initialize these fields.
 *     *   Public getter methods for `id` and `description`.
 *     *   Override `toString()` to provide a user-friendly representation (e.g., "Task [ID]: Description").
 * 2.  **`TaskManager` Class:**
 *     *   Manage the collections of pending and completed tasks.
 *     *   Private fields: `Queue<Task> pendingTasks`, `List<Task> completedTasks`, and an integer counter for generating unique task IDs.
 *     *   Constructor to initialize the collections and the ID counter.
 *     *   Public methods:
 *         *   `addTask(String description)`: Creates a new `Task` with a unique ID and adds it to the `pendingTasks` queue. Should validate that the description is not empty.
 *         *   `processNextTask()`: Removes the task at the head of the `pendingTasks` queue and adds it to the `completedTasks` list. Returns the processed task or `null` if the pending queue was empty.
 *         *   `viewPendingTasks()`: Displays all tasks currently in the `pendingTasks` queue.
 *         *   `viewCompletedTasks()`: Displays all tasks currently in the `completedTasks` list.
 * 3.  **`TaskApp` Class (Main Application):**
 *     *   Contain the `main` method.
 *     *   Create a `Scanner` object and a `TaskManager` object.
 *     *   Implement a main application loop that continues until the user chooses to exit.
 *     *   Inside the loop:
 *         *   Display a menu of options using `System.out`.
 *         *   Read the user's choice using `Scanner`.
 *         *   Use a `try-catch` block to handle potential `NumberFormatException` if the user enters non-integer input for the menu choice.
 *         *   Use a `switch` statement on the valid integer choice to perform the corresponding action.
 *         *   For each action (adding, processing, viewing), call the appropriate method(s) on the `TaskManager` object.
 *         *   Implement error handling for specific scenarios (e.g., attempting to process an empty queue, adding an empty task) using `System.err`. This can be done by checking the return value of `processNextTask` or catching exceptions thrown by `addTask`.
 *         *   Include a `default` case in the `switch` for invalid menu numbers, printing an error to `System.err`.
 *     *   Ensure the `Scanner` is properly closed when the application exits (e.g., using try-with-resources or closing explicitly).
 * 
 * **Best Practices:**
 * 
 * *   Use meaningful variable and method names.
 * *   Include basic comments explaining the purpose of classes and key methods.
 * *   Implement input validation (e.g., task description not empty).
 * *   Provide clear output messages using `System.out` and error messages using `System.err`.
 * *   Handle edge cases gracefully (e.g., viewing empty lists/queues).
 * 
 * **Expected Output:**
 * 
 * The application should present a clear menu. User interactions should result in appropriate messages confirming actions, displaying task lists (or indicating they are empty), or printing error messages to the standard error stream when invalid operations or inputs occur.
 * 
 * ```
 * --- Simple Team Task Manager ---
 * Please choose an option:
 * 1. Add New Task
 * 2. Process Next Task
 * 3. View Pending Tasks
 * 4. View Completed Tasks
 * 5. Exit
 * Enter your choice: 1
 * Enter task description: Implement menu
 * Added task: Task 1: Implement menu
 * 
 * Please choose an option:
 * 1. Add New Task
 * 2. Process Next Task
 * 3. View Pending Tasks
 * 4. View Completed Tasks
 * 5. Exit
 * Enter your choice: 1
 * Enter task description: Add error handling
 * Added task: Task 2: Add error handling
 * 
 * Please choose an option:
 * 1. Add New Task
 * 2. Process Next Task
 * 3. View Pending Tasks
 * 4. View Completed Tasks
 * 5. Exit
 * Enter your choice: 3
 * 
 * --- Pending Tasks ---
 * 1. Task 1: Implement menu
 * 2. Task 2: Add error handling
 * ---------------------
 * 
 * Please choose an option:
 * 1. Add New Task
 * 2. Process Next Task
 * 3. View Pending Tasks
 * 4. View Completed Tasks
 * 5. Exit
 * Enter your choice: 2
 * Processed task: Task 1: Implement menu
 * 
 * Please choose an option:
 * 1. Add New Task
 * 2. Process Next Task
 * 3. View Pending Tasks
 * 4. View Completed Tasks
 * 5. Exit
 * Enter your choice: 4
 * 
 * --- Completed Tasks ---
 * 1. Task 1: Implement menu
 * -----------------------
 * 
 * Please choose an option:
 * 1. Add New Task
 * 2. Process Next Task
 * 3. View Pending Tasks
 * 4. View Completed Tasks
 * 5. Exit
 * Enter your choice: abc
 * Invalid input. Please enter a number.
 * 
 * Please choose an option:
 * 1. Add New Task
 * 2. Process Next Task
 * 3. View Pending Tasks
 * 4. View Completed Tasks
 * 5. Exit
 * Enter your choice: 2
 * Processed task: Task 2: Add error handling
 * 
 * Please choose an option:
 * 1. Add New Task
 * 2. Process Next Task
 * 3. View Pending Tasks
 * 4. View Completed Tasks
 * 5. Exit
 * Enter your choice: 2
 * Error: No pending tasks to process.
 * 
 * Please choose an option:
 * 1. Add New Task
 * 2. Process Next Task
 * 3. View Pending Tasks
 * 4. View Completed Tasks
 * 5. Exit
 * Enter your choice: 5
 * Exiting Task Manager. Goodbye!
 * ```
 * 
 * Write the complete Java code for this application.
 *
 * EXPLANATION:
 * This solution implements a simple task management system demonstrating the required Java concepts and best practices.
 * 
 * 1.  **`Task` Class:** This is a simple Plain Old Java Object (POJO) representing a task with an `id` and `description`. It follows encapsulation principles with private fields and public getters. The `toString()` method provides a convenient way to print task details.
 * 
 * 2.  **`TaskManager` Class:** This class acts as the core logic unit, managing the state of the application (the pending and completed tasks).
 *     *   `pendingTasks`: Declared as a `Queue<Task>` and instantiated as a `LinkedList`. `Queue` is chosen because tasks are processed in the order they are added (FIFO), which is the defining characteristic of a queue. `LinkedList` is a common and suitable implementation for `Queue`.
 *     *   `completedTasks`: Declared as a `List<Task>` and instantiated as an `ArrayList`. `List` provides ordered collection capabilities, and `ArrayList` is efficient for storing and iterating over completed items. Declaring it as `List` adheres to the requirement and promotes good practice by programming to an interface.
 *     *   `nextTaskId`: An instance variable used to generate unique sequential IDs for new tasks.
 *     *   `addTask()`: Takes a description, validates it, creates a new `Task` object using the `nextTaskId` counter, and adds it to the `pendingTasks` queue using `offer()`. It includes input validation and throws an `IllegalArgumentException` for empty descriptions.
 *     *   `processNextTask()`: Uses `pendingTasks.poll()` to retrieve and remove the head of the queue. `poll()` is safe as it returns `null` if the queue is empty, avoiding exceptions like `NoSuchElementException`. If a task is retrieved (`not null`), it's added to the `completedTasks` list. The method returns the task or `null`.
 *     *   `viewPendingTasks()` and `viewCompletedTasks()`: These methods iterate through their respective collections and print the task details using `System.out`. They also handle the case where the collections are empty.
 * 
 * 3.  **`TaskApp` Class:** This is the main entry point of the application.
 *     *   `main` method: Initializes the `Scanner` (using try-with-resources for automatic closing) and `TaskManager`.
 *     *   Main loop (`while(running)`): Continuously displays the menu and processes user input until `running` becomes `false`.
 *     *   `printMenu()`: A helper method to display the menu options using `System.out`.
 *     *   **`Scanner`**: Reads user input using `scanner.nextLine()`. Reading the whole line is generally safer than `nextInt()` as it consumes the newline character, preventing issues in subsequent `nextLine()` calls.
 *     *   **`try-catch` (Input Handling)**: A `try-catch` block wraps the `Integer.parseInt(inputLine)` call. If the user enters non-numeric text, `NumberFormatException` is caught, and an error message is printed to `System.err`. This prevents the program from crashing on invalid input type.
 *     *   **`switch` statement**: Used to direct execution based on the parsed integer choice (1-5). This provides a clean and readable way to handle multiple distinct command options.
 *     *   **`try-catch` (Logic/Validation Handling)**:
 *         *   Inside `case 1` (Add Task), a `try-catch` block calls `manager.addTask()`. It specifically catches `IllegalArgumentException` thrown by `addTask` if the description is invalid, printing the error message to `System.err`.
 *         *   Inside `case 2` (Process Task), the code checks the return value of `manager.processNextTask()`. If it's `null`, it means the queue was empty, and an error message is printed to `System.err`. If not `null`, the success message is printed to `System.out`.
 *     *   **`System.out` / `System.err`**: `System.out` is used for standard informational output (menu, prompts, success messages, task lists), while `System.err` is strictly used for error conditions (invalid input type, invalid menu choice, empty description error, attempting to process an empty queue, unexpected errors).
 *     *   **Class-wide Exception Handling**: The `try-catch` blocks within the `main` loop effectively handle exceptions that occur during the processing of each user command. An outer `try-catch` handles potential issues during application startup or related to the `Scanner` itself.
 * 
 * This solution effectively integrates all required components within a practical scenario, demonstrating proper object-oriented design, data structure usage, input handling, and robust error management, aligning with best practices.
 */

// File: Task.java
package com.exam.taskmanager; // Using a package is good practice

/**
 * Represents a single task with an ID and description.
 */
public class Task {
    private int id;
    private String description;

    /**
     * Constructs a new Task.
     * @param id The unique identifier for the task.
     * @param description A brief description of the task.
     */
    public Task(int id, String description) {
        this.id = id;
        this.description = description;
    }

    // --- Getters ---
    public int getId() {
        return id;
    }

    public String getDescription() {
        return description;
    }

    /**
     * Provides a user-friendly string representation of the task.
     * @return Formatted string "Task [ID]: Description".
     */
    @Override
    public String toString() {
        return "Task " + id + ": " + description;
    }
}

// File: TaskManager.java
package com.exam.taskmanager; // Using a package is good practice

import java.util.Queue;
import java.util.LinkedList; // Common Queue implementation
import java.util.List;
import java.util.ArrayList; // Common List implementation
import java.util.NoSuchElementException; // Although poll() avoids this, good to know

/**
 * Manages collections of pending and completed tasks.
 * Uses a Queue for pending tasks (FIFO) and a List for completed tasks.
 */
public class TaskManager {
    // Use Queue for FIFO behavior for pending tasks
    private Queue<Task> pendingTasks;
    // Use List (implemented by ArrayList) for completed tasks
    private List<Task> completedTasks;
    private int nextTaskId; // Counter for generating unique task IDs

    /**
     * Constructs a new TaskManager, initializing empty task collections.
     */
    public TaskManager() {
        this.pendingTasks = new LinkedList<>(); // LinkedList implements Queue
        this.completedTasks = new ArrayList<>(); // ArrayList implements List
        this.nextTaskId = 1; // Start task IDs from 1
    }

    /**
     * Adds a new task to the pending queue.
     *
     * @param description The description of the task.
     * @throws IllegalArgumentException if the description is null or empty/whitespace.
     */
    public void addTask(String description) {
        // Input validation for description
        if (description == null || description.trim().isEmpty()) {
            throw new IllegalArgumentException("Task description cannot be empty.");
        }

        Task newTask = new Task(nextTaskId++, description.trim());
        // offer() is the standard way to add to a Queue
        pendingTasks.offer(newTask);
        System.out.println("Added task: " + newTask); // Normal output
    }

    /**
     * Processes the next task from the pending queue, moving it to the completed list.
     *
     * @return The task that was processed, or null if the pending queue is empty.
     */
    public Task processNextTask() {
        // poll() retrieves and removes the head of the queue, returns null if empty
        Task nextTask = pendingTasks.poll();

        if (nextTask != null) {
            completedTasks.add(nextTask); // Add to the completed list
            // Success message will be printed by the caller (TaskApp)
        }
        return nextTask; // Return the processed task or null
    }

    /**
     * Displays all tasks currently in the pending queue.
     */
    public void viewPendingTasks() {
        System.out.println("\n--- Pending Tasks ---"); // Normal output
        if (pendingTasks.isEmpty()) {
            System.out.println("No tasks pending."); // Normal output
        } else {
            // Iterate through the queue without removing elements
            int index = 1;
            for (Task task : pendingTasks) {
                System.out.println(index++ + ". " + task); // Normal output
            }
        }
        System.out.println("---------------------"); // Normal output
    }

    /**
     * Displays all tasks currently in the completed list.
     */
    public void viewCompletedTasks() {
        System.out.println("\n--- Completed Tasks ---"); // Normal output
        if (completedTasks.isEmpty()) {
            System.out.println("No tasks completed yet."); // Normal output
        } else {
            // Iterate through the list
            for (int i = 0; i < completedTasks.size(); i++) {
                 // Access by index is common with List/ArrayList
                System.out.println((i + 1) + ". " + completedTasks.get(i)); // Normal output
            }
        }
        System.out.println("-----------------------"); // Normal output
    }
}

// File: TaskApp.java
package com.exam.taskmanager; // Using a package is good practice

import java.util.Scanner;
import java.util.InputMismatchException; // Included for completeness, though not strictly used with nextLine()

/**
 * Main application class for the Simple Team Task Manager.
 * Provides a command-line interface using Scanner, switch, and try-catch.
 */
public class TaskApp {

    public static void main(String[] args) {
        // Use try-with-resources to ensure the Scanner is closed properly
        try (Scanner scanner = new Scanner(System.in)) {
            TaskManager manager = new TaskManager();
            boolean running = true;

            System.out.println("--- Simple Team Task Manager ---"); // Normal output

            while (running) {
                printMenu(); // Display menu using System.out

                String inputLine = scanner.nextLine(); // Read the entire line of input
                int choice = -1; // Default value for choice

                try {
                    // Attempt to parse the input string as an integer
                    choice = Integer.parseInt(inputLine);

                    // Use a switch statement to handle the valid integer choice
                    switch (choice) {
                        case 1: // Add New Task
                            System.out.print("Enter task description: "); // Normal output
                            String description = scanner.nextLine();
                            try {
                                // Call TaskManager method, handles validation
                                manager.addTask(description);
                            } catch (IllegalArgumentException e) {
                                // Catch validation errors from TaskManager
                                System.err.println("Error adding task: " + e.getMessage()); // Error output
                            }
                            break;

                        case 2: // Process Next Task
                            Task processedTask = manager.processNextTask();
                            if (processedTask != null) {
                                System.out.println("Processed task: " + processedTask); // Normal output
                            } else {
                                // Handled by checking the null return value from poll()
                                System.err.println("Error: No pending tasks to process."); // Error output
                            }
                            break;

                        case 3: // View Pending Tasks
                            manager.viewPendingTasks(); // Handles its own output
                            break;

                        case 4: // View Completed Tasks
                            manager.viewCompletedTasks(); // Handles its own output
                            break;

                        case 5: // Exit
                            running = false; // Set flag to exit loop
                            System.out.println("Exiting Task Manager. Goodbye!"); // Normal output
                            break;

                        default: // Handles integer choices outside the 1-5 range
                            System.err.println("Invalid choice. Please enter a number between 1 and 5."); // Error output
                            break;
                    }

                } catch (NumberFormatException e) {
                    // Catch exception if inputLine cannot be parsed to an int
                    System.err.println("Invalid input. Please enter a number."); // Error output
                } catch (Exception e) {
                    // Catch any other unexpected exceptions during the switch processing
                    System.err.println("An unexpected error occurred: " + e.getMessage()); // Error output
                    e.printStackTrace(); // Print stack trace for debugging unexpected errors
                }
                System.out.println(); // Add a blank line for better readability in console output
            }

        } catch (Exception e) {
            // Catch exceptions related to Scanner initialization or other critical errors outside the loop
            System.err.println("A critical error occurred during application startup: " + e.getMessage()); // Error output
            e.printStackTrace();
        }
    }

    /**
     * Prints the main menu options to the console using System.out.
     */
    private static void printMenu() {
        System.out.println("Please choose an option:");
        System.out.println("1. Add New Task");
        System.out.println("2. Process Next Task");
        System.out.println("3. View Pending Tasks");
        System.out.println("4. View Completed Tasks");
        System.out.println("5. Exit");
        System.out.print("Enter your choice: "); // Use print to keep cursor on the same line
    }
}
