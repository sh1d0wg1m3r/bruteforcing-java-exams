/*
 * Exam Question #280
 * Generated on: 2025-05-11 22:48:59
 * Generated by: Account 3
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Advanced Appointment Scheduling System
 * 
 * **Objective:** Design and implement a console-based application for managing patient appointments in a small clinic. The system should allow scheduling, cancellation, and viewing of appointments, incorporating a waiting list mechanism for busy doctors.
 * 
 * **Requirements:**
 * 
 * 1.  **Core Functionality:**
 *     *   Allow adding predefined patients and doctors (for simplicity, these can be hardcoded initially).
 *     *   Provide a menu-driven interface for the user (clinic staff).
 *     *   Implement the ability to schedule a new appointment for a patient with a specific doctor at a given time.
 *     *   If a doctor is already booked at the requested time, the system should offer to add the patient to a waiting list for that doctor.
 *     *   Implement the ability to cancel an existing appointment.
 *     *   When an appointment is cancelled, the system should check the waiting list for that doctor. If there are patients waiting, the first patient in the queue should be notified (simulated output) and potentially offered the now-available slot (for simplicity, assume they accept in this exam).
 *     *   Implement the ability to view all appointments for a specific patient or a specific doctor.
 *     *   Allow exiting the application.
 * 
 * 2.  **Required Java Components:** Your solution *must* use and demonstrate the practical application of *all* the following components:
 *     *   `java.util.Queue` (for the waiting list)
 *     *   `java.util.ArrayList` (to store lists of patients, doctors, appointments)
 *     *   `java.util.List` (as the type for variables holding `ArrayList` instances where appropriate)
 *     *   `java.util.Scanner` (for all user input)
 *     *   `switch` statement (for handling menu options)
 *     *   `System.err` (for displaying error messages, e.g., invalid input, scheduling conflicts)
 *     *   `System.out` (for displaying the menu, prompts, successful operations, and appointment details)
 *     *   Class-wide exception handling using `try-catch` blocks (to gracefully handle potential runtime errors, e.g., input mismatches).
 * 
 * 3.  **Best Practices:**
 *     *   Use proper encapsulation (private fields, public methods).
 *     *   Choose meaningful variable, method, and class names.
 *     *   Include comments to explain complex logic.
 *     *   Implement input validation (e.g., checking if patient/doctor IDs exist, handling non-integer input for menu choices).
 *     *   Provide clear output messages.
 * 
 * **Simplified Assumptions:**
 * *   Appointment times can be represented as simple strings (e.g., "10:00 AM", "2:30 PM"). No complex date/time validation is required beyond checking for uniqueness for a given doctor.
 * *   Patient and Doctor IDs can be simple integers.
 * *   For the waiting list, assume the first patient dequeued automatically takes the cancelled slot.
 * 
 * **Expected Output:**
 * The program should present a menu to the user, accept input via `Scanner`, perform the requested actions, and display results or errors using `System.out` or `System.err` as appropriate. Example interactions might look like:
 * 
 * ```
 * --- Appointment System Menu ---
 * 1. Schedule Appointment
 * 2. Cancel Appointment
 * 3. View Appointments
 * 4. Exit
 * Enter choice: 1
 * Enter Patient ID: 101
 * Enter Doctor ID: 201
 * Enter desired time (e.g., 10:00 AM): 10:30 AM
 * Appointment scheduled successfully! Appointment ID: 1
 * 
 * --- Appointment System Menu ---
 * 1. Schedule Appointment
 * 2. Cancel Appointment
 * 3. View Appointments
 * 4. Exit
 * Enter choice: 1
 * Enter Patient ID: 102
 * Enter Doctor ID: 201
 * Enter desired time (e.g., 10:00 AM): 10:30 AM
 * Doctor 201 is already booked at 10:30 AM.
 * Do you want to join the waiting list for Doctor 201? (yes/no): yes
 * Patient 102 added to waiting list for Doctor 201.
 * 
 * --- Appointment System Menu ---
 * ... (user cancels appointment 1)
 * Appointment 1 cancelled.
 * Patient 102 from the waiting list has been offered and accepted the 10:30 AM slot with Doctor 201. New Appointment ID: 2
 * ...
 * ```
 * 
 * **Evaluation:** Your solution will be evaluated on correctness, adherence to all requirements (especially the use of specified Java components), code quality (readability, structure, comments, best practices), and error handling.
 * 
 * **Submission:** Provide the complete Java code for the solution.
 *
 * EXPLANATION:
 * The provided solution implements a basic Appointment Scheduling System demonstrating the required Java concepts.
 * 
 * 1.  **Class Structure:**
 *     *   `Patient`, `Doctor`, and `Appointment` classes encapsulate the data for each entity with private fields and public getter methods, following the principle of encapsulation. `toString()` methods are included for easy printing.
 *     *   `AppointmentSystem` is the main class that orchestrates the system logic. It holds collections of these objects and manages the system's state.
 * 
 * 2.  **Data Storage:**
 *     *   `List<Patient> patientList`, `List<Doctor> doctorList`, and `List<Appointment> appointmentList` are declared using the `List` interface and initialized with `ArrayList`. `ArrayList` provides dynamic arrays suitable for storing and accessing lists of these objects.
 *     *   `Map<Integer, Queue<Integer>> doctorWaitingLists` uses a `Map` to associate each `Doctor` ID with a `Queue`. The `Queue` is implemented using `LinkedList` (`java.util.LinkedList` implements `java.util.Queue`), which is suitable for managing a waiting list where patients are processed in First-In, First-Out (FIFO) order. The queue stores `Patient` IDs.
 * 
 * 3.  **Core Functionality Implementation:**
 *     *   **Initial Data:** The `addInitialData()` method populates the system with some predefined patients and doctors and initializes an empty `LinkedList` (as a `Queue`) for each doctor in the `doctorWaitingLists` map.
 *     *   **Scheduling (`scheduleAppointment`):**
 *         *   Takes `patientId`, `doctorId`, and `time` as input.
 *         *   Validates if the patient and doctor exist using helper methods (`findPatientById`, `findDoctorById`).
 *         *   Checks if the doctor is available at the requested time using `isDoctorAvailable`. This method iterates through the `appointmentList` to see if any *scheduled* appointment exists for that doctor at that exact time.
 *         *   If available, a new `Appointment` is created with status "SCHEDULED" and added to `appointmentList`.
 *         *   If not available, the user is prompted to join the waiting list. If the response is "yes", the `patientId` is added to the corresponding doctor's `Queue` using `offer()`.
 *     *   **Cancellation (`cancelAppointment`):**
 *         *   Takes `appointmentId` as input and finds the appointment.
 *         *   Validates if the appointment exists and is not already cancelled.
 *         *   Sets the appointment's status to "CANCELLED".
 *         *   Retrieves the waiting `Queue` for the doctor of the cancelled appointment.
 *         *   If the queue is not empty (`!waitingList.isEmpty()`), it uses `peek()` to look at the next patient ID. It then dequeues (`poll()`) the patient ID from the queue and creates a *new* scheduled appointment for this waiting patient using the time slot of the cancelled appointment. This demonstrates the FIFO nature of the `Queue`.
 *     *   **Viewing (`viewAppointments`):**
 *         *   Prompts the user to view by patient or doctor.
 *         *   Based on the choice, it prompts for the respective ID.
 *         *   It iterates through the `appointmentList` and prints appointments matching the criteria.
 *         *   When viewing by doctor, it also iterates through the doctor's waiting `Queue` using a for-each loop (which iterates without removing elements) to display the patients currently waiting, demonstrating how to access elements in the queue.
 * 
 * 4.  **Input and Output:**
 *     *   `java.util.Scanner` is used in the `main` method and passed to functional methods (`scheduleAppointment`, `cancelAppointment`, `viewAppointments`) to handle user input.
 *     *   `System.out.println()` is used for displaying the menu, prompts, successful operations, and lists of appointments/patients.
 *     *   `System.err.println()` is used specifically for displaying error messages, such as invalid IDs, scheduling conflicts, or incorrect menu choices.
 *     *   A helper method `readIntInput` is created to handle reading integers robustly, preventing `InputMismatchException` by checking `scanner.hasNextInt()` and consuming invalid input.
 * 
 * 5.  **Flow Control:**
 *     *   A `while` loop in `main` keeps the application running until the user chooses to exit.
 *     *   A `switch` statement is used within the loop to direct execution based on the user's menu choice, fulfilling the requirement to use a `switch`.
 * 
 * 6.  **Exception Handling:**
 *     *   A broad `try-catch (Exception e)` block wraps the main `while` loop in the `main` method. This provides a class-wide mechanism to catch any unexpected runtime exceptions that might occur during the program's execution, printing an error message and the stack trace to `System.err` before potentially terminating, thus preventing the program from crashing abruptly. Specific input validation (like `readIntInput`) handles common `InputMismatchException` cases more gracefully before they reach the main `catch` block.
 *     *   A `finally` block ensures the `Scanner` is closed when the program exits the `try` block (either normally or due to an exception).
 * 
 * 7.  **Best Practices:**
 *     *   Private fields and public methods (`getters`) enforce encapsulation.
 *     *   Variable names (`patientList`, `doctorWaitingLists`, `nextAppointmentId`) and method names (`scheduleAppointment`, `findPatientById`, `isDoctorAvailable`) are descriptive.
 *     *   Comments are included to explain the purpose of classes, methods, and specific logic sections (like the waiting list handling).
 *     *   Input validation is performed (e.g., checking if patient/doctor IDs exist, handling non-integer input).
 * 
 * This solution effectively integrates all the required Java components into a functional system, demonstrating understanding of data structures (`List`, `Queue`, `Map`), object-oriented principles (encapsulation), user interaction (`Scanner`, `System.out`, `System.err`), flow control (`switch`, loops), and error handling (`try-catch`).
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.InputMismatchException;
import java.util.HashMap;
import java.util.Map;

// Simple class to represent a Patient
class Patient {
    private int id;
    private String name;

    public Patient(int id, String name) {
        this.id = id;
        this.name = name;
    }

    public int getId() {
        return id;
    }

    public String getName() {
        return name;
    }

    @Override
    public String toString() {
        return "Patient [ID=" + id + ", Name=" + name + "]";
    }
}

// Simple class to represent a Doctor
class Doctor {
    private int id;
    private String name;
    private String specialty;

    public Doctor(int id, String name, String specialty) {
        this.id = id;
        this.name = name;
        this.specialty = specialty;
    }

    public int getId() {
        return id;
    }

    public String getName() {
        return name;
    }

    public String getSpecialty() {
        return specialty;
    }

    @Override
    public String toString() {
        return "Doctor [ID=" + id + ", Name=" + name + ", Specialty=" + specialty + "]";
    }
}

// Class to represent an Appointment
class Appointment {
    private int id;
    private int patientId;
    private int doctorId;
    private String time; // Simplified time representation
    private String status; // e.g., SCHEDULED, CANCELLED, WAITING (though WAITING patients are in queue)

    public Appointment(int id, int patientId, int doctorId, String time, String status) {
        this.id = id;
        this.patientId = patientId;
        this.doctorId = doctorId;
        this.time = time;
        this.status = status;
    }

    public int getId() {
        return id;
    }

    public int getPatientId() {
        return patientId;
    }

    public int getDoctorId() {
        return doctorId;
    }

    public String getTime() {
        return time;
    }

    public String getStatus() {
        return status;
    }

    public void setStatus(String status) {
        this.status = status;
    }

    @Override
    public String toString() {
        return "Appointment [ID=" + id + ", Patient ID=" + patientId + ", Doctor ID=" + doctorId + ", Time=" + time + ", Status=" + status + "]";
    }
}

// Main system class managing appointments, patients, doctors, and waiting lists
public class AppointmentSystem {

    private List<Patient> patientList;
    private List<Doctor> doctorList;
    private List<Appointment> appointmentList;
    // Map to hold waiting lists for each doctor (Doctor ID -> Queue of Patient IDs)
    private Map<Integer, Queue<Integer>> doctorWaitingLists;
    private int nextAppointmentId; // Counter for unique appointment IDs

    public AppointmentSystem() {
        // Use ArrayList for storing lists of objects
        patientList = new ArrayList<>();
        doctorList = new ArrayList<>();
        appointmentList = new ArrayList<>();
        // Use HashMap to map doctor IDs to their waiting queues
        // Use LinkedList as the implementation for Queue
        doctorWaitingLists = new HashMap<>();
        nextAppointmentId = 1; // Start appointment IDs from 1

        // Add some initial data for demonstration
        addInitialData();
    }

    // Helper method to add initial patients and doctors
    private void addInitialData() {
        patientList.add(new Patient(101, "Alice Smith"));
        patientList.add(new Patient(102, "Bob Johnson"));
        patientList.add(new Patient(103, "Charlie Brown"));

        doctorList.add(new Doctor(201, "Dr. Anya Sharma", "Cardiology"));
        doctorList.add(new Doctor(202, "Dr. Ben Carter", "Pediatrics"));
        doctorList.add(new Doctor(203, "Dr. Claire Davies", "Neurology"));

        // Initialize waiting lists for each doctor
        for (Doctor doctor : doctorList) {
            doctorWaitingLists.put(doctor.getId(), new LinkedList<>()); // LinkedList implements Queue
        }

        System.out.println("Initial data loaded: 3 Patients, 3 Doctors.");
    }

    // Method to find a patient by ID
    private Patient findPatientById(int patientId) {
        for (Patient patient : patientList) {
            if (patient.getId() == patientId) {
                return patient;
            }
        }
        return null; // Patient not found
    }

    // Method to find a doctor by ID
    private Doctor findDoctorById(int doctorId) {
        for (Doctor doctor : doctorList) {
            if (doctor.getId() == doctorId) {
                return doctor;
            }
        }
        return null; // Doctor not found
    }

    // Method to find an appointment by ID
    private Appointment findAppointmentById(int appointmentId) {
        for (Appointment appointment : appointmentList) {
            if (appointment.getId() == appointmentId) {
                return appointment;
            }
        }
        return null; // Appointment not found
    }

    // Method to check if a doctor is available at a specific time
    private boolean isDoctorAvailable(int doctorId, String time) {
        for (Appointment appointment : appointmentList) {
            // Check for scheduled appointments for the same doctor at the same time
            if (appointment.getDoctorId() == doctorId &&
                appointment.getTime().equalsIgnoreCase(time) &&
                appointment.getStatus().equals("SCHEDULED")) {
                return false; // Doctor is booked
            }
        }
        return true; // Doctor is available
    }

    // --- Core Functionality Methods ---

    public void scheduleAppointment(Scanner scanner) {
        System.out.println("\n--- Schedule New Appointment ---");
        System.out.print("Enter Patient ID: ");
        int patientId = readIntInput(scanner);
        if (patientId == -1) return; // Error reading input

        Patient patient = findPatientById(patientId);
        if (patient == null) {
            System.err.println("Error: Patient with ID " + patientId + " not found.");
            return;
        }

        System.out.print("Enter Doctor ID: ");
        int doctorId = readIntInput(scanner);
        if (doctorId == -1) return; // Error reading input

        Doctor doctor = findDoctorById(doctorId);
        if (doctor == null) {
            System.err.println("Error: Doctor with ID " + doctorId + " not found.");
            return;
        }

        System.out.print("Enter desired time (e.g., 10:00 AM): ");
        String time = scanner.nextLine().trim();
        if (time.isEmpty()) {
             System.err.println("Error: Time cannot be empty.");
             return;
        }


        if (isDoctorAvailable(doctorId, time)) {
            // Doctor is available, schedule the appointment
            Appointment newAppointment = new Appointment(nextAppointmentId++, patientId, doctorId, time, "SCHEDULED");
            appointmentList.add(newAppointment);
            System.out.println("Appointment scheduled successfully! " + newAppointment);
        } else {
            // Doctor is not available, offer waiting list
            System.out.println("Doctor " + doctor.getName() + " (ID: " + doctorId + ") is already booked at " + time + ".");
            System.out.print("Do you want to join the waiting list for " + doctor.getName() + "? (yes/no): ");
            String response = scanner.nextLine().trim().toLowerCase();

            if (response.equals("yes")) {
                Queue<Integer> waitingList = doctorWaitingLists.get(doctorId);
                if (waitingList != null) {
                    waitingList.offer(patientId); // Add patient ID to the queue
                    System.out.println("Patient " + patient.getName() + " (ID: " + patientId + ") added to waiting list for Doctor " + doctor.getName() + ".");
                } else {
                     // Should not happen if doctorWaitingLists is properly initialized
                     System.err.println("Internal Error: Waiting list not found for doctor ID " + doctorId);
                }
            } else {
                System.out.println("Appointment not scheduled.");
            }
        }
    }

    public void cancelAppointment(Scanner scanner) {
        System.out.println("\n--- Cancel Appointment ---");
        System.out.print("Enter Appointment ID to cancel: ");
        int appointmentId = readIntInput(scanner);
        if (appointmentId == -1) return; // Error reading input

        Appointment appointmentToCancel = findAppointmentById(appointmentId);

        if (appointmentToCancel == null) {
            System.err.println("Error: Appointment with ID " + appointmentId + " not found.");
            return;
        }

        if (appointmentToCancel.getStatus().equals("CANCELLED")) {
            System.out.println("Appointment with ID " + appointmentId + " is already cancelled.");
            return;
        }

        // Cancel the appointment
        appointmentToCancel.setStatus("CANCELLED");
        System.out.println("Appointment " + appointmentId + " cancelled successfully.");

        // Check the waiting list for the doctor whose appointment was cancelled
        int doctorId = appointmentToCancel.getDoctorId();
        Queue<Integer> waitingList = doctorWaitingLists.get(doctorId);

        if (waitingList != null && !waitingList.isEmpty()) {
            // A patient is waiting, offer them the slot
            Integer nextPatientId = waitingList.peek(); // Peek to see who is next without removing

            Patient nextPatient = findPatientById(nextPatientId);
            Doctor doctor = findDoctorById(doctorId);

            if (nextPatient != null && doctor != null) {
                System.out.println("Patient " + nextPatient.getName() + " (ID: " + nextPatientId + ") from the waiting list is next for Doctor " + doctor.getName() + ".");
                // In a real system, you'd contact the patient. For this exam, assume acceptance.
                // Remove from waiting list and create a new scheduled appointment for them
                waitingList.poll(); // Remove from the queue

                // Create a new appointment for the waiting patient for the cancelled slot's time
                Appointment newAppointmentForWaitingPatient = new Appointment(
                    nextAppointmentId++,
                    nextPatientId,
                    doctorId,
                    appointmentToCancel.getTime(), // Assign the time of the cancelled slot
                    "SCHEDULED"
                );
                appointmentList.add(newAppointmentForWaitingPatient);
                System.out.println("Patient " + nextPatient.getName() + " accepted the slot. New Appointment scheduled: " + newAppointmentForWaitingPatient);

            } else {
                 // Should not happen if IDs are valid, but good practice to handle
                 System.err.println("Internal Error: Could not find waiting patient or doctor details.");
            }
        } else {
            System.out.println("No patients currently waiting for Doctor " + doctorId + ".");
        }
    }

    public void viewAppointments(Scanner scanner) {
        System.out.println("\n--- View Appointments ---");
        System.out.print("View by (P)atient ID or (D)octor ID? (P/D): ");
        String type = scanner.nextLine().trim().toUpperCase();

        if ("P".equals(type)) {
            System.out.print("Enter Patient ID: ");
            int patientId = readIntInput(scanner);
            if (patientId == -1) return; // Error reading input

            Patient patient = findPatientById(patientId);
            if (patient == null) {
                System.err.println("Error: Patient with ID " + patientId + " not found.");
                return;
            }

            System.out.println("\nAppointments for Patient: " + patient.getName());
            boolean found = false;
            for (Appointment appt : appointmentList) {
                if (appt.getPatientId() == patientId) {
                    System.out.println(appt);
                    found = true;
                }
            }
            if (!found) {
                System.out.println("No appointments found for this patient.");
            }

        } else if ("D".equals(type)) {
            System.out.print("Enter Doctor ID: ");
            int doctorId = readIntInput(scanner);
             if (doctorId == -1) return; // Error reading input

            Doctor doctor = findDoctorById(doctorId);
            if (doctor == null) {
                System.err.println("Error: Doctor with ID " + doctorId + " not found.");
                return;
            }

            System.out.println("\nAppointments for Doctor: " + doctor.getName() + " (" + doctor.getSpecialty() + ")");
            boolean found = false;
            for (Appointment appt : appointmentList) {
                if (appt.getDoctorId() == doctorId) {
                    System.out.println(appt);
                    found = true;
                }
            }
            if (!found) {
                System.out.println("No appointments found for this doctor.");
            }

            // Optionally, show waiting list for the doctor
            Queue<Integer> waitingList = doctorWaitingLists.get(doctorId);
             if (waitingList != null && !waitingList.isEmpty()) {
                 System.out.println("--- Waiting List for Dr. " + doctor.getName() + " ---");
                 // Iterate through the queue without removing elements
                 int position = 1;
                 for(Integer pId : waitingList) {
                     Patient waitingPatient = findPatientById(pId);
                     if(waitingPatient != null) {
                         System.out.println("  " + position + ". " + waitingPatient.getName() + " (ID: " + waitingPatient.getId() + ")");
                         position++;
                     }
                 }
                 System.out.println("--------------------------------------");
             }


        } else {
            System.err.println("Invalid view type. Please enter 'P' or 'D'.");
        }
    }

    // Helper method for reading integer input with validation
    private int readIntInput(Scanner scanner) {
        while (!scanner.hasNextInt()) {
            System.err.println("Invalid input. Please enter a number.");
            scanner.next(); // Consume the invalid input
            System.out.print("Enter valid ID: "); // Re-prompt
        }
        int input = scanner.nextInt();
        scanner.nextLine(); // Consume the newline character left by nextInt()
        return input;
    }


    // Main method to run the system
    public static void main(String[] args) {
        AppointmentSystem system = new AppointmentSystem();
        Scanner scanner = new Scanner(System.in);
        boolean running = true;

        // Class-wide exception handling using try-catch
        try {
            while (running) {
                System.out.println("\n--- Appointment System Menu ---");
                System.out.println("1. Schedule Appointment");
                System.out.println("2. Cancel Appointment");
                System.out.println("3. View Appointments");
                System.out.println("4. Exit");
                System.out.print("Enter choice: ");

                int choice = system.readIntInput(scanner); // Use helper for int input

                // Use switch statement for menu navigation
                switch (choice) {
                    case 1:
                        system.scheduleAppointment(scanner);
                        break;
                    case 2:
                        system.cancelAppointment(scanner);
                        break;
                    case 3:
                        system.viewAppointments(scanner);
                        break;
                    case 4:
                        System.out.println("Exiting Appointment System. Goodbye!");
                        running = false;
                        break;
                    default:
                        System.err.println("Invalid choice. Please enter a number between 1 and 4.");
                }
            }
        } catch (Exception e) {
            // Catch any unexpected exceptions during runtime
            System.err.println("An unexpected error occurred: " + e.getMessage());
            e.printStackTrace(System.err); // Print stack trace to standard error
        } finally {
            // Ensure scanner is closed
            scanner.close();
            System.out.println("Scanner closed.");
        }
    }
}
