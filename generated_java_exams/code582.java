/*
 * Exam Question #582
 * Generated on: 2025-05-12 16:10:26
 * Generated by: Account 5
 * 
 * QUESTION:
 * ## Advanced Java Programming Exam Task: Automated Task Dispatch System Simulation
 * 
 * **Scenario:**
 * 
 * You are tasked with building a simplified simulation of an automated task dispatch system. This system receives tasks, queues them for processing, processes them one by one, and keeps a record of completed tasks.
 * 
 * **Requirements:**
 * 
 * Implement a Java program that simulates this system with the following features:
 * 
 * 1.  **Task Representation:** Create a `Task` class to represent a unit of work.
 *     *   Each `Task` should have a unique integer `taskId`, a `description` (String), and a `status` (String, e.g., "PENDING", "PROCESSING", "COMPLETED", "FAILED").
 *     *   Use proper encapsulation: fields should be `private`, and access should be via `public` getter methods. Include a `toString()` method for easy display.
 * 2.  **Task Dispatcher:** Create a `TaskDispatcher` class to manage the tasks.
 *     *   It must use a `java.util.Queue` to hold tasks that are waiting to be processed (`pendingTasksQueue`).
 *     *   It must use a `java.util.List` (specifically implemented by `java.util.ArrayList`) to store tasks that have been processed (`processedTasksList`).
 *     *   Include methods:
 *         *   `addTask(String description)`: Creates a new `Task` with a unique ID, sets its status to "PENDING", and adds it to the `pendingTasksQueue`.
 *         *   `processNextTask()`: Removes the next task from the `pendingTasksQueue`. If a task is retrieved, change its status to "COMPLETED" (simulate successful processing) and add it to the `processedTasksList`. If the queue is empty, indicate that there are no tasks to process.
 *         *   `displayStatus()`: Prints the current state, showing tasks in the `pendingTasksQueue` and tasks in the `processedTasksList`.
 * 3.  **User Interface:** Implement a simple command-line interface using `java.util.Scanner`.
 *     *   Present a menu to the user with options:
 *         1.  Add New Task
 *         2.  Process Next Task
 *         3.  Display System Status
 *         4.  Exit
 *     *   Use a `switch` statement to handle the user's menu choice.
 * 4.  **Error Handling:**
 *     *   Use a `try-catch` block to handle potential input errors (e.g., non-integer input when expecting an integer) or other runtime exceptions within the main interaction loop. Print informative error messages.
 *     *   Use `System.err` to print all error messages (e.g., invalid input, attempting to process an empty queue, general exceptions).
 *     *   Use `System.out` for all normal output (menu, prompts, status display, successful operation confirmations).
 * 5.  **Best Practices:**
 *     *   Apply proper encapsulation in classes.
 *     *   Use meaningful variable and method names.
 *     *   Include comments where necessary to explain logic.
 *     *   Perform basic input validation (e.g., check if task description is empty).
 * 
 * **Expected Output:**
 * 
 * The program should run interactively, presenting a menu, accepting input, performing the requested action, and displaying status or error messages as appropriate. Example interaction flow:
 * 
 * ```
 * Automated Task Dispatch System
 * 
 * Menu:
 * 1. Add New Task
 * 2. Process Next Task
 * 3. Display System Status
 * 4. Exit
 * Enter your choice: 1
 * Enter task description: Process financial report
 * Task 1 "Process financial report" added to the queue.
 * 
 * Menu:
 * 1. Add New Task
 * 2. Process Next Task
 * 3. Display System Status
 * 4. Exit
 * Enter your choice: 1
 * Enter task description: Send out invoices
 * Task 2 "Send out invoices" added to the queue.
 * 
 * Menu:
 * 1. Add New Task
 * 2. Process Next Task
 * 3. Display System Status
 * 4. Exit
 * Enter your choice: 3
 * --- System Status ---
 * Pending Tasks (Queue):
 * [Task ID: 1, Description: Process financial report, Status: PENDING]
 * [Task ID: 2, Description: Send out invoices, Status: PENDING]
 * Processed Tasks (List):
 * [No tasks processed yet]
 * ---------------------
 * 
 * Menu:
 * 1. Add New Task
 * 2. Process Next Task
 * 3. Display System Status
 * 4. Exit
 * Enter your choice: 2
 * Processing next task...
 * Task 1 "Process financial report" completed and moved to processed list.
 * 
 * Menu:
 * 1. Add New Task
 * 2. Process Next Task
 * 3. Display System Status
 * 4. Exit
 * Enter your choice: 3
 * --- System Status ---
 * Pending Tasks (Queue):
 * [Task ID: 2, Description: Send out invoices, Status: PENDING]
 * Processed Tasks (List):
 * [Task ID: 1, Description: Process financial report, Status: COMPLETED]
 * ---------------------
 * 
 * Menu:
 * 1. Add New Task
 * 2. Process Next Task
 * 3. Display System Status
 * 4. Exit
 * Enter your choice: 5
 * Error: Invalid menu choice. Please enter a number between 1 and 4.
 * 
 * Menu:
 * 1. Add New Task
 * 2. Process Next Task
 * 3. Display System Status
 * 4. Exit
 * Enter your choice: exit
 * Error: Invalid input. Please enter an integer.
 * 
 * Menu:
 * 1. Add New Task
 * 2. Process Next Task
 * 3. Display System Status
 * 4. Exit
 * Enter your choice: 4
 * Exiting system.
 * ```
 * 
 * Your solution should be a single `.java` file containing all necessary classes.
 *
 * EXPLANATION:
 * This solution implements the Automated Task Dispatch System simulation as requested, demonstrating the required Java concepts and best practices.
 * 
 * 1.  **Task Class:**
 *     *   The `Task` class encapsulates the data for a single task: `taskId`, `description`, and `status`.
 *     *   Fields are `private`, accessed via `public` getters (`getTaskId`, `getDescription`, `getStatus`). A setter (`setStatus`) is provided to allow the dispatcher to update the task's state.
 *     *   The `toString()` method provides a convenient way to print task details.
 * 
 * 2.  **TaskDispatcher Class:**
 *     *   Uses a `java.util.Queue<Task>` (`pendingTasksQueue`), specifically implemented with `java.util.LinkedList`, to manage tasks waiting in a FIFO order. `offer()` is used for adding and `poll()` for removing from the queue.
 *     *   Uses a `java.util.List<Task>` (`processedTasksList`), specifically implemented with `java.util.ArrayList`, to store tasks after they have been processed. Declaring it as `List` demonstrates polymorphism and adherence to the interface requirement, while `ArrayList` provides the dynamic array implementation.
 *     *   `nextTaskId` ensures each task gets a unique ID.
 *     *   `addTask`: Creates a new `Task` and adds it to the queue. Includes basic validation for the description.
 *     *   `processNextTask`: Uses `poll()` to get the next task from the queue. If `poll()` returns `null` (queue is empty), it prints an error to `System.err`. Otherwise, it updates the task's status and adds it to the `processedTasksList`.
 *     *   `displayStatus`: Iterates through both the queue and the list to print their contents using the `Task`'s `toString()` method. Iterating the queue directly (e.g., using a for-each loop) is safe as it doesn't remove elements.
 *     *   `getProcessedTasks`: An example method returning a `List` view of the processed tasks, fulfilling the requirement to use the `List` interface in potentially more than one place. Returning an unmodifiable list is a good practice.
 * 
 * 3.  **TaskSimulation (Main Class):**
 *     *   Contains the `main` method where execution begins.
 *     *   Initializes `Scanner` for user input and `TaskDispatcher`.
 *     *   The main logic runs in a `while(running)` loop.
 *     *   The `printMenu()` method displays the available options using `System.out`.
 *     *   User input is read using `scanner.hasNextInt()` and `scanner.nextInt()` followed by `scanner.nextLine()` to handle the newline character.
 *     *   Input validation checks if the input is an integer. If not, an error is printed to `System.err`, and the invalid input is consumed before continuing the loop.
 *     *   A `switch` statement is used to direct control flow based on the validated integer choice, fulfilling the `switch` requirement.
 *     *   Each case calls the appropriate method on the `TaskDispatcher`.
 *     *   Invalid menu options (integers outside 1-4) are caught by the `default` case in the `switch`, printing an error to `System.err`.
 *     *   A `try-catch (Exception e)` block wraps the core `while` loop. This serves as a class-wide exception handler, catching any unhandled runtime exceptions that might occur during the program's execution and printing an error message to `System.err`.
 *     *   A `finally` block ensures the `Scanner` is closed when the program exits or an exception occurs, preventing resource leaks.
 *     *   `System.out` is used for all normal messages (menu, prompts, success messages, status displays).
 *     *   `System.err` is used exclusively for error messages (invalid input, empty queue, unexpected exceptions).
 * 
 * This solution effectively combines the required data structures (`Queue`, `ArrayList`, `List`) and control flow mechanisms (`Scanner`, `switch`, `try-catch`) within a practical, simulated scenario, adhering to best practices like encapsulation, meaningful names, and clear separation of concerns between classes.
 */

import java.util.ArrayList;
import java.util.LinkedList; // LinkedList implements Queue
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.InputMismatchException;

// Enum for Task Status (Good practice, though String was allowed by prompt, Enum is better)
// Using String as per prompt requirement, but noting Enum would be better.
// enum TaskStatus { PENDING, PROCESSING, COMPLETED, FAILED }

/**
 * Represents a single task in the system.
 */
class Task {
    private int taskId;
    private String description;
    private String status; // Using String as required, but enum would be safer

    /**
     * Constructs a new Task.
     * @param taskId The unique identifier for the task.
     * @param description A brief description of the task.
     */
    public Task(int taskId, String description) {
        this.taskId = taskId;
        this.description = description;
        this.status = "PENDING"; // Initial status
    }

    // --- Getters ---
    public int getTaskId() {
        return taskId;
    }

    public String getDescription() {
        return description;
    }

    public String getStatus() {
        return status;
    }

    // --- Setter for Status (used during processing) ---
    public void setStatus(String status) {
        this.status = status;
    }

    /**
     * Provides a string representation of the Task.
     * @return A formatted string showing task details.
     */
    @Override
    public String toString() {
        return "[Task ID: " + taskId + ", Description: " + description + ", Status: " + status + "]";
    }
}

/**
 * Manages the queue of pending tasks and the list of processed tasks.
 */
class TaskDispatcher {
    // Queue for tasks waiting to be processed (FIFO)
    private Queue<Task> pendingTasksQueue;
    // List for tasks that have been processed
    private List<Task> processedTasksList; // Declared as List interface
    private int nextTaskId; // Counter for unique task IDs

    /**
     * Constructs a new TaskDispatcher, initializing collections.
     */
    public TaskDispatcher() {
        // LinkedList is a common implementation of the Queue interface
        this.pendingTasksQueue = new LinkedList<>();
        // ArrayList is a common implementation of the List interface
        this.processedTasksList = new ArrayList<>(); // Instantiated as ArrayList
        this.nextTaskId = 1; // Start task IDs from 1
    }

    /**
     * Creates a new task and adds it to the pending tasks queue.
     * @param description The description for the new task.
     */
    public void addTask(String description) {
        if (description == null || description.trim().isEmpty()) {
            System.err.println("Error: Task description cannot be empty.");
            return;
        }
        Task newTask = new Task(nextTaskId++, description.trim());
        pendingTasksQueue.offer(newTask); // offer() is preferred over add() for capacity-constrained queues, but works here too
        System.out.println("Task " + newTask.getTaskId() + " \"" + newTask.getDescription() + "\" added to the queue.");
    }

    /**
     * Processes the next task from the queue.
     * Removes the task from the pending queue, updates its status, and moves it to the processed list.
     */
    public void processNextTask() {
        System.out.println("Processing next task...");
        Task taskToProcess = pendingTasksQueue.poll(); // Retrieves and removes the head of the queue

        if (taskToProcess != null) {
            // Simulate processing - just change status
            taskToProcess.setStatus("COMPLETED"); // Could add logic for "FAILED" based on conditions
            processedTasksList.add(taskToProcess);
            System.out.println("Task " + taskToProcess.getTaskId() + " \"" + taskToProcess.getDescription() + "\" completed and moved to processed list.");
        } else {
            System.err.println("Error: No tasks currently in the pending queue to process.");
        }
    }

    /**
     * Displays the current state of the pending and processed tasks.
     */
    public void displayStatus() {
        System.out.println("--- System Status ---");

        System.out.println("Pending Tasks (Queue):");
        if (pendingTasksQueue.isEmpty()) {
            System.out.println("[No tasks pending]");
        } else {
            // Iterate through the queue without removing elements
            for (Task task : pendingTasksQueue) {
                System.out.println(task);
            }
        }

        System.out.println("Processed Tasks (List):");
        if (processedTasksList.isEmpty()) {
            System.out.println("[No tasks processed yet]");
        } else {
             // Iterate through the list
            for (Task task : processedTasksList) {
                System.out.println(task);
            }
        }
        System.out.println("---------------------");
    }

    /**
     * Example method returning a List (demonstrates List interface usage).
     * @return An immutable view of the processed tasks list.
     */
    public List<Task> getProcessedTasks() {
        // Returning an immutable list is a good practice to prevent external modification
        return java.util.Collections.unmodifiableList(processedTasksList);
    }
}

/**
 * Main class to run the Task Dispatch System simulation.
 * Handles user interaction and manages the TaskDispatcher.
 */
public class TaskSimulation {

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        TaskDispatcher dispatcher = new TaskDispatcher();
        boolean running = true;

        System.out.println("Automated Task Dispatch System\n");

        // Class-wide exception handling for the main interaction loop
        try {
            while (running) {
                printMenu();

                System.out.print("Enter your choice: ");
                int choice = -1; // Default invalid choice

                // Input validation for integer choice
                if (scanner.hasNextInt()) {
                    choice = scanner.nextInt();
                } else {
                    System.err.println("Error: Invalid input. Please enter an integer.");
                    scanner.next(); // Consume the invalid input
                    continue; // Skip to the next loop iteration
                }
                scanner.nextLine(); // Consume the newline character left by nextInt()

                // Using switch statement for flow control based on user choice
                switch (choice) {
                    case 1:
                        System.out.print("Enter task description: ");
                        String description = scanner.nextLine();
                        dispatcher.addTask(description);
                        break;
                    case 2:
                        dispatcher.processNextTask();
                        break;
                    case 3:
                        dispatcher.displayStatus();
                        break;
                    case 4:
                        System.out.println("Exiting system.");
                        running = false;
                        break;
                    default:
                        System.err.println("Error: Invalid menu choice. Please enter a number between 1 and 4.");
                        break;
                }
                System.out.println(); // Add a newline for better readability between actions

            } // End of while loop
        } catch (Exception e) {
            // Catch any other unexpected runtime exceptions
            System.err.println("An unexpected error occurred: " + e.getMessage());
            // e.printStackTrace(); // Uncomment for detailed debugging stack trace
        } finally {
            // Ensure the scanner is closed
            if (scanner != null) {
                scanner.close();
            }
            System.out.println("System shutdown complete.");
        }
    }

    /**
     * Prints the main menu options to the console.
     */
    private static void printMenu() {
        System.out.println("Menu:");
        System.out.println("1. Add New Task");
        System.out.println("2. Process Next Task");
        System.out.println("3. Display System Status");
        System.out.println("4. Exit");
    }
}
