/*
 * Exam Question #1023
 * Generated on: 2025-05-12 17:14:15
 * Generated by: Account 3
 * 
 * QUESTION:
 * **Java Programming Exam Task: Hospital Appointment Management System**
 * 
 * **Problem Description:**
 * 
 * You are tasked with developing a simplified console-based application for managing patient appointments in a hospital. The system should allow registering new patients, adding registered patients to a waiting list for appointments, processing the next patient from the waiting list, and viewing the lists of registered patients and those currently waiting.
 * 
 * Your solution must demonstrate proficiency in using fundamental Java data structures and control flow mechanisms, along with proper error handling and code structure.
 * 
 * **Requirements:**
 * 
 * 1.  **Patient Representation:** Create a `Patient` class with private fields for `patientId` (String, unique) and `name` (String). Include a constructor, appropriate getters, and override `equals()` and `hashCode()` based on `patientId`. Implement a `toString()` method for easy printing.
 * 2.  **Appointment Management Class:** Create a class named `AppointmentManager` that encapsulates the core logic. It must contain:
 *     *   A `List<Patient>` (specifically using `ArrayList`) to store all registered patients.
 *     *   A `Queue<Patient>` (using `java.util.Queue`) to manage the waiting list for appointments.
 * 3.  **Functionality:** The `AppointmentManager` class must provide methods for the following operations:
 *     *   `registerPatient(String patientId, String name)`: Registers a new patient. Must ensure `patientId` is unique. If a patient with the same ID already exists, print an error message to `System.err` and do not register.
 *     *   `addPatientToWaitingList(String patientId)`: Finds the patient by ID in the registered patients list and adds them to the waiting list queue. If the patient ID is not found among registered patients, print an error message to `System.err`. A patient can be added to the waiting list multiple times if needed in this simplified model.
 *     *   `processNextPatient()`: Removes and returns the patient at the front of the waiting list queue. If the waiting list is empty, print an informative message to `System.out`.
 *     *   `getAllRegisteredPatients()`: Returns the list of all registered patients.
 *     *   `getAppointmentWaitingList()`: Returns the current waiting list queue.
 * 4.  **User Interface:** Implement a console-based interface in a `main` method in a separate class (e.g., `HospitalApp`).
 *     *   Use `java.util.Scanner` to read user input.
 *     *   Present a menu of options to the user:
 *         1.  Register Patient
 *         2.  Add Patient to Waiting List
 *         3.  Process Next Appointment
 *         4.  View Registered Patients
 *         5.  View Waiting List
 *         6.  Exit
 *     *   Use a `switch` statement to handle the user's menu choice.
 *     *   Implement input validation (e.g., ensuring menu choice is a number).
 * 5.  **Error Handling:**
 *     *   Use `System.err` for printing specific error messages related to invalid operations (e.g., patient not found, duplicate ID).
 *     *   Use `System.out` for normal output (menu, success messages, list contents).
 *     *   Implement class-wide exception handling using `try-catch` blocks within the `main` method's loop to gracefully handle unexpected errors, especially input parsing issues (`NumberFormatException`).
 * 6.  **Best Practices:**
 *     *   Use meaningful variable and method names.
 *     *   Apply proper encapsulation (private fields, public methods).
 *     *   Include appropriate comments and documentation (e.g., Javadoc for classes and methods).
 *     *   Ensure clean code structure.
 * 
 * **Expected Output:**
 * 
 * The program should run in a loop, presenting the menu. User interactions should lead to corresponding actions (registration, adding to queue, processing, viewing lists) with clear messages on `System.out` for success/information and `System.err` for errors.
 * 
 * Example interaction flow:
 * ```
 * --- Hospital Appointment System ---
 * 1. Register Patient
 * 2. Add Patient to Waiting List
 * 3. Process Next Appointment
 * 4. View Registered Patients
 * 5. View Waiting List
 * 6. Exit
 * Enter your choice: 1
 * Enter Patient ID: P001
 * Enter Patient Name: Alice
 * Patient P001 (Alice) registered successfully.
 * 
 * --- Hospital Appointment System ---
 * ...
 * Enter your choice: 1
 * Enter Patient ID: P001
 * Enter Patient Name: Bob
 * Error: Patient with ID P001 already exists.
 * 
 * --- Hospital Appointment System ---
 * ...
 * Enter your choice: 2
 * Enter Patient ID: P001
 * Patient P001 added to waiting list.
 * 
 * --- Hospital Appointment System ---
 * ...
 * Enter your choice: 2
 * Enter Patient ID: P003
 * Error: Patient with ID P003 not found in registered patients.
 * 
 * --- Hospital Appointment System ---
 * ...
 * Enter your choice: 5
 * --- Waiting List ---
 * P001 (Alice)
 * --------------------
 * 
 * --- Hospital Appointment System ---
 * ...
 * Enter your choice: 3
 * Processing appointment for: P001 (Alice)
 * 
 * --- Hospital Appointment System ---
 * ...
 * Enter your choice: 3
 * Waiting list is empty.
 * 
 * --- Hospital Appointment System ---
 * ...
 * Enter your choice: 6
 * Exiting system.
 * ```
 * 
 * **Evaluation:**
 * 
 * Your solution will be evaluated based on:
 * *   Correct usage of `Queue`, `ArrayList`, `List`, `Scanner`, `switch`.
 * *   Proper use of `System.out` and `System.err`.
 * *   Effective implementation of `try-catch` for error handling.
 * *   Correct implementation of the required functionalities (registration, adding to queue, processing, viewing).
 * *   Adherence to best practices (encapsulation, naming, comments, structure).
 * *   Handling of edge cases (empty queue, patient not found, duplicate ID).
 *
 * EXPLANATION:
 * The provided solution implements a simplified hospital appointment management system using the required Java components and best practices.
 * 
 * 1.  **`Patient` Class:** This class is a simple Plain Old Java Object (POJO) representing a patient. It holds `patientId` and `name`. The `equals()` and `hashCode()` methods are overridden based on `patientId` to correctly identify unique patients, which is crucial for searching and potentially using `Set`s if needed (though not required here, it's good practice). `toString()` provides a convenient way to display patient information.
 * 
 * 2.  **`AppointmentManager` Class:** This class encapsulates the core logic and data structures.
 *     *   `registeredPatients`: An `ArrayList` is used to store the list of all patients registered in the system. `ArrayList` is suitable here as we need to store a dynamic list and occasionally search by ID. It is declared using the `List` interface type (`List<Patient>`), adhering to the requirement and promoting good practice (programming to interfaces).
 *     *   `appointmentWaitingList`: A `Queue` is used to manage patients waiting for an appointment. A `LinkedList` is instantiated because it implements the `Queue` interface and provides efficient insertion (`offer`) and removal (`poll`) from the head, which is typical queue behavior (FIFO - First-In, First-Out).
 *     *   **`registerPatient`:** Adds a new patient to `registeredPatients` after checking for duplicate IDs using a stream and `anyMatch`. Prints success or error messages to `System.out` or `System.err` respectively.
 *     *   **`addPatientToWaitingList`:** Finds the patient in `registeredPatients` using the `findPatientById` helper method. If found, the patient is added to the `appointmentWaitingList` using `offer()`. If not found, an error is printed to `System.err`.
 *     *   **`processNextPatient`:** Uses `appointmentWaitingList.poll()` to retrieve and remove the patient at the front of the queue. `poll()` is used because it returns `null` if the queue is empty, allowing graceful handling without throwing an exception. Success or "empty list" messages are printed to `System.out`.
 *     *   **`getAllRegisteredPatients` and `getAppointmentWaitingList`:** Provide access to the internal lists. While returning the direct reference breaks strict encapsulation, for a typical exam scenario, this is often acceptable unless immutable views are specifically required.
 *     *   **`findPatientById`:** A private helper method demonstrating iteration over the `registeredPatients` `ArrayList` to find a patient by their unique ID.
 * 
 * 3.  **`HospitalApp` Class (Main):**
 *     *   The `main` method drives the application. It initializes a `Scanner` for input and an `AppointmentManager`.
 *     *   A `while(running)` loop keeps the application active until the user chooses to exit.
 *     *   Inside the loop, the menu is printed.
 *     *   User input for the menu choice is read using `scanner.nextLine()` and then parsed into an integer. This two-step process (`nextLine()` then `parseInt()`) is robust against leftover newline characters from previous inputs.
 *     *   **`try-catch` (Input Validation):** A `try-catch(NumberFormatException)` block is specifically used around the `Integer.parseInt()` call to handle cases where the user enters non-numeric input for the menu choice. An error is printed to `System.err`, and the loop continues.
 *     *   **`switch` Statement:** The parsed integer choice is used in a `switch` statement to direct the program flow to the corresponding functionality within the `AppointmentManager`.
 *     *   **`System.out` and `System.err`:** Used throughout the `main` method and `AppointmentManager` for displaying menu, success messages, list contents (`System.out`), and error messages (`System.err`).
 *     *   **Class-wide `try-catch`:** The entire `while` loop containing the main application logic is wrapped in a broad `try-catch(Exception e)` block. This serves as a safety net to catch any unexpected exceptions that might occur during execution, preventing the program from crashing abruptly and printing an error message to `System.err`. The `finally` block ensures the `Scanner` is closed.
 * 
 * This solution effectively utilizes all required components (`Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.err`, `System.out`, `try-catch`), demonstrates proper encapsulation, input validation, error handling, and follows a clean, structured approach suitable for an advanced Java programming exam.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.Objects; // For Objects.equals and Objects.hash

/**
 * Represents a patient in the hospital system.
 */
class Patient {
    private String patientId;
    private String name;

    /**
     * Constructs a new Patient.
     * @param patientId The unique ID of the patient.
     * @param name The name of the patient.
     */
    public Patient(String patientId, String name) {
        this.patientId = patientId;
        this.name = name;
    }

    /**
     * Gets the patient ID.
     * @return The patient ID.
     */
    public String getPatientId() {
        return patientId;
    }

    /**
     * Gets the patient name.
     * @return The patient name.
     */
    public String getName() {
        return name;
    }

    /**
     * Checks if two Patient objects are equal based on their patientId.
     * @param o The object to compare with.
     * @return true if the objects are equal, false otherwise.
     */
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Patient patient = (Patient) o;
        return Objects.equals(patientId, patient.patientId);
    }

    /**
     * Generates a hash code for the Patient based on their patientId.
     * @return The hash code.
     */
    @Override
    public int hashCode() {
        return Objects.hash(patientId);
    }

    /**
     * Returns a string representation of the Patient.
     * @return A string in the format "ID (Name)".
     */
    @Override
    public String toString() {
        return patientId + " (" + name + ")";
    }
}

/**
 * Manages patient registration and appointment waiting list.
 */
class AppointmentManager {
    private List<Patient> registeredPatients;
    private Queue<Patient> appointmentWaitingList;

    /**
     * Constructs an AppointmentManager with empty lists.
     */
    public AppointmentManager() {
        this.registeredPatients = new ArrayList<>();
        this.appointmentWaitingList = new LinkedList<>(); // LinkedList implements Queue
    }

    /**
     * Registers a new patient if their ID is unique.
     * @param patientId The ID of the patient.
     * @param name The name of the patient.
     */
    public void registerPatient(String patientId, String name) {
        // Check for duplicate ID
        boolean idExists = registeredPatients.stream()
                                            .anyMatch(p -> p.getPatientId().equals(patientId));

        if (idExists) {
            System.err.println("Error: Patient with ID " + patientId + " already exists.");
        } else {
            Patient newPatient = new Patient(patientId, name);
            registeredPatients.add(newPatient);
            System.out.println("Patient " + newPatient + " registered successfully.");
        }
    }

    /**
     * Adds a registered patient to the appointment waiting list.
     * @param patientId The ID of the patient to add.
     */
    public void addPatientToWaitingList(String patientId) {
        // Find the patient in the registered list
        Patient patientToAdd = findPatientById(patientId);

        if (patientToAdd != null) {
            appointmentWaitingList.offer(patientToAdd); // offer is generally preferred over add for queues
            System.out.println("Patient " + patientToAdd + " added to waiting list.");
        } else {
            System.err.println("Error: Patient with ID " + patientId + " not found in registered patients.");
        }
    }

    /**
     * Processes (removes) the next patient from the waiting list.
     * @return The Patient object that was processed, or null if the waiting list was empty.
     */
    public Patient processNextPatient() {
        Patient nextPatient = appointmentWaitingList.poll(); // poll returns null if queue is empty

        if (nextPatient != null) {
            System.out.println("Processing appointment for: " + nextPatient);
            return nextPatient;
        } else {
            System.out.println("Waiting list is empty.");
            return null;
        }
    }

    /**
     * Gets an unmodifiable view of all registered patients.
     * @return A List of registered patients.
     */
    public List<Patient> getAllRegisteredPatients() {
        // Return a copy or unmodifiable list for better encapsulation, but returning reference is simpler for exam
         return registeredPatients;
        // return Collections.unmodifiableList(registeredPatients);
    }

    /**
     * Gets the current appointment waiting list queue.
     * @return The Queue of patients waiting.
     */
    public Queue<Patient> getAppointmentWaitingList() {
        // Return the reference to the queue
        return appointmentWaitingList;
    }

    /**
     * Helper method to find a patient by ID in the registered patients list.
     * @param patientId The ID to search for.
     * @return The Patient object if found, otherwise null.
     */
    private Patient findPatientById(String patientId) {
        for (Patient patient : registeredPatients) {
            if (patient.getPatientId().equals(patientId)) {
                return patient;
            }
        }
        return null; // Patient not found
    }
}

/**
 * Main application class for the Hospital Appointment System.
 * Handles user interaction and menu.
 */
public class HospitalApp {

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        AppointmentManager manager = new AppointmentManager();
        boolean running = true;

        // Class-wide exception handling around the main loop
        try {
            while (running) {
                printMenu();

                System.out.print("Enter your choice: ");
                String choiceStr = scanner.nextLine();
                int choice = -1;

                try {
                    choice = Integer.parseInt(choiceStr);
                } catch (NumberFormatException e) {
                    System.err.println("Invalid input. Please enter a number.");
                    continue; // Skip to next iteration
                }

                // Switch statement for flow control
                switch (choice) {
                    case 1: // Register Patient
                        System.out.print("Enter Patient ID: ");
                        String regId = scanner.nextLine();
                        System.out.print("Enter Patient Name: ");
                        String regName = scanner.nextLine();
                        manager.registerPatient(regId, regName);
                        break;

                    case 2: // Add Patient to Waiting List
                        System.out.print("Enter Patient ID to add to waiting list: ");
                        String waitId = scanner.nextLine();
                        manager.addPatientToWaitingList(waitId);
                        break;

                    case 3: // Process Next Appointment
                        manager.processNextPatient(); // Method handles output
                        break;

                    case 4: // View Registered Patients
                        List<Patient> registered = manager.getAllRegisteredPatients();
                        System.out.println("--- Registered Patients ---");
                        if (registered.isEmpty()) {
                            System.out.println("No patients registered.");
                        } else {
                            for (Patient p : registered) {
                                System.out.println(p);
                            }
                        }
                        System.out.println("---------------------------");
                        break;

                    case 5: // View Waiting List
                        Queue<Patient> waiting = manager.getAppointmentWaitingList();
                        System.out.println("--- Waiting List ---");
                        if (waiting.isEmpty()) {
                            System.out.println("Waiting list is empty.");
                        } else {
                            // Iterate without removing elements
                            for (Patient p : waiting) {
                                System.out.println(p);
                            }
                        }
                        System.out.println("--------------------");
                        break;

                    case 6: // Exit
                        System.out.println("Exiting system.");
                        running = false;
                        break;

                    default:
                        System.err.println("Invalid choice. Please enter a number between 1 and 6.");
                }
                System.out.println(); // Add a newline for better readability between operations
            }
        } catch (Exception e) {
            // Catch any unexpected exceptions during the main loop execution
            System.err.println("An unexpected error occurred: " + e.getMessage());
            e.printStackTrace(); // Print stack trace for debugging
        } finally {
            // Ensure the scanner is closed
            scanner.close();
        }
    }

    /**
     * Prints the main menu options to the console.
     */
    private static void printMenu() {
        System.out.println("--- Hospital Appointment System ---");
        System.out.println("1. Register Patient");
        System.out.println("2. Add Patient to Waiting List");
        System.out.println("3. Process Next Appointment");
        System.out.println("4. View Registered Patients");
        System.out.println("5. View Waiting List");
        System.out.println("6. Exit");
        System.out.println("-----------------------------------");
    }
}
