/*
 * Exam Question #606
 * Generated on: 2025-05-12 16:14:07
 * Generated by: Account 5
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Restaurant Order Management System
 * 
 * **Objective:** Design and implement a simple command-line based Restaurant Order Management System. This system should allow staff to view the menu, add new customer orders, and process pending orders. Orders are processed in the order they are received (First-In, First-Out).
 * 
 * **Requirements:**
 * 
 * 1.  **Menu:** The system must have a predefined menu of items.
 * 2.  **Orders:** Customers place orders consisting of one or more menu items. Orders should be stored in a queue awaiting processing.
 * 3.  **Functionality:** The system must support the following operations via a command-line interface:
 *     *   View the menu with item numbers and prices.
 *     *   Add a new order: Prompt the user to select items from the menu by number until they indicate they are finished. An order must contain at least one item.
 *     *   Process the next order: Remove the oldest pending order from the queue, display its details (items and total price), and indicate that it has been processed.
 *     *   Exit the system.
 * 4.  **User Interface:** Use `java.util.Scanner` to read user input for menu choices and order item selections.
 * 5.  **Data Structures:**
 *     *   Use `java.util.List` (specifically implemented by `java.util.ArrayList`) to store the menu items.
 *     *   Use `java.util.Queue` (specifically implemented by `java.util.LinkedList`) to manage the pending orders.
 *     *   An `Order` object should internally use a `List` (specifically `ArrayList`) to store the `MenuItem`s it contains.
 * 6.  **Control Flow:** Use a `switch` statement to handle the main command options entered by the user.
 * 7.  **Output:**
 *     *   Use `System.out` for displaying the menu, prompts, successful operations, and processed order details.
 *     *   Use `System.err` for displaying error messages (e.g., invalid input, processing when no orders are pending, trying to add an empty order).
 * 8.  **Exception Handling:** Implement robust exception handling.
 *     *   Use `try-catch` blocks to handle potential issues, such as invalid user input (e.g., non-numeric input when expecting a number).
 *     *   Demonstrate "class-wide" exception handling by including a `try-catch` block that wraps the main command processing loop to catch unexpected runtime errors.
 * 9.  **Best Practices:**
 *     *   Employ proper encapsulation (private fields, public getters/methods).
 *     *   Use meaningful variable and method names.
 *     *   Include appropriate comments and documentation (basic Javadoc style is sufficient).
 *     *   Validate user input where necessary (e.g., ensuring menu item index is valid).
 *     *   Ensure proper error handling messages guide the user.
 *     *   Structure the code into appropriate classes (`MenuItem`, `Order`, `RestaurantSystem`, and a main class).
 * 
 * **Expected Output:**
 * 
 * The system should present a menu of options. Based on user input, it should perform the requested action, displaying relevant information or error messages.
 * 
 * *   Viewing Menu: Displays the list of items with numbers and prices.
 * *   Adding Order: Prompts for item numbers, validates input, confirms items added, and confirms order added. Displays errors for invalid input or if no items are selected before finishing.
 * *   Processing Order: Removes and displays details of the next order in the queue. Displays an error if the queue is empty.
 * *   Exiting: Displays an exit message.
 * *   Errors: Displays clear error messages to `System.err` for invalid commands, invalid item selection, non-numeric input, or attempting to process an empty queue. Unexpected errors should be caught and reported.
 * 
 * **Example Interaction Flow (Illustrative):**
 * 
 * ```
 * Welcome to the Restaurant Order System!
 * --- Restaurant Menu ---
 * 1. Burger - $8.99
 * 2. Pizza - $12.50
 * 3. Salad - $7.00
 * 4. Fries - $3.50
 * 5. Soda - $2.00
 * -----------------------
 * 
 * Choose an action:
 * 1. Add New Order
 * 2. Process Next Order
 * 3. View Menu
 * 4. Exit
 * Enter choice: 1
 * --- Adding New Order ---
 * Enter item number to add (enter 0 when done):
 * --- Restaurant Menu ---
 * ... (menu displayed again) ...
 * -----------------------
 * Enter item number (0 to finish): 1
 * Burger added to order.
 * --- Restaurant Menu ---
 * ... (menu displayed again) ...
 * -----------------------
 * Enter item number (0 to finish): 5
 * Soda added to order.
 * --- Restaurant Menu ---
 * ... (menu displayed again) ...
 * -----------------------
 * Enter item number (0 to finish): 0
 * Order added successfully with 2 items.
 * 
 * Choose an action:
 * 1. Add New Order
 * 2. Process Next Order
 * 3. View Menu
 * 4. Exit
 * Enter choice: 2
 * --- Processing Next Order ---
 * Processing Order:
 *   - 1. Burger ($8.99)
 *   - 2. Soda ($2.00)
 * Order Total: $10.99
 * Order processed.
 * 
 * Choose an action:
 * 1. Add New Order
 * 2. Process Next Order
 * 3. View Menu
 * 4. Exit
 * Enter choice: 2
 * --- Processing Next Order ---
 * No pending orders in the queue.
 * 
 * Choose an action:
 * ... (menu displayed) ...
 * Enter choice: invalid
 * Invalid choice. Please enter 1, 2, 3, or 4.
 * 
 * Choose an action:
 * ... (menu displayed) ...
 * Enter choice: 4
 * Exiting system. Goodbye!
 * ```
 * 
 * Your solution should be a single `.java` file containing all necessary classes.
 *
 * EXPLANATION:
 * This solution implements the Restaurant Order Management System using the required Java components and best practices.
 * 
 * 1.  **Class Structure:** The code is organized into four classes:
 *     *   `MenuItem`: A simple Plain Old Java Object (POJO) representing an item on the menu. It encapsulates the item's `name` and `price` as private fields with public getter methods, demonstrating encapsulation.
 *     *   `Order`: Represents a customer's order. It contains a `List<MenuItem>` to store the items. The constructor and `getItems()` method use `new ArrayList<>(...)` to create copies of the list, ensuring that the internal state (`items`) cannot be modified directly from outside the class, which is a key aspect of good encapsulation. It also includes a `calculateTotal()` method.
 *     *   `RestaurantSystem`: This is the core class managing the restaurant's operations. It holds the menu (`List<MenuItem>`) and the queue of pending orders (`Queue<Order>`). It contains methods for displaying the menu, adding orders, processing orders, and the main `run()` method that drives the user interaction.
 *     *   `RestaurantApp`: A simple main class with a `main` method to create an instance of `RestaurantSystem` and call its `run()` method to start the application.
 * 
 * 2.  **Data Structures:**
 *     *   `java.util.List`: The `menu` is declared as a `List<MenuItem>` and initialized as an `ArrayList`. The `Order` class also uses a `List<MenuItem>` (implemented as `ArrayList`) internally.
 *     *   `java.util.Queue`: The `pendingOrders` queue is declared as a `Queue<Order>` and initialized as a `LinkedList`. This correctly uses `LinkedList` as a common implementation of the `Queue` interface, ensuring FIFO order for processing orders (`offer` to add, `poll` to remove).
 *     *   `java.util.ArrayList`: Used specifically for the implementation of the `List` interface for the menu and order items.
 * 
 * 3.  **User Input (`Scanner`):** A `java.util.Scanner` is used in the `run()` method to read the user's main command choice. It is then passed to the `addOrder()` method so that `addOrder` can read the item selections for a new order. Reading lines (`nextLine()`) for commands and handling the newline character after `nextInt()` in `addOrder()` are important details for robust `Scanner` usage.
 * 
 * 4.  **Control Flow (`switch`):** The `run()` method uses a `switch` statement based on the user's command choice (`"1"`, `"2"`, `"3"`, `"4"`) to direct the program flow to the appropriate method (`addOrder`, `processOrder`, etc.).
 * 
 * 5.  **Output Streams (`System.out`, `System.err`):**
 *     *   `System.out.println()` is used for all standard output: displaying the menu, prompts, confirmation messages (order added, order processed), and processed order details.
 *     *   `System.err.println()` is used specifically for error messages: invalid command choices, invalid item selections during order creation, non-numeric input, and attempting to process an order when the queue is empty. This follows the convention of separating normal output from error information.
 * 
 * 6.  **Exception Handling (`try-catch`):**
 *     *   **Specific Input Handling:** The `addOrder()` method contains a `try-catch(InputMismatchException e)` block. This specifically catches the exception thrown by `scanner.nextInt()` if the user enters non-numeric text. It prints an informative error message to `System.err` and consumes the invalid input line (`scanner.nextLine()`) to prevent an infinite loop, demonstrating robust input validation and error handling.
 *     *   **Class-wide Handling:** The `run()` method has a large `try-catch(Exception e)` block wrapping the entire `while` loop that processes user commands. This block serves as a catch-all for any *unexpected* runtime exceptions that might occur within the main loop or methods called from it. It prints a generic error message and the stack trace to `System.err`, providing a basic level of resilience against unforeseen issues and demonstrating "class-wide" handling of potential errors during the main execution flow. A `finally` block ensures the `Scanner` is closed regardless of whether the loop finishes normally or an exception occurs.
 * 
 * 7.  **Best Practices:**
 *     *   **Encapsulation:** Achieved through private fields and public methods (`MenuItem`, `Order`, `RestaurantSystem`). The `Order` class's handling of its item list demonstrates defensive copying for better encapsulation.
 *     *   **Meaningful Names:** Variables (`menu`, `pendingOrders`, `itemIndex`, `currentOrderItems`, `nextOrder`), methods (`displayMenu`, `addOrder`, `processOrder`, `calculateTotal`), and classes (`MenuItem`, `Order`, `RestaurantSystem`) have names that clearly indicate their purpose.
 *     *   **Comments/Documentation:** Basic Javadoc-style comments are included for classes and methods, explaining their purpose, parameters, and return values.
 *     *   **Input Validation:** Checks are performed in `addOrder()` to ensure the entered item number is numeric (using `try-catch`) and within the valid range of the menu size. It also checks that an order is not empty before adding it to the queue.
 *     *   **Error Handling:** Different error conditions (invalid input type, invalid item index, empty queue, invalid command) are handled with specific messages directed to `System.err`.
 *     *   **Clean Code Structure:** The problem is broken down into logical components represented by separate classes, making the code more organized and maintainable.
 * 
 * This solution effectively demonstrates the required Java concepts in a practical, interconnected scenario, providing a good test of a student's understanding of these fundamental and intermediate topics.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.InputMismatchException;

/**
 * Represents a single menu item with a name and price.
 */
class MenuItem {
    private String name;
    private double price;

    /**
     * Constructs a new MenuItem.
     * @param name The name of the menu item.
     * @param price The price of the menu item.
     */
    public MenuItem(String name, double price) {
        this.name = name;
        this.price = price;
    }

    /**
     * Gets the name of the menu item.
     * @return The name.
     */
    public String getName() {
        return name;
    }

    /**
     * Gets the price of the menu item.
     * @return The price.
     */
    public double getPrice() {
        return price;
    }

    @Override
    public String toString() {
        return name + " - $" + String.format("%.2f", price);
    }
}

/**
 * Represents a customer order containing a list of menu items.
 */
class Order {
    private List<MenuItem> items;

    /**
     * Constructs a new Order.
     * @param items A list of MenuItem objects included in this order.
     */
    public Order(List<MenuItem> items) {
        // Create a new ArrayList from the input list to ensure encapsulation
        this.items = new ArrayList<>(items);
    }

    /**
     * Gets the list of items in the order.
     * Returns a copy to prevent external modification of the internal list.
     * @return A new List containing the items in the order.
     */
    public List<MenuItem> getItems() {
        return new ArrayList<>(items); // Return a copy for encapsulation
    }

    /**
     * Calculates the total price of the order.
     * @return The total price.
     */
    public double calculateTotal() {
        double total = 0;
        for (MenuItem item : items) {
            total += item.getPrice();
        }
        return total;
    }
}

/**
 * Manages the restaurant operations, including menu display,
 * adding orders to a queue, and processing orders from the queue.
 */
public class RestaurantSystem {
    // Use List interface, implemented by ArrayList for the menu
    private List<MenuItem> menu;
    // Use Queue interface, implemented by LinkedList for pending orders
    private Queue<Order> pendingOrders;

    /**
     * Constructs a new RestaurantSystem and initializes the menu and order queue.
     */
    public RestaurantSystem() {
        // Initialize data structures
        this.menu = new ArrayList<>();
        this.pendingOrders = new LinkedList<>();

        // Populate the menu with some sample items
        initializeMenu();
    }

    /**
     * Initializes the restaurant menu with predefined items.
     */
    private void initializeMenu() {
        menu.add(new MenuItem("Burger", 8.99));
        menu.add(new MenuItem("Pizza", 12.50));
        menu.add(new MenuItem("Salad", 7.00));
        menu.add(new MenuItem("Fries", 3.50));
        menu.add(new MenuItem("Soda", 2.00));
    }

    /**
     * Displays the current menu to the console.
     */
    public void displayMenu() {
        System.out.println("--- Restaurant Menu ---");
        if (menu.isEmpty()) {
            System.out.println("Menu is currently empty.");
        } else {
            for (int i = 0; i < menu.size(); i++) {
                // Display item number (1-based index) and item details
                System.out.println((i + 1) + ". " + menu.get(i));
            }
        }
        System.out.println("-----------------------");
    }

    /**
     * Allows the user to add a new order by selecting items from the menu.
     * Uses Scanner for input and includes input validation.
     * @param scanner The Scanner object to read user input.
     */
    public void addOrder(Scanner scanner) {
        List<MenuItem> currentOrderItems = new ArrayList<>();
        System.out.println("--- Adding New Order ---");
        System.out.println("Enter item number to add (enter 0 when done):");

        while (true) {
            displayMenu(); // Show menu each time for easy selection
            System.out.print("Enter item number (0 to finish): ");
            int itemIndex = -1;

            try {
                // Read the integer input for item number
                itemIndex = scanner.nextInt();
                // Consume the leftover newline character after nextInt()
                scanner.nextLine();
            } catch (InputMismatchException e) {
                // Handle non-integer input using System.err
                System.err.println("Invalid input. Please enter a number.");
                // Consume the invalid input line to prevent infinite loop
                scanner.nextLine();
                continue; // Ask for input again
            }

            // Check if the user wants to finish the order
            if (itemIndex == 0) {
                if (currentOrderItems.isEmpty()) {
                    // Use System.err if no items were added, as it's an incomplete order
                    System.err.println("Order cancelled. No items were added.");
                } else {
                    // Create a new Order object with the selected items
                    Order newOrder = new Order(currentOrderItems);
                    // Add the new order to the pending orders queue
                    pendingOrders.offer(newOrder); // offer() is preferred over add() as it returns false on failure
                    System.out.println("Order added successfully with " + currentOrderItems.size() + " items.");
                }
                break; // Exit the item selection loop
            }

            // Validate the selected item index against the menu size
            if (itemIndex > 0 && itemIndex <= menu.size()) {
                // Add the selected item to the current order's item list
                currentOrderItems.add(menu.get(itemIndex - 1)); // Adjust for 0-based list index
                System.out.println(menu.get(itemIndex - 1).getName() + " added to order.");
            } else {
                // Handle invalid item number using System.err
                System.err.println("Invalid item number. Please select from the menu list.");
            }
        }
    }

    /**
     * Processes the next pending order in the queue (FIFO).
     * Displays order details or an error if the queue is empty.
     */
    public void processOrder() {
        System.out.println("--- Processing Next Order ---");
        // Retrieve and remove the head of the queue using poll()
        Order nextOrder = pendingOrders.poll();

        if (nextOrder == null) {
            // Use System.err when there are no orders to process
            System.err.println("No pending orders in the queue.");
        } else {
            System.out.println("Processing Order:");
            List<MenuItem> items = nextOrder.getItems();
            // Display items in the processed order
            for (int i = 0; i < items.size(); i++) {
                MenuItem item = items.get(i);
                System.out.println("  - " + (i + 1) + ". " + item.getName() + " ($" + String.format("%.2f", item.getPrice()) + ")");
            }
            // Display the total price of the order
            System.out.println("Order Total: $" + String.format("%.2f", nextOrder.calculateTotal()));
            System.out.println("Order processed successfully.");
        }
    }

    /**
     * Runs the main command-line interface loop for the restaurant system.
     * Includes class-wide exception handling for unexpected errors.
     */
    public void run() {
        Scanner scanner = new Scanner(System.in);
        boolean running = true;
        System.out.println("Welcome to the Restaurant Order System!");

        // Class-wide exception handling wrapping the main execution loop
        try {
            while (running) {
                displayMenu(); // Display menu at the start of each interaction cycle
                System.out.println("\nChoose an action:");
                System.out.println("1. Add New Order");
                System.out.println("2. Process Next Order");
                System.out.println("3. View Menu");
                System.out.println("4. Exit");
                System.out.print("Enter choice: ");

                // Read the entire line for the command choice
                String choice = scanner.nextLine();

                // Use a switch statement to handle different command choices
                switch (choice) {
                    case "1":
                        addOrder(scanner); // Pass the scanner to the method
                        break;
                    case "2":
                        processOrder();
                        break;
                    case "3":
                        // Menu is already displayed at the top of the loop, but this option
                        // allows redisplaying it explicitly if needed.
                        // displayMenu();
                        System.out.println("Menu displayed above.");
                        break;
                    case "4":
                        running = false; // Set flag to exit the loop
                        System.out.println("Exiting system. Goodbye!");
                        break;
                    default:
                        // Handle invalid command input using System.err
                        System.err.println("Invalid choice. Please enter 1, 2, 3, or 4.");
                }
                System.out.println(); // Add a blank line for better readability between interactions
            }
        } catch (Exception e) {
            // This catch block handles any unexpected runtime exceptions that might occur
            // during the execution of the main loop or methods called within it,
            // demonstrating a form of class-wide handling.
            System.err.println("An unexpected system error occurred: " + e.getMessage());
            e.printStackTrace(System.err); // Print stack trace to the error stream for debugging
        } finally {
            // Ensure the scanner resource is closed when the system exits (normally or via exception)
            scanner.close();
            System.out.println("Scanner closed.");
        }
    }

    /**
     * Main method to start the Restaurant Order Management System.
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        RestaurantSystem system = new RestaurantSystem();
        system.run(); // Start the system's main loop
    }
}
