/*
 * Exam Question #694
 * Generated on: 2025-05-12 16:26:40
 * Generated by: Account 1
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Customer Service Ticket Management System
 * 
 * **Objective:**
 * 
 * Design and implement a simple text-based customer service ticket management system. The system should allow users (simulating agents) to submit new support tickets, process the oldest pending ticket, view the list of open tickets, and view the list of closed tickets.
 * 
 * **Requirements:**
 * 
 * 1.  **`SupportTicket` Class:**
 *     *   Create a class named `SupportTicket` to represent a single support ticket.
 *     *   It must have private fields: `id` (an integer, unique), `description` (String), and `status` (String, e.g., "Open", "Closed").
 *     *   Include a constructor to initialize `description` and set the initial `status` to "Open". The `id` should be assigned automatically by the system.
 *     *   Provide public getter methods for all fields.
 *     *   Provide a public method `closeTicket()` that changes the `status` to "Closed".
 *     *   Override the `toString()` method to provide a clear string representation of the ticket (including ID, description, and status).
 * 
 * 2.  **`TicketSystem` Class:**
 *     *   Create a class named `TicketSystem` to manage the tickets.
 *     *   It must have private fields:
 *         *   A `Queue<SupportTicket>` to store open tickets waiting to be processed. Use an appropriate implementation (e.g., `java.util.LinkedList` which implements `Queue`).
 *         *   A `List<SupportTicket>` (specifically using `java.util.ArrayList` as the concrete implementation) to store closed tickets.
 *         *   A private counter for generating unique ticket IDs.
 *     *   Include a public method `addTicket(String description)`:
 *         *   Validates that the description is not null or empty. If invalid, print an error to `System.err` and do not add the ticket.
 *         *   If valid, creates a new `SupportTicket` object, assigns it a unique ID using the counter, and adds it to the open tickets queue. Print a confirmation message to `System.out`.
 *     *   Include a public method `processNextTicket()`:
 *         *   Checks if the open tickets queue is empty. If so, print an error message to `System.err`.
 *         *   If not empty, remove the oldest ticket from the queue, call its `closeTicket()` method, and add it to the closed tickets list. Print a success message to `System.out`.
 *     *   Include a public method `viewOpenTickets()`:
 *         *   Iterates through the open tickets queue and prints details of each ticket to `System.out`. Indicate if the queue is empty.
 *     *   Include a public method `viewClosedTickets()`:
 *         *   Iterates through the closed tickets list and prints details of each ticket to `System.out`. Indicate if the list is empty.
 * 
 * 3.  **Main Application (`ExamTicketSystem` or similar):**
 *     *   Create a class with a `main` method to run the system.
 *     *   Use `java.util.Scanner` to get user input from the console.
 *     *   Implement a menu-driven loop with the following options:
 *         *   1. Submit New Ticket
 *         *   2. Process Next Ticket
 *         *   3. View Open Tickets Queue
 *         *   4. View Closed Tickets List
 *         *   5. Exit
 *     *   Use a `switch` statement to handle the different menu choices.
 *     *   Use `System.out` for displaying the menu and normal output.
 *     *   Use `System.err` for displaying error messages (e.g., invalid menu choice, empty description, processing empty queue).
 *     *   Implement class-wide exception handling using `try-catch` blocks, specifically to handle potential `java.util.InputMismatchException` if the user enters non-integer input for the menu choice. The main menu loop should ideally be wrapped or handle this gracefully to prevent the program from crashing on bad input type.
 *     *   Ensure the program terminates cleanly when the user chooses the Exit option.
 * 
 * **General Requirements & Best Practices:**
 * 
 * *   Use appropriate data types and variable names.
 * *   Follow Java coding conventions (camelCase for variables/methods, PascalCase for classes).
 * *   Include meaningful comments where necessary.
 * *   Ensure proper encapsulation (private fields, public methods where needed).
 * *   Use the `List` interface type for the closed tickets collection variable, even though the implementation is `ArrayList`.
 * 
 * **Expected Output:**
 * 
 * The program should present a menu, accept user input, perform the requested actions, and print relevant messages or ticket details to the console (`System.out` for success/info, `System.err` for errors). Demonstrate adding tickets, viewing queues/lists, processing tickets, and handling invalid input or operations (like processing an empty queue).
 * 
 * ---
 *
 * EXPLANATION:
 * This solution implements a basic Customer Service Ticket Management System demonstrating the required Java concepts.
 * 
 * 1.  **`SupportTicket` Class:** This class is a simple Plain Old Java Object (POJO) representing a ticket. It encapsulates the ticket's `id`, `description`, and `status`. It provides a constructor, public getters, a method to change its own status (`closeTicket`), and an overridden `toString()` for easy printing. This fulfills the encapsulation requirement.
 * 
 * 2.  **`TicketSystem` Class:** This is the core class managing the collections of tickets.
 *     *   It uses a `java.util.Queue<SupportTicket>` named `openTickets`. The `Queue` interface represents a collection designed for holding elements prior to processing, typically in a FIFO (First-In, First-Out) manner. `java.util.LinkedList` is used as the concrete implementation because it efficiently supports queue operations (`offer` to add to the tail, `poll` to remove from the head).
 *     *   It uses a `java.util.List<SupportTicket>` named `closedTickets`. The `List` interface represents an ordered collection. `java.util.ArrayList` is used as the concrete implementation, providing dynamic array capabilities suitable for storing the history of closed tickets. Using the `List` interface type for the variable (`List<SupportTicket>`) demonstrates programming to interfaces, a good practice.
 *     *   A simple `nextTicketId` counter is used to generate unique IDs for new tickets.
 *     *   Methods like `addTicket`, `processNextTicket`, `viewOpenTickets`, and `viewClosedTickets` implement the system's logic, interacting with the queue and list. `addTicket` includes input validation for the description. `processNextTicket` demonstrates the core queue operation (`poll`) and moves the ticket to the closed list.
 * 
 * 3.  **`ExamTicketSystem` Class (Main Application):**
 *     *   The `main` method drives the application.
 *     *   A `java.util.Scanner` is used to read user input from the console.
 *     *   A `while` loop keeps the application running until the user chooses to exit.
 *     *   Inside the loop, a menu is printed, and user input is read.
 *     *   A `switch` statement is used to direct the program flow based on the user's integer choice, calling the appropriate methods in the `TicketSystem` instance. This fulfills the `switch` requirement.
 *     *   `System.out.println` is used for displaying the menu, successful operations, and ticket details.
 *     *   `System.err.println` is used for printing error messages, such as invalid input, empty descriptions, or attempting to process tickets when none are available. This fulfills the `System.out` and `System.err` requirements.
 *     *   A `try-catch` block is wrapped around the input reading and processing within the main loop. This specifically catches `InputMismatchException`, which occurs if the user enters non-integer input when an integer is expected by `scanner.nextInt()`. This demonstrates class-wide (or at least, main application loop level) exception handling using `try-catch` as required. A general `Exception` catch is also included as a fallback for unexpected issues. The `scanner.nextLine()` after `scanner.nextInt()` is crucial to consume the leftover newline character, preventing input issues in subsequent `scanner.nextLine()` calls.
 * 
 * This solution effectively integrates all the required Java components (`Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.err`, `System.out`, `try-catch`) into a cohesive, practical application demonstrating object-oriented principles, data structure usage, user interaction, and error handling.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.InputMismatchException;

// Represents a single support ticket
class SupportTicket {
    private int id;
    private String description;
    private String status;

    // Constructor
    public SupportTicket(int id, String description) {
        this.id = id;
        this.description = description;
        this.status = "Open"; // Tickets start as Open
    }

    // Getters
    public int getId() {
        return id;
    }

    public String getDescription() {
        return description;
    }

    public String getStatus() {
        return status;
    }

    // Method to close the ticket
    public void closeTicket() {
        this.status = "Closed";
    }

    // String representation of the ticket
    @Override
    public String toString() {
        return "Ticket [ID=" + id + ", Description='" + description + "', Status=" + status + "]";
    }
}

// Manages the collection of support tickets
class TicketSystem {
    // Queue for tickets waiting to be processed (FIFO)
    private Queue<SupportTicket> openTickets;
    // List for tickets that have been processed (history)
    private List<SupportTicket> closedTickets;
    // Counter for generating unique ticket IDs
    private int nextTicketId;

    // Constructor
    public TicketSystem() {
        // Using LinkedList as a Queue implementation
        this.openTickets = new LinkedList<>();
        // Using ArrayList as a List implementation
        this.closedTickets = new ArrayList<>();
        this.nextTicketId = 1; // Start ID from 1
    }

    /**
     * Adds a new ticket to the open tickets queue.
     * @param description The description of the issue.
     */
    public void addTicket(String description) {
        // Input validation
        if (description == null || description.trim().isEmpty()) {
            System.err.println("Error: Ticket description cannot be empty.");
            return;
        }

        // Create new ticket and add to queue
        SupportTicket newTicket = new SupportTicket(nextTicketId++, description.trim());
        openTickets.offer(newTicket); // offer() is preferred over add() for queues as it handles capacity
        System.out.println("Ticket submitted: " + newTicket.toString());
    }

    /**
     * Processes the oldest ticket in the queue.
     * Moves the ticket from the open queue to the closed list.
     */
    public void processNextTicket() {
        // Check if queue is empty
        if (openTickets.isEmpty()) {
            System.err.println("Error: No open tickets to process.");
            return;
        }

        // Remove ticket from queue, close it, and add to closed list
        SupportTicket ticketToProcess = openTickets.poll(); // poll() retrieves and removes the head, returns null if empty
        if (ticketToProcess != null) { // Should not be null due to isEmpty check, but good practice
            ticketToProcess.closeTicket();
            closedTickets.add(ticketToProcess);
            System.out.println("Ticket processed and closed: " + ticketToProcess.toString());
        }
    }

    /**
     * Displays all tickets currently in the open tickets queue.
     */
    public void viewOpenTickets() {
        System.out.println("\n--- Open Tickets Queue ---");
        if (openTickets.isEmpty()) {
            System.out.println("No open tickets.");
        } else {
            // Iterate through the queue without removing elements
            int count = 0;
            for (SupportTicket ticket : openTickets) {
                System.out.println(ticket.toString());
                count++;
            }
            System.out.println("Total open tickets: " + count);
        }
        System.out.println("--------------------------");
    }

    /**
     * Displays all tickets currently in the closed tickets list.
     */
    public void viewClosedTickets() {
        System.out.println("\n--- Closed Tickets List ---");
        if (closedTickets.isEmpty()) {
            System.out.println("No closed tickets.");
        } else {
            // Iterate through the list
            for (SupportTicket ticket : closedTickets) {
                System.out.println(ticket.toString());
            }
            System.out.println("Total closed tickets: " + closedTickets.size());
        }
        System.out.println("---------------------------");
    }
}

// Main class to run the ticket management system
public class ExamTicketSystem {

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        TicketSystem ticketSystem = new TicketSystem();
        boolean running = true;

        System.out.println("Welcome to the Customer Service Ticket System!");

        // Main application loop
        while (running) {
            printMenu();

            try {
                System.out.print("Enter your choice: ");
                int choice = scanner.nextInt();
                scanner.nextLine(); // Consume newline left-over

                // Switch statement for menu options
                switch (choice) {
                    case 1:
                        System.out.print("Enter ticket description: ");
                        String description = scanner.nextLine();
                        ticketSystem.addTicket(description);
                        break;
                    case 2:
                        ticketSystem.processNextTicket();
                        break;
                    case 3:
                        ticketSystem.viewOpenTickets();
                        break;
                    case 4:
                        ticketSystem.viewClosedTickets();
                        break;
                    case 5:
                        running = false; // Exit the loop
                        System.out.println("Exiting Ticket System. Goodbye!");
                        break;
                    default:
                        // Handle invalid integer input within range
                        System.err.println("Invalid choice. Please enter a number between 1 and 5.");
                        break;
                }
            } catch (InputMismatchException e) {
                // Handle non-integer input using try-catch
                System.err.println("Invalid input. Please enter a number.");
                scanner.next(); // Consume the invalid input to prevent infinite loop
            } catch (Exception e) {
                // Catch any other unexpected exceptions
                System.err.println("An unexpected error occurred: " + e.getMessage());
                e.printStackTrace(); // Print stack trace for debugging
            }
            System.out.println(); // Add a newline for better readability between actions
        }

        scanner.close(); // Close the scanner
    }

    // Helper method to print the menu
    private static void printMenu() {
        System.out.println("\n--- Menu ---");
        System.out.println("1. Submit New Ticket");
        System.out.println("2. Process Next Ticket");
        System.out.println("3. View Open Tickets Queue");
        System.out.println("4. View Closed Tickets List");
        System.out.println("5. Exit");
        System.out.println("------------");
    }
}
