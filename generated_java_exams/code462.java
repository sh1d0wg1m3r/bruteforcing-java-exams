/*
 * Exam Question #462
 * Generated on: 2025-05-11 23:14:50
 * Generated by: Account 1
 * 
 * QUESTION:
 * ## Java Programming Exam: Software Pipeline Simulation
 * 
 * **Problem Description:**
 * 
 * You are tasked with building a simplified command-line simulator for a software build and deployment pipeline. This simulator will manage tasks that move through different stages: Pending, Processing, and Completed. Users will interact with the system via a text-based menu.
 * 
 * **Requirements:**
 * 
 * Implement a Java application that simulates this pipeline with the following features:
 * 
 * 1.  **Add New Task:** Allow the user to add a new task to the pipeline. Each task should have a description and a priority (HIGH, MEDIUM, LOW). New tasks are initially in the PENDING state.
 * 2.  **Process Next Task:** Move the next available task from the PENDING queue to the PROCESSING state. Only one task can be in the PROCESSING state at any time. If a task is already processing, or if there are no pending tasks, inform the user.
 * 3.  **Complete Current Task:** Move the task currently in the PROCESSING state to the COMPLETED state and add it to a list of completed tasks. If no task is currently processing, inform the user.
 * 4.  **View Pending Tasks:** Display all tasks currently in the PENDING queue.
 * 5.  **View Completed Tasks:** Display all tasks that have been moved to the COMPLETED state.
 * 6.  **Exit:** Terminate the application.
 * 
 * **Technical Constraints & Required Components:**
 * 
 * Your solution **must** use and demonstrate understanding of the following Java components and concepts:
 * 
 * *   `java.util.Queue`: To manage tasks in the PENDING state (FIFO - First-In, First-Out).
 * *   `java.util.ArrayList`: To store tasks in the COMPLETED state.
 * *   `java.util.List`: Declare the variable holding completed tasks using the `List` interface type.
 * *   `java.util.Scanner`: To read all user input from the console.
 * *   `switch` statement: To control the flow based on the user's menu selection.
 * *   `System.out`: For printing normal output (menu, task details, success messages).
 * *   `System.err`: For printing all error messages (invalid input, operational errors).
 * *   Class-wide exception handling with `try-catch` blocks: Implement error handling, particularly for potential issues with user input parsing (e.g., non-integer menu choice) and potentially for logical errors (though some operational errors might be handled with `if/else` checks and `System.err`).
 * 
 * **Best Practices:**
 * 
 * *   **Encapsulation:** Design classes with private fields and public methods/getters.
 * *   **Meaningful Names:** Use descriptive names for classes, variables, methods, and enums.
 * *   **Comments & Documentation:** Include comments to explain complex logic and document classes/methods (basic Javadoc style is encouraged).
 * *   **Input Validation:** Validate user input, especially for task priority (accept "HIGH", "MEDIUM", "LOW" case-insensitively) and menu choices.
 * *   **Proper Error Handling:** Gracefully handle invalid input and operational issues (e.g., trying to process an empty queue, trying to complete a non-existent task), reporting errors via `System.err`.
 * *   **Clean Code Structure:** Organize your code into appropriate classes (`Task`, `PipelineManager`, main application class).
 * 
 * **Task Details:**
 * 
 * Create a `Task` class with the following attributes:
 * *   An integer `id` (auto-generated, starting from 1).
 * *   A `String` `description`.
 * *   A `Priority` enum (values: `HIGH`, `MEDIUM`, `LOW`).
 * *   A `Status` enum (values: `PENDING`, `PROCESSING`, `COMPLETED`).
 * 
 * The `PipelineManager` class should manage the state (the queue, the list, and the currently processing task) and contain the methods for the pipeline operations.
 * 
 * **Expected Output:**
 * 
 * The application should present a menu. When adding tasks, it should prompt for description and priority. When viewing tasks, it should list them clearly. Error messages should be distinct (using `System.err`).
 * 
 * ```
 * --- Pipeline Menu ---
 * 1. Add New Task
 * 2. Process Next Task
 * 3. Complete Current Task
 * 4. View Pending Tasks
 * 5. View Completed Tasks
 * 6. Exit
 * ---------------------
 * Enter your choice: 1
 * Enter task description: Implement feature X
 * Enter task priority (HIGH, MEDIUM, LOW): HIGH
 * Added task: Task{ID=1, Desc='Implement feature X', Priority=HIGH, Status=PENDING}
 * 
 * --- Pipeline Menu ---
 * ...
 * Enter your choice: 2
 * Started processing task: Task{ID=1, Desc='Implement feature X', Priority=HIGH, Status=PROCESSING}
 * 
 * --- Pipeline Menu ---
 * ...
 * Enter your choice: 4
 * 
 * --- Pending Tasks ---
 * No pending tasks.
 * ---------------------
 * 
 * --- Pipeline Menu ---
 * ...
 * Enter your choice: 3
 * Completed task: Task{ID=1, Desc='Implement feature X', Priority=HIGH, Status=COMPLETED}
 * 
 * --- Pipeline Menu ---
 * ...
 * Enter your choice: 5
 * 
 * --- Completed Tasks ---
 * Task{ID=1, Desc='Implement feature X', Priority=HIGH, Status=COMPLETED}
 * -----------------------
 * 
 * --- Pipeline Menu ---
 * ...
 * Enter your choice: ABC
 * Invalid input. Please enter a number for your choice.
 * 
 * --- Pipeline Menu ---
 * ...
 * Enter your choice: 1
 * Enter task description: Fix bug Y
 * Enter task priority (HIGH, MEDIUM, LOW): URGENT
 * Invalid priority entered. Please use HIGH, MEDIUM, or LOW.
 * 
 * --- Pipeline Menu ---
 * ...
 * Enter your choice: 6
 * Exiting Pipeline Simulator. Goodbye!
 * ```
 * 
 * This task is designed to be challenging and test your ability to integrate multiple core Java data structures, control flow mechanisms, and error handling techniques in a practical scenario. You should aim to complete it within 45-60 minutes.
 *
 * EXPLANATION:
 * The solution implements the Software Build and Deployment Pipeline Simulator using several core Java concepts and data structures as required.
 * 
 * 1.  **Class Structure:** The problem is broken down into logical classes:
 *     *   `Priority` and `Status` enums define the possible states and attributes of a task, improving code readability and preventing invalid values. The `Priority` enum includes a static `fromString` helper method for robust input parsing.
 *     *   `Task` class encapsulates the data for a single task (ID, description, priority, status) and provides getters and a `toString` method for easy display. An auto-incrementing static field ensures unique IDs.
 *     *   `PipelineManager` class is the central component managing the state of the pipeline. It holds the `Queue` of pending tasks, the `List` of completed tasks, and the single `Task` currently being processed. Its methods (`addTask`, `processNextTask`, `completeCurrentTask`) implement the core pipeline logic, encapsulating the state manipulation.
 *     *   `PipelineApp` class contains the `main` method. It handles user interaction, displays the menu, reads input using `Scanner`, and delegates operations to the `PipelineManager`.
 * 
 * 2.  **Data Structures (`Queue`, `List`, `ArrayList`):**
 *     *   `java.util.Queue`: The `pendingTasks` field in `PipelineManager` is declared as `Queue<Task>` and initialized with `new LinkedList<>()`. `LinkedList` is a common class that implements the `Queue` interface, providing FIFO behavior. Tasks are added using `offer()` and removed for processing using `poll()`. `poll()` is used because it safely returns `null` if the queue is empty, avoiding an exception.
 *     *   `java.util.List` and `java.util.ArrayList`: The `completedTasks` field is declared using the `List<Task>` interface type (`private List<Task> completedTasks;`) and initialized with `new ArrayList<>()`. This adheres to the principle of programming to interfaces. `ArrayList` is used as the concrete implementation to store completed tasks. Completed tasks are added using the `add()` method.
 * 
 * 3.  **User Input (`Scanner`) and Control Flow (`switch`):**
 *     *   `java.util.Scanner`: An instance of `Scanner` is used in the `main` method to read user input from `System.in` for both the menu choice (`nextInt()`) and task details (`nextLine()`). It's important to handle the leftover newline character after `nextInt()` by calling `scanner.nextLine()`. The `Scanner` is closed when the application exits.
 *     *   `switch` statement: The main application loop uses a `switch` statement based on the integer menu choice read by the `Scanner`. Each `case` corresponds to a menu option, calling the appropriate method in the `PipelineManager` or handling application exit.
 * 
 * 4.  **Output Streams (`System.out`, `System.err`):**
 *     *   `System.out`: Used for all normal output, including printing the menu, confirming successful operations (task added, started, completed), and displaying the contents of the pending and completed task lists.
 *     *   `System.err`: Used *exclusively* for error messages. This includes reporting invalid user input (non-integer choice, invalid priority string) and operational errors (e.g., trying to process a task when one is already processing, trying to complete a task when none is processing). This distinction helps users easily identify errors.
 * 
 * 5.  **Exception Handling (`try-catch`):**
 *     *   A `try-catch` block is wrapped around the menu choice reading and the subsequent `switch` statement in the `main` loop.
 *     *   `catch (InputMismatchException e)` specifically handles cases where the user enters input that cannot be parsed as an integer by `scanner.nextInt()`. It prints an error to `System.err` and consumes the invalid input using `scanner.nextLine()` to prevent an infinite loop.
 *     *   A general `catch (Exception e)` is included as a fallback to catch any other unexpected runtime errors that might occur within the try block during execution, printing a generic error message to `System.err`.
 *     *   Logical operational errors (like attempting to process a task when one is processing) are handled within the `PipelineManager` methods using `if/else` checks, and the error condition is reported using `System.err`. While these *could* potentially throw custom exceptions, handling them with conditional checks and `System.err` output is a common and acceptable pattern, especially for state-based errors in this context.
 * 
 * 6.  **Best Practices:**
 *     *   **Encapsulation:** Fields in `Task` and `PipelineManager` are `private`, accessed via public methods (getters, setters, or operation methods).
 *     *   **Meaningful Names:** Variable names (`pendingTasks`, `currentlyProcessingTask`), method names (`processNextTask`, `completeCurrentTask`), class names (`Task`, `PipelineManager`), and enum names (`Priority`, `Status`) are chosen to clearly indicate their purpose.
 *     *   **Comments:** Javadoc-style comments explain the purpose of classes and key methods. Inline comments clarify specific logic points (like consuming the newline after `nextInt`).
 *     *   **Input Validation:** The `Priority.fromString()` method validates the priority input string. The `try-catch` block validates the menu choice input type.
 *     *   **Error Handling:** Invalid inputs and operational state errors are checked and reported using `System.err`. The `try-catch` prevents the program from crashing on invalid menu input.
 *     *   **Clean Code:** The code is separated into distinct classes based on responsibility, enhancing organization and maintainability. Methods perform specific tasks.
 * 
 * This solution effectively demonstrates the required Java components and best practices by integrating them into a functional, albeit simplified, simulation of a real-world process.
 */

import java.util.Queue;
import java.util.LinkedList;
import java.util.List;
import java.util.ArrayList;
import java.util.Scanner;
import java.util.InputMismatchException;

// Enum for task priority
enum Priority {
    HIGH, MEDIUM, LOW;

    /**
     * Converts a string (case-insensitive) to a Priority enum.
     * Returns null if the string does not match any priority.
     * @param text The string to convert.
     * @return The corresponding Priority enum, or null if invalid.
     */
    public static Priority fromString(String text) {
        if (text != null) {
            for (Priority p : Priority.values()) {
                if (p.name().equalsIgnoreCase(text.trim())) {
                    return p;
                }
            }
        }
        return null; // Indicate invalid input
    }
}

// Enum for task status
enum Status {
    PENDING, PROCESSING, COMPLETED
}

/**
 * Represents a single task in the pipeline.
 */
class Task {
    private static int nextId = 1; // For auto-generating unique IDs

    private int id;
    private String description;
    private Priority priority;
    private Status status;

    /**
     * Constructs a new Task.
     * @param description The task description.
     * @param priority The task priority.
     */
    public Task(String description, Priority priority) {
        this.id = nextId++; // Assign unique ID and increment counter
        this.description = description;
        this.priority = priority;
        this.status = Status.PENDING; // New tasks start as PENDING
    }

    // --- Getters ---
    public int getId() { return id; }
    public String getDescription() { return description; }
    public Priority getPriority() { return priority; }
    public Status getStatus() { return status; }

    /**
     * Sets the status of the task. Used by PipelineManager.
     * @param status The new status.
     */
    public void setStatus(Status status) { this.status = status; }

    /**
     * Provides a string representation of the Task.
     * @return Formatted string detailing the task.
     */
    @Override
    public String toString() {
        return String.format("Task{ID=%d, Desc='%s', Priority=%s, Status=%s}",
                             id, description, priority, status);
    }
}

/**
 * Manages the tasks in the pipeline, including pending, processing, and completed states.
 */
class PipelineManager {
    // Queue for tasks waiting to be processed (FIFO)
    private Queue<Task> pendingTasks;
    // List for tasks that have been completed
    private List<Task> completedTasks;
    // Variable to hold the single task currently being processed
    private Task currentlyProcessingTask;

    /**
     * Constructs a new PipelineManager, initializing collections.
     */
    public PipelineManager() {
        // LinkedList is a common implementation of Queue
        this.pendingTasks = new LinkedList<>();
        // ArrayList is a common implementation of List
        this.completedTasks = new ArrayList<>();
        this.currentlyProcessingTask = null; // No task processing initially
    }

    /**
     * Adds a new task to the pending queue.
     * Performs basic validation on description and priority.
     * @param description The task description.
     * @param priority The task priority.
     */
    public void addTask(String description, Priority priority) {
        if (description == null || description.trim().isEmpty()) {
            // Use System.err for error messages
            System.err.println("Error: Task description cannot be empty.");
            return; // Stop execution of this method
        }
        if (priority == null) {
             // This case should ideally be caught by input validation before calling,
             // but included for robustness.
             System.err.println("Error: Task priority cannot be null (internal error or invalid input).");
             return;
        }
        Task newTask = new Task(description, priority);
        // offer() is the preferred way to add to a queue
        pendingTasks.offer(newTask);
        // Use System.out for normal confirmation messages
        System.out.println("Added task: " + newTask);
    }

    /**
     * Attempts to move the next pending task to the processing state.
     * Checks if a task is already processing or if the queue is empty.
     * @return The task being processed, or null if the operation failed.
     */
    public Task processNextTask() {
        if (currentlyProcessingTask != null) {
            // Use System.err for operational errors
            System.err.println("Error: A task (ID " + currentlyProcessingTask.getId() + ") is already being processed.");
            return null;
        }

        // poll() retrieves and removes the head, returns null if queue is empty
        Task taskToProcess = pendingTasks.poll();
        if (taskToProcess != null) {
            currentlyProcessingTask = taskToProcess;
            currentlyProcessingTask.setStatus(Status.PROCESSING);
            // Use System.out for successful operation messages
            System.out.println("Started processing task: " + currentlyProcessingTask);
        } else {
            // Use System.out for informational messages about state
            System.out.println("No pending tasks to process.");
        }
        return currentlyProcessingTask;
    }

    /**
     * Attempts to complete the task currently being processed.
     * Moves it to the completed list and clears the processing slot.
     * Checks if a task is currently processing.
     * @return The completed task, or null if the operation failed.
     */
    public Task completeCurrentTask() {
        if (currentlyProcessingTask == null) {
            // Use System.err for operational errors
            System.err.println("Error: No task is currently being processed.");
            return null;
        }

        currentlyProcessingTask.setStatus(Status.COMPLETED);
        completedTasks.add(currentlyProcessingTask); // Add to the completed list
        // Use System.out for successful operation messages
        System.out.println("Completed task: " + currentlyProcessingTask);
        Task completed = currentlyProcessingTask; // Store reference before clearing
        currentlyProcessingTask = null; // Clear the processing slot
        return completed;
    }

    /**
     * Returns the queue of tasks currently in the PENDING state.
     * @return The Queue of pending tasks.
     */
    public Queue<Task> getPendingTasks() {
        // Returning the direct reference allows iteration/inspection
        return pendingTasks;
    }

    /**
     * Returns the list of tasks that are in the COMPLETED state.
     * @return The List of completed tasks.
     */
    public List<Task> getCompletedTasks() {
        // Returning the direct reference allows iteration/inspection
        return completedTasks;
    }

     /**
     * Returns the task currently being processed.
     * @return The task being processed, or null if none.
     */
    public Task getCurrentlyProcessingTask() {
        return currentlyProcessingTask;
    }
}

/**
 * Main application class to handle user interaction and manage the pipeline simulation.
 */
public class PipelineApp {

    public static void main(String[] args) {
        // Use Scanner for all user input
        Scanner scanner = new Scanner(System.in);
        PipelineManager manager = new PipelineManager();

        int choice = -1; // Initialize choice outside the loop

        // Main application loop continues until user chooses to exit (option 6)
        while (choice != 6) {
            printMenu();
            System.out.print("Enter your choice: ");

            // Use try-catch for robust input handling, specifically for Scanner issues
            try {
                // Attempt to read an integer for the menu choice
                choice = scanner.nextInt();
                // Consume the newline character left-over after reading the integer
                scanner.nextLine();

                // Use switch statement for menu selection
                switch (choice) {
                    case 1: // Add New Task
                        System.out.print("Enter task description: ");
                        String description = scanner.nextLine();
                        System.out.print("Enter task priority (HIGH, MEDIUM, LOW): ");
                        String priorityString = scanner.nextLine();
                        // Validate priority input using the enum helper method
                        Priority priority = Priority.fromString(priorityString);

                        if (priority != null) {
                            manager.addTask(description, priority);
                        } else {
                            // Use System.err for invalid input errors
                            System.err.println("Invalid priority entered. Please use HIGH, MEDIUM, or LOW.");
                        }
                        break;

                    case 2: // Process Next Task
                        manager.processNextTask();
                        break;

                    case 3: // Complete Current Task
                        manager.completeCurrentTask();
                        break;

                    case 4: // View Pending Tasks
                        System.out.println("\n--- Pending Tasks ---");
                        Queue<Task> pending = manager.getPendingTasks();
                        if (pending.isEmpty()) {
                            System.out.println("No pending tasks.");
                        } else {
                            // Iterate over the Queue without removing elements
                            // For-each loop or stream() can be used
                            pending.forEach(System.out::println);
                        }
                        System.out.println("---------------------\n");
                        break;

                    case 5: // View Completed Tasks
                        System.out.println("\n--- Completed Tasks ---");
                        List<Task> completed = manager.getCompletedTasks();
                        if (completed.isEmpty()) {
                            System.out.println("No completed tasks.");
                        } else {
                            // Iterate over the List
                            completed.forEach(System.out::println);
                        }
                        System.out.println("-----------------------\n");
                        break;

                    case 6: // Exit
                        System.out.println("Exiting Pipeline Simulator. Goodbye!");
                        break;

                    default:
                        // Use System.err for invalid menu choices
                        System.err.println("Invalid choice. Please enter a number between 1 and 6.");
                        break;
                }
            } catch (InputMismatchException e) {
                // Catch exception if user enters non-integer input for menu choice
                System.err.println("Invalid input. Please enter a number for your choice.");
                // Consume the invalid input from the scanner buffer to prevent infinite loop
                scanner.nextLine();
                choice = -1; // Reset choice to an invalid value to continue the loop
            } catch (Exception e) {
                 // Catch any other unexpected runtime errors during the switch processing
                 // While InputMismatchException is the most likely, a general catch
                 // provides robustness for unforeseen issues in exam context.
                 System.err.println("An unexpected error occurred: " + e.getMessage());
                 // e.printStackTrace(); // Optional: uncomment for detailed debugging in exam
            }
        }

        // Close the scanner when the application exits
        scanner.close();
    }

    /**
     * Prints the main menu options to the console.
     */
    private static void printMenu() {
        // Use System.out for normal output
        System.out.println("\n--- Pipeline Menu ---");
        System.out.println("1. Add New Task");
        System.out.println("2. Process Next Task");
        System.out.println("3. Complete Current Task");
        System.out.println("4. View Pending Tasks");
        System.out.println("5. View Completed Tasks");
        System.out.println("6. Exit");
        System.out.println("---------------------");
    }
}
