/*
 * Exam Question #469
 * Generated on: 2025-05-11 23:15:44
 * Generated by: Account 3
 * 
 * QUESTION:
 * ## Java Programming Exam: Advanced Task Management System
 * 
 * **Objective:** Design and implement a console-based Task Management System that allows users to add, process, and view tasks. This system should demonstrate your understanding of core Java collections, input handling, control flow, and exception handling.
 * 
 * **Scenario:** You are building a simplified system for managing support tickets or tasks. Tasks are added to a queue for processing in the order they arrive. Once processed, they are moved to a list of completed tasks.
 * 
 * **Requirements:**
 * 
 * 1.  **Task Representation:** Create a class named `Task` with the following private fields:
 *     *   `id` (int): A unique identifier for the task.
 *     *   `description` (String): A brief description of the task.
 *     *   `status` (String): The current status of the task (e.g., "Pending", "Completed").
 *     *   Include a constructor, public getter methods for all fields, and a public method `markAsCompleted()` that updates the `status` field.
 *     *   Override the `toString()` method to provide a clear representation of the task.
 * 
 * 2.  **Task Management System:** Create a class named `TaskManagementSystem` that contains the main logic.
 *     *   It must have a private field that is a `Queue<Task>` to hold tasks waiting to be processed. Use an implementation of `Queue` like `java.util.LinkedList`.
 *     *   It must have a private field that is a `List<Task>` to hold completed tasks. Use `java.util.ArrayList` and declare the field type as `List`.
 *     *   It must use a `java.util.Scanner` to read user input from the console.
 *     *   It must use a private integer field, `nextTaskId`, initialized to 1, to automatically generate unique task IDs.
 * 
 * 3.  **Functionality (Menu-Driven):** The system should present a menu to the user and perform actions based on their choice using a `switch` statement. The main loop should continue until the user chooses to exit.
 *     *   **Add New Task:** Prompt the user for a task description. Create a new `Task` object with the next available ID (increment `nextTaskId`), the provided description, and initial status "Pending". Add this task to the pending tasks queue. Implement input validation: the description cannot be empty. If empty, print an error message to `System.err` and do not add the task.
 *     *   **Process Next Task:** Remove the task at the front of the pending tasks queue. If the queue is empty, print an error message to `System.err`. If a task is successfully removed, call its `markAsCompleted()` method and add it to the completed tasks list. Print a confirmation message to `System.out`.
 *     *   **View Pending Tasks:** Iterate through the pending tasks queue and print the details of each task using its `toString()` method to `System.out`. If the queue is empty, print a message indicating so to `System.out`.
 *     *   **View Completed Tasks:** Iterate through the completed tasks list and print the details of each task using its `toString()` method to `System.out`. If the list is empty, print a message indicating so to `System.out`.
 *     *   **Exit:** Terminate the program.
 * 
 * 4.  **Error Handling:**
 *     *   Use `try-catch` blocks to handle potential errors.
 *     *   Specifically handle cases where the user might enter non-integer input for the menu choice (e.g., using `Scanner.nextInt()` or parsing). Reading the input as a String and parsing is a robust approach.
 *     *   Implement class-wide exception handling using a `try-catch(Exception e)` block around the main application loop in the method that runs the system, printing a general error message and the exception details to `System.err` if an unexpected error occurs.
 * 
 * 5.  **Output:**
 *     *   All normal program output (menu, task details, confirmation messages) must go to `System.out`.
 *     *   All error messages (invalid input, empty queue/list operations, unexpected exceptions) must go to `System.err`.
 * 
 * 6.  **Best Practices:**
 *     *   Use meaningful variable and method names.
 *     *   Add appropriate comments to explain complex parts or logic.
 *     *   Ensure proper encapsulation in the `Task` class.
 *     *   Maintain clean code structure (separate methods for different actions).
 * 
 * **Expected Output Structure:**
 * 
 * ```
 * --- Task Management System ---
 * 1. Add New Task
 * 2. Process Next Task
 * 3. View Pending Tasks
 * 4. View Completed Tasks
 * 5. Exit
 * Enter your choice: [user input]
 * 
 * [Depending on choice:]
 * - If Add:
 *   Enter task description: [user input]
 *   Task added: [Task details via toString()]
 *   (or error message to System.err if description empty)
 * - If Process:
 *   Processing next task...
 *   Task processed: [Task details via toString()]
 *   (or error message to System.err if queue empty)
 * - If View Pending:
 *   --- Pending Tasks ---
 *   [Task details via toString()]
 *   [Task details via toString()]
 *   ...
 *   (or "No pending tasks." message to System.out)
 * - If View Completed:
 *   --- Completed Tasks ---
 *   [Task details via toString()]
 *   [Task details via toString()]
 *   ...
 *   (or "No completed tasks." message to System.out)
 * - If Exit:
 *   Exiting Task Management System.
 * - If invalid choice:
 *   Invalid choice. Please try again. (to System.err)
 * - If unexpected error:
 *   An unexpected error occurred: [exception details] (to System.err)
 * ```
 * 
 * Implement the complete Java code for this system.
 *
 * EXPLANATION:
 * This solution implements a simple console-based Task Management System as required, demonstrating the use of all specified Java components and following best practices.
 * 
 * 1.  **`Task` Class:**
 *     *   Represents individual tasks with `id`, `description`, and `status`.
 *     *   Uses `private` fields and `public` getters for encapsulation.
 *     *   Includes a `markAsCompleted()` method to change the status, adhering to the principle that an object should manage its own state.
 *     *   Overrides `toString()` for easy printing of task details.
 * 
 * 2.  **`TaskManagementSystem` Class:**
 *     *   **Collections:**
 *         *   `private Queue<Task> pendingTasks = new LinkedList<>();`: A `Queue` is used to store tasks waiting for processing. `LinkedList` is a common implementation of the `Queue` interface, providing FIFO (First-In, First-Out) behavior, suitable for processing tasks in the order they are added.
 *         *   `private List<Task> completedTasks = new ArrayList<>();`: A `List` (specifically `ArrayList`) is used to store tasks after they have been processed. `ArrayList` provides dynamic resizing and efficient access to completed tasks. The field is declared using the `List` interface type, promoting good practice (programming to interfaces).
 *     *   **Input:**
 *         *   `private Scanner scanner = new Scanner(System.in);`: Used to read user input from the console.
 *     *   **Task ID Generation:**
 *         *   `private int nextTaskId = 1;`: A simple counter to ensure each task gets a unique ID, incremented each time a new task is created.
 *     *   **Methods:**
 *         *   `displayMenu()`: Prints the options to `System.out`.
 *         *   `addNewTask()`: Prompts for description, validates it's not empty (using `String.trim()` and `isEmpty()`). If valid, it creates a new `Task` with the next ID and "Pending" status and adds it to the `pendingTasks` queue using `offer()`. Error messages for empty descriptions go to `System.err`. Success messages go to `System.out`.
 *         *   `processNextTask()`: Uses `pendingTasks.poll()` to retrieve and remove the head of the queue. If `poll()` returns `null` (queue is empty), an error is printed to `System.err`. Otherwise, it calls `markAsCompleted()` on the task and adds it to the `completedTasks` list. Confirmation goes to `System.out`.
 *         *   `viewPendingTasks()`: Iterates through the `pendingTasks` queue using an enhanced for loop and prints each task's `toString()` representation to `System.out`. Checks if the queue is empty first.
 *         *   `viewCompletedTasks()`: Iterates through the `completedTasks` list using an enhanced for loop and prints each task's `toString()` representation to `System.out`. Checks if the list is empty first.
 *         *   `run()`: This is the main method driving the system. It contains the application loop (`while(running)`).
 *             *   **Class-wide Exception Handling:** The entire `while` loop is wrapped in a `try-catch(Exception e)` block. This catches any unhandled runtime exceptions that might occur within the loop, preventing the program from crashing abruptly and printing an error message and stack trace to `System.err`.
 *             *   **Menu Input Handling:** Inside the loop, it calls `displayMenu()`, reads the user's choice as a `String` using `scanner.nextLine()`.
 *             *   **Input Validation & Specific Exception Handling:** It then uses a nested `try-catch(NumberFormatException e)` block to attempt to parse the input string into an integer using `Integer.parseInt()`. This specifically handles cases where the user enters non-numeric input, printing an error to `System.err` without crashing.
 *             *   **Control Flow:** A `switch` statement is used on the parsed integer choice to call the appropriate method (`addNewTask`, `processNextTask`, etc.) or set the `running` flag to `false` for the "Exit" option. A `default` case handles invalid integer choices.
 *             *   **Resource Management:** A `finally` block is used to ensure the `Scanner` is closed when the `run` method finishes (either normally or due to an exception), releasing the system resource.
 *     *   **`main` Method:** Creates an instance of `TaskManagementSystem` and calls its `run()` method to start the application.
 * 
 * This solution effectively integrates the required components (`Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.err`, `System.out`, `try-catch`), demonstrates practical task management logic, and adheres to good programming practices like encapsulation, clear naming, and robust error handling.
 */

import java.util.Queue;
import java.util.LinkedList;
import java.util.List;
import java.util.ArrayList;
import java.util.Scanner;
import java.util.InputMismatchException; // Although we will read as String for robustness

/**
 * Represents a single task in the Task Management System.
 * Follows encapsulation principles.
 */
class Task {
    private int id;
    private String description;
    private String status;

    /**
     * Constructs a new Task.
     * @param id The unique ID of the task.
     * @param description The description of the task.
     */
    public Task(int id, String description) {
        this.id = id;
        this.description = description;
        this.status = "Pending"; // Initial status
    }

    // --- Getters ---
    public int getId() {
        return id;
    }

    public String getDescription() {
        return description;
    }

    public String getStatus() {
        return status;
    }

    /**
     * Marks the task's status as "Completed".
     */
    public void markAsCompleted() {
        this.status = "Completed";
    }

    /**
     * Provides a string representation of the Task.
     * @return A formatted string describing the task.
     */
    @Override
    public String toString() {
        return String.format("Task ID: %d, Description: \"%s\", Status: %s",
                             id, description, status);
    }
}

/**
 * Manages tasks using a queue for pending and a list for completed tasks.
 * Provides a menu-driven interface.
 */
public class TaskManagementSystem {

    private Queue<Task> pendingTasks;
    private List<Task> completedTasks;
    private Scanner scanner;
    private int nextTaskId;

    /**
     * Constructs a new TaskManagementSystem.
     * Initializes collections and scanner.
     */
    public TaskManagementSystem() {
        // Use LinkedList as a Queue implementation
        this.pendingTasks = new LinkedList<>();
        // Use ArrayList as a List implementation
        this.completedTasks = new ArrayList<>();
        this.scanner = new Scanner(System.in);
        this.nextTaskId = 1; // Start task IDs from 1
    }

    /**
     * Displays the main menu options to the user.
     */
    private void displayMenu() {
        System.out.println("\n--- Task Management System ---");
        System.out.println("1. Add New Task");
        System.out.println("2. Process Next Task");
        System.out.println("3. View Pending Tasks");
        System.out.println("4. View Completed Tasks");
        System.out.println("5. Exit");
        System.out.print("Enter your choice: ");
    }

    /**
     * Adds a new task based on user input.
     * Validates description input.
     */
    private void addNewTask() {
        System.out.print("Enter task description: ");
        // Consume the newline character left by previous nextInt() or nextLine() if any
        // Although we read choice as string, this is good practice after other next() methods.
        // scanner.nextLine(); // Not strictly needed if only nextLine() is used for descriptions

        String description = scanner.nextLine().trim(); // Read entire line and trim whitespace

        if (description.isEmpty()) {
            System.err.println("Error: Task description cannot be empty.");
            return; // Do not add the task
        }

        Task newTask = new Task(nextTaskId++, description);
        pendingTasks.offer(newTask); // Add to the end of the queue

        System.out.println("Task added: " + newTask);
    }

    /**
     * Processes the next task in the pending queue.
     * Moves the task to the completed list.
     */
    private void processNextTask() {
        // poll() retrieves and removes the head of the queue, returns null if queue is empty
        Task taskToProcess = pendingTasks.poll();

        if (taskToProcess == null) {
            System.err.println("Error: No pending tasks to process.");
        } else {
            System.out.println("Processing next task...");
            taskToProcess.markAsCompleted();
            completedTasks.add(taskToProcess); // Add to the completed list
            System.out.println("Task processed: " + taskToProcess);
        }
    }

    /**
     * Displays all tasks currently in the pending queue.
     */
    private void viewPendingTasks() {
        System.out.println("\n--- Pending Tasks ---");
        if (pendingTasks.isEmpty()) {
            System.out.println("No pending tasks.");
        } else {
            // Iterate without removing elements from the queue
            for (Task task : pendingTasks) {
                System.out.println(task);
            }
        }
    }

    /**
     * Displays all tasks currently in the completed list.
     */
    private void viewCompletedTasks() {
        System.out.println("\n--- Completed Tasks ---");
        if (completedTasks.isEmpty()) {
            System.out.println("No completed tasks.");
        } else {
            for (Task task : completedTasks) {
                System.out.println(task);
            }
        }
    }

    /**
     * Runs the main application loop, handling user interaction.
     * Includes class-wide exception handling.
     */
    public void run() {
        boolean running = true;

        // Class-wide try-catch block for general exceptions during the main loop
        try {
            while (running) {
                displayMenu();

                String choiceString = scanner.nextLine(); // Read choice as String

                try {
                    int choice = Integer.parseInt(choiceString); // Attempt to parse as integer

                    // Use switch statement for menu control flow
                    switch (choice) {
                        case 1:
                            addNewTask();
                            break;
                        case 2:
                            processNextTask();
                            break;
                        case 3:
                            viewPendingTasks();
                            break;
                        case 4:
                            viewCompletedTasks();
                            break;
                        case 5:
                            running = false; // Set flag to exit loop
                            System.out.println("Exiting Task Management System.");
                            break;
                        default:
                            // Handle choices outside the valid range
                            System.err.println("Invalid choice. Please enter a number between 1 and 5.");
                            break;
                    }
                } catch (NumberFormatException e) {
                    // Handle cases where input is not a valid integer
                    System.err.println("Invalid input. Please enter a number.");
                }
            }
        } catch (Exception e) {
            // Catch any other unexpected runtime exceptions
            System.err.println("An unexpected error occurred:");
            e.printStackTrace(System.err); // Print stack trace to System.err
        } finally {
            // Ensure the scanner is closed when the application exits
            if (scanner != null) {
                scanner.close();
            }
        }
    }

    /**
     * Main method to start the Task Management System.
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        TaskManagementSystem system = new TaskManagementSystem();
        system.run(); // Start the system's main loop
    }
}
