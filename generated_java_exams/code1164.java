/*
 * Exam Question #1164
 * Generated on: 2025-05-12 17:33:57
 * Generated by: Account 4
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Production Line Task Manager
 * 
 * **Scenario:**
 * 
 * You are tasked with developing a simplified **Production Line Task Manager**. This system simulates a production line where tasks arrive, are placed in a queue, processed one by one, and then sorted into either a 'finished' or 'rejected' list based on the processing outcome. The system should interact with a user through a command-line interface.
 * 
 * **Requirements:**
 * 
 * 1.  **Core Functionality:**
 *     *   Allow the user to add new tasks to a processing queue. Each task should have a unique ID (String) and a description (String).
 *     *   Allow the user to initiate the processing of the next task from the front of the queue.
 *     *   Simulate the processing: Tasks with an ID containing the case-insensitive substring "FAIL" should fail processing. All other tasks succeed.
 *     *   Successfully processed tasks should be moved from the queue to a list of finished tasks.
 *     *   Tasks that fail processing should be moved from the queue to a list of rejected tasks.
 *     *   Allow the user to view the current tasks waiting in the queue.
 *     *   Allow the user to view the tasks in the finished list.
 *     *   Allow the user to view the tasks in the rejected list.
 *     *   Allow the user to exit the application.
 * 
 * 2.  **Required Java Components:** Your solution MUST use and demonstrate the practical application of ALL the following Java components:
 *     *   `java.util.Queue` (use an appropriate implementing class)
 *     *   `java.util.ArrayList`
 *     *   `java.util.List` interface (declare list variables using this interface)
 *     *   `java.util.Scanner` for reading user input from the console.
 *     *   `switch` statement for handling the user's menu choices.
 *     *   `System.err` for printing error messages (e.g., invalid input, processing errors).
 *     *   `System.out` for printing normal output (menu, prompts, task information, success messages).
 *     *   Class-wide exception handling with `try-catch` blocks. This should include handling specific expected exceptions (like processing an empty queue, invalid input format) and a general catch for unexpected errors in the main application loop.
 * 
 * 3.  **Best Practices:** Your code should adhere to the following best practices:
 *     *   **Encapsulation:** Use private fields and public methods where appropriate.
 *     *   **Meaningful Names:** Use descriptive names for classes, variables, and methods.
 *     *   **Documentation:** Include appropriate comments, especially Javadoc for classes and methods.
 *     *   **Input Validation:** Validate user input where necessary (e.g., ensure task ID is not empty, handle non-numeric menu input).
 *     *   **Proper Error Handling:** Implement robust error handling for potential issues (empty queue processing, invalid input, unexpected errors). Use `System.err` for error output.
 *     *   **Clean Code Structure:** Organize your code into appropriate classes and packages (optional but recommended).
 * 
 * **Implementation Details:**
 * 
 * *   Create a `Task` class to represent tasks.
 * *   Create a `ProductionLine` class to manage the queue and lists, and handle task processing.
 * *   Create a main application class (e.g., `ProductionLineApp`) with the `main` method to handle user interaction, menu display, and coordinate operations using the `ProductionLine` object.
 * *   Implement a simple menu loop in the main class.
 * *   Handle the case where the user tries to process a task when the queue is empty.
 * 
 * **Expected Output:**
 * 
 * Your program should display a menu, prompt the user for input, and display results or error messages accordingly. Error messages should be directed to `System.err`. List/Queue views should clearly number the items.
 * 
 * **Example Interaction Flow (Illustrative):**
 * 
 * ```
 * --- Production Line Task Manager ---
 * --- Menu ---
 * 1. Add New Task
 * 2. Process Next Task
 * 3. View Task Queue
 * 4. View Finished Tasks
 * 5. View Rejected Tasks
 * 6. Exit
 * ------------
 * Enter your choice: 1
 * Enter Task ID: Task001
 * Enter Task Description: Assemble Part A
 * Task 'Task001' added to queue.
 * 
 * --- Menu ---
 * ...
 * Enter your choice: 1
 * Enter Task ID: TaskFAIL
 * Enter Task Description: Quality Check
 * Task 'TaskFAIL' added to queue.
 * 
 * --- Menu ---
 * ...
 * Enter your choice: 3
 * --- Current Task Queue ---
 * 1. Task{ID='Task001', Desc='Assemble Part A'}
 * 2. Task{ID='TaskFAIL', Desc='Quality Check'}
 * --------------------------
 * 
 * --- Menu ---
 * ...
 * Enter your choice: 2
 * Attempting to process task: Task001...
 * Task Task001 processed successfully.
 * 
 * --- Menu ---
 * ...
 * Enter your choice: 2
 * Attempting to process task: TaskFAIL...
 * Processing failed for task: TaskFAIL. Moving to rejected list. // This line should ideally go to System.err
 * 
 * --- Menu ---
 * ...
 * Enter your choice: 4
 * --- Finished Tasks ---
 * 1. Task{ID='Task001', Desc='Assemble Part A'}
 * ----------------------
 * 
 * --- Menu ---
 * ...
 * Enter your choice: 5
 * --- Rejected Tasks ---
 * 1. Task{ID='TaskFAIL', Desc='Quality Check'}
 * ----------------------
 * 
 * --- Menu ---
 * ...
 * Enter your choice: 2
 * Processing Error: No tasks in the queue to process. // This line should go to System.err
 * 
 * --- Menu ---
 * ...
 * Enter your choice: 7
 * Invalid choice. Please enter a number between 1 and 6. // This line should go to System.err
 * 
 * --- Menu ---
 * ...
 * Enter your choice: exit // Example of non-numeric input
 * Invalid input. Please enter a number. // This line should go to System.err
 * 
 * --- Menu ---
 * ...
 * Enter your choice: 6
 * Exiting Production Line Task Manager. Goodbye!
 * ```
 * 
 * Your solution should be provided as complete, compilable Java code.
 *
 * EXPLANATION:
 * The solution implements a simple Production Line Task Manager application demonstrating the required Java concepts and best practices.
 * 
 * **Overall Design:**
 * The application is structured into four classes:
 * 1.  `Task`: Represents a single task with an ID and description, encapsulating its data. Includes input validation for the ID in its constructor.
 * 2.  `EmptyQueueException`: A custom exception class to specifically signal when a processing attempt is made on an empty queue.
 * 3.  `ProductionLine`: Manages the state of the production line, holding the task queue and the finished/rejected lists. It contains the core logic for adding and processing tasks.
 * 4.  `ProductionLineApp`: Contains the `main` method, handles user interaction, displays the menu, reads input, and orchestrates calls to the `ProductionLine` object based on user choices.
 * 
 * **Required Java Components Usage:**
 * 
 * *   **`java.util.Queue`**: Used in the `ProductionLine` class (`taskQueue`) to store tasks waiting for processing. `LinkedList` is used as the concrete implementation, providing FIFO (First-In, First-Out) behavior suitable for a queue. Methods like `offer()` (for adding) and `poll()` (for retrieving and removing) are used.
 * *   **`java.util.ArrayList`**: Used in the `ProductionLine` class to implement the `finishedTasks` and `rejectedTasks` lists, providing dynamic arrays to store completed and failed tasks.
 * *   **`java.util.List` interface**: Variables `finishedTasks` and `rejectedTasks` in `ProductionLine` are declared using the `List` interface, promoting good practice by programming to the interface rather than the concrete implementation (`ArrayList`).
 * *   **`java.util.Scanner`**: Used in the `ProductionLineApp` class within the `main` method and the `getUserChoice` helper method to read user input from `System.in`. `nextLine()` is used to avoid common pitfalls with mixing `nextInt()` or `nextDouble()` with `nextLine()`.
 * *   **`switch` statement**: Used in the `ProductionLineApp.main` method to control the application flow based on the integer choice entered by the user from the menu.
 * *   **`System.err`**: Used for printing error messages. This includes invalid numeric input in `getUserChoice`, errors adding tasks due to invalid data (`IllegalArgumentException`), processing failure notifications in `ProductionLine.processNextTask`, specific processing errors like an empty queue (`EmptyQueueException`), and unexpected exceptions caught in the main loop.
 * *   **`System.out`**: Used for all normal output, such as printing the menu, prompts for input, confirmation messages for adding tasks, success messages for processing tasks, and displaying the contents of the queue and lists.
 * *   **Class-wide exception handling with `try-catch` blocks**:
 *     *   A large `try-catch (Exception e)` block wraps the main `while` loop in `ProductionLineApp.main`. This serves as a "class-wide" catch-all for any unexpected exceptions that might occur during the application's runtime, preventing the program from crashing abruptly and providing a basic error report (stack trace to `System.err`).
 *     *   Specific `try-catch` blocks are used where expected exceptions might occur:
 *         *   In `getUserChoice` to catch `NumberFormatException` when parsing user input, ensuring the program doesn't crash on non-numeric input and prompts the user again.
 *         *   In `ProductionLineApp.main`'s case 1 (Add Task) to catch `IllegalArgumentException` thrown by the `Task` constructor if the task ID is invalid.
 *         *   In `ProductionLineApp.main`'s case 2 (Process Task) to catch the custom `EmptyQueueException` thrown by `ProductionLine.processNextTask` when the queue is empty.
 * 
 * **Best Practices:**
 * 
 * *   **Encapsulation:** The `Task` and `ProductionLine` classes use `private` fields (`id`, `description`, `taskQueue`, `finishedTasks`, `rejectedTasks`) and provide `public` methods (`getId`, `getDescription`, `addTask`, `processNextTask`, etc.) to control access to their internal state.
 * *   **Meaningful Names:** Class names (`Task`, `ProductionLine`, `ProductionLineApp`, `EmptyQueueException`), variable names (`taskQueue`, `finishedTasks`, `rejectedTasks`, `taskId`, `description`, `choice`), and method names (`addTask`, `processNextTask`, `viewQueue`, `getUserChoice`, `printMenu`) are descriptive and indicate their purpose.
 * *   **Documentation:** Javadoc comments are included for classes and public methods to explain their purpose, parameters, and return values or exceptions.
 * *   **Input Validation:** The `Task` constructor validates the `id` parameter. The `getUserChoice` method validates that the user's menu input is a valid integer using a `try-catch` block.
 * *   **Proper Error Handling:** Specific exceptions are caught and handled appropriately (e.g., `EmptyQueueException` informs the user the queue is empty, `NumberFormatException` prompts for valid input). Error messages are directed to `System.err`. A general catch block in `main` handles unexpected errors gracefully. The `finally` block ensures the `Scanner` is closed.
 * *   **Clean Code Structure:** The code is divided into logical classes, each responsible for a specific part of the system. Helper methods (`printMenu`, `getUserChoice`, `simulateProcessing`) are used to break down functionality and improve readability.
 * 
 * This solution effectively combines various fundamental and intermediate Java concepts to solve a practical problem, demonstrating understanding of data structures, object-oriented principles, user interaction, and robust error handling.
 */

package com.exam.productionline;

import java.util.Queue;
import java.util.LinkedList;
import java.util.List;
import java.util.ArrayList;
import java.util.Scanner;
import java.util.NoSuchElementException; // Although we handle with poll, this is related

/**
 * Represents a single task in the production line.
 */
class Task {
    private String id;
    private String description;

    /**
     * Constructs a new Task.
     *
     * @param id The unique identifier for the task. Cannot be null or empty.
     * @param description A brief description of the task. Can be empty, but not null.
     * @throws IllegalArgumentException if the task ID is null or empty.
     */
    public Task(String id, String description) {
        // Input validation for ID
        if (id == null || id.trim().isEmpty()) {
            throw new IllegalArgumentException("Task ID cannot be null or empty.");
        }
        this.id = id.trim();

        // Handle null description gracefully
        this.description = (description == null) ? "" : description;
    }

    /**
     * Gets the task ID.
     * @return The task ID.
     */
    public String getId() {
        return id;
    }

    /**
     * Gets the task description.
     * @return The task description.
     */
    public String getDescription() {
        return description;
    }

    @Override
    public String toString() {
        return "Task{ID='" + id + "', Desc='" + description + "'}";
    }
}

/**
 * Custom exception for indicating an empty queue condition.
 */
class EmptyQueueException extends Exception {
    /**
     * Constructs a new EmptyQueueException with the specified detail message.
     * @param message The detail message.
     */
    public EmptyQueueException(String message) {
        super(message);
    }
}

/**
 * Manages the production line, including the task queue and finished/rejected task lists.
 */
class ProductionLine {
    // Use Queue interface, implemented by LinkedList for FIFO behavior
    private Queue<Task> taskQueue;
    // Use List interface, implemented by ArrayList for dynamic arrays
    private List<Task> finishedTasks;
    private List<Task> rejectedTasks;

    /**
     * Constructs a new ProductionLine with empty queue and lists.
     */
    public ProductionLine() {
        this.taskQueue = new LinkedList<>();
        this.finishedTasks = new ArrayList<>();
        this.rejectedTasks = new ArrayList<>();
    }

    /**
     * Adds a task to the end of the processing queue.
     * @param task The task to add. Must not be null.
     */
    public void addTask(Task task) {
        if (task != null) {
            taskQueue.offer(task); // offer is the preferred way to add to a bounded queue, works fine for unbounded LinkedList
        } else {
            System.err.println("Attempted to add a null task.");
        }
    }

    /**
     * Processes the next task from the front of the queue.
     * Simulates processing success/failure and moves the task to the appropriate list.
     *
     * @return The task that was processed (either successfully or failed), or null if queue was empty.
     * @throws EmptyQueueException if the task queue is empty.
     */
    public Task processNextTask() throws EmptyQueueException {
        Task task = taskQueue.poll(); // Retrieve and remove the head of the queue, returns null if empty

        if (task == null) {
            throw new EmptyQueueException("No tasks in the queue to process.");
        }

        System.out.println("Attempting to process task: " + task.getId() + "...");

        // Simulate processing logic: fail if ID contains "FAIL"
        boolean success = simulateProcessing(task);

        if (success) {
            System.out.println("Task " + task.getId() + " processed successfully.");
            finishedTasks.add(task);
        } else {
            // Use System.err for failure messages as per requirements
            System.err.println("Processing failed for task: " + task.getId() + ". Moving to rejected list.");
            rejectedTasks.add(task);
        }
        return task; // Return the task that was just processed (regardless of outcome)
    }

    /**
     * Simulates the processing logic for a task.
     * @param task The task to simulate processing for.
     * @return true if processing is simulated as successful, false otherwise.
     */
    private boolean simulateProcessing(Task task) {
        // Simple simulation: fail if task ID contains "FAIL" (case-insensitive)
        return !task.getId().toUpperCase().contains("FAIL");
    }

    /**
     * Displays the tasks currently waiting in the queue.
     */
    public void viewQueue() {
        System.out.println("\n--- Current Task Queue ---");
        if (taskQueue.isEmpty()) {
            System.out.println("Queue is empty.");
        } else {
            // Iterate through the queue without removing elements
            int index = 1;
            for (Task task : taskQueue) {
                System.out.println(index++ + ". " + task);
            }
        }
        System.out.println("--------------------------");
    }

    /**
     * Displays the tasks that have been successfully finished.
     */
    public void viewFinishedTasks() {
        System.out.println("\n--- Finished Tasks ---");
        if (finishedTasks.isEmpty()) {
            System.out.println("No tasks finished yet.");
        } else {
            for (int i = 0; i < finishedTasks.size(); i++) {
                System.out.println((i + 1) + ". " + finishedTasks.get(i));
            }
        }
        System.out.println("----------------------");
    }

    /**
     * Displays the tasks that failed processing and were rejected.
     */
    public void viewRejectedTasks() {
        System.out.println("\n--- Rejected Tasks ---");
        if (rejectedTasks.isEmpty()) {
            System.out.println("No tasks rejected yet.");
        } else {
            for (int i = 0; i < rejectedTasks.size(); i++) {
                System.out.println((i + 1) + ". " + rejectedTasks.get(i));
            }
        }
        System.out.println("----------------------");
    }
}

/**
 * Main application class for the Production Line Task Manager.
 * Handles user interaction and the main application loop.
 */
public class ProductionLineApp {

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        ProductionLine productionLine = new ProductionLine();

        // Class-wide exception handling: Wrap the main application loop
        try {
            System.out.println("--- Production Line Task Manager ---");

            while (true) {
                printMenu();
                int choice = getUserChoice(scanner); // Helper method for input with validation

                // Use a switch statement for menu navigation
                switch (choice) {
                    case 1: // Add New Task
                        System.out.print("Enter Task ID: ");
                        String taskId = scanner.nextLine();
                        System.out.print("Enter Task Description: ");
                        String taskDescription = scanner.nextLine();
                        try {
                            // Task constructor handles ID validation, throws IllegalArgumentException
                            Task newTask = new Task(taskId, taskDescription);
                            productionLine.addTask(newTask);
                            System.out.println("Task '" + newTask.getId() + "' added to queue.");
                        } catch (IllegalArgumentException e) {
                            // Use System.err for input validation errors
                            System.err.println("Error adding task: " + e.getMessage());
                        }
                        break;

                    case 2: // Process Next Task
                        try {
                            Task processedTask = productionLine.processNextTask();
                            // productionLine.processNextTask() prints success/failure messages internally
                            // and handles adding to the appropriate lists.
                            // We just need to catch exceptions here.
                        } catch (EmptyQueueException e) {
                            // Use System.err for specific expected errors like empty queue
                            System.err.println("Processing Error: " + e.getMessage());
                        } catch (Exception e) {
                             // Catch any other unexpected errors during processing
                             System.err.println("An unexpected error occurred during task processing: " + e.getMessage());
                             e.printStackTrace(System.err); // Print stack trace for debugging
                        }
                        break;

                    case 3: // View Queue
                        productionLine.viewQueue();
                        break;

                    case 4: // View Finished Tasks
                        productionLine.viewFinishedTasks();
                        break;

                    case 5: // View Rejected Tasks
                        productionLine.viewRejectedTasks();
                        break;

                    case 6: // Exit
                        System.out.println("Exiting Production Line Task Manager. Goodbye!");
                        return; // Exit the application

                    default:
                        // Use System.out for general invalid menu choices (not input format error)
                        System.out.println("Invalid choice. Please enter a number between 1 and 6.");
                }
                System.out.println(); // Add a blank line for readability between operations
            }
        } catch (Exception e) {
            // General catch block for any unexpected exceptions that escape specific handlers
            // This provides "class-wide" handling for the main application execution flow
            System.err.println("\nAn unexpected critical error occurred during application execution:");
            e.printStackTrace(System.err); // Print stack trace to System.err for debugging
        } finally {
            // Ensure the scanner resource is closed regardless of how the application exits
            if (scanner != null) {
                scanner.close();
            }
            System.out.println("Scanner closed."); // Optional: Confirmation of cleanup
        }
    }

    /**
     * Prints the main menu options to the console using System.out.
     */
    private static void printMenu() {
        System.out.println("--- Menu ---");
        System.out.println("1. Add New Task");
        System.out.println("2. Process Next Task");
        System.out.println("3. View Task Queue");
        System.out.println("4. View Finished Tasks");
        System.out.println("5. View Rejected Tasks");
        System.out.println("6. Exit");
        System.out.println("------------");
    }

    /**
     * Reads the user's menu choice from the console using Scanner.
     * Handles non-numeric input using try-catch and System.err.
     * Loops until valid integer input is received.
     *
     * @param scanner The Scanner object for reading input.
     * @return The valid integer choice entered by the user.
     */
    private static int getUserChoice(Scanner scanner) {
        while (true) { // Loop until valid input is received
            System.out.print("Enter your choice: ");
            try {
                // Use nextLine() to read the entire line to avoid issues with nextInt()
                String input = scanner.nextLine();
                return Integer.parseInt(input); // Attempt to parse the input string as an integer
            } catch (NumberFormatException e) {
                // Use System.err for input format errors
                System.err.println("Invalid input. Please enter a number.");
                // Loop continues automatically
            }
        }
    }
}
