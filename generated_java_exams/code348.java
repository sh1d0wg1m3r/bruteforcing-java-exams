/*
 * Exam Question #348
 * Generated on: 2025-05-11 22:58:47
 * Generated by: Account 2
 * 
 * QUESTION:
 * ## Advanced Java Programming Exam Task: Task Management System
 * 
 * **Scenario:**
 * 
 * You are required to develop a simple command-line Task Management System for a small team. The system should allow users to add tasks, complete the next task in line, view pending tasks, and view completed tasks.
 * 
 * **Requirements:**
 * 
 * Implement a Java application that simulates this task management system. Your solution must adhere to the following technical specifications and best practices:
 * 
 * 1.  **Core Data Structures:**
 *     *   Use `java.util.Queue` to manage the pending tasks. Tasks should be processed in a FIFO (First-In, First-Out) manner.
 *     *   Use `java.util.ArrayList` to store the completed tasks.
 *     *   Ensure methods that return lists of tasks use the `java.util.List` interface as the return type.
 * 
 * 2.  **User Interaction:**
 *     *   Use `java.util.Scanner` to read user commands and input from the console.
 *     *   Implement the following commands:
 *         *   `add <description> <priority>`: Adds a new task to the pending queue. Priority must be one of "High", "Medium", or "Low" (case-insensitive).
 *         *   `complete`: Removes the next task from the pending queue and moves it to the completed list.
 *         *   `view pending`: Displays all tasks currently in the pending queue.
 *         *   `view completed`: Displays all tasks in the completed list.
 *         *   `exit`: Terminates the application.
 * 
 * 3.  **Flow Control and Output:**
 *     *   Use a `switch` statement to process the different user commands.
 *     *   Use `System.out` for all normal output (prompts, success messages, task lists).
 *     *   Use `System.err` for all error messages (e.g., invalid command, invalid priority, missing arguments, no pending tasks to complete).
 * 
 * 4.  **Error Handling:**
 *     *   Implement class-wide exception handling using `try-catch` blocks around the main command processing loop to catch unexpected runtime errors.
 *     *   Implement specific input validation (e.g., for command format, priority values).
 * 
 * 5.  **Object-Oriented Design & Best Practices:**
 *     *   Create a `Task` class with appropriate private fields (e.g., task ID, description, priority) and public getter methods.
 *     *   Create a `TaskManager` class that encapsulates the `Queue` of pending tasks and the `List` of completed tasks. It should contain public methods for adding, completing, and viewing tasks.
 *     *   Use meaningful variable and method names.
 *     *   Include basic comments or JavaDocs explaining the purpose of classes and key methods.
 *     *   Ensure proper encapsulation by making fields private.
 * 
 * **Task Details:**
 * 
 * *   Each task should have a unique integer ID, automatically assigned starting from 1.
 * *   Priority validation should accept "High", "Medium", or "Low" regardless of case.
 * 
 * **Expected Output Examples:**
 * 
 * ```
 * Task Management System
 * Commands: add <description> <priority>, complete, view pending, view completed, exit
 * > add Write Report High
 * Task added: Task{id=1, description='Write Report', priority='High'}
 * > add Prepare Presentation Medium
 * Task added: Task{id=2, description='Prepare Presentation', priority='Medium'}
 * > view pending
 * Pending Tasks:
 * - Task{id=1, description='Write Report', priority='High'}
 * - Task{id=2, description='Prepare Presentation', priority='Medium'}
 * > complete
 * Completed task: Task{id=1, description='Write Report', priority='High'}
 * > view completed
 * Completed Tasks:
 * - Task{id=1, description='Write Report', priority='High'}
 * > view pending
 * Pending Tasks:
 * - Task{id=2, description='Prepare Presentation', priority='Medium'}
 * > add Code Review Low
 * Task added: Task{id=3, description='Code Review', priority='Low'}
 * > complete
 * Completed task: Task{id=2, description='Prepare Presentation', priority='Medium'}
 * > view pending
 * Pending Tasks:
 * - Task{id=3, description='Code Review', priority='Low'}
 * > complete
 * Completed task: Task{id=3, description='Code Review', priority='Low'}
 * > complete
 * No pending tasks to complete.
 * > view pending
 * No pending tasks.
 * > view completed
 * Completed Tasks:
 * - Task{id=1, description='Write Report', priority='High'}
 * - Task{id=2, description='Prepare Presentation', priority='Medium'}
 * - Task{id=3, description='Code Review', priority='Low'}
 * > add Invalid Priority Test
 * Usage: add <description> <priority>
 * > add Another Task InvalidPriority
 * Invalid priority. Use High, Medium, or Low.
 * > exit
 * Exiting Task Management System. Goodbye!
 * ```
 * 
 * Your solution should be a single Java file containing all necessary classes.
 *
 * EXPLANATION:
 * The provided solution implements a simple command-line Task Management System in Java, fulfilling all specified requirements.
 * 
 * 1.  **`Task` Class:** This class represents a single task with private fields for `id`, `description`, and `priority`. It includes a constructor to initialize these fields and public getter methods (`getId`, `getDescription`, `getPriority`) for accessing the data, demonstrating proper encapsulation. The `toString()` method provides a convenient string representation for printing tasks.
 * 
 * 2.  **`TaskManager` Class:** This class acts as the core logic handler.
 *     *   It uses a `java.util.Queue<Task>` named `pendingTasks` (implemented by `java.util.LinkedList`) to store tasks awaiting completion. The `Queue` interface ensures FIFO behavior, which is suitable for processing tasks in the order they were added.
 *     *   It uses a `java.util.List<Task>` named `completedTasks` (implemented by `java.util.ArrayList`) to store tasks that have been completed. `ArrayList` provides a dynamic array structure suitable for storing a growing list of completed items.
 *     *   `nextTaskId` is a simple counter to assign unique IDs to new tasks.
 *     *   `addTask(String description, String priority)`: Creates a new `Task` object with the next available ID and adds it to the `pendingTasks` queue using `offer()`. `offer()` is generally preferred over `add()` for queues as it handles potential capacity restrictions gracefully (though `LinkedList` doesn't have a fixed capacity).
 *     *   `completeNextTask()`: Uses `poll()` to retrieve and remove the head of the `pendingTasks` queue. `poll()` returns `null` if the queue is empty, which is handled to print an appropriate error message using `System.err`. If a task is retrieved, it's added to the `completedTasks` list.
 *     *   `getPendingTasks()`: Returns a `List<Task>` representation of the current pending tasks. A new `ArrayList` is created from the queue's elements to return a `List` interface type without exposing the internal `Queue` implementation directly.
 *     *   `getCompletedTasks()`: Returns the `completedTasks` `ArrayList`, declared as a `List<Task>`, demonstrating the use of the `List` interface.
 * 
 * 3.  **`TaskApp` Class (`main` method):** This is the entry point of the application and handles user interaction.
 *     *   A `TaskManager` instance is created to manage the tasks.
 *     *   A `java.util.Scanner` is used to read input lines from `System.in`.
 *     *   An infinite `while(true)` loop keeps the application running until the user enters the `exit` command.
 *     *   **Class-wide Exception Handling:** A `try-catch(Exception e)` block wraps the entire command processing logic inside the loop. This provides a safety net to catch any unexpected exceptions that might occur during input parsing or command execution, printing an error message to `System.err`.
 *     *   Input lines are read, trimmed, and split into parts using `split("\\s+", 3)`, which splits by whitespace into a maximum of 3 parts (command, description, priority), simplifying parsing for the `add` command.
 *     *   **Switch Statement:** A `switch` statement on the lowercased first part (`command`) directs the flow to the appropriate logic (`add`, `complete`, `view`, `exit`).
 *     *   **Input Validation:**
 *         *   For `add`, it checks if at least 3 parts were provided. It also calls `isValidPriority()` to validate the priority string.
 *         *   For `complete` and `exit`, it checks if no extra arguments were provided.
 *         *   For `view`, it checks if a second argument (view type) is provided and uses a **nested switch** statement to handle "pending" or "completed".
 *     *   **Output:** `System.out.println` is used for success messages, task additions, task completions, and listing tasks. `System.err.println` is used for all validation failures and error conditions (like trying to complete a task when none are pending).
 *     *   The `isValidPriority` helper method performs case-insensitive validation against the allowed priority values.
 *     *   The `exit` command closes the `Scanner` resource and uses `return` to exit the `main` method, terminating the program.
 * 
 * This solution effectively integrates `Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.err`, `System.out`, and `try-catch` within a practical, object-oriented structure, demonstrating key Java concepts and best practices suitable for an advanced exam task.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;

// Represents a single task
class Task {
    private int id;
    private String description;
    private String priority; // High, Medium, Low

    /**
     * Constructs a new Task.
     * @param id The unique task ID.
     * @param description The task description.
     * @param priority The task priority (High, Medium, or Low).
     */
    public Task(int id, String description, String priority) {
        this.id = id;
        this.description = description;
        this.priority = priority;
    }

    // --- Getters ---
    public int getId() {
        return id;
    }

    public String getDescription() {
        return description;
    }

    public String getPriority() {
        return priority;
    }

    @Override
    public String toString() {
        return "Task{id=" + id + ", description='" + description + "', priority='" + priority + "'}";
    }
}

// Manages the collection of pending and completed tasks
class TaskManager {
    // Using LinkedList as it implements the Queue interface for FIFO
    private Queue<Task> pendingTasks;
    // Using ArrayList which implements the List interface for completed tasks
    private List<Task> completedTasks;
    private int nextTaskId;

    /**
     * Constructs a new TaskManager.
     * Initializes the pending and completed task collections and the task ID counter.
     */
    public TaskManager() {
        pendingTasks = new LinkedList<>();
        completedTasks = new ArrayList<>();
        nextTaskId = 1;
    }

    /**
     * Adds a new task to the pending queue.
     * @param description The description of the task.
     * @param priority The priority of the task (High, Medium, Low).
     */
    public void addTask(String description, String priority) {
        // Basic validation is handled in the main application loop,
        // but TaskManager could also perform checks or assume valid input.
        Task newTask = new Task(nextTaskId++, description, priority);
        pendingTasks.offer(newTask); // offer is preferred over add for queues (doesn't throw exception on capacity issues, though LinkedList is unbounded)
        System.out.println("Task added: " + newTask);
    }

    /**
     * Completes the next task in the pending queue (FIFO).
     * Moves the completed task to the completed list.
     * Handles the case where there are no pending tasks.
     */
    public void completeNextTask() {
        Task completed = pendingTasks.poll(); // poll is preferred over remove for queues (returns null if empty)
        if (completed != null) {
            completedTasks.add(completed);
            System.out.println("Completed task: " + completed);
        } else {
            System.err.println("No pending tasks to complete.");
        }
    }

    /**
     * Returns a list of all pending tasks.
     * @return A List of pending Task objects.
     */
    public List<Task> getPendingTasks() {
        // Return a new ArrayList containing elements from the queue
        // to expose as a List interface without exposing the internal Queue structure directly.
        return new ArrayList<>(pendingTasks);
    }

    /**
     * Returns a list of all completed tasks.
     * @return A List of completed Task objects.
     */
    public List<Task> getCompletedTasks() {
        // ArrayList already implements List, so can return directly
        return completedTasks;
    }
}

// Main application class for user interaction
public class TaskApp {

    private static final String[] VALID_PRIORITIES = {"high", "medium", "low"};

    /**
     * Entry point for the Task Management System application.
     * Handles user input and command processing.
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        TaskManager manager = new TaskManager();
        Scanner scanner = new Scanner(System.in);

        System.out.println("Task Management System");
        System.out.println("Commands: add <description> <priority>, complete, view pending, view completed, exit");

        // Main application loop
        while (true) {
            System.out.print("> ");
            String inputLine = scanner.nextLine().trim();

            // Use try-catch block for class-wide exception handling during command processing
            try {
                // Split input line into parts, limit to 3 parts: command, description, priority
                String[] parts = inputLine.split("\\s+", 3);
                String command = parts[0].toLowerCase(); // Get the command and convert to lowercase

                // Use switch statement for command processing
                switch (command) {
                    case "add":
                        // Check if enough arguments are provided (command, description, priority)
                        if (parts.length >= 3) {
                            String description = parts[1];
                            String priority = parts[2];
                            // Validate priority string
                            if (isValidPriority(priority)) {
                                manager.addTask(description, priority);
                            } else {
                                System.err.println("Invalid priority. Use High, Medium, or Low.");
                            }
                        } else {
                            System.err.println("Usage: add <description> <priority>");
                        }
                        break;

                    case "complete":
                        // No additional arguments needed for complete
                        if (parts.length == 1) {
                             manager.completeNextTask();
                        } else {
                             System.err.println("Usage: complete");
                        }
                        break;

                    case "view":
                        // Check if a view type argument is provided
                        if (parts.length >= 2) {
                            String viewType = parts[1].toLowerCase();
                            // Use nested switch for view types
                            switch (viewType) {
                                case "pending":
                                    // Get pending tasks using the List interface
                                    List<Task> pending = manager.getPendingTasks();
                                    if (pending.isEmpty()) {
                                        System.out.println("No pending tasks.");
                                    } else {
                                        System.out.println("Pending Tasks:");
                                        // Iterate and print tasks
                                        for (Task task : pending) {
                                            System.out.println("- " + task);
                                        }
                                    }
                                    break;
                                case "completed":
                                    // Get completed tasks using the List interface (ArrayList)
                                    List<Task> completed = manager.getCompletedTasks();
                                    if (completed.isEmpty()) {
                                        System.out.println("No completed tasks.");
                                    } else {
                                        System.out.println("Completed Tasks:");
                                        // Iterate and print tasks
                                        for (Task task : completed) {
                                            System.out.println("- " + task);
                                        }
                                    }
                                    break;
                                default:
                                    // Invalid view type
                                    System.err.println("Invalid view type. Use 'pending' or 'completed'.");
                                    break;
                            }
                        } else {
                            // Missing view type argument
                            System.err.println("Usage: view pending or view completed");
                        }
                        break;

                    case "exit":
                        // Exit command
                        if (parts.length == 1) {
                            System.out.println("Exiting Task Management System. Goodbye!");
                            scanner.close(); // Close the scanner resource
                            return; // Exit the main method, terminating the program
                        } else {
                            System.err.println("Usage: exit");
                        }
                        break;

                    case "":
                        // Handle empty input line gracefully
                        break;

                    default:
                        // Unknown command
                        System.err.println("Unknown command. Commands: add, complete, view, exit");
                        break;
                }
            } catch (Exception e) {
                // Catch any unexpected exceptions during command processing
                System.err.println("An unexpected error occurred: " + e.getMessage());
                // For debugging, you might print the stack trace: e.printStackTrace();
            }
        }
    }

    /**
     * Validates if the provided priority string is one of the accepted values.
     * @param priority The priority string to validate.
     * @return true if the priority is valid, false otherwise.
     */
    private static boolean isValidPriority(String priority) {
        if (priority == null) {
            return false;
        }
        String lowerPriority = priority.toLowerCase();
        for (String validPriority : VALID_PRIORITIES) {
            if (lowerPriority.equals(validPriority)) {
                return true;
            }
        }
        return false;
    }
}
