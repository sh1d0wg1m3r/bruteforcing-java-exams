/*
 * Exam Question #781
 * Generated on: 2025-05-12 16:39:48
 * Generated by: Account 5
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Logistics Package Tracking System
 * 
 * **Scenario:**
 * 
 * You are tasked with developing a simplified package tracking system for a small logistics hub. The system needs to manage incoming packages, process them for shipping, and allow users to query the status and location of packages.
 * 
 * **Requirements:**
 * 
 * Implement a Java program that simulates this system. Your solution must adhere to the following specifications:
 * 
 * 1.  **Package Representation:** Create a class `Package` to represent a package. Each package should have a unique ID (String), a destination address (String), and a status (String, e.g., "Pending", "Processed"). Use appropriate private fields and public getter methods. Include a meaningful `toString()` method.
 * 2.  **Package Management:** Create a class `PackageProcessor` that manages the packages. This class will contain:
 *     *   A `Queue` to hold packages that are pending processing (incoming).
 *     *   A `List` to hold packages that have been processed.
 *     *   Methods for the following operations, interacting with the user via a `Scanner`:
 *         *   **Add Package:** Prompt the user for package ID and destination. Create a new `Package` object with status "Pending" and add it to the incoming queue. Validate that the ID and destination are not empty.
 *         *   **Process Next Package:** Take the package at the front of the incoming queue, change its status to "Processed", and move it to the processed list. If the queue is empty, report an error.
 *         *   **View Incoming Queue:** Display all packages currently in the incoming queue.
 *         *   **View Processed Packages:** Display all packages in the processed list.
 *         *   **Search Package:** Prompt the user for a package ID and search for it in both the incoming queue and the processed list. Report if the package is found, its current location (queue or processed), and its details. If not found, report that.
 *         *   **Exit:** Terminate the program.
 * 3.  **User Interface:** Implement a simple command-line interface using `Scanner` to present a menu of options (Add, Process, View Queue, View Processed, Search, Exit) to the user. Use a `switch` statement to handle the user's choice. The interface loop should continue until the user chooses to exit.
 * 4.  **Required Java Components:** Your solution MUST utilize ALL of the following components:
 *     *   `java.util.Queue`
 *     *   `java.util.ArrayList`
 *     *   `java.util.List` interface (declare the processed packages collection using this interface)
 *     *   `java.util.Scanner` for user input
 *     *   `switch` statement for menu handling
 *     *   `System.err` for displaying error messages (e.g., invalid input, queue empty during processing, package not found during search).
 *     *   `System.out` for displaying the menu, prompts, successful operation messages, and package details.
 * 5.  **Error Handling:** Implement class-wide exception handling within the `PackageProcessor`'s main loop (or a method called by it) using `try-catch` blocks to gracefully handle unexpected issues, such as invalid input format for menu options. Specific validation errors (like empty ID) should be handled with checks and `System.err` without necessarily throwing exceptions, but the main loop should be robust.
 * 6.  **Best Practices:** Apply good programming practices:
 *     *   Proper encapsulation (private fields, public methods).
 *     *   Meaningful variable and method names.
 *     *   Appropriate comments explaining complex logic or class purpose.
 *     *   Input validation as specified.
 *     *   Clean code structure.
 * 
 * **Expected Output:**
 * 
 * The program should display a menu, prompt for input, and provide output based on user actions.
 * 
 * *   Adding a package: Confirm success.
 * *   Processing a package: Report which package was processed and its new status/location. Report error if queue is empty.
 * *   Viewing queues/lists: Print details of packages in the respective collections. Indicate if a collection is empty.
 * *   Searching: Report if found/not found, location, and details.
 * *   Errors: Print error messages to `System.err`.
 * *   Normal output: Print messages and data to `System.out`.
 * 
 * **Example Interaction Snippet:**
 * 
 * ```
 * Package Tracking System Menu:
 * 1. Add Package
 * 2. Process Next Package
 * 3. View Incoming Queue
 * 4. View Processed Packages
 * 5. Search Package
 * 6. Exit
 * Enter your choice: 1
 * Enter Package ID: PKG001
 * Enter Destination: New York
 * Package PKG001 added to incoming queue.
 * 
 * Package Tracking System Menu:
 * ...
 * Enter your choice: 2
 * Processing package: PKG001 to New York
 * Package PKG001 processed and moved to processed list.
 * 
 * Package Tracking System Menu:
 * ...
 * Enter your choice: 5
 * Enter Package ID to search: PKG001
 * Package PKG001 found in Processed Packages. Details: [Package ID: PKG001, Destination: New York, Status: Processed]
 * 
 * Package Tracking System Menu:
 * ...
 * Enter your choice: 5
 * Enter Package ID to search: PKG999
 * Error: Package PKG999 not found in the system.
 * 
 * Package Tracking System Menu:
 * ...
 * Enter your choice: 2
 * Incoming queue is empty. Cannot process.
 * 
 * Package Tracking System Menu:
 * ...
 * Enter your choice: 7
 * Error: Invalid choice. Please enter a number between 1 and 6.
 * 
 * Package Tracking System Menu:
 * ...
 * Enter your choice: 6
 * Exiting system. Goodbye!
 * ```
 * 
 * Implement the necessary classes and logic to fulfill these requirements.
 *
 * EXPLANATION:
 * This solution implements a simplified Package Tracking System as required, demonstrating the use of all specified Java components and following good practices.
 * 
 * 1.  **`Package` Class:**
 *     *   Represents a single package with `packageId`, `destination`, and `status` as private fields, ensuring encapsulation.
 *     *   Public getter methods provide controlled access to the data.
 *     *   A `setStatus` method is included as the package's status needs to change during processing.
 *     *   The constructor includes basic validation using `IllegalArgumentException`.
 *     *   `toString()` provides a convenient way to display package details.
 * 
 * 2.  **`PackageProcessor` Class:**
 *     *   This is the core class managing the system logic.
 *     *   It uses a `Queue<Package> incomingPackages` (implemented with `LinkedList`) to manage packages in a First-In, First-Out (FIFO) manner, simulating an arrival queue.
 *     *   It uses a `List<Package> processedPackages` (declared as `List`, implemented with `ArrayList`) to store packages once they have been processed. Using the `List` interface for the variable declaration is a best practice promoting flexibility.
 *     *   A `Scanner` object is held as a field to manage user input throughout the class's operations.
 *     *   Methods like `addPackage`, `processNextPackage`, `viewIncomingQueue`, `viewProcessedPackages`, and `searchPackage` encapsulate specific functionalities.
 *     *   `addPackage` performs input validation for ID and destination and checks for duplicate IDs before adding a new package to the queue using `offer()`.
 *     *   `processNextPackage` uses `poll()` to retrieve and remove the head of the queue, handling the `null` case if the queue is empty. It updates the package status and adds it to the `processedPackages` list.
 *     *   `viewIncomingQueue` and `viewProcessedPackages` iterate through the respective collections and print package details using the `toString()` method. They check if the collections are empty.
 *     *   `searchPackage` iterates through both collections to find a package by ID, demonstrating searching within different data structures. It prints the location (queue or list) if found.
 *     *   `displayMenu` is a helper method for presenting the user options.
 *     *   The `run()` method contains the main application loop. It repeatedly displays the menu, reads user input using the `Scanner`, and uses a `switch` statement to dispatch to the appropriate method based on the user's choice.
 * 
 * 3.  **Required Components Usage:**
 *     *   `Queue`: Used for `incomingPackages`.
 *     *   `ArrayList`: Used as the implementation for `processedPackages`.
 *     *   `List`: Used as the type declaration for `processedPackages`.
 *     *   `Scanner`: Used in `PackageProcessor` to get user input for menu choices and package details.
 *     *   `switch`: Used in the `run()` method to handle menu selection.
 *     *   `System.err`: Used for all error messages (invalid input, empty queue, package not found, unexpected exceptions).
 *     *   `System.out`: Used for displaying the menu, prompts, successful operation messages, and package details.
 * 
 * 4.  **Error Handling:**
 *     *   Input validation (checking for empty strings) is performed in `addPackage` and `searchPackage` with error messages printed to `System.err`.
 *     *   Specific operational errors (like processing an empty queue) are checked for and reported to `System.err`.
 *     *   The `run()` method implements **class-wide exception handling** using a `try-catch` block around the main loop body. It specifically catches `InputMismatchException` for invalid menu input (non-integer) and a general `Exception` to catch any other unexpected runtime errors that might occur within the loop's execution. This makes the main loop robust and prevents the program from crashing due to user errors or unforeseen issues. Error messages and stack traces (for general exceptions) are directed to `System.err`.
 * 
 * 5.  **Best Practices:**
 *     *   **Encapsulation:** Private fields and public methods are used in both classes.
 *     *   **Naming:** Variable and method names are descriptive (`incomingPackages`, `processNextPackage`, `viewIncomingQueue`, etc.).
 *     *   **Comments:** Javadoc comments explain the purpose of classes, constructors, and methods. Inline comments explain key logic points.
 *     *   **Input Validation:** Basic checks for empty required fields are included.
 *     *   **Clean Code Structure:** The code is divided into logical classes (`Package`, `PackageProcessor`, `PackageProcessingApp`) with clear responsibilities. The main loop in `run()` is clean, delegating tasks to specific methods.
 *     *   **Resource Management:** The `Scanner` is managed in the `main` method using a try-with-resources block, ensuring it is closed properly when the application finishes.
 * 
 * This solution effectively combines data structures (`Queue`, `List`), control flow (`switch`, loops), object-oriented principles (classes, encapsulation), input/output (`Scanner`, `System.out`, `System.err`), and error handling (`try-catch`, validation) to solve a practical problem, demonstrating an advanced understanding of core Java concepts.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.InputMismatchException;

/**
 * Represents a package with ID, destination, and status.
 */
class Package {
    private String packageId;
    private String destination;
    private String status;

    /**
     * Constructs a new Package.
     * @param packageId The unique ID of the package.
     * @param destination The destination address of the package.
     * @param status The initial status of the package (e.g., "Pending").
     */
    public Package(String packageId, String destination, String status) {
        // Basic validation during construction is good practice
        if (packageId == null || packageId.trim().isEmpty()) {
            throw new IllegalArgumentException("Package ID cannot be null or empty.");
        }
        if (destination == null || destination.trim().isEmpty()) {
            throw new IllegalArgumentException("Destination cannot be null or empty.");
        }
        if (status == null || status.trim().isEmpty()) {
             throw new IllegalArgumentException("Status cannot be null or empty.");
        }
        this.packageId = packageId.trim();
        this.destination = destination.trim();
        this.status = status.trim();
    }

    // --- Getters ---
    public String getPackageId() {
        return packageId;
    }

    public String getDestination() {
        return destination;
    }

    public String getStatus() {
        return status;
    }

    // --- Setter for status (needed for processing) ---
    public void setStatus(String status) {
         if (status == null || status.trim().isEmpty()) {
             throw new IllegalArgumentException("Status cannot be null or empty.");
         }
        this.status = status.trim();
    }

    /**
     * Provides a string representation of the Package.
     * @return Formatted string with package details.
     */
    @Override
    public String toString() {
        return "[Package ID: " + packageId + ", Destination: " + destination + ", Status: " + status + "]";
    }
}

/**
 * Manages the incoming and processed packages.
 * Handles user interaction and system operations.
 */
class PackageProcessor {
    // Using Queue for incoming packages (FIFO)
    private Queue<Package> incomingPackages;
    // Using List for processed packages (storage)
    private List<Package> processedPackages;
    private Scanner scanner;

    /**
     * Constructs a PackageProcessor.
     * Initializes the package collections and the scanner.
     */
    public PackageProcessor(Scanner scanner) {
        // LinkedList is a common implementation for Queue
        this.incomingPackages = new LinkedList<>();
        // ArrayList is a common implementation for List
        this.processedPackages = new ArrayList<>();
        this.scanner = scanner; // Scanner is provided, not created here
    }

    /**
     * Displays the main menu to the user.
     */
    private void displayMenu() {
        System.out.println("\n--- Package Tracking System Menu ---");
        System.out.println("1. Add Package");
        System.out.println("2. Process Next Package");
        System.out.println("3. View Incoming Queue");
        System.out.println("4. View Processed Packages");
        System.out.println("5. Search Package");
        System.out.println("6. Exit");
        System.out.print("Enter your choice: ");
    }

    /**
     * Adds a new package based on user input.
     * Includes input validation.
     */
    private void addPackage() {
        System.out.print("Enter Package ID: ");
        String id = scanner.nextLine().trim();

        if (id.isEmpty()) {
            System.err.println("Error: Package ID cannot be empty.");
            return;
        }

        System.out.print("Enter Destination: ");
        String destination = scanner.nextLine().trim();

        if (destination.isEmpty()) {
            System.err.println("Error: Destination cannot be empty.");
            return;
        }

        // Check if package ID already exists (simple check across both collections)
        boolean idExists = incomingPackages.stream().anyMatch(p -> p.getPackageId().equals(id)) ||
                           processedPackages.stream().anyMatch(p -> p.getPackageId().equals(id));

        if (idExists) {
             System.err.println("Error: Package with ID '" + id + "' already exists.");
             return;
        }


        try {
            Package newPackage = new Package(id, destination, "Pending");
            incomingPackages.offer(newPackage); // offer is preferred over add for queues
            System.out.println("Package " + id + " added to incoming queue.");
        } catch (IllegalArgumentException e) {
            // This catch is mostly for robustness if validation above missed something
            System.err.println("Error creating package: " + e.getMessage());
        }
    }

    /**
     * Processes the next package from the incoming queue.
     * Moves it to the processed list. Handles empty queue.
     */
    private void processNextPackage() {
        Package packageToProcess = incomingPackages.poll(); // poll returns null if queue is empty

        if (packageToProcess == null) {
            System.err.println("Incoming queue is empty. Cannot process.");
        } else {
            System.out.println("Processing package: " + packageToProcess.getPackageId() + " to " + packageToProcess.getDestination());
            packageToProcess.setStatus("Processed");
            processedPackages.add(packageToProcess);
            System.out.println("Package " + packageToProcess.getPackageId() + " processed and moved to processed list.");
        }
    }

    /**
     * Displays all packages currently in the incoming queue.
     */
    private void viewIncomingQueue() {
        System.out.println("\n--- Incoming Queue ---");
        if (incomingPackages.isEmpty()) {
            System.out.println("Incoming queue is empty.");
        } else {
            // Iterate and print using standard for-each loop
            int index = 1;
            for (Package pkg : incomingPackages) {
                System.out.println(index++ + ". " + pkg);
            }
        }
    }

    /**
     * Displays all packages currently in the processed list.
     */
    private void viewProcessedPackages() {
        System.out.println("\n--- Processed Packages ---");
        if (processedPackages.isEmpty()) {
            System.out.println("Processed packages list is empty.");
        } else {
            // Iterate and print using standard for-each loop
            int index = 1;
            for (Package pkg : processedPackages) {
                System.out.println(index++ + ". " + pkg);
            }
        }
    }

    /**
     * Searches for a package by ID in both collections.
     * Reports its status and location.
     */
    private void searchPackage() {
        System.out.print("Enter Package ID to search: ");
        String searchId = scanner.nextLine().trim();

         if (searchId.isEmpty()) {
            System.err.println("Error: Package ID cannot be empty for search.");
            return;
        }

        // Search in incoming queue
        for (Package pkg : incomingPackages) {
            if (pkg.getPackageId().equalsIgnoreCase(searchId)) {
                System.out.println("Package " + searchId + " found in Incoming Queue. Details: " + pkg);
                return; // Found, exit method
            }
        }

        // Search in processed list
        for (Package pkg : processedPackages) {
             if (pkg.getPackageId().equalsIgnoreCase(searchId)) {
                System.out.println("Package " + searchId + " found in Processed Packages. Details: " + pkg);
                return; // Found, exit method
            }
        }

        // If loop finishes without finding
        System.err.println("Error: Package " + searchId + " not found in the system.");
    }

    /**
     * Runs the main application loop, displaying the menu
     * and handling user choices. Includes class-wide exception handling.
     */
    public void run() {
        int choice = -1;
        while (choice != 6) {
            displayMenu();
            try {
                choice = scanner.nextInt();
                scanner.nextLine(); // Consume newline left-over

                switch (choice) {
                    case 1:
                        addPackage();
                        break;
                    case 2:
                        processNextPackage();
                        break;
                    case 3:
                        viewIncomingQueue();
                        break;
                    case 4:
                        viewProcessedPackages();
                        break;
                    case 5:
                        searchPackage();
                        break;
                    case 6:
                        System.out.println("Exiting system. Goodbye!");
                        break;
                    default:
                        System.err.println("Error: Invalid choice. Please enter a number between 1 and 6.");
                }
            } catch (InputMismatchException e) {
                System.err.println("Error: Invalid input. Please enter a number.");
                scanner.nextLine(); // Consume the invalid input to prevent infinite loop
                choice = -1; // Reset choice to continue loop
            } catch (Exception e) {
                // Catch any other unexpected runtime exceptions
                System.err.println("An unexpected error occurred: " + e.getMessage());
                e.printStackTrace(System.err); // Print stack trace to error stream
                choice = -1; // Reset choice
            }
        }
    }
}

/**
 * Main class to start the Package Tracking System application.
 */
public class PackageProcessingApp {
    public static void main(String[] args) {
        // Use try-with-resources to ensure scanner is closed
        try (Scanner scanner = new Scanner(System.in)) {
            PackageProcessor processor = new PackageProcessor(scanner);
            processor.run();
        } // Scanner is automatically closed here
    }
}
