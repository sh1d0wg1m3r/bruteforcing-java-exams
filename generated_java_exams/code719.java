/*
 * Exam Question #719
 * Generated on: 2025-05-12 16:30:26
 * Generated by: Account 2
 * 
 * QUESTION:
 * **Java Programming Exam Task: Advanced Task Management System**
 * 
 * You are tasked with developing a simple command-line based Task Management System. This system will allow users to add tasks to a waiting queue, process tasks one by one, and view the status of tasks (waiting, completed, or failed).
 * 
 * The system must adhere to the following requirements:
 * 
 * 1.  **Task Representation:**
 *     *   Create a `Task` class with private fields for `id` (int), `description` (String), and `status` (String, e.g., "Waiting", "Completed", "Failed").
 *     *   Include a constructor to initialize `id` and `description`.
 *     *   Provide public getter methods for all fields.
 *     *   Provide a public setter method for the `status`.
 *     *   Override the `toString()` method for easy printing of task details.
 * 2.  **Task Processor:**
 *     *   Create a `TaskProcessor` class responsible for managing tasks.
 *     *   It must have three private member variables:
 *         *   A `Queue<Task>` to hold tasks waiting to be processed. Use a suitable implementation like `LinkedList`.
 *         *   An `ArrayList<Task>` to hold tasks that have been successfully completed.
 *         *   A `List<Task>` (using the `List` interface, instantiated as `ArrayList`) to hold tasks that failed during processing.
 *     *   Include a private counter for generating unique task IDs, initialized to 1.
 *     *   Implement a public method `addTask(String description)`:
 *         *   Creates a new `Task` object with the next available ID and the given description.
 *         *   Sets the initial status to "Waiting".
 *         *   Adds the task to the waiting queue.
 *         *   Increments the task ID counter.
 *         *   Perform basic input validation: If the description is null or empty, do not add the task and print an error message to `System.err`.
 *     *   Implement a public method `processNextTask()`:
 *         *   Attempts to retrieve and remove the next task from the waiting queue.
 *         *   If the queue is empty, it should indicate that no task was processed (e.g., by returning `false`).
 *         *   If a task is retrieved, simulate processing:
 *             *   If the task description contains the word "critical" (case-insensitive), simulate a processing failure. Set the task status to "Failed" and add it to the failed tasks list.
 *             *   Otherwise, simulate successful processing. Set the task status to "Completed" and add it to the completed tasks list.
 *         *   Use a `try-catch` block *within* this method to handle potential issues during processing simulation (e.g., NullPointerException if description was somehow null, though input validation should prevent this). If an exception occurs during simulation, mark the task as "Failed" and add it to the failed tasks list, printing an error to `System.err`.
 *         *   Return `true` if a task was successfully processed (either completed or failed), `false` if the queue was empty.
 *     *   Implement public methods `viewQueue()`, `viewCompletedTasks()`, and `viewFailedTasks()` that print the details of tasks in their respective collections to `System.out`. Include messages indicating which list is being displayed and if a list is empty.
 * 3.  **Main Application (`TaskManagementApp`):**
 *     *   Create a `main` method to run the application.
 *     *   Use a `Scanner` to read user input from the console.
 *     *   Present a menu of options to the user:
 *         *   1. Add New Task
 *         *   2. Process Next Task
 *         *   3. View Waiting Queue
 *         *   4. View Completed Tasks
 *         *   5. View Failed Tasks
 *         *   6. Exit
 *     *   Use a `while` loop to keep the application running until the user chooses to exit.
 *     *   Use a `switch` statement to handle the user's menu choice.
 *     *   Implement input validation for the menu choice: If the input is not a valid integer or not within the range of options, print an error message to `System.err` and clear the invalid input from the scanner buffer.
 *     *   Call the appropriate methods of the `TaskProcessor` based on the user's choice.
 *     *   Handle the return value of `processNextTask()` to inform the user if a task was processed or if the queue was empty, using `System.out` for success messages and `System.err` for the "queue empty" error.
 *     *   Implement class-wide exception handling using a `try-catch` block around the main application loop to catch any unexpected errors and print a generic error message to `System.err` before exiting.
 *     *   Ensure the `Scanner` is closed when the application exits.
 * 
 * **Expected Output:**
 * 
 * The program should present a menu, accept user input, and display task information or error messages based on the operations performed. Examples:
 * 
 * *   Adding a task: "Task added to queue: Task{id=1, description='...', status='Waiting'}"
 * *   Processing a task: "Task processed." (followed by view commands to see where it went)
 * *   Processing with empty queue: "Error: No tasks in the queue to process." (on `System.err`)
 * *   Viewing lists: Print formatted task details or "The [list name] is empty."
 * *   Invalid input: "Error: Invalid input. Please enter a number between 1 and 6." (on `System.err`)
 * *   Task description validation: "Error: Task description cannot be empty." (on `System.err`)
 * *   Processing simulation error: "Error during task processing simulation for Task ID [id]: [exception message]" (on `System.err`)
 * *   Unexpected application error: "An unexpected error occurred: [exception message]" (on `System.err`)
 * 
 * This task requires integrating multiple core Java concepts and handling various flow control and error conditions.
 *
 * EXPLANATION:
 * This solution implements a simple Task Management System, demonstrating the required Java concepts in a practical scenario.
 * 
 * 1.  **`Task` Class:**
 *     *   Represents a single task with `id`, `description`, and `status`.
 *     *   Uses private fields and public getters/setters, adhering to encapsulation principles.
 *     *   The `toString()` method provides a convenient way to print task details.
 * 
 * 2.  **`TaskProcessor` Class:**
 *     *   Acts as the core logic handler.
 *     *   Manages three collections:
 *         *   `taskQueue`: A `Queue<Task>` implemented using `LinkedList`. Tasks are added to the end (`offer`) and removed from the front (`poll`), simulating a waiting line.
 *         *   `completedTasks`: An `ArrayList<Task>`. Tasks successfully processed are added here. This fulfills the requirement to use `ArrayList`.
 *         *   `failedTasks`: A `List<Task>` instantiated as `new ArrayList<>()`. Tasks that failed processing are added here. This fulfills the requirement to use the `List` interface for one list and `ArrayList` for another.
 *     *   `nextTaskId`: A private counter ensures each task gets a unique ID.
 *     *   `addTask()`: Validates the description and adds a new `Task` to the `taskQueue`. Prints success/error messages to `System.out` or `System.err`.
 *     *   `processNextTask()`:
 *         *   Checks if the `taskQueue` is empty first, returning `false` if it is.
 *         *   Uses `taskQueue.poll()` to get and remove the next task.
 *         *   Includes a `try-catch` block *within* the method to handle potential exceptions during the simulated processing step. This demonstrates specific error handling at the method level.
 *         *   Simulates success or failure based on the task description ("critical" keyword) or a small random chance, setting the task status accordingly.
 *         *   Adds the processed task to either `completedTasks` or `failedTasks`.
 *         *   Returns `true` if a task was successfully processed (dequeued and handled), regardless of its final status (completed/failed).
 *     *   `viewQueue()`, `viewCompletedTasks()`, `viewFailedTasks()`: Iterate through the respective collections and print task details using `System.out`. They check if the lists are empty and print appropriate messages. `viewQueue` uses `forEach` on the queue which iterates without removing elements.
 * 
 * 3.  **`TaskManagementApp` Class:**
 *     *   Contains the `main` method, the entry point of the application.
 *     *   Uses `Scanner` to get input from `System.in`.
 *     *   Implements a main `while` loop to keep the application running.
 *     *   Uses a `switch` statement to control the flow based on the user's menu choice.
 *     *   Includes robust input validation for the menu choice, handling non-integer input and out-of-range numbers, printing errors to `System.err` and consuming the invalid input.
 *     *   Calls the appropriate methods on the `TaskProcessor` instance.
 *     *   Checks the return value of `processNextTask()` to print informative messages using `System.out` for success and `System.err` for the "queue empty" error condition.
 *     *   Includes a large `try-catch` block around the main `while` loop. This serves as the "class-wide" or application-level exception handling requirement, catching any unexpected exceptions that might propagate up, printing an error to `System.err` and a stack trace for debugging.
 *     *   Ensures the `Scanner` is closed before the application exits to release system resources.
 *     *   Uses `System.out` for normal program output (menu, task added, task processed, viewing lists) and `System.err` for error messages (invalid input, empty description, empty queue on process attempt, processing simulation errors, unexpected application errors).
 * 
 * This solution effectively integrates `Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.err`, `System.out`, and `try-catch` blocks in a structured, practical, and challenging manner suitable for an advanced Java exam question. It demonstrates object-oriented design, collection usage, input handling, and various error management techniques.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;

// Represents a single task in the system
class Task {
    private int id;
    private String description;
    private String status; // e.g., "Waiting", "Completed", "Failed"

    // Constructor
    public Task(int id, String description) {
        this.id = id;
        this.description = description;
        this.status = "Waiting"; // Initial status
    }

    // Getters
    public int getId() {
        return id;
    }

    public String getDescription() {
        return description;
    }

    public String getStatus() {
        return status;
    }

    // Setter for status
    public void setStatus(String status) {
        this.status = status;
    }

    // Override toString for easy printing
    @Override
    public String toString() {
        return "Task{id=" + id + ", description='" + description + "', status='" + status + "'}";
    }
}

// Manages the task queue, completed tasks, and failed tasks
class TaskProcessor {
    private Queue<Task> taskQueue;
    private ArrayList<Task> completedTasks; // Requirement: use ArrayList concrete class
    private List<Task> failedTasks; // Requirement: use List interface
    private int nextTaskId;

    // Constructor
    public TaskProcessor() {
        this.taskQueue = new LinkedList<>(); // LinkedList implements Queue
        this.completedTasks = new ArrayList<>();
        this.failedTasks = new ArrayList<>(); // Instantiate List interface with ArrayList
        this.nextTaskId = 1;
    }

    // Adds a new task to the waiting queue
    public void addTask(String description) {
        if (description == null || description.trim().isEmpty()) {
            System.err.println("Error: Task description cannot be empty.");
            return;
        }
        Task newTask = new Task(nextTaskId++, description.trim());
        taskQueue.offer(newTask); // offer is preferred for queues (returns false if capacity restricted, add throws exception)
        System.out.println("Task added to queue: " + newTask);
    }

    // Processes the next task from the queue
    // Returns true if a task was processed, false if the queue was empty
    public boolean processNextTask() {
        if (taskQueue.isEmpty()) {
            return false; // No tasks to process
        }

        Task taskToProcess = taskQueue.poll(); // Retrieve and remove the head of the queue
        System.out.println("Attempting to process task: " + taskToProcess.getDescription());

        try {
            // Simulate processing based on description
            if (taskToProcess.getDescription().toLowerCase().contains("critical")) {
                System.out.println("Simulating failure for critical task.");
                taskToProcess.setStatus("Failed");
                failedTasks.add(taskToProcess);
            } else {
                System.out.println("Simulating successful task processing.");
                // Simulate a potential random error during 'successful' processing
                if (Math.random() < 0.05) { // 5% chance of random failure
                     throw new RuntimeException("Simulated random processing error.");
                }
                taskToProcess.setStatus("Completed");
                completedTasks.add(taskToProcess);
            }
        } catch (Exception e) {
            // Catch any exception during simulation (e.g., the simulated random error)
            System.err.println("Error during task processing simulation for Task ID " + taskToProcess.getId() + ": " + e.getMessage());
            taskToProcess.setStatus("Failed");
            failedTasks.add(taskToProcess); // Ensure task is moved to failed list on error
        }

        return true; // A task was taken from the queue and processed (either completed or failed)
    }

    // Views tasks in the waiting queue
    public void viewQueue() {
        System.out.println("\n--- Waiting Queue ---");
        if (taskQueue.isEmpty()) {
            System.out.println("The waiting queue is empty.");
        } else {
            // Iterate through the queue without removing elements
            taskQueue.forEach(System.out::println);
        }
        System.out.println("---------------------");
    }

    // Views completed tasks
    public void viewCompletedTasks() {
        System.out.println("\n--- Completed Tasks ---");
        if (completedTasks.isEmpty()) {
            System.out.println("The completed tasks list is empty.");
        } else {
            completedTasks.forEach(System.out::println);
        }
        System.out.println("-----------------------");
    }

    // Views failed tasks
    public void viewFailedTasks() {
        System.out.println("\n--- Failed Tasks ---");
        if (failedTasks.isEmpty()) {
            System.out.println("The failed tasks list is empty.");
        } else {
            failedTasks.forEach(System.out::println);
        }
        System.out.println("--------------------");
    }
}

// Main application class
public class TaskManagementApp {

    public static void main(String[] args) {
        // Class-wide exception handling
        try {
            TaskProcessor processor = new TaskProcessor();
            Scanner scanner = new Scanner(System.in);
            int choice;

            while (true) {
                printMenu();

                // Input validation for integer choice
                if (!scanner.hasNextInt()) {
                    System.err.println("Error: Invalid input. Please enter a number.");
                    scanner.next(); // Consume the invalid input
                    continue;
                }

                choice = scanner.nextInt();
                scanner.nextLine(); // Consume the newline character after reading int

                // Use switch statement for menu options
                switch (choice) {
                    case 1: // Add New Task
                        System.out.print("Enter task description: ");
                        String description = scanner.nextLine();
                        processor.addTask(description);
                        break;
                    case 2: // Process Next Task
                        boolean processed = processor.processNextTask();
                        if (processed) {
                            System.out.println("Task processed.");
                        } else {
                            System.err.println("Error: No tasks in the queue to process.");
                        }
                        break;
                    case 3: // View Waiting Queue
                        processor.viewQueue();
                        break;
                    case 4: // View Completed Tasks
                        processor.viewCompletedTasks();
                        break;
                    case 5: // View Failed Tasks
                        processor.viewFailedTasks();
                        break;
                    case 6: // Exit
                        System.out.println("Exiting Task Management System. Goodbye!");
                        scanner.close(); // Close the scanner
                        return; // Exit the main method and thus the program
                    default: // Invalid choice
                        System.err.println("Error: Invalid choice. Please enter a number between 1 and 6.");
                }
                System.out.println(); // Add a newline for better readability between operations
            }
        } catch (Exception e) {
            // Catch any unexpected exceptions not handled elsewhere
            System.err.println("An unexpected error occurred: " + e.getMessage());
            e.printStackTrace(); // Print stack trace for debugging unexpected errors
        }
    }

    // Helper method to print the menu
    private static void printMenu() {
        System.out.println("--- Task Management Menu ---");
        System.out.println("1. Add New Task");
        System.out.println("2. Process Next Task");
        System.out.println("3. View Waiting Queue");
        System.out.println("4. View Completed Tasks");
        System.out.println("5. View Failed Tasks");
        System.out.println("6. Exit");
        System.out.print("Enter your choice: ");
    }
}
