/*
 * Exam Question #617
 * Generated on: 2025-05-12 16:15:33
 * Generated by: Account 4
 * 
 * QUESTION:
 * ## Advanced Java Programming Exam Task: Hospital Procedure Waitlist Management
 * 
 * **Scenario:**
 * 
 * You are tasked with developing a simplified system for managing patients waiting for a specific procedure at a small hospital clinic. The system needs to keep track of all registered patients and maintain a waiting list for the procedure based on arrival time (First-In, First-Out).
 * 
 * **Problem Description:**
 * 
 * Implement a Java program that simulates this system. The program should allow users to perform the following operations via a command-line interface:
 * 
 * 1.  **Register New Patient:** Add a new patient to the system's registry. Each patient has a unique ID, name, and condition.
 * 2.  **Add Patient to Waitlist:** Move a registered patient from the general registry to the procedure waitlist.
 * 3.  **Call Next Patient:** Remove the patient who has been on the waitlist the longest and indicate they are ready for the procedure.
 * 4.  **View All Registered Patients:** Display a list of all patients currently registered in the system.
 * 5.  **View Current Waitlist:** Display the list of patients currently on the procedure waitlist, in the order they will be called.
 * 6.  **Exit:** Terminate the program.
 * 
 * **Requirements:**
 * 
 * Your solution must adhere to the following:
 * 
 * 1.  **Data Structures:**
 *     *   Use `java.util.ArrayList` to store the list of all registered patients.
 *     *   Use `java.util.Queue` to manage the procedure waitlist (FIFO). You can choose a suitable implementation like `java.util.LinkedList`.
 *     *   Use `java.util.List` interface in method signatures where appropriate (e.g., returning lists).
 * 2.  **Input:** Use `java.util.Scanner` to read user commands and patient details from the console.
 * 3.  **Control Flow:** Use a `switch` statement to handle the main menu options.
 * 4.  **Output:**
 *     *   Use `System.out` for displaying the menu, prompts, success messages, and list contents.
 *     *   Use `System.err` for displaying error messages (e.g., invalid input, patient not found, waitlist empty, duplicate patient ID).
 * 5.  **Error Handling:**
 *     *   Implement robust input validation (e.g., handle non-integer menu choices, ensure patient ID/name/condition are not empty).
 *     *   Use `try-catch` blocks to handle potential exceptions, particularly around user input parsing and operations that might fail (like calling from an empty queue or adding a duplicate). A general `try-catch` in the main loop is acceptable for catching unexpected issues.
 * 6.  **Object-Oriented Design:**
 *     *   Create a `Patient` class with private fields (ID, name, condition) and public getters. Include a `toString()` method for easy printing.
 *     *   Create a `HospitalSystem` class that encapsulates the `ArrayList` of all patients and the `Queue` waitlist. This class should contain methods for managing patients and the waitlist (register, find, add to waitlist, call next, get lists).
 *     *   The main logic should reside in a separate class with a `main` method.
 * 7.  **Best Practices:**
 *     *   Use meaningful variable and method names.
 *     *   Include appropriate comments (especially Javadoc for classes and methods).
 *     *   Ensure proper encapsulation (private fields, public methods).
 * 
 * **Expected Output:**
 * 
 * The program should present a menu. Based on the user's integer input, it should perform the corresponding action, providing feedback to the user. Error messages should be clearly distinguishable using `System.err`.
 * 
 * Example interaction:
 * 
 * ```
 * --- Hospital Waitlist Management ---
 * 1. Register New Patient
 * 2. Add Patient to Waitlist
 * 3. Call Next Patient
 * 4. View All Registered Patients
 * 5. View Current Waitlist
 * 6. Exit
 * Enter your choice: 1
 * Enter Patient ID: P001
 * Enter Patient Name: Alice Smith
 * Enter Patient Condition: Fever
 * Patient P001 registered successfully.
 * 
 * --- Hospital Waitlist Management ---
 * ...
 * Enter your choice: 1
 * Enter Patient ID: P002
 * Enter Patient Name: Bob Johnson
 * Enter Patient Condition: Sprain
 * Patient P002 registered successfully.
 * 
 * --- Hospital Waitlist Management ---
 * ...
 * Enter your choice: 2
 * Enter Patient ID to add to waitlist: P001
 * Patient P001 added to the waitlist.
 * 
 * --- Hospital Waitlist Management ---
 * ...
 * Enter your choice: 2
 * Enter Patient ID to add to waitlist: P003
 * Error: Patient with ID P003 not found.
 * 
 * --- Hospital Waitlist Management ---
 * ...
 * Enter your choice: 5
 * --- Current Waitlist ---
 * P001 - Alice Smith (Fever)
 * --------------------------
 * 
 * --- Hospital Waitlist Management ---
 * ...
 * Enter your choice: 3
 * Calling next patient from waitlist: P001 - Alice Smith (Fever)
 * 
 * --- Hospital Waitlist Management ---
 * ...
 * Enter your choice: 5
 * --- Current Waitlist ---
 * --------------------------
 * 
 * --- Hospital Waitlist Management ---
 * ...
 * Enter your choice: 3
 * Error: Waitlist is empty.
 * 
 * --- Hospital Waitlist Management ---
 * ...
 * Enter your choice: 6
 * Exiting system. Goodbye!
 * ```
 * 
 * **Evaluation:**
 * 
 * Your solution will be evaluated on:
 * *   Correct usage of all required Java components (`Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.err`, `System.out`, `try-catch`).
 * *   Correct implementation of the required functionalities.
 * *   Proper object-oriented design and encapsulation.
 * *   Effective error handling and input validation.
 * *   Code clarity, readability, comments, and adherence to best practices.
 *
 * EXPLANATION:
 * This solution implements the hospital waitlist management system using the required Java components and best practices.
 * 
 * 1.  **`Patient` Class:**
 *     *   Represents a single patient with `private` fields (`id`, `name`, `condition`) ensuring encapsulation.
 *     *   The constructor includes basic validation to prevent creating `Patient` objects with empty or null data, throwing `IllegalArgumentException`.
 *     *   `public` getters provide controlled access to the patient's data.
 *     *   `toString()` provides a convenient string representation for printing.
 * 
 * 2.  **`HospitalSystem` Class:**
 *     *   Manages the core logic and data structures.
 *     *   `private List<Patient> allPatients;`: Uses `ArrayList` (assigned to a `List` reference) to store all registered patients. `ArrayList` is suitable here for dynamic storage and easy iteration.
 *     *   `private Queue<Patient> waitlistQueue;`: Uses `Queue` (specifically `LinkedList` as an implementation) to store patients waiting for the procedure. The `Queue` ensures FIFO order, which is appropriate for a waitlist where patients are called in the order they joined.
 *     *   `registerPatient(Patient patient)`: Adds a patient to `allPatients`. It includes a check using `findPatientById` to prevent duplicate IDs, returning `false` if a duplicate is found.
 *     *   `findPatientById(String patientId)`: Iterates through `allPatients` to find a patient by ID. This demonstrates basic list traversal.
 *     *   `addToWaitlist(String patientId)`: Finds the patient in `allPatients` and, if found and not already on the waitlist, adds them to the `waitlistQueue` using `offer()`. Returns `false` if the patient isn't found or is already on the waitlist.
 *     *   `callNextPatient()`: Removes the head of the `waitlistQueue` using `poll()`, which returns `null` if the queue is empty, preventing exceptions.
 *     *   `getAllPatients()`: Returns the `allPatients` list, demonstrating the use of the `List` interface as a return type.
 *     *   `getWaitlist()`: Creates and returns a new `ArrayList` containing the elements from the `waitlistQueue`. This allows viewing the waitlist content without removing elements from the queue and also uses the `List` interface as a return type.
 * 
 * 3.  **`HospitalWaitlistApp` Class (Main):**
 *     *   Contains the `main` method, which is the entry point of the application.
 *     *   Initializes `HospitalSystem` and `Scanner`.
 *     *   The main application loop runs until the user chooses to exit (option 6).
 *     *   `printMenu()`: Displays the available options using `System.out`.
 *     *   Input reading: Uses `scanner.nextLine()` to read the entire line for menu choice and patient details, which helps avoid common pitfalls with mixed `nextInt()` and `nextLine()`.
 *     *   `switch (choice)`: Controls the flow based on the user's menu selection, directing execution to the appropriate private helper method.
 *     *   `try-catch` blocks:
 *         *   An outer `try-catch` in `main` catches general exceptions for robustness.
 *         *   An inner `try-catch(NumberFormatException)` specifically handles cases where the user enters non-integer input for the menu choice, printing an error using `System.err`.
 *         *   `IllegalArgumentException` is caught specifically to handle validation errors from the `Patient` constructor.
 *         *   Other `try-catch` blocks within helper methods (`registerNewPatient`, `addPatientToWaitlist`) handle specific errors like empty input strings or exceptions during object creation.
 *     *   Helper methods (`registerNewPatient`, `addPatientToWaitlist`, etc.): Encapsulate the logic for each menu option, prompting the user, performing basic input validation, calling the relevant `HospitalSystem` method, and providing feedback to the user using `System.out` for success/prompts and `System.err` for errors.
 *     *   `finally` block: Ensures the `Scanner` is closed when the program exits, releasing system resources.
 * 
 * This solution effectively demonstrates the required Java components within a practical scenario, emphasizing proper object-oriented design, encapsulation, input validation, and error handling using `try-catch` and distinguishing between normal output (`System.out`) and error messages (`System.err`).
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.Iterator; // Used for iterating Queue to display

/**
 * Represents a patient in the hospital system.
 */
class Patient {
    private String id;
    private String name;
    private String condition;

    /**
     * Constructs a new Patient object.
     * @param id The unique patient ID.
     * @param name The patient's name.
     * @param condition The patient's medical condition.
     */
    public Patient(String id, String name, String condition) {
        // Basic validation during construction
        if (id == null || id.trim().isEmpty()) {
            throw new IllegalArgumentException("Patient ID cannot be null or empty.");
        }
        if (name == null || name.trim().isEmpty()) {
            throw new IllegalArgumentException("Patient name cannot be null or empty.");
        }
        if (condition == null || condition.trim().isEmpty()) {
            throw new IllegalArgumentException("Patient condition cannot be null or empty.");
        }
        this.id = id.trim();
        this.name = name.trim();
        this.condition = condition.trim();
    }

    public String getId() {
        return id;
    }

    public String getName() {
        return name;
    }

    public String getCondition() {
        return condition;
    }

    /**
     * Returns a string representation of the patient.
     * @return A formatted string with patient details.
     */
    @Override
    public String toString() {
        return id + " - " + name + " (" + condition + ")";
    }

    // Optional: hashCode and equals could be added if needed for collections like HashSet/HashMap
    // but for this problem, linear search by ID in ArrayList is sufficient.
}

/**
 * Manages the hospital's patient registry and procedure waitlist.
 */
class HospitalSystem {
    private List<Patient> allPatients; // Stores all registered patients
    private Queue<Patient> waitlistQueue; // Stores patients waiting for procedure (FIFO)

    /**
     * Constructs a new HospitalSystem.
     */
    public HospitalSystem() {
        this.allPatients = new ArrayList<>();
        this.waitlistQueue = new LinkedList<>(); // LinkedList is a common Queue implementation
    }

    /**
     * Registers a new patient in the system.
     * Checks for duplicate IDs.
     * @param patient The patient object to register.
     * @return true if registration was successful, false if patient ID already exists.
     */
    public boolean registerPatient(Patient patient) {
        if (findPatientById(patient.getId()) != null) {
            // Patient with this ID already exists
            return false;
        }
        allPatients.add(patient);
        return true;
    }

    /**
     * Finds a patient in the registry by their ID.
     * @param patientId The ID of the patient to find.
     * @return The Patient object if found, null otherwise.
     */
    public Patient findPatientById(String patientId) {
        if (patientId == null || patientId.trim().isEmpty()) {
            return null; // Cannot search for null or empty ID
        }
        String searchId = patientId.trim();
        for (Patient p : allPatients) {
            if (p.getId().equals(searchId)) {
                return p;
            }
        }
        return null; // Patient not found
    }

    /**
     * Adds a registered patient to the procedure waitlist.
     * Checks if the patient is registered and not already on the waitlist.
     * @param patientId The ID of the patient to add to the waitlist.
     * @return true if added successfully, false otherwise (not found, already on waitlist).
     */
    public boolean addToWaitlist(String patientId) {
        Patient patient = findPatientById(patientId);
        if (patient == null) {
            // Patient not registered
            return false;
        }
        if (waitlistQueue.contains(patient)) {
            // Patient already on waitlist
            return false;
        }
        // offer() is preferred over add() for queues as it returns false on failure instead of throwing exception
        return waitlistQueue.offer(patient);
    }

    /**
     * Removes and returns the next patient from the waitlist (FIFO).
     * @return The next Patient to be called, or null if the waitlist is empty.
     */
    public Patient callNextPatient() {
        // poll() is preferred over remove() for queues as it returns null on failure instead of throwing exception
        return waitlistQueue.poll();
    }

    /**
     * Gets a list of all registered patients.
     * @return A List containing all registered Patient objects.
     */
    public List<Patient> getAllPatients() {
        // Return a copy or unmodifiable list if you want to prevent external modification.
        // For this exam, returning the internal list reference is acceptable for simplicity.
        return allPatients;
    }

    /**
     * Gets a list of patients currently on the waitlist, in order.
     * Note: Iterating over a Queue is not guaranteed to be efficient,
     * but it allows viewing elements without removing them.
     * For display purposes, converting to a List is practical.
     * @return A List containing patients currently on the waitlist.
     */
    public List<Patient> getWaitlist() {
        // Convert the queue elements to a List for easy display iteration
        List<Patient> waitlistAsList = new ArrayList<>(waitlistQueue);
        return waitlistAsList;
    }
}

/**
 * Main class to run the Hospital Waitlist Management system.
 */
public class HospitalWaitlistApp {

    private static HospitalSystem hospitalSystem = new HospitalSystem();
    private static Scanner scanner = new Scanner(System.in);

    public static void main(String[] args) {
        int choice = -1;

        // Use a try-catch block to catch potential exceptions during the main loop
        // like Scanner issues or unexpected errors, providing a graceful exit.
        try {
            while (choice != 6) {
                printMenu();

                try {
                    System.out.print("Enter your choice: ");
                    choice = Integer.parseInt(scanner.nextLine()); // Read full line to avoid issues

                    // Use switch statement for menu navigation
                    switch (choice) {
                        case 1:
                            registerNewPatient();
                            break;
                        case 2:
                            addPatientToWaitlist();
                            break;
                        case 3:
                            callNextPatient();
                            break;
                        case 4:
                            viewAllRegisteredPatients();
                            break;
                        case 5:
                            viewCurrentWaitlist();
                            break;
                        case 6:
                            System.out.println("Exiting system. Goodbye!");
                            break;
                        default:
                            // Use System.err for invalid menu choices
                            System.err.println("Error: Invalid choice. Please enter a number between 1 and 6.");
                    }
                } catch (NumberFormatException e) {
                    // Use System.err for non-integer input errors
                    System.err.println("Error: Invalid input. Please enter a number.");
                    choice = -1; // Reset choice to prevent accidental exit if 6 was entered before error
                } catch (IllegalArgumentException e) {
                    // Catch exceptions from Patient constructor or other validation
                    System.err.println("Validation Error: " + e.getMessage());
                } catch (Exception e) {
                    // Catch any other unexpected exceptions
                    System.err.println("An unexpected error occurred: " + e.getMessage());
                    // e.printStackTrace(); // Uncomment for debugging
                }
                System.out.println(); // Add a blank line for readability
            }
        } finally {
            // Ensure the scanner is closed when the application exits
            scanner.close();
        }
    }

    /**
     * Prints the main menu options to the console.
     */
    private static void printMenu() {
        System.out.println("--- Hospital Waitlist Management ---");
        System.out.println("1. Register New Patient");
        System.out.println("2. Add Patient to Waitlist");
        System.out.println("3. Call Next Patient");
        System.out.println("4. View All Registered Patients");
        System.out.println("5. View Current Waitlist");
        System.out.println("6. Exit");
    }

    /**
     * Handles the process of registering a new patient.
     * Prompts user for details and calls the HospitalSystem method.
     */
    private static void registerNewPatient() {
        System.out.print("Enter Patient ID: ");
        String id = scanner.nextLine();
        System.out.print("Enter Patient Name: ");
        String name = scanner.nextLine();
        System.out.print("Enter Patient Condition: ");
        String condition = scanner.nextLine();

        // Basic input validation before creating Patient object
        if (id.trim().isEmpty() || name.trim().isEmpty() || condition.trim().isEmpty()) {
            System.err.println("Error: Patient details (ID, Name, Condition) cannot be empty.");
            return; // Stop registration process
        }

        try {
            Patient newPatient = new Patient(id, name, condition);
            if (hospitalSystem.registerPatient(newPatient)) {
                System.out.println("Patient " + newPatient.getId() + " registered successfully.");
            } else {
                // Use System.err for duplicate ID error
                System.err.println("Error: Patient with ID " + newPatient.getId() + " already exists.");
            }
        } catch (IllegalArgumentException e) {
            // Catch potential validation errors from Patient constructor
            System.err.println("Error creating patient: " + e.getMessage());
        }
    }

    /**
     * Handles the process of adding a patient to the waitlist.
     * Prompts user for patient ID and calls the HospitalSystem method.
     */
    private static void addPatientToWaitlist() {
        System.out.print("Enter Patient ID to add to waitlist: ");
        String patientId = scanner.nextLine();

        if (patientId.trim().isEmpty()) {
             System.err.println("Error: Patient ID cannot be empty.");
             return;
        }

        Patient patient = hospitalSystem.findPatientById(patientId);
        if (patient == null) {
            // Use System.err for patient not found error
            System.err.println("Error: Patient with ID " + patientId + " not found.");
            return;
        }

        if (hospitalSystem.addToWaitlist(patientId)) {
            System.out.println("Patient " + patientId + " added to the waitlist.");
        } else {
            // Use System.err for already on waitlist error
            System.err.println("Error: Patient with ID " + patientId + " is already on the waitlist.");
        }
    }

    /**
     * Handles the process of calling the next patient from the waitlist.
     * Calls the HospitalSystem method and displays the result.
     */
    private static void callNextPatient() {
        Patient nextPatient = hospitalSystem.callNextPatient();
        if (nextPatient != null) {
            System.out.println("Calling next patient from waitlist: " + nextPatient);
        } else {
            // Use System.err for empty waitlist error
            System.err.println("Error: Waitlist is empty.");
        }
    }

    /**
     * Displays all registered patients.
     * Retrieves the list using the List interface and prints contents.
     */
    private static void viewAllRegisteredPatients() {
        List<Patient> patients = hospitalSystem.getAllPatients(); // Using List interface
        System.out.println("--- All Registered Patients ---");
        if (patients.isEmpty()) {
            System.out.println("No patients registered.");
        } else {
            for (Patient p : patients) {
                System.out.println(p);
            }
        }
        System.out.println("-----------------------------");
    }

    /**
     * Displays the current waitlist.
     * Retrieves the list using the List interface (converted from Queue) and prints contents.
     */
    private static void viewCurrentWaitlist() {
        List<Patient> waitlist = hospitalSystem.getWaitlist(); // Using List interface
        System.out.println("--- Current Waitlist ---");
        if (waitlist.isEmpty()) {
            System.out.println("Waitlist is empty.");
        } else {
             for (Patient p : waitlist) {
                System.out.println(p);
            }
        }
        System.out.println("--------------------------");
    }
}
