/*
 * Exam Question #717
 * Generated on: 2025-05-12 16:30:01
 * Generated by: Account 1
 * 
 * QUESTION:
 * **Java Programming Exam Task: Print Job Management System**
 * 
 * You are tasked with developing a simple Print Job Management system. This system should allow users to add new print jobs, process the next job in the queue, view pending jobs, and view completed/failed jobs.
 * 
 * Your solution must demonstrate proficiency in core Java concepts, including object-oriented programming, collections, user input handling, control flow, and exception handling.
 * 
 * **Requirements:**
 * 
 * 1.  **Create a `PrintJob` class:**
 *     *   It should have private fields for `jobId` (int), `fileName` (String), and `status` (String - e.g., "Pending", "Processing", "Completed", "Failed").
 *     *   Implement a constructor to initialize `jobId` and `fileName`, setting the initial status to "Pending".
 *     *   Provide public getter methods for all fields.
 *     *   Provide a public setter method for the `status` field.
 *     *   Override the `toString()` method to provide a user-friendly string representation of the job.
 * 2.  **Create a `PrintJobManager` class:**
 *     *   It should manage the print jobs using a queue for pending jobs and a list for completed/failed jobs.
 *     *   Declare a private field `printQueue` of type `Queue<PrintJob>`. Use a concrete implementation like `LinkedList`.
 *     *   Declare a private field `completedJobs` of type `List<PrintJob>`. Use a concrete implementation like `ArrayList`.
 *     *   Declare a private field `nextJobId` (int) to generate unique job IDs, initialized to 1.
 *     *   Declare a private field `scanner` of type `Scanner` for user input.
 *     *   Implement a constructor to initialize the collection fields and the scanner.
 *     *   Implement a method `addJob(String fileName)`: Creates a new `PrintJob` with the next available ID, adds it to the `printQueue`, and increments `nextJobId`. Include basic validation for the file name (e.g., not empty).
 *     *   Implement a method `processNextJob()`:
 *         *   Retrieves and removes the next job from the `printQueue`.
 *         *   If the queue is empty, print a message to `System.out`.
 *         *   If a job is retrieved, simulate processing (e.g., print a message). Update its status to "Processing".
 *         *   **Crucially:** Implement a `try-catch` block within this method to simulate potential processing errors (e.g., a simulated `RuntimeException` or `InterruptedException`). If an error occurs, set the job status to "Failed". If successful, set the status to "Completed".
 *         *   After processing (whether successful or failed), add the job to the `completedJobs` list.
 *         *   Use `System.err` to report processing errors.
 *     *   Implement a method `viewQueue()`: Iterates through and prints details of all jobs currently in the `printQueue` to `System.out`.
 *     *   Implement a method `viewCompletedJobs()`: Iterates through and prints details of all jobs in the `completedJobs` list to `System.out`.
 *     *   Implement a `run()` method that contains the main application loop:
 *         *   Display a menu of options (Add Job, Process Next, View Queue, View Completed, Exit).
 *         *   Use `Scanner` to read the user's choice.
 *         *   Use a `switch` statement to handle the user's choice, calling the appropriate methods.
 *         *   Handle invalid input (non-integer choice, choice out of range) using `try-catch` for `InputMismatchException` and a `default` case in the `switch`. Print errors to `System.err`.
 *         *   The loop should continue until the user chooses to exit.
 *         *   **Implement class-wide exception handling:** Wrap the main `run()` loop (or significant parts of it) with a `try-catch(Exception e)` block to catch any unhandled exceptions that might occur during the application's execution and print an error message to `System.err`. Ensure the `Scanner` is closed in a `finally` block or similar mechanism upon application exit.
 * 3.  **Implement a `main` method** in the `PrintJobManager` class to create an instance of the manager and call its `run()` method to start the application.
 * 4.  **Adhere to best practices:** Use meaningful variable/method names, proper encapsulation, and add comments where necessary.
 * 
 * **Expected Output Structure:**
 * 
 * The output should be interactive, displaying a menu, prompting for input, and showing the status of jobs and queues based on user actions. Error messages from validation or exceptions should go to `System.err`, while normal output (menu, job status, queue content) goes to `System.out`.
 * 
 * ```
 * --- Print Job Manager ---
 * Select an option:
 * 1. Add Print Job
 * 2. Process Next Job
 * 3. View Print Queue
 * 4. View Completed/Failed Jobs
 * 5. Exit
 * Enter your choice: 1
 * Enter file name to print: report.pdf
 * Added job: 1 ('report.pdf') to the queue.
 * 
 * Select an option:
 * ... (menu repeats)
 * Enter your choice: 2
 * Processing job: 1 ('report.pdf')...
 * Job 1 completed successfully.
 * 
 * Select an option:
 * ... (menu repeats)
 * Enter your choice: 3
 * 
 * --- Current Print Queue ---
 * The queue is empty.
 * ---------------------------
 * 
 * Select an option:
 * ... (menu repeats)
 * Enter your choice: 4
 * 
 * --- Completed/Failed Jobs ---
 * 1. Job ID: 1, File: 'report.pdf', Status: Completed
 * -----------------------------
 * 
 * Select an option:
 * ... (menu repeats)
 * Enter your choice: 6
 * Error: Invalid choice. Please enter a number between 1 and 5. (This should go to System.err)
 * 
 * Select an option:
 * ... (menu repeats)
 * Enter your choice: abc
 * Error: Invalid input. Please enter a number. (This should go to System.err)
 * 
 * Select an option:
 * ... (menu repeats)
 * Enter your choice: 2
 * The print queue is empty. No jobs to process.
 * 
 * Select an option:
 * ... (menu repeats)
 * Enter your choice: 5
 * Exiting Print Job Manager.
 * ```
 *
 * EXPLANATION:
 * This solution implements a `PrintJobManager` system as requested, utilizing all specified Java components and adhering to best practices.
 * 
 * 1.  **`PrintJob` Class:** This class serves as a simple data structure (an object model) representing a single print task. It encapsulates the `jobId`, `fileName`, and `status` as private fields, providing controlled access through public getter and setter methods. The `toString()` method makes it easy to print job details.
 * 
 * 2.  **`PrintJobManager` Class:** This is the core class managing the system logic.
 *     *   **Collections:**
 *         *   `printQueue`: A `Queue<PrintJob>` implemented using `LinkedList` is used to hold jobs in a "Pending" state. The `Queue` interface is suitable because jobs are processed in a First-In, First-Out (FIFO) order using `offer()` to add and `poll()` to retrieve/remove.
 *         *   `completedJobs`: A `List<PrintJob>` implemented using `ArrayList` is used to store jobs once they have been processed (either "Completed" or "Failed"). A `List` is appropriate here as we just need to store and iterate through them, order isn't strictly FIFO after processing.
 *     *   **`nextJobId`:** A simple integer counter ensures each new job gets a unique ID.
 *     *   **`scanner`:** A `Scanner` is used for reading user input from `System.in`.
 *     *   **`addJob(String fileName)`:** Creates a `PrintJob` instance and adds it to the `printQueue` using `offer()`. Includes basic input validation for the file name.
 *     *   **`processNextJob()`:**
 *         *   Uses `printQueue.poll()` to get and remove the next job. `poll()` is safe as it returns `null` if the queue is empty, which is checked.
 *         *   Sets the job status to "Processing".
 *         *   Contains a nested `try-catch` block to simulate processing and potential errors (`InterruptedException` from `Thread.sleep` or a simulated `RuntimeException`). This demonstrates handling specific, expected exceptions within an operation.
 *         *   Based on whether an exception occurred or not, the job's status is updated to "Completed" or "Failed".
 *         *   A `finally` block ensures that the processed job is always added to the `completedJobs` list, regardless of the outcome of the processing simulation.
 *         *   `System.err` is used specifically for printing error messages related to processing failures.
 *     *   **`viewQueue()` and `viewCompletedJobs()`:** These methods iterate through the respective collections and print job details to `System.out`. Iterating over a `Queue` directly (like in `viewQueue()`) is possible but doesn't remove elements.
 *     *   **`run()`:** This method implements the main application loop.
 *         *   It repeatedly displays a menu and reads user input using the `scanner`.
 *         *   **`switch` Statement:** A `switch` statement is used to direct execution based on the user's integer choice, calling the appropriate manager methods.
 *         *   **Input Validation & Handling:** A `try-catch(InputMismatchException e)` block is used around `scanner.nextInt()` to catch cases where the user enters non-numeric input for the menu choice. An error message is printed to `System.err`, and `scanner.nextLine()` is called to consume the invalid input line, preventing an infinite loop. The `default` case in the `switch` handles valid integer input that is outside the expected range (1-5), also printing an error to `System.err`.
 *         *   **Class-wide Exception Handling:** The entire `while(running)` loop within the `run()` method is wrapped in a `try-catch(Exception e)` block. This demonstrates catching any unexpected exceptions that might occur during the execution of the main application flow that weren't specifically handled elsewhere. The error is printed to `System.err`.
 *         *   **Resource Management:** A `finally` block is used after the main `try-catch` in `run()` to ensure the `scanner` resource is closed when the application loop finishes (either by exiting normally or due to an unhandled exception).
 * 
 * 3.  **`main` Method:** The standard entry point of the application. It creates an instance of `PrintJobManager` and calls its `run()` method to start the interactive system.
 * 
 * This solution effectively integrates the required Java components into a functional, albeit simple, application, demonstrating understanding of collections, object states, user interaction patterns, and robust error handling using `try-catch` and `System.err`.
 */

import java.util.Queue;
import java.util.LinkedList; // Implements Queue
import java.util.List;
import java.util.ArrayList;
import java.util.Scanner;
import java.util.InputMismatchException;
import java.util.concurrent.TimeUnit; // For simulation delay

/**
 * Represents a single print job with ID, file name, and status.
 */
class PrintJob {
    private int jobId;
    private String fileName;
    private String status; // e.g., "Pending", "Processing", "Completed", "Failed"

    /**
     * Constructs a new PrintJob.
     * @param jobId The unique ID for the job.
     * @param fileName The name of the file to print.
     */
    public PrintJob(int jobId, String fileName) {
        this.jobId = jobId;
        this.fileName = fileName;
        this.status = "Pending"; // Initial status
    }

    // --- Getters ---
    public int getJobId() {
        return jobId;
    }

    public String getFileName() {
        return fileName;
    }

    public String getStatus() {
        return status;
    }

    // --- Setter ---
    /**
     * Sets the status of the print job.
     * @param status The new status (e.g., "Processing", "Completed", "Failed").
     */
    public void setStatus(String status) {
        this.status = status;
    }

    /**
     * Provides a string representation of the PrintJob.
     */
    @Override
    public String toString() {
        return "Job ID: " + jobId + ", File: '" + fileName + "', Status: " + status;
    }
}

/**
 * Manages a queue of print jobs and a list of completed/failed jobs.
 */
public class PrintJobManager {

    private Queue<PrintJob> printQueue; // Queue for pending jobs
    private List<PrintJob> completedJobs; // List for completed/failed jobs
    private int nextJobId; // Counter for unique job IDs
    private Scanner scanner; // Scanner for user input

    /**
     * Constructs a new PrintJobManager.
     * Initializes the queue, list, job ID counter, and scanner.
     */
    public PrintJobManager() {
        // LinkedList implements the Queue interface
        this.printQueue = new LinkedList<>();
        // ArrayList implements the List interface
        this.completedJobs = new ArrayList<>();
        this.nextJobId = 1; // Start ID from 1
        this.scanner = new Scanner(System.in);
    }

    /**
     * Adds a new print job to the queue.
     * @param fileName The name of the file for the new job.
     */
    public void addJob(String fileName) {
        // Basic input validation for file name
        if (fileName == null || fileName.trim().isEmpty()) {
            System.err.println("Error: File name cannot be empty.");
            return;
        }
        PrintJob newJob = new PrintJob(nextJobId++, fileName);
        printQueue.offer(newJob); // Add to the end of the queue (offer is preferred over add)
        System.out.println("Added job: " + newJob.getJobId() + " ('" + newJob.getFileName() + "') to the queue.");
    }

    /**
     * Processes the next job from the print queue.
     * Demonstrates exception handling during processing simulation.
     */
    public void processNextJob() {
        // Use poll() to retrieve and remove the head of the queue, returns null if empty
        PrintJob jobToProcess = printQueue.poll();

        if (jobToProcess == null) {
            System.out.println("The print queue is empty. No jobs to process.");
            return;
        }

        System.out.println("Processing job: " + jobToProcess.getJobId() + " ('" + jobToProcess.getFileName() + "')...");
        jobToProcess.setStatus("Processing");

        // --- Simulate processing time and potential failure ---
        // This try-catch block demonstrates handling exceptions specific to job processing.
        try {
            // Simulate work time
            TimeUnit.SECONDS.sleep(2);

            // Simulate random success/failure (e.g., 20% chance of failure)
            if (Math.random() < 0.2) {
                // Simulate a runtime error during processing
                throw new RuntimeException("Simulated print error: Printer offline!");
            }

            // If simulation succeeds
            jobToProcess.setStatus("Completed");
            System.out.println("Job " + jobToProcess.getJobId() + " completed successfully.");

        } catch (InterruptedException e) {
            // Handle if the sleep was interrupted
            System.err.println("Processing interrupted for job " + jobToProcess.getJobId() + ": " + e.getMessage());
            jobToProcess.setStatus("Failed");
            // Restore the interrupted status
            Thread.currentThread().interrupt();
        } catch (RuntimeException e) {
            // Handle the simulated processing failure
            System.err.println("Processing failed for job " + jobToProcess.getJobId() + ": " + e.getMessage());
            jobToProcess.setStatus("Failed");
        } catch (Exception e) {
             // Catch any other unexpected exceptions during processing
             System.err.println("An unexpected error occurred during processing job " + jobToProcess.getJobId() + ": " + e.getMessage());
             jobToProcess.setStatus("Failed"); // Mark as failed on unexpected error
        } finally {
            // The finally block ensures the job is always added to the completed list,
            // regardless of whether processing succeeded, failed, or threw an exception.
            completedJobs.add(jobToProcess);
        }
    }

    /**
     * Displays the current print queue.
     */
    public void viewQueue() {
        System.out.println("\n--- Current Print Queue ---");
        if (printQueue.isEmpty()) {
            System.out.println("The queue is empty.");
        } else {
            // Iterate through the queue without removing elements
            int index = 1;
            for (PrintJob job : printQueue) {
                System.out.println(index++ + ". " + job);
            }
        }
        System.out.println("---------------------------");
    }

    /**
     * Displays the list of completed and failed jobs.
     */
    public void viewCompletedJobs() {
        System.out.println("\n--- Completed/Failed Jobs ---");
        if (completedJobs.isEmpty()) {
            System.out.println("No jobs have been completed or failed yet.");
        } else {
            // Iterate through the list
            int index = 1;
            for (PrintJob job : completedJobs) {
                System.out.println(index++ + ". " + job);
            }
        }
        System.out.println("-----------------------------");
    }

    /**
     * Runs the main application loop, handling user interaction.
     * Includes class-wide exception handling.
     */
    public void run() {
        System.out.println("--- Print Job Manager ---");
        boolean running = true;

        // --- Class-wide exception handling for the main application loop ---
        try {
            while (running) {
                printMenu(); // Display the menu

                int choice = -1;
                // --- Input validation and exception handling for menu choice ---
                try {
                    System.out.print("Enter your choice: ");
                    choice = scanner.nextInt();
                    // Consume the rest of the line after reading the integer
                    scanner.nextLine();
                } catch (InputMismatchException e) {
                    // Handle cases where the user enters non-integer input
                    System.err.println("Invalid input. Please enter a number.");
                    // Consume the invalid input to prevent infinite loop
                    scanner.nextLine();
                    continue; // Skip the rest of the loop iteration and show menu again
                }

                // --- Switch statement for handling menu options ---
                switch (choice) {
                    case 1:
                        System.out.print("Enter file name to print: ");
                        String fileName = scanner.nextLine();
                        addJob(fileName);
                        break;
                    case 2:
                        processNextJob();
                        break;
                    case 3:
                        viewQueue();
                        break;
                    case 4:
                        viewCompletedJobs();
                        break;
                    case 5:
                        running = false; // Set flag to exit the loop
                        System.out.println("Exiting Print Job Manager.");
                        break;
                    default:
                        // Handle choices that are integers but out of the valid range
                        System.err.println("Invalid choice. Please enter a number between 1 and 5.");
                        break;
                }
            }
        } catch (Exception e) {
            // --- Catch any unhandled exceptions that propagate up to the main loop ---
            System.err.println("An unexpected fatal error occurred during application execution: " + e.getMessage());
            e.printStackTrace(); // Print stack trace for debugging purposes
        } finally {
             // --- Ensure the scanner is closed when the application exits ---
             if (scanner != null) {
                 scanner.close();
                 System.out.println("Scanner closed."); // Optional confirmation
             }
        }
    }

    /**
     * Helper method to print the main menu options.
     */
    private void printMenu() {
        System.out.println("\nSelect an option:");
        System.out.println("1. Add Print Job");
        System.out.println("2. Process Next Job");
        System.out.println("3. View Print Queue");
        System.out.println("4. View Completed/Failed Jobs");
        System.out.println("5. Exit");
    }

    /**
     * Main method to start the Print Job Manager application.
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        PrintJobManager manager = new PrintJobManager();
        manager.run(); // Start the application loop
    }
}
