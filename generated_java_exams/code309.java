/*
 * Exam Question #309
 * Generated on: 2025-05-11 22:53:02
 * Generated by: Account 5
 * 
 * QUESTION:
 * ## Advanced Java Programming Exam Task: Team Task Management System
 * 
 * **Scenario:**
 * 
 * Your team needs a simple command-line application to manage tasks. Tasks are added, placed into a queue for processing, and marked as complete once processed. The system should keep track of all tasks created, regardless of their current status or whether they are in the processing queue.
 * 
 * **Your Task:**
 * 
 * Implement a Java program that simulates this task management system.
 * 
 * **Requirements:**
 * 
 * 1.  **Task Representation:** Create a `Task` class with the following private attributes:
 *     *   `id` (int): A unique identifier, automatically generated sequentially starting from 1.
 *     *   `description` (String): A brief description of the task.
 *     *   `priority` (enum `Priority`): Can be `HIGH`, `MEDIUM`, or `LOW`.
 *     *   `status` (enum `Status`): Can be `PENDING` or `COMPLETED`.
 *     *   Include appropriate public getter methods for these attributes.
 *     *   Include a public method `setStatus(Status status)` to update the task's status.
 *     *   Override the `toString()` method to provide a user-friendly representation of the task.
 *     *   Use enums `Priority` and `Status` which you must define.
 * 
 * 2.  **Data Storage:** The system must maintain two primary collections:
 *     *   A `List<Task>` (using `java.util.ArrayList`) named `allTasks` to store *every* task ever created.
 *     *   A `Queue<Task>` (using an appropriate implementation from `java.util.Queue`, e.g., `java.util.LinkedList` or `java.util.ArrayDeque`) named `pendingTasksQueue` to store tasks that are currently waiting to be processed.
 * 
 * 3.  **User Interface:** Implement a command-line interface using `java.util.Scanner` to interact with the user. The program should present a menu of available commands and process user input.
 * 
 * 4.  **Commands:** Support the following commands:
 *     *   `add`: Prompts the user for a task description and priority. Creates a new `Task` object, adds it to both `allTasks` and `pendingTasksQueue`.
 *     *   `list_all`: Displays all tasks currently stored in the `allTasks` list.
 *     *   `process_next`: Removes the next task from the head of the `pendingTasksQueue`. If a task is successfully retrieved, update its `status` to `COMPLETED` within the `allTasks` list (you'll need to find the task in `allTasks` by its ID). Display a confirmation message. If the queue is empty, display an error message.
 *     *   `view_pending`: Displays all tasks currently in the `pendingTasksQueue`.
 *     *   `exit`: Terminates the program.
 * 
 * 5.  **Flow Control:** Use a `switch` statement to handle the different user commands.
 * 
 * 6.  **Output:**
 *     *   Use `System.out` for displaying menu options, task lists, and success messages.
 *     *   Use `System.err` for displaying error messages (e.g., invalid command, queue empty for processing, invalid input format).
 * 
 * 7.  **Error Handling:** Implement robust exception handling using `try-catch` blocks. This should include:
 *     *   Handling potential input errors when reading task priority (e.g., user enters an invalid string).
 *     *   Handling the case where `process_next` is called on an empty queue.
 *     *   Include a general `catch (Exception e)` block to catch any unexpected runtime errors and print an informative message to `System.err`.
 *     *   Place `try-catch` blocks around the main command processing loop to handle errors gracefully without crashing the program.
 * 
 * 8.  **Best Practices:**
 *     *   Adhere to proper encapsulation in the `Task` class.
 *     *   Use meaningful names for variables, methods, and classes.
 *     *   Include comments where necessary to explain complex logic.
 *     *   Validate user input where appropriate (e.g., task priority).
 *     *   Ensure the `Scanner` is properly closed upon program termination.
 * 
 * **Expected Output:**
 * 
 * Your program should behave interactively like a command-line application. Output should be clear, using `System.out` for normal information and `System.err` for errors. An example interaction might look similar to the sketch provided in the thought process, showing task addition, listing, viewing pending, processing, and handling the empty queue case.
 * 
 * ```
 * Task Management System
 * Available Commands: add, list_all, process_next, view_pending, exit
 * 
 * Enter command: add
 * Enter task description: Implement login
 * Enter priority (HIGH, MEDIUM, LOW): HIGH
 * Task added with ID: 1
 * 
 * Enter command: add
 * Enter task description: Design database schema
 * Enter priority (HIGH, MEDIUM, LOW): MEDIUM
 * Task added with ID: 2
 * 
 * Enter command: view_pending
 * Pending Tasks:
 * ID: 1, Description: Implement login, Priority: HIGH, Status: PENDING
 * ID: 2, Description: Design database schema, Priority: MEDIUM, Status: PENDING
 * 
 * Enter command: process_next
 * Processing task with ID: 1, Description: Implement login
 * Task ID 1 marked as COMPLETED.
 * 
 * Enter command: list_all
 * All Tasks:
 * ID: 1, Description: Implement login, Priority: HIGH, Status: COMPLETED
 * ID: 2, Description: Design database schema, Priority: MEDIUM, Status: PENDING
 * 
 * Enter command: process_next
 * Processing task with ID: 2, Description: Design database schema
 * Task ID 2 marked as COMPLETED.
 * 
 * Enter command: process_next
 * Error: No tasks currently in the pending queue to process.
 * 
 * Enter command: exit
 * Exiting Task Management System.
 * ```
 *
 * EXPLANATION:
 * This solution implements the Task Management System as described in the exam question, demonstrating the required Java concepts and best practices.
 * 
 * 1.  **Task Representation:** The `Task` class encapsulates the task data (`id`, `description`, `priority`, `status`) using private fields. A static `nextId` ensures unique sequential IDs. Enums `Priority` and `Status` provide type-safe representations for these attributes. Getters provide controlled access to the data, and `setStatus` allows modifying only the status. The `toString()` method provides a convenient way to display task details.
 * 
 * 2.  **Data Storage:**
 *     *   `List<Task> allTasks = new ArrayList<>();`: An `ArrayList` is used, implementing the `List` interface. This collection stores every task created, acting as the system's complete historical record of tasks. `ArrayList` is suitable for frequent iteration and random access (though not heavily used here), which is typical for listing all items.
 *     *   `Queue<Task> pendingTasksQueue = new LinkedList<>();`: A `LinkedList` is used, implementing the `Queue` interface. This collection manages tasks waiting for processing. `Queue` provides FIFO (First-In, First-Out) behavior, which is natural for a processing queue where tasks are handled in the order they become pending. `LinkedList` is a common `Queue` implementation that performs well for additions and removals at the ends.
 * 
 * 3.  **User Interface and Flow Control:** The `main` method creates a `TaskManagementSystem` instance and calls `start()`. The `start()` method contains the main application loop. It uses a `Scanner` to read user input from the console. A `switch` statement is used to efficiently direct execution based on the command entered by the user (`add`, `list_all`, `process_next`, `view_pending`, `exit`).
 * 
 * 4.  **Command Implementation:**
 *     *   `addTask()`: Reads description and priority from the user. It includes input validation for the priority string, attempting to convert it to the `Priority` enum using `Priority.valueOf()` and catching `IllegalArgumentException` if the input is invalid. A new `Task` is created and added to *both* `allTasks` and `pendingTasksQueue`.
 *     *   `listAllTasks()`: Iterates through the `allTasks` `ArrayList` and prints each task's details using its `toString()` method.
 *     *   `processNextTask()`: Uses `pendingTasksQueue.poll()` to retrieve and remove the element at the head of the queue. `poll()` is used instead of `remove()` because it returns `null` if the queue is empty, allowing for graceful handling without throwing a `NoSuchElementException`. If a task is retrieved, the code then iterates through the `allTasks` `List` to find the task with the matching ID and updates its status to `COMPLETED`. This demonstrates how the two collections interact. An error message is printed to `System.err` if `poll()` returns `null`.
 *     *   `viewPendingTasks()`: Iterates through the `pendingTasksQueue` and prints the details of tasks currently waiting. Note that iterating a `Queue` typically processes elements in their queue order, but the iteration itself doesn't remove them.
 *     *   `exit`: Sets the `running` flag to `false`, terminating the main loop and ending the program after closing the `Scanner`.
 * 
 * 5.  **Error Handling:** `try-catch` blocks are used extensively:
 *     *   The main command processing loop in `start()` is wrapped in a `try-catch` block.
 *     *   A specific `catch (InputMismatchException e)` is included, although less critical here as `nextLine()` is mostly used, it's good practice for `Scanner` input.
 *     *   A specific `catch (IllegalArgumentException e)` is used to handle errors during the conversion of the priority string to the `Priority` enum in `addTask()`. Error messages are printed to `System.err`.
 *     *   A general `catch (Exception e)` is included as a fallback to catch any other unexpected runtime errors, printing the error message and stack trace to `System.err`.
 *     *   The `processNextTask()` method explicitly checks if `pendingTasksQueue.poll()` returns `null` to handle the empty queue case, printing an error to `System.err`.
 * 
 * 6.  **Best Practices:**
 *     *   **Encapsulation:** The `Task` class uses private fields and public methods.
 *     *   **Meaningful Names:** Classes (`Task`, `TaskManagementSystem`), variables (`allTasks`, `pendingTasksQueue`, `description`, `priority`), methods (`addTask`, `processNextTask`, `listAllTasks`), and enums (`Priority`, `Status`) have clear, descriptive names.
 *     *   **Comments:** Javadoc comments explain the purpose of classes and methods, and inline comments clarify specific logic.
 *     *   **Input Validation:** The priority input in `addTask()` is explicitly validated against the `Priority` enum values.
 *     *   **Resource Management:** The `Scanner` is closed using `scanner.close()` when the program exits.
 *     *   **Output Streams:** Correct use of `System.out` for normal output and `System.err` for errors.
 * 
 * This solution effectively utilizes all the required Java components in a cohesive, practical application, demonstrating understanding of data structures, control flow, object-oriented principles, and robust error handling.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.InputMismatchException;
import java.util.NoSuchElementException; // Although poll() is safer, good to know about remove()

// Enum for Task Priority
enum Priority {
    HIGH, MEDIUM, LOW
}

// Enum for Task Status
enum Status {
    PENDING, COMPLETED
}

// Task class representing a single task
class Task {
    private static int nextId = 1; // Static counter for unique IDs

    private int id;
    private String description;
    private Priority priority;
    private Status status;

    /**
     * Constructs a new Task.
     * @param description The task description.
     * @param priority The task priority.
     */
    public Task(String description, Priority priority) {
        this.id = nextId++; // Assign and increment ID
        this.description = description;
        this.priority = priority;
        this.status = Status.PENDING; // New tasks are always pending
    }

    // --- Getters ---
    public int getId() {
        return id;
    }

    public String getDescription() {
        return description;
    }

    public Priority getPriority() {
        return priority;
    }

    public Status getStatus() {
        return status;
    }

    /**
     * Sets the status of the task.
     * @param status The new status.
     */
    public void setStatus(Status status) {
        this.status = status;
    }

    /**
     * Provides a string representation of the Task.
     * @return Formatted string of the task details.
     */
    @Override
    public String toString() {
        return String.format("ID: %d, Description: %s, Priority: %s, Status: %s",
                             id, description, priority, status);
    }
}

// Main class for the Task Management System
public class TaskManagementSystem {

    // Use List interface type, implemented by ArrayList
    private List<Task> allTasks = new ArrayList<>();
    // Use Queue interface type, implemented by LinkedList
    private Queue<Task> pendingTasksQueue = new LinkedList<>();
    private Scanner scanner = new Scanner(System.in);

    /**
     * Starts the task management system.
     */
    public void start() {
        System.out.println("Task Management System");
        System.out.println("Available Commands: add, list_all, process_next, view_pending, exit");

        boolean running = true;
        while (running) {
            System.out.print("\nEnter command: ");
            // Use a try-catch block to handle potential issues during command processing
            try {
                String command = scanner.nextLine().trim().toLowerCase();

                // Use switch statement for command processing
                switch (command) {
                    case "add":
                        addTask();
                        break;
                    case "list_all":
                        listAllTasks();
                        break;
                    case "process_next":
                        processNextTask();
                        break;
                    case "view_pending":
                        viewPendingTasks();
                        break;
                    case "exit":
                        running = false;
                        System.out.println("Exiting Task Management System.");
                        break;
                    default:
                        // Use System.err for invalid command messages
                        System.err.println("Error: Unknown command. Please try again.");
                }
            } catch (InputMismatchException e) {
                // Catch specific input format errors if any read operation fails type expectations
                // (Less likely here as we mostly read lines, but good practice)
                System.err.println("Error: Invalid input format. " + e.getMessage());
                // Consume the invalid input to prevent infinite loop
                if (scanner.hasNextLine()) {
                     scanner.nextLine();
                }
            } catch (IllegalArgumentException e) {
                 // Catch specific errors like invalid enum value
                 System.err.println("Error: Invalid argument provided. " + e.getMessage());
            } catch (Exception e) {
                // General catch-all for unexpected errors
                System.err.println("An unexpected error occurred: " + e.getMessage());
                e.printStackTrace(); // Print stack trace for debugging
            }
        }

        // Close the scanner when the program exits
        scanner.close();
    }

    /**
     * Handles the 'add' command to create and add a new task.
     */
    private void addTask() {
        System.out.print("Enter task description: ");
        String description = scanner.nextLine().trim();
        if (description.isEmpty()) {
            System.err.println("Error: Description cannot be empty.");
            return;
        }

        Priority priority = null;
        boolean validPriority = false;
        while (!validPriority) {
            System.out.print("Enter priority (HIGH, MEDIUM, LOW): ");
            String priorityString = scanner.nextLine().trim().toUpperCase();
            try {
                // Input validation and conversion to enum
                priority = Priority.valueOf(priorityString);
                validPriority = true;
            } catch (IllegalArgumentException e) {
                // Use System.err for input validation errors
                System.err.println("Error: Invalid priority. Please enter HIGH, MEDIUM, or LOW.");
            }
        }

        Task newTask = new Task(description, priority);
        allTasks.add(newTask); // Add to the list of all tasks
        pendingTasksQueue.add(newTask); // Add to the pending queue

        System.out.println("Task added with ID: " + newTask.getId());
    }

    /**
     * Handles the 'list_all' command to display all tasks.
     */
    private void listAllTasks() {
        System.out.println("\nAll Tasks:");
        if (allTasks.isEmpty()) {
            System.out.println("No tasks created yet.");
        } else {
            // Iterate through the List (ArrayList) and print each task
            for (Task task : allTasks) {
                System.out.println(task);
            }
        }
    }

    /**
     * Handles the 'process_next' command to process the next task in the queue.
     */
    private void processNextTask() {
        // Use poll() which returns null if the queue is empty (safer than remove())
        Task taskToProcess = pendingTasksQueue.poll();

        if (taskToProcess == null) {
            // Use System.err for error when queue is empty
            System.err.println("Error: No tasks currently in the pending queue to process.");
        } else {
            System.out.println("Processing task with " + taskToProcess.toString().split(", Status:")[0]); // Print details before status

            // Find the task in the allTasks list by ID and update its status
            // This demonstrates interaction between the Queue and the List
            boolean foundInAllTasks = false;
            for (Task task : allTasks) {
                if (task.getId() == taskToProcess.getId()) {
                    task.setStatus(Status.COMPLETED);
                    foundInAllTasks = true;
                    break; // Found the task, no need to continue searching
                }
            }

            // Although in this logic taskToProcess comes from allTasks,
            // this check makes the logic robust if tasks could be added/removed differently.
            if (foundInAllTasks) {
                 System.out.println("Task ID " + taskToProcess.getId() + " marked as " + Status.COMPLETED + ".");
            } else {
                 // This case should ideally not happen in this specific program flow,
                 // but included for robust error reporting.
                 System.err.println("Warning: Processed task ID " + taskToProcess.getId() + " not found in the main task list.");
            }
        }
    }

    /**
     * Handles the 'view_pending' command to display tasks in the queue.
     */
    private void viewPendingTasks() {
        System.out.println("\nPending Tasks:");
        if (pendingTasksQueue.isEmpty()) {
            System.out.println("No tasks currently in the pending queue.");
        } else {
            // Iterate through the Queue and print each task (order depends on Queue implementation)
            // Using peek() and iteration or converting to List for printing without removing
            // For simple display, iterating directly is fine if the order isn't strictly guaranteed FIFO during iteration itself.
            // To guarantee FIFO display order without removing, could copy to temp list:
            // List<Task> pendingList = new ArrayList<>(pendingTasksQueue);
            // for (Task task : pendingList) { ... }
            // However, simple iteration is sufficient for the requirement "Displays all tasks currently in the Queue".
            for (Task task : pendingTasksQueue) {
                 System.out.println(task);
            }
        }
    }

    /**
     * Main method to start the application.
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        TaskManagementSystem system = new TaskManagementSystem();
        system.start();
    }
}
