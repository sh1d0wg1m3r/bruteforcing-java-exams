/*
 * Exam Question #952
 * Generated on: 2025-05-12 17:04:29
 * Generated by: Account 2
 * 
 * QUESTION:
 * **Complex Task Management System Simulation**
 * 
 * **Scenario:**
 * You are tasked with building a simple command-line application to simulate a task management system. This system allows users to add new tasks, execute the next pending task, view pending tasks, and view completed tasks. Tasks have a description and a priority level. The system should process tasks in the order they were added (FIFO), but the priority is recorded for information purposes.
 * 
 * **Requirements:**
 * 
 * 1.  **Task Representation:** Create a `Task` class with private fields for `description` (String) and `priority` (String, e.g., "HIGH", "MEDIUM", "LOW"). Include a constructor and appropriate public getter methods.
 * 2.  **Task Manager:** Create a `TaskManager` class that manages the tasks.
 *     *   It must internally use a `java.util.Queue<Task>` to store pending tasks.
 *     *   It must internally use a `java.util.ArrayList<Task>` to store completed tasks.
 *     *   Include public methods:
 *         *   `addTask(Task task)`: Adds a task to the pending queue.
 *         *   `executeNextTask()`: Removes the next task from the pending queue and adds it to the completed list. It should return the executed task or indicate failure if the queue is empty.
 *         *   `getPendingTasks()`: Returns a `java.util.List<Task>` containing all tasks currently in the pending queue. The order should reflect the processing order.
 *         *   `getCompletedTasks()`: Returns a `java.util.List<Task>` containing all completed tasks.
 * 3.  **Main Application:** Create a main class (`TaskApp` or similar) with a `main` method to interact with the user.
 *     *   Use `java.util.Scanner` to read user input from the console.
 *     *   Implement a menu-driven interface with the following options:
 *         1.  Add New Task
 *         2.  Execute Next Task
 *         3.  View Pending Tasks
 *         4.  View Completed Tasks
 *         5.  Exit
 *     *   Use a `switch` statement to handle the user's menu choice.
 *     *   Implement input validation for menu choices and task priority (accept only "HIGH", "MEDIUM", "LOW" case-insensitively when adding a task). Prompt the user again if input is invalid.
 *     *   Use `System.out` for displaying the menu, prompts, task details, and success messages.
 *     *   Use `System.err` for displaying error messages (e.g., invalid input, attempting to execute when no tasks are pending).
 *     *   Implement class-wide exception handling using `try-catch` blocks. This could be around the main application loop or within specific operations to catch unexpected errors (like `InputMismatchException` from Scanner or potential issues from Queue operations, although safe methods like `poll` are preferred for expected empty states). Handle at least `InputMismatchException` during input reading.
 *     *   Ensure proper resource management (closing the `Scanner`).
 * 4.  **Best Practices:**
 *     *   Use appropriate data types and meaningful variable/method names.
 *     *   Include comments or Javadoc where necessary.
 *     *   Adhere to encapsulation principles (private fields, public getters/methods).
 * 
 * **Expected Output:**
 * 
 * The application should run interactively.
 * *   When adding a task, it should prompt for description and priority, validate priority, and confirm addition.
 * *   When executing a task, it should report which task was executed or state that no tasks are pending.
 * *   When viewing tasks, it should list them with description and priority.
 * *   Invalid inputs should result in an error message on `System.err` and the menu being displayed again (or re-prompting for specific invalid input like priority).
 * *   Unexpected errors should be caught and reported.
 * 
 * **Example Interaction Flow:**
 * 
 * ```
 * --- Task Management Menu ---
 * 1. Add New Task
 * 2. Execute Next Task
 * 3. View Pending Tasks
 * 4. View Completed Tasks
 * 5. Exit
 * Enter your choice: 1
 * Enter task description: Write Exam Question
 * Enter task priority (HIGH, MEDIUM, LOW): HIGH
 * Task added: Write Exam Question (HIGH)
 * 
 * --- Task Management Menu ---
 * 1. Add New Task
 * 2. Execute Next Task
 * 3. View Pending Tasks
 * 4. View Completed Tasks
 * 5. Exit
 * Enter your choice: 1
 * Enter task description: Grade Papers
 * Enter task priority (HIGH, MEDIUM, LOW): medium
 * Task added: Grade Papers (MEDIUM)
 * 
 * --- Task Management Menu ---
 * 1. Add New Task
 * 2. Execute Next Task
 * 3. View Pending Tasks
 * 4. View Completed Tasks
 * 5. Exit
 * Enter your choice: 3
 * --- Pending Tasks ---
 * 1. Write Exam Question (HIGH)
 * 2. Grade Papers (MEDIUM)
 * 
 * --- Task Management Menu ---
 * 1. Add New Task
 * 2. Execute Next Task
 * 3. View Pending Tasks
 * 4. View Completed Tasks
 * 5. Exit
 * Enter your choice: 2
 * Executing task: Write Exam Question (HIGH)
 * Task completed.
 * 
 * --- Task Management Menu ---
 * 1. Add New Task
 * 2. Execute Next Task
 * 3. View Pending Tasks
 * 4. View Completed Tasks
 * 5. Exit
 * Enter your choice: 3
 * --- Pending Tasks ---
 * 1. Grade Papers (MEDIUM)
 * 
 * --- Task Management Menu ---
 * 1. Add New Task
 * 2. Execute Next Task
 * 3. View Pending Tasks
 * 4. View Completed Tasks
 * 5. Exit
 * Enter your choice: 4
 * --- Completed Tasks ---
 * 1. Write Exam Question (HIGH)
 * 
 * --- Task Management Menu ---
 * 1. Add New Task
 * 2. Execute Next Task
 * 3. View Pending Tasks
 * 4. View Completed Tasks
 * 5. Exit
 * Enter your choice: 2
 * Executing task: Grade Papers (MEDIUM)
 * Task completed.
 * 
 * --- Task Management Menu ---
 * 1. Add New Task
 * 2. Execute Next Task
 * 3. View Pending Tasks
 * 4. View Completed Tasks
 * 5. Exit
 * Enter your choice: 2
 * System.err: No tasks pending to execute.
 * 
 * --- Task Management Menu ---
 * ...
 * Enter your choice: 5
 * Exiting Task Management System.
 * ```
 * 
 * This task requires you to integrate multiple core Java concepts and standard library classes to build a functional, robust, and user-friendly command-line application.
 *
 * EXPLANATION:
 * This solution implements a simple task management system demonstrating the required Java concepts.
 * 
 * 1.  **`Task` Class:** This is a simple Plain Old Java Object (POJO) representing a task. It encapsulates the `description` and `priority` as private fields and provides public getter methods, adhering to encapsulation principles. The `toString()` method is overridden for easy printing.
 * 
 * 2.  **`TaskManager` Class:** This class acts as the core logic handler.
 *     *   It uses a `java.util.Queue<Task>` (`pendingTasks`) implemented by `java.util.LinkedList` to store tasks awaiting execution. `LinkedList` is a common implementation of the `Queue` interface and provides FIFO behavior suitable for this scenario.
 *     *   It uses a `java.util.ArrayList<Task>` (`completedTasks`) to store tasks that have been processed. `ArrayList` provides dynamic resizing and efficient storage/retrieval of completed items.
 *     *   The `addTask` method adds a task to the end of the `pendingTasks` queue using `offer()`.
 *     *   The `executeNextTask` method uses `poll()` to retrieve and remove the task at the head of the `pendingTasks` queue. `poll()` is used because it safely returns `null` if the queue is empty, which is handled by the calling code. If a task is retrieved, it's added to the `completedTasks` `ArrayList`.
 *     *   `getPendingTasks()` and `getCompletedTasks()` methods return copies of the internal lists as `java.util.List<Task>`. Returning the `List` interface is a good practice as it hides the specific implementation (`ArrayList`, `LinkedList`) from the caller and allows flexibility. Returning a *new* `ArrayList` containing the elements ensures that external code cannot directly modify the internal queue or list, maintaining encapsulation.
 * 
 * 3.  **`TaskApp` Class:** This class contains the `main` method and handles user interaction.
 *     *   A `static Scanner` is used for reading input from `System.in`. It's closed when the application exits to release the system resource.
 *     *   The `runMenu` method contains the main application loop (`while(running)`).
 *     *   A `try-catch` block is wrapped around the core logic within the loop. This provides class-wide exception handling. It specifically catches `InputMismatchException` which can occur if the user enters non-integer input when prompted for a menu choice, preventing the application from crashing and allowing recovery. A general `Exception` catch is also included for unexpected errors. Error messages are printed to `System.err`.
 *     *   A `switch` statement is used to process the user's integer choice, directing execution to the appropriate helper method (`addTask`, `executeTask`, etc.). This fulfills the `switch` requirement.
 *     *   Helper methods like `addTask`, `executeTask`, `viewPendingTasks`, and `viewCompletedTasks` encapsulate the logic for each menu option.
 *     *   `addTask` includes a loop and a `switch` statement to validate that the user enters a valid priority ("HIGH", "MEDIUM", "LOW"), re-prompting until valid input is received.
 *     *   `executeTask` checks if the pending queue is empty using `taskManager.isPendingQueueEmpty()` before attempting to execute, printing an error message to `System.err` if empty. This demonstrates input validation/state checking before operation.
 *     *   `viewPendingTasks` and `viewCompletedTasks` retrieve the task lists using the `TaskManager` methods that return `List<Task>` and iterate through them to print details using `System.out`.
 * 
 * This solution effectively integrates `Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.err`, `System.out`, `try-catch`, encapsulation, and input validation within a practical simulation, meeting all specified requirements for a challenging exam task.
 */

import java.util.Queue;
import java.util.LinkedList; // LinkedList is a common implementation for Queue
import java.util.List;
import java.util.ArrayList;
import java.util.Scanner;
import java.util.InputMismatchException;

/**
 * Represents a single task with a description and priority.
 */
class Task {
    private String description;
    private String priority; // e.g., "HIGH", "MEDIUM", "LOW"

    /**
     * Constructs a new Task.
     * @param description The description of the task.
     * @param priority The priority level of the task.
     */
    public Task(String description, String priority) {
        this.description = description;
        this.priority = priority;
    }

    /**
     * Gets the task description.
     * @return The description.
     */
    public String getDescription() {
        return description;
    }

    /**
     * Gets the task priority.
     * @return The priority.
     */
    public String getPriority() {
        return priority;
    }

    @Override
    public String toString() {
        return description + " (" + priority + ")";
    }
}

/**
 * Manages a collection of pending and completed tasks.
 */
class TaskManager {
    // Use Queue for pending tasks (FIFO)
    private Queue<Task> pendingTasks;
    // Use ArrayList for completed tasks
    private ArrayList<Task> completedTasks;

    /**
     * Constructs a new TaskManager.
     */
    public TaskManager() {
        // LinkedList implements the Queue interface
        this.pendingTasks = new LinkedList<>();
        this.completedTasks = new ArrayList<>();
    }

    /**
     * Adds a new task to the pending queue.
     * @param task The task to add.
     */
    public void addTask(Task task) {
        if (task != null) {
            pendingTasks.offer(task); // offer is generally preferred over add for capacity-constrained queues, though LinkedList is not
        }
    }

    /**
     * Executes the next task from the pending queue.
     * Moves the task from pending to completed.
     * @return The task that was executed, or null if no tasks were pending.
     */
    public Task executeNextTask() {
        // poll retrieves and removes the head of the queue, returns null if empty
        Task nextTask = pendingTasks.poll();
        if (nextTask != null) {
            completedTasks.add(nextTask);
            return nextTask;
        }
        return null; // Indicate no task was executed
    }

    /**
     * Gets a list of all pending tasks.
     * Returns a new list to maintain encapsulation.
     * @return A List of pending tasks.
     */
    public List<Task> getPendingTasks() {
        // Return a new ArrayList containing elements from the queue
        // This prevents external modification of the internal queue
        return new ArrayList<>(pendingTasks);
    }

    /**
     * Gets a list of all completed tasks.
     * Returns a new list to maintain encapsulation.
     * @return A List of completed tasks.
     */
    public List<Task> getCompletedTasks() {
        // Return a new ArrayList containing elements from the completedTasks list
        return new ArrayList<>(completedTasks);
    }

    /**
     * Checks if there are any pending tasks.
     * @return true if the pending queue is empty, false otherwise.
     */
    public boolean isPendingQueueEmpty() {
        return pendingTasks.isEmpty();
    }
}

/**
 * Main application class for the Task Management System.
 */
public class TaskApp {

    private static TaskManager taskManager = new TaskManager();
    private static Scanner scanner = new Scanner(System.in);

    public static void main(String[] args) {
        System.out.println("--- Welcome to Task Management System ---");
        runMenu();
        System.out.println("Exiting Task Management System.");
        scanner.close(); // Close the scanner resource
    }

    /**
     * Runs the main interactive menu loop.
     * Includes class-wide exception handling.
     */
    private static void runMenu() {
        boolean running = true;
        while (running) {
            printMenu();
            try {
                System.out.print("Enter your choice: ");
                int choice = scanner.nextInt();
                scanner.nextLine(); // Consume newline left-over

                // Use switch statement for menu navigation
                switch (choice) {
                    case 1:
                        addTask();
                        break;
                    case 2:
                        executeTask();
                        break;
                    case 3:
                        viewPendingTasks();
                        break;
                    case 4:
                        viewCompletedTasks();
                        break;
                    case 5:
                        running = false; // Exit the loop
                        break;
                    default:
                        // Handle invalid menu numbers
                        System.err.println("Invalid choice. Please enter a number between 1 and 5.");
                }
            } catch (InputMismatchException e) {
                // Handle non-integer input for menu choice
                System.err.println("Invalid input. Please enter a number.");
                scanner.nextLine(); // Consume the invalid input to prevent infinite loop
            } catch (Exception e) {
                // Catch any other unexpected exceptions
                System.err.println("An unexpected error occurred: " + e.getMessage());
                // e.printStackTrace(); // Uncomment for debugging
            }
            System.out.println(); // Add a newline for better formatting between operations
        }
    }

    /**
     * Prints the main menu options to the console.
     * Uses System.out.
     */
    private static void printMenu() {
        System.out.println("--- Task Management Menu ---");
        System.out.println("1. Add New Task");
        System.out.println("2. Execute Next Task");
        System.out.println("3. View Pending Tasks");
        System.out.println("4. View Completed Tasks");
        System.out.println("5. Exit");
    }

    /**
     * Handles the process of adding a new task based on user input.
     * Includes input validation for priority.
     */
    private static void addTask() {
        System.out.print("Enter task description: ");
        String description = scanner.nextLine();

        String priority = null;
        boolean validPriority = false;
        while (!validPriority) {
            System.out.print("Enter task priority (HIGH, MEDIUM, LOW): ");
            priority = scanner.nextLine().toUpperCase(); // Read and convert to uppercase
            // Validate priority using switch or if-else
            switch (priority) {
                case "HIGH":
                case "MEDIUM":
                case "LOW":
                    validPriority = true; // Priority is valid
                    break;
                default:
                    // Handle invalid priority input
                    System.err.println("Invalid priority. Please enter HIGH, MEDIUM, or LOW.");
            }
        }

        Task newTask = new Task(description, priority);
        taskManager.addTask(newTask);
        System.out.println("Task added: " + newTask); // Uses Task.toString()
    }

    /**
     * Handles the process of executing the next pending task.
     * Reports success or failure (if queue is empty).
     * Uses System.err for the error case.
     */
    private static void executeTask() {
        // Check if the queue is empty before attempting to execute
        if (taskManager.isPendingQueueEmpty()) {
            System.err.println("No tasks pending to execute.");
            return; // Exit the method
        }

        System.out.println("Executing next task...");
        Task executedTask = taskManager.executeNextTask();
        if (executedTask != null) {
            System.out.println("Task completed: " + executedTask);
        } else {
            // This case should ideally not be reached if isPendingQueueEmpty() is checked first,
            // but included for robustness if executeNextTask logic changes.
            System.err.println("Failed to execute task.");
        }
    }

    /**
     * Displays the list of pending tasks to the console.
     */
    private static void viewPendingTasks() {
        List<Task> pending = taskManager.getPendingTasks(); // Get List from TaskManager
        System.out.println("--- Pending Tasks ---");
        if (pending.isEmpty()) {
            System.out.println("No tasks pending.");
        } else {
            // Iterate and print tasks using List
            for (int i = 0; i < pending.size(); i++) {
                System.out.println((i + 1) + ". " + pending.get(i));
            }
        }
    }

    /**
     * Displays the list of completed tasks to the console.
     */
    private static void viewCompletedTasks() {
        List<Task> completed = taskManager.getCompletedTasks(); // Get List from TaskManager
        System.out.println("--- Completed Tasks ---");
        if (completed.isEmpty()) {
            System.out.println("No tasks completed yet.");
        } else {
            // Iterate and print tasks using List
            for (int i = 0; i < completed.size(); i++) {
                System.out.println((i + 1) + ". " + completed.get(i));
            }
        }
    }
}
