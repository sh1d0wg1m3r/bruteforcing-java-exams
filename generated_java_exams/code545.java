/*
 * Exam Question #545
 * Generated on: 2025-05-11 23:27:22
 * Generated by: Account 4
 * 
 * QUESTION:
 * ## Advanced Java Programming Exam Task: Task Management System
 * 
 * **Scenario:**
 * 
 * You are tasked with building a simplified task management system for a small development team. The system needs to manage tasks that are pending processing and tasks that have been completed. New tasks are added to a queue for processing. A user can process the next task in the queue, view the list of pending tasks, view the list of completed tasks, or exit the system.
 * 
 * **Requirements:**
 * 
 * Implement a Java program that fulfills the following requirements:
 * 
 * 1.  **Task Representation:** Create a `Task` class with private fields for a `description` (String) and a `type` (String, e.g., "BUG", "FEATURE", "TASK"). Include a constructor and appropriate getter methods. Override `toString()` for easy printing.
 * 2.  **Task Management Logic:** Create a `TaskProcessor` class responsible for managing the task collections.
 *     *   It must use a `java.util.Queue<Task>` (specifically, `java.util.LinkedList` which implements `Queue`) to store tasks that are pending processing.
 *     *   It must use a `java.util.List<Task>` (specifically, `java.util.ArrayList` which implements `List`) to store tasks that have been completed. Declare the variable using the `List` interface type.
 *     *   Include methods:
 *         *   `addTask(Task task)`: Adds a task to the pending queue.
 *         *   `processNextTask()`: Removes the next task from the pending queue and adds it to the completed list. Should return the processed `Task` or `null` if the pending queue is empty.
 *         *   `printPendingTasks()`: Prints the tasks currently in the pending queue to `System.out`. Indicate if the queue is empty.
 *         *   `getCompletedTasks()`: Returns the `List` of completed tasks.
 * 3.  **User Interface:** Create a main class (`TaskProcessorApp`) with a `main` method to handle user interaction.
 *     *   Use `java.util.Scanner` to read user input from the console.
 *     *   Present a menu of options to the user:
 *         1.  Add New Task
 *         2.  Process Next Task
 *         3.  View Pending Tasks
 *         4.  View Completed Tasks
 *         5.  Exit
 *     *   Use a `switch` statement to handle the user's menu choice.
 *     *   Implement input validation:
 *         *   Ensure the menu choice is a valid integer within the range of options. Handle non-integer input gracefully.
 *         *   When adding a task, validate that the entered task type is one of the allowed types (e.g., "BUG", "FEATURE", "TASK"). Case-insensitive validation is preferred.
 *     *   Use `System.out` for displaying the menu, prompts, task lists, and success messages.
 *     *   Use `System.err` for displaying error messages (e.g., invalid input, attempting to process task when queue is empty, invalid task type).
 *     *   Implement class-wide exception handling using a `try-catch` block in the `main` method's primary loop to catch unexpected exceptions during execution and print an error message to `System.err`.
 * 4.  **Best Practices:**
 *     *   Apply proper encapsulation (private fields, public methods).
 *     *   Use meaningful variable and method names.
 *     *   Include appropriate comments and Javadoc documentation for classes and methods.
 *     *   Ensure resources (like `Scanner`) are properly closed.
 *     *   Handle the case where the pending queue is empty when trying to process a task.
 * 
 * **Expected Output:**
 * 
 * The program should run interactively, presenting a menu, accepting user input, performing the requested action, and displaying results or errors. Example interactions:
 * 
 * ```
 * --- Task Management Menu ---
 * 1. Add New Task
 * 2. Process Next Task
 * 3. View Pending Tasks
 * 4. View Completed Tasks
 * 5. Exit
 * Enter your choice: 1
 * Enter task description: Fix login bug
 * Enter task type (BUG, FEATURE, TASK): BUG
 * Task added: [BUG] Fix login bug
 * 
 * --- Task Management Menu ---
 * ...
 * Enter your choice: 3
 * Pending Tasks:
 * [BUG] Fix login bug
 * 
 * --- Task Management Menu ---
 * ...
 * Enter your choice: 2
 * Processing task: [BUG] Fix login bug
 * Task completed.
 * 
 * --- Task Management Menu ---
 * ...
 * Enter your choice: 3
 * Pending Tasks:
 * (Queue is empty)
 * 
 * --- Task Management Menu ---
 * ...
 * Enter your choice: 4
 * Completed Tasks:
 * [BUG] Fix login bug
 * 
 * --- Task Management Menu ---
 * ...
 * Enter your choice: 99
 * Error: Invalid choice. Please enter a number between 1 and 5.
 * 
 * --- Task Management Menu ---
 * ...
 * Enter your choice: two
 * Error: Invalid input. Please enter a number.
 * 
 * --- Task Management Menu ---
 * ...
 * Enter your choice: 1
 * Enter task description: Implement new feature
 * Enter task type (BUG, FEATURE, TASK): NEWTYPE
 * Error: Invalid task type. Allowed types: BUG, FEATURE, TASK.
 * Task not added.
 * 
 * --- Task Management Menu ---
 * ...
 * Enter your choice: 5
 * Exiting Task Management System.
 * ```
 * 
 * Your solution should provide the complete Java code in a single file.
 *
 * EXPLANATION:
 * This solution implements a simple task management system demonstrating the required Java concepts and best practices.
 * 
 * 1.  **`Task` Class:** A basic Plain Old Java Object (POJO) representing a task with a `description` and a `type`. It includes a constructor, getters, and an overridden `toString()` method for convenient display. Encapsulation is maintained with private fields and public getters.
 * 
 * 2.  **`TaskProcessor` Class:** This class encapsulates the core logic for managing tasks.
 *     *   It uses a `Queue<Task>` (`LinkedList`) for `pendingTasks`, correctly utilizing the queue's FIFO (First-In, First-Out) behavior for processing the "next" task. The `offer()` method is used for adding, and `poll()` for removing and retrieving the head of the queue, which safely returns `null` if the queue is empty.
 *     *   It uses a `List<Task>` (`ArrayList`) for `completedTasks`, declared using the `List` interface type, demonstrating good practice. `ArrayList` is suitable here for storing a list of completed items where order of completion is preserved and access by index isn't strictly necessary but possible.
 *     *   `addTask()`: Adds a task to the `pendingTasks` queue.
 *     *   `processNextTask()`: Removes the head of the `pendingTasks` queue using `poll()`. If `poll()` returns `null` (queue is empty), it prints an error to `System.err`. Otherwise, it adds the task to `completedTasks` and prints success messages to `System.out`.
 *     *   `printPendingTasks()`: Iterates through the `pendingTasks` queue using a for-each loop (which does not remove elements) and prints each task to `System.out`. It checks if the queue is empty and prints a message accordingly.
 *     *   `getCompletedTasks()`: Returns the `completedTasks` list, allowing the caller (the UI layer) to access and display completed tasks.
 * 
 * 3.  **`TaskProcessorApp` Class:** This is the main class handling the user interface.
 *     *   It initializes a `TaskProcessor` and a `Scanner` for input.
 *     *   The `run()` method contains the main application loop. This loop is wrapped in a `try-catch(Exception e)` block, fulfilling the requirement for class-wide exception handling. Any unexpected exception during the execution of the menu loop will be caught, an error message printed to `System.err`, and the stack trace outputted to `System.err`. A `finally` block ensures the `Scanner` is closed when the `run()` method exits, whether normally or due to an exception.
 *     *   `printMenu()`: Displays the menu options to `System.out`.
 *     *   `getUserChoice()`: Reads the user's integer choice. It uses `scanner.hasNextInt()` to check if the next input is an integer *before* attempting to read it with `scanner.nextInt()`. If not an integer, it consumes the invalid input using `scanner.next()` (or `scanner.nextLine()`) and prints an error to `System.err`. It also validates that the integer is within the valid range (1-5) and keeps prompting until valid input is received.
 *     *   The `switch` statement in `run()` directs execution based on the valid user choice, calling the appropriate methods on the `TaskProcessor`.
 *     *   `addTask()`: Prompts for task description and type. It includes a loop with `isValidTaskType()` to validate the entered task type against a predefined array of allowed types (`ALLOWED_TASK_TYPES`). It converts the input type to uppercase for case-insensitive comparison. Error messages for invalid types are printed to `System.err`.
 *     *   `isValidTaskType()`: A helper method to perform the task type validation.
 *     *   `viewCompletedTasks()`: Retrieves the `completedTasks` list from the processor and iterates through it, printing each completed task to `System.out`.
 *     *   `closeScanner()`: A utility method called in the `finally` block to ensure the `Scanner` resource is released.
 *     *   `main()`: The entry point of the application, which simply creates an instance of `TaskProcessorApp` and calls its `run()` method.
 * 
 * **Best Practices Demonstrated:**
 * 
 * *   **Encapsulation:** Fields in `Task` and `TaskProcessor` are private, accessed via public methods.
 * *   **Meaningful Names:** Variable names like `pendingTasks`, `completedTasks`, `processNextTask`, `getUserChoice` clearly indicate their purpose.
 * *   **Comments and Documentation:** Javadoc comments are included for classes and public methods, explaining their function. Inline comments explain specific code logic where necessary.
 * *   **Input Validation:** Handled in `getUserChoice` (for integer and range) and `addTask` (for task type). Error messages go to `System.err`.
 * *   **Error Handling:** Specific errors (empty queue, invalid input) are handled and reported to `System.err`. A general `try-catch(Exception e)` in the main loop provides class-wide handling for unexpected errors, printing details to `System.err`.
 * *   **Clean Code Structure:** The code is divided into logical classes (`Task`, `TaskProcessor`, `TaskProcessorApp`) with clear responsibilities. Methods are generally small and focused on a single task.
 * *   **Resource Management:** The `Scanner` is explicitly closed in a `finally` block.
 * *   **Interface Usage:** Using `List` as the type for `completedTasks` rather than directly `ArrayList`.
 * 
 * This solution effectively uses all the required Java components in a practical, cohesive application, demonstrating understanding of data structures, control flow, input/output, error handling, and object-oriented principles.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.InputMismatchException; // Import for specific exception handling

/**
 * Represents a single task with a description and type.
 */
class Task {
    private String description;
    private String type; // e.g., BUG, FEATURE, TASK

    /**
     * Constructs a new Task.
     * @param description The description of the task.
     * @param type The type of the task (e.g., BUG, FEATURE, TASK).
     */
    public Task(String description, String type) {
        this.description = description;
        this.type = type;
    }

    /**
     * Gets the task description.
     * @return The description.
     */
    public String getDescription() {
        return description;
    }

    /**
     * Gets the task type.
     * @return The type.
     */
    public String getType() {
        return type;
    }

    /**
     * Returns a string representation of the task.
     * @return Formatted task string.
     */
    @Override
    public String toString() {
        return "[" + type + "] " + description;
    }
}

/**
 * Manages the collection of pending and completed tasks.
 */
class TaskProcessor {
    // Queue for tasks waiting to be processed
    private Queue<Task> pendingTasks;
    // List for tasks that have been completed
    private List<Task> completedTasks;

    /**
     * Constructs a new TaskProcessor, initializing task collections.
     */
    public TaskProcessor() {
        // Use LinkedList as it implements Queue
        pendingTasks = new LinkedList<>();
        // Use ArrayList as it implements List
        completedTasks = new ArrayList<>();
    }

    /**
     * Adds a task to the pending queue.
     * @param task The task to add.
     */
    public void addTask(Task task) {
        pendingTasks.offer(task); // offer is preferred over add for queues
        System.out.println("Task added: " + task);
    }

    /**
     * Processes the next task from the pending queue.
     * Moves the task from pending to completed list.
     * @return The task that was processed, or null if the pending queue was empty.
     */
    public Task processNextTask() {
        Task nextTask = pendingTasks.poll(); // poll retrieves and removes the head, returns null if empty
        if (nextTask != null) {
            completedTasks.add(nextTask);
            System.out.println("Processing task: " + nextTask);
            System.out.println("Task completed.");
        } else {
            System.err.println("Error: No tasks pending to process.");
        }
        return nextTask;
    }

    /**
     * Prints all tasks currently in the pending queue to System.out.
     */
    public void printPendingTasks() {
        System.out.println("Pending Tasks:");
        if (pendingTasks.isEmpty()) {
            System.out.println("(Queue is empty)");
        } else {
            // Iterate without removing elements
            for (Task task : pendingTasks) {
                System.out.println(task);
            }
        }
    }

    /**
     * Returns the list of completed tasks.
     * @return The List of completed tasks.
     */
    public List<Task> getCompletedTasks() {
        return completedTasks;
    }
}

/**
 * Main application class for the Task Management System.
 * Handles user interaction and menu logic.
 */
public class TaskProcessorApp {

    private TaskProcessor processor;
    private Scanner scanner;
    private static final String[] ALLOWED_TASK_TYPES = {"BUG", "FEATURE", "TASK"};

    /**
     * Constructs the TaskProcessorApp, initializing the processor and scanner.
     */
    public TaskProcessorApp() {
        processor = new TaskProcessor();
        scanner = new Scanner(System.in);
    }

    /**
     * Runs the main application loop.
     * Includes class-wide exception handling.
     */
    public void run() {
        int choice = -1;

        // Class-wide exception handling for the main operational loop
        try {
            while (choice != 5) {
                printMenu();
                choice = getUserChoice();

                // Use switch statement for menu control flow
                switch (choice) {
                    case 1:
                        addTask();
                        break;
                    case 2:
                        processor.processNextTask();
                        break;
                    case 3:
                        processor.printPendingTasks();
                        break;
                    case 4:
                        viewCompletedTasks();
                        break;
                    case 5:
                        System.out.println("Exiting Task Management System.");
                        break;
                    default:
                        // Handled by getUserChoice validation, but included for completeness
                        System.err.println("Error: Invalid choice. Please enter a number between 1 and 5.");
                        break;
                }
                System.out.println(); // Add a newline for better readability between actions
            }
        } catch (Exception e) {
            // Catch any unexpected runtime exceptions and print to System.err
            System.err.println("An unexpected error occurred: " + e.getMessage());
            e.printStackTrace(System.err); // Print stack trace to System.err
        } finally {
            // Ensure the scanner is closed regardless of how the loop exits
            closeScanner();
        }
    }

    /**
     * Prints the main menu options to System.out.
     */
    private void printMenu() {
        System.out.println("--- Task Management Menu ---");
        System.out.println("1. Add New Task");
        System.out.println("2. Process Next Task");
        System.out.println("3. View Pending Tasks");
        System.out.println("4. View Completed Tasks");
        System.out.println("5. Exit");
        System.out.print("Enter your choice: ");
    }

    /**
     * Gets the user's menu choice from input, including validation.
     * Handles non-integer input and range checking.
     * @return The valid integer choice.
     */
    private int getUserChoice() {
        int choice = -1;
        while (true) {
            try {
                if (scanner.hasNextInt()) {
                    choice = scanner.nextInt();
                    // Consume the newline character left by nextInt()
                    scanner.nextLine();
                    if (choice >= 1 && choice <= 5) {
                        return choice; // Valid choice
                    } else {
                        System.err.println("Error: Invalid choice. Please enter a number between 1 and 5.");
                        printMenu(); // Re-print menu after invalid choice
                    }
                } else {
                    // Handle non-integer input
                    String invalidInput = scanner.next(); // Consume the invalid input
                    System.err.println("Error: Invalid input '" + invalidInput + "'. Please enter a number.");
                    // Consume the rest of the line to prevent infinite loop on invalid input
                    scanner.nextLine();
                    printMenu(); // Re-print menu after invalid input
                }
            } catch (InputMismatchException e) {
                 // This catch block might be redundant due to hasNextInt() check,
                 // but kept for robustness against unexpected Scanner state issues.
                 System.err.println("Error reading input. Please try again.");
                 scanner.nextLine(); // Consume the invalid input
                 printMenu();
            }
        }
    }

    /**
     * Prompts the user for task details and adds a new task.
     * Includes task type validation.
     */
    private void addTask() {
        System.out.print("Enter task description: ");
        String description = scanner.nextLine();

        String type;
        boolean validType = false;
        do {
            System.out.print("Enter task type (" + String.join(", ", ALLOWED_TASK_TYPES) + "): ");
            type = scanner.nextLine().toUpperCase(); // Read and convert to uppercase for case-insensitivity
            validType = isValidTaskType(type);
            if (!validType) {
                System.err.println("Error: Invalid task type. Allowed types: " + String.join(", ", ALLOWED_TASK_TYPES) + ".");
            }
        } while (!validType);

        Task newTask = new Task(description, type);
        processor.addTask(newTask);
    }

    /**
     * Checks if the entered task type is one of the allowed types.
     * @param type The type string to validate.
     * @return true if the type is allowed, false otherwise.
     */
    private boolean isValidTaskType(String type) {
        if (type == null || type.trim().isEmpty()) {
            return false;
        }
        for (String allowedType : ALLOWED_TASK_TYPES) {
            if (allowedType.equals(type)) {
                return true;
            }
        }
        return false;
    }

    /**
     * Retrieves and prints the list of completed tasks.
     */
    private void viewCompletedTasks() {
        List<Task> completed = processor.getCompletedTasks();
        System.out.println("Completed Tasks:");
        if (completed.isEmpty()) {
            System.out.println("(No tasks completed yet)");
        } else {
            for (Task task : completed) {
                System.out.println(task);
            }
        }
    }

    /**
     * Closes the scanner resource.
     */
    private void closeScanner() {
        if (scanner != null) {
            scanner.close();
            System.out.println("Scanner closed.");
        }
    }

    /**
     * Main method to start the application.
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        TaskProcessorApp app = new TaskProcessorApp();
        app.run();
    }
}
