/*
 * Exam Question #305
 * Generated on: 2025-05-11 22:52:23
 * Generated by: Account 4
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Air Traffic Control Simulation
 * 
 * **Problem Description:**
 * 
 * You are tasked with developing a simplified simulation of an Air Traffic Control (ATC) system for managing landing requests at a small airport. The system needs to handle planes requesting permission to land, process these requests in the order they are received, and maintain a record of all planes that have interacted with the system.
 * 
 * Your program should present a menu-driven interface allowing the user to:
 * 1.  **Request Landing:** A new plane arrives and requests landing clearance. It is added to a waiting queue.
 * 2.  **Grant Next Landing Clearance:** The ATC grants clearance to the plane that has been waiting the longest. This plane is removed from the waiting queue.
 * 3.  **View Waiting Queue:** Display the list of planes currently waiting for clearance, in the order they will be processed.
 * 4.  **View All Planes:** Display a list of all planes that have ever requested landing via this system, along with their current status.
 * 5.  **Exit:** Terminate the simulation.
 * 
 * **Requirements:**
 * 
 * 1.  **Data Structures:**
 *     *   Use a `java.util.Queue` to manage planes waiting for landing clearance (First-In, First-Out).
 *     *   Use a `java.util.ArrayList` (or an implementation assigned to a `java.util.List` interface variable) to maintain a comprehensive list of all planes that have entered the system, regardless of their current queue status.
 * 2.  **Input/Output:**
 *     *   Use `java.util.Scanner` to read user input for menu choices and plane details (e.g., flight number).
 *     *   Use `System.out` for displaying the menu, system messages, and listing planes/queue contents.
 *     *   Use `System.err` to display error messages (e.g., invalid input, attempting to grant clearance when the queue is empty, attempting to add a plane with a flight number that already exists in the system).
 * 3.  **Control Flow:**
 *     *   Use a `switch` statement to handle the user's menu selection.
 *     *   Implement a loop to keep the simulation running until the user chooses to exit.
 * 4.  **Error Handling:**
 *     *   Implement specific error handling using `try-catch` blocks for expected issues like `NumberFormatException` when parsing user input.
 *     *   Implement class-wide exception handling by wrapping the main simulation loop in a `try-catch(Exception e)` block to catch any unexpected runtime errors and report them via `System.err`.
 *     *   Perform input validation where appropriate (e.g., checking if a flight number already exists before adding a new plane).
 *     *   Handle cases where operations cannot be performed (e.g., granting clearance from an empty queue).
 * 5.  **Object-Oriented Design:**
 *     *   Create a `Plane` class to represent an aircraft with attributes like `flightNumber` and `status`. Include appropriate getters and setters.
 *     *   Create an `AirTrafficController` class that encapsulates the `Queue` and `List` and provides methods for the ATC operations (request landing, grant clearance, view queues).
 *     *   Use meaningful variable and method names.
 *     *   Include comments to explain complex parts of the code.
 * 6.  **Best Practices:**
 *     *   Adhere to principles of encapsulation (private fields, public methods).
 *     *   Ensure clean code structure.
 * 
 * **Expected Output/Interaction:**
 * 
 * The program should display a menu. Based on user input, it should perform the requested action and provide feedback. Error conditions should be reported clearly using `System.err`. Listing operations should display the relevant plane information using `System.out`.
 * 
 * Example interaction flow:
 * 
 * ```
 * *** Air Traffic Control Simulation ***
 * Choose an action:
 * 1. Request Landing
 * 2. Grant Next Landing Clearance
 * 3. View Waiting Queue
 * 4. View All Planes
 * 5. Exit
 * Enter choice: 1
 * Enter flight number: AA101
 * Flight AA101 requested landing. Added to queue.
 * 
 * Choose an action:
 * ...
 * Enter choice: 1
 * Enter flight number: BB202
 * Flight BB202 requested landing. Added to queue.
 * 
 * Choose an action:
 * ...
 * Enter choice: 3
 * --- Waiting Queue ---
 * AA101 [REQUESTING_LANDING]
 * BB202 [REQUESTING_LANDING]
 * ---------------------
 * 
 * Choose an action:
 * ...
 * Enter choice: 2
 * Granting clearance to AA101. Status updated to LANDING.
 * 
 * Choose an action:
 * ...
 * Enter choice: 3
 * --- Waiting Queue ---
 * BB202 [REQUESTING_LANDING]
 * ---------------------
 * 
 * Choose an action:
 * ...
 * Enter choice: 4
 * --- All Planes ---
 * AA101 [LANDING]
 * BB202 [REQUESTING_LANDING]
 * ------------------
 * 
 * Choose an action:
 * ...
 * Enter choice: 2
 * Granting clearance to BB202. Status updated to LANDING.
 * 
 * Choose an action:
 * ...
 * Enter choice: 2
 * Error: No planes currently waiting for clearance.
 * 
 * Choose an action:
 * ...
 * Enter choice: 5
 * Exiting simulation.
 * ```
 * 
 * Your solution should be a single Java file containing all necessary classes.
 *
 * EXPLANATION:
 * This solution implements a simplified Air Traffic Control simulation as requested, demonstrating the use of all specified Java components and adhering to best practices.
 * 
 * 1.  **`Plane` Class:**
 *     *   A simple class `Plane` is created with private fields `flightNumber` and `status`.
 *     *   An `enum PlaneStatus` is used for type-safe representation of plane states (`REQUESTING_LANDING`, `LANDING`, etc.).
 *     *   Public getter and setter methods provide controlled access to the fields, ensuring encapsulation.
 *     *   `toString()` is overridden for easy printing of `Plane` objects.
 *     *   `equals()` and `hashCode()` are overridden based on `flightNumber` to facilitate checking for duplicate flight numbers in the `allPlanes` list.
 * 
 * 2.  **`AirTrafficController` Class:**
 *     *   This class encapsulates the core logic and data structures.
 *     *   `private Queue<Plane> landingQueue`: A `LinkedList` is used as it implements the `Queue` interface and provides efficient FIFO operations (`offer` to add, `poll` to remove). This queue holds planes waiting for clearance.
 *     *   `private List<Plane> allPlanes`: An `ArrayList` is used to store references to *all* `Plane` objects created in the system. This list serves as a historical record and allows lookup/validation. It's declared using the `List` interface type.
 *     *   The constructor initializes both collections.
 *     *   `requestLanding(String flightNumber)`:
 *         *   Takes a flight number as input.
 *         *   Includes basic input validation for empty/null flight numbers.
 *         *   Iterates through `allPlanes` to check if a plane with the same flight number already exists (using `equalsIgnoreCase` for case-insensitivity). If a duplicate is found, an error is printed to `System.err`, and the method returns.
 *         *   If the flight number is unique, a new `Plane` object is created with `REQUESTING_LANDING` status.
 *         *   The new plane is added to both the `landingQueue` (using `offer`) and the `allPlanes` list (using `add`).
 *         *   A success message is printed to `System.out`.
 *     *   `grantLandingClearance()`:
 *         *   Checks if the `landingQueue` is empty. If so, an error is printed to `System.err`, and the method returns `null`.
 *         *   If the queue is not empty, `landingQueue.poll()` retrieves and removes the head of the queue (the plane waiting longest).
 *         *   The status of the polled `Plane` object is updated to `LANDING`. Since the `allPlanes` list holds the same object reference, the status update is automatically reflected in the list as well.
 *         *   A success message is printed to `System.out`.
 *         *   The cleared `Plane` object is returned.
 *     *   `getWaitingQueue()` and `getAllPlanes()`: These methods provide access to the internal collections. (Note: For simplicity in an exam setting, the direct collections are returned. In a production system, returning copies or unmodifiable views would be better for encapsulation).
 * 
 * 3.  **`main` Method (within `AirTrafficController`):**
 *     *   This method contains the simulation loop and user interaction logic.
 *     *   **`try-with-resources` for `Scanner`:** Ensures the `Scanner` is properly closed, preventing resource leaks.
 *     *   **Class-wide `try-catch(Exception e)`:** The entire `while (running)` loop is wrapped in a `try-catch` block. This catches any unexpected `Exception` that might occur anywhere within the main simulation logic (not specifically handled by local `try-catch` blocks) and prints an error message and stack trace to `System.err`. This fulfills the "class-wide exception handling" requirement.
 *     *   A `while (running)` loop keeps the simulation active until the `running` flag is set to `false`.
 *     *   Inside the loop:
 *         *   The menu is displayed using `System.out`.
 *         *   User input is read using `scanner.nextLine()`.
 *         *   **Local `try-catch(NumberFormatException)`:** A specific `try-catch` block is used to handle the potential `NumberFormatException` if the user enters non-numeric input for the menu choice. An error is printed to `System.err`, and `continue` skips the rest of the loop iteration, prompting the user again.
 *         *   **`switch` statement:** The parsed integer choice controls the program flow.
 *             *   Cases 1-4 call the corresponding methods of the `AirTrafficController` instance.
 *             *   Case 1 (`requestLanding`): Prompts for flight number, reads it, and calls `atc.requestLanding()`.
 *             *   Case 2 (`grantLandingClearance`): Calls `atc.grantLandingClearance()`. The error handling for an empty queue is inside the `grantLandingClearance` method itself, which prints to `System.err`.
 *             *   Case 3 (`viewWaitingQueue`): Retrieves the queue and iterates through it using an `Iterator` (a standard and safe way to traverse collections) to print each plane using `System.out`. Handles the empty queue case.
 *             *   Case 4 (`viewAllPlanes`): Retrieves the list and iterates through it using a `for-each` loop to print each plane using `System.out`. Handles the empty list case.
 *             *   Case 5 (`Exit`): Sets `running` to `false` to terminate the loop and prints an exit message to `System.out`.
 *             *   `default`: Handles invalid integer inputs (outside 1-5) by printing an error to `System.err`.
 * 
 * This solution effectively integrates `Queue`, `List`/`ArrayList`, `Scanner`, `switch`, `System.out`, `System.err`, and `try-catch` blocks within a practical, object-oriented simulation, demonstrating key Java programming concepts and best practices.
 */

import java.util.ArrayList;
import java.util.LinkedList; // LinkedList implements Queue
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.Iterator; // To iterate over collections

// Enum to represent the status of a plane
enum PlaneStatus {
    REQUESTING_LANDING,
    LANDING,
    LANDED, // Added for completeness, though not fully implemented in this sim
    CANCELLED // Added for completeness
}

// Represents a single aircraft
class Plane {
    private String flightNumber;
    private PlaneStatus status;

    /**
     * Constructs a new Plane object.
     * @param flightNumber The unique flight number.
     * @param status The initial status of the plane.
     */
    public Plane(String flightNumber, PlaneStatus status) {
        this.flightNumber = flightNumber;
        this.status = status;
    }

    // Getters
    public String getFlightNumber() {
        return flightNumber;
    }

    public PlaneStatus getStatus() {
        return status;
    }

    // Setter for status
    public void setStatus(PlaneStatus status) {
        this.status = status;
    }

    @Override
    public String toString() {
        return flightNumber + " [" + status + "]";
    }

    // Override equals and hashCode based on flight number for uniqueness check
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Plane plane = (Plane) o;
        return flightNumber.equals(plane.flightNumber);
    }

    @Override
    public int hashCode() {
        return flightNumber.hashCode();
    }
}

// Manages the air traffic control operations
public class AirTrafficController {

    // Queue for planes waiting for landing clearance (FIFO)
    private Queue<Plane> landingQueue;

    // List to keep track of all planes that have entered the system
    private List<Plane> allPlanes;

    /**
     * Constructs an AirTrafficController, initializing the necessary collections.
     */
    public AirTrafficController() {
        // LinkedList is a common implementation of the Queue interface
        landingQueue = new LinkedList<>();
        // ArrayList is a common implementation of the List interface
        allPlanes = new ArrayList<>();
    }

    /**
     * Adds a new plane to the system and the waiting queue.
     * Checks if a plane with the same flight number already exists.
     * @param flightNumber The flight number of the arriving plane.
     */
    public void requestLanding(String flightNumber) {
        // Input validation: Check if flight number is empty or null
        if (flightNumber == null || flightNumber.trim().isEmpty()) {
             System.err.println("Error: Flight number cannot be empty.");
             return;
        }

        // Input validation: Check if plane already exists in the system
        // Iterate through allPlanes to find a match by flight number
        boolean exists = false;
        for (Plane existingPlane : allPlanes) {
            if (existingPlane.getFlightNumber().equalsIgnoreCase(flightNumber.trim())) {
                exists = true;
                break;
            }
        }

        if (exists) {
            System.err.println("Error: Flight number " + flightNumber.trim() + " already exists in the system.");
            return;
        }

        // Create a new plane with REQUESTING_LANDING status
        Plane newPlane = new Plane(flightNumber.trim(), PlaneStatus.REQUESTING_LANDING);

        // Add the plane to the waiting queue
        landingQueue.offer(newPlane); // offer is generally preferred over add for queues

        // Add the plane to the comprehensive list of all planes
        allPlanes.add(newPlane);

        System.out.println("Flight " + flightNumber.trim() + " requested landing. Added to queue.");
    }

    /**
     * Grants landing clearance to the next plane in the queue.
     * Removes the plane from the queue and updates its status.
     * Reports an error if the queue is empty.
     * @return The plane that was granted clearance, or null if the queue was empty.
     */
    public Plane grantLandingClearance() {
        // Check if the queue is empty
        if (landingQueue.isEmpty()) {
            System.err.println("Error: No planes currently waiting for clearance.");
            return null;
        }

        // Get the next plane from the queue (and remove it)
        Plane clearedPlane = landingQueue.poll();

        // Update the status of the cleared plane.
        // Since the same Plane object reference exists in both the queue and the list,
        // updating the status on the polled object also updates it in the list.
        clearedPlane.setStatus(PlaneStatus.LANDING);

        System.out.println("Granting clearance to " + clearedPlane.getFlightNumber() + ". Status updated to LANDING.");

        return clearedPlane;
    }

    /**
     * Returns the queue of planes waiting for clearance.
     * Note: Returning the direct collection allows external modification,
     * but for this exam simulation, it's acceptable.
     * In a real-world system, you might return a copy or an unmodifiable view.
     */
    public Queue<Plane> getWaitingQueue() {
        return landingQueue;
    }

    /**
     * Returns the list of all planes in the system.
     * Note: Returning the direct collection allows external modification,
     * but for this exam simulation, it's acceptable.
     * In a real-world system, you might return a copy or an unmodifiable view.
     */
    public List<Plane> getAllPlanes() {
        return allPlanes;
    }

    /**
     * The main method to run the ATC simulation.
     * Handles user interaction and calls the appropriate ATC methods.
     */
    public static void main(String[] args) {
        // Class-wide try-catch block to handle unexpected exceptions during simulation
        try (Scanner scanner = new Scanner(System.in)) { // Use try-with-resources for Scanner
            AirTrafficController atc = new AirTrafficController();
            boolean running = true;

            System.out.println("*** Air Traffic Control Simulation ***");

            while (running) {
                // Display menu
                System.out.println("\nChoose an action:");
                System.out.println("1. Request Landing");
                System.out.println("2. Grant Next Landing Clearance");
                System.out.println("3. View Waiting Queue");
                System.out.println("4. View All Planes");
                System.out.println("5. Exit");
                System.out.print("Enter choice: ");

                int choice = -1;
                try {
                    // Read user input and parse it as an integer
                    choice = Integer.parseInt(scanner.nextLine());
                } catch (NumberFormatException e) {
                    // Handle invalid input (non-integer)
                    System.err.println("Error: Invalid input. Please enter a number.");
                    continue; // Continue to the next iteration of the loop
                }

                // Use a switch statement to process the user's choice
                switch (choice) {
                    case 1:
                        // Request Landing
                        System.out.print("Enter flight number: ");
                        String flightNumber = scanner.nextLine();
                        atc.requestLanding(flightNumber);
                        break;

                    case 2:
                        // Grant Next Landing Clearance
                        atc.grantLandingClearance();
                        break;

                    case 3:
                        // View Waiting Queue
                        Queue<Plane> waitingQueue = atc.getWaitingQueue();
                        System.out.println("--- Waiting Queue ---");
                        if (waitingQueue.isEmpty()) {
                            System.out.println("The waiting queue is empty.");
                        } else {
                            // Iterate and print elements in the queue order
                            // Using an Iterator is a safe way to traverse collections
                            Iterator<Plane> queueIterator = waitingQueue.iterator();
                            while (queueIterator.hasNext()) {
                                System.out.println(queueIterator.next());
                            }
                        }
                        System.out.println("---------------------");
                        break;

                    case 4:
                        // View All Planes
                        List<Plane> allPlanesList = atc.getAllPlanes();
                        System.out.println("--- All Planes ---");
                        if (allPlanesList.isEmpty()) {
                            System.out.println("No planes in the system yet.");
                        } else {
                            // Iterate and print elements in the list order
                             for (Plane plane : allPlanesList) {
                                System.out.println(plane);
                            }
                        }
                        System.out.println("------------------");
                        break;

                    case 5:
                        // Exit
                        System.out.println("Exiting simulation.");
                        running = false; // Set running flag to false to exit the loop
                        break;

                    default:
                        // Handle choices outside the valid range
                        System.err.println("Error: Invalid choice. Please enter a number between 1 and 5.");
                        break;
                }
            }
        } catch (Exception e) {
            // Catch any unexpected exceptions during the simulation
            System.err.println("An unexpected error occurred during the simulation:");
            e.printStackTrace(System.err); // Print stack trace to System.err
        }
        // Scanner is automatically closed by try-with-resources
    }
}
