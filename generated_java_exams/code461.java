/*
 * Exam Question #461
 * Generated on: 2025-05-11 23:14:48
 * Generated by: Account 5
 * 
 * QUESTION:
 * **Java Programming Exam Task: Event Attendee Management System**
 * 
 * You are tasked with developing a simple command-line application to manage attendee registration and a waiting list for an event with a fixed capacity. The system should allow users to register, cancel registration, and view lists of registered and waiting attendees.
 * 
 * Your solution must strictly adhere to the following requirements:
 * 
 * 1.  **Data Structures:**
 *     *   Maintain a list of attendees who are successfully registered using `java.util.List` (specifically, implement it using `java.util.ArrayList`).
 *     *   Maintain a waiting list for attendees who try to register when the event is full, using `java.util.Queue` (you can use `java.util.LinkedList` as the concrete implementation which provides the `Queue` interface methods).
 * 2.  **User Interaction:**
 *     *   Use `java.util.Scanner` to read user commands from standard input.
 *     *   Support the following commands (case-insensitive):
 *         *   `register <attendee_name>`: Attempts to register an attendee. If successful (capacity available), add to the registered list. If full, add to the waiting list. An attendee name must be provided. An attendee cannot register if they are already on either list.
 *         *   `cancel <attendee_name>`: Attempts to cancel an attendee's registration or remove them from the waiting list. If a registered attendee cancels and the waiting list is not empty, the first person on the waiting list should be automatically moved to the registered list. An attendee name must be provided.
 *         *   `list_registered`: Displays all attendees currently on the registered list.
 *         *   `list_waiting`: Displays all attendees currently on the waiting list.
 *         *   `exit`: Terminates the program.
 * 3.  **Control Flow:**
 *     *   Use a `switch` statement to process the user commands.
 * 4.  **Output:**
 *     *   Use `System.out` for normal output (success messages, listing attendees).
 *     *   Use `System.err` for error messages (invalid command, attendee not found, invalid input format, attendee already exists, etc.).
 * 5.  **Error Handling:**
 *     *   Implement input validation to check for correct command format and required arguments.
 *     *   Use class-wide exception handling with `try-catch` blocks to gracefully handle unexpected runtime issues during the command processing loop.
 * 6.  **Best Practices:**
 *     *   Employ proper encapsulation (private fields, public methods).
 *     *   Use meaningful variable and method names.
 *     *   Include appropriate comments explaining complex logic or sections.
 *     *   Structure the code cleanly within a single class for this exam task.
 * 
 * **Event Capacity:** The event has a fixed capacity of **3** attendees.
 * 
 * **Expected Output Structure (Examples):**
 * 
 * ```
 * Enter command: register Alice
 * Alice registered successfully.
 * 
 * Enter command: register Bob
 * Bob registered successfully.
 * 
 * Enter command: register Charlie
 * Charlie registered successfully.
 * 
 * Enter command: register David
 * Event full. David added to waiting list.
 * 
 * Enter command: list_registered
 * Registered Attendees:
 * - Alice
 * - Bob
 * - Charlie
 * 
 * Enter command: list_waiting
 * Waiting List:
 * - David
 * 
 * Enter command: cancel Bob
 * Bob cancelled registration. David moved from waiting list to registered.
 * 
 * Enter command: list_registered
 * Registered Attendees:
 * - Alice
 * - Charlie
 * - David
 * 
 * Enter command: list_waiting
 * Waiting List:
 * (Empty)
 * 
 * Enter command: register Alice
 * Error: Alice is already registered.
 * 
 * Enter command: cancel Eve
 * Error: Attendee 'Eve' not found.
 * 
 * Enter command: register
 * Error: Invalid command format. Usage: register <attendee_name>
 * 
 * Enter command: invalid_command
 * Error: Unknown command.
 * 
 * Enter command: exit
 * Exiting Event Management System.
 * ```
 * 
 * Your code should be a single `.java` file containing the `main` method.
 *
 * EXPLANATION:
 * This Java program implements a simple Event Attendee Management System demonstrating the required Java concepts.
 * 
 * **Core Functionality:**
 * The system manages a fixed-capacity event. Attendees can register; if the event is full, they are placed on a waiting list. Attendees can cancel their registration or remove themselves from the waiting list. When a registered attendee cancels and there are people on the waiting list, the next person from the waiting list is automatically registered.
 * 
 * **Required Components and Their Usage:**
 * 
 * 1.  **`java.util.Queue`:** The `waitingList` is declared as a `Queue<String>`. We use `java.util.LinkedList` as the concrete implementation because it implements the `Queue` interface and also provides a convenient `remove(Object)` method needed for cancelling someone who is not at the head of the waiting list.
 *     *   `waitingList.add(attendeeName)`: Used to add an attendee to the end of the waiting list when the event is full.
 *     *   `waitingList.poll()`: Used to retrieve and remove the head of the waiting list when a spot opens up due to cancellation.
 *     *   `waitingList.isEmpty()`: Used to check if the waiting list has any attendees.
 *     *   `waitingList.contains(attendeeName)`: Used to check if an attendee is already on the waiting list before registration.
 *     *   `waitingList.remove(attendeeName)`: Used to remove a specific attendee from the waiting list if they cancel.
 *     *   Iteration (`for (String attendee : waitingList)`) is used to list the contents of the waiting list.
 * 
 * 2.  **`java.util.ArrayList`:** The `registeredAttendees` list is implemented using `ArrayList<String>`.
 *     *   `registeredAttendees = new ArrayList<>();`: Instantiation.
 *     *   `registeredAttendees.add(attendeeName)`: Used to add an attendee upon successful registration or when moved from the waiting list.
 *     *   `registeredAttendees.remove(attendeeName)`: Used to remove an attendee upon cancellation.
 *     *   `registeredAttendees.size()`: Used to check the current number of registered attendees against the capacity.
 *     *   `registeredAttendees.contains(attendeeName)`: Used to check if an attendee is already registered.
 *     *   `registeredAttendees.isEmpty()`: Used to check if the registered list is empty for listing purposes.
 *     *   Iteration (`for (String attendee : registeredAttendees)`) is used to list the contents of the registered list.
 * 
 * 3.  **`java.util.List` interface:** `registeredAttendees` is declared using the `List` interface (`private List<String> registeredAttendees;`), promoting good practice by programming to the interface rather than the specific implementation (`ArrayList`).
 * 
 * 4.  **`java.util.Scanner`:** A `Scanner` object (`scanner`) is used to read input lines from `System.in`.
 *     *   `scanner = new Scanner(System.in);`: Instantiation.
 *     *   `scanner.nextLine()`: Reads the entire line of input entered by the user.
 * 
 * 5.  **`switch` statement:** The main command processing loop uses a `switch` statement on the lowercased command string (`command`) to determine which action method (`handleRegisterCommand`, `handleCancelCommand`, etc.) should be executed.
 * 
 * 6.  **`System.err`:** Used for printing error messages to the standard error stream. This includes messages for unknown commands, invalid input formats, attendees not found, or attendees already existing.
 * 
 * 7.  **`System.out`:** Used for printing normal output messages to the standard output stream. This includes success messages for registration/cancellation, system prompts, and the lists of attendees.
 * 
 * 8.  **Class-wide Exception Handling (`try-catch`):** A `try-catch(Exception e)` block is wrapped around the main `while (true)` loop in the `run()` method. This demonstrates class-wide handling of any unexpected runtime exceptions that might occur during the processing of commands, preventing the program from crashing abruptly and providing a general error message via `System.err`. A `finally` block ensures the `Scanner` is closed.
 * 
 * **Best Practices:**
 * 
 * *   **Encapsulation:** The data structures (`registeredAttendees`, `waitingList`) and the `scanner` are declared as `private` fields. Access and modification are done through public or private methods (`run`, `handleRegisterCommand`, `handleCancelCommand`, `listRegisteredAttendees`, `listWaitingList`), controlling how the internal state is managed.
 * *   **Meaningful Names:** Variables (`registeredAttendees`, `waitingList`, `attendeeName`, `inputLine`, `command`, `argument`), methods (`run`, `handleRegisterCommand`, `listWaitingList`), and constants (`EVENT_CAPACITY`) have descriptive names.
 * *   **Comments:** Comments are included to explain the purpose of methods, specific logic steps (like moving from waiting list), and the usage of data structures.
 * *   **Input Validation:** Inside `handleRegisterCommand` and `handleCancelCommand`, checks are performed to ensure that an attendee name argument was provided. Checks are also made for duplicate registrations.
 * *   **Error Handling:** Specific error conditions (invalid command, missing argument, attendee not found, attendee already exists) are checked explicitly, and informative messages are printed to `System.err`. The `try-catch` provides a fallback for unexpected errors.
 * *   **Clean Code Structure:** The logic is broken down into smaller, single-purpose private methods (`handleRegisterCommand`, `handleCancelCommand`, etc.), making the `run` method cleaner and easier to understand.
 * 
 * This solution effectively combines the required Java components to simulate a practical scenario, demonstrating understanding of data structures, control flow, user input, and robust error handling.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;

public class EventManagementSystem {

    private static final int EVENT_CAPACITY = 3; // Fixed event capacity
    private List<String> registeredAttendees;
    private Queue<String> waitingList;
    private Scanner scanner;

    public EventManagementSystem() {
        registeredAttendees = new ArrayList<>();
        waitingList = new LinkedList<>(); // LinkedList implements Queue
        scanner = new Scanner(System.in);
    }

    // Method to run the system loop
    public void run() {
        System.out.println("Event Attendee Management System");
        System.out.println("Event Capacity: " + EVENT_CAPACITY);
        System.out.println("Commands: register <name>, cancel <name>, list_registered, list_waiting, exit");

        // Use try-catch for class-wide exception handling during the command processing loop
        try {
            while (true) {
                System.out.print("\nEnter command: ");
                String inputLine = scanner.nextLine().trim();

                if (inputLine.isEmpty()) {
                    continue; // Skip empty lines
                }

                String[] parts = inputLine.split(" ", 2); // Split into command and potential argument
                String command = parts[0].toLowerCase();
                String argument = parts.length > 1 ? parts[1] : "";

                switch (command) {
                    case "register":
                        handleRegisterCommand(argument);
                        break;
                    case "cancel":
                        handleCancelCommand(argument);
                        break;
                    case "list_registered":
                        listRegisteredAttendees();
                        break;
                    case "list_waiting":
                        listWaitingList();
                        break;
                    case "exit":
                        System.out.println("Exiting Event Management System.");
                        return; // Exit the run method, ending the program
                    default:
                        System.err.println("Error: Unknown command.");
                }
            }
        } catch (Exception e) {
            // Catch any unexpected exceptions during the main loop
            System.err.println("An unexpected error occurred: " + e.getMessage());
            // e.printStackTrace(); // Uncomment for debugging if needed
        } finally {
            // Ensure the scanner is closed
            if (scanner != null) {
                scanner.close();
            }
        }
    }

    // Handles the 'register' command
    private void handleRegisterCommand(String attendeeName) {
        if (attendeeName.isEmpty()) {
            System.err.println("Error: Invalid command format. Usage: register <attendee_name>");
            return;
        }

        // Check if attendee already exists in either list
        if (registeredAttendees.contains(attendeeName)) {
            System.err.println("Error: " + attendeeName + " is already registered.");
            return;
        }
        if (waitingList.contains(attendeeName)) {
            System.err.println("Error: " + attendeeName + " is already on the waiting list.");
            return;
        }

        // Attempt to register
        if (registeredAttendees.size() < EVENT_CAPACITY) {
            registeredAttendees.add(attendeeName);
            System.out.println(attendeeName + " registered successfully.");
        } else {
            // Event is full, add to waiting list
            waitingList.add(attendeeName);
            System.out.println("Event full. " + attendeeName + " added to waiting list.");
        }
    }

    // Handles the 'cancel' command
    private void handleCancelCommand(String attendeeName) {
        if (attendeeName.isEmpty()) {
            System.err.println("Error: Invalid command format. Usage: cancel <attendee_name>");
            return;
        }

        boolean foundAndRemoved = false;

        // Check and remove from registered list
        if (registeredAttendees.remove(attendeeName)) {
            System.out.println(attendeeName + " cancelled registration.");
            foundAndRemoved = true;

            // If someone cancelled and there's a waiting list, move the next person
            if (!waitingList.isEmpty()) {
                String nextAttendee = waitingList.poll(); // Get and remove head of the queue
                if (nextAttendee != null) {
                    registeredAttendees.add(nextAttendee);
                    System.out.println(nextAttendee + " moved from waiting list to registered.");
                }
            }
        } else if (waitingList.remove(attendeeName)) { // Check and remove from waiting list
             // Note: LinkedList's remove(Object) method is used here.
            System.out.println(attendeeName + " removed from waiting list.");
            foundAndRemoved = true;
        }

        if (!foundAndRemoved) {
            System.err.println("Error: Attendee '" + attendeeName + "' not found.");
        }
    }

    // Lists all registered attendees
    private void listRegisteredAttendees() {
        System.out.println("Registered Attendees (" + registeredAttendees.size() + "/" + EVENT_CAPACITY + "):");
        if (registeredAttendees.isEmpty()) {
            System.out.println("(Empty)");
        } else {
            for (String attendee : registeredAttendees) {
                System.out.println("- " + attendee);
            }
        }
    }

    // Lists all attendees on the waiting list
    private void listWaitingList() {
        System.out.println("Waiting List (" + waitingList.size() + "):");
        if (waitingList.isEmpty()) {
            System.out.println("(Empty)");
        } else {
            // Iterating over a Queue for listing is common
            for (String attendee : waitingList) {
                System.out.println("- " + attendee);
            }
        }
    }

    public static void main(String[] args) {
        EventManagementSystem system = new EventManagementSystem();
        system.run();
    }
}
