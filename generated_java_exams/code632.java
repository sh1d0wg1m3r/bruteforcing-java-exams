/*
 * Exam Question #632
 * Generated on: 2025-05-12 16:17:33
 * Generated by: Account 3
 * 
 * QUESTION:
 * **Advanced Java Programming Exam Task: Hospital Appointment Management System**
 * 
 * **Problem Description:**
 * 
 * You are tasked with developing a simplified console-based hospital appointment management system. The system should allow patients to register for appointments, allow a doctor to call the next patient from a waiting list, and display the current waiting list and a list of appointments being processed or completed.
 * 
 * Your solution must demonstrate a strong understanding of core Java collections, control flow, input/output, and exception handling.
 * 
 * **System Requirements:**
 * 
 * 1.  **Patient Registration:** Allow users to input a patient's name. The patient should be added to a waiting list.
 * 2.  **Call Next Patient:** Allow users (simulating a doctor/receptionist) to call the next patient from the waiting list. The called patient should be removed from the waiting list and moved to a list of "Active Appointments".
 * 3.  **View Status:** Allow users to view the current waiting list and the list of active appointments.
 * 4.  **Exit:** Allow users to exit the application.
 * 
 * **Technical Requirements:**
 * 
 * Your Java code MUST utilize ALL of the following components:
 * 
 * *   `java.util.Queue`: To manage the waiting list of patients.
 * *   `java.util.ArrayList`: To store the list of active/processed appointments.
 * *   `java.util.List`: Declare the variable holding active appointments using the `List` interface type (`List<Appointment> activeAppointments = new ArrayList<>();`).
 * *   `java.util.Scanner`: To read user input from the console.
 * *   `switch` statement: To handle the different menu options (register, call next, view, exit).
 * *   `System.err`: To display error messages (e.g., attempting to call a patient when the waiting list is empty).
 * *   `System.out`: To display menus, prompts, success messages, and list contents.
 * *   Class-wide exception handling using `try-catch` blocks: Implement a broad `try-catch` block (e.g., around the main application loop or the core execution method) to gracefully handle unexpected runtime exceptions.
 * 
 * **Implementation Details & Best Practices:**
 * 
 * *   Create appropriate classes (`Patient`, `Appointment`, `HospitalScheduler`).
 * *   Use private fields and public methods for encapsulation.
 * *   Use meaningful variable and method names.
 * *   Include comments (especially Javadoc for classes/methods) to explain your code.
 * *   Implement input validation where necessary (e.g., handling empty input for names, ensuring the queue is not empty before dequeueing).
 * *   Ensure proper resource management (close the `Scanner`).
 * *   Structure your code logically within a class (e.g., a `HospitalScheduler` class with a `run()` method).
 * 
 * **Expected Output:**
 * 
 * The program should present a menu to the user. Based on the user's choice, it should perform the corresponding action. Error messages should be printed to `System.err`, while normal output (menus, prompts, lists, success messages) should go to `System.out`.
 * 
 * Example Interaction:
 * 
 * ```
 * --- Hospital Appointment System ---
 * 1. Register Patient
 * 2. Call Next Patient
 * 3. View Status
 * 4. Exit
 * Enter your choice: 1
 * Enter patient name: Alice
 * Alice registered successfully.
 * 
 * --- Hospital Appointment System ---
 * 1. Register Patient
 * 2. Call Next Patient
 * 3. View Status
 * 4. Exit
 * Enter your choice: 1
 * Enter patient name: Bob
 * Bob registered successfully.
 * 
 * --- Hospital Appointment System ---
 * 1. Register Patient
 * 2. Call Next Patient
 * 3. View Status
 * 4. Exit
 * Enter your choice: 3
 * Waiting List:
 * - Alice
 * - Bob
 * Active Appointments:
 * (No active appointments yet)
 * 
 * --- Hospital Appointment System ---
 * 1. Register Patient
 * 2. Call Next Patient
 * 3. View Status
 * 4. Exit
 * Enter your choice: 2
 * Calling next patient: Alice
 * Alice is now in an active appointment.
 * 
 * --- Hospital Appointment System ---
 * 1. Register Patient
 * 2. Call Next Patient
 * 3. View Status
 * 4. Exit
 * Enter your choice: 3
 * Waiting List:
 * - Bob
 * Active Appointments:
 * - Alice (Active)
 * 
 * --- Hospital Appointment System ---
 * 1. Register Patient
 * 2. Call Next Patient
 * 3. View Status
 * 4. Exit
 * Enter your choice: 2
 * Calling next patient: Bob
 * Bob is now in an active appointment.
 * 
 * --- Hospital Appointment System ---
 * 1. Register Patient
 * 2. Call Next Patient
 * 3. View Status
 * 4. Exit
 * Enter your choice: 2
 * Error: Waiting list is empty. Cannot call next patient.
 * 
 * --- Hospital Appointment System ---
 * 1. Register Patient
 * 2. Call Next Patient
 * 3. View Status
 * 4. Exit
 * Enter your choice: 3
 * Waiting List:
 * (Waiting list is empty)
 * Active Appointments:
 * - Alice (Active)
 * - Bob (Active)
 * 
 * --- Hospital Appointment System ---
 * 1. Register Patient
 * 2. Call Next Patient
 * 3. View Status
 * 4. Exit
 * Enter your choice: 4
 * Exiting system. Goodbye!
 * ```
 * 
 * **Evaluation Criteria:**
 * 
 * *   Correct usage of all specified Java components.
 * *   Logical structure and flow of the program.
 * *   Effective use of collections (`Queue`, `List`, `ArrayList`).
 * *   Proper handling of user input and menu selection (`Scanner`, `switch`).
 * *   Robust error handling (`try-catch`, `System.err`) and input validation.
 * *   Adherence to object-oriented principles (encapsulation).
 * *   Code readability and maintainability (meaningful names, comments).
 *
 * EXPLANATION:
 * The provided solution implements a simple hospital appointment scheduling system as described in the problem statement, demonstrating the required Java components and best practices.
 * 
 * **Core Structure:**
 * 
 * The system is organized into three classes:
 * 1.  `Patient`: A simple class to hold patient information (just a name in this case).
 * 2.  `Appointment`: Represents an ongoing or completed appointment, linking a `Patient` object and a status string.
 * 3.  `HospitalScheduler`: The main class that manages the system's state (the waiting queue and active appointments list) and handles user interaction.
 * 
 * **Required Components Usage:**
 * 
 * 1.  **`Queue` (`java.util.Queue`)**: A `LinkedList` is used to implement the `Queue` interface for the `waitingQueue`. Patients are added using `offer()` and removed from the front using `poll()`, adhering to the FIFO (First-In, First-Out) nature of a queue, which is appropriate for a waiting list.
 * 2.  **`ArrayList` (`java.util.ArrayList`)**: An `ArrayList` is used to store `Appointment` objects representing patients currently being seen or who have been processed.
 * 3.  **`List` interface (`java.util.List`)**: The `activeAppointments` variable is declared using the `List` interface type (`List<Appointment>`), while being instantiated as an `ArrayList` (`new ArrayList<>()`). This is good practice, favoring interface-based programming.
 * 4.  **`Scanner` (`java.util.Scanner`)**: Used in the `HospitalScheduler` class to read user input from `System.in` for menu choices and patient names. The `scanner.close()` call in the `finally` block ensures the resource is released.
 * 5.  **`switch` statement**: Located in the `processChoice()` method, the `switch` statement is used to direct program flow based on the user's integer input from the menu.
 * 6.  **`System.err`**: Used specifically in the `callNextPatient()` method to report the error condition when the waiting queue is empty. It's also used in the main `try-catch` block to print details of unexpected errors.
 * 7.  **`System.out`**: Used extensively for printing the menu, prompts, success messages, and the contents of the waiting list and active appointments list.
 * 8.  **Class-wide exception handling (`try-catch`)**: The main `run()` method of the `HospitalScheduler` is wrapped in a `try-catch (Exception e)` block. This provides a top-level handler for any unhandled runtime exceptions that might occur during the program's execution, preventing abrupt crashes and printing an error message to `System.err`. More specific error handling, like catching `InputMismatchException` for invalid integer input, is handled locally within the `getUserChoice()` method.
 * 
 * **Best Practices:**
 * 
 * *   **Encapsulation:** Fields in `Patient`, `Appointment`, and `HospitalScheduler` are `private`, and access is provided through public methods (`getName()`, `getPatient()`, `getStatus()`, `setStatus()`, `run()`, etc.).
 * *   **Meaningful Names:** Classes, variables (`waitingQueue`, `activeAppointments`, `patientName`, `choice`), and methods (`registerPatient`, `callNextPatient`, `viewStatus`, `processChoice`) have names that clearly indicate their purpose.
 * *   **Comments and Documentation:** Javadoc comments are included for classes and key methods, explaining their purpose, parameters, and return values. Inline comments are used where necessary.
 * *   **Input Validation:** The `registerPatient()` method checks if the entered name is empty. The `callNextPatient()` method checks if the queue is empty before attempting to poll. The `getUserChoice()` method handles `InputMismatchException` if the user enters non-numeric input.
 * *   **Error Handling:** Specific errors (empty queue, invalid input type) are handled with targeted messages (`System.err`). A general `try-catch` handles unexpected errors.
 * *   **Clean Code Structure:** The code is divided into logical methods (`printMenu`, `getUserChoice`, `processChoice`, `registerPatient`, etc.) within the `HospitalScheduler` class, making it modular and easier to understand.
 * 
 * **Flow of Execution:**
 * 
 * 1.  The `main` method creates a `HospitalScheduler` object and calls its `run()` method.
 * 2.  The `run()` method enters a `while` loop (controlled by the `running` flag) wrapped in a `try` block.
 * 3.  Inside the loop, `printMenu()` displays options.
 * 4.  `getUserChoice()` reads the user's input, handling potential `InputMismatchException`.
 * 5.  `processChoice()` uses a `switch` statement to call the appropriate method based on the validated choice.
 * 6.  The specific methods (`registerPatient`, `callNextPatient`, `viewStatus`, `exitSystem`) perform the requested actions, interacting with the `waitingQueue` and `activeAppointments` list.
 * 7.  Error conditions (like an empty queue) are reported via `System.err`.
 * 8.  The loop continues until `exitSystem()` sets `running` to `false`.
 * 9.  When the loop exits, the `finally` block ensures the `Scanner` is closed.
 * 10. If any unexpected `Exception` occurs within the `try` block, the `catch` block is executed, printing error details to `System.err` before the `finally` block and program termination.
 * 
 * This solution effectively integrates all required components within a practical scenario, demonstrating robust error handling, proper data structure usage, and adherence to fundamental Java programming best practices.
 */

import java.util.Queue;
import java.util.LinkedList;
import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;
import java.util.InputMismatchException;

/**
 * Represents a patient in the hospital system.
 */
class Patient {
    private String name;

    /**
     * Constructs a Patient object.
     * @param name The name of the patient.
     */
    public Patient(String name) {
        this.name = name;
    }

    /**
     * Gets the name of the patient.
     * @return The patient's name.
     */
    public String getName() {
        return name;
    }

    @Override
    public String toString() {
        return name;
    }
}

/**
 * Represents an appointment, linking a patient and a status.
 */
class Appointment {
    private Patient patient;
    private String status; // e.g., "Active", "Completed"

    /**
     * Constructs an Appointment object.
     * @param patient The patient associated with the appointment.
     * @param status The initial status of the appointment.
     */
    public Appointment(Patient patient, String status) {
        this.patient = patient;
        this.status = status;
    }

    /**
     * Gets the patient for this appointment.
     * @return The associated patient.
     */
    public Patient getPatient() {
        return patient;
    }

    /**
     * Gets the status of the appointment.
     * @return The appointment status.
     */
    public String getStatus() {
        return status;
    }

    /**
     * Sets the status of the appointment.
     * @param status The new status.
     */
    public void setStatus(String status) {
        this.status = status;
    }

    @Override
    public String toString() {
        return patient.getName() + " (" + status + ")";
    }
}

/**
 * Manages the hospital appointment scheduling logic.
 */
public class HospitalScheduler {

    private Queue<Patient> waitingQueue;
    private List<Appointment> activeAppointments; // Declared as List interface
    private Scanner scanner;
    private boolean running;

    /**
     * Constructs a HospitalScheduler instance.
     * Initializes the waiting queue, active appointments list, and scanner.
     */
    public HospitalScheduler() {
        waitingQueue = new LinkedList<>(); // LinkedList implements Queue
        activeAppointments = new ArrayList<>(); // ArrayList implements List
        scanner = new Scanner(System.in);
        running = true;
    }

    /**
     * Starts the main application loop.
     * Includes class-wide exception handling.
     */
    public void run() {
        try { // Class-wide exception handling
            while (running) {
                printMenu();
                int choice = getUserChoice();
                processChoice(choice);
            }
        } catch (Exception e) {
            // Catch any unexpected runtime exceptions
            System.err.println("An unexpected error occurred: " + e.getMessage());
            e.printStackTrace(System.err); // Print stack trace to error stream
        } finally {
            // Ensure scanner is closed
            if (scanner != null) {
                scanner.close();
            }
            System.out.println("System terminated.");
        }
    }

    /**
     * Prints the main menu to the console.
     */
    private void printMenu() {
        System.out.println("\n--- Hospital Appointment System ---");
        System.out.println("1. Register Patient");
        System.out.println("2. Call Next Patient");
        System.out.println("3. View Status");
        System.out.println("4. Exit");
        System.out.print("Enter your choice: ");
    }

    /**
     * Reads and validates the user's menu choice.
     * Handles non-integer input errors.
     * @return The valid integer choice.
     */
    private int getUserChoice() {
        int choice = -1;
        try {
            choice = scanner.nextInt();
        } catch (InputMismatchException e) {
            System.err.println("Invalid input. Please enter a number.");
            scanner.next(); // Consume the invalid input
        }
        return choice;
    }

    /**
     * Processes the user's menu choice using a switch statement.
     * @param choice The integer choice entered by the user.
     */
    private void processChoice(int choice) {
        switch (choice) {
            case 1:
                registerPatient();
                break;
            case 2:
                callNextPatient();
                break;
            case 3:
                viewStatus();
                break;
            case 4:
                exitSystem();
                break;
            default:
                System.out.println("Invalid choice. Please try again.");
                break;
        }
    }

    /**
     * Handles the patient registration process.
     * Prompts for patient name and adds them to the waiting queue.
     */
    private void registerPatient() {
        scanner.nextLine(); // Consume newline left-over from nextInt()
        System.out.print("Enter patient name: ");
        String name = scanner.nextLine().trim();

        if (name.isEmpty()) {
            System.err.println("Patient name cannot be empty.");
            return;
        }

        Patient patient = new Patient(name);
        waitingQueue.offer(patient); // Add patient to the end of the queue
        System.out.println(patient.getName() + " registered successfully.");
    }

    /**
     * Calls the next patient from the waiting queue.
     * Moves the patient to the active appointments list if the queue is not empty.
     */
    private void callNextPatient() {
        Patient nextPatient = waitingQueue.poll(); // Retrieve and remove head of queue

        if (nextPatient == null) {
            System.err.println("Error: Waiting list is empty. Cannot call next patient.");
        } else {
            System.out.println("Calling next patient: " + nextPatient.getName());
            Appointment activeAppointment = new Appointment(nextPatient, "Active");
            activeAppointments.add(activeAppointment); // Add to the list of active appointments
            System.out.println(nextPatient.getName() + " is now in an active appointment.");
        }
    }

    /**
     * Displays the current status of the waiting list and active appointments.
     */
    private void viewStatus() {
        System.out.println("\nWaiting List:");
        if (waitingQueue.isEmpty()) {
            System.out.println("(Waiting list is empty)");
        } else {
            waitingQueue.forEach(patient -> System.out.println("- " + patient.getName()));
        }

        System.out.println("\nActive Appointments:");
        if (activeAppointments.isEmpty()) {
            System.out.println("(No active appointments yet)");
        } else {
            activeAppointments.forEach(appointment -> System.out.println("- " + appointment));
        }
    }

    /**
     * Sets the flag to exit the main application loop.
     */
    private void exitSystem() {
        running = false;
        System.out.println("Exiting system. Goodbye!");
    }

    /**
     * Main method to start the application.
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        HospitalScheduler scheduler = new HospitalScheduler();
        scheduler.run();
    }
}
