/*
 * Exam Question #587
 * Generated on: 2025-05-12 16:11:14
 * Generated by: Account 5
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Warehouse Inventory Processing System
 * 
 * **Scenario:**
 * 
 * You are tasked with developing a simplified warehouse inventory processing system. The system should manage incoming shipments that need to be processed and update the main inventory. Incoming shipments arrive as collections of items and are placed in a queue to await processing. A warehouse worker then processes shipments one by one from the queue, adding their contents to the central inventory.
 * 
 * **Requirements:**
 * 
 * 1.  **Item Representation:** Create a class `Item` with private fields `name` (String) and `quantity` (int). Include a constructor and public getter methods for these fields. Add a method `addQuantity(int amount)` to increase the item's quantity. Override the `toString()` method for easy printing.
 * 2.  **Warehouse Management Class:** Create a class `WarehouseManager` to handle the core logic.
 * 3.  **Data Structures:**
 *     *   Use a `java.util.Queue` (specifically, an implementation like `LinkedList`) to store incoming shipments. Each element in the queue should be a `java.util.List<Item>`, representing a single shipment containing multiple items.
 *     *   Use a `java.util.List` (specifically, a `java.util.ArrayList`) to represent the main warehouse inventory. This list should store `Item` objects, where each object represents a distinct item type and its *total* quantity in the warehouse.
 * 4.  **Functionality:** Implement the following features within the `WarehouseManager`:
 *     *   `addShipmentToQueue()`: Prompts the user to enter details for a new shipment (item name and quantity for multiple items). Creates a `List<Item>` for this shipment and adds it to the incoming shipment queue. Input validation is required for item details (non-empty name, positive integer quantity).
 *     *   `processNextShipment()`: Takes the next shipment from the head of the queue. For each `Item` in the shipment, update the main inventory: if an item with the same name already exists in the inventory, add the shipment quantity to the existing item's quantity; otherwise, add the item as a new entry in the inventory list.
 *     *   `viewInventory()`: Displays the current contents of the main inventory (item name and total quantity).
 *     *   `viewShipmentQueueStatus()`: Displays the current number of shipments waiting in the queue.
 * 5.  **User Interface:**
 *     *   Use `java.util.Scanner` to get user input.
 *     *   Present a menu of options to the user: Add Shipment, Process Shipment, View Inventory, View Queue Status, Exit.
 *     *   Use a `switch` statement to handle the user's menu choice.
 * 6.  **Output:**
 *     *   Use `System.out` for displaying the menu, prompts, successful actions, inventory list, and queue status.
 *     *   Use `System.err` for displaying all error messages (e.g., invalid menu choice, invalid input format, empty queue when trying to process).
 * 7.  **Error Handling:**
 *     *   Implement robust input validation for user-provided data (e.g., checking for non-numeric input for quantity, non-positive quantity, empty item names).
 *     *   Implement class-wide exception handling using `try-catch` blocks. Wrap the main application loop in a `try-catch` block to catch unexpected runtime exceptions. Include specific `catch` blocks for expected exceptions like `NumberFormatException` during input parsing. Handle cases like trying to process a shipment when the queue is empty.
 * 8.  **Best Practices:**
 *     *   Apply proper encapsulation (private fields, public methods).
 *     *   Use meaningful variable and method names.
 *     *   Include appropriate comments where necessary to explain complex logic.
 *     *   Ensure resources like `Scanner` are properly closed.
 * 
 * **Expected Output:**
 * 
 * The program should run interactively, presenting a menu. Users should be able to add shipments, process them, and view inventory/queue status. Error messages should clearly indicate the problem and appear on `System.err`.
 * 
 * ```
 * --- Warehouse Management Menu ---
 * 1. Add Incoming Shipment to Queue
 * 2. Process Next Shipment from Queue
 * 3. View Current Inventory
 * 4. View Shipment Queue Status
 * 0. Exit
 * -------------------------------
 * Enter your choice: 1
 * Enter shipment details (type 'done' when finished):
 * Enter item name (or 'done'): Laptop
 * Enter quantity for 'Laptop': 10
 * Added 10 x Laptop to current shipment.
 * Enter item name (or 'done'): Mouse
 * Enter quantity for 'Mouse': 50
 * Added 50 x Mouse to current shipment.
 * Enter item name (or 'done'): done
 * Shipment added to the processing queue. Queue size: 1
 * 
 * --- Warehouse Management Menu ---
 * ... (menu repeats)
 * Enter your choice: 4
 * Shipments waiting in queue: 1
 * 
 * --- Warehouse Management Menu ---
 * ... (menu repeats)
 * Enter your choice: 2
 * Processing shipment...
 * Shipment processed and inventory updated.
 * 
 * --- Warehouse Management Menu ---
 * ... (menu repeats)
 * Enter your choice: 3
 * 
 * Current Inventory:
 * - Laptop (Qty: 10)
 * - Mouse (Qty: 50)
 * --------------------
 * 
 * --- Warehouse Management Menu ---
 * ... (menu repeats)
 * Enter your choice: 2
 * Error: No shipments in the queue to process. (This should appear on System.err)
 * 
 * --- Warehouse Management Menu ---
 * ... (menu repeats)
 * Enter your choice: abc
 * Error: Invalid input. Please enter a number. (This should appear on System.err)
 * 
 * --- Warehouse Management Menu ---
 * ... (menu repeats)
 * Enter your choice: 0
 * Exiting Warehouse Management System. Goodbye!
 * Scanner closed.
 * ```
 * 
 * Your solution should consist of the complete Java code for the `Item` and `WarehouseManager` classes, including the `main` method to start the application.
 *
 * EXPLANATION:
 * The provided solution implements a `WarehouseInventoryProcessingSystem` based on the requirements, demonstrating the usage of `Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.err`, `System.out`, and `try-catch` blocks.
 * 
 * 1.  **`Item` Class:** A simple class encapsulating the data for an item (`name` and `quantity`). It includes a constructor, getters, a method to add quantity (`addQuantity`), and an overridden `toString()` for easy printing. This adheres to encapsulation principles.
 * 
 * 2.  **`WarehouseManager` Class:** This is the core class managing the warehouse operations.
 *     *   **Data Structures:**
 *         *   `incomingShipmentQueue`: Declared as `Queue<List<Item>>`, using `LinkedList` as the concrete implementation. This correctly represents a queue where each element is a list of items (a shipment). Shipments are added to the end (`offer`) and removed from the front (`poll`).
 *         *   `inventory`: Declared as `List<Item>`, using `ArrayList` as the concrete implementation. This list holds the current total stock of each distinct item type.
 *     *   **Methods:**
 *         *   `addShipmentToQueue(List<Item> shipment)`: Takes a completed shipment list and adds it to the queue. Includes a basic check for empty/null shipments.
 *         *   `processNextShipment()`: Retrieves (and removes) the next `List<Item>` from the queue using `poll()`. It iterates through the items in this shipment and calls `addItemToInventory` for each. It handles the case where the queue is empty using `System.err`.
 *         *   `addItemToInventory(Item newItem)`: This private helper method is crucial. It iterates through the `inventory` list. If an `Item` with the same name (case-insensitive) is found, it updates its quantity using the `addQuantity` method of the existing `Item` object. If not found, it creates a *new* `Item` object with the name and quantity from the shipment and adds it to the `inventory` list. Using `equalsIgnoreCase` makes the item matching more user-friendly. Creating a new `Item` prevents external lists from directly modifying inventory items, upholding encapsulation.
 *         *   `viewInventory()`: Iterates through the `inventory` list and prints each `Item` using its `toString()` method. Handles the case of an empty inventory.
 *         *   `viewShipmentQueueStatus()`: Simply prints the size of the `incomingShipmentQueue`.
 *         *   `getUserShipmentInput(Scanner scanner)`: Manages the interactive input process for creating a shipment list. It loops, prompting for item name and quantity until the user types 'done'. It performs validation: checks for empty names, non-positive quantities, and uses a `try-catch(NumberFormatException)` to ensure the quantity input is a valid integer. Error messages are printed to `System.err`.
 *         *   `printMenu()`: A helper method to display the user menu using `System.out`.
 *         *   `run()`: Contains the main application loop. It continuously displays the menu, reads user input using `Scanner`, and uses a `switch` statement to dispatch to the appropriate method based on the user's choice. It includes input validation for the menu choice itself (checking for non-numeric input and out-of-range numbers).
 * 
 * 3.  **Exception Handling (`try-catch`)**:
 *     *   The `run()` method is wrapped in a large `try-catch(Exception e)`. This serves as the "class-wide" exception handler, catching any unexpected runtime errors that might occur within the application logic and printing an error message to `System.err`.
 *     *   Inside the `run()` loop, there's a specific `try-catch(NumberFormatException e)` block around the `Integer.parseInt(inputLine)` call for the menu choice. This handles cases where the user enters non-numeric input for the menu.
 *     *   The `getUserShipmentInput` method also includes a `try-catch(NumberFormatException e)` specifically for parsing the item quantity input, ensuring robustness against invalid number formats.
 *     *   Business logic errors, like attempting to process an empty queue, are handled with explicit checks (`if (incomingShipmentQueue.isEmpty())`) and reported via `System.err`.
 * 
 * 4.  **Input/Output (`Scanner`, `System.out`, `System.err`)**:
 *     *   `Scanner` is used throughout `run()` and `getUserShipmentInput` to read user input from `System.in`.
 *     *   `System.out` is used for standard informational messages (menu, prompts, success messages, inventory display).
 *     *   `System.err` is exclusively used for reporting errors or invalid operations, as required.
 * 
 * 5.  **Control Flow (`switch`)**:
 *     *   A `switch` statement in the `run()` method effectively directs the program flow based on the user's numeric menu selection. The `default` case handles invalid numeric inputs.
 * 
 * 6.  **Best Practices:**
 *     *   Private fields and public methods ensure encapsulation.
 *     *   Method and variable names clearly indicate their purpose.
 *     *   Comments explain the role of classes, methods, fields, and key logic sections.
 *     *   Input validation is performed at the point of input.
 *     *   Error handling is implemented using `try-catch` and conditional checks, directing errors to `System.err`.
 *     *   The `Scanner` resource is closed in a `finally` block to prevent resource leaks.
 * 
 * This solution effectively integrates the required Java components into a practical, albeit simplified, application, demonstrating understanding of data structures, object-oriented principles, user interaction, and robust error handling.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;

/**
 * Represents an item with a name and quantity.
 */
class Item {
    private String name;
    private int quantity;

    /**
     * Constructs a new Item.
     * @param name The name of the item.
     * @param quantity The quantity of the item.
     */
    public Item(String name, int quantity) {
        this.name = name;
        this.quantity = quantity;
    }

    /**
     * Gets the name of the item.
     * @return The item name.
     */
    public String getName() {
        return name;
    }

    /**
     * Gets the quantity of the item.
     * @return The item quantity.
     */
    public int getQuantity() {
        return quantity;
    }

    /**
     * Adds a specified amount to the current quantity.
     * @param amount The amount to add. Must be non-negative.
     */
    public void addQuantity(int amount) {
        if (amount >= 0) {
            this.quantity += amount;
        } else {
            // In a real system, might throw an exception or log an error
            System.err.println("Warning: Attempted to add negative quantity to item " + name);
        }
    }

    /**
     * Returns a string representation of the item.
     * @return A string in the format "Name (Qty: Quantity)".
     */
    @Override
    public String toString() {
        return name + " (Qty: " + quantity + ")";
    }
}

/**
 * Manages warehouse operations including incoming shipments and inventory.
 */
public class WarehouseManager {

    // Queue to hold incoming shipments waiting to be processed.
    // Each shipment is represented as a List of Items.
    private Queue<List<Item>> incomingShipmentQueue;

    // List to represent the main warehouse inventory.
    // Each Item in this list is a distinct product type with its total quantity.
    private List<Item> inventory; // Using ArrayList as required

    /**
     * Constructs a new WarehouseManager, initializing the queue and inventory.
     */
    public WarehouseManager() {
        // LinkedList is a common implementation of the Queue interface
        this.incomingShipmentQueue = new LinkedList<>();
        // ArrayList is used for the inventory list as required
        this.inventory = new ArrayList<>();
    }

    /**
     * Adds a new shipment to the processing queue.
     * @param shipment The list of items constituting the shipment.
     */
    public void addShipmentToQueue(List<Item> shipment) {
        if (shipment == null || shipment.isEmpty()) {
            System.err.println("Error: Cannot add an empty or null shipment to the queue.");
            return;
        }
        // offer() is generally preferred over add() for queues as it handles
        // capacity-constrained queues more gracefully, although LinkedList is not capacity constrained.
        this.incomingShipmentQueue.offer(shipment);
        System.out.println("Shipment added to the processing queue. Queue size: " + incomingShipmentQueue.size());
    }

    /**
     * Processes the next shipment from the queue and updates the inventory.
     */
    public void processNextShipment() {
        // Check if the queue is empty before attempting to poll
        if (incomingShipmentQueue.isEmpty()) {
            System.err.println("Error: No shipments in the queue to process.");
            return;
        }

        // Retrieve and remove the head of the queue (the next shipment)
        List<Item> shipment = incomingShipmentQueue.poll();
        System.out.println("Processing shipment...");

        // Iterate through items in the shipment and add/update them in the inventory
        for (Item item : shipment) {
            addItemToInventory(item);
        }
        System.out.println("Shipment processed and inventory updated.");
    }

    /**
     * Helper method to add or update an item's quantity in the main inventory list.
     * If the item already exists (based on name), its quantity is updated.
     * Otherwise, the item is added as a new entry.
     * @param newItem The item from the shipment to add/update in inventory.
     */
    private void addItemToInventory(Item newItem) {
        boolean found = false;
        // Search for the item by name in the existing inventory
        for (Item existingItem : inventory) {
            // Case-insensitive comparison for item names
            if (existingItem.getName().equalsIgnoreCase(newItem.getName())) {
                existingItem.addQuantity(newItem.getQuantity());
                found = true;
                // System.out.println("Updated inventory for: " + existingItem.getName()); // Optional detail
                break; // Item found and updated, exit loop
            }
        }

        // If the item was not found in the inventory, add it as a new item
        if (!found) {
            // Add a *new* Item object to the inventory list.
            // This is important to maintain encapsulation and prevent external
            // lists (like shipments) from holding references directly into the inventory.
            inventory.add(new Item(newItem.getName(), newItem.getQuantity()));
            // System.out.println("Added new item to inventory: " + newItem.getName()); // Optional detail
        }
    }

    /**
     * Displays the current contents of the main warehouse inventory.
     */
    public void viewInventory() {
        if (inventory.isEmpty()) {
            System.out.println("Inventory is currently empty.");
            return;
        }
        System.out.println("\nCurrent Inventory:");
        // Iterate and print each item in the inventory list
        for (Item item : inventory) {
            System.out.println("- " + item); // Item's toString() is used here
        }
        System.out.println("--------------------");
    }

    /**
     * Displays the current number of shipments waiting in the queue.
     */
    public void viewShipmentQueueStatus() {
        System.out.println("Shipments waiting in queue: " + incomingShipmentQueue.size());
    }

    /**
     * Guides the user through entering details for a new shipment.
     * Reads input using the provided Scanner.
     * Includes input validation for item details.
     * @param scanner The Scanner object to use for input.
     * @return A List of Item objects representing the user-entered shipment.
     */
    public List<Item> getUserShipmentInput(Scanner scanner) {
        List<Item> shipmentItems = new ArrayList<>();
        System.out.println("Enter shipment details (type 'done' when finished):");

        while (true) {
            System.out.print("Enter item name (or 'done'): ");
            String name = scanner.nextLine().trim(); // Read item name

            if (name.equalsIgnoreCase("done")) {
                break; // Exit loop if user types 'done'
            }

            // Validate item name
            if (name.isEmpty()) {
                System.err.println("Error: Item name cannot be empty.");
                continue; // Ask for item name again
            }

            System.out.print("Enter quantity for '" + name + "': ");
            int quantity = 0;
            try {
                // Read quantity and attempt to parse it as an integer
                quantity = Integer.parseInt(scanner.nextLine().trim());

                // Validate quantity
                if (quantity <= 0) {
                    System.err.println("Error: Quantity must be a positive number.");
                    continue; // Ask for quantity again
                }
            } catch (NumberFormatException e) {
                // Handle case where input is not a valid integer
                System.err.println("Error: Invalid quantity format. Please enter a number.");
                continue; // Ask for quantity again
            }

            // If name and quantity are valid, create Item and add to shipment list
            shipmentItems.add(new Item(name, quantity));
            System.out.println("Added " + quantity + " x " + name + " to current shipment.");
        }

        return shipmentItems;
    }

    /**
     * Prints the main menu options to the console.
     */
    private void printMenu() {
        System.out.println("\n--- Warehouse Management Menu ---");
        System.out.println("1. Add Incoming Shipment to Queue");
        System.out.println("2. Process Next Shipment from Queue");
        System.out.println("3. View Current Inventory");
        System.out.println("4. View Shipment Queue Status");
        System.out.println("0. Exit");
        System.out.println("-------------------------------");
    }

    /**
     * Runs the main application loop, handling user interaction and menu choices.
     * Includes class-wide exception handling.
     */
    public void run() {
        Scanner scanner = new Scanner(System.in);
        int choice = -1; // Initialize choice to a non-exit value

        // Class-wide exception handling: Wrap the main application loop
        try {
            while (choice != 0) {
                printMenu(); // Display the menu
                System.out.print("Enter your choice: ");

                try {
                    // Read user choice and attempt to parse as integer
                    String inputLine = scanner.nextLine().trim();
                    if (inputLine.isEmpty()) {
                         System.err.println("Error: Input cannot be empty.");
                         continue; // Skip to next iteration if input is empty
                    }
                    choice = Integer.parseInt(inputLine);

                    // Use a switch statement to handle different menu options
                    switch (choice) {
                        case 1:
                            // Option 1: Add Incoming Shipment
                            List<Item> newShipment = getUserShipmentInput(scanner);
                            if (!newShipment.isEmpty()) {
                                addShipmentToQueue(newShipment);
                            } else {
                                System.out.println("No items entered for the shipment. Shipment not added.");
                            }
                            break;
                        case 2:
                            // Option 2: Process Next Shipment
                            processNextShipment();
                            break;
                        case 3:
                            // Option 3: View Inventory
                            viewInventory();
                            break;
                        case 4:
                            // Option 4: View Shipment Queue Status
                            viewShipmentQueueStatus();
                            break;
                        case 0:
                            // Option 0: Exit
                            System.out.println("Exiting Warehouse Management System. Goodbye!");
                            break;
                        default:
                            // Handle invalid menu choices (numbers outside 0-4)
                            System.err.println("Error: Invalid choice. Please enter a number between 0 and 4.");
                            break;
                    }
                } catch (NumberFormatException e) {
                    // Specific catch for non-integer input for the menu choice
                    System.err.println("Error: Invalid input. Please enter a number.");
                } catch (Exception e) {
                    // Catch any other unexpected exceptions that might occur within the loop's logic
                    System.err.println("An unexpected error occurred during operation: " + e.getMessage());
                    // e.printStackTrace(); // Uncomment for debugging purposes
                }
                // Add a blank line for better readability between menu iterations
                System.out.println();
            }
        } catch (Exception e) {
            // This catch block handles exceptions that might occur *outside* the main loop's
            // internal try-catch, demonstrating a form of "class-wide" handling for critical errors.
            System.err.println("A critical error occurred outside the main application loop: " + e.getMessage());
            e.printStackTrace(); // Print stack trace for critical errors
        } finally {
            // Ensure the scanner resource is closed when the application exits
            scanner.close();
            System.out.println("Scanner closed.");
        }
    }

    /**
     * The main method to start the Warehouse Management application.
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        WarehouseManager manager = new WarehouseManager();
        manager.run(); // Start the application
    }
}
