/*
 * Exam Question #584
 * Generated on: 2025-05-12 16:10:30
 * Generated by: Account 3
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Emergency Room Patient Management System
 * 
 * **Scenario:**
 * 
 * You are tasked with developing a simplified console-based system for managing patients in a hospital Emergency Room (ER). The system needs to handle patient registration, triage, treatment processing, and provide views of the waiting and treated patients.
 * 
 * **Requirements:**
 * 
 * Implement a Java program that simulates this ER system with the following features:
 * 
 * 1.  **Patient Registration:**
 *     *   Allows registering new patients by name and condition (e.g., STABLE, URGENT, CRITICAL).
 *     *   Assigns a unique ID to each patient.
 *     *   Newly registered patients are placed in a general waiting queue.
 *     *   All registered patients are also added to a master list for record-keeping.
 * 
 * 2.  **Patient Triage:**
 *     *   Allows moving a patient from the waiting queue to a treatment queue based on their ID.
 *     *   The patient's status should be updated to "TRIAGED".
 * 
 * 3.  **Process Patient:**
 *     *   Takes the next patient from the head of the treatment queue.
 *     *   Updates the patient's status to "TREATED".
 *     *   Simulates processing (e.g., prints a message).
 * 
 * 4.  **View Waiting Queue:**
 *     *   Displays the list of patients currently in the waiting queue.
 * 
 * 5.  **View All Patients:**
 *     *   Displays the list of all patients ever registered in the system, along with their current status.
 * 
 * 6.  **Exit:**
 *     *   Terminates the application.
 * 
 * **Technical Constraints:**
 * 
 * Your solution **MUST** utilize **ALL** of the following Java components:
 * 
 * *   `java.util.Queue`
 * *   `java.util.ArrayList`
 * *   `java.util.List` (used as the declared type for the list of all patients)
 * *   `java.util.Scanner` (for user input)
 * *   `switch` statement (for handling menu options)
 * *   `System.err` (for displaying error messages)
 * *   `System.out` (for displaying normal output, menus, results)
 * *   Class-wide exception handling using `try-catch` blocks (at least a top-level catch in the main application loop, plus specific handling where appropriate).
 * 
 * **Best Practices:**
 * 
 * *   Employ proper encapsulation (private fields, public getters/setters where necessary).
 * *   Use meaningful names for variables, methods, and classes.
 * *   Include appropriate comments to explain complex logic.
 * *   Implement robust input validation (e.g., handling non-integer input for choices or IDs).
 * *   Handle potential errors gracefully (e.g., trying to triage/process from an empty queue, patient not found).
 * *   Structure your code cleanly into appropriate classes (`Patient`, `ERManagementSystem`).
 * 
 * **Expected Output:**
 * 
 * The program should present a menu to the user and respond to their choices. Example interactions might look like:
 * 
 * ```
 * --- Emergency Room Management System ---
 * 
 * --- Menu ---
 * 1. Register New Patient
 * 2. Triage Patient (Move from Waiting to Treatment)
 * 3. Process Next Patient from Treatment
 * 4. View Waiting Queue
 * 5. View All Registered Patients
 * 6. Exit
 * Enter your choice: 1
 * --- Register New Patient ---
 * Enter patient name: Alice
 * Select condition:
 * 1. STABLE
 * 2. URGENT
 * 3. CRITICAL
 * Enter condition number (1-3): 2
 * Patient registered: Patient [ID=100, Name=Alice, Condition=URGENT, Status=WAITING]
 * Added to waiting queue. Waiting queue size: 1
 * 
 * --- Menu ---
 * ...
 * Enter your choice: 4
 * --- Waiting Queue ---
 * Patient [ID=100, Name=Alice, Condition=URGENT, Status=WAITING]
 * 
 * --- Menu ---
 * ...
 * Enter your choice: 2
 * --- Triage Patient ---
 * Enter Patient ID to triage: 100
 * Patient ID 100 triaged and moved to treatment queue.
 * Treatment queue size: 1
 * 
 * --- Menu ---
 * ...
 * Enter your choice: 4
 * --- Waiting Queue ---
 * Waiting queue is empty.
 * 
 * --- Menu ---
 * ...
 * Enter your choice: 3
 * --- Process Next Patient ---
 * Processing patient: Alice (ID: 100)
 * Patient ID 100 has been treated.
 * 
 * --- Menu ---
 * ...
 * Enter your choice: 5
 * --- All Registered Patients ---
 * Patient [ID=100, Name=Alice, Condition=URGENT, Status=TREATED]
 * 
 * --- Menu ---
 * ...
 * Enter your choice: 7
 * Invalid choice. Please enter a number between 1 and 6.
 * 
 * --- Menu ---
 * ...
 * Enter your choice: abc
 * Invalid input. Please enter a number.
 * 
 * --- Menu ---
 * ...
 * Enter your choice: 3
 * --- Process Next Patient ---
 * Treatment queue is empty. No patients to process.
 * 
 * --- Menu ---
 * ...
 * Enter your choice: 6
 * Exiting system. Goodbye!
 * Scanner closed.
 * ```
 * 
 * Your solution should compile and run correctly, demonstrating the required functionalities and error handling.
 *
 * EXPLANATION:
 * This solution implements a simplified Emergency Room Patient Management System, demonstrating the required Java concepts and best practices.
 * 
 * **System Design:**
 * 
 * The system is composed of two main classes:
 * 1.  `Patient`: Represents a single patient with attributes like ID, name, condition, and status. It includes encapsulation with private fields and public methods. A static counter ensures unique IDs.
 * 2.  `ERManagementSystem`: This is the core class that manages the patient flow. It holds three collections:
 *     *   `waitingQueue`: A `Queue<Patient>` (implemented using `LinkedList`) for patients who have just arrived.
 *     *   `treatmentQueue`: Another `Queue<Patient>` (implemented using `LinkedList`) for patients who have been triaged and are waiting for treatment.
 *     *   `allPatients`: A `List<Patient>` (implemented using `ArrayList`) that serves as a master record of every patient ever registered.
 * 
 * The `ERManagementSystem` class contains methods for each menu option (`registerPatient`, `triagePatient`, `processNextPatient`, `viewWaitingQueue`, `viewAllPatients`) and a `run` method that contains the main application loop, menu display, and user input handling.
 * 
 * **Usage of Required Components:**
 * 
 * *   **`java.util.Queue`**: Used for `waitingQueue` and `treatmentQueue`. The `offer()` method is used to add patients to the tail, and `poll()` is used to retrieve and remove the patient from the head. The `isEmpty()` method checks if a queue is empty before attempting operations. Iteration is used to view elements without removing them or to find/remove a specific element during triage.
 * *   **`java.util.ArrayList`**: Used as the concrete implementation for the `allPatients` list, providing dynamic resizing and easy iteration.
 * *   **`java.util.List`**: Used as the declared type for the `allPatients` collection (`List<Patient> allPatients = new ArrayList<>();`). This demonstrates programming to the interface, which is a key best practice, allowing flexibility to change the underlying implementation (e.g., to `LinkedList`) later if needed without modifying the code that uses the `List` methods.
 * *   **`java.util.Scanner`**: An instance is created to read user input from `System.in`. It's used in the `run` method for the main menu choice and within methods like `registerPatient` and `triagePatient` to get specific details. `scanner.nextLine()` is used carefully after `scanner.nextInt()` to consume the leftover newline character.
 * *   **`switch` statement**: Used in the `run` method to direct the program flow based on the user's integer input from the main menu. It's also used within `registerPatient` to map the user's numeric choice for condition to a string value.
 * *   **`System.err`**: Used specifically for displaying error messages, such as invalid menu choices, invalid input format (`InputMismatchException`), patient not found, or critical unhandled errors. This distinguishes error output from normal program output.
 * *   **`System.out`**: Used for all standard output, including the welcome message, menu display, prompts for input, success messages, and listing patients in the queues/list.
 * *   **Class-wide exception handling with `try-catch`**: The `run` method has a top-level `try-catch (Exception e)` block that wraps the main `while` loop. This serves as a safety net to catch any unhandled exceptions that might occur anywhere within the system's execution during the main loop, preventing the program from crashing abruptly. Additionally, specific methods like `registerPatient` and `triagePatient` have their own `try-catch (InputMismatchException e)` blocks to handle expected input format errors gracefully at the point where they occur, allowing the program to recover and continue. The `finally` block in `run` ensures the `Scanner` resource is closed.
 * 
 * **Best Practices Applied:**
 * 
 * *   **Encapsulation:** The `Patient` class fields are private, accessible only through public getters and a setter for the status. The collections and scanner in `ERManagementSystem` are also private.
 * *   **Meaningful Names:** Class names (`Patient`, `ERManagementSystem`), variable names (`waitingQueue`, `patientToTriage`, `conditionChoice`), and method names (`registerPatient`, `processNextPatient`, `viewAllPatients`) are descriptive and indicate their purpose.
 * *   **Comments:** Comments are included to explain the purpose of classes, methods, fields, and specific logic blocks (like the iterator usage in `triagePatient`).
 * *   **Input Validation:** The code checks if the menu choice is within the valid range (1-6). It also specifically catches `InputMismatchException` when reading integers to handle non-numeric input, prompting the user and consuming the invalid input to prevent infinite loops. Condition choice input is validated in `registerPatient`.
 * *   **Error Handling:** The system handles cases like attempting to triage or process from empty queues by checking `isEmpty()`. It handles the case where a patient ID is not found in the waiting queue during triage. Error messages are printed using `System.err`. The layered `try-catch` structure provides both specific and general error handling.
 * *   **Clean Code Structure:** The code is divided into logical classes. The main application logic is separated into distinct, focused methods called from the main `run` loop.
 * 
 * This solution effectively integrates the required components into a practical scenario, demonstrating understanding of collection types, user interaction, control flow, and robust error management in Java.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.InputMismatchException;
import java.util.Iterator;

// Class representing a Patient in the ER
class Patient {
    private static int nextId = 100; // Starting ID for patients
    private int id;
    private String name;
    private String condition; // e.g., "STABLE", "URGENT", "CRITICAL"
    private String status; // e.g., "WAITING", "TRIAGED", "TREATED"

    /**
     * Constructor for Patient.
     * Automatically assigns a unique ID and sets initial status to WAITING.
     * @param name The name of the patient.
     * @param condition The medical condition/priority of the patient.
     */
    public Patient(String name, String condition) {
        this.id = nextId++; // Assign unique ID and increment counter
        this.name = name;
        this.condition = condition;
        this.status = "WAITING"; // Initial status
    }

    // --- Getters ---
    public int getId() {
        return id;
    }

    public String getName() {
        return name;
    }

    public String getCondition() {
        return condition;
    }

    public String getStatus() {
        return status;
    }

    // --- Setter for status ---
    public void setStatus(String status) {
        this.status = status;
    }

    /**
     * Provides a string representation of the Patient object.
     * @return A formatted string with patient details.
     */
    @Override
    public String toString() {
        return "Patient [ID=" + id + ", Name=" + name + ", Condition=" + condition + ", Status=" + status + "]";
    }
}

// Class managing the ER operations
public class ERManagementSystem {

    // Queues to manage patient flow
    private Queue<Patient> waitingQueue; // Patients just arrived, waiting for triage
    private Queue<Patient> treatmentQueue; // Patients triaged, waiting for treatment

    // List to keep track of all registered patients
    private List<Patient> allPatients;

    private Scanner scanner; // Scanner for user input

    /**
     * Constructor initializes the queues, list, and scanner.
     */
    public ERManagementSystem() {
        // Using LinkedList as a common implementation for Queue
        waitingQueue = new LinkedList<>();
        treatmentQueue = new LinkedList<>();
        // Using ArrayList as an implementation for List
        allPatients = new ArrayList<>();
        scanner = new Scanner(System.in);
    }

    /**
     * Registers a new patient based on user input.
     * Adds the patient to the waiting queue and the allPatients list.
     * Handles input validation for condition.
     */
    private void registerPatient() {
        System.out.println("\n--- Register New Patient ---");
        try {
            System.out.print("Enter patient name: ");
            String name = scanner.nextLine();

            System.out.println("Select condition:");
            System.out.println("1. STABLE");
            System.out.println("2. URGENT");
            System.out.println("3. CRITICAL");
            System.out.print("Enter condition number (1-3): ");

            int conditionChoice = scanner.nextInt();
            scanner.nextLine(); // Consume the leftover newline character

            String condition;
            switch (conditionChoice) {
                case 1: condition = "STABLE"; break;
                case 2: condition = "URGENT"; break;
                case 3: condition = "CRITICAL"; break;
                default:
                    // Use System.err for invalid input messages that prevent action
                    System.err.println("Invalid condition choice. Patient not registered.");
                    return; // Exit method if input is invalid
            }

            Patient newPatient = new Patient(name, condition);
            waitingQueue.offer(newPatient); // Add to the tail of the waiting queue
            allPatients.add(newPatient); // Add to the list of all patients

            System.out.println("Patient registered successfully: " + newPatient);
            System.out.println("Added to waiting queue. Current waiting queue size: " + waitingQueue.size());

        } catch (InputMismatchException e) {
            // Catch non-integer input specifically for nextInt()
            System.err.println("Invalid input. Please enter a number for the condition choice.");
            scanner.nextLine(); // Consume the invalid input to prevent infinite loop
        } catch (Exception e) {
            // Catch any other unexpected exceptions during registration
            System.err.println("An unexpected error occurred during patient registration: " + e.getMessage());
            // Consider logging e.printStackTrace() in a real application for debugging
        }
    }

    /**
     * Moves a patient from the waiting queue to the treatment queue.
     * Requires the patient's ID. Finds and removes the patient from waitingQueue
     * using an iterator and adds them to treatmentQueue.
     * Handles cases where waiting queue is empty or patient ID is not found.
     */
    private void triagePatient() {
        System.out.println("\n--- Triage Patient ---");
        if (waitingQueue.isEmpty()) {
            System.out.println("Waiting queue is empty. No patients to triage.");
            return;
        }

        try {
            System.out.print("Enter Patient ID to triage: ");
            int patientIdToTriage = scanner.nextInt();
            scanner.nextLine(); // Consume the leftover newline

            Patient patientToTriage = null;
            Iterator<Patient> iterator = waitingQueue.iterator();
            // Iterate through the waiting queue to find the patient by ID
            while (iterator.hasNext()) {
                Patient p = iterator.next();
                if (p.getId() == patientIdToTriage) {
                    patientToTriage = p;
                    iterator.remove(); // Remove the patient from the waiting queue using the iterator
                    break; // Found and removed, exit loop
                }
            }

            if (patientToTriage == null) {
                System.err.println("Patient with ID " + patientIdToTriage + " not found in the waiting queue.");
            } else {
                // Update status and add to the treatment queue
                patientToTriage.setStatus("TRIAGED");
                treatmentQueue.offer(patientToTriage); // Add to the tail of the treatment queue
                System.out.println("Patient ID " + patientIdToTriage + " triaged and moved to treatment queue.");
                System.out.println("Current treatment queue size: " + treatmentQueue.size());
            }

        } catch (InputMismatchException e) {
            System.err.println("Invalid input. Please enter a number for Patient ID.");
            scanner.nextLine(); // Consume the invalid input
        } catch (Exception e) {
            System.err.println("An unexpected error occurred during patient triage: " + e.getMessage());
            // e.printStackTrace();
        }
    }

    /**
     * Processes the next patient from the head of the treatment queue.
     * Updates the patient's status to TREATED.
     * Handles case where treatment queue is empty.
     */
    private void processNextPatient() {
        System.out.println("\n--- Process Next Patient ---");
        try {
            Patient patientToProcess = treatmentQueue.poll(); // Retrieves and removes the head of the queue

            if (patientToProcess == null) {
                System.out.println("Treatment queue is empty. No patients to process.");
            } else {
                patientToProcess.setStatus("TREATED");
                System.out.println("Processing patient: " + patientToProcess.getName() + " (ID: " + patientToProcess.getId() + ")");
                // Simulate treatment process
                System.out.println("Patient ID " + patientToProcess.getId() + " has been treated.");
            }
        } catch (Exception e) {
            // Catch any unexpected exceptions during processing
            System.err.println("An unexpected error occurred during patient processing: " + e.getMessage());
            // e.printStackTrace();
        }
    }

    /**
     * Displays all patients currently in the waiting queue.
     */
    private void viewWaitingQueue() {
        System.out.println("\n--- Waiting Queue ---");
        if (waitingQueue.isEmpty()) {
            System.out.println("Waiting queue is empty.");
        } else {
            // Iterate through the queue elements without removing
            for (Patient p : waitingQueue) {
                System.out.println(p);
            }
        }
    }

    /**
     * Displays all patients ever registered in the system.
     */
    private void viewAllPatients() {
        System.out.println("\n--- All Registered Patients ---");
        if (allPatients.isEmpty()) {
            System.out.println("No patients registered yet.");
        } else {
            // Iterate through the list of all patients
            for (Patient p : allPatients) {
                System.out.println(p);
            }
        }
    }

    /**
     * Prints the main menu options to the console.
     */
    private void printMenu() {
        System.out.println("\n--- Menu ---");
        System.out.println("1. Register New Patient");
        System.out.println("2. Triage Patient (Move from Waiting to Treatment)");
        System.out.println("3. Process Next Patient from Treatment");
        System.out.println("4. View Waiting Queue");
        System.out.println("5. View All Registered Patients");
        System.out.println("6. Exit");
    }

    /**
     * The main application loop. Displays the menu and processes user input.
     * Includes class-wide exception handling using a top-level try-catch.
     */
    public void run() {
        boolean running = true;
        System.out.println("--- Emergency Room Management System ---");

        // Class-wide exception handling for the main application loop
        try {
            while (running) {
                printMenu();
                System.out.print("Enter your choice: ");

                try {
                    // Use a nested try-catch for input parsing specifically
                    int choice = scanner.nextInt();
                    scanner.nextLine(); // Consume the newline character after reading the integer

                    // Use a switch statement for flow control based on user choice
                    switch (choice) {
                        case 1:
                            registerPatient();
                            break;
                        case 2:
                            triagePatient();
                            break;
                        case 3:
                            processNextPatient();
                            break;
                        case 4:
                            viewWaitingQueue();
                            break;
                        case 5:
                            viewAllPatients();
                            break;
                        case 6:
                            running = false; // Set flag to exit the loop
                            System.out.println("Exiting system. Goodbye!");
                            break;
                        default:
                            // Use System.err for invalid menu choices
                            System.err.println("Invalid choice. Please enter a number between 1 and 6.");
                    }
                } catch (InputMismatchException e) {
                    // Catch non-integer input for menu choice
                    System.err.println("Invalid input. Please enter a number.");
                    scanner.nextLine(); // Consume the invalid input to prevent infinite loop
                }
                // Specific errors (like empty queues or patient not found) are handled within the respective methods.
                // Any unhandled runtime exceptions from methods would bubble up to the outer try-catch.
            }
        } catch (Exception e) {
            // This catches any unhandled exceptions that occur outside the specific input handling
            // or bubble up from the methods. Acts as the class-wide catcher for critical errors.
            System.err.println("\n--- A critical error occurred! The system is shutting down. ---");
            System.err.println("Error details: " + e.getMessage());
            // In a real application, you would log this error and potentially attempt a graceful shutdown.
            // e.printStackTrace(); // Uncomment for debugging purposes if needed
        } finally {
            // Ensure the scanner resource is closed when the application exits
            if (scanner != null) {
                scanner.close();
                System.out.println("Scanner closed.");
            }
        }
    }

    /**
     * Main method to start the ER Management System application.
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        ERManagementSystem system = new ERManagementSystem();
        system.run(); // Start the main application loop
    }
}
