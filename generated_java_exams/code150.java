/*
 * Exam Question #150
 * Generated on: 2025-05-11 22:22:04
 * Generated by: Account 2
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Logistics Package Management System
 * 
 * **Problem Description:**
 * 
 * A logistics company needs a simple console-based system to manage packages before they are dispatched for delivery. Packages arrive and are placed in a central processing queue. When a package is ready for delivery, it is taken from the queue and assigned to one of several predefined delivery routes.
 * 
 * Your task is to implement this system using the specified Java components and best practices.
 * 
 * The system must support the following operations via a text-based menu:
 * 1.  **Add New Package:** Allows the user to enter details for a new package (ID, destination address, weight) and adds it to the processing queue.
 * 2.  **Process Next Package for Delivery:** Takes the package at the front of the processing queue and assigns it to a specified delivery route.
 * 3.  **List Packages in Processing Queue:** Displays the details of all packages currently waiting in the processing queue.
 * 4.  **List Packages on a Specific Delivery Route:** Displays the details of all packages assigned to a particular delivery route.
 * 5.  **List All Delivery Routes:** Displays the contents of all delivery routes.
 * 6.  **Exit:** Terminates the program.
 * 
 * Assume there are exactly **3** delivery routes, numbered 1, 2, and 3 for user interaction.
 * 
 * **Technical Requirements:**
 * 
 * Your solution must utilize **ALL** of the following Java components from the `java.util` package or standard Java features:
 * 
 * *   `java.util.Queue` (for the processing queue)
 * *   `java.util.ArrayList` (specifically used for storing the collection of delivery routes)
 * *   `java.util.List` (used as the type for individual delivery routes within the ArrayList)
 * *   `java.util.Scanner` (for reading user input from the console)
 * *   `switch` statement (for handling the menu options)
 * *   `System.err` (for printing error messages)
 * *   `System.out` (for printing normal output, prompts, and menu)
 * *   Class-wide exception handling using `try-catch` blocks (handle potential issues like invalid input, empty queue, invalid route index, etc.)
 * 
 * **Best Practices:**
 * 
 * *   Implement proper encapsulation (private fields, public methods/constructors).
 * *   Use meaningful variable, method, and class names.
 * *   Include appropriate comments and documentation (e.g., Javadoc-style).
 * *   Perform input validation (e.g., check for valid menu choices, non-empty strings, positive weight, valid route index).
 * *   Provide clear error messages using `System.err`.
 * *   Structure your code into appropriate classes (`Package`, `LogisticsSystem`, and a main application class).
 * 
 * **Expected Output:**
 * 
 * *   The program should continuously display the menu until the user chooses to exit.
 * *   Prompts for input should be clear.
 * *   Successful operations should have confirmation messages.
 * *   Listing operations should clearly format and display the contents of the queue or routes.
 * *   Invalid operations or errors (e.g., trying to process from an empty queue, entering non-numeric input, specifying an invalid route number) should result in an informative error message printed to `System.err`, and the program should not crash, returning to the menu instead (except for the Exit option).
 * 
 * **Example Interaction Snippet:**
 * 
 * ```
 * --- Logistics System Menu ---
 * 1. Add New Package
 * 2. Process Next Package for Delivery
 * 3. List Packages in Processing Queue
 * 4. List Packages on a Specific Delivery Route
 * 5. List All Delivery Routes
 * 6. Exit
 * -----------------------------
 * Enter your choice: 1
 * Enter Package ID: PKG001
 * Enter Destination Address: 123 Main St
 * Enter Weight (kg): 5.5
 * Package PKG001 added to processing queue.
 * 
 * --- Logistics System Menu ---
 * ...
 * Enter your choice: 2
 * Enter route number (1 to 3): 2
 * Package PKG001 processed and assigned to Route 2
 * 
 * --- Logistics System Menu ---
 * ...
 * Enter your choice: 3
 * --- Packages in Processing Queue ---
 * Queue is empty.
 * ------------------------------------
 * 
 * --- Logistics System Menu ---
 * ...
 * Enter your choice: 4
 * Enter route number (1 to 3): 2
 * --- Packages on Route 2 ---
 * 1. Package [ID=PKG001, Dest=123 Main St, Weight=5.5 kg]
 * -----------------------------------
 * 
 * --- Logistics System Menu ---
 * ...
 * Enter your choice: 2
 * Enter route number (1 to 3): 1
 * Error processing package: No packages in the processing queue.
 * 
 * --- Logistics System Menu ---
 * ...
 * Enter your choice: 7
 * Invalid choice. Please enter a number between 1 and 6.
 * 
 * --- Logistics System Menu ---
 * ...
 * Enter your choice: abc
 * Invalid input. Please enter a number.
 * 
 * --- Logistics System Menu ---
 * ...
 * Enter your choice: 6
 * Exiting system. Goodbye!
 * ```
 * 
 * Implement the complete Java code for this system.
 *
 * EXPLANATION:
 * The provided solution implements a console-based Logistics Package Management System, demonstrating the required Java concepts and best practices.
 * 
 * **Required Components Usage:**
 * 
 * 1.  **`java.util.Queue`**: The `processingQueue` in the `LogisticsSystem` class is declared as a `Queue<Package>`. It uses `LinkedList` as the concrete implementation, which is a common choice for queues. Packages are added using `offer()` and removed/processed using `poll()`.
 * 2.  **`java.util.ArrayList`**: The `deliveryRoutes` in `LogisticsSystem` is an `ArrayList` of `List<Package>`. This `ArrayList` dynamically stores the collection of delivery routes.
 * 3.  **`java.util.List`**: Each individual route stored within the `deliveryRoutes` `ArrayList` is declared as a `List<Package>`. `ArrayList` is used as the concrete implementation for these inner lists, allowing packages to be added to specific routes.
 * 4.  **`java.util.Scanner`**: An instance of `Scanner` is used in the `main` method of `LogisticsApp` to read user input from `System.in` for menu choices and package details. `nextLine()` is used consistently to consume entire lines, preventing common scanner issues.
 * 5.  **`switch` statement**: The `main` method uses a `switch` statement based on the user's integer input (`choice`) to direct program flow to the corresponding operation (Add, Process, List Queue, List Route, List All, Exit).
 * 6.  **`System.err`**: Used throughout the `main` method and occasionally in `LogisticsSystem` (e.g., adding null package) to print error messages, distinguishing them from normal output.
 * 7.  **`System.out`**: Used for displaying the menu, prompts for input, confirmation messages, and the formatted output of package lists from the queue and routes.
 * 8.  **`try-catch` blocks**: Extensive `try-catch` blocks are used in the `main` method to handle various potential exceptions:
 *     *   `NumberFormatException` for non-integer menu input or non-numeric weight/route number input.
 *     *   `IllegalArgumentException` caught from the `Package` constructor (for invalid package data) or `LogisticsSystem` constructor (though less likely with a constant).
 *     *   Custom exceptions (`EmptyQueueException`, `InvalidRouteException`) thrown by `LogisticsSystem` methods are caught and handled gracefully, printing informative messages to `System.err`.
 *     *   A general `Exception` catch-all is included in the main loop and specific operation blocks for unexpected errors, printing a stack trace for debugging. This demonstrates robust, multi-level exception handling.
 * 
 * **Code Structure and Best Practices:**
 * 
 * *   **Encapsulation:** The `Package` and `LogisticsSystem` classes have private fields (`packageId`, `destinationAddress`, `weight`, `processingQueue`, `deliveryRoutes`, `numberOfRoutes`) and public methods (`getters`, `addPackageToQueue`, `processNextPackage`, etc.) to control access and manage internal state.
 * *   **Meaningful Names:** Class names (`Package`, `LogisticsSystem`, `LogisticsApp`), method names (`addPackageToQueue`, `processNextPackage`, `listQueueContents`), and variable names (`packageId`, `deliveryRoutes`, `routeIndex`) are descriptive.
 * *   **Comments and Documentation:** Javadoc-style comments are used for classes and methods to explain their purpose, parameters, and potential exceptions. Inline comments clarify specific logic points.
 * *   **Input Validation:** Validation is performed at multiple levels:
 *     *   In `Package` constructor: checks for empty/null strings and non-positive weight.
 *     *   In `LogisticsSystem` methods (`processNextPackage`, `listRouteContents`): validates the provided route index.
 *     *   In `main`: `try-catch` handles `NumberFormatException` for user input.
 * *   **Error Handling:** Errors are handled gracefully using `try-catch`. Custom exceptions (`EmptyQueueException`, `InvalidRouteException`) are defined to represent specific business logic errors, making the error handling clearer than relying solely on built-in exceptions. Error messages are printed to `System.err`.
 * *   **Clean Code Structure:** The code is divided into three logical classes: `Package` (data model), `LogisticsSystem` (core logic), and `LogisticsApp` (user interface/main execution). The `main` method contains a clear menu loop and uses the `switch` statement to delegate tasks to the `LogisticsSystem` object.
 * 
 * **Key Concepts Demonstrated:**
 * 
 * *   **Object-Oriented Programming:** Use of classes, objects, encapsulation.
 * *   **Data Structures:** Practical application of `Queue` for FIFO processing and nested `List`/`ArrayList` for structured storage of routes and packages.
 * *   **Collections Framework:** Utilizing interfaces (`Queue`, `List`) and concrete implementations (`LinkedList`, `ArrayList`).
 * *   **Exception Handling:** Implementing `try-catch` blocks for anticipated issues (`NumberFormatException`, custom exceptions) and unexpected errors. Definition and use of custom exception classes.
 * *   **User Input Processing:** Using `Scanner` to read different data types and handling potential input errors.
 * *   **Control Flow:** Using `switch` for menu navigation and loops (`while`) for continuous operation.
 * *   **Basic Input/Output:** Using `System.out` and `System.err`.
 * *   **Indexing Conversion:** Handling the conversion between user-friendly 1-based route numbers and internal 0-based list indices.
 * 
 * The solution effectively integrates all required components into a functional system that simulates a practical logistics scenario while adhering to good programming practices and demonstrating robust error handling.
 */

import java.util.ArrayList;
import java.util.LinkedList; // A common Queue implementation
import java.util.List;
import java.util.Queue;
import java.util.Scanner;

// Custom exception for an empty queue operation
class EmptyQueueException extends Exception {
    public EmptyQueueException(String message) {
        super(message);
    }
}

// Custom exception for an invalid route index
class InvalidRouteException extends Exception {
    public InvalidRouteException(String message) {
        super(message);
    }
}

/**
 * Represents a package with ID, destination, and weight.
 */
class Package {
    private String packageId;
    private String destinationAddress;
    private double weight;

    /**
     * Constructs a new Package.
     *
     * @param packageId The unique identifier for the package.
     * @param destinationAddress The destination address for the package.
     * @param weight The weight of the package in kilograms.
     * @throws IllegalArgumentException if packageId, destinationAddress are null/empty or weight is non-positive.
     */
    public Package(String packageId, String destinationAddress, double weight) {
        // Input validation
        if (packageId == null || packageId.trim().isEmpty()) {
            throw new IllegalArgumentException("Package ID cannot be empty.");
        }
        if (destinationAddress == null || destinationAddress.trim().isEmpty()) {
            throw new IllegalArgumentException("Destination address cannot be empty.");
        }
        if (weight <= 0) {
            throw new IllegalArgumentException("Weight must be positive.");
        }

        this.packageId = packageId;
        this.destinationAddress = destinationAddress;
        this.weight = weight;
    }

    // --- Getters ---
    public String getPackageId() {
        return packageId;
    }

    public String getDestinationAddress() {
        return destinationAddress;
    }

    public double getWeight() {
        return weight;
    }

    @Override
    public String toString() {
        return "Package [ID=" + packageId + ", Dest=" + destinationAddress + ", Weight=" + weight + " kg]";
    }
}

/**
 * Manages the package processing queue and delivery routes.
 */
class LogisticsSystem {
    private Queue<Package> processingQueue;
    private List<List<Package>> deliveryRoutes; // ArrayList of Lists
    private final int numberOfRoutes;

    /**
     * Constructs a LogisticsSystem with a specified number of routes.
     *
     * @param numberOfRoutes The number of delivery routes to initialize.
     */
    public LogisticsSystem(int numberOfRoutes) {
        if (numberOfRoutes <= 0) {
            throw new IllegalArgumentException("Number of routes must be positive.");
        }
        this.numberOfRoutes = numberOfRoutes;
        this.processingQueue = new LinkedList<>(); // Using LinkedList as a Queue implementation
        this.deliveryRoutes = new ArrayList<>(numberOfRoutes);
        // Initialize each route as an empty ArrayList
        for (int i = 0; i < numberOfRoutes; i++) {
            this.deliveryRoutes.add(new ArrayList<>());
        }
    }

    /**
     * Adds a package to the processing queue.
     *
     * @param pkg The package to add.
     */
    public void addPackageToQueue(Package pkg) {
        if (pkg != null) {
            processingQueue.offer(pkg); // offer is preferred over add for queues
            System.out.println("Package " + pkg.getPackageId() + " added to processing queue.");
        } else {
             System.err.println("Cannot add a null package to the queue.");
        }
    }

    /**
     * Processes the next package from the queue and assigns it to a delivery route.
     *
     * @param routeIndex The 0-based index of the route to assign the package to.
     * @throws EmptyQueueException if the processing queue is empty.
     * @throws InvalidRouteException if the route index is out of bounds.
     */
    public void processNextPackage(int routeIndex) throws EmptyQueueException, InvalidRouteException {
        if (processingQueue.isEmpty()) {
            throw new EmptyQueueException("No packages in the processing queue.");
        }

        if (routeIndex < 0 || routeIndex >= deliveryRoutes.size()) {
            // Throw exception with user-friendly 1-based index
            throw new InvalidRouteException("Invalid route number: " + (routeIndex + 1) + ". Routes are 1 to " + numberOfRoutes + ".");
        }

        Package pkg = processingQueue.poll(); // Removes and returns the head of the queue
        deliveryRoutes.get(routeIndex).add(pkg); // Add package to the specified route list
        System.out.println("Package " + pkg.getPackageId() + " processed and assigned to Route " + (routeIndex + 1));
    }

    /**
     * Lists all packages currently in the processing queue.
     */
    public void listQueueContents() {
        System.out.println("--- Packages in Processing Queue ---");
        if (processingQueue.isEmpty()) {
            System.out.println("Queue is empty.");
            System.out.println("------------------------------------");
            return;
        }

        // Iterate through the queue without removing elements
        int index = 1;
        for (Package pkg : processingQueue) {
            System.out.println(index++ + ". " + pkg);
        }
        System.out.println("------------------------------------");
    }

    /**
     * Lists all packages assigned to a specific delivery route.
     *
     * @param routeIndex The 0-based index of the route to list.
     * @throws InvalidRouteException if the route index is out of bounds.
     */
    public void listRouteContents(int routeIndex) throws InvalidRouteException {
         if (routeIndex < 0 || routeIndex >= deliveryRoutes.size()) {
            // Throw exception with user-friendly 1-based index
            throw new InvalidRouteException("Invalid route number: " + (routeIndex + 1) + ". Routes are 1 to " + numberOfRoutes + ".");
        }

        List<Package> route = deliveryRoutes.get(routeIndex);
        System.out.println("--- Packages on Route " + (routeIndex + 1) + " ---");
        if (route.isEmpty()) {
            System.out.println("Route " + (routeIndex + 1) + " is empty.");
            System.out.println("-----------------------------------");
            return;
        }

        int index = 1;
        for (Package pkg : route) {
            System.out.println(index++ + ". " + pkg);
        }
        System.out.println("-----------------------------------");
    }

    /**
     * Lists the contents of all delivery routes.
     */
    public void listAllRoutes() {
        System.out.println("--- All Delivery Routes ---");
        if (deliveryRoutes.isEmpty()) {
             System.out.println("No delivery routes defined."); // Should not happen with current constructor
             System.out.println("--------------------------");
             return;
        }

        for (int i = 0; i < deliveryRoutes.size(); i++) {
            List<Package> route = deliveryRoutes.get(i);
            System.out.println("Route " + (i + 1) + ":");
            if (route.isEmpty()) {
                System.out.println("  (Empty)");
            } else {
                int index = 1;
                for (Package pkg : route) {
                     System.out.println("  " + index++ + ". " + pkg);
                }
            }
        }
        System.out.println("--------------------------");
    }

    /**
     * Gets the total number of defined delivery routes.
     * @return The number of routes.
     */
    public int getNumberOfRoutes() {
        return numberOfRoutes;
    }
}

/**
 * Main application class for the Logistics Package Management System.
 * Handles user interaction and calls methods of the LogisticsSystem.
 */
public class LogisticsApp {

    private static final int NUMBER_OF_ROUTES = 3; // Constant for the number of routes

    /**
     * Displays the main menu options to the user.
     */
    private static void displayMenu() {
        System.out.println("\n--- Logistics System Menu ---");
        System.out.println("1. Add New Package");
        System.out.println("2. Process Next Package for Delivery");
        System.out.println("3. List Packages in Processing Queue");
        System.out.println("4. List Packages on a Specific Delivery Route");
        System.out.println("5. List All Delivery Routes");
        System.out.println("6. Exit");
        System.out.println("-----------------------------");
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        LogisticsSystem system = null;

        try {
            // Initialize the system - could potentially throw IllegalArgumentException
            system = new LogisticsSystem(NUMBER_OF_ROUTES);
        } catch (IllegalArgumentException e) {
            System.err.println("System initialization failed: " + e.getMessage());
            scanner.close(); // Close scanner before exiting
            return; // Exit if system cannot be initialized
        }


        while (true) {
            displayMenu();
            int choice = -1; // Default invalid choice

            System.out.print("Enter your choice: ");
            String inputLine = scanner.nextLine(); // Read the entire line

            try {
                choice = Integer.parseInt(inputLine); // Attempt to parse input as integer

                // Use switch for menu control
                switch (choice) {
                    case 1: // Add New Package
                        try {
                            System.out.print("Enter Package ID: ");
                            String id = scanner.nextLine();
                            System.out.print("Enter Destination Address: ");
                            String address = scanner.nextLine();
                            System.out.print("Enter Weight (kg): ");
                            double weight = Double.parseDouble(scanner.nextLine()); // Potential NumberFormatException

                            // Create Package object - potential IllegalArgumentException
                            Package newPackage = new Package(id, address, weight);
                            system.addPackageToQueue(newPackage);

                        } catch (NumberFormatException e) {
                            System.err.println("Invalid input for weight. Please enter a numeric value.");
                        } catch (IllegalArgumentException e) {
                            // Catches validation errors from Package constructor
                            System.err.println("Error creating package: " + e.getMessage());
                        } catch (Exception e) {
                            // Catch any other unexpected errors during package creation/addition
                            System.err.println("An unexpected error occurred while adding package: " + e.getMessage());
                            e.printStackTrace(System.err); // Print stack trace for debugging
                        }
                        break;

                    case 2: // Process Next Package for Delivery
                        try {
                            System.out.print("Enter route number (1 to " + system.getNumberOfRoutes() + "): ");
                            int routeNumber = Integer.parseInt(scanner.nextLine()); // Potential NumberFormatException
                            // Convert 1-based user input to 0-based index
                            int routeIndex = routeNumber - 1;

                            // Call process method - potential EmptyQueueException or InvalidRouteException
                            system.processNextPackage(routeIndex);

                        } catch (NumberFormatException e) {
                            System.err.println("Invalid input for route number. Please enter a number.");
                        } catch (EmptyQueueException | InvalidRouteException e) {
                            // Catch custom exceptions from processNextPackage
                            System.err.println("Error processing package: " + e.getMessage());
                        } catch (Exception e) {
                            // Catch any other unexpected errors during processing
                            System.err.println("An unexpected error occurred while processing package: " + e.getMessage());
                            e.printStackTrace(System.err);
                        }
                        break;

                    case 3: // List Packages in Processing Queue
                        system.listQueueContents();
                        break;

                    case 4: // List Packages on a Specific Delivery Route
                        try {
                            System.out.print("Enter route number (1 to " + system.getNumberOfRoutes() + "): ");
                            int listRouteNumber = Integer.parseInt(scanner.nextLine()); // Potential NumberFormatException
                             // Convert 1-based user input to 0-based index
                            int listRouteIndex = listRouteNumber - 1;

                            // Call list method - potential InvalidRouteException
                            system.listRouteContents(listRouteIndex);

                        } catch (NumberFormatException e) {
                            System.err.println("Invalid input for route number. Please enter a number.");
                        } catch (InvalidRouteException e) {
                             // Catch custom exception from listRouteContents
                            System.err.println("Error listing route: " + e.getMessage());
                        } catch (Exception e) {
                            // Catch any other unexpected errors during listing route
                            System.err.println("An unexpected error occurred while listing route: " + e.getMessage());
                            e.printStackTrace(System.err);
                        }
                        break;

                    case 5: // List All Delivery Routes
                        system.listAllRoutes();
                        break;

                    case 6: // Exit
                        System.out.println("Exiting system. Goodbye!");
                        scanner.close(); // Close the scanner resource
                        return; // Terminate the program

                    default:
                        // Handle choices outside the 1-6 range
                        System.err.println("Invalid choice. Please enter a number between 1 and 6.");
                }

            } catch (NumberFormatException e) {
                // Catches errors if the initial menu input is not a valid integer
                System.err.println("Invalid input. Please enter a number.");
                // nextLine() already consumes the invalid input line, no need for scanner.next() or similar
            } catch (Exception e) {
                // Generic catch for any other unexpected exceptions in the main loop
                System.err.println("An unexpected system error occurred: " + e.getMessage());
                e.printStackTrace(System.err);
            }
            System.out.println(); // Add a blank line for better readability between operations
        }
    }
}
