/*
 * Exam Question #449
 * Generated on: 2025-05-11 23:12:38
 * Generated by: Account 4
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Production Line Task Manager
 * 
 * **Scenario:**
 * 
 * You are tasked with developing a simplified system to manage tasks on a manufacturing production line. Tasks arrive and are placed in a queue waiting to be processed. A single worker processes tasks one by one from the front of the queue. Once a task is processed, it is moved to a log of completed tasks. The system should allow a user to interactively manage this process via a command-line interface.
 * 
 * **Requirements:**
 * 
 * Implement a Java program that fulfills the following:
 * 
 * 1.  **Task Representation:** Create a class named `Task` to represent a production task. It must have:
 *     *   A `private` integer field for a unique `id`.
 *     *   A `private` String field for the `description` of the task.
 *     *   A `private` String field for the `status` (e.g., "Pending", "Processed").
 *     *   A constructor `Task(int id, String description)` that initializes `id`, `description`, and sets the initial `status` to "Pending".
 *     *   `public` getter methods for `id`, `description`, and `status`.
 *     *   A `public` method `markAsProcessed()` that changes the task's status to "Processed".
 *     *   Override the `toString()` method to provide a user-friendly string representation of the task (e.g., "Task ID: [id], Description: [description], Status: [status]").
 * 
 * 2.  **Production Line Manager:** Create a class (e.g., `ProductionLineManager`) containing the `main` method. This class will manage the task flow.
 *     *   It must use a `java.util.Queue<Task>` (e.g., `java.util.LinkedList`) to store tasks waiting to be processed.
 *     *   It must use a `java.util.List<Task>` (implemented by `java.util.ArrayList`) to store tasks that have been processed. Declare the field using the `List` interface.
 *     *   Implement a menu-driven command-line interface using `java.util.Scanner` to get user input. The menu should offer the following options:
 *         *   `1. Add New Task`: Prompt the user for a Task ID (integer) and Description (String). Create a `Task` object and add it to the production queue.
 *         *   `2. Process Next Task`: Take the task at the front of the queue, mark it as processed using the `markAsProcessed()` method, and move it to the list of processed tasks. If the queue is empty, display an appropriate error message.
 *         *   `3. View Pending Tasks`: Display all tasks currently in the production queue.
 *         *   `4. View Processed Tasks`: Display all tasks in the processed tasks list.
 *         *   `5. Exit`: Terminate the program.
 *     *   Use a `switch` statement to handle the user's menu choice.
 *     *   Use `System.out` for displaying the menu, prompts, and successful output (task details, confirmation messages).
 *     *   Use `System.err` for displaying error messages (e.g., invalid input, queue empty when processing).
 *     *   Implement input validation:
 *         *   Ensure Task ID is a positive integer. Handle non-integer input gracefully.
 *         *   Ensure Task Description is not empty.
 *         *   Handle invalid menu choices.
 *     *   Implement class-wide exception handling: Wrap the main application loop or critical operations in a `try-catch` block to catch potential unexpected errors and print an error message using `System.err`.
 * 
 * **Expected Output:**
 * 
 * The program should present a menu, accept user input, perform the requested action, and display results or errors.
 * 
 * Example Interaction (user input shown in `bold`):
 * 
 * ```
 * --- Production Line Task Manager ---
 * 1. Add New Task
 * 2. Process Next Task
 * 3. View Pending Tasks
 * 4. View Processed Tasks
 * 5. Exit
 * Enter your choice: **1**
 * Enter Task ID: **101**
 * Enter Task Description: **Assemble Widget A**
 * Task 101 added to the queue.
 * 
 * --- Production Line Task Manager ---
 * ... (menu repeats)
 * Enter your choice: **1**
 * Enter Task ID: **102**
 * Enter Task Description: **Test Widget B**
 * Task 102 added to the queue.
 * 
 * --- Production Line Task Manager ---
 * ... (menu repeats)
 * Enter your choice: **3**
 * --- Pending Tasks ---
 * Task ID: 101, Description: Assemble Widget A, Status: Pending
 * Task ID: 102, Description: Test Widget B, Status: Pending
 * 
 * --- Production Line Task Manager ---
 * ... (menu repeats)
 * Enter your choice: **2**
 * Processing task: Task ID: 101, Description: Assemble Widget A, Status: Pending
 * Task 101 processed and moved to completed list.
 * 
 * --- Production Line Task Manager ---
 * ... (menu repeats)
 * Enter your choice: **3**
 * --- Pending Tasks ---
 * Task ID: 102, Description: Test Widget B, Status: Pending
 * 
 * --- Production Line Task Manager ---
 * ... (menu repeats)
 * Enter your choice: **4**
 * --- Processed Tasks ---
 * Task ID: 101, Description: Assemble Widget A, Status: Processed
 * 
 * --- Production Line Task Manager ---
 * ... (menu repeats)
 * Enter your choice: **2**
 * Processing task: Task ID: 102, Description: Test Widget B, Status: Pending
 * Task 102 processed and moved to completed list.
 * 
 * --- Production Line Task Manager ---
 * ... (menu repeats)
 * Enter your choice: **2**
 * Error: No tasks in the queue to process.
 * 
 * --- Production Line Task Manager ---
 * ... (menu repeats)
 * Enter your choice: **6**
 * Error: Invalid choice. Please enter a number between 1 and 5.
 * 
 * --- Production Line Task Manager ---
 * ... (menu repeats)
 * Enter your choice: **5**
 * Exiting Production Line Manager.
 * ```
 * 
 * **Constraints:**
 * 
 * *   Must use all specified Java components (`Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.err`, `System.out`, `try-catch`).
 * *   Adhere to good programming practices (encapsulation, meaningful names, comments, validation, error handling).
 * 
 * Your solution should provide the complete Java code for the `Task` class and the `ProductionLineManager` class.
 *
 * EXPLANATION:
 * This solution implements the `ProductionLineManager` system as required, demonstrating the practical use of all specified Java components in a cohesive application.
 * 
 * 1.  **`Task` Class:**
 *     *   Encapsulates task data (`id`, `description`, `status`) using `private` fields.
 *     *   Provides a constructor for initialization and `public` getters for accessing data.
 *     *   Includes a specific method `markAsProcessed()` to manage the task's state, adhering to encapsulation principles.
 *     *   Overrides `toString()` for convenient display.
 * 
 * 2.  **`ProductionLineManager` Class:**
 *     *   **Data Structures:**
 *         *   `productionQueue`: Declared as `Queue<Task>` and instantiated as `LinkedList`. This correctly uses the `Queue` interface for FIFO (First-In, First-Out) behavior, suitable for a processing queue. `LinkedList` is a common implementation for `Queue`.
 *         *   `processedTasks`: Declared as `List<Task>` and instantiated as `ArrayList`. This uses the `List` interface, which is a good practice, while `ArrayList` provides a dynamic, ordered collection suitable for logging completed tasks.
 *     *   **User Input:** A `Scanner` is used to read input from `System.in`.
 *     *   **Menu and `switch`:** The `displayMenu()` method presents options, and a `switch` statement in the main `run()` loop directs execution based on the user's integer input, fulfilling the `switch` requirement.
 *     *   **Operations:**
 *         *   `addNewTask()`: Prompts for ID and description, performs basic validation (positive ID, non-empty description), creates a `Task` object, and adds it to the `productionQueue` using `offer()`. Input validation includes handling `InputMismatchException` if the user enters non-numeric input for the ID.
 *         *   `processNextTask()`: Uses `productionQueue.poll()` to retrieve and remove the head of the queue. It checks if the result is `null` to determine if the queue was empty, printing an error to `System.err` if so. Otherwise, it calls `markAsProcessed()` on the task and adds it to the `processedTasks` list.
 *         *   `viewPendingTasks()`: Iterates through the `productionQueue` using a for-each loop to display tasks without removing them. Checks for emptiness.
 *         *   `viewProcessedTasks()`: Iterates through the `processedTasks` `List` to display completed tasks. Checks for emptiness.
 *     *   **Error Handling:**
 *         *   Specific input validation is done within `addNewTask()` and the main `run()` loop (`InputMismatchException` for integer input). Error messages for invalid input or operations (like processing an empty queue) are printed to `System.err` as required.
 *         *   A broad `try-catch (Exception e)` block is placed around the main `while` loop in the `run()` method. This serves as the "class-wide" or application-level exception handling, catching any unexpected runtime errors that might occur during the program's execution and printing an error message to `System.err`. A `finally` block ensures the `Scanner` is closed.
 *     *   **Best Practices:**
 *         *   Private fields and public methods ensure proper encapsulation.
 *         *   Method and variable names are descriptive (`addNewTask`, `productionQueue`, `processedTasks`).
 *         *   Javadoc and inline comments explain the purpose of classes, methods, and key logic.
 *         *   Input validation and specific error handling (e.g., checking for empty queue, catching `InputMismatchException`) are implemented.
 *         *   The code is structured into logical methods, making it readable and maintainable.
 * 
 * This solution effectively integrates the required components to simulate the production line task management process, demonstrating an understanding of data structures, control flow, user interaction, and robust error handling in Java.
 */

import java.util.LinkedList;
import java.util.Queue;
import java.util.List;
import java.util.ArrayList;
import java.util.Scanner;
import java.util.InputMismatchException;

// Represents a single production task
class Task {
    private int id;
    private String description;
    private String status; // e.g., "Pending", "Processed"

    /**
     * Constructs a new Task with a given ID and description.
     * Status is initialized to "Pending".
     * @param id The unique identifier for the task.
     * @param description A brief description of the task.
     */
    public Task(int id, String description) {
        this.id = id;
        this.description = description;
        this.status = "Pending";
    }

    // --- Getters ---
    public int getId() {
        return id;
    }

    public String getDescription() {
        return description;
    }

    public String getStatus() {
        return status;
    }

    /**
     * Marks the task as processed by changing its status.
     */
    public void markAsProcessed() {
        this.status = "Processed";
    }

    /**
     * Provides a string representation of the Task.
     * @return String representation of the task.
     */
    @Override
    public String toString() {
        return "Task ID: " + id +
               ", Description: " + description +
               ", Status: " + status;
    }
}

// Manages the production line tasks using a queue and a list
public class ProductionLineManager {

    private Queue<Task> productionQueue;
    private List<Task> processedTasks;
    private Scanner scanner;

    /**
     * Constructs a ProductionLineManager, initializing the queue and list.
     */
    public ProductionLineManager() {
        // Use LinkedList as an implementation of Queue
        productionQueue = new LinkedList<>();
        // Use ArrayList as an implementation of List
        processedTasks = new ArrayList<>();
        scanner = new Scanner(System.in);
    }

    /**
     * Displays the main menu options to the user.
     */
    private void displayMenu() {
        System.out.println("\n--- Production Line Task Manager ---");
        System.out.println("1. Add New Task");
        System.out.println("2. Process Next Task");
        System.out.println("3. View Pending Tasks");
        System.out.println("4. View Processed Tasks");
        System.out.println("5. Exit");
        System.out.print("Enter your choice: ");
    }

    /**
     * Adds a new task to the production queue based on user input.
     * Handles input validation for ID and description.
     */
    private void addNewTask() {
        int taskId = -1;
        boolean validInput = false;

        // Validate Task ID input
        while (!validInput) {
            System.out.print("Enter Task ID: ");
            try {
                taskId = scanner.nextInt();
                if (taskId <= 0) {
                    System.err.println("Error: Task ID must be a positive integer.");
                } else {
                    // Consume the rest of the line after reading the integer
                    scanner.nextLine();
                    validInput = true;
                }
            } catch (InputMismatchException e) {
                System.err.println("Error: Invalid input. Please enter an integer for Task ID.");
                scanner.nextLine(); // Consume the invalid input
            }
        }

        System.out.print("Enter Task Description: ");
        String taskDescription = scanner.nextLine().trim();

        // Validate Task Description input
        if (taskDescription.isEmpty()) {
            System.err.println("Error: Task Description cannot be empty. Task not added.");
            return; // Exit method if description is invalid
        }

        Task newTask = new Task(taskId, taskDescription);
        productionQueue.offer(newTask); // offer() is preferred over add() for queues
        System.out.println("Task " + taskId + " added to the queue.");
    }

    /**
     * Processes the next task from the front of the queue.
     * Moves the processed task to the processed tasks list.
     * Handles the case where the queue is empty.
     */
    private void processNextTask() {
        Task taskToProcess = productionQueue.poll(); // poll() returns null if queue is empty

        if (taskToProcess == null) {
            System.err.println("Error: No tasks in the queue to process.");
        } else {
            System.out.println("Processing task: " + taskToProcess);
            taskToProcess.markAsProcessed();
            processedTasks.add(taskToProcess);
            System.out.println("Task " + taskToProcess.getId() + " processed and moved to completed list.");
        }
    }

    /**
     * Displays all tasks currently waiting in the production queue.
     * Handles the case where the queue is empty.
     */
    private void viewPendingTasks() {
        System.out.println("\n--- Pending Tasks ---");
        if (productionQueue.isEmpty()) {
            System.out.println("No tasks currently in the queue.");
        } else {
            // Iterate through the queue without removing elements
            for (Task task : productionQueue) {
                System.out.println(task);
            }
        }
    }

    /**
     * Displays all tasks that have been processed and are in the completed list.
     * Handles the case where the processed list is empty.
     */
    private void viewProcessedTasks() {
        System.out.println("\n--- Processed Tasks ---");
        if (processedTasks.isEmpty()) {
            System.out.println("No tasks have been processed yet.");
        } else {
            // Iterate through the list
            for (Task task : processedTasks) {
                System.out.println(task);
            }
        }
    }

    /**
     * Runs the main application loop, handling user interaction.
     * Includes a top-level try-catch block for general exception handling.
     */
    public void run() {
        int choice = -1;
        // Class-wide exception handling around the main operational loop
        try {
            while (choice != 5) {
                displayMenu();
                try {
                    choice = scanner.nextInt();
                    // Consume the newline character left by nextInt()
                    scanner.nextLine();

                    switch (choice) {
                        case 1:
                            addNewTask();
                            break;
                        case 2:
                            processNextTask();
                            break;
                        case 3:
                            viewPendingTasks();
                            break;
                        case 4:
                            viewProcessedTasks();
                            break;
                        case 5:
                            System.out.println("Exiting Production Line Manager.");
                            break;
                        default:
                            System.err.println("Error: Invalid choice. Please enter a number between 1 and 5.");
                    }
                } catch (InputMismatchException e) {
                    System.err.println("Error: Invalid input. Please enter a number.");
                    // Consume the invalid input to prevent infinite loop
                    scanner.nextLine();
                    choice = -1; // Reset choice to prevent exiting or incorrect switch case
                }
            }
        } catch (Exception e) {
            // General catch block for any other unexpected exceptions
            System.err.println("An unexpected error occurred during program execution: " + e.getMessage());
            // Optionally print stack trace for debugging
            // e.printStackTrace();
        } finally {
            // Ensure scanner is closed even if an exception occurs
            if (scanner != null) {
                scanner.close();
            }
        }
    }

    public static void main(String[] args) {
        ProductionLineManager manager = new ProductionLineManager();
        manager.run();
    }
}
