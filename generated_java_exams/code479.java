/*
 * Exam Question #479
 * Generated on: 2025-05-11 23:17:08
 * Generated by: Account 5
 * 
 * QUESTION:
 * ## Advanced Java Programming Exam: Task Processing System
 * 
 * **Scenario:**
 * 
 * You are tasked with developing a simple console-based system to manage and process tasks. The system should allow users to add new tasks to a queue for processing, process the next task in line, and view both the pending tasks and the history of completed tasks.
 * 
 * **Requirements:**
 * 
 * Implement a Java program that fulfills the following requirements:
 * 
 * 1.  **Task Representation:** Create a class named `Task` with private fields for `id` (int), `description` (String), and `status` (String, e.g., "Pending", "Completed"). Include a constructor and public getter methods for these fields.
 * 2.  **Task Management System:** Create a class named `TaskProcessorSystem` that manages the tasks. This class should:
 *     *   Maintain a `Queue` of `Task` objects representing tasks awaiting processing.
 *     *   Maintain a `List` of `Task` objects representing tasks that have been processed. Use an `ArrayList` as the concrete implementation for the history list.
 *     *   Use a `Scanner` object to read user input for commands and task details.
 * 3.  **Functionality:** The system should support the following commands entered by the user:
 *     *   `add`: Prompts the user for a task ID (integer) and description (string), creates a new `Task` with status "Pending", and adds it to the pending tasks queue.
 *     *   `process`: Takes the next task from the pending tasks queue, changes its status to "Completed", and moves it to the processed tasks list. If the queue is empty, print an error message.
 *     *   `view_pending`: Displays all tasks currently in the pending tasks queue, including their ID, description, and status.
 *     *   `view_completed`: Displays all tasks currently in the processed tasks list, including their ID, description, and status.
 *     *   `exit`: Terminates the program.
 *     *   Any other input should be considered an invalid command.
 * 4.  **Input Handling:**
 *     *   Use `Scanner` to read user input.
 *     *   When adding a task, validate that the task ID is a valid integer. If not, print an error message and do not add the task.
 * 5.  **Output:**
 *     *   Use `System.out` for all normal output (prompts, task lists, success messages).
 *     *   Use `System.err` for all error messages (invalid command, invalid input, processing empty queue).
 * 6.  **Control Flow:** Use a `switch` statement to handle the different user commands.
 * 7.  **Error Handling:** Implement class-wide exception handling using `try-catch` blocks to gracefully handle potential runtime errors, particularly those related to input parsing or unexpected issues within the main command loop.
 * 8.  **Best Practices:** Adhere to best practices including encapsulation (private fields, public methods), meaningful variable and method names, appropriate comments (including Javadoc where helpful), and clean code structure.
 * 
 * **Expected Output Format:**
 * 
 * *   Prompts should be clear (e.g., "Enter command: ").
 * *   Task lists should clearly display ID, Description, and Status for each task.
 * *   Error messages should be informative and printed to `System.err`.
 * 
 * ```
 * Enter command: add
 * Enter task ID (integer): 101
 * Enter task description: Implement add command
 * Task 101 added to pending queue.
 * Enter command: add
 * Enter task ID (integer): 102
 * Enter task description: Implement process command
 * Task 102 added to pending queue.
 * Enter command: view_pending
 * Pending Tasks:
 * ID: 101, Description: Implement add command, Status: Pending
 * ID: 102, Description: Implement process command, Status: Pending
 * Enter command: process
 * Processing task: ID: 101, Description: Implement add command
 * Task 101 completed and moved to history.
 * Enter command: view_completed
 * Completed Tasks:
 * ID: 101, Description: Implement add command, Status: Completed
 * Enter command: view_pending
 * Pending Tasks:
 * ID: 102, Description: Implement process command, Status: Pending
 * Enter command: process
 * Processing task: ID: 102, Description: Implement process command
 * Task 102 completed and moved to history.
 * Enter command: process
 * Error: No tasks in the pending queue to process. (Printed to System.err)
 * Enter command: view_completed
 * Completed Tasks:
 * ID: 101, Description: Implement add command, Status: Completed
 * ID: 102, Description: Implement process command, Status: Completed
 * Enter command: add
 * Enter task ID (integer): abc
 * Error: Invalid input. Please enter a valid integer for Task ID. (Printed to System.err)
 * Enter command: exit
 * Exiting Task Processor System.
 * ```
 * 
 * Your solution should be a single `.java` file containing all necessary classes.
 *
 * EXPLANATION:
 * The provided solution implements a `TaskProcessorSystem` that manages tasks using a queue for pending items and a list for completed items, demonstrating the required Java concepts and best practices.
 * 
 * **Key Components and Concepts Demonstrated:**
 * 
 * 1.  **`Task` Class:** A simple class representing the data structure for a task, encapsulating its ID, description, and status with private fields and public getters. A setter is provided for updating the status upon processing.
 * 2.  **`TaskProcessorSystem` Class:** This is the core class managing the system logic.
 *     *   **`Queue<Task> pendingTasks`**: Declared using the `Queue` interface and instantiated with `LinkedList`. This correctly models the FIFO (First-In, First-Out) behavior required for processing tasks in the order they are added. `LinkedList` is a common and efficient implementation for a `Queue` when elements are frequently added to one end and removed from the other.
 *     *   **`List<Task> processedTasks`**: Declared using the `List` interface and instantiated with `ArrayList`. This models a collection where elements are added over time and can be easily iterated or accessed, suitable for a history log. `ArrayList` provides dynamic resizing and efficient element access by index (though not heavily used here, it's a standard list implementation).
 *     *   **`Scanner scanner`**: Used to read input from `System.in`. It's managed as a class member and closed in the `finally` block to prevent resource leaks.
 *     *   **`run()` Method**: Contains the main application loop. It reads user commands, processes them using a `switch` statement, and continues until the `running` flag is set to `false` by the `exit` command.
 *     *   **Class-wide `try-catch`**: The `run()` method is wrapped in a `try-catch(Exception e)` block. This demonstrates a common pattern for handling unexpected errors that might occur anywhere within the main execution flow, preventing the program from crashing abruptly. A `finally` block ensures resource cleanup (`scanner.close()`).
 * 3.  **Command Handling (`switch`):** The `switch` statement in the `run()` method effectively dispatches control to the appropriate private method based on the user's command string, making the main loop clean and readable.
 * 4.  **Input Validation and Error Handling (`Scanner`, `try-catch`, `System.err`):**
 *     *   The `addTask` method demonstrates input validation for the task ID. It reads the input as a `String` first (`scanner.nextLine()`) and then attempts to parse it into an integer using `Integer.parseInt()`.
 *     *   A specific `catch (NumberFormatException e)` block is used to handle cases where the user enters non-integer text for the ID.
 *     *   General `catch (Exception e)` blocks are included in `addTask` and the main `run` loop as a safety net for less predictable errors.
 *     *   `System.err.println()` is consistently used for printing all error messages as required.
 * 5.  **Queue and List Operations:**
 *     *   `pendingTasks.add(newTask)`: Adds a task to the tail of the queue.
 *     *   `pendingTasks.isEmpty()`: Checks if the queue has any tasks before attempting to process.
 *     *   `pendingTasks.poll()`: Retrieves and removes the task at the head of the queue for processing.
 *     *   `processedTasks.add(taskToProcess)`: Adds the completed task to the end of the history list.
 *     *   Iteration: Enhanced for loops are used to iterate through both the `pendingTasks` queue and `processedTasks` list for viewing, demonstrating how to access elements without removing them (for viewing the queue) or simply iterating through the list.
 * 6.  **Best Practices:**
 *     *   **Encapsulation:** Fields in `Task` and `TaskProcessorSystem` are `private`, and access is provided through public methods (`getters`, `setStatus`, `addTask`, `run`, etc.).
 *     *   **Naming:** Variable and method names are descriptive (e.g., `pendingTasks`, `processNextTask`, `viewCompletedTasks`).
 *     *   **Comments:** Javadoc comments are used for classes and methods, explaining their purpose, parameters, and return values. Inline comments explain specific logic points.
 *     *   **Clean Code:** The code is structured into logical methods, each responsible for a single piece of functionality (adding, processing, viewing, exiting). The main loop is kept simple by delegating work to these methods.
 * 
 * This solution effectively combines various fundamental and intermediate Java concepts (object-oriented design, collections, input/output, control flow, exception handling) in a practical scenario, fulfilling all the requirements of the exam question.
 */

import java.util.Queue;
import java.util.LinkedList;
import java.util.List;
import java.util.ArrayList;
import java.util.Scanner;
import java.util.InputMismatchException;

/**
 * Represents a single task in the system.
 */
class Task {
    private int id;
    private String description;
    private String status; // e.g., "Pending", "Completed"

    /**
     * Constructs a new Task object.
     *
     * @param id The unique identifier for the task.
     * @param description A brief description of the task.
     * @param status The initial status of the task.
     */
    public Task(int id, String description, String status) {
        this.id = id;
        this.description = description;
        this.status = status;
    }

    // --- Getters ---
    public int getId() {
        return id;
    }

    public String getDescription() {
        return description;
    }

    public String getStatus() {
        return status;
    }

    // --- Setter for Status (used during processing) ---
    public void setStatus(String status) {
        this.status = status;
    }

    /**
     * Provides a string representation of the Task.
     * @return Formatted string of task details.
     */
    @Override
    public String toString() {
        return String.format("ID: %d, Description: %s, Status: %s", id, description, status);
    }
}

/**
 * Manages the task processing workflow using a queue and a history list.
 */
public class TaskProcessorSystem {
    private Queue<Task> pendingTasks;
    private List<Task> processedTasks;
    private Scanner scanner;
    private boolean running;

    /**
     * Constructs a new TaskProcessorSystem.
     * Initializes the queue, list, and scanner.
     */
    public TaskProcessorSystem() {
        this.pendingTasks = new LinkedList<>(); // LinkedList is a common Queue implementation
        this.processedTasks = new ArrayList<>();
        this.scanner = new Scanner(System.in);
        this.running = true;
    }

    /**
     * Starts the main command loop of the system.
     * Includes class-wide exception handling.
     */
    public void run() {
        System.out.println("Task Processor System Started. Enter 'help' for commands.");

        // Class-wide try-catch block for the main operational loop
        try {
            while (running) {
                System.out.print("Enter command: ");
                String command = scanner.nextLine().trim().toLowerCase();

                switch (command) {
                    case "add":
                        addTask();
                        break;
                    case "process":
                        processNextTask();
                        break;
                    case "view_pending":
                        viewPendingTasks();
                        break;
                    case "view_completed":
                        viewProcessedTasks();
                        break;
                    case "exit":
                        exitSystem();
                        break;
                    case "help":
                        printHelp();
                        break;
                    default:
                        // Invalid command handled by default case in switch
                        System.err.println("Error: Invalid command. Enter 'help' for commands.");
                        break;
                }
            }
        } catch (Exception e) {
            // Catch any unexpected exceptions during the run loop
            System.err.println("An unexpected system error occurred: " + e.getMessage());
            e.printStackTrace(); // Print stack trace for debugging in an exam scenario
        } finally {
            // Ensure scanner is closed even if an exception occurs
            if (scanner != null) {
                scanner.close();
                System.out.println("Scanner closed.");
            }
            System.out.println("Task Processor System Shutting Down.");
        }
    }

    /**
     * Adds a new task to the pending queue based on user input.
     * Includes input validation for the task ID.
     */
    private void addTask() {
        int id = -1;
        System.out.print("Enter task ID (integer): ");
        try {
            // Use nextLine and parse to handle non-integer input gracefully
            String idInput = scanner.nextLine();
            id = Integer.parseInt(idInput);

            System.out.print("Enter task description: ");
            String description = scanner.nextLine();

            if (description == null || description.trim().isEmpty()) {
                 System.err.println("Error: Task description cannot be empty.");
                 return; // Stop adding task if description is empty
            }

            Task newTask = new Task(id, description, "Pending");
            pendingTasks.add(newTask);
            System.out.println("Task " + id + " added to pending queue.");

        } catch (NumberFormatException e) {
            // Catch specific exception for invalid integer input
            System.err.println("Error: Invalid input. Please enter a valid integer for Task ID.");
        } catch (Exception e) {
             // Catch any other potential exceptions during add (less likely here, but good practice)
             System.err.println("An error occurred while adding task: " + e.getMessage());
        }
    }

    /**
     * Processes the next task from the pending queue.
     * Moves the task to the completed list.
     */
    private void processNextTask() {
        if (pendingTasks.isEmpty()) {
            System.err.println("Error: No tasks in the pending queue to process.");
            return;
        }

        Task taskToProcess = pendingTasks.poll(); // Retrieve and remove the head of the queue
        if (taskToProcess != null) { // poll returns null if queue is empty, though checked above
            System.out.println("Processing task: " + taskToProcess);
            taskToProcess.setStatus("Completed"); // Update status
            processedTasks.add(taskToProcess);    // Add to history list
            System.out.println("Task " + taskToProcess.getId() + " completed and moved to history.");
        }
    }

    /**
     * Displays all tasks currently in the pending queue.
     */
    private void viewPendingTasks() {
        System.out.println("Pending Tasks:");
        if (pendingTasks.isEmpty()) {
            System.out.println("  No pending tasks.");
        } else {
            // Iterate through the queue without removing elements
            for (Task task : pendingTasks) {
                System.out.println("  " + task);
            }
        }
    }

    /**
     * Displays all tasks currently in the processed tasks list.
     */
    private void viewProcessedTasks() {
        System.out.println("Completed Tasks:");
        if (processedTasks.isEmpty()) {
            System.out.println("  No completed tasks.");
        } else {
            // Iterate through the list
            for (Task task : processedTasks) {
                System.out.println("  " + task);
            }
        }
    }

    /**
     * Sets the flag to stop the main loop and exit the system.
     */
    private void exitSystem() {
        System.out.println("Exiting Task Processor System.");
        running = false; // This will cause the while loop in run() to terminate
    }

    /**
     * Prints the list of available commands.
     */
    private void printHelp() {
        System.out.println("Available commands:");
        System.out.println("  add          - Add a new task to the pending queue.");
        System.out.println("  process      - Process the next task in the pending queue.");
        System.out.println("  view_pending - View all tasks currently in the pending queue.");
        System.out.println("  view_completed- View all tasks that have been processed.");
        System.out.println("  exit         - Exit the system.");
        System.out.println("  help         - Display this help message.");
    }


    /**
     * Main method to start the Task Processor System.
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        TaskProcessorSystem system = new TaskProcessorSystem();
        system.run();
    }
}
