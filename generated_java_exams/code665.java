/*
 * Exam Question #665
 * Generated on: 2025-05-12 16:22:24
 * Generated by: Account 5
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Simple Task Processor
 * 
 * **Scenario:**
 * You are tasked with building a simple command-line application to manage tasks. The application should allow users to add new tasks, view the next task waiting to be processed, complete tasks sequentially, and view all tasks that have been completed.
 * 
 * **Functionality:**
 * 1.  **Add Task:** Prompt the user for a task description and add it to a queue of pending tasks. Each task should automatically be assigned a unique, sequential ID starting from 1.
 * 2.  **View Next Pending Task:** Display the details of the task at the front of the pending queue without removing it.
 * 3.  **Complete Next Pending Task:** Remove the task at the front of the pending queue and move it to a list of completed tasks.
 * 4.  **View Completed Tasks:** Display all tasks currently in the completed tasks list.
 * 5.  **Exit:** Terminate the application.
 * 
 * **Constraints & Requirements:**
 * *   You **must** use `java.util.Queue` (specifically, a `LinkedList` implementation acting as a Queue) to manage the pending tasks.
 * *   You **must** use `java.util.ArrayList` to store the completed tasks.
 * *   You **must** use the `java.util.List` interface (e.g., for declaring the completed tasks variable or a method return type).
 * *   You **must** use `java.util.Scanner` to get all user input.
 * *   You **must** use a `switch` statement to handle the main menu options selected by the user.
 * *   You **must** use `System.err.println()` exclusively for displaying error messages (e.g., invalid menu choice, invalid input type, attempting to complete a task when none are pending).
 * *   You **must** use `System.out.println()` exclusively for displaying the menu, prompts, task details, success messages, and the list of completed tasks.
 * *   You **must** implement class-wide exception handling using `try-catch` blocks to gracefully handle potential runtime errors, such as incorrect input types or unexpected issues during execution.
 * *   Implement proper encapsulation using private fields and public methods within your classes.
 * *   Use meaningful variable and method names.
 * *   Include appropriate comments and documentation (e.g., Javadoc for classes/methods).
 * *   Perform basic input validation (e.g., ensure task description is not empty).
 * *   Handle edge cases gracefully (e.g., what happens when you try to view or complete a task when the pending queue is empty? What happens when you try to view completed tasks when the list is empty?).
 * 
 * **Expected Output & Interaction:**
 * The program should present a menu to the user. Based on the user's numerical input, it should perform the corresponding action.
 * *   Invalid menu choices or invalid input types should result in an error message printed to `System.err` and the menu being redisplayed.
 * *   Adding a task should prompt for a description and print a success message to `System.out`. An empty description should result in an error message to `System.err`.
 * *   Viewing/Completing a task when the queue is empty should print an appropriate message to `System.out`.
 * *   Viewing completed tasks when the list is empty should print an appropriate message to `System.out`.
 * *   Successful view/completion should print task details to `System.out`.
 * *   The program should loop until the user chooses the Exit option.
 * *   Any unexpected exceptions should be caught and reported to `System.err`.
 * 
 * Your solution should be a single Java file containing all necessary classes.
 * 
 * **Time Allotment:** 45-60 minutes
 *
 * EXPLANATION:
 * The provided solution implements a simple command-line task processor application, demonstrating the required Java concepts and best practices.
 * 
 * **Key Components and Their Usage:**
 * 
 * 1.  **`java.util.Queue` (`LinkedList`)**: The `pendingTasks` variable in `TaskManager` is declared as a `Queue<Task>` and initialized with a `LinkedList`. `LinkedList` implements the `Queue` interface and is suitable for a FIFO (First-In, First-Out) queue. Tasks are added using `add()` and retrieved/removed from the front using `peek()` (view) and `poll()` (complete).
 * 2.  **`java.util.ArrayList`**: The `completedTasks` variable in `TaskManager` is initialized as an `ArrayList<Task>`. This structure is used to store tasks once they are completed, allowing easy iteration and access to all completed items.
 * 3.  **`java.util.List` interface**: The `completedTasks` variable is explicitly declared using the `List<Task>` interface type. The `getCompletedTasks()` method also returns a `List<Task>`, fulfilling the requirement to use the interface.
 * 4.  **`java.util.Scanner`**: A `Scanner` object is created in the `main` method of `TaskProcessor` to read user input from `System.in`. It's used to read both integer choices (`nextInt()`) and string descriptions (`nextLine()`). Proper handling (`scanner.nextLine()` after `nextInt()`) is included to consume the leftover newline character. The scanner is closed in a `finally` block to release the resource.
 * 5.  **`switch` statement**: The `main` method uses a `switch` statement to direct the program flow based on the user's menu choice, invoking the corresponding methods in the `TaskManager`.
 * 6.  **`System.err`**: Error messages, such as invalid menu choices, `InputMismatchException` when reading input, and validation errors (like an empty task description), are printed exclusively to `System.err.println()`. This separates error output from normal application output.
 * 7.  **`System.out`**: All normal output, including the menu, prompts for input, task details, status messages (like "No pending tasks"), success confirmations, and the list of completed tasks, is printed exclusively to `System.out.println()`.
 * 8.  **Class-wide exception handling (`try-catch`)**: The main `while` loop in the `main` method is wrapped in a `try-catch` block to catch any unexpected `Exception` that might occur during execution, demonstrating a form of class-wide handling for the core logic. Additionally, a specific `try-catch` block handles `InputMismatchException` during the input reading phase, allowing for graceful recovery from non-integer input. A `finally` block ensures the `Scanner` is closed regardless of whether an exception occurred.
 * 
 * **Best Practices Implemented:**
 * 
 * *   **Encapsulation**: The `Task` and `TaskManager` classes have private fields (`id`, `description`, `pendingTasks`, `completedTasks`, `nextTaskId`) and provide public methods (`getId`, `getDescription`, `addTask`, `viewNextPendingTask`, etc.) to access and modify the data, controlling external interaction with the internal state.
 * *   **Meaningful Names**: Variables (`pendingTasks`, `completedTasks`, `nextTaskId`, `description`, `choice`) and methods (`addTask`, `viewNextPendingTask`, `completeNextPendingTask`, `getCompletedTasks`, `printMenu`) have names that clearly indicate their purpose.
 * *   **Comments and Documentation**: Javadoc comments are used for classes and methods, explaining their role, parameters, and return values. Inline comments explain specific implementation details or requirements (like using `System.err` or `System.out`).
 * *   **Input Validation**: The `addTask` method checks if the provided task description is null or empty (`trim().isEmpty()`) before creating and adding the task. An error message is printed to `System.err` if validation fails.
 * *   **Proper Error Handling**: Specific errors like `InputMismatchException` are caught and handled gracefully. Operational errors, such as attempting to complete a task when the queue is empty, are handled by checking the return value of `poll()` and printing an informative message to `System.out`. Validation errors use `System.err`.
 * *   **Clean Code Structure**: The code is organized into logical classes (`Task`, `TaskManager`, `TaskProcessor`) with clear responsibilities. The `main` method focuses on user interaction and delegating tasks to the `TaskManager`. Helper methods like `printMenu` improve readability.
 * 
 * This solution effectively integrates the required Java components within a functional application, demonstrating an understanding of data structures, object-oriented principles, input/output handling, control flow, and robust error management.
 */

import java.util.Queue;
import java.util.LinkedList;
import java.util.List;
import java.util.ArrayList;
import java.util.Scanner;
import java.util.InputMismatchException;

/**
 * Represents a single task with an ID and description.
 */
class Task {
    private int id;
    private String description;

    /**
     * Constructs a new Task.
     * @param id The unique ID of the task.
     * @param description The description of the task.
     */
    public Task(int id, String description) {
        this.id = id;
        this.description = description;
    }

    /**
     * Gets the task ID.
     * @return The task ID.
     */
    public int getId() {
        return id;
    }

    /**
     * Gets the task description.
     * @return The task description.
     */
    public String getDescription() {
        return description;
    }

    /**
     * Returns a string representation of the task.
     * @return Task details as a string.
     */
    @Override
    public String toString() {
        return "Task ID: " + id + ", Description: \"" + description + "\"";
    }
}

/**
 * Manages the collection of pending and completed tasks.
 */
class TaskManager {
    private Queue<Task> pendingTasks;
    private List<Task> completedTasks;
    private int nextTaskId;

    /**
     * Constructs a new TaskManager, initializing the task collections.
     */
    public TaskManager() {
        // pendingTasks must be a Queue, using LinkedList implementation
        this.pendingTasks = new LinkedList<>();
        // completedTasks must be an ArrayList, declared as List
        this.completedTasks = new ArrayList<>();
        this.nextTaskId = 1;
    }

    /**
     * Adds a new task to the pending queue.
     *
     * @param description The description of the task.
     * @return true if the task was added successfully, false if description is empty or null.
     */
    public boolean addTask(String description) {
        if (description == null || description.trim().isEmpty()) {
            // Use System.err for validation errors
            System.err.println("Error: Task description cannot be empty.");
            return false;
        }
        Task newTask = new Task(nextTaskId++, description.trim());
        pendingTasks.add(newTask); // add() is fine here for LinkedList
        System.out.println("Task added: " + newTask); // Use System.out for success messages
        return true;
    }

    /**
     * Views the next task in the pending queue without removing it.
     *
     * @return The next Task or null if the queue is empty.
     */
    public Task viewNextPendingTask() {
        return pendingTasks.peek(); // peek() returns null if queue is empty
    }

    /**
     * Completes the next task in the pending queue by moving it to the completed list.
     *
     * @return The completed Task or null if the pending queue is empty.
     */
    public Task completeNextPendingTask() {
        Task completedTask = pendingTasks.poll(); // poll() returns null if queue is empty
        if (completedTask != null) {
            completedTasks.add(completedTask);
            System.out.println("Task completed: " + completedTask); // Use System.out for success messages
        }
        return completedTask;
    }

    /**
     * Gets the list of all completed tasks.
     * The return type uses the List interface as required.
     *
     * @return A List of completed tasks.
     */
    public List<Task> getCompletedTasks() {
        // Returning the internal list is acceptable for this exam context.
        // For better encapsulation in production code, one might return a copy
        // or an unmodifiable list: return Collections.unmodifiableList(completedTasks);
        return completedTasks;
    }

    /**
     * Checks if the pending queue is empty.
     *
     * @return true if the pending queue is empty, false otherwise.
     */
    public boolean isPendingQueueEmpty() {
        return pendingTasks.isEmpty();
    }

    /**
     * Checks if the completed list is empty.
     *
     * @return true if the completed list is empty, false otherwise.
     */
    public boolean isCompletedListEmpty() {
        return completedTasks.isEmpty();
    }
}

/**
 * Main class for the Simple Task Processor application.
 * Contains the main execution loop and handles user interaction.
 */
public class TaskProcessor {

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        TaskManager taskManager = new TaskManager();
        boolean running = true;

        System.out.println("--- Simple Task Processor ---");

        // Class-wide exception handling wrapping the main execution loop
        try {
            while (running) {
                printMenu();

                int choice = -1;
                try {
                    System.out.print("Enter your choice: "); // Use System.out for prompts
                    choice = scanner.nextInt();
                    scanner.nextLine(); // Consume the newline character left by nextInt()

                } catch (InputMismatchException e) {
                    // Use System.err for input errors
                    System.err.println("Invalid input. Please enter a number.");
                    scanner.nextLine(); // Consume the invalid input to prevent infinite loop
                    continue; // Skip the rest of the loop and show menu again
                }

                // Use switch statement for flow control based on user choice
                switch (choice) {
                    case 1: // Add Task
                        System.out.print("Enter task description: "); // Use System.out for prompts
                        String description = scanner.nextLine();
                        taskManager.addTask(description); // addTask handles validation and System.err
                        break;

                    case 2: // View Next Pending Task
                        Task nextTask = taskManager.viewNextPendingTask();
                        if (nextTask != null) {
                            System.out.println("Next pending task: " + nextTask); // Use System.out for task details
                        } else {
                            System.out.println("No pending tasks."); // Use System.out for status messages
                        }
                        break;

                    case 3: // Complete Next Pending Task
                        Task completedTask = taskManager.completeNextPendingTask();
                        if (completedTask == null) {
                            System.out.println("No pending tasks to complete."); // Use System.out for status messages
                        }
                        // Success message is printed inside completeNextPendingTask method
                        break;

                    case 4: // View Completed Tasks
                        List<Task> completedList = taskManager.getCompletedTasks(); // Using List interface
                        if (completedList.isEmpty()) {
                            System.out.println("No tasks have been completed yet."); // Use System.out for status messages
                        } else {
                            System.out.println("--- Completed Tasks ---"); // Use System.out for headers
                            for (Task task : completedList) { // Iterating over the List
                                System.out.println(task); // Use System.out for task details
                            }
                            System.out.println("-----------------------"); // Use System.out for footers
                        }
                        break;

                    case 5: // Exit
                        System.out.println("Exiting Task Processor. Goodbye!"); // Use System.out for exit message
                        running = false;
                        break;

                    default:
                        // Use System.err for invalid choices
                        System.err.println("Invalid choice. Please enter a number between 1 and 5.");
                        break;
                }
                System.out.println(); // Add a blank line for readability in System.out
            }
        } catch (Exception e) {
            // Catch any unexpected exceptions during the main execution
            // Use System.err for unexpected errors
            System.err.println("An unexpected error occurred: " + e.getMessage());
            e.printStackTrace(); // Print stack trace for debugging purposes
        } finally {
            // Ensure the scanner resource is closed
            if (scanner != null) {
                scanner.close();
            }
            System.out.println("Scanner closed."); // Indicate cleanup
        }
    }

    /**
     * Prints the main menu options to the console using System.out.
     */
    private static void printMenu() {
        System.out.println("Menu:");
        System.out.println("1. Add New Task");
        System.out.println("2. View Next Pending Task");
        System.out.println("3. Complete Next Pending Task");
        System.out.println("4. View Completed Tasks");
        System.out.println("5. Exit");
    }
}
