/*
 * Exam Question #329
 * Generated on: 2025-05-11 22:56:09
 * Generated by: Account 5
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Restaurant Order Management System
 * 
 * **Scenario:**
 * 
 * You are tasked with building a simplified backend system for a small restaurant's order management. The system needs to handle placing new orders, processing orders from a queue, marking individual items within an order as ready, and displaying the current state of orders and the menu.
 * 
 * **Requirements:**
 * 
 * Implement a Java program that simulates this system. Your solution must adhere to the following:
 * 
 * 1.  **Core Functionality:**
 *     *   Maintain a menu of food items.
 *     *   Allow customers to place new orders, which are added to a waiting queue.
 *     *   Process the next order from the queue, moving it to an active orders list and changing its status.
 *     *   Allow kitchen staff to mark specific items within an active order as ready. An order is considered fully ready when all its items are marked ready.
 *     *   Display the current menu.
 *     *   Display the list of pending orders (in the queue).
 *     *   Display the list of active orders (being prepared or ready).
 * 2.  **Required Java Components:** Your solution *must* use *all* of the following:
 *     *   `java.util.Queue`
 *     *   `java.util.ArrayList`
 *     *   `java.util.List` interface (use `List` for declarations where appropriate, e.g., `List<MenuItem>`)
 *     *   `java.util.Scanner` for user input.
 *     *   `switch` statement for handling different user commands.
 *     *   `System.err` for displaying error messages (e.g., invalid input, trying to process an empty queue, invalid order ID).
 *     *   `System.out` for displaying menu, order details, and normal messages.
 *     *   Class-wide exception handling using `try-catch` blocks to gracefully handle potential runtime issues (like invalid input format).
 * 3.  **Design and Best Practices:**
 *     *   Use proper encapsulation (private fields, public getters/methods).
 *     *   Employ meaningful variable and method names.
 *     *   Include appropriate comments and basic documentation (e.g., class purpose).
 *     *   Implement input validation (e.g., checking if menu item indices are valid, if order IDs exist).
 *     *   Ensure proper error handling as specified above.
 *     *   Maintain a clean and readable code structure.
 *     *   Use an `enum` for order status.
 * 
 * **Implementation Details:**
 * 
 * *   Create classes like `MenuItem`, `OrderItem` (representing an item within an order, potentially tracking its readiness), `Order`, and the main `RestaurantSystem` class.
 * *   The `RestaurantSystem` class should manage the menu, the pending orders queue, and the active orders list.
 * *   The main method should provide a simple text-based interface using `Scanner` and a `switch` statement for user interaction (e.g., options like "1. View Menu", "2. Place Order", "3. Process Next Order", etc.).
 * *   Initialize the menu with a few sample items.
 * 
 * **Example User Interaction Flow (Partial):**
 * 
 * ```
 * --- Restaurant Management System ---
 * 1. View Menu
 * 2. Place New Order
 * 3. Process Next Pending Order
 * 4. View Pending Orders
 * 5. View Active Orders
 * 6. Mark Item Ready
 * 7. Exit
 * Enter command: 1
 * 
 * --- Menu ---
 * 1. Burger ($9.99)
 * 2. Pizza ($12.50)
 * 3. Fries ($3.00)
 * 
 * Enter command: 2
 * 
 * --- Place New Order ---
 * Enter menu item numbers (comma-separated, e.g., 1,3,3): 1,3
 * Order placed successfully! Order ID: 1
 * 
 * Enter command: 4
 * 
 * --- Pending Orders ---
 * Order ID: 1
 * Items: Burger, Fries
 * 
 * Enter command: 3
 * Processing next order... Order ID 1 moved to active list.
 * 
 * Enter command: 5
 * 
 * --- Active Orders ---
 * Order ID: 1 (Status: PREPARING)
 * Items:
 * - Burger (Pending)
 * - Fries (Pending)
 * 
 * Enter command: 6
 * 
 * --- Mark Item Ready ---
 * Enter Order ID: 1
 * Enter item number within order (1 for first item, 2 for second, etc.): 1
 * Item 'Burger' in Order ID 1 marked as ready.
 * 
 * Enter command: 5
 * 
 * --- Active Orders ---
 * Order ID: 1 (Status: PREPARING)
 * Items:
 * - Burger (Ready)
 * - Fries (Pending)
 * 
 * Enter command: 6
 * 
 * --- Mark Item Ready ---
 * Enter Order ID: 1
 * Enter item number within order (1 for first item, 2 for second, etc.): 2
 * Item 'Fries' in Order ID 1 marked as ready.
 * Order ID 1 is now fully READY.
 * 
 * Enter command: 5
 * 
 * --- Active Orders ---
 * Order ID: 1 (Status: READY)
 * Items:
 * - Burger (Ready)
 * - Fries (Ready)
 * 
 * Enter command: 7
 * Exiting system.
 * ```
 * 
 * **Evaluation:**
 * 
 * Your solution will be evaluated based on:
 * *   Correct implementation of all required functionalities.
 * *   Proper and effective use of `Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.err`, `System.out`, and `try-catch`.
 * *   Adherence to object-oriented principles and best practices (encapsulation, naming, comments).
 * *   Robustness through input validation and error handling.
 * *   Code clarity and structure.
 * 
 * **Note:** Focus on the core logic and component usage. You don't need a fancy GUI or persistent storage.
 *
 * EXPLANATION:
 * This solution implements a simplified restaurant order management system, demonstrating the required Java concepts and best practices.
 * 
 * **Key Components and Their Usage:**
 * 
 * 1.  **`java.util.Queue`:** The `pendingOrdersQueue` in `RestaurantSystem` is declared as a `Queue<Order>` and initialized with `java.util.LinkedList`. This is used to store orders that have been placed by customers but are waiting to be processed by the kitchen. `offer()` is used to add new orders to the tail, and `poll()` is used to retrieve and remove the order at the head (the next order to be processed). `viewPendingOrders()` iterates through the queue using a for-each loop to display its contents without removing them.
 * 2.  **`java.util.ArrayList`:** `ArrayList` is used extensively for dynamic lists.
 *     *   `menuItems` in `RestaurantSystem` is declared as `List<MenuItem>` and initialized with `ArrayList`.
 *     *   `activeOrdersList` in `RestaurantSystem` is declared as `List<Order>` and initialized with `ArrayList`.
 *     *   The `items` list within the `Order` class is declared as `List<OrderItem>` and initialized with `ArrayList`.
 *     *   Temporary lists, like `itemIndices` in `main` and `orderItems` in `placeOrder`, also use `ArrayList`.
 * 3.  **`java.util.List` interface:** The `menuItems`, `activeOrdersList`, and the `items` list within the `Order` class are declared using the `List` interface (`List<MenuItem>`, `List<Order>`, `List<OrderItem>`). This promotes good practice by programming to the interface rather than the concrete implementation (`ArrayList`), allowing for easier switching of list implementations in the future if needed.
 * 4.  **`java.util.Scanner`:** Used in the `main` method to read user input from the console (`System.in`). Methods like `nextInt()` and `nextLine()` are used to capture different types of input.
 * 5.  **`switch` statement:** The `switch` statement in the `main` method is used to control the program flow based on the user's command number, directing execution to the appropriate system function (view menu, place order, etc.).
 * 6.  **`System.err`:** Used to print error messages, such as invalid user input (non-numeric, invalid item index, invalid order ID), or system state errors (e.g., trying to process an empty queue). This distinguishes error output from normal program output.
 * 7.  **`System.out`:** Used for all normal program output, including displaying the menu, confirming actions (order placed, item marked), and showing the details of pending and active orders.
 * 8.  **Class-wide Exception Handling (`try-catch`):** The main `while` loop in the `main` method is wrapped in a large `try-catch` block. This outer catch block is intended to catch any unexpected exceptions that might propagate up, preventing the program from crashing abruptly and printing a stack trace to `System.err`. Inner `try-catch` blocks are also used specifically around `scanner.nextInt()` calls within the `switch` cases to handle `InputMismatchException` for invalid numeric input, allowing the loop to continue. `NumberFormatException` is caught when parsing item indices for placing an order.
 * 
 * **Design and Best Practices:**
 * 
 * *   **Encapsulation:** Fields in `MenuItem`, `OrderItem`, and `Order` are `private` with public getter methods. Fields in `RestaurantSystem` are also `private`.
 * *   **Meaningful Names:** Variable names (`pendingOrdersQueue`, `activeOrdersList`, `nextOrderId`, `itemIndexInOrder`) and method names (`placeOrder`, `processNextPendingOrder`, `markItemReady`, `viewActiveOrders`) clearly describe their purpose.
 * *   **Comments and Documentation:** Basic comments explain the purpose of classes, methods, and key code sections.
 * *   **Input Validation:** The code checks if entered menu item indices are valid (`placeOrder`), if an order ID exists in the active list (`markItemReady`), and if the item index within an order is valid (`markItemReady`). It also handles non-numeric input using `try-catch`.
 * *   **Error Handling:** Specific error messages are printed to `System.err` for various invalid scenarios. The `try-catch` blocks handle input format errors gracefully.
 * *   **Clean Code Structure:** The logic is divided into separate classes (`MenuItem`, `OrderItem`, `Order`, `RestaurantSystem`) and methods, making the code modular and easier to understand. The `main` method focuses on the user interaction loop.
 * *   **`enum` for Status:** `OrderStatus` enum provides a clear and type-safe way to represent the state of an order (`PENDING`, `PREPARING`, `READY`).
 * 
 * This solution effectively integrates all required components into a functional simulation of a restaurant order system, demonstrating advanced understanding of Java collections, control flow, object-oriented design, and error handling.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.InputMismatchException;

// Enum for Order Status
enum OrderStatus {
    PENDING, PREPARING, READY
}

// Represents a menu item
class MenuItem {
    private String name;
    private double price;

    public MenuItem(String name, double price) {
        this.name = name;
        this.price = price;
    }

    public String getName() {
        return name;
    }

    public double getPrice() {
        return price;
    }

    @Override
    public String toString() {
        return name + " ($" + String.format("%.2f", price) + ")";
    }
}

// Represents an item within a specific order
class OrderItem {
    private MenuItem item;
    private boolean isReady;

    public OrderItem(MenuItem item) {
        this.item = item;
        this.isReady = false; // Initially not ready
    }

    public MenuItem getItem() {
        return item;
    }

    public boolean isReady() {
        return isReady;
    }

    public void markReady() {
        this.isReady = true;
    }

    @Override
    public String toString() {
        return item.getName() + (isReady ? " (Ready)" : " (Pending)");
    }
}

// Represents a customer order
class Order {
    private int orderId;
    private List<OrderItem> items; // Use List for items within the order
    private OrderStatus status;

    public Order(int orderId, List<OrderItem> items) {
        this.orderId = orderId;
        this.items = new ArrayList<>(items); // Use ArrayList for internal storage
        this.status = OrderStatus.PENDING; // Starts as PENDING
    }

    public int getOrderId() {
        return orderId;
    }

    public List<OrderItem> getItems() {
        return items;
    }

    public OrderStatus getStatus() {
        return status;
    }

    public void setStatus(OrderStatus status) {
        this.status = status;
    }

    // Checks if all items in the order are ready
    public boolean areAllItemsReady() {
        for (OrderItem item : items) {
            if (!item.isReady()) {
                return false;
            }
        }
        return true;
    }

    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        sb.append("Order ID: ").append(orderId).append(" (Status: ").append(status).append(")\n");
        sb.append("Items:\n");
        for (OrderItem item : items) {
            sb.append("- ").append(item).append("\n");
        }
        return sb.toString();
    }
}

// Main class managing the restaurant system
class RestaurantSystem {
    private List<MenuItem> menuItems; // Use List interface
    private Queue<Order> pendingOrdersQueue; // Use Queue interface
    private List<Order> activeOrdersList; // Use List interface
    private int nextOrderId;

    public RestaurantSystem() {
        menuItems = new ArrayList<>(); // Implementation using ArrayList
        pendingOrdersQueue = new LinkedList<>(); // Implementation using LinkedList for Queue
        activeOrdersList = new ArrayList<>(); // Implementation using ArrayList
        nextOrderId = 1; // Start order IDs from 1
        initializeMenu();
    }

    // Adds initial items to the menu
    private void initializeMenu() {
        menuItems.add(new MenuItem("Burger", 9.99));
        menuItems.add(new MenuItem("Pizza", 12.50));
        menuItems.add(new MenuItem("Fries", 3.00));
        menuItems.add(new MenuItem("Soda", 2.00));
    }

    // Displays the menu
    public void displayMenu() {
        System.out.println("\n--- Menu ---");
        if (menuItems.isEmpty()) {
            System.out.println("Menu is empty.");
            return;
        }
        for (int i = 0; i < menuItems.size(); i++) {
            System.out.println((i + 1) + ". " + menuItems.get(i));
        }
        System.out.println("------------");
    }

    // Places a new order based on menu item indices
    public void placeOrder(List<Integer> itemIndices) {
        if (itemIndices == null || itemIndices.isEmpty()) {
            System.err.println("Error: No items selected for the order.");
            return;
        }

        List<OrderItem> orderItems = new ArrayList<>(); // Use ArrayList for items in this order
        for (int index : itemIndices) {
            // Validate item index
            if (index < 1 || index > menuItems.size()) {
                System.err.println("Warning: Invalid menu item number ignored: " + index);
                continue; // Skip invalid index
            }
            // Add item to the order
            orderItems.add(new OrderItem(menuItems.get(index - 1))); // -1 because menu is 1-indexed
        }

        if (orderItems.isEmpty()) {
            System.err.println("Error: Order could not be placed as no valid items were selected.");
            return;
        }

        // Create and add the new order to the pending queue
        Order newOrder = new Order(nextOrderId++, orderItems);
        pendingOrdersQueue.offer(newOrder); // offer is preferred over add for queues
        System.out.println("Order placed successfully! Order ID: " + newOrder.getOrderId());
    }

    // Processes the next order from the pending queue
    public void processNextPendingOrder() {
        if (pendingOrdersQueue.isEmpty()) {
            System.err.println("Error: No pending orders to process.");
            return;
        }

        // Get and remove the head of the queue
        Order orderToProcess = pendingOrdersQueue.poll();
        orderToProcess.setStatus(OrderStatus.PREPARING); // Change status to PREPARING
        activeOrdersList.add(orderToProcess); // Add to the active list
        System.out.println("Processing next order... Order ID " + orderToProcess.getOrderId() + " moved to active list.");
    }

    // Marks a specific item within an active order as ready
    public void markItemReady(int orderId, int itemIndexInOrder) {
        Order targetOrder = findOrderById(orderId);

        if (targetOrder == null) {
            System.err.println("Error: Order with ID " + orderId + " not found in active orders.");
            return;
        }

        if (targetOrder.getStatus() == OrderStatus.READY) {
            System.err.println("Error: Order ID " + orderId + " is already marked as READY.");
            return;
        }

        List<OrderItem> orderItems = targetOrder.getItems(); // Use List interface here
        // Validate item index within the order
        if (itemIndexInOrder < 1 || itemIndexInOrder > orderItems.size()) {
            System.err.println("Error: Invalid item number (" + itemIndexInOrder + ") for Order ID " + orderId + ".");
            return;
        }

        OrderItem itemToMark = orderItems.get(itemIndexInOrder - 1); // -1 for 0-based index
        if (itemToMark.isReady()) {
            System.out.println("Item '" + itemToMark.getItem().getName() + "' in Order ID " + orderId + " was already ready.");
        } else {
            itemToMark.markReady();
            System.out.println("Item '" + itemToMark.getItem().getName() + "' in Order ID " + orderId + " marked as ready.");

            // Check if the entire order is now ready
            if (targetOrder.areAllItemsReady()) {
                targetOrder.setStatus(OrderStatus.READY);
                System.out.println("Order ID " + orderId + " is now fully READY.");
            }
        }
    }

    // Finds an order by its ID in the active list
    private Order findOrderById(int orderId) {
        for (Order order : activeOrdersList) {
            if (order.getOrderId() == orderId) {
                return order;
            }
        }
        return null; // Not found
    }

    // Displays all pending orders in the queue
    public void viewPendingOrders() {
        System.out.println("\n--- Pending Orders ---");
        if (pendingOrdersQueue.isEmpty()) {
            System.out.println("No pending orders.");
            return;
        }
        // Iterate through the queue without removing elements
        for (Order order : pendingOrdersQueue) {
            // Print a summary for pending orders
            System.out.println("Order ID: " + order.getOrderId());
            System.out.print("Items: ");
            boolean first = true;
            for (OrderItem item : order.getItems()) {
                if (!first) System.out.print(", ");
                System.out.print(item.getItem().getName());
                first = false;
            }
            System.out.println("\n");
        }
        System.out.println("--------------------");
    }

    // Displays all active orders
    public void viewActiveOrders() {
        System.out.println("\n--- Active Orders ---");
        if (activeOrdersList.isEmpty()) {
            System.out.println("No active orders.");
            return;
        }
        for (Order order : activeOrdersList) {
            System.out.println(order); // Order's toString provides detailed output
        }
        System.out.println("-------------------");
    }

    // Main method for user interaction
    public static void main(String[] args) {
        RestaurantSystem system = new RestaurantSystem();
        Scanner scanner = new Scanner(System.in);
        boolean running = true;

        System.out.println("--- Restaurant Management System ---");

        // Class-wide try-catch block for the main interaction loop
        try {
            while (running) {
                System.out.println("\n--- Options ---");
                System.out.println("1. View Menu");
                System.out.println("2. Place New Order");
                System.out.println("3. Process Next Pending Order");
                System.out.println("4. View Pending Orders");
                System.out.println("5. View Active Orders");
                System.out.println("6. Mark Item Ready");
                System.out.println("7. Exit");
                System.out.print("Enter command: ");

                int command = -1;
                try {
                    command = scanner.nextInt();
                    // Consume the newline character left by nextInt()
                    scanner.nextLine();
                } catch (InputMismatchException e) {
                    System.err.println("Invalid input. Please enter a number.");
                    scanner.nextLine(); // Consume the invalid input
                    continue; // Skip to the next loop iteration
                }

                // Switch statement for command handling
                switch (command) {
                    case 1:
                        system.displayMenu();
                        break;
                    case 2:
                        System.out.println("\n--- Place New Order ---");
                        System.out.print("Enter menu item numbers (comma-separated, e.g., 1,3,3): ");
                        String itemInput = scanner.nextLine();
                        List<Integer> itemIndices = new ArrayList<>();
                        try {
                            String[] indexStrings = itemInput.split(",");
                            for (String indexStr : indexStrings) {
                                if (!indexStr.trim().isEmpty()) {
                                    itemIndices.add(Integer.parseInt(indexStr.trim()));
                                }
                            }
                            system.placeOrder(itemIndices);
                        } catch (NumberFormatException e) {
                            System.err.println("Invalid input format. Please enter numbers separated by commas.");
                        }
                        break;
                    case 3:
                        system.processNextPendingOrder();
                        break;
                    case 4:
                        system.viewPendingOrders();
                        break;
                    case 5:
                        system.viewActiveOrders();
                        break;
                    case 6:
                        System.out.println("\n--- Mark Item Ready ---");
                        int orderIdToMark = -1;
                        int itemIndexToMark = -1;
                        try {
                            System.out.print("Enter Order ID: ");
                            orderIdToMark = scanner.nextInt();
                            System.out.print("Enter item number within order (1 for first item, 2 for second, etc.): ");
                            itemIndexToMark = scanner.nextInt();
                            scanner.nextLine(); // Consume newline
                            system.markItemReady(orderIdToMark, itemIndexToMark);
                        } catch (InputMismatchException e) {
                            System.err.println("Invalid input. Please enter numbers for Order ID and item number.");
                            scanner.nextLine(); // Consume invalid input
                        }
                        break;
                    case 7:
                        running = false;
                        System.out.println("Exiting system.");
                        break;
                    default:
                        System.err.println("Invalid command. Please enter a number between 1 and 7.");
                }
            }
        } catch (Exception e) {
            // Catch any unexpected exceptions at the top level
            System.err.println("An unexpected system error occurred:");
            e.printStackTrace(System.err); // Print stack trace to System.err
        } finally {
            // Ensure scanner is closed
            if (scanner != null) {
                scanner.close();
            }
        }
    }
}
