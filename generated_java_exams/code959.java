/*
 * Exam Question #959
 * Generated on: 2025-05-12 17:05:15
 * Generated by: Account 5
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Hospital Appointment Management System
 * 
 * **Scenario:**
 * 
 * You are tasked with building a simplified system for managing patient appointments at a small hospital reception desk. The system needs to keep track of doctors and the waiting queue of patients for each doctor. Patients arrive and are added to a specific doctor's queue. When a doctor is ready, the next patient from their queue is called.
 * 
 * **Your Task:**
 * 
 * Implement a Java program that simulates this system. The program should interact with the user via the console, accepting commands to manage doctors and patient queues.
 * 
 * **Requirements:**
 * 
 * 1.  **Data Structures:**
 *     *   Maintain a list of `Doctor` objects.
 *     *   Each `Doctor` object must manage its own waiting `Queue` of `Patient` objects.
 * 2.  **Classes:**
 *     *   Create a `Patient` class (minimal, e.g., just storing the patient's name).
 *     *   Create a `Doctor` class (storing the doctor's name and their patient `Queue`).
 *     *   Create a main class (e.g., `HospitalSystem`) that contains the `List` of doctors and handles user interaction and system logic.
 * 3.  **Functionality (Commands):** The program should accept the following commands from the user (case-insensitive):
 *     *   `ADD_DOCTOR <doctor_name>`: Adds a new doctor to the system. Print a success message using `System.out`. If a doctor with the same name already exists, print an error using `System.err`.
 *     *   `ADD_PATIENT <patient_name> <doctor_name>`: Adds a new patient to the waiting queue of the specified doctor. Print a success message using `System.out`. If the specified doctor does not exist, print an error using `System.err`.
 *     *   `SEE_PATIENT <doctor_name>`: Removes and prints the name of the next patient from the specified doctor's queue using `System.out`. If the doctor does not exist or the queue is empty, print an error using `System.err`.
 *     *   `LIST_QUEUE <doctor_name>`: Lists all patients currently in the specified doctor's waiting queue in order, without removing them. Print each patient name on a new line using `System.out`. If the doctor does not exist or the queue is empty, print an appropriate message using `System.out` or `System.err`.
 *     *   `LIST_DOCTORS`: Lists the names of all registered doctors. Print each doctor name on a new line using `System.out`. If no doctors are registered, print an appropriate message using `System.out`.
 *     *   `EXIT`: Terminates the program.
 * 4.  **Required Java Components:** Your solution MUST use ALL of the following:
 *     *   `java.util.Queue`
 *     *   `java.util.ArrayList`
 *     *   `java.util.List`
 *     *   `java.util.Scanner` (for reading user input from `System.in`)
 *     *   `switch` statement (for processing user commands)
 *     *   `System.err` (for error messages)
 *     *   `System.out` (for normal output and success messages)
 *     *   Class-wide exception handling using `try-catch` blocks (e.g., handling potential unexpected errors during command processing).
 * 5.  **Best Practices:**
 *     *   Use meaningful variable and method names.
 *     *   Apply proper encapsulation (private fields, public methods).
 *     *   Include basic input validation (e.g., checking if required arguments are provided, if doctors exist).
 *     *   Provide appropriate comments where necessary.
 *     *   Maintain a clean code structure.
 * 
 * **Input Format:**
 * 
 * Commands are entered on a single line. Arguments are separated by spaces.
 * 
 * **Example Interaction:**
 * 
 * ```
 * ADD_DOCTOR Dr.Smith
 * Doctor Dr.Smith added.
 * ADD_DOCTOR Dr.Jones
 * Doctor Dr.Jones added.
 * LIST_DOCTORS
 * Dr.Smith
 * Dr.Jones
 * ADD_PATIENT Alice Dr.Smith
 * Alice added to Dr.Smith's queue.
 * ADD_PATIENT Bob Dr.Smith
 * Bob added to Dr.Smith's queue.
 * ADD_PATIENT Charlie Dr.Jones
 * Charlie added to Dr.Jones's queue.
 * LIST_QUEUE Dr.Smith
 * Alice
 * Bob
 * LIST_QUEUE Dr.Jones
 * Charlie
 * SEE_PATIENT Dr.Smith
 * Dr.Smith is now seeing Alice.
 * LIST_QUEUE Dr.Smith
 * Bob
 * SEE_PATIENT Dr.Smith
 * Dr.Smith is now seeing Bob.
 * SEE_PATIENT Dr.Smith
 * Error: Dr.Smith's queue is empty.
 * ADD_PATIENT David Dr.Evil
 * Error: Doctor Dr.Evil not found.
 * LIST_QUEUE Dr.Evil
 * Error: Doctor Dr.Evil not found.
 * EXIT
 * Exiting Hospital System.
 * ```
 * 
 * **Constraints:**
 * 
 * *   Assume doctor and patient names are single words or can be treated as such after splitting the input line. For simplicity, you can assume names don't contain spaces or handle multi-word names by taking the rest of the line as the name if appropriate for the command. Let's assume single-word names for doctors and patients based on the example.
 * *   Focus on the core requirements and data structure usage.
 * 
 * **Expected Output:**
 * 
 * The output should match the example interaction format, using `System.out` for success/list messages and `System.err` for errors.
 *
 * EXPLANATION:
 * This solution implements a simplified hospital appointment system, demonstrating the required Java concepts and best practices.
 * 
 * 1.  **Class Structure:**
 *     *   `Patient`: A simple class holding the patient's `name`. Encapsulation is used with a private field and a public getter.
 *     *   `Doctor`: Holds the doctor's `name` and a `Queue<Patient>` called `waitingQueue`. This queue manages the patients waiting for this specific doctor. Methods like `addPatient`, `seeNextPatient`, and `isQueueEmpty` provide controlled access to the queue, adhering to encapsulation. `LinkedList` is chosen as a concrete implementation of the `Queue` interface because it provides the necessary queue operations efficiently.
 *     *   `HospitalSystem`: This is the main class orchestrating the system. It holds a `List<Doctor>` called `doctors`, implemented by `ArrayList`. This list stores all the doctors in the system. It contains methods corresponding to each command, encapsulating the logic for managing doctors and their queues. The `main` method handles user interaction, command parsing, and the main application loop.
 * 
 * 2.  **Required Java Components Usage:**
 *     *   `java.util.Queue`: Used within the `Doctor` class (`waitingQueue`) to manage patients in a First-In, First-Out (FIFO) manner. `offer()` is used to add (enqueue) patients, and `poll()` is used to remove (dequeue) the next patient. `isEmpty()` checks if the queue has patients.
 *     *   `java.util.ArrayList`: Used in `HospitalSystem` to store the `doctors`. It provides a dynamic, resizable array implementation for the list of doctors.
 *     *   `java.util.List`: The `doctors` field in `HospitalSystem` is declared as `List<Doctor>`, programming to the interface rather than the specific implementation (`ArrayList`). This is a good practice for flexibility.
 *     *   `java.util.Scanner`: Used in the `main` method to read user input from `System.in`.
 *     *   `switch` statement: Used in the `main` method to determine which command the user entered and execute the corresponding logic.
 *     *   `System.err`: Used throughout the `HospitalSystem` methods (and `main` for input errors) to print error messages to the standard error stream, clearly separating them from normal output.
 *     *   `System.out`: Used for printing success messages, listing information (doctors, queues), and general program output.
 *     *   `try-catch`: A `try-catch` block wraps the main command processing loop in the `main` method. This provides a form of class-wide exception handling, catching any unexpected runtime exceptions that might occur during command execution and preventing the program from crashing abruptly. Specific validation checks (like null/empty inputs, doctor not found, empty queue) are handled with `if` statements and `System.err` *before* potential exceptions would occur, but the `try-catch` serves as a fallback for unforeseen issues.
 * 
 * 3.  **Best Practices:**
 *     *   **Encapsulation:** Fields in `Patient` and `Doctor` are private with public getters/methods for controlled access. The `HospitalSystem` manages its internal list of doctors and provides public methods for operations, hiding the internal data structures.
 *     *   **Meaningful Names:** Class names (`Patient`, `Doctor`, `HospitalSystem`), variable names (`name`, `waitingQueue`, `doctors`, `command`, `patientName`, `doctorName`), and method names (`addPatient`, `seeNextPatient`, `findDoctor`, `listQueue`) are descriptive.
 *     *   **Input Validation:** The methods in `HospitalSystem` check for null or empty input strings (`name == null || name.trim().isEmpty()`) and validate the existence of doctors before attempting operations on them, printing errors to `System.err`.
 *     *   **Error Handling:** Specific error conditions (doctor not found, queue empty, missing arguments) are checked and reported using `System.err`. The general `try-catch` provides robustness against unexpected runtime errors.
 *     *   **Comments:** Basic comments explain the purpose of classes and key parts of the code.
 *     *   **Clean Code:** The code is structured logically with separate classes for distinct entities and methods for specific actions. The `main` method is kept relatively clean by delegating the core logic to methods within the `HospitalSystem` instance. The use of `split()` with a limit simplifies command parsing. Iterating over the `Queue` for listing is done using an `Iterator` to avoid modifying the queue's state.
 * 
 * The solution effectively combines various Java core concepts and data structures to solve a practical problem, fulfilling all the requirements of the exam task.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.Iterator; // Needed to iterate over Queue for listing

// Class representing a Patient
class Patient {
    private String name;

    public Patient(String name) {
        this.name = name;
    }

    public String getName() {
        return name;
    }

    @Override
    public String toString() {
        return name;
    }
}

// Class representing a Doctor with their patient queue
class Doctor {
    private String name;
    private Queue<Patient> waitingQueue;

    public Doctor(String name) {
        this.name = name;
        this.waitingQueue = new LinkedList<>(); // LinkedList implements Queue
    }

    public String getName() {
        return name;
    }

    public void addPatient(Patient patient) {
        waitingQueue.offer(patient); // offer is generally preferred over add for queues
    }

    public Patient seeNextPatient() {
        return waitingQueue.poll(); // poll returns null if queue is empty
    }

    public boolean isQueueEmpty() {
        return waitingQueue.isEmpty();
    }

    public Queue<Patient> getWaitingQueue() {
        return waitingQueue;
    }

    @Override
    public String toString() {
        return name;
    }
}

// Main class for the Hospital Management System
public class HospitalSystem {
    private List<Doctor> doctors; // Use List interface, implemented by ArrayList

    public HospitalSystem() {
        this.doctors = new ArrayList<>(); // ArrayList implements List
    }

    // Helper method to find a doctor by name
    private Doctor findDoctor(String name) {
        for (Doctor doctor : doctors) {
            if (doctor.getName().equalsIgnoreCase(name)) {
                return doctor;
            }
        }
        return null; // Doctor not found
    }

    // Command: ADD_DOCTOR
    public void addDoctor(String name) {
        if (name == null || name.trim().isEmpty()) {
            System.err.println("Error: Doctor name cannot be empty.");
            return;
        }
        if (findDoctor(name) != null) {
            System.err.println("Error: Doctor " + name + " already exists.");
        } else {
            Doctor newDoctor = new Doctor(name);
            doctors.add(newDoctor);
            System.out.println("Doctor " + name + " added.");
        }
    }

    // Command: ADD_PATIENT
    public void addPatient(String patientName, String doctorName) {
        if (patientName == null || patientName.trim().isEmpty() || doctorName == null || doctorName.trim().isEmpty()) {
            System.err.println("Error: Patient name and doctor name cannot be empty.");
            return;
        }
        Doctor doctor = findDoctor(doctorName);
        if (doctor == null) {
            System.err.println("Error: Doctor " + doctorName + " not found.");
        } else {
            Patient newPatient = new Patient(patientName);
            doctor.addPatient(newPatient);
            System.out.println(patientName + " added to " + doctorName + "'s queue.");
        }
    }

    // Command: SEE_PATIENT
    public void seePatient(String doctorName) {
        if (doctorName == null || doctorName.trim().isEmpty()) {
            System.err.println("Error: Doctor name cannot be empty.");
            return;
        }
        Doctor doctor = findDoctor(doctorName);
        if (doctor == null) {
            System.err.println("Error: Doctor " + doctorName + " not found.");
        } else {
            Patient nextPatient = doctor.seeNextPatient();
            if (nextPatient == null) {
                System.err.println("Error: " + doctorName + "'s queue is empty.");
            } else {
                System.out.println(doctorName + " is now seeing " + nextPatient.getName() + ".");
            }
        }
    }

    // Command: LIST_QUEUE
    public void listQueue(String doctorName) {
        if (doctorName == null || doctorName.trim().isEmpty()) {
            System.err.println("Error: Doctor name cannot be empty.");
            return;
        }
        Doctor doctor = findDoctor(doctorName);
        if (doctor == null) {
            System.err.println("Error: Doctor " + doctorName + " not found.");
        } else {
            Queue<Patient> queue = doctor.getWaitingQueue();
            if (queue.isEmpty()) {
                System.out.println(doctorName + "'s queue is empty.");
            } else {
                System.out.println("Patients in " + doctorName + "'s queue:");
                // Iterate over the queue without removing elements
                Iterator<Patient> iterator = queue.iterator();
                while (iterator.hasNext()) {
                    System.out.println(iterator.next().getName());
                }
            }
        }
    }

    // Command: LIST_DOCTORS
    public void listDoctors() {
        if (doctors.isEmpty()) {
            System.out.println("No doctors registered.");
        } else {
            System.out.println("Registered Doctors:");
            for (Doctor doctor : doctors) {
                System.out.println(doctor.getName());
            }
        }
    }

    public static void main(String[] args) {
        HospitalSystem hospital = new HospitalSystem();
        Scanner scanner = new Scanner(System.in);
        boolean running = true;

        System.out.println("Hospital Appointment System");
        System.out.println("Available commands: ADD_DOCTOR <name>, ADD_PATIENT <patient> <doctor>, SEE_PATIENT <doctor>, LIST_QUEUE <doctor>, LIST_DOCTORS, EXIT");

        // Class-wide exception handling
        try {
            while (running) {
                System.out.print("> ");
                String line = scanner.nextLine().trim();
                if (line.isEmpty()) {
                    continue;
                }

                String[] parts = line.split("\\s+", 3); // Split into command and up to 2 arguments
                String command = parts[0].toUpperCase();

                try {
                    switch (command) {
                        case "ADD_DOCTOR":
                            if (parts.length < 2) {
                                System.err.println("Error: ADD_DOCTOR requires a doctor name.");
                            } else {
                                hospital.addDoctor(parts[1]);
                            }
                            break;
                        case "ADD_PATIENT":
                            if (parts.length < 3) {
                                System.err.println("Error: ADD_PATIENT requires patient name and doctor name.");
                            } else {
                                hospital.addPatient(parts[1], parts[2]);
                            }
                            break;
                        case "SEE_PATIENT":
                            if (parts.length < 2) {
                                System.err.println("Error: SEE_PATIENT requires a doctor name.");
                            } else {
                                hospital.seePatient(parts[1]);
                            }
                            break;
                        case "LIST_QUEUE":
                            if (parts.length < 2) {
                                System.err.println("Error: LIST_QUEUE requires a doctor name.");
                            } else {
                                hospital.listQueue(parts[1]);
                            }
                            break;
                        case "LIST_DOCTORS":
                            hospital.listDoctors();
                            break;
                        case "EXIT":
                            running = false;
                            System.out.println("Exiting Hospital System.");
                            break;
                        default:
                            System.err.println("Unknown command: " + command);
                            System.out.println("Available commands: ADD_DOCTOR <name>, ADD_PATIENT <patient> <doctor>, SEE_PATIENT <doctor>, LIST_QUEUE <doctor>, LIST_DOCTORS, EXIT");
                            break;
                    }
                } catch (Exception e) {
                    // Catch exceptions within command processing for more specific error context if needed,
                    // but the main try-catch handles unexpected runtime issues.
                    System.err.println("An error occurred during command execution: " + e.getMessage());
                    // e.printStackTrace(); // Uncomment for debugging
                }
            }
        } catch (Exception e) {
            // General catch-all for unexpected errors during the main loop
            System.err.println("An unexpected system error occurred: " + e.getMessage());
            // e.printStackTrace(); // Uncomment for debugging
        } finally {
            scanner.close(); // Ensure scanner is closed
        }
    }
}
