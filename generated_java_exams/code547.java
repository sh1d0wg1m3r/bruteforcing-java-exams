/*
 * Exam Question #547
 * Generated on: 2025-05-11 23:27:42
 * Generated by: Account 2
 * 
 * QUESTION:
 * ## Advanced Java Programming Exam Task: Task Management System
 * 
 * **Problem Description:**
 * 
 * You are tasked with building a simple command-line based Task Management System for a small team. The system should allow users to add new tasks, view tasks waiting to be processed, view tasks that have been completed, and process the next task in the queue.
 * 
 * Your solution must demonstrate proficiency in using core Java collections, input handling, control flow, and exception handling.
 * 
 * **Requirements:**
 * 
 * 1.  **Task Representation:** Create a `Task` class with private fields for a unique integer `id` and a `String` `description`. The `id` should be automatically generated sequentially starting from 1 for each new task created. Provide appropriate public getter methods.
 * 2.  **Data Structures:**
 *     *   Maintain a collection of tasks that are waiting to be processed. This collection **must** be implemented using the `java.util.Queue` interface.
 *     *   Maintain a collection of tasks that have been completed. This collection **must** be declared using the `java.util.List` interface and implemented using `java.util.ArrayList`.
 * 3.  **User Interaction:**
 *     *   Implement a command-line interface using `java.util.Scanner` to read user input. Use a `try-with-resources` block for the `Scanner` to ensure it's closed properly.
 *     *   Present the user with a menu of options:
 *         1.  Add New Task
 *         2.  View Pending Tasks
 *         3.  View Completed Tasks
 *         4.  Process Next Task
 *         5.  Exit
 *     *   Read the user's choice and use a `switch` statement to handle the different options.
 * 4.  **Functionality:**
 *     *   **Add New Task:** Prompt the user for a task description. Create a new `Task` object and add it to the pending tasks queue. Print a success message to `System.out`.
 *     *   **View Pending Tasks:** Iterate through the pending tasks queue and print the details of each task to `System.out`. If the queue is empty, print a message indicating that.
 *     *   **View Completed Tasks:** Iterate through the completed tasks list and print the details of each task to `System.out`. If the list is empty, print a message indicating that.
 *     *   **Process Next Task:** Take the next task from the front of the pending tasks queue and move it to the completed tasks list. Print a success message to `System.out` showing the processed task. If the pending tasks queue is empty, print an error message to `System.err`.
 *     *   **Exit:** Terminate the program.
 * 5.  **Error Handling and Validation:**
 *     *   Implement input validation for the "Add New Task" option: The task description cannot be empty or just whitespace. If invalid, print an error message to `System.err` and do not add the task.
 *     *   Handle cases where the user enters an invalid menu choice (not 1-5). Print an error message to `System.err`.
 *     *   Use `System.err` specifically for all error messages (invalid input, empty queue/list operations where an action fails).
 *     *   Use `System.out` for all normal output (menu, prompts, success messages, task lists).
 *     *   Implement **class-wide exception handling** using a `try-catch` block that wraps the main program loop to catch any unexpected runtime errors. Print a generic error message to `System.err` if such an exception occurs.
 * 6.  **Best Practices:**
 *     *   Follow proper encapsulation principles for the `Task` class.
 *     *   Use meaningful variable and method names.
 *     *   Include appropriate comments and basic documentation (e.g., Javadoc for classes).
 *     *   Structure the code cleanly.
 * 
 * **Expected Output:**
 * 
 * The program should interact with the user via the console, displaying menus and task information. Error messages should be clearly distinguishable using `System.err`.
 * 
 * Example Interaction Snippet:
 * 
 * ```
 * Task Processor Menu:
 * 1. Add New Task
 * 2. View Pending Tasks
 * 3. View Completed Tasks
 * 4. Process Next Task
 * 5. Exit
 * Enter your choice: 1
 * Enter task description: Implement Task Class
 * Task #1 added: Implement Task Class
 * 
 * Task Processor Menu:
 * 1. Add New Task
 * 2. View Pending Tasks
 * 3. View Completed Tasks
 * 4. Process Next Task
 * 5. Exit
 * Enter your choice: 2
 * Pending Tasks:
 * [#1] Implement Task Class
 * 
 * Task Processor Menu:
 * 1. Add New Task
 * 2. View Pending Tasks
 * 3. View Completed Tasks
 * 4. Process Next Task
 * 5. Exit
 * Enter your choice: 4
 * Processed Task #1: Implement Task Class
 * 
 * Task Processor Menu:
 * 1. Add New Task
 * 2. View Pending Tasks
 * 3. View Completed Tasks
 * 4. Process Next Task
 * 5. Exit
 * Enter your choice: 3
 * Completed Tasks:
 * [#1] Implement Task Class
 * 
 * Task Processor Menu:
 * 1. Add New Task
 * 2. View Pending Tasks
 * 3. View Completed Tasks
 * 4. Process Next Task
 * 5. Exit
 * Enter your choice: 4
 * Error: No tasks currently pending.
 * 
 * Task Processor Menu:
 * 1. Add New Task
 * 2. View Pending Tasks
 * 3. View Completed Tasks
 * 4. Process Next Task
 * 5. Exit
 * Enter your choice: 9
 * Error: Invalid choice. Please enter a number between 1 and 5.
 * 
 * Task Processor Menu:
 * ... (continues until Exit)
 * ```
 * 
 * Your code should be contained within a single file for this exam.
 * 
 * **Evaluation:**
 * 
 * Your solution will be evaluated based on:
 * *   Correct implementation and usage of all required Java components (`Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.err`, `System.out`, `try-catch`).
 * *   Correct functionality according to the requirements (adding, viewing, processing tasks).
 * *   Robustness in handling user input and error conditions.
 * *   Adherence to best practices (encapsulation, naming, comments, clean code).
 * *   Proper use of `System.out` vs. `System.err`.
 *
 * EXPLANATION:
 * This solution implements a simple Task Management System demonstrating the required Java concepts.
 * 
 * 1.  **`Task` Class:**
 *     *   Encapsulates task data (`id`, `description`) with private fields.
 *     *   Uses a `static` variable `nextId` to automatically generate unique IDs for each new `Task` object, demonstrating class-level state.
 *     *   Provides public getter methods (`getId`, `getDescription`).
 *     *   Overrides `toString()` for convenient printing of task details.
 * 
 * 2.  **Data Structures:**
 *     *   `pendingTasks`: Declared as `Queue<Task>` and instantiated as `LinkedList<Task>`. This fulfills the requirement to use the `Queue` interface and is suitable for managing tasks in a FIFO (First-In, First-Out) manner, where tasks are processed in the order they are added. `offer()` is used to add tasks and `poll()` is used to retrieve and remove the head task.
 *     *   `completedTasks`: Declared as `List<Task>` and instantiated as `ArrayList<Task>`. This fulfills the requirement to use the `List` interface and `ArrayList` implementation. `ArrayList` is suitable for storing completed tasks as a dynamic list, allowing easy iteration and storage of processed items. `add()` is used to add completed tasks.
 * 
 * 3.  **User Interaction and Control Flow:**
 *     *   `Scanner`: Used within a `try-with-resources` block in the `main` method. This ensures the `Scanner` resource is automatically closed when the block is exited, preventing resource leaks. It reads user input from `System.in`. Reading the entire line (`scanner.nextLine()`) and then parsing is a safer approach for handling mixed input types compared to using `nextInt()`.
 *     *   `switch`: The main program loop uses a `switch` statement based on the parsed user input (`choice`) to direct the program flow to the selected action (Add, View Pending, View Completed, Process, Exit). The `default` case handles invalid integer inputs.
 * 
 * 4.  **Functionality Implementation:**
 *     *   Each `case` in the `switch` statement implements the corresponding menu option logic, interacting with the `pendingTasks` queue and `completedTasks` list.
 *     *   **Add:** Reads description, validates it, creates a `Task`, and adds it to `pendingTasks` using `offer()`.
 *     *   **View Pending:** Iterates through `pendingTasks` using a for-each loop (which does not remove elements from the queue) and prints each task. Checks `isEmpty()` first.
 *     *   **View Completed:** Iterates through `completedTasks` using a for-each loop and prints each task. Checks `isEmpty()` first.
 *     *   **Process:** Uses `pendingTasks.poll()` to get and remove the next task. If `poll()` returns `null` (queue is empty), it indicates an error. Otherwise, the retrieved task is added to `completedTasks`.
 *     *   **Exit:** Sets the `running` flag to `false`, terminating the `while` loop.
 * 
 * 5.  **Error Handling and Validation:**
 *     *   Input Validation: The "Add New Task" case checks if the trimmed description is empty using `isEmpty()`. Invalid descriptions result in an error message printed to `System.err`.
 *     *   Invalid Menu Choice: The `default` case of the `switch` handles inputs that are not 1-5 (including non-integer inputs caught by the `NumberFormatException` handler before the switch). An error message is printed to `System.err`.
 *     *   Processing Empty Queue: The "Process Next Task" case checks if `pendingTasks.poll()` returns `null`. If so, an error message is printed to `System.err`.
 *     *   `System.err` vs. `System.out`: `System.err` is used exclusively for error output, while `System.out` is used for all normal program output (menu, prompts, success messages, task lists).
 *     *   Class-wide `try-catch`: The entire `while` loop containing the main program logic is wrapped in a `try-catch (Exception e)` block. This provides a safety net to catch any unexpected runtime exceptions that might occur anywhere within the loop, preventing the program from crashing abruptly and printing a generic error message to `System.err`.
 * 
 * 6.  **Best Practices:**
 *     *   Encapsulation is followed in the `Task` class.
 *     *   Variable names (`pendingTasks`, `completedTasks`, `description`, `choice`, `running`, `processedTask`) and method names (`printMenu`, `getId`, `getDescription`) are meaningful.
 *     *   Basic Javadoc comments are provided for the classes and key methods.
 *     *   The code is structured logically with a separate `Task` class and the main logic in the `TaskProcessor` class's `main` method, including a helper method `printMenu`.
 * 
 * This solution effectively combines the required Java components in a practical scenario, demonstrating essential programming skills like data structure usage, input handling, control flow, and error management.
 */

import java.util.Queue;
import java.util.LinkedList;
import java.util.List;
import java.util.ArrayList;
import java.util.Scanner;

/**
 * Represents a single task in the Task Management System.
 */
class Task {
    private static int nextId = 1; // Static counter for unique task IDs
    private int id;
    private String description;

    /**
     * Constructs a new Task with an auto-generated ID and a description.
     * @param description The description of the task.
     */
    public Task(String description) {
        this.id = nextId++;
        this.description = description;
    }

    /**
     * Gets the unique ID of the task.
     * @return The task ID.
     */
    public int getId() {
        return id;
    }

    /**
     * Gets the description of the task.
     * @return The task description.
     */
    public String getDescription() {
        return description;
    }

    /**
     * Provides a string representation of the task.
     * @return A formatted string for the task.
     */
    @Override
    public String toString() {
        return "[#" + id + "] " + description;
    }
}

/**
 * Simple command-line Task Management System.
 * Manages pending and completed tasks using Queue and List.
 */
public class TaskProcessor {

    public static void main(String[] args) {
        // Use LinkedList as an implementation of Queue for pending tasks
        Queue<Task> pendingTasks = new LinkedList<>();
        // Use ArrayList as an implementation of List for completed tasks
        List<Task> completedTasks = new ArrayList<>();

        boolean running = true;

        // Class-wide try-catch block to handle any unexpected exceptions during execution
        try (Scanner scanner = new Scanner(System.in)) { // Use try-with-resources for Scanner
            while (running) {
                printMenu();
                System.out.print("Enter your choice: ");

                // Read the whole line to handle various inputs gracefully
                String choiceStr = scanner.nextLine();
                int choice = -1; // Default invalid choice

                try {
                    choice = Integer.parseInt(choiceStr);
                } catch (NumberFormatException e) {
                    // If parsing fails, choice remains -1, handled by default case
                }

                // Use switch statement for menu navigation
                switch (choice) {
                    case 1: // Add New Task
                        System.out.print("Enter task description: ");
                        String description = scanner.nextLine().trim(); // Read description and trim whitespace
                        if (description.isEmpty()) {
                            System.err.println("Error: Task description cannot be empty.");
                        } else {
                            Task newTask = new Task(description);
                            pendingTasks.offer(newTask); // offer() is a Queue method to add
                            System.out.println("Task " + newTask + " added.");
                        }
                        break;

                    case 2: // View Pending Tasks
                        System.out.println("\n--- Pending Tasks ---");
                        if (pendingTasks.isEmpty()) {
                            System.out.println("No tasks currently pending.");
                        } else {
                            // Iterate through the queue without removing elements
                            int count = 0;
                            for (Task task : pendingTasks) {
                                System.out.println(task);
                                count++;
                            }
                            System.out.println("Total pending: " + count);
                        }
                        System.out.println("---------------------\n");
                        break;

                    case 3: // View Completed Tasks
                        System.out.println("\n--- Completed Tasks ---");
                        if (completedTasks.isEmpty()) {
                            System.out.println("No tasks have been completed yet.");
                        } else {
                            // Iterate through the list
                            for (Task task : completedTasks) {
                                System.out.println(task);
                            }
                            System.out.println("Total completed: " + completedTasks.size());
                        }
                        System.out.println("-----------------------\n");
                        break;

                    case 4: // Process Next Task
                        Task processedTask = pendingTasks.poll(); // poll() retrieves and removes the head of the queue
                        if (processedTask == null) {
                            System.err.println("Error: No tasks currently pending to process.");
                        } else {
                            completedTasks.add(processedTask); // Add to the completed list
                            System.out.println("Processed Task " + processedTask + ".");
                        }
                        break;

                    case 5: // Exit
                        System.out.println("Exiting Task Processor. Goodbye!");
                        running = false;
                        break;

                    default: // Invalid choice
                        System.err.println("Error: Invalid choice. Please enter a number between 1 and 5.");
                        break;
                }
                System.out.println(); // Add a newline for better readability between menu loops
            }
        } catch (Exception e) {
            // Catch any unexpected runtime exceptions not handled elsewhere
            System.err.println("An unexpected error occurred: " + e.getMessage());
            // e.printStackTrace(); // Uncomment for detailed debugging in case of unexpected issues
        }
    }

    /**
     * Prints the main menu options to the console.
     */
    private static void printMenu() {
        System.out.println("Task Processor Menu:");
        System.out.println("1. Add New Task");
        System.out.println("2. View Pending Tasks");
        System.out.println("3. View Completed Tasks");
        System.out.println("4. Process Next Task");
        System.out.println("5. Exit");
    }
}
