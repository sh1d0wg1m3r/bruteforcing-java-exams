/*
 * Exam Question #975
 * Generated on: 2025-05-12 17:07:19
 * Generated by: Account 1
 * 
 * QUESTION:
 * ## Advanced Java Programming Exam - E-commerce Order Processing System
 * 
 * **Task:** Design and implement a simplified E-commerce system that manages a product catalog, handles incoming customer orders, processes them in the order they were received, and allows viewing processed orders.
 * 
 * Your solution must be a single Java program file and demonstrate advanced understanding by incorporating specific Java features and best practices.
 * 
 * **Requirements:**
 * 
 * 1.  **Product Catalog:** Maintain a list of available products. Each product should have a unique ID (integer), a name (String), and a price (double).
 * 2.  **Order Handling:**
 *     *   Customers place orders by specifying one or more product IDs.
 *     *   Incoming orders are added to a waiting list (queue) for processing.
 *     *   Orders are processed one by one from the front of the queue.
 *     *   Processed orders are moved to a separate list of completed orders.
 * 3.  **User Interface:** Provide a simple text-based menu for the user (simulating system administrator actions) with the following options:
 *     *   Display Product Catalog
 *     *   Place New Order
 *     *   Process Next Order
 *     *   View Processed Orders
 *     *   Exit
 * 4.  **Implementation Constraints:** Your solution *must* use the following Java components:
 *     *   `java.util.Queue` for managing pending orders.
 *     *   `java.util.ArrayList` for storing the product catalog and processed orders.
 *     *   `java.util.List` interface (use `List` as the type for variables holding `ArrayList` instances where appropriate).
 *     *   `java.util.Scanner` for reading user input from the console.
 *     *   `switch` statement for controlling the main menu flow.
 *     *   `System.err` for printing error messages (e.g., invalid input, order processing failures).
 *     *   `System.out` for printing normal output (menu, catalog, order details, success messages).
 *     *   Class-wide exception handling using `try-catch` blocks to gracefully handle unexpected issues during program execution, especially around input processing.
 * 5.  **Best Practices:**
 *     *   Implement proper encapsulation using private fields and public methods/getters.
 *     *   Use meaningful variable and method names.
 *     *   Include appropriate comments and Javadoc-style documentation for classes and methods.
 *     *   Implement input validation (e.g., ensuring product IDs exist, handling non-numeric input for menu choices).
 *     *   Handle potential errors gracefully (e.g., attempting to process an order when the queue is empty).
 *     *   Structure your code logically with separate classes for `Product` and `Order`, and a main class to manage the system operations.
 * 
 * **Scenario Flow:**
 * 
 * 1.  The system starts and populates a small product catalog.
 * 2.  The main menu is displayed.
 * 3.  The user selects an option.
 * 4.  Based on the selection:
 *     *   **Display Catalog:** Prints the list of products.
 *     *   **Place Order:** Prompts the user for product IDs to include in the order (allow adding multiple items until a sentinel value like 0 is entered). Validates product IDs. Creates an `Order` object and adds it to the pending orders queue.
 *     *   **Process Next Order:** Takes the oldest order from the queue, calculates its total price (by looking up product prices in the catalog), prints processing details, and moves it to the processed orders list. Handles the case where the queue is empty.
 *     *   **View Processed Orders:** Prints details of all completed orders.
 *     *   **Exit:** Terminates the program.
 * 5.  The menu redisplays until the user chooses to exit.
 * 
 * **Expected Output:**
 * 
 * The output should be clear and user-friendly, using `System.out` for standard information (menu, lists, success messages) and `System.err` for errors (invalid input, non-existent product ID, etc.).
 * 
 * *   Menu display upon startup and after each action.
 * *   Formatted product catalog display.
 * *   Prompts for placing orders.
 * *   Confirmation messages upon successful order placement and processing.
 * *   Error messages for invalid input or operations that cannot be performed.
 * *   Formatted processed orders display.
 * 
 * **Evaluation:** Your solution will be evaluated based on correctness, adherence to all requirements (especially the use of the specified Java components), code quality, error handling robustness, and clarity.
 *
 * EXPLANATION:
 * The provided solution implements a basic E-commerce order processing system demonstrating the required Java concepts.
 * 
 * 1.  **Structure:** The code is organized into three classes: `Product`, `Order`, and `ECommerceSystem`. This promotes modularity and encapsulation.
 *     *   `Product`: Simple class to hold product data. Uses private fields and public getters.
 *     *   `Order`: Holds order information, including a list of product IDs and a calculated total amount. It also uses a static counter to generate unique order IDs. Uses private fields and public getters/setters.
 *     *   `ECommerceSystem`: The main class containing the core logic. It holds the product catalog, pending orders queue, and processed orders list. It also manages user interaction via the `Scanner` and the main menu loop.
 * 
 * 2.  **Required Java Components Usage:**
 *     *   `java.util.Queue`: The `pendingOrders` variable is declared as `Queue<Order>` and initialized with a `LinkedList`. The `LinkedList` class implements the `Queue` interface, providing FIFO (First-In, First-Out) behavior suitable for processing orders in the order they are placed. `offer()` is used to add orders to the queue, and `poll()` is used to retrieve and remove the next order for processing.
 *     *   `java.util.ArrayList`: Used to store the `productCatalog` and the `processedOrders`. `ArrayList` is suitable here as these collections are primarily accessed by iterating or retrieving by index (though direct index access isn't heavily used in this simple example, it's a standard list use case), and their size can grow dynamically.
 *     *   `java.util.List`: The variables `productCatalog`, `processedOrders`, and `productIds` within the `Order` class are declared using the `List` interface type (`List<Product>`, `List<Order>`, `List<Integer>`). This demonstrates coding to an interface, which is a best practice allowing for potential flexibility in changing the underlying implementation (e.g., to `LinkedList` or `Vector`) with minimal code changes elsewhere.
 *     *   `java.util.Scanner`: An instance of `Scanner` is used in the `ECommerceSystem` class to read user input from `System.in` for menu choices and product IDs. `scanner.nextInt()` is used for numbers, and `scanner.nextLine()` is used to consume the remaining newline character after reading a number, preventing input issues in subsequent reads.
 *     *   `switch` statement: The `run()` method uses a `switch` statement based on the user's menu choice (`choice`) to direct the program flow to the appropriate method (`displayCatalog`, `placeOrder`, etc.).
 *     *   `System.err`: Used specifically for printing error messages, such as invalid menu choices, non-existent product IDs entered during order placement, invalid input types caught by `InputMismatchException`, and messages within the main `catch` block. This separates error output from normal program output (`System.out`).
 *     *   `System.out`: Used for all normal program output, including the menu, product catalog listing, prompts for input, confirmation messages, and processed order details.
 *     *   Class-wide exception handling (`try-catch`): The main `run()` method's `while` loop, which contains the core program execution logic, is wrapped in a `try-catch(Exception e)` block. This provides a top-level handler for any unexpected runtime exceptions that might occur within the main program loop, preventing the program from crashing abruptly and printing an error message to `System.err` before exiting or attempting to continue. More specific `try-catch` blocks are also used within `run()` (for `InputMismatchException` on menu input) and `placeOrder()` (for `InputMismatchException` on product ID input) for targeted error handling and recovery. A `finally` block ensures the `Scanner` is closed.
 * 
 * 3.  **Best Practices & Error Handling:**
 *     *   **Encapsulation:** Fields in `Product` and `Order` are `private`, accessed via `public` getters (and a setter for `totalAmount` in `Order`).
 *     *   **Naming:** Variable and method names are descriptive (e.g., `productCatalog`, `pendingOrders`, `placeOrder`, `findProductById`).
 *     *   **Comments/Documentation:** Basic comments explain the purpose of classes, methods, and key code sections. Javadoc-style comments are used for class definitions.
 *     *   **Input Validation:**
 *         *   When placing an order, the `placeOrder` method checks if entered product IDs exist in the `productCatalog` using `findProductById`.
 *         *   `try-catch(InputMismatchException)` is used when reading integer input (menu choice, product ID) to catch cases where the user enters non-numeric text, preventing program crashes and prompting the user to retry.
 *     *   **Error Handling:**
 *         *   `System.err` is used for error messages.
 *         *   The `processNextOrder` method explicitly checks if the `pendingOrders` queue is empty (`poll()` returns `null`) before attempting to process, printing a user-friendly message.
 *         *   The top-level `try-catch` in `run()` provides a fallback for unforeseen errors.
 *     *   **Clean Code Structure:** The logic is divided into smaller, focused methods (`displayCatalog`, `placeOrder`, etc.) within the `ECommerceSystem` class, making the code easier to read, understand, and maintain. The `run` method acts as the controller, coordinating calls to these methods based on user input.
 * 
 * 4.  **Scenario Implementation:**
 *     *   The `populateCatalog` method initializes the system with some sample products.
 *     *   The `placeOrder` method guides the user to add product IDs, validates them, and creates an `Order` object added to the `pendingOrders` queue using `offer()`.
 *     *   The `processNextOrder` method retrieves the next order using `poll()`, iterates through its product IDs to calculate the total amount by looking up products in the catalog, updates the order object, and adds it to the `processedOrders` list.
 *     *   `displayCatalog` and `displayProcessedOrders` iterate through their respective lists (`productCatalog`, `processedOrders`) and print the details using the objects' `toString()` methods.
 *     *   The main loop in `run()` displays the menu and uses the `switch` statement to handle user selections until the 'Exit' option is chosen.
 * 
 * This solution effectively integrates all the required Java components within a practical scenario, demonstrating proper object-oriented design, input handling, error management, and the use of standard Java collections and control flow structures.
 */

import java.util.ArrayList;
import java.util.LinkedList; // LinkedList implements Queue and List
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.InputMismatchException; // Specific exception for Scanner

// Represents a product in the catalog
class Product {
    private int id;
    private String name;
    private double price;

    public Product(int id, String name, double price) {
        this.id = id;
        this.name = name;
        this.price = price;
    }

    public int getId() {
        return id;
    }

    public String getName() {
        return name;
    }

    public double getPrice() {
        return price;
    }

    @Override
    public String toString() {
        return String.format("ID: %d, Name: %s, Price: %.2f", id, name, price);
    }
}

// Represents a customer order
class Order {
    private static int orderCounter = 1; // To generate unique order IDs
    private int orderId;
    private List<Integer> productIds; // List of product IDs in the order
    private double totalAmount; // Calculated after processing

    public Order(List<Integer> productIds) {
        this.orderId = orderCounter++;
        this.productIds = new ArrayList<>(productIds); // Create a copy
        this.totalAmount = 0.0; // Initialize, calculated later
    }

    public int getOrderId() {
        return orderId;
    }

    public List<Integer> getProductIds() {
        return productIds;
    }

    public double getTotalAmount() {
        return totalAmount;
    }

    public void setTotalAmount(double totalAmount) {
        this.totalAmount = totalAmount;
    }

    @Override
    public String toString() {
        // Simple representation before processing
        if (totalAmount == 0.0) {
             return String.format("Order ID: %d, Items (Product IDs): %s, Status: Pending",
                    orderId, productIds.toString());
        } else {
            // Representation after processing
            return String.format("Order ID: %d, Items (Product IDs): %s, Total: %.2f, Status: Processed",
                    orderId, productIds.toString(), totalAmount);
        }
    }
}

// Main system class managing catalog, orders, and user interaction
public class ECommerceSystem {

    // Use List interface type for collections where implementation detail (ArrayList/LinkedList)
    // is less important for the variable's purpose.
    private List<Product> productCatalog;
    private Queue<Order> pendingOrders; // Use Queue interface for FIFO behavior
    private List<Order> processedOrders; // Use List interface for collection of processed items

    private Scanner scanner;

    public ECommerceSystem() {
        // Use ArrayList for catalog and processed orders as they are list-like collections
        productCatalog = new ArrayList<>();
        // Use LinkedList as it implements both Queue and List, suitable for a queue implementation
        pendingOrders = new LinkedList<>();
        processedOrders = new ArrayList<>();
        scanner = new Scanner(System.in);

        // Populate initial catalog
        populateCatalog();
    }

    // Populates the product catalog with some sample data
    private void populateCatalog() {
        productCatalog.add(new Product(101, "Laptop", 1200.00));
        productCatalog.add(new Product(102, "Keyboard", 75.00));
        productCatalog.add(new Product(103, "Mouse", 25.00));
        productCatalog.add(new Product(104, "Monitor", 300.00));
        productCatalog.add(new Product(105, "Webcam", 50.00));
        System.out.println("Product catalog populated.");
    }

    // Displays the main menu options
    private void displayMenu() {
        System.out.println("\n--- E-commerce System Menu ---");
        System.out.println("1. Display Product Catalog");
        System.out.println("2. Place New Order");
        System.out.println("3. Process Next Order");
        System.out.println("4. View Processed Orders");
        System.out.println("5. Exit");
        System.out.print("Enter your choice: ");
    }

    // Finds a product by its ID
    private Product findProductById(int id) {
        for (Product product : productCatalog) {
            if (product.getId() == id) {
                return product;
            }
        }
        return null; // Product not found
    }

    // Handles displaying the product catalog
    private void displayCatalog() {
        System.out.println("\n--- Product Catalog ---");
        if (productCatalog.isEmpty()) {
            System.out.println("Catalog is empty.");
        } else {
            for (Product product : productCatalog) {
                System.out.println(product);
            }
        }
    }

    // Handles placing a new order
    private void placeOrder() {
        List<Integer> itemsInOrder = new ArrayList<>();
        System.out.println("\n--- Place New Order ---");
        System.out.println("Enter product IDs to add to order (enter 0 to finish):");

        while (true) {
            System.out.print("Enter Product ID: ");
            try {
                int productId = scanner.nextInt();
                // Consume the newline character left by nextInt()
                scanner.nextLine();

                if (productId == 0) {
                    break; // User finished adding items
                }

                Product product = findProductById(productId);
                if (product != null) {
                    itemsInOrder.add(productId);
                    System.out.println("Product '" + product.getName() + "' added to order.");
                } else {
                    System.err.println("Error: Product with ID " + productId + " not found in catalog.");
                }
            } catch (InputMismatchException e) {
                System.err.println("Error: Invalid input. Please enter a number.");
                scanner.nextLine(); // Consume the invalid input to prevent infinite loop
            } catch (Exception e) {
                System.err.println("An unexpected error occurred while reading product ID: " + e.getMessage());
                // Consider if more specific handling or exiting is needed for critical errors
                scanner.nextLine(); // Attempt to consume line even on unexpected error
            }
        }

        if (itemsInOrder.isEmpty()) {
            System.out.println("No items added to order. Order cancelled.");
        } else {
            Order newOrder = new Order(itemsInOrder);
            pendingOrders.offer(newOrder); // Add order to the queue
            System.out.println("Order " + newOrder.getOrderId() + " placed successfully and added to pending queue.");
        }
    }

    // Handles processing the next order in the queue
    private void processNextOrder() {
        System.out.println("\n--- Process Next Order ---");
        Order orderToProcess = pendingOrders.poll(); // Retrieve and remove the head of the queue

        if (orderToProcess == null) {
            System.out.println("No pending orders to process.");
        } else {
            System.out.println("Processing Order ID: " + orderToProcess.getOrderId() + "...");
            double orderTotal = 0.0;
            boolean processingSuccessful = true;

            for (int productId : orderToProcess.getProductIds()) {
                Product product = findProductById(productId);
                if (product != null) {
                    orderTotal += product.getPrice();
                } else {
                    // This case ideally shouldn't happen if validation was perfect during placement,
                    // but good to handle defensively.
                    System.err.println("Warning: Product ID " + productId + " not found in catalog during processing.");
                    // Decide how to handle: skip item, fail order? Let's skip for simplicity here.
                    // processingSuccessful = false; // Uncomment to fail the entire order
                    // break; // Uncomment to stop processing on first missing product
                }
            }

            if (processingSuccessful) {
                orderToProcess.setTotalAmount(orderTotal);
                processedOrders.add(orderToProcess); // Add to processed list
                System.out.println("Order " + orderToProcess.getOrderId() + " processed successfully.");
                System.out.println("Order Details: " + orderToProcess);
            } else {
                 System.err.println("Order " + orderToProcess.getOrderId() + " failed processing due to errors.");
                 // Optionally, re-add to a failed queue or log more details
            }
        }
    }

    // Handles displaying processed orders
    private void displayProcessedOrders() {
        System.out.println("\n--- Processed Orders ---");
        if (processedOrders.isEmpty()) {
            System.out.println("No orders have been processed yet.");
        } else {
            for (Order order : processedOrders) {
                System.out.println(order);
            }
        }
    }

    // The main method to run the system
    public void run() {
         // Use a try-catch block to wrap the main operational logic
         // for "class-wide" exception handling of unexpected errors.
        try {
            int choice = -1;
            while (choice != 5) {
                displayMenu();

                try {
                    choice = scanner.nextInt();
                     // Consume the newline character left by nextInt()
                    scanner.nextLine();

                    // Use a switch statement for menu navigation
                    switch (choice) {
                        case 1:
                            displayCatalog();
                            break;
                        case 2:
                            placeOrder();
                            break;
                        case 3:
                            processNextOrder();
                            break;
                        case 4:
                            displayProcessedOrders();
                            break;
                        case 5:
                            System.out.println("Exiting E-commerce System. Goodbye!");
                            break;
                        default:
                            // Use System.err for invalid menu choices
                            System.err.println("Invalid choice. Please enter a number between 1 and 5.");
                            break;
                    }
                } catch (InputMismatchException e) {
                     // Catch non-integer input for menu choice
                    System.err.println("Error: Invalid input. Please enter a number.");
                    scanner.nextLine(); // Consume the invalid input
                    choice = -1; // Reset choice to continue the loop
                }
                // Other specific exceptions could be caught here if needed
            }
        } catch (Exception e) {
            // Catch any other unexpected exceptions during the main loop execution
            System.err.println("An unexpected system error occurred: " + e.getMessage());
            e.printStackTrace(System.err); // Print stack trace to standard error
        } finally {
             // Ensure the scanner is closed regardless of how the program exits (normally or by exception)
            if (scanner != null) {
                scanner.close();
            }
        }
    }

    // Entry point of the program
    public static void main(String[] args) {
        ECommerceSystem system = new ECommerceSystem();
        system.run();
    }
}
