/*
 * Exam Question #444
 * Generated on: 2025-05-11 23:11:57
 * Generated by: Account 2
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Print Job Management System
 * 
 * **Scenario:**
 * 
 * You are tasked with developing a simple simulation of a print server's job management system. The system should be able to accept new print jobs, hold them in a waiting queue, process them one by one, and maintain a history of completed jobs.
 * 
 * **Requirements:**
 * 
 * 1.  **Data Structures:**
 *     *   Use a `java.util.Queue` to manage the jobs waiting to be processed (First-In, First-Out).
 *     *   Use a `java.util.ArrayList` to store the history of completed jobs.
 *     *   Declare the history list using the `java.util.List` interface (`List<PrintJob> completedJobs = new ArrayList<>();`).
 * 
 * 2.  **Classes:**
 *     *   Create an `enum` called `PrintJobStatus` with states: `WAITING`, `PROCESSING`, `COMPLETED`.
 *     *   Create a class `PrintJob` representing a print job. It should have:
 *         *   Private fields: `id` (unique integer), `fileName` (String), `pages` (int), `status` (`PrintJobStatus`).
 *         *   A constructor to initialize `fileName` and `pages`. The `id` should be automatically generated (e.g., using a static counter), and the initial `status` should be `WAITING`.
 *         *   Public getter methods for all fields.
 *         *   A public method `setStatus(PrintJobStatus status)` to change the job's status.
 *         *   Override the `toString()` method to provide a clear representation of the job.
 *     *   Create a class `PrintJobManager` to manage the print jobs. It should have:
 *         *   Private fields: A `Queue<PrintJob>` for waiting jobs and a `List<PrintJob>` (using `ArrayList`) for completed jobs.
 *         *   A public method `submitJob(String fileName, int pages)`: Creates a new `PrintJob` and adds it to the waiting queue. Validate that `pages` is positive; if not, print an error to `System.err` and do not add the job.
 *         *   A public method `processNextJob()`: Removes the job at the front of the waiting queue, changes its status to `COMPLETED`, and moves it to the completed jobs list. If the queue is empty, print an error message to `System.err`.
 *         *   Public methods `getWaitingJobs()` and `getCompletedJobs()` to access the respective lists (can return the lists directly for simplicity in this exam context).
 *     *   Create a `Main` class with the `main` method. This class will handle user interaction.
 * 
 * 3.  **User Interface (in `Main` class):**
 *     *   Use `java.util.Scanner` to read user input from the console.
 *     *   Implement a command-line menu with the following options:
 *         *   `S` or `submit`: Submit a new print job (prompts for file name and pages).
 *         *   `P` or `process`: Process the next job in the queue.
 *         *   `Q` or `view queue`: Display the jobs currently in the waiting queue.
 *         *   `H` or `view history`: Display the completed jobs history.
 *         *   `E` or `exit`: Terminate the program.
 *     *   Use a `switch` statement to handle the different user commands. The command input should be case-insensitive.
 *     *   Use `System.out` for menu display, prompts, and printing job details.
 *     *   Use `System.err` for all error messages (e.g., invalid command, invalid page count, queue empty).
 * 
 * 4.  **Error Handling:**
 *     *   Implement input validation as described (`pages > 0`).
 *     *   Handle the case where `processNextJob()` is called on an empty queue.
 *     *   Implement **class-wide exception handling** by wrapping the main command processing loop in the `main` method with a `try-catch(Exception e)` block to catch and report any unexpected runtime errors using `System.err`.
 * 
 * 5.  **Best Practices:**
 *     *   Use proper encapsulation (private fields, public methods).
 *     *   Use meaningful variable and method names.
 *     *   Include basic comments where necessary to explain logic.
 *     *   Ensure clean code structure.
 * 
 * **Expected Output:**
 * 
 * Your program should allow a user to interactively manage print jobs. The output should clearly show the menu, prompts for input, successful operations (job submitted, job processed, queue contents, history contents), and error messages when invalid actions are attempted.
 * 
 * For example:
 * 
 * ```
 * --- Print Job Manager ---
 * S: Submit Job
 * P: Process Next Job
 * Q: View Queue
 * H: View History
 * E: Exit
 * Enter command: S
 * Enter file name: document.txt
 * Enter number of pages: 15
 * Job 1 [document.txt, 15 pages, WAITING] submitted.
 * Enter command: S
 * Enter file name: image.jpg
 * Enter number of pages: -5
 * Error: Number of pages must be positive. Job not submitted.
 * Enter command: Q
 * Waiting Queue:
 * Job 1 [document.txt, 15 pages, WAITING]
 * Enter command: P
 * Processing job: Job 1 [document.txt, 15 pages, WAITING]
 * Job 1 [document.txt, 15 pages, COMPLETED] moved to history.
 * Enter command: Q
 * Waiting Queue is empty.
 * Enter command: P
 * Error: Cannot process job. Waiting queue is empty.
 * Enter command: H
 * Completed Jobs History:
 * Job 1 [document.txt, 15 pages, COMPLETED]
 * Enter command: E
 * Exiting Print Job Manager.
 * ```
 * 
 * Your implementation should match the requirements and demonstrate the correct usage of all specified Java components.
 *
 * EXPLANATION:
 * This solution implements a simple Print Job Management System as requested, demonstrating the required Java concepts and best practices.
 * 
 * 1.  **`PrintJobStatus` Enum:** Defines the possible states a print job can be in (`WAITING`, `PROCESSING`, `COMPLETED`), improving code readability and maintainability compared to using raw strings or integers for status.
 * 2.  **`PrintJob` Class:** Encapsulates the data for a single print job (ID, file name, pages, status).
 *     *   It uses a `static int nextId` to automatically generate unique IDs for each new job instance, ensuring every job has a distinct identifier.
 *     *   Private fields enforce encapsulation.
 *     *   Public getters provide controlled access to the job's data.
 *     *   A `setStatus` method allows controlled state changes.
 *     *   The `toString()` method provides a user-friendly representation for printing.
 * 3.  **`PrintJobManager` Class:** This is the core logic class, managing the collections of jobs.
 *     *   It declares `waitingJobs` as a `Queue<PrintJob>`, using `LinkedList` as the concrete implementation, which is suitable for queue operations (add to end, remove from front).
 *     *   It declares `completedJobs` as a `List<PrintJob>` and initializes it with an `ArrayList`. This demonstrates coding to the `List` interface while using `ArrayList` for storage.
 *     *   `submitJob`: Takes file name and pages, performs basic input validation (`pages > 0`), creates a `PrintJob` object, and adds it to the `waitingJobs` queue using `offer()`. Uses `System.err` for validation errors and `System.out` for success messages.
 *     *   `processNextJob`: Checks if the `waitingJobs` queue is empty using `isEmpty()`. If not empty, it removes the head of the queue using `poll()`, updates the job's status to `COMPLETED`, and adds it to the `completedJobs` list. Uses `System.err` for the empty queue error and `System.out` for processing messages.
 *     *   `getWaitingJobs` and `getCompletedJobs`: Provide access to the job lists for display in the `Main` class. `getWaitingJobs` returns a new `ArrayList` copy of the queue elements to prevent external code from modifying the queue directly, adhering better to encapsulation (though returning the internal list was allowed for simplicity in this context). `getCompletedJobs` returns the internal `ArrayList`.
 * 4.  **`Main` Class:** Handles the application entry point and user interaction loop.
 *     *   A `Scanner` is used to read input from `System.in`.
 *     *   The main application logic is within a `while(true)` loop that continues until the user chooses to exit.
 *     *   A `switch` statement is used to process the user's command, handling case-insensitivity by converting input to lowercase.
 *     *   Each case calls the appropriate method on the `PrintJobManager` instance.
 *     *   Input validation for pages is done within the 'submit' case, including handling `NumberFormatException` if the user enters non-numeric input for pages. `System.err` is used for these specific input errors.
 *     *   `System.out` is used for the menu, prompts, and displaying the contents of the waiting queue and completed history.
 *     *   **Class-wide Exception Handling:** The entire command processing loop is wrapped in a `try-catch(Exception e)` block. This catches any unexpected runtime exceptions that might occur within the loop, prints an error message and stack trace to `System.err`, and allows the program to terminate gracefully rather than crashing abruptly. A `finally` block ensures the `Scanner` is closed.
 *     *   The `printMenu` method is a helper to display the available commands.
 * 5.  **Best Practices:**
 *     *   Encapsulation is maintained through private fields and public methods.
 *     *   Variable and method names are descriptive (e.g., `waitingJobs`, `processNextJob`, `fileName`, `pages`).
 *     *   Comments explain the purpose of classes, methods, and key logic sections.
 *     *   Input validation for pages is implemented.
 *     *   Error handling is present for specific scenarios (empty queue, invalid page count, invalid command) using `System.err`, and a general `try-catch` handles unexpected errors.
 *     *   The code is structured into logical classes, separating concerns (Job data, Job management logic, User interface).
 * 
 * This solution effectively integrates all required components to build a functional, albeit simple, system that demonstrates key Java programming concepts suitable for an advanced exam.
 */

import java.util.LinkedList;
import java.util.Queue;
import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;

// Enum for job status
enum PrintJobStatus {
    WAITING,
    PROCESSING, // Although processing is simulated instantly, having the state is good practice
    COMPLETED
}

// Represents a single print job
class PrintJob {
    private static int nextId = 1; // Static counter for unique IDs

    private int id;
    private String fileName;
    private int pages;
    private PrintJobStatus status;

    /**
     * Constructs a new PrintJob.
     * @param fileName The name of the file to print.
     * @param pages The number of pages in the job.
     */
    public PrintJob(String fileName, int pages) {
        this.id = nextId++; // Assign unique ID and increment counter
        this.fileName = fileName;
        this.pages = pages;
        this.status = PrintJobStatus.WAITING; // Initial status is WAITING
    }

    // --- Getters ---
    public int getId() {
        return id;
    }

    public String getFileName() {
        return fileName;
    }

    public int getPages() {
        return pages;
    }

    public PrintJobStatus getStatus() {
        return status;
    }

    // --- Setter ---
    public void setStatus(PrintJobStatus status) {
        this.status = status;
    }

    /**
     * Provides a string representation of the PrintJob.
     * @return A formatted string describing the job.
     */
    @Override
    public String toString() {
        return "Job " + id + " [" + fileName + ", " + pages + " pages, " + status + "]";
    }
}

// Manages the print job queue and history
class PrintJobManager {
    // Use Queue for waiting jobs (FIFO)
    private Queue<PrintJob> waitingJobs;
    // Use List (implemented by ArrayList) for completed jobs history
    private List<PrintJob> completedJobs;

    /**
     * Constructs a PrintJobManager.
     */
    public PrintJobManager() {
        // LinkedList is a common implementation of Queue
        this.waitingJobs = new LinkedList<>();
        this.completedJobs = new ArrayList<>();
    }

    /**
     * Submits a new print job to the waiting queue.
     * @param fileName The name of the file.
     * @param pages The number of pages.
     */
    public void submitJob(String fileName, int pages) {
        // Input validation
        if (pages <= 0) {
            System.err.println("Error: Number of pages must be positive. Job not submitted.");
            return;
        }

        PrintJob newJob = new PrintJob(fileName, pages);
        waitingJobs.offer(newJob); // offer is generally preferred over add for queues (returns false instead of throwing exception on capacity limit, though LinkedList is unbounded)
        System.out.println(newJob + " submitted.");
    }

    /**
     * Processes the next job from the waiting queue.
     * Moves the job to the completed history.
     */
    public void processNextJob() {
        // Check if the queue is empty
        if (waitingJobs.isEmpty()) {
            System.err.println("Error: Cannot process job. Waiting queue is empty.");
            return;
        }

        // Get and remove the head of the queue
        PrintJob jobToProcess = waitingJobs.poll(); // poll returns null if queue is empty, but we checked already

        System.out.println("Processing job: " + jobToProcess);

        // Simulate processing by changing status and moving to history
        jobToProcess.setStatus(PrintJobStatus.COMPLETED);
        completedJobs.add(jobToProcess);

        System.out.println(jobToProcess + " moved to history.");
    }

    /**
     * Gets the list of jobs currently waiting in the queue.
     * @return A List view of the waiting jobs (order reflects queue).
     */
    public List<PrintJob> getWaitingJobs() {
        // Return a new ArrayList containing elements from the queue
        // This prevents external modification of the internal queue structure
        return new ArrayList<>(waitingJobs);
    }

    /**
     * Gets the list of completed jobs.
     * @return The List of completed jobs.
     */
    public List<PrintJob> getCompletedJobs() {
        return completedJobs; // Returning the internal list for simplicity as allowed
    }
}

// Main class for user interaction
public class Main {

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        PrintJobManager manager = new PrintJobManager();

        System.out.println("--- Print Job Manager ---");

        // Class-wide exception handling for the main application loop
        try {
            while (true) {
                printMenu();
                System.out.print("Enter command: ");
                String command = scanner.nextLine().trim().toLowerCase(); // Read command and normalize

                // Use switch statement for command processing
                switch (command) {
                    case "s":
                    case "submit":
                        System.out.print("Enter file name: ");
                        String fileName = scanner.nextLine().trim();
                        int pages = 0;
                        try {
                            System.out.print("Enter number of pages: ");
                            pages = Integer.parseInt(scanner.nextLine().trim());
                            manager.submitJob(fileName, pages);
                        } catch (NumberFormatException e) {
                            // Specific error handling for non-integer page input
                            System.err.println("Error: Invalid number format for pages. Please enter an integer.");
                        }
                        break;

                    case "p":
                    case "process":
                        manager.processNextJob();
                        break;

                    case "q":
                    case "view queue":
                        List<PrintJob> waiting = manager.getWaitingJobs();
                        System.out.println("Waiting Queue:");
                        if (waiting.isEmpty()) {
                            System.out.println("Waiting Queue is empty.");
                        } else {
                            // Iterate and print jobs from the List obtained from the manager
                            for (PrintJob job : waiting) {
                                System.out.println(job);
                            }
                        }
                        break;

                    case "h":
                    case "view history":
                        List<PrintJob> history = manager.getCompletedJobs();
                        System.out.println("Completed Jobs History:");
                        if (history.isEmpty()) {
                            System.out.println("Completed Jobs History is empty.");
                        } else {
                            // Iterate and print jobs from the List obtained from the manager
                            for (PrintJob job : history) {
                                System.out.println(job);
                            }
                        }
                        break;

                    case "e":
                    case "exit":
                        System.out.println("Exiting Print Job Manager.");
                        scanner.close(); // Close the scanner
                        System.exit(0); // Terminate the application
                        break;

                    default:
                        // Handle invalid commands
                        System.err.println("Error: Invalid command. Please try again.");
                        break;
                }
                System.out.println(); // Add a newline for better readability
            }
        } catch (Exception e) {
            // Catch-all for any unexpected exceptions during the main loop
            System.err.println("An unexpected error occurred: " + e.getMessage());
            e.printStackTrace(System.err); // Print stack trace to error stream
        } finally {
            // Ensure scanner is closed even if an exception occurs or loop exits
            if (scanner != null) {
                scanner.close();
            }
        }
    }

    /**
     * Prints the main menu options to the console.
     */
    private static void printMenu() {
        System.out.println("--- Menu ---");
        System.out.println("S: Submit Job");
        System.out.println("P: Process Next Job");
        System.out.println("Q: View Queue");
        System.out.println("H: View History");
        System.out.println("E: Exit");
        System.out.println("------------");
    }
}
