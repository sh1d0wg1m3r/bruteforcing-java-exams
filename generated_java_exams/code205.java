/*
 * Exam Question #205
 * Generated on: 2025-05-11 22:31:33
 * Generated by: Account 1
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Task Management System
 * 
 * **Scenario:**
 * 
 * You are tasked with developing a command-line application to simulate a simple task management system for a small team. The system should allow users to add new tasks, complete the next pending task, view pending tasks, and view completed tasks.
 * 
 * **Requirements:**
 * 
 * 1.  **Task Representation:** Create a class `Task` to represent a single task. It should minimally contain a unique ID and a description.
 * 2.  **Task Management Logic:** Create a class `TaskManager` responsible for managing the tasks.
 *     *   Pending tasks should be stored in a data structure that follows the **Queue** interface (e.g., `LinkedList`). Tasks are added to the end and completed from the front.
 *     *   Completed tasks should be stored in a data structure that follows the **List** interface (specifically using **ArrayList**).
 *     *   The `TaskManager` should provide methods to:
 *         *   Add a new task to the pending queue.
 *         *   Complete the next task from the pending queue, moving it to the completed list.
 *         *   Provide access to the pending tasks collection (for viewing).
 *         *   Provide access to the completed tasks collection (for viewing).
 * 3.  **User Interface:** Create a main class (e.g., `TaskApp`) with a `main` method to handle user interaction via the command line.
 *     *   Use **java.util.Scanner** to read user input (menu choices and task descriptions).
 *     *   Present a menu of options to the user using **System.out**.
 *     *   Use a **switch** statement to process the user's menu choice.
 *     *   Display task lists and success messages using **System.out**.
 *     *   Report error conditions (e.g., trying to complete a task when none are pending, invalid menu input) using **System.err**.
 * 4.  **Error Handling:** Implement **class-wide exception handling** using **try-catch** blocks within the main application loop to gracefully handle potential issues, such as invalid input types from the `Scanner`.
 * 5.  **Best Practices:**
 *     *   Employ **proper encapsulation** by making class fields private and providing public methods for access/modification.
 *     *   Use **meaningful variable and method names**.
 *     *   Include **appropriate comments and documentation** (e.g., Javadoc-style).
 *     *   Implement basic **input validation** (at least for the menu choice).
 *     *   Ensure **proper error handling** for business logic errors (like an empty queue) and input errors.
 *     *   Maintain a **clean code structure** with separate classes for different responsibilities.
 * 
 * **Required Components Checklist:**
 * 
 * *   [ ] `java.util.Queue`
 * *   [ ] `java.util.ArrayList`
 * *   [ ] `java.util.List` interface
 * *   [ ] `java.util.Scanner`
 * *   [ ] `switch` statement
 * *   [ ] `System.err`
 * *   [ ] `System.out`
 * *   [ ] `try-catch` blocks (class-wide/main loop)
 * 
 * **Expected Output:**
 * 
 * The application should run interactively. Examples of expected output include:
 * 
 * *   Displaying the main menu.
 * *   Prompting for input (choice, task description).
 * *   Confirming task addition.
 * *   Confirming task completion or reporting an error if no tasks are pending.
 * *   Listing pending tasks (or stating none are pending).
 * *   Listing completed tasks (or stating none are completed).
 * *   Reporting invalid menu choices or input type errors to `System.err`.
 * *   An exit message.
 * 
 * ```
 * --- Task Management System ---
 * 1. Add New Task
 * 2. Complete Next Task
 * 3. View Pending Tasks
 * 4. View Completed Tasks
 * 5. Exit
 * ----------------------------
 * Enter your choice: 1
 * Enter task description: Finish report
 * Task added: [ID: 1] Finish report
 * 
 * --- Task Management System ---
 * ... menu ...
 * Enter your choice: 3
 * --- Pending Tasks ---
 * [ID: 1] Finish report
 * ---------------------
 * 
 * --- Task Management System ---
 * ... menu ...
 * Enter your choice: 2
 * Task completed: [ID: 1] Finish report
 * 
 * --- Task Management System ---
 * ... menu ...
 * Enter your choice: 4
 * --- Completed Tasks ---
 * [ID: 1] Finish report
 * -----------------------
 * 
 * --- Task Management System ---
 * ... menu ...
 * Enter your choice: 2
 * Error: No pending tasks to complete.
 * 
 * --- Task Management System ---
 * ... menu ...
 * Enter your choice: invalid_input
 * Error: Invalid input. Please enter a number.
 * 
 * --- Task Management System ---
 * ... menu ...
 * Enter your choice: 5
 * Exiting Task Management System.
 * ```
 * 
 * Implement the complete Java code for this Task Management System.
 *
 * EXPLANATION:
 * This solution implements a simple command-line Task Management System demonstrating the required Java concepts and best practices.
 * 
 * 1.  **Task Class:** The `Task` class is a simple Plain Old Java Object (POJO) representing a task. It has private fields (`id`, `description`) and public getter methods, demonstrating encapsulation. The `toString()` method provides a convenient string representation for printing.
 * 
 * 2.  **TaskManager Class:** This class encapsulates the core logic for managing tasks.
 *     *   It uses `private Queue<Task> pendingTasks;` to store tasks waiting to be completed. `java.util.Queue` is chosen because tasks are processed in the order they are added (FIFO). `LinkedList` is used as a concrete implementation of `Queue`.
 *     *   It uses `private List<Task> completedTasks;` to store tasks that have been finished. `java.util.List` is the interface type, and `ArrayList` is used as the concrete implementation, suitable for storing a dynamic list of items where order matters and elements might be accessed or iterated over.
 *     *   `addTask(String description)`: Creates a new `Task` with a unique ID (managed by `nextTaskId`) and adds it to the `pendingTasks` queue using `offer()`.
 *     *   `completeNextTask()`: Uses `poll()` on the `pendingTasks` queue. `poll()` retrieves and removes the head of the queue, returning `null` if the queue is empty. If a task is retrieved, it's added to the `completedTasks` `List`. The completed task (or `null`) is returned to the caller for status reporting.
 *     *   `getPendingTasks()` and `getCompletedTasks()`: Provide access to the internal collections for viewing.
 * 
 * 3.  **TaskApp Class:** This is the main application class containing the `main` method and the application loop.
 *     *   `Scanner scanner = new Scanner(System.in);` is used to read input from the console.
 *     *   `TaskManager taskManager = new TaskManager();` creates an instance of the manager class.
 *     *   The `run()` method contains the main `while` loop that keeps the application running until the user chooses to exit.
 *     *   Inside the loop, `displayMenu()` prints options using `System.out`.
 *     *   User input for the menu choice is read using `scanner.nextInt()`. `scanner.nextLine()` is called immediately after to consume the leftover newline character, which is crucial when mixing `nextInt()` and `nextLine()`.
 *     *   A `switch` statement processes the integer `choice`, directing execution to the appropriate logic block (add, complete, view pending, view completed, exit, or default for invalid choice).
 *     *   **System.out** is used for all standard output, including the menu, prompts, task lists, and success messages.
 *     *   **System.err** is specifically used for reporting error conditions:
 *         *   When the user enters non-integer input for the menu choice (caught by `InputMismatchException`).
 *         *   When the user chooses to complete a task but the `pendingTasks` queue is empty (checked after calling `taskManager.completeNextTask()`).
 *         *   For invalid menu numbers (in the `default` case of the `switch`).
 *         *   For any other unexpected exceptions caught by the general `catch (Exception e)`.
 *     *   **Try-catch blocks** are used around the main logic within the `while` loop. This demonstrates class-wide exception handling by wrapping the core operations of the `run` method. It specifically catches `InputMismatchException` for invalid number input and a general `Exception` for any other unexpected runtime errors, printing informative messages to `System.err`.
 *     *   Input validation for the menu choice is handled by the `try-catch` block catching `InputMismatchException` and the `default` case of the `switch` for out-of-range numbers. Basic validation for the task description (not empty) is added in `TaskManager.addTask`.
 *     *   The `scanner.close()` is called after the loop exits to release the system resource.
 * 
 * This solution effectively integrates all the required components (`Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.err`, `System.out`, `try-catch`) into a functional application, following good object-oriented design principles and error handling practices.
 */

package com.example.taskapp; // Example package - adjust if necessary

import java.util.ArrayList;
import java.util.InputMismatchException;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;

/**
 * Represents a single task with an ID and description.
 * Demonstrates basic encapsulation.
 */
class Task {
    private int id;
    private String description;

    /**
     * Constructs a new Task.
     * @param id The unique identifier for the task.
     * @param description A brief description of the task.
     */
    public Task(int id, String description) {
        this.id = id;
        this.description = description;
    }

    /**
     * Gets the task ID.
     * @return The task ID.
     */
    public int getId() {
        return id;
    }

    /**
     * Gets the task description.
     * @return The task description.
     */
    public String getDescription() {
        return description;
    }

    /**
     * Provides a string representation of the task for display.
     * @return A formatted string including task ID and description.
     */
    @Override
    public String toString() {
        return "[ID: " + id + "] " + description;
    }
}

/**
 * Manages a collection of pending and completed tasks.
 * Uses a Queue for pending tasks and a List (implemented by ArrayList) for completed tasks.
 * Demonstrates usage of Queue, List, and ArrayList.
 */
class TaskManager {
    // Using Queue for pending tasks (FIFO - First-In, First-Out)
    private Queue<Task> pendingTasks;
    // Using List (implemented by ArrayList) for completed tasks
    private List<Task> completedTasks;
    private int nextTaskId; // To generate unique task IDs

    /**
     * Constructs a new TaskManager, initializing the task collections.
     */
    public TaskManager() {
        this.pendingTasks = new LinkedList<>(); // LinkedList is a common Queue implementation
        this.completedTasks = new ArrayList<>(); // ArrayList is a common List implementation
        this.nextTaskId = 1; // Start task IDs from 1
    }

    /**
     * Adds a new task to the pending queue.
     * A unique ID is automatically assigned.
     * @param description The description of the task to add.
     */
    public void addTask(String description) {
        // Basic input validation for description
        if (description == null || description.trim().isEmpty()) {
            System.err.println("Error: Task description cannot be empty.");
            return;
        }
        Task newTask = new Task(nextTaskId++, description.trim());
        // offer() is generally preferred over add() for queues as it handles capacity restrictions (though LinkedList is unbounded)
        pendingTasks.offer(newTask);
        System.out.println("Task added: " + newTask);
    }

    /**
     * Completes the next task from the pending queue.
     * The completed task is moved to the list of completed tasks.
     * @return The completed Task object, or null if the pending queue was empty.
     */
    public Task completeNextTask() {
        // poll() retrieves and removes the head of the queue, returning null if empty.
        Task completed = pendingTasks.poll();
        if (completed != null) {
            completedTasks.add(completed); // Add the completed task to the List
        }
        return completed;
    }

    /**
     * Gets the queue of pending tasks.
     * Note: Iterating over this Queue directly is fine for viewing,
     * but operations like poll()/remove() should be done via TaskManager methods.
     * @return The Queue of pending tasks.
     */
    public Queue<Task> getPendingTasks() {
        return pendingTasks;
    }

    /**
     * Gets the list of completed tasks.
     * @return The List of completed tasks.
     */
    public List<Task> getCompletedTasks() {
        return completedTasks;
    }
}

/**
 * Main application class for the Task Management System.
 * Handles user interaction, menu display, and delegates operations to TaskManager.
 * Demonstrates usage of Scanner, switch, System.out, System.err, and try-catch.
 */
public class TaskApp {

    private TaskManager taskManager;
    private Scanner scanner;

    /**
     * Constructs a new TaskApp, initializing the TaskManager and Scanner.
     */
    public TaskApp() {
        taskManager = new TaskManager();
        scanner = new Scanner(System.in);
    }

    /**
     * Displays the main menu options to the user using System.out.
     */
    private void displayMenu() {
        System.out.println("\n--- Task Management System ---");
        System.out.println("1. Add New Task");
        System.out.println("2. Complete Next Task");
        System.out.println("3. View Pending Tasks");
        System.out.println("4. View Completed Tasks");
        System.out.println("5. Exit");
        System.out.println("----------------------------");
    }

    /**
     * Runs the main application loop, handling user input and actions.
     * Includes try-catch blocks for class-wide exception handling.
     */
    public void run() {
        boolean exit = false;
        // Main application loop
        while (!exit) {
            // try-catch block for handling input errors and other potential exceptions
            try {
                displayMenu();
                System.out.print("Enter your choice: ");

                // Read user choice using Scanner
                int choice = scanner.nextInt();
                scanner.nextLine(); // Consume the newline character left by nextInt()

                // Process user choice using a switch statement
                switch (choice) {
                    case 1:
                        // Add New Task
                        System.out.print("Enter task description: ");
                        String description = scanner.nextLine();
                        taskManager.addTask(description); // Delegate to TaskManager
                        break;

                    case 2:
                        // Complete Next Task
                        Task completedTask = taskManager.completeNextTask(); // Delegate to TaskManager
                        if (completedTask != null) {
                            System.out.println("Task completed: " + completedTask); // Use System.out for success
                        } else {
                            // Use System.err for error message when queue is empty
                            System.err.println("Error: No pending tasks to complete.");
                        }
                        break;

                    case 3:
                        // View Pending Tasks
                        System.out.println("\n--- Pending Tasks ---");
                        Queue<Task> pending = taskManager.getPendingTasks(); // Get the Queue
                        if (pending.isEmpty()) {
                            System.out.println("No pending tasks."); // Use System.out
                        } else {
                            // Iterate over the Queue to display elements (without removing)
                            for (Task task : pending) {
                                System.out.println(task); // Use System.out
                            }
                        }
                        System.out.println("---------------------");
                        break;

                    case 4:
                        // View Completed Tasks
                        System.out.println("\n--- Completed Tasks ---");
                        List<Task> completed = taskManager.getCompletedTasks(); // Get the List (ArrayList)
                        if (completed.isEmpty()) {
                            System.out.println("No completed tasks."); // Use System.out
                        } else {
                            // Iterate over the List to display elements
                            for (Task task : completed) {
                                System.out.println(task); // Use System.out
                            }
                        }
                        System.out.println("-----------------------");
                        break;

                    case 5:
                        // Exit
                        exit = true;
                        System.out.println("Exiting Task Management System."); // Use System.out
                        break;

                    default:
                        // Invalid choice
                        // Use System.err for invalid input error
                        System.err.println("Error: Invalid choice. Please enter a number between 1 and 5.");
                        break;
                }

            } catch (InputMismatchException e) {
                // Handle cases where the user enters non-integer input for the choice
                // Use System.err for input type errors
                System.err.println("Error: Invalid input. Please enter a number.");
                scanner.nextLine(); // Consume the invalid input from the scanner to prevent infinite loop
            } catch (Exception e) {
                // Catch any other unexpected runtime exceptions
                // Use System.err for general unexpected errors
                System.err.println("An unexpected error occurred: " + e.getMessage());
                // Optional: e.printStackTrace(); // Uncomment for detailed debugging during development/exam
            }
        }

        // Close the scanner when exiting the application
        scanner.close();
    }

    /**
     * Main method to start the Task Management System application.
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        TaskApp app = new TaskApp();
        app.run(); // Start the application loop
    }
}
