/*
 * Exam Question #808
 * Generated on: 2025-05-12 16:43:54
 * Generated by: Account 4
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Task Prioritization and Processing System
 * 
 * **Scenario:**
 * 
 * A small team requires a simple command-line application to manage incoming tasks. Each task has a unique ID, a description, and a priority level (HIGH, MEDIUM, LOW). New tasks are added to a queue for processing. The system should allow users to add new tasks, view the next task waiting for processing, process the next task (moving it from the pending queue to a completed list), view all completed tasks, and exit the system.
 * 
 * **Requirements:**
 * 
 * Implement a Java application that fulfills the following:
 * 
 * 1.  **Task Representation:** Create a `Task` class with private fields for `id` (int), `description` (String), and `priority` (String). Include a constructor and public getter methods for all fields. Override the `toString()` method to provide a user-friendly representation of a task.
 * 2.  **Task Management System:** Create a `TaskManagementSystem` class responsible for managing the tasks.
 *     *   It must use a `java.util.Queue<Task>` to store tasks that are pending processing. Use `java.util.LinkedList` as the concrete implementation.
 *     *   It must use a `java.util.List<Task>` to store tasks that have been completed. Use `java.util.ArrayList` as the concrete implementation, but declare the field using the `List` interface.
 *     *   Maintain a counter for generating unique task IDs automatically.
 *     *   Implement methods for:
 *         *   `addTask(String description, String priority)`: Creates a new `Task` with a unique ID and adds it to the pending queue. **Validate the priority input** (must be "HIGH", "MEDIUM", or "LOW", case-insensitive). If invalid, do not add the task and report an error.
 *         *   `viewNextTask()`: Returns the task at the front of the queue without removing it. Returns `null` if the queue is empty.
 *         *   `processNextTask()`: Removes the task from the front of the queue and adds it to the completed list. Returns the processed task or `null` if the queue was empty.
 *         *   `viewCompletedTasks()`: Returns the list of completed tasks.
 *     *   Implement a `run()` method that contains the main application loop and user interaction logic.
 * 3.  **User Interface:**
 *     *   Use `java.util.Scanner` to read user input from the console.
 *     *   Present a menu of options to the user (Add Task, View Next, Process Next, View Completed, Exit).
 *     *   Use a `switch` statement to handle the user's menu choice.
 *     *   Use `System.out` for displaying the menu, prompts, success messages, and task information.
 *     *   Use `System.err` for displaying error messages (e.g., invalid menu choice, invalid priority, attempting to process/view next task when the queue is empty, general unexpected errors).
 * 4.  **Error Handling:**
 *     *   Implement input validation as specified for `addTask` and menu choice (handle non-integer input).
 *     *   Handle cases where the pending queue is empty when trying to view or process the next task, reporting an error via `System.err`.
 *     *   Include a **class-wide `try-catch` block** in the `run()` method to catch any unexpected exceptions during the execution of the main loop and report them using `System.err`.
 *     *   Ensure the `Scanner` is properly closed when the program exits or encounters an error.
 * 5.  **Best Practices:**
 *     *   Adhere to proper encapsulation (private fields, public methods).
 *     *   Use meaningful variable and method names.
 *     *   Include appropriate comments (e.g., explaining the purpose of classes, methods, or complex logic).
 *     *   Structure the code cleanly.
 * 
 * **Menu Options:**
 * 
 * 1.  Add New Task
 * 2.  View Next Pending Task
 * 3.  Process Next Task
 * 4.  View Completed Tasks
 * 5.  Exit
 * 
 * **Expected Output:**
 * 
 * The program should start, display the menu, and respond to user commands. Error messages should appear on the standard error stream (`System.err`), while normal output and information messages appear on the standard output stream (`System.out`).
 * 
 * Example Interaction Snippet:
 * 
 * ```
 * --- Task Management System ---
 * Choose an action:
 * 1. Add New Task
 * 2. View Next Pending Task
 * 3. Process Next Task
 * 4. View Completed Tasks
 * 5. Exit
 * Enter your choice: 1
 * Enter task description: Write exam question
 * Enter task priority (HIGH, MEDIUM, LOW): HIGH
 * Task added successfully: Task [ID=1, Priority=HIGH, Description='Write exam question']
 * 
 * Choose an action:
 * ...
 * Enter your choice: 2
 * Next pending task: Task [ID=1, Priority=HIGH, Description='Write exam question']
 * 
 * Choose an action:
 * ...
 * Enter your choice: 3
 * Successfully processed task: Task [ID=1, Priority=HIGH, Description='Write exam question']
 * 
 * Choose an action:
 * ...
 * Enter your choice: 4
 * --- Completed Tasks ---
 * Task [ID=1, Priority=HIGH, Description='Write exam question']
 * -----------------------
 * 
 * Choose an action:
 * ...
 * Enter your choice: 3
 * No pending tasks to process. // This should go to System.err
 * 
 * Choose an action:
 * ...
 * Enter your choice: invalid_input
 * Invalid input. Please enter a number. // This should go to System.err
 * 
 * Choose an action:
 * ...
 * Enter your choice: 1
 * Enter task description: Test System
 * Enter task priority (HIGH, MEDIUM, LOW): URGENT
 * Invalid priority: URGENT. Task not added. Use HIGH, MEDIUM, or LOW. // This should go to System.err
 * 
 * Choose an action:
 * ...
 * Enter your choice: 5
 * Exiting Task Management System. Goodbye!
 * Scanner closed.
 * ```
 * 
 * Implement the complete Java code for this system.
 *
 * EXPLANATION:
 * This solution implements a `Task Prioritization and Processing System` as described in the exam question, demonstrating the required Java concepts and best practices.
 * 
 * 1.  **`Task` Class:** This class serves as a simple data structure to hold information about a task. It includes private fields (`id`, `description`, `priority`), a constructor to initialize these fields, and public getter methods (`getId`, `getDescription`, `getPriority`) to allow external access to the data while keeping the fields encapsulated. The `toString()` method is overridden to provide a convenient string representation for printing.
 * 
 * 2.  **`TaskManagementSystem` Class:** This is the core class that orchestrates the task management logic.
 *     *   **`pendingTasks`:** A `Queue<Task>` (implemented using `LinkedList`) is used to store tasks awaiting processing. The `Queue` interface naturally supports the FIFO (First-In, First-Out) behavior required for processing the "next" task. `offer()` is used for adding tasks, and `poll()` is used for removing and retrieving the head of the queue. `peek()` is used to view the next task without removing it.
 *     *   **`completedTasks`:** A `List<Task>` (implemented using `ArrayList`) is used to store tasks once they have been processed. The `List` interface provides a simple way to store and iterate over the completed tasks in the order they were finished.
 *     *   **`nextTaskId`:** A simple integer counter ensures each task gets a unique ID.
 *     *   **`scanner`:** A `Scanner` object is used throughout the `run` method to read user input. It's declared as a class field and initialized in the constructor.
 * 
 * 3.  **Methods (`addTask`, `viewNextTask`, `processNextTask`, `viewCompletedTasks`):** These methods encapsulate the core business logic for managing the task collections. They interact with the `pendingTasks` queue and `completedTasks` list. `addTask` includes validation for the priority string. `processNextTask` and `viewNextTask` check if the queue is empty before attempting operations that would throw exceptions (`poll()` or `peek()` on an empty queue, though `peek()` and `poll()` on `LinkedList` specifically return `null` if empty, checking `isEmpty()` first allows for custom error messages via `System.err`).
 * 
 * 4.  **`run()` Method:** This method contains the main application loop.
 *     *   It continuously displays a menu (`printMenu()`) and prompts the user for input using `System.out`.
 *     *   User input is read using `scanner.nextLine()` and then parsed into an integer using `Integer.parseInt()`. This approach is generally safer than `scanner.nextInt()` followed by `scanner.nextLine()` as it consumes the entire line, preventing newline issues.
 *     *   A `switch` statement is used to direct the program flow based on the user's integer choice, calling the appropriate task management methods.
 *     *   `System.out` is used for all standard output, including the menu, prompts, success messages, and listing tasks.
 *     *   `System.err` is used specifically for error conditions, such as invalid menu choices (non-numeric or out-of-range), invalid task priority input, or attempting to process/view a task when the pending queue is empty.
 * 
 * 5.  **Error Handling:**
 *     *   **Input Validation:** `addTask` explicitly checks if the provided priority string is valid. The `run` method uses a `try-catch(NumberFormatException)` block around `Integer.parseInt()` to handle cases where the user enters non-numeric input for the menu choice.
 *     *   **Empty Queue Handling:** `processNextTask` and `viewNextTask` (indirectly handled by the caller checking for `null`) check for an empty queue before proceeding, reporting an error via `System.err` if necessary.
 *     *   **Class-Wide `try-catch`:** A `try-catch(Exception e)` block wraps the entire `while` loop in the `run` method. This serves as a safety net to catch any unexpected runtime exceptions that might occur within the loop's execution, preventing the program from crashing abruptly. It prints a generic error message and the stack trace to `System.err`.
 *     *   **Resource Management:** A `finally` block ensures that the `scanner` object is closed when the `try` block is exited, either normally or due to an exception, releasing the underlying system resources.
 * 
 * 6.  **Best Practices:**
 *     *   Encapsulation is used in both `Task` and `TaskManagementSystem` classes.
 *     *   Variable and method names are descriptive (`pendingTasks`, `processNextTask`, `nextTaskId`).
 *     *   Comments explain the purpose of classes, fields, and key methods.
 *     *   The code is structured into logical classes and methods, improving readability and maintainability.
 * 
 * This solution effectively integrates the required Java components (`Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.err`, `System.out`, `try-catch`) into a practical, albeit simplified, real-world scenario while demonstrating fundamental object-oriented principles, input validation, and robust error handling.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.InputMismatchException; // Although using nextLine().parseInt() avoids this specific one, good to know

/**
 * Represents a single task in the system.
 */
class Task {
    private int id;
    private String description;
    private String priority; // HIGH, MEDIUM, LOW

    /**
     * Constructs a new Task.
     * @param id The unique identifier for the task.
     * @param description A brief description of the task.
     * @param priority The priority level (HIGH, MEDIUM, LOW).
     */
    public Task(int id, String description, String priority) {
        this.id = id;
        this.description = description;
        this.priority = priority;
    }

    // --- Getters ---
    public int getId() {
        return id;
    }

    public String getDescription() {
        return description;
    }

    public String getPriority() {
        return priority;
    }

    /**
     * Provides a string representation of the Task.
     * @return A formatted string describing the task.
     */
    @Override
    public String toString() {
        return "Task [ID=" + id + ", Priority=" + priority + ", Description='" + description + "']";
    }
}

/**
 * Manages a collection of pending and completed tasks.
 * Uses a Queue for pending tasks and a List for completed tasks.
 */
class TaskManagementSystem {
    // Queue for tasks waiting to be processed (FIFO)
    private Queue<Task> pendingTasks;
    // List for tasks that have been completed
    private List<Task> completedTasks;
    // Counter for generating unique task IDs
    private int nextTaskId;
    // Scanner for reading user input
    private Scanner scanner;

    /**
     * Constructs a new TaskManagementSystem, initializing collections and scanner.
     */
    public TaskManagementSystem() {
        // Initialize the Queue using LinkedList
        this.pendingTasks = new LinkedList<>();
        // Initialize the List using ArrayList, declared with List interface
        this.completedTasks = new ArrayList<>();
        this.nextTaskId = 1;
        this.scanner = new Scanner(System.in);
    }

    /**
     * Adds a new task to the pending tasks queue.
     * Validates the priority string.
     * @param description The task description.
     * @param priority The task priority (HIGH, MEDIUM, LOW).
     */
    public void addTask(String description, String priority) {
        String upperPriority = priority.toUpperCase();
        // Input validation for priority
        if (!upperPriority.equals("HIGH") && !upperPriority.equals("MEDIUM") && !upperPriority.equals("LOW")) {
            System.err.println("Invalid priority: " + priority + ". Task not added. Use HIGH, MEDIUM, or LOW.");
            return; // Do not add the task if priority is invalid
        }

        Task newTask = new Task(nextTaskId++, description, upperPriority);
        // Add the new task to the end of the queue
        pendingTasks.offer(newTask); // offer() is generally preferred over add() for queues
        System.out.println("Task added successfully: " + newTask); // Use System.out for success message
    }

    /**
     * Views the next task to be processed without removing it.
     * @return The next task, or null if the queue is empty.
     */
    public Task viewNextTask() {
        // peek() returns the head of the queue, or null if the queue is empty
        return pendingTasks.peek();
    }

    /**
     * Processes the next task in the queue, removing it and adding it to the completed list.
     * @return The processed task, or null if the queue was empty.
     */
    public Task processNextTask() {
        // Check if queue is empty before attempting to poll
        if (pendingTasks.isEmpty()) {
            System.err.println("No pending tasks to process."); // Use System.err for error message
            return null; // Indicate failure/empty queue
        }
        // Remove and return the head of the queue
        Task processedTask = pendingTasks.poll(); // poll() removes the head and returns it, or null if empty (already checked)
        // Add the processed task to the completed list
        completedTasks.add(processedTask);
        return processedTask;
    }

    /**
     * Returns the list of completed tasks.
     * @return A List of completed tasks.
     */
    public List<Task> viewCompletedTasks() {
        // Return the list of completed tasks (simplification for exam - in production, return a copy or unmodifiable list)
        return completedTasks;
    }

    /**
     * Runs the main task management system loop, handling user interaction.
     * Includes the main menu, input processing, and top-level exception handling.
     */
    public void run() {
        System.out.println("--- Task Management System ---");

        boolean running = true;
        // Class-wide exception handling for the main operational loop
        try {
            while (running) {
                printMenu();

                int choice = -1; // Default invalid choice
                System.out.print("Enter your choice: ");
                try {
                    // Use nextLine() and parse to handle potential non-integer input gracefully
                    String inputLine = scanner.nextLine();
                    choice = Integer.parseInt(inputLine);
                } catch (NumberFormatException e) {
                    // Specific handling for non-integer input using System.err
                    System.err.println("Invalid input. Please enter a number.");
                    // Use continue to skip the rest of the switch and show the menu again
                    continue;
                }

                // Use switch statement for flow control based on user choice
                switch (choice) {
                    case 1: // Add Task
                        System.out.print("Enter task description: "); // System.out for prompt
                        String description = scanner.nextLine();
                        System.out.print("Enter task priority (HIGH, MEDIUM, LOW): "); // System.out for prompt
                        String priority = scanner.nextLine();
                        // addTask handles validation and System.err for invalid priority
                        addTask(description, priority);
                        break;

                    case 2: // View Next Pending Task
                        Task nextTask = viewNextTask(); // viewNextTask returns null if empty
                        if (nextTask != null) {
                            System.out.println("Next pending task: " + nextTask); // System.out for task details
                        } else {
                            System.out.println("No pending tasks in the queue."); // System.out for informational message
                        }
                        break;

                    case 3: // Process Next Task
                        // processNextTask uses System.err if the queue is empty
                        Task processed = processNextTask();
                        if (processed != null) {
                            System.out.println("Successfully processed task: " + processed); // System.out for success message
                        }
                        // Error message for empty queue is handled inside processNextTask via System.err
                        break;

                    case 4: // View Completed Tasks
                        List<Task> completed = viewCompletedTasks();
                        if (completed.isEmpty()) {
                            System.out.println("No tasks have been completed yet."); // System.out for informational message
                        } else {
                            System.out.println("--- Completed Tasks ---"); // System.out for header
                            // Iterate and print each completed task using System.out
                            for (Task task : completed) {
                                System.out.println(task);
                            }
                            System.out.println("-----------------------"); // System.out for footer
                        }
                        break;

                    case 5: // Exit
                        System.out.println("Exiting Task Management System. Goodbye!"); // System.out for exit message
                        running = false; // Set flag to false to exit the while loop
                        break;

                    default: // Handle valid numbers outside the menu range
                        System.err.println("Invalid choice. Please enter a number between 1 and 5."); // System.err for invalid input error
                        break;
                }
                System.out.println(); // Add a blank line for readability between operations
            }
        } catch (Exception e) {
            // Catch any other unexpected exceptions that might occur in the loop
            System.err.println("An unexpected error occurred during system operation."); // Use System.err for critical error
            e.printStackTrace(System.err); // Print stack trace to System.err for debugging
        } finally {
            // Ensure scanner is closed regardless of how the loop exits or if an exception occurs
            if (scanner != null) {
                scanner.close();
                System.out.println("Scanner closed."); // Informational message via System.out
            }
        }
    }

    /**
     * Prints the main menu options to the console using System.out.
     */
    private void printMenu() {
        System.out.println("Choose an action:");
        System.out.println("1. Add New Task");
        System.out.println("2. View Next Pending Task");
        System.out.println("3. Process Next Task");
        System.out.println("4. View Completed Tasks");
        System.out.println("5. Exit");
    }

    /**
     * Main method to start the application.
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        TaskManagementSystem system = new TaskManagementSystem();
        system.run(); // Start the main application loop
    }
}
