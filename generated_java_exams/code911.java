/*
 * Exam Question #911
 * Generated on: 2025-05-12 16:58:26
 * Generated by: Account 1
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Task Management System
 * 
 * **Objective:** Design and implement a simple command-line based Task Management System. The system should allow users to add new tasks to a queue of pending tasks, process the next task from the queue, and view lists of both pending and completed tasks.
 * 
 * **Requirements:**
 * 
 * 1.  **Task Representation:** Create a `Task` class with private fields for an integer ID and a String description. Include a constructor and public getter methods. Override the `toString()` method for easy printing.
 * 2.  **Task Management Logic:** Create a `TaskManager` class responsible for managing the tasks.
 *     *   It must use a `java.util.Queue<Task>` to store tasks that are waiting to be processed (pending tasks). Choose an appropriate implementation for the `Queue` interface.
 *     *   It must use a `java.util.List<Task>` to store tasks that have been processed (completed tasks). Instantiate this `List` using a `java.util.ArrayList`.
 *     *   Include methods:
 *         *   `addTask(String description)`: Creates a new `Task` with a unique ID and adds it to the pending queue.
 *         *   `processNextTask()`: Removes the next task from the pending queue and adds it to the completed list. Returns the processed `Task` or `null` if the queue was empty.
 *         *   `getPendingTasks()`: Returns the collection of pending tasks (as a `List`).
 *         *   `getCompletedTasks()`: Returns the collection of completed tasks (as a `List`).
 * 3.  **User Interface:** Create a main class (`ExamTaskSystem`) with a `main` method to handle user interaction.
 *     *   Use `java.util.Scanner` to read user input from the console (`System.in`). Ensure the `Scanner` is properly closed.
 *     *   Present a menu of options to the user:
 *         1.  Add New Task
 *         2.  Process Next Task
 *         3.  View Pending Tasks
 *         4.  View Completed Tasks
 *         5.  Exit
 *     *   Use a `switch` statement to handle the user's choice.
 *     *   Display normal program output (menu, prompts, task lists, confirmations) using `System.out`.
 *     *   Display error messages (e.g., invalid input, attempting to process an empty queue, empty task description) using `System.err`.
 * 4.  **Error Handling:**
 *     *   Implement input validation for the task description (cannot be empty).
 *     *   Use `try-catch` blocks within the main loop to handle potential exceptions, specifically `InputMismatchException` if the user enters non-integer input for the menu choice. Also consider handling other potential runtime exceptions gracefully. The exception handling should be class-wide within the `main` method's logic block.
 * 5.  **Best Practices:**
 *     *   Apply proper encapsulation (private fields, public methods).
 *     *   Use meaningful variable and method names.
 *     *   Include appropriate comments (especially Javadoc for classes and methods).
 *     *   Ensure clean code structure by separating concerns into different classes.
 * 
 * **Expected Output:**
 * 
 * The system should run interactively. Users should be able to perform the actions via menu choices.
 * - Adding a task should show a confirmation.
 * - Processing a task should show which task was processed or an error if none were pending.
 * - Viewing lists should display the current tasks in each state or a message indicating the list is empty.
 * - Invalid input (non-numeric choice, empty description) should result in an error message on `System.err`.
 * - Exiting should terminate the program gracefully.
 * 
 * Example interaction:
 * 
 * ```
 * --- Task Management System ---
 * 
 * Select an option:
 * 1. Add New Task
 * 2. Process Next Task
 * 3. View Pending Tasks
 * 4. View Completed Tasks
 * 5. Exit
 * Enter your choice: 1
 * Enter task description: Write exam question
 * Task added: Task #1: Write exam question
 * 
 * Select an option:
 * 1. Add New Task
 * 2. Process Next Task
 * 3. View Pending Tasks
 * 4. View Completed Tasks
 * 5. Exit
 * Enter your choice: 1
 * Enter task description: Review solution
 * Task added: Task #2: Review solution
 * 
 * Select an option:
 * 1. Add New Task
 * 2. Process Next Task
 * 3. View Pending Tasks
 * 4. View Completed Tasks
 * 5. Exit
 * Enter your choice: 3
 * --- Pending Tasks ---
 * Task #1: Write exam question
 * Task #2: Review solution
 * ---------------------
 * 
 * Select an option:
 * 1. Add New Task
 * 2. Process Next Task
 * 3. View Pending Tasks
 * 4. View Completed Tasks
 * 5. Exit
 * Enter your choice: 2
 * Processed task: Task #1: Write exam question
 * 
 * Select an option:
 * 1. Add New Task
 * 2. Process Next Task
 * 3. View Pending Tasks
 * 4. View Completed Tasks
 * 5. Exit
 * Enter your choice: 3
 * --- Pending Tasks ---
 * Task #2: Review solution
 * ---------------------
 * 
 * Select an option:
 * 1. Add New Task
 * 2. Process Next Task
 * 3. View Pending Tasks
 * 4. View Completed Tasks
 * 5. Exit
 * Enter your choice: 4
 * --- Completed Tasks ---
 * Task #1: Write exam question
 * -----------------------
 * 
 * Select an option:
 * 1. Add New Task
 * 2. Process Next Task
 * 3. View Pending Tasks
 * 4. View Completed Tasks
 * 5. Exit
 * Enter your choice: abc
 * Invalid input. Please enter a number.
 * 
 * Select an option:
 * 1. Add New Task
 * 2. Process Next Task
 * 3. View Pending Tasks
 * 4. View Completed Tasks
 * 5. Exit
 * Enter your choice: 2
 * Processed task: Task #2: Review solution
 * 
 * Select an option:
 * 1. Add New Task
 * 2. Process Next Task
 * 3. View Pending Tasks
 * 4. View Completed Tasks
 * 5. Exit
 * Enter your choice: 2
 * Error: No pending tasks to process.
 * 
 * Select an option:
 * 1. Add New Task
 * 2. Process Next Task
 * 3. View Pending Tasks
 * 4. View Completed Tasks
 * 5. Exit
 * Enter your choice: 5
 * Exiting Task Management System. Goodbye!
 * ```
 *
 * EXPLANATION:
 * This solution implements a simple Task Management System demonstrating the required Java concepts.
 * 
 * 1.  **Task Class:** A basic class representing a task with an ID and description, following encapsulation principles. The `toString()` method provides a convenient way to display task information.
 * 
 * 2.  **TaskManager Class:**
 *     *   It holds the core state: `pendingTasks` (a `Queue`) and `completedTasks` (a `List`, specifically an `ArrayList`).
 *     *   A `Queue` (`LinkedList` implementation is used here) is ideal for pending tasks because it naturally enforces a First-In, First-Out (FIFO) processing order, where the oldest task is processed first. `offer()` is used for adding (preferred over `add` for queues as it's designed for capacity-constrained queues, though not strictly necessary here) and `poll()` is used for removing from the head (preferred over `remove` as it returns `null` if the queue is empty, allowing graceful handling).
 *     *   A `List` (`ArrayList` implementation is used) is suitable for completed tasks as it maintains the order of completion and allows dynamic resizing. `add()` is used to append completed tasks.
 *     *   Methods like `addTask` and `processNextTask` encapsulate the logic for manipulating these collections. `processNextTask` checks if the queue is empty using the `poll()` method's return value (`null`) to avoid exceptions and signal the calling code.
 *     *   `getPendingTasks()` and `getCompletedTasks()` provide access to the task lists, allowing the main class to display them.
 * 
 * 3.  **ExamTaskSystem (main class):**
 *     *   The `main` method orchestrates the application flow.
 *     *   A `Scanner` is used within a `try-with-resources` block to ensure it's closed automatically, preventing resource leaks.
 *     *   A `while` loop keeps the system running until the user chooses to exit.
 *     *   A menu is printed using `System.out`.
 *     *   The user's choice is read using `scanner.nextInt()`.
 *     *   `scanner.nextLine()` is called immediately after reading the integer to consume the leftover newline character, which is crucial to prevent issues with subsequent `scanner.nextLine()` calls for reading strings.
 *     *   A `switch` statement efficiently handles the different menu options.
 *     *   **Input Validation:** Inside the "Add New Task" case, `description.isEmpty()` checks if the user entered a non-empty string. If not, an error is printed to `System.err`.
 *     *   **Error Handling (System.err):** `System.err` is used to print error messages for invalid menu choices (in the `default` case of the `switch`), for empty task descriptions, and when the user tries to process a task but the pending queue is empty.
 *     *   **Error Handling (try-catch):**
 *         *   A `try-catch` block wraps the input reading and `switch` logic inside the main loop.
 *         *   It specifically catches `InputMismatchException`, which occurs if the user enters text instead of a number for the menu choice. The catch block prints an error to `System.err` and consumes the invalid input from the scanner (`scanner.nextLine()`) to prevent an infinite loop.
 *         *   Additional specific catches like `NoSuchElementException` and `IllegalStateException` are included for more robust handling of potential scanner issues, though less common in this simple console setup.
 *         *   A general `catch (Exception e)` is included around the `try-with-resources` block to catch any issues during the initialization or closing of the `Scanner` itself.
 *     *   `System.out` is used for all standard output, including the menu, prompts, and lists of tasks.
 * 
 * This structure effectively separates concerns and demonstrates the practical application of all specified Java components within a functional program, while adhering to best practices for encapsulation, naming, and error handling.
 */

import java.util.InputMismatchException;
import java.util.List;
import java.util.ArrayList;
import java.util.Queue;
import java.util.LinkedList; // A common Queue implementation
import java.util.Scanner;
import java.util.NoSuchElementException;

/**
 * Represents a single task in the system.
 */
class Task {
    private int id;
    private String description;

    /**
     * Constructs a new Task.
     * @param id The unique identifier for the task.
     * @param description The description of the task.
     */
    public Task(int id, String description) {
        this.id = id;
        this.description = description;
    }

    /**
     * Gets the task ID.
     * @return The task ID.
     */
    public int getId() {
        return id;
    }

    /**
     * Gets the task description.
     * @return The task description.
     */
    public String getDescription() {
        return description;
    }

    /**
     * Returns a string representation of the task.
     * @return Formatted string including ID and description.
     */
    @Override
    public String toString() {
        return "Task #" + id + ": " + description;
    }
}

/**
 * Manages the queue of pending tasks and the list of completed tasks.
 */
class TaskManager {
    // Using Queue for pending tasks (FIFO - First-In, First-Out)
    private Queue<Task> pendingTasks;
    // Using List (specifically ArrayList) for completed tasks (ordered, dynamic)
    private List<Task> completedTasks;
    private int nextTaskId;

    /**
     * Constructs a new TaskManager.
     * Initializes the pending and completed task collections.
     */
    public TaskManager() {
        this.pendingTasks = new LinkedList<>(); // LinkedList implements Queue
        this.completedTasks = new ArrayList<>(); // ArrayList implements List
        this.nextTaskId = 1; // Start task IDs from 1
    }

    /**
     * Adds a new task to the pending queue.
     * Task description is validated by the caller.
     * @param description The description of the task. Must not be null or empty.
     * @return The newly created Task object.
     */
    public Task addTask(String description) {
        // Validation is assumed to be done by the caller (e.g., main method)
        Task newTask = new Task(nextTaskId++, description);
        pendingTasks.offer(newTask); // offer is preferred over add for queues, returns boolean
        return newTask;
    }

    /**
     * Processes the next task from the pending queue.
     * Moves the task from the pending queue to the completed list.
     * @return The completed Task, or null if the pending queue was empty.
     */
    public Task processNextTask() {
        Task taskToProcess = pendingTasks.poll(); // poll retrieves and removes the head, returns null if empty
        if (taskToProcess != null) {
            completedTasks.add(taskToProcess);
        }
        return taskToProcess;
    }

    /**
     * Gets the current list of pending tasks.
     * @return A List view of the pending tasks (the underlying Queue).
     */
    public List<Task> getPendingTasks() {
        // Note: Returning the LinkedList directly which implements List is acceptable for exam
        // In a real application, returning an unmodifiable view might be better encapsulation
        // Or returning new ArrayList<>(pendingTasks) to decouple
        return (List<Task>) pendingTasks; // Cast LinkedList to List
    }

    /**
     * Gets the current list of completed tasks.
     * @return The List of completed tasks (ArrayList).
     */
    public List<Task> getCompletedTasks() {
        return completedTasks;
    }

    /**
     * Checks if the pending task queue is empty.
     * @return true if the pending queue is empty, false otherwise.
     */
    public boolean isQueueEmpty() {
        return pendingTasks.isEmpty();
    }

    /**
     * Checks if the completed tasks list is empty.
     * @return true if the completed list is empty, false otherwise.
     */
    public boolean isCompletedListEmpty() {
        return completedTasks.isEmpty();
    }
}

/**
 * Main class for the Task Management System.
 * Provides a command-line interface for interacting with the TaskManager.
 */
public class ExamTaskSystem {

    public static void main(String[] args) {
        // Use try-with-resources for Scanner to ensure it's closed
        try (Scanner scanner = new Scanner(System.in)) {
            TaskManager taskManager = new TaskManager();
            System.out.println("--- Task Management System ---");

            boolean running = true;
            while (running) {
                printMenu();

                try {
                    System.out.print("Enter your choice: ");
                    int choice = scanner.nextInt();
                    // Consume the newline character left after reading the integer
                    scanner.nextLine();

                    // Use a switch statement to handle different user choices
                    switch (choice) {
                        case 1: // Add New Task
                            System.out.print("Enter task description: ");
                            String description = scanner.nextLine().trim(); // trim whitespace

                            // Input validation for task description
                            if (description.isEmpty()) {
                                System.err.println("Error: Task description cannot be empty.");
                            } else {
                                Task addedTask = taskManager.addTask(description);
                                System.out.println("Task added: " + addedTask);
                            }
                            break;

                        case 2: // Process Next Task
                            Task processedTask = taskManager.processNextTask();
                            if (processedTask != null) {
                                System.out.println("Processed task: " + processedTask);
                            } else {
                                // Use System.err for error condition (queue empty)
                                System.err.println("Error: No pending tasks to process.");
                            }
                            break;

                        case 3: // View Pending Tasks
                            List<Task> pending = taskManager.getPendingTasks(); // Get List view from Queue
                            if (pending.isEmpty()) {
                                System.out.println("No pending tasks.");
                            } else {
                                System.out.println("--- Pending Tasks ---");
                                // Iterate and print using System.out
                                for (Task task : pending) {
                                    System.out.println(task);
                                }
                                System.out.println("---------------------");
                            }
                            break;

                        case 4: // View Completed Tasks
                            List<Task> completed = taskManager.getCompletedTasks(); // Get ArrayList (implements List)
                            if (completed.isEmpty()) {
                                System.out.println("No completed tasks yet.");
                            } else {
                                System.out.println("--- Completed Tasks ---");
                                // Iterate and print using System.out
                                for (Task task : completed) {
                                    System.out.println(task);
                                }
                                System.out.println("-----------------------");
                            }
                            break;

                        case 5: // Exit
                            System.out.println("Exiting Task Management System. Goodbye!");
                            running = false; // Set flag to exit the loop
                            break;

                        default: // Invalid choice
                            // Use System.err for invalid input error
                            System.err.println("Invalid choice. Please enter a number between 1 and 5.");
                            break;
                    }
                } catch (InputMismatchException e) {
                    // Class-wide exception handling for non-integer input
                    System.err.println("Invalid input. Please enter a number.");
                    scanner.nextLine(); // IMPORTANT: Consume the invalid input to prevent infinite loop
                } catch (NoSuchElementException e) {
                     // Handles cases where scanner might run out of input - less likely in simple console apps
                     System.err.println("Input stream exhausted. Exiting.");
                     running = false;
                } catch (IllegalStateException e) {
                    // Handles cases where scanner might be closed - less likely with try-with-resources
                    System.err.println("Scanner is closed. Exiting.");
                    running = false;
                }
                 // A general catch block for unexpected errors could be added for robustness,
                 // but specific ones cover the expected issues in this app.
                 // catch (Exception e) {
                 //    System.err.println("An unexpected error occurred: " + e.getMessage());
                 //    e.printStackTrace(); // For debugging purposes
                 // }
            }
        } catch (Exception e) {
            // Catch any potential exception during Scanner initialization or closing
            System.err.println("An error occurred during system initialization or shutdown: " + e.getMessage());
            e.printStackTrace();
        }
    }

    /**
     * Prints the main menu options to the console.
     */
    private static void printMenu() {
        System.out.println("\nSelect an option:");
        System.out.println("1. Add New Task");
        System.out.println("2. Process Next Task");
        System.out.println("3. View Pending Tasks");
        System.out.println("4. View Completed Tasks");
        System.out.println("5. Exit");
    }
}
