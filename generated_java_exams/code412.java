/*
 * Exam Question #412
 * Generated on: 2025-05-11 23:07:21
 * Generated by: Account 5
 * 
 * QUESTION:
 * **Java Programming Exam Task: Distribution Center Package Management**
 * 
 * **Scenario:**
 * You are tasked with building a simplified package management system for a small distribution center. Packages arrive, are placed in an incoming queue for processing, and once processed, are moved to a list of completed packages. The system should interact with a user via a console menu, demonstrating robust handling of data structures, user input, and errors.
 * 
 * **Requirements:**
 * 
 * 1.  **Data Structures:**
 *     *   Maintain an `incomingQueue` of `Package` objects. This queue represents packages waiting to be processed in a First-In, First-Out (FIFO) manner. You must use a class that implements the `java.util.Queue` interface (e.g., `LinkedList`).
 *     *   Maintain a `processedPackages` list of `Package` objects. This list stores packages that have been successfully processed. You must use a class that implements the `java.util.List` interface (e.g., `ArrayList`).
 *     *   Create a simple `Package` class with private fields for `id` (String) and `destination` (String), a constructor to initialize these fields, appropriate public getter methods, and a `toString()` method that provides a clear representation of the package (e.g., "Package [ID=..., Destination=...]").
 * 
 * 2.  **Functionality (Console Menu):** Implement a console application that presents the user with the following menu and performs the corresponding actions:
 *     *   **1. Add New Package:** Prompt the user for a Package ID and Destination. Create a `Package` object using the provided details and add it to the `incomingQueue`. You must validate that neither the ID nor the Destination is empty or consists only of whitespace. If validation fails, display an error.
 *     *   **2. Process Next Package:** Remove the package at the head of the `incomingQueue` and add it to the `processedPackages` list. If the `incomingQueue` is currently empty, display an appropriate error message.
 *     *   **3. View Incoming Packages:** Display all packages currently in the `incomingQueue` in their current order. If the queue is empty, indicate that the queue is empty. To achieve this without removing elements from the queue, you should create a temporary copy of the queue's contents into an `ArrayList` and iterate through that list. Explicitly use the `java.util.List` interface when referencing this temporary list.
 *     *   **4. View Processed Packages:** Display all packages currently in the `processedPackages` list. If the list is empty, indicate that no packages have been processed yet. Explicitly use the `java.util.List` interface when iterating through this list.
 *     *   **5. Exit:** Terminate the application gracefully.
 * 
 * 3.  **Required Java Components:** Your solution *must* demonstrate the correct usage of ALL of the following Java components:
 *     *   `java.util.Queue`
 *     *   `java.util.ArrayList`
 *     *   `java.util.List` (used as a type/interface)
 *     *   `java.util.Scanner` (for reading user input from the console)
 *     *   `switch` statement (for controlling the flow based on the user's menu choice)
 *     *   `System.err` (for displaying all error messages)
 *     *   `System.out` (for displaying the menu, prompts, successful operation messages, and list contents)
 *     *   Class-wide exception handling with `try-catch` blocks (Wrap the main application loop or core logic in a `try-catch` block to handle potential unexpected runtime exceptions. Additionally, include specific handling for expected input errors, such as non-integer input for the menu choice).
 * 
 * 4.  **Best Practices:**
 *     *   Implement proper encapsulation by making fields private and providing public methods only where necessary.
 *     *   Use meaningful variable, method, and class names that clearly describe their purpose.
 *     *   Include appropriate comments and documentation (e.g., Javadoc for classes and methods, inline comments for complex logic if any).
 *     *   Perform input validation as specified in the functionality requirements.
 *     *   Implement proper error handling for invalid operations (like processing from an empty queue) and invalid input.
 *     *   Structure your code clearly with separate methods for different tasks (e.g., displaying menu, handling specific actions).
 * 
 * **Expected Output:**
 * 
 * The program should continuously display the menu, prompt the user for input, and execute the chosen action. Output should be clear and informative, using `System.out` for normal messages and `System.err` for errors. List views should present packages in a readable format.
 * 
 * Example Interaction Snippet:
 * ```
 * Distribution Center Menu:
 * 1. Add New Package
 * 2. Process Next Package
 * 3. View Incoming Packages
 * 4. View Processed Packages
 * 5. Exit
 * Enter your choice: 1
 * Enter Package ID: PKG001
 * Enter Destination: Los Angeles
 * Success: Package added to incoming queue -> Package [ID=PKG001, Destination=Los Angeles]
 * 
 * Distribution Center Menu:
 * ...
 * Enter your choice: 3
 * --- Incoming Packages ---
 * 1. Package [ID=PKG001, Destination=Los Angeles]
 * -------------------------
 * 
 * Distribution Center Menu:
 * ...
 * Enter your choice: 2
 * Processed package: Package [ID=PKG001, Destination=Los Angeles]
 * 
 * Distribution Center Menu:
 * ...
 * Enter your choice: 4
 * --- Processed Packages ---
 * 1. Package [ID=PKG001, Destination=Los Angeles]
 * --------------------------
 * 
 * Distribution Center Menu:
 * ...
 * Enter your choice: 2
 * Incoming queue is empty. No packages to process.
 * 
 * Distribution Center Menu:
 * ...
 * Enter your choice: abc
 * Invalid input. Please enter a number.
 * 
 * Distribution Center Menu:
 * ...
 * Enter your choice: 6
 * Invalid choice. Please enter a number between 1 and 5.
 * 
 * Distribution Center Menu:
 * ...
 * Enter your choice: 5
 * Exiting Distribution Center system. Goodbye!
 * Scanner closed.
 * ```
 * Your solution should be presented as a single block of Java code containing all necessary classes.
 *
 * EXPLANATION:
 * The provided solution implements a simple Distribution Center package management system, demonstrating the required Java concepts and best practices.
 * 
 * 1.  **`Package` Class:**
 *     *   A simple class `Package` is defined with private fields `id` and `destination`.
 *     *   It includes a constructor to initialize these fields, public getter methods (`getId`, `getDestination`) for accessing the data, and an overridden `toString()` method for easy printing of package details.
 *     *   This adheres to the requirement of proper encapsulation.
 * 
 * 2.  **`DistributionCenter` Class:**
 *     *   This is the main class containing the application logic.
 *     *   **Data Structures:** It uses a `private Queue<Package> incomingQueue` initialized with a `LinkedList` instance. `LinkedList` is a common implementation of `Queue` that provides FIFO behavior. It also uses a `private List<Package> processedPackages` initialized with an `ArrayList` instance. `ArrayList` implements the `List` interface and is suitable for storing processed packages in a dynamic array structure. The use of `List` as the type for `processedPackages` fulfills the requirement to use the `List` interface.
 *     *   **Functionality Methods:**
 *         *   `addPackage(Package p)`: A private helper method to add a package to the `incomingQueue` using the `offer()` method, which is generally preferred for queues as it handles capacity constraints gracefully (though `LinkedList` is unbounded).
 *         *   `processNextPackage()`: Removes the head of the `incomingQueue` using `poll()`. `poll()` returns `null` if the queue is empty, allowing for easy checking of the empty condition. If a package is retrieved, it's added to the `processedPackages` `ArrayList` (referenced as a `List`). An error message is printed to `System.err` if the queue is empty.
 *         *   `viewIncomingPackages()`: Displays the contents of the `incomingQueue`. To do this without altering the queue, a new `ArrayList` is created using the queue's contents (`new ArrayList<>(this.incomingQueue)`). This temporary list is then iterated through using a `List` reference (`List<Package> queueList`), fulfilling the requirement to use `ArrayList` and the `List` interface for viewing the queue's state. Output is directed to `System.out`.
 *         *   `viewProcessedPackages()`: Displays the contents of the `processedPackages` list. Since `processedPackages` is already an `ArrayList` referenced by the `List` interface type, it's directly iterated using a `List` reference (`List<Package> processedList`). Output is directed to `System.out`.
 *         *   `displayMenu()`: A simple method to print the menu options to `System.out`.
 *         *   `handleAddPackageInput(Scanner scanner)`: Handles the specific input process for adding a package, including prompting the user and performing validation (checking for empty ID/Destination after trimming whitespace). Uses `System.out` for prompts and success messages, and `System.err` for validation errors.
 *     *   **`run()` Method:** This is the core of the application logic.
 *         *   It initializes a `Scanner` for reading console input.
 *         *   It contains a `while` loop that continues until the `running` flag is set to `false` (by choosing option 5).
 *         *   **Class-wide Exception Handling:** The entire `while` loop is wrapped in a `try-catch(Exception e)` block. This fulfills the requirement for class-wide exception handling, catching any unexpected runtime errors that might occur during the execution of the menu actions. An error message is printed to `System.err`.
 *         *   **Input Handling and `switch`:** Inside the loop, the menu is displayed (`System.out`). User input is read using `scanner.nextLine()` to avoid common issues when mixing `nextInt()` and `nextLine()`. A nested `try-catch(NumberFormatException e)` is used specifically to handle cases where the user enters non-integer input for the menu choice. An error message is printed to `System.err`, and `continue` skips to the next loop iteration. A `switch` statement is used to direct execution based on the valid integer choice, calling the appropriate methods or setting the `running` flag for exit. This fulfills the `Scanner`, `switch`, `System.out`, and `System.err` requirements.
 *         *   **`finally` Block:** A `finally` block ensures that the `Scanner` resource is closed properly when the `try` block is exited (either normally or due to an exception), preventing resource leaks.
 *     *   **`main()` Method:** The entry point of the application. It creates a `DistributionCenter` object and calls its `run()` method to start the system.
 * 
 * 3.  **Best Practices:**
 *     *   Encapsulation is maintained with private fields and controlled access via methods.
 *     *   Names are descriptive (`incomingQueue`, `processNextPackage`, `handleAddPackageInput`).
 *     *   Javadoc comments are included for classes and methods, explaining their purpose and parameters.
 *     *   Input validation is performed for package details and menu choices.
 *     *   Error handling is implemented for empty queues, invalid input format, invalid menu choices, and potential unexpected exceptions, using `System.err` for error output.
 *     *   The code is structured into logical methods, improving readability and maintainability.
 * 
 * This solution effectively integrates all specified Java components (`Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.err`, `System.out`, `try-catch`) within a practical scenario, demonstrating advanced understanding of collection usage, input handling, control flow, and robust error management in Java.
 */

import java.util.Queue;
import java.util.LinkedList;
import java.util.List;
import java.util.ArrayList;
import java.util.Scanner;

/**
 * Represents a package with an ID and destination.
 */
class Package {
    private String id;
    private String destination;

    /**
     * Constructs a new Package.
     *
     * @param id The unique identifier for the package.
     * @param destination The destination address for the package.
     */
    public Package(String id, String destination) {
        this.id = id;
        this.destination = destination;
    }

    /**
     * Gets the package ID.
     *
     * @return The package ID.
     */
    public String getId() {
        return id;
    }

    /**
     * Gets the package destination.
     *
     * @return The package destination.
     */
    public String getDestination() {
        return destination;
    }

    /**
     * Returns a string representation of the Package.
     *
     * @return String representation.
     */
    @Override
    public String toString() {
        return "Package [ID=" + id + ", Destination=" + destination + "]";
    }
}

/**
 * Manages package flow through a distribution center using a queue and a list.
 * Provides a console interface for user interaction.
 */
public class DistributionCenter {

    private Queue<Package> incomingQueue;
    private List<Package> processedPackages; // Using List interface, implemented by ArrayList

    /**
     * Constructs a new DistributionCenter.
     * Initializes the incoming queue and processed packages list.
     */
    public DistributionCenter() {
        // Use LinkedList as an implementation of Queue
        this.incomingQueue = new LinkedList<>();
        // Use ArrayList as an implementation of List
        this.processedPackages = new ArrayList<>();
    }

    /**
     * Adds a package to the incoming queue.
     * Private helper method used by handleAddPackageInput.
     *
     * @param p The package to add.
     */
    private void addPackage(Package p) {
        if (p != null) {
            this.incomingQueue.offer(p); // offer is generally preferred over add for queues
        }
    }

    /**
     * Processes the next package from the incoming queue.
     * Removes the package from the queue and adds it to the processed list.
     * Displays success or error message.
     */
    private void processNextPackage() {
        Package processed = this.incomingQueue.poll(); // poll returns null if queue is empty
        if (processed != null) {
            this.processedPackages.add(processed);
            System.out.println("Processed package: " + processed);
        } else {
            System.err.println("Incoming queue is empty. No packages to process.");
        }
    }

    /**
     * Displays all packages currently in the incoming queue.
     * Uses a temporary List to iterate without modifying the queue.
     */
    private void viewIncomingPackages() {
        System.out.println("--- Incoming Packages ---");
        if (this.incomingQueue.isEmpty()) {
            System.out.println("Queue is empty.");
        } else {
            // Create a temporary List from the queue to iterate and display
            // This demonstrates using ArrayList and List interface together
            List<Package> queueList = new ArrayList<>(this.incomingQueue);
            for (int i = 0; i < queueList.size(); i++) {
                System.out.println((i + 1) + ". " + queueList.get(i));
            }
        }
        System.out.println("-------------------------");
    }

    /**
     * Displays all packages that have been processed.
     * Explicitly uses the List interface reference.
     */
    private void viewProcessedPackages() {
        System.out.println("--- Processed Packages ---");
        if (this.processedPackages.isEmpty()) {
            System.out.println("No packages have been processed yet.");
        } else {
            // processedPackages is already a List<Package> (ArrayList)
            List<Package> processedList = this.processedPackages; // Using List interface reference
            for (int i = 0; i < processedList.size(); i++) {
                 System.out.println((i + 1) + ". " + processedList.get(i));
            }
        }
        System.out.println("--------------------------");
    }

    /**
     * Displays the main menu options to the console.
     * Uses System.out.
     */
    private void displayMenu() {
        System.out.println("Distribution Center Menu:");
        System.out.println("1. Add New Package");
        System.out.println("2. Process Next Package");
        System.out.println("3. View Incoming Packages");
        System.out.println("4. View Processed Packages");
        System.out.println("5. Exit");
    }

    /**
     * Handles user input specifically for adding a new package.
     * Performs input validation.
     *
     * @param scanner The Scanner object to read input from.
     */
    private void handleAddPackageInput(Scanner scanner) {
        System.out.print("Enter Package ID: ");
        String id = scanner.nextLine().trim(); // Read line and trim whitespace
        System.out.print("Enter Destination: ");
        String destination = scanner.nextLine().trim(); // Read line and trim whitespace

        // Input validation: Check if ID or Destination are empty after trimming
        if (id.isEmpty()) {
            System.err.println("Error: Package ID cannot be empty.");
            return; // Stop processing this add request
        }
         if (destination.isEmpty()) {
            System.err.println("Error: Package Destination cannot be empty.");
            return; // Stop processing this add request
        }

        Package newPackage = new Package(id, destination);
        addPackage(newPackage); // Call the internal add method
        System.out.println("Success: Package added to incoming queue -> " + newPackage);
    }

    /**
     * Runs the main application loop, handling user interactions.
     * Includes class-wide exception handling and input-specific error handling.
     * Uses Scanner, switch, System.out, System.err, try-catch.
     */
    public void run() {
        Scanner scanner = new Scanner(System.in);
        boolean running = true;

        // Class-wide exception handling block wrapping the main operational loop
        try {
            while (running) {
                displayMenu();
                System.out.print("Enter your choice: ");

                int choice = -1;
                try {
                    // Read the entire line to handle potential non-integer input gracefully
                    String inputLine = scanner.nextLine();
                    choice = Integer.parseInt(inputLine);
                } catch (NumberFormatException e) {
                    // Handle non-integer input specifically using System.err
                    System.err.println("Invalid input. Please enter a number.");
                    continue; // Skip the rest of the loop and show menu again
                }

                // Use switch statement for flow control based on user choice
                switch (choice) {
                    case 1:
                        handleAddPackageInput(scanner); // Delegate input handling
                        break;
                    case 2:
                        processNextPackage(); // Process the next package in the queue
                        break;
                    case 3:
                        viewIncomingPackages(); // Display contents of the incoming queue
                        break;
                    case 4:
                        viewProcessedPackages(); // Display contents of the processed list
                        break;
                    case 5:
                        running = false; // Set flag to exit loop
                        System.out.println("Exiting Distribution Center system. Goodbye!");
                        break;
                    default:
                        // Handle choices outside the valid range using System.err
                        System.err.println("Invalid choice. Please enter a number between 1 and 5.");
                }
                System.out.println(); // Add a newline for better separation between actions
            }
        } catch (Exception e) {
            // Catch any other unexpected exceptions that might occur within the main loop
            // This provides class-wide handling for unforeseen errors
            System.err.println("An unexpected system error occurred: " + e.getMessage());
            // e.printStackTrace(); // Uncomment for debugging purposes
        } finally {
            // Ensure the scanner resource is closed properly regardless of how the try block exits
            if (scanner != null) {
                scanner.close();
            }
            // System.out.println("Scanner closed."); // Optional confirmation
        }
    }

    /**
     * Main method to start the Distribution Center application.
     *
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        DistributionCenter center = new DistributionCenter();
        center.run(); // Start the main application loop
    }
}
