/*
 * Exam Question #905
 * Generated on: 2025-05-12 16:57:37
 * Generated by: Account 4
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Advanced Task Management System
 * 
 * **Scenario:**
 * 
 * A small team needs a simple console-based tool to manage their tasks. The tool should allow users to add new tasks, view all tasks, see which tasks are currently pending and next in line for processing, mark tasks as completed, and exit the application.
 * 
 * You are required to implement this system in Java, demonstrating your understanding of core data structures, object-oriented principles, user interaction, and robust error handling.
 * 
 * **Requirements:**
 * 
 * 1.  **Implement the core logic:** Create a Java program that simulates the task management system.
 * 2.  **Task Representation:** Define a class `Task` to represent a single task. Each task should have:
 *     *   A unique integer ID.
 *     *   A description (String).
 *     *   A priority level (e.g., HIGH, MEDIUM, LOW).
 *     *   A status (PENDING, COMPLETED).
 * 3.  **Task Manager:** Define a class `TaskManager` responsible for managing the collection of tasks. This class should contain:
 *     *   A collection to store *all* tasks ever created.
 *     *   A collection to manage tasks that are currently *pending* and potentially in a specific processing order.
 *     *   Methods for adding, viewing, and completing tasks.
 * 4.  **User Interface:** Implement a command-line interface using `java.util.Scanner` to interact with the user. The program should present a menu of options:
 *     *   Add New Task
 *     *   View All Tasks
 *     *   View Pending Tasks
 *     *   Mark Task as Completed
 *     *   Exit
 * 5.  **Data Structures:** You *must* use the following Java collections:
 *     *   `java.util.Queue` to manage the *pending* tasks. Tasks should be added to this queue when created. When a task is completed, it should be removed from this queue. The queue should process tasks in a standard FIFO order (using a suitable implementation like `LinkedList`).
 *     *   `java.util.ArrayList` as the concrete implementation for a `java.util.List` which stores *all* tasks (both pending and completed) for historical viewing.
 *     *   `java.util.List` as the declared type for the collection storing all tasks within the `TaskManager`.
 * 6.  **Control Flow:** Use a `switch` statement to handle the user's menu choice.
 * 7.  **Input/Output:**
 *     *   Use `System.out` for displaying the menu, task lists, and success messages.
 *     *   Use `System.err` for displaying all error messages (e.g., invalid input, task not found).
 * 8.  **Error Handling:**
 *     *   Implement input validation for user inputs (e.g., ensuring priority is valid, ensuring task ID for completion is a valid number).
 *     *   Handle cases where a user tries to complete a non-existent task or a task that is already completed.
 *     *   Implement **class-wide exception handling** using `try-catch` blocks to gracefully handle unexpected runtime errors that might occur during program execution (e.g., wrap the main program loop or core logic).
 * 9.  **Best Practices:**
 *     *   Employ proper encapsulation (private fields, public methods/getters).
 *     *   Use meaningful variable and method names.
 *     *   Include appropriate comments and documentation (e.g., Javadoc for classes/methods).
 *     *   Ensure clean code structure and logical separation of concerns (e.g., separate `Task` and `TaskManager` classes).
 * 
 * **Expected Output:**
 * 
 * The program should display a menu, prompt for input, and provide output based on the user's choice. Error messages should be clearly distinguishable using `System.err`.
 * 
 * Example Interaction Snippet:
 * 
 * ```
 * --- Task Management System ---
 * 1. Add New Task
 * 2. View All Tasks
 * 3. View Pending Tasks
 * 4. Mark Task as Completed
 * 5. Exit
 * Enter your choice: 1
 * Enter task description: Implement Task Class
 * Enter priority (HIGH, MEDIUM, LOW): HIGH
 * Task added with ID: 1
 * 
 * --- Task Management System ---
 * ...
 * Enter your choice: 1
 * Enter task description: Create Exam Question
 * Enter priority (HIGH, MEDIUM, LOW): medium
 * Task added with ID: 2
 * 
 * --- Task Management System ---
 * ...
 * Enter your choice: 3
 * --- Pending Tasks ---
 * [Task ID: 1, Description: Implement Task Class, Priority: HIGH, Status: PENDING]
 * [Task ID: 2, Description: Create Exam Question, Priority: MEDIUM, Status: PENDING]
 * 
 * --- Task Management System ---
 * ...
 * Enter your choice: 4
 * Enter Task ID to complete: 1
 * Task with ID 1 marked as completed.
 * 
 * --- Task Management System ---
 * ...
 * Enter your choice: 3
 * --- Pending Tasks ---
 * [Task ID: 2, Description: Create Exam Question, Priority: MEDIUM, Status: PENDING]
 * 
 * --- Task Management System ---
 * ...
 * Enter your choice: 4
 * Enter Task ID to complete: 99
 * Error: Task with ID 99 not found.
 * 
 * --- Task Management System ---
 * ...
 * Enter your choice: 4
 * Enter Task ID to complete: 1
 * Error: Task with ID 1 is already completed.
 * 
 * --- Task Management System ---
 * ...
 * Enter your choice: 5
 * Exiting Task Management System.
 * ```
 * 
 * Your solution should compile and run, providing the described functionality while adhering to all specified requirements.
 *
 * EXPLANATION:
 * This solution implements a simple console-based Task Management System, demonstrating the required Java concepts and best practices.
 * 
 * **1. Task Representation (`Task` Class):**
 * - The `Task` class encapsulates the data for a single task: `id`, `description`, `priority`, and `status`.
 * - It uses enums (`Priority`, `Status`) for type safety and readability.
 * - Fields are `private`, and public getter methods provide controlled access, adhering to encapsulation.
 * - `markCompleted()` is a public method to change the status, demonstrating object behavior.
 * - `toString()` is overridden for easy printing of task details.
 * - `equals()` and `hashCode()` are overridden based on the task `id`. This is crucial because `Queue.remove(Object)` (used in `completeTask`) relies on the `equals()` method to find and remove the correct task object from the queue.
 * 
 * **2. Task Manager (`TaskManager` Class):**
 * - The `TaskManager` class manages the collections of tasks.
 * - It uses a `java.util.List<Task>` named `allTasks` (implemented with `ArrayList`) to store every task created. This list serves as a historical record.
 * - It uses a `java.util.Queue<Task>` named `pendingTasksQueue` (implemented with `LinkedList`) to store only the tasks that are currently pending. When a task is added, it's offered to the queue (`offer()`). When a task is completed, it's removed from the queue (`remove()`). The queue represents tasks that are active and waiting for completion, processed in FIFO order as typical for `LinkedList` used as a Queue.
 * - `nextTaskId` is a private counter ensuring unique IDs.
 * - `addTask()` creates a new `Task` object, adds it to both `allTasks` and `pendingTasksQueue`, and increments the ID counter.
 * - `getAllTasks()` provides access to the full list.
 * - `getPendingTasksQueue()` provides access to the queue of pending tasks. Note that iterating directly over the queue (as done in `main` for viewing) does not remove elements.
 * - `completeTask()` searches `allTasks` for the task by ID. It validates if the task exists and is pending before marking it completed. It then attempts to remove the completed task object from the `pendingTasksQueue` using `remove(Object)`, which works correctly because `Task.equals()` is defined based on ID.
 * 
 * **3. User Interface and Control Flow (`TaskManagementSystem.main`):**
 * - The `main` method in `TaskManagementSystem` provides the command-line interface.
 * - `java.util.Scanner` is used to read user input. `scanner.nextLine()` is used consistently to avoid issues with leftover newlines.
 * - A `while` loop keeps the program running until the user chooses to exit.
 * - A `switch` statement handles the different menu options, directing the program flow based on user input.
 * 
 * **4. Input/Output and Error Handling:**
 * - `System.out.println()` is used for displaying the menu, task lists, and success messages, fulfilling the requirement for normal output.
 * - `System.err.println()` is used for all error messages (invalid choice, invalid priority, task not found/already completed), fulfilling the requirement for error output.
 * - **Input Validation:**
 *     - For the menu choice and task ID for completion, `Integer.parseInt()` is used within a `try-catch(NumberFormatException)` block to handle non-numeric input gracefully, printing an error to `System.err`.
 *     - For priority input, `Priority.valueOf()` is used within a `try-catch(IllegalArgumentException)` block to validate the input string against the enum values, prompting the user again until valid input is received.
 * - **Business Logic Error Handling:** `completeTask` checks if the task exists and if it's already completed, printing specific error messages to `System.err` and returning `false`.
 * - **Class-wide Exception Handling:** The core `while` loop in `main` is wrapped in a `try-catch(Exception e)` block. This block catches any unexpected runtime exceptions that might occur anywhere within the loop's execution, preventing the program from crashing abruptly. It prints a generic error message and the exception's stack trace to `System.err`, demonstrating robust handling of unforeseen issues.
 * - A `finally` block is used to ensure the `Scanner` is closed when the program exits or an unexpected exception occurs.
 * 
 * **5. Best Practices:**
 * - **Encapsulation:** Clearly demonstrated in the `Task` and `TaskManager` classes.
 * - **Meaningful Names:** Classes (`Task`, `TaskManager`, `TaskManagementSystem`), methods (`addTask`, `completeTask`, `printMenu`), variables (`allTasks`, `pendingTasksQueue`, `nextTaskId`, `description`, `priorityInput`), and enums (`Priority`, `Status`) have names reflecting their purpose.
 * - **Comments and Documentation:** Javadoc comments are included for classes and key methods, explaining their purpose, parameters, and return values. Inline comments clarify specific logic points.
 * - **Clean Code Structure:** The code is organized into logical classes, and the `main` method orchestrates the interaction without containing the core task management logic, which resides in `TaskManager`.
 * 
 * This solution effectively integrates the required Java components (`Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.err`, `System.out`, `try-catch`) into a practical, well-structured application that includes essential error handling and follows object-oriented design principles.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.NoSuchElementException; // Required for queue operations that might fail

// Enum for Task Priority
enum Priority {
    HIGH, MEDIUM, LOW
}

// Enum for Task Status
enum Status {
    PENDING, COMPLETED
}

/**
 * Represents a single task in the Task Management System.
 */
class Task {
    private int id;
    private String description;
    private Priority priority;
    private Status status;

    /**
     * Constructs a new Task.
     *
     * @param id The unique ID for the task.
     * @param description The description of the task.
     * @param priority The priority level of the task.
     */
    public Task(int id, String description, Priority priority) {
        this.id = id;
        this.description = description;
        this.priority = priority;
        this.status = Status.PENDING; // New tasks are always pending
    }

    // --- Getters ---
    public int getId() {
        return id;
    }

    public String getDescription() {
        return description;
    }

    public Priority getPriority() {
        return priority;
    }

    public Status getStatus() {
        return status;
    }

    /**
     * Marks the task as completed.
     */
    public void markCompleted() {
        this.status = Status.COMPLETED;
    }

    @Override
    public String toString() {
        return String.format("[Task ID: %d, Description: %s, Priority: %s, Status: %s]",
                             id, description, priority, status);
    }

    // Needed for Queue.remove(Object) which uses equals()
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Task task = (Task) o;
        return id == task.id;
    }

    @Override
    public int hashCode() {
        return Integer.hashCode(id);
    }
}

/**
 * Manages a collection of tasks.
 */
class TaskManager {
    // List to store all tasks (both pending and completed)
    private List<Task> allTasks;
    // Queue to manage tasks that are currently pending and active
    private Queue<Task> pendingTasksQueue;
    private int nextTaskId; // Counter for unique task IDs

    /**
     * Constructs a new TaskManager.
     */
    public TaskManager() {
        // Use ArrayList as the implementation for the List interface
        this.allTasks = new ArrayList<>();
        // Use LinkedList as the implementation for the Queue interface
        this.pendingTasksQueue = new LinkedList<>();
        this.nextTaskId = 1; // Start task IDs from 1
    }

    /**
     * Adds a new task to the system.
     *
     * @param description The description of the new task.
     * @param priority    The priority of the new task.
     * @return The ID of the newly created task.
     */
    public int addTask(String description, Priority priority) {
        Task newTask = new Task(nextTaskId, description, priority);
        allTasks.add(newTask);
        pendingTasksQueue.offer(newTask); // Add to the end of the pending queue
        System.out.println("Task added with ID: " + nextTaskId);
        return nextTaskId++; // Increment for the next task
    }

    /**
     * Returns a list of all tasks in the system.
     *
     * @return A List containing all tasks.
     */
    public List<Task> getAllTasks() {
        return allTasks; // Returning the internal list reference for simplicity in exam context
    }

    /**
     * Returns the queue of pending tasks.
     *
     * @return The Queue containing pending tasks.
     */
    public Queue<Task> getPendingTasksQueue() {
        return pendingTasksQueue; // Returning the internal queue reference
    }

    /**
     * Marks a task as completed.
     *
     * @param taskId The ID of the task to complete.
     * @return true if the task was found and marked completed, false otherwise.
     */
    public boolean completeTask(int taskId) {
        Task taskToComplete = null;
        // Find the task in the list of all tasks
        for (Task task : allTasks) {
            if (task.getId() == taskId) {
                taskToComplete = task;
                break;
            }
        }

        if (taskToComplete == null) {
            System.err.println("Error: Task with ID " + taskId + " not found.");
            return false;
        }

        if (taskToComplete.getStatus() == Status.COMPLETED) {
            System.err.println("Error: Task with ID " + taskId + " is already completed.");
            return false;
        }

        // Mark the task as completed in the main list
        taskToComplete.markCompleted();

        // Remove the task from the pending queue
        // LinkedList's remove(Object) works based on equals(), which we've overridden based on ID
        boolean removedFromQueue = pendingTasksQueue.remove(taskToComplete);

        if (removedFromQueue) {
             System.out.println("Task with ID " + taskId + " marked as completed and removed from pending queue.");
        } else {
             // This case ideally shouldn't happen if logic is correct, but good for robustness
             System.err.println("Warning: Task with ID " + taskId + " marked completed, but was not found in the pending queue.");
        }


        return true;
    }
}

/**
 * Main class to run the Task Management System.
 */
public class TaskManagementSystem {

    public static void main(String[] args) {
        TaskManager manager = new TaskManager();
        Scanner scanner = new Scanner(System.in);
        boolean running = true;

        // Class-wide exception handling for the main program loop
        try {
            while (running) {
                printMenu();
                System.out.print("Enter your choice: ");
                String choiceInput = scanner.nextLine(); // Read choice as line to handle non-integer input gracefully

                int choice = -1;
                try {
                    choice = Integer.parseInt(choiceInput);
                } catch (NumberFormatException e) {
                    System.err.println("Invalid input. Please enter a number.");
                    continue; // Ask for input again
                }

                // Use switch statement for flow control
                switch (choice) {
                    case 1: // Add New Task
                        System.out.print("Enter task description: ");
                        String description = scanner.nextLine();

                        Priority priority = null;
                        boolean validPriority = false;
                        while (!validPriority) {
                            System.out.print("Enter priority (HIGH, MEDIUM, LOW): ");
                            String priorityInput = scanner.nextLine().toUpperCase();
                            try {
                                priority = Priority.valueOf(priorityInput);
                                validPriority = true;
                            } catch (IllegalArgumentException e) {
                                System.err.println("Invalid priority. Please use HIGH, MEDIUM, or LOW.");
                            }
                        }
                        manager.addTask(description, priority);
                        break;

                    case 2: // View All Tasks
                        System.out.println("\n--- All Tasks ---");
                        List<Task> allTasks = manager.getAllTasks();
                        if (allTasks.isEmpty()) {
                            System.out.println("No tasks available.");
                        } else {
                            for (Task task : allTasks) {
                                System.out.println(task);
                            }
                        }
                        break;

                    case 3: // View Pending Tasks
                        System.out.println("\n--- Pending Tasks ---");
                        Queue<Task> pendingTasks = manager.getPendingTasksQueue();
                        if (pendingTasks.isEmpty()) {
                            System.out.println("No pending tasks.");
                        } else {
                            // Iterate through the queue without removing elements
                            for (Task task : pendingTasks) {
                                System.out.println(task);
                            }
                            // Or process the queue (e.g., peek at the next task)
                            // Task nextTask = pendingTasks.peek();
                            // if (nextTask != null) {
                            //     System.out.println("Next task in queue: " + nextTask);
                            // }
                        }
                        break;

                    case 4: // Mark Task as Completed
                        System.out.print("Enter Task ID to complete: ");
                        String taskIdInput = scanner.nextLine();

                        int taskId = -1;
                        try {
                            taskId = Integer.parseInt(taskIdInput);
                        } catch (NumberFormatException e) {
                            System.err.println("Invalid Task ID format. Please enter a number.");
                            break; // Go back to menu
                        }

                        manager.completeTask(taskId);
                        break;

                    case 5: // Exit
                        System.out.println("Exiting Task Management System.");
                        running = false;
                        break;

                    default: // Invalid choice
                        System.err.println("Invalid choice. Please enter a number between 1 and 5.");
                        break;
                }
                System.out.println(); // Add a blank line for readability
            }
        } catch (Exception e) {
            // Catch any unexpected exceptions during the main execution flow
            System.err.println("An unexpected error occurred:");
            e.printStackTrace(System.err); // Print stack trace to System.err
        } finally {
            // Ensure the scanner is closed
            scanner.close();
            System.out.println("System shutdown complete.");
        }
    }

    /**
     * Prints the main menu options to the console.
     */
    private static void printMenu() {
        System.out.println("--- Task Management System ---");
        System.out.println("1. Add New Task");
        System.out.println("2. View All Tasks");
        System.out.println("3. View Pending Tasks");
        System.out.println("4. Mark Task as Completed");
        System.out.println("5. Exit");
    }
}
