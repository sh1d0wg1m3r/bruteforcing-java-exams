/*
 * Exam Question #739
 * Generated on: 2025-05-12 16:33:39
 * Generated by: Account 4
 * 
 * QUESTION:
 * ## Advanced Java Programming Exam Task: Restaurant Order Management System
 * 
 * **Scenario:**
 * 
 * You are tasked with developing a simple command-line based system for a small restaurant to manage customer orders. The system should allow staff to view the menu, place new orders (which can contain multiple items), process the next pending order, and view the queue of waiting orders.
 * 
 * **Requirements:**
 * 
 * 1.  **Core Functionality:**
 *     *   Maintain a fixed menu of items (Name, Price).
 *     *   Allow placing orders. Each order consists of one or more menu items with specified quantities.
 *     *   Process the oldest pending order in a First-In, First-Out (FIFO) manner.
 *     *   Display the current menu.
 *     *   Display the list of orders currently waiting to be processed.
 *     *   Exit the application.
 * 2.  **Data Structures:**
 *     *   Use `java.util.List` (specifically `java.util.ArrayList`) to store the restaurant's menu.
 *     *   Use `java.util.Queue` to store pending customer orders.
 * 3.  **Input/Output:**
 *     *   Use `java.util.Scanner` to read user input from the console (menu choices, item selections, quantities).
 *     *   Use `System.out` for all normal output (prompts, menu display, order details, success messages, queue status).
 *     *   Use `System.err` for displaying error messages (e.g., invalid input, attempting to process an empty queue).
 * 4.  **Control Flow:**
 *     *   Use a `switch` statement to handle the main menu selections (Place Order, Process Order, View Menu, View Queue, Exit).
 * 5.  **Error Handling:**
 *     *   Implement class-wide exception handling using `try-catch` blocks to gracefully handle potential runtime errors, particularly related to user input (e.g., non-integer input when an integer is expected, selecting invalid menu item indices). The system should not crash due to invalid user input.
 * 6.  **Best Practices:**
 *     *   Design appropriate classes (`MenuItem`, `OrderItem`, `Order`, `RestaurantOrderSystem`).
 *     *   Employ proper encapsulation (private fields, public getters/methods).
 *     *   Use meaningful variable and method names.
 *     *   Include relevant comments and documentation (basic Javadoc or inline comments).
 *     *   Implement input validation (e.g., check if selected menu item index is valid, check if quantity is positive).
 *     *   Ensure clean code structure and formatting.
 * 
 * **Classes to Consider (Recommended Structure):**
 * 
 * *   `MenuItem`: Represents an item on the menu (e.g., `String name`, `double price`).
 * *   `OrderItem`: Represents a specific item *within* an order (e.g., `MenuItem item`, `int quantity`). Should calculate its own subtotal.
 * *   `Order`: Represents a customer order (e.g., `int orderId`, `List<OrderItem> items`). Should have methods to add items and calculate the total price.
 * *   `RestaurantOrderSystem`: The main class containing the `main` method and managing the menu (`List<MenuItem>`) and the order queue (`Queue<Order>`). Contains the main application loop and logic for placing/processing orders.
 * 
 * **User Interaction Flow:**
 * 
 * The program should present a main menu:
 * 1. Place New Order
 * 2. Process Next Order
 * 3. View Menu
 * 4. View Pending Orders
 * 5. Exit
 * 
 * Based on the user's integer input, the `switch` statement should direct execution to the corresponding functionality. Input validation and error handling are crucial at each step where user input is involved.
 * 
 * **Expected Output Examples:**
 * 
 * ```
 * --- Restaurant Order Management ---
 * 1. Place New Order
 * 2. Process Next Order
 * 3. View Menu
 * 4. View Pending Orders
 * 5. Exit
 * Enter your choice: 3
 * --- Menu ---
 * 1. Burger - $5.99
 * 2. Fries - $2.49
 * 3. Soda - $1.99
 * 
 * --- Restaurant Order Management ---
 * 1. Place New Order
 * 2. Process Next Order
 * 3. View Menu
 * 4. View Pending Orders
 * 5. Exit
 * Enter your choice: 1
 * --- Menu ---
 * 1. Burger - $5.99
 * 2. Fries - $2.49
 * 3. Soda - $1.99
 * Enter item number to add (0 to finish order): 1
 * Enter quantity: 2
 * Add another item? (yes/no): yes
 * --- Menu ---
 * 1. Burger - $5.99
 * 2. Fries - $2.49
 * 3. Soda - $1.99
 * Enter item number to add (0 to finish order): 3
 * Enter quantity: 3
 * Add another item? (yes/no): no
 * Order #1 placed successfully! Total: $17.95
 * 
 * --- Restaurant Order Management ---
 * 1. Place New Order
 * 2. Process Next Order
 * 3. View Menu
 * 4. View Pending Orders
 * 5. Exit
 * Enter your choice: 4
 * --- Pending Orders ---
 * Order #1 (Items: 2, Total: $17.95)
 * 
 * --- Restaurant Order Management ---
 * 1. Place New Order
 * 2. Process Next Order
 * 3. View Menu
 * 4. View Pending Orders
 * 5. Exit
 * Enter your choice: 2
 * Processing Order #1...
 * Details:
 *   2 x Burger ($5.99 each)
 *   3 x Soda ($1.99 each)
 * Total: $17.95
 * 
 * --- Restaurant Order Management ---
 * 1. Place New Order
 * 2. Process Next Order
 * 3. View Menu
 * 4. View Pending Orders
 * 5. Exit
 * Enter your choice: 2
 * Error: No orders currently pending.
 * ```
 * *(Note: Error messages should go to `System.err`)*
 * 
 * **Evaluation:**
 * 
 * Your solution will be evaluated on:
 * *   Correctness of implementation based on requirements.
 * *   Proper usage of `Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.err`, `System.out`, and `try-catch`.
 * *   Adherence to object-oriented principles (encapsulation, class design).
 * *   Quality of input validation and error handling.
 * *   Code readability, comments, and adherence to best practices.
 * 
 * You must provide the complete Java code for the solution.
 *
 * EXPLANATION:
 * This solution implements a basic Restaurant Order Management System, fulfilling all specified requirements and demonstrating advanced Java concepts.
 * 
 * 1.  **Class Structure:**
 *     *   `MenuItem`: A simple POJO (Plain Old Java Object) representing a menu item with `name` and `price`. Encapsulation is used via private fields and public getters.
 *     *   `OrderItem`: Represents a specific item *within* an order, linking a `MenuItem` to a `quantity`. It calculates its own `subtotal`. Encapsulation and a helpful `toString` method are included.
 *     *   `Order`: Represents a complete customer order. It has a unique `orderId` (managed by a static counter) and uses a `List<OrderItem>` (specifically `ArrayList`) to store the items. It provides methods to `addItem` and calculate the `total`.
 *     *   `RestaurantOrderSystem`: The main class that orchestrates the application. It holds the `menu` (`List<MenuItem>`) and the `orderQueue` (`Queue<Order>`). The `run` method contains the main application loop and `switch` statement for handling user choices.
 * 
 * 2.  **Data Structures (`List`, `ArrayList`, `Queue`):**
 *     *   `List<MenuItem> menu`: An `ArrayList` is used to store the menu items. `ArrayList` is suitable here because we need indexed access (to get a `MenuItem` by its displayed number) and the size is relatively static after initialization (though `ArrayList` is dynamic). We declare it as `List` to program to the interface.
 *     *   `Queue<Order> orderQueue`: A `LinkedList` is used to implement the `Queue` interface. `Queue` is the perfect choice for managing pending orders that should be processed in the order they were received (FIFO). `LinkedList` provides efficient additions to the end (`offer`) and removals from the beginning (`poll`).
 * 
 * 3.  **Input/Output (`Scanner`, `System.out`, `System.err`):**
 *     *   `Scanner`: Used throughout the `RestaurantOrderSystem` class to read integer choices and String inputs from the console.
 *     *   `System.out`: Used for all standard output, including displaying menus, prompts, order details, success messages, and the pending order list.
 *     *   `System.err`: Used exclusively for displaying error messages, such as invalid user input, attempting to process an empty queue, or internal unexpected errors caught by the general `try-catch`.
 * 
 * 4.  **Control Flow (`switch`):**
 *     *   The `run` method uses a `while` loop for the main application cycle. Inside the loop, a `switch` statement is used to direct execution based on the integer choice read from the `Scanner`, cleanly separating the logic for each menu option.
 * 
 * 5.  **Error Handling (`try-catch`):**
 *     *   **Input Validation:** Specific `try-catch (InputMismatchException)` blocks are used around `scanner.nextInt()` calls. If the user enters non-integer input when an integer is expected, the exception is caught, an error message is printed to `System.err`, the invalid input is consumed using `scanner.nextLine()` (crucial to prevent an infinite loop), and the user is prompted again.
 *     *   **Logic Validation:** Checks are performed for invalid states (e.g., `itemIndex` being out of bounds when selecting a menu item, `quantity` being non-positive, `orderQueue` being empty when processing). Error messages for these logical issues are also printed to `System.err`.
 *     *   **Class-wide Exception Handling:** The main `run` method's logic is wrapped in a broader `try-catch (Exception e)` block. This demonstrates a robust approach to catch any unexpected runtime errors that might occur within the main loop, printing an error message and the stack trace to `System.err` before the `finally` block ensures resources are closed.
 *     *   **`finally` block:** A `finally` block ensures that the `scanner` resource is properly closed when the `run` method finishes, regardless of whether it exits normally or due to an exception.
 * 
 * 6.  **Best Practices:**
 *     *   **Encapsulation:** All class fields are `private`, accessed via `public` getters (and setters where needed, though none are strictly required for this problem's logic).
 *     *   **Naming:** Variables (`menu`, `orderQueue`, `itemChoice`, `quantity`), methods (`displayMenu`, `placeOrder`, `processNextOrder`), and classes are named descriptively.
 *     *   **Comments/Documentation:** Basic inline comments explain key parts, and method comments (like for `addItem` and `getTotal`) explain their purpose.
 *     *   **Input Validation:** Checks for valid menu indices and positive quantities are implemented.
 *     *   **Clean Code:** The code is structured into logical methods, the main loop is clear, and error handling is integrated where needed. Using `scanner.nextLine()` after `scanner.nextInt()` is a common best practice demonstrated to consume the leftover newline character.
 * 
 * This solution effectively integrates all required components into a functional, albeit simple, system while adhering to good programming practices and robust error handling.
 */

import java.util.ArrayList;
import java.util.LinkedList; // LinkedList implements Queue
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.InputMismatchException;

// Represents a single item on the restaurant's menu
class MenuItem {
    private String name;
    private double price;

    public MenuItem(String name, double price) {
        this.name = name;
        this.price = price;
    }

    public String getName() {
        return name;
    }

    public double getPrice() {
        return price;
    }

    @Override
    public String toString() {
        return name + " - $" + String.format("%.2f", price);
    }
}

// Represents a specific item and quantity within a customer's order
class OrderItem {
    private MenuItem item;
    private int quantity;

    public OrderItem(MenuItem item, int quantity) {
        this.item = item;
        this.quantity = quantity;
    }

    public MenuItem getItem() {
        return item;
    }

    public int getQuantity() {
        return quantity;
    }

    public double getSubtotal() {
        return item.getPrice() * quantity;
    }

    @Override
    public String toString() {
        return quantity + " x " + item.getName() + " ($" + String.format("%.2f", item.getPrice()) + " each)";
    }
}

// Represents a customer's complete order
class Order {
    private static int nextOrderId = 1; // Static counter for unique order IDs

    private int orderId;
    private List<OrderItem> items; // Using List for order items

    public Order() {
        this.orderId = nextOrderId++;
        this.items = new ArrayList<>(); // Using ArrayList for order items list
    }

    public int getOrderId() {
        return orderId;
    }

    public List<OrderItem> getItems() {
        return items;
    }

    /**
     * Adds an item with a specific quantity to the order.
     * @param item The MenuItem being added.
     * @param quantity The number of this item.
     */
    public void addItem(MenuItem item, int quantity) {
        if (item != null && quantity > 0) {
            items.add(new OrderItem(item, quantity));
        } else if (quantity <= 0) {
             System.err.println("Warning: Quantity must be positive. Item not added.");
        }
        // If item is null, it implies an invalid menu selection was handled elsewhere.
    }

    /**
     * Calculates the total price of the order.
     * @return The total price.
     */
    public double getTotal() {
        double total = 0;
        for (OrderItem orderItem : items) {
            total += orderItem.getSubtotal();
        }
        return total;
    }

    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        sb.append("Order #").append(orderId).append(" (Items: ").append(items.size());
        sb.append(", Total: $").append(String.format("%.2f", getTotal())).append(")");
        return sb.toString();
    }
}

// The main class managing the restaurant system
public class RestaurantOrderSystem {

    private List<MenuItem> menu; // Using List interface, implemented by ArrayList
    private Queue<Order> orderQueue; // Using Queue interface, implemented by LinkedList
    private Scanner scanner;

    public RestaurantOrderSystem() {
        // Initialize menu using ArrayList
        menu = new ArrayList<>();
        menu.add(new MenuItem("Burger", 5.99));
        menu.add(new MenuItem("Fries", 2.49));
        menu.add(new MenuItem("Soda", 1.99));
        menu.add(new MenuItem("Pizza Slice", 3.50));
        menu.add(new MenuItem("Salad", 4.75));

        // Initialize order queue using LinkedList (implements Queue)
        orderQueue = new LinkedList<>();

        // Initialize scanner
        scanner = new Scanner(System.in);
    }

    /**
     * Displays the main menu options to the user.
     */
    private void displayMainMenu() {
        System.out.println("\n--- Restaurant Order Management ---");
        System.out.println("1. Place New Order");
        System.out.println("2. Process Next Order");
        System.out.println("3. View Menu");
        System.out.println("4. View Pending Orders");
        System.out.println("5. Exit");
        System.out.print("Enter your choice: ");
    }

    /**
     * Displays the available menu items.
     */
    private void displayMenu() {
        System.out.println("\n--- Menu ---");
        if (menu.isEmpty()) {
            System.out.println("Menu is currently empty.");
        } else {
            for (int i = 0; i < menu.size(); i++) {
                // Displaying 1-based index for user friendliness
                System.out.println((i + 1) + ". " + menu.get(i));
            }
        }
    }

    /**
     * Handles the process of placing a new order.
     * Guides the user to select items and quantities.
     */
    private void placeOrder() {
        Order currentOrder = new Order();
        System.out.println("\n--- Placing New Order ---");

        boolean addingItems = true;
        while (addingItems) {
            displayMenu();
            System.out.println("Enter item number to add (0 to finish order): ");

            int itemChoice = -1;
            try {
                itemChoice = scanner.nextInt();
                // Consume the newline character left by nextInt()
                scanner.nextLine();
            } catch (InputMismatchException e) {
                System.err.println("Error: Invalid input. Please enter a number.");
                scanner.nextLine(); // Consume the invalid input
                continue; // Restart the item selection loop
            }

            if (itemChoice == 0) {
                addingItems = false;
                break; // Exit the item selection loop
            }

            // Convert 1-based user input to 0-based list index
            int itemIndex = itemChoice - 1;

            if (itemIndex >= 0 && itemIndex < menu.size()) {
                MenuItem selectedItem = menu.get(itemIndex);

                System.out.print("Enter quantity: ");
                int quantity = -1;
                 try {
                    quantity = scanner.nextInt();
                    // Consume the newline character
                    scanner.nextLine();
                 } catch (InputMismatchException e) {
                    System.err.println("Error: Invalid input for quantity. Please enter a number.");
                    scanner.nextLine(); // Consume the invalid input
                    continue; // Restart the item selection loop
                 }

                if (quantity > 0) {
                    currentOrder.addItem(selectedItem, quantity);
                    System.out.println(selectedItem.getName() + " (x" + quantity + ") added to order.");
                } else {
                    System.err.println("Error: Quantity must be positive.");
                }

                System.out.print("Add another item? (yes/no): ");
                String addMore = scanner.nextLine().trim().toLowerCase();
                if (!addMore.equals("yes")) {
                    addingItems = false;
                }

            } else {
                System.err.println("Error: Invalid item number.");
            }
        }

        if (!currentOrder.getItems().isEmpty()) {
            orderQueue.offer(currentOrder); // Add the order to the queue
            System.out.println("Order #" + currentOrder.getOrderId() + " placed successfully! Total: $" + String.format("%.2f", currentOrder.getTotal()));
        } else {
            System.out.println("No items added. Order cancelled.");
        }
    }

    /**
     * Processes the next order in the queue (FIFO).
     */
    private void processNextOrder() {
        System.out.println("\n--- Processing Next Order ---");
        Order processedOrder = orderQueue.poll(); // Retrieve and remove the head of the queue

        if (processedOrder != null) {
            System.out.println("Processing Order #" + processedOrder.getOrderId() + "...");
            System.out.println("Details:");
            for (OrderItem item : processedOrder.getItems()) {
                System.out.println("  " + item);
            }
            System.out.println("Total: $" + String.format("%.2f", processedOrder.getTotal()));
            System.out.println("Order #" + processedOrder.getOrderId() + " processed.");
        } else {
            System.err.println("Error: No orders currently pending.");
        }
    }

    /**
     * Displays the list of orders waiting in the queue.
     */
    private void viewPendingOrders() {
        System.out.println("\n--- Pending Orders ---");
        if (orderQueue.isEmpty()) {
            System.out.println("No orders currently pending.");
        } else {
            // Iterate through the queue without removing elements
            int count = 1;
            for (Order order : orderQueue) {
                System.out.println(count++ + ". " + order);
            }
        }
    }

    /**
     * Runs the main application loop.
     * Includes class-wide exception handling.
     */
    public void run() {
        int choice = -1;

        // Class-wide try-catch block for the main application loop
        try {
            while (choice != 5) {
                displayMainMenu();

                try {
                    choice = scanner.nextInt();
                    // Consume the newline character left by nextInt()
                    scanner.nextLine(); // Important to prevent issues with nextLine() after nextInt()
                } catch (InputMismatchException e) {
                    System.err.println("Error: Invalid input. Please enter a number.");
                    scanner.nextLine(); // Consume the invalid input to prevent infinite loop
                    choice = -1; // Reset choice to stay in loop and show menu again
                    continue; // Skip the switch and show menu again
                }

                switch (choice) {
                    case 1:
                        placeOrder();
                        break;
                    case 2:
                        processNextOrder();
                        break;
                    case 3:
                        displayMenu();
                        break;
                    case 4:
                        viewPendingOrders();
                        break;
                    case 5:
                        System.out.println("Exiting Restaurant Order System. Goodbye!");
                        break;
                    default:
                        System.err.println("Error: Invalid choice. Please enter a number between 1 and 5.");
                        break;
                }
            }
        } catch (Exception e) {
            // Catch any unexpected exceptions that might occur
            System.err.println("An unexpected error occurred: " + e.getMessage());
            e.printStackTrace(System.err); // Print stack trace to error stream
        } finally {
            // Ensure the scanner is closed when the application exits
            if (scanner != null) {
                scanner.close();
            }
        }
    }

    public static void main(String[] args) {
        RestaurantOrderSystem system = new RestaurantOrderSystem();
        system.run();
    }
}
