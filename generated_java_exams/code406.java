/*
 * Exam Question #406
 * Generated on: 2025-05-11 23:06:23
 * Generated by: Account 5
 * 
 * QUESTION:
 * ## Java Programming Exam: Production Line Task Management System
 * 
 * **Objective:** Design and implement a simplified simulation of a production line task management system. Your system should manage a queue of pending tasks and a list of completed tasks, allowing users to interact via a console interface.
 * 
 * **Requirements:**
 * 
 * 1.  **Classes:**
 *     *   `Task`: A class representing a single production task. It should have private fields for a unique task ID (integer) and a description (String). Provide a constructor and public getter methods for these fields.
 *     *   `ProductionLine`: A class managing the production process. It should have:
 *         *   A private field to hold the queue of pending `Task` objects. Use `java.util.Queue`.
 *         *   A private field to hold the list of completed `Task` objects. Use `java.util.List` instantiated with `java.util.ArrayList`.
 *         *   A public method `addTask(int taskId, String description)`: Adds a new task to the pending queue. Validate that the task ID is positive.
 *         *   A public method `processNextTask()`: Removes the next task from the pending queue and adds it to the completed list. This method should handle the case where the queue is empty.
 *         *   A public method `viewPendingTasks()`: Prints all tasks currently in the pending queue.
 *         *   A public method `viewCompletedTasks()`: Prints all tasks currently in the completed list.
 *         *   Ensure proper encapsulation for all fields.
 * 
 * 2.  **Main Application (`Main` class):**
 *     *   Create a `main` method to run the simulation.
 *     *   Instantiate a `ProductionLine` object.
 *     *   Use `java.util.Scanner` to read user input from the console.
 *     *   Implement a command-line interface with the following options using a `switch` statement:
 *         *   `1`: Add Task (Prompts for Task ID and Description)
 *         *   `2`: Process Next Task
 *         *   `3`: View Pending Tasks
 *         *   `4`: View Completed Tasks
 *         *   `5`: Exit
 *     *   Use `System.out` for displaying menu options, successful operations, and task lists.
 *     *   Use `System.err` for displaying error messages (e.g., invalid command, invalid input during task creation, attempting to process task from an empty queue).
 *     *   Implement class-wide exception handling using `try-catch` blocks in the `main` method to catch potential runtime errors (like `InputMismatchException` when reading commands or task IDs) and handle them gracefully by printing an error message to `System.err` and continuing the loop. Specific error conditions handled within `ProductionLine` methods should also use `System.err`.
 *     *   The program should loop, accepting commands until the user chooses to exit.
 * 
 * 3.  **Best Practices:**
 *     *   Use meaningful variable and method names.
 *     *   Add comments and basic documentation (e.g., Javadoc for classes/methods).
 *     *   Implement input validation (e.g., positive task ID).
 *     *   Handle errors gracefully using `System.err` for errors and `System.out` for normal output.
 *     *   Structure your code clearly into classes.
 * 
 * **Expected Output Structure:**
 * 
 * ```
 * Production Line Management System
 * Choose an action:
 * 1. Add Task
 * 2. Process Next Task
 * 3. View Pending Tasks
 * 4. View Completed Tasks
 * 5. Exit
 * Enter command: 1
 * Enter Task ID: 101
 * Enter Task Description: Assemble Widget A
 * Task 101 added to pending queue.
 * 
 * Enter command: 1
 * Enter Task ID: 102
 * Enter Task Description: Test Widget B
 * Task 102 added to pending queue.
 * 
 * Enter command: 3
 * --- Pending Tasks ---
 * ID: 101, Description: Assemble Widget A
 * ID: 102, Description: Test Widget B
 * ---------------------
 * 
 * Enter command: 2
 * Processing task: ID: 101, Description: Assemble Widget A
 * Task 101 moved to completed list.
 * 
 * Enter command: 3
 * --- Pending Tasks ---
 * ID: 102, Description: Test Widget B
 * ---------------------
 * 
 * Enter command: 4
 * --- Completed Tasks ---
 * ID: 101, Description: Assemble Widget A
 * -----------------------
 * 
 * Enter command: 2
 * Processing task: ID: 102, Description: Test Widget B
 * Task 102 moved to completed list.
 * 
 * Enter command: 2
 * System.err: Error: No tasks in the pending queue to process.
 * 
 * Enter command: 6
 * System.err: Error: Invalid command. Please enter a number between 1 and 5.
 * 
 * Enter command: 5
 * Exiting Production Line Management System.
 * ```
 * 
 * Your solution should compile and run, demonstrating the correct usage of all specified Java components and adherence to best practices.
 *
 * EXPLANATION:
 * The solution implements a simple Production Line Task Management System as described in the problem.
 * 
 * **Key Components and Concepts Demonstrated:**
 * 
 * 1.  **`Task` Class:** A basic class representing a data structure. It uses `private final` fields for encapsulation and immutability after creation, along with public getter methods. The `toString()` method is overridden for easy printing.
 * 2.  **`ProductionLine` Class:** This class manages the core logic.
 *     *   It uses a `java.util.Queue<Task>` (`pendingTasks`) implemented by `LinkedList` to store tasks waiting to be processed. `Queue` is appropriate here because tasks are processed in a First-In, First-Out (FIFO) manner. Methods like `offer()` (for adding) and `poll()` (for removing) are used, which are safer than `add()` and `remove()` as they return `false`/`null` instead of throwing exceptions on failure (like a full queue, though `LinkedList` doesn't have a fixed size).
 *     *   It uses a `java.util.List<Task>` (`completedTasks`) instantiated with `ArrayList` to store tasks that have been processed. `List` and `ArrayList` are suitable for storing a collection of items where order of insertion is maintained and elements can be easily iterated over.
 *     *   Methods like `addTask`, `processNextTask`, `viewPendingTasks`, and `viewCompletedTasks` encapsulate the operations on these data structures.
 *     *   `addTask` includes basic input validation for the task ID.
 *     *   `processNextTask` checks if the queue is empty before attempting to process, printing an error to `System.err` if it is.
 * 3.  **`Main` Class:** This is the entry point of the application.
 *     *   It creates a `Scanner` object to read input from `System.in`.
 *     *   It uses a `while` loop to keep the application running until the user chooses to exit.
 *     *   A `switch` statement is used to control the flow based on the user's command. This demonstrates a clear way to handle multiple discrete options.
 *     *   **Input Handling and Validation:** `Scanner` is used to read different types of input (integer for commands/IDs, String for descriptions). `scanner.nextLine()` is used carefully after `nextInt()` to consume the remaining newline character, preventing issues in subsequent `nextLine()` calls.
 *     *   **Error Handling (`try-catch`):**
 *         *   A large `try-catch (Exception e)` block wraps the main command processing loop in `main`. This serves as a class-wide handler for any unexpected runtime exceptions that might occur, printing an error message and stack trace to `System.err`.
 *         *   Specific `try-catch (InputMismatchException e)` blocks are used around `scanner.nextInt()` calls within the loop to gracefully handle cases where the user enters non-integer input when an integer is expected. The invalid input is consumed using `scanner.next()` or `scanner.nextLine()` to prevent infinite loops, and an error message is printed to `System.err`.
 *         *   Business logic errors, like trying to process a task when the queue is empty or providing an invalid task ID, are handled within the `ProductionLine` methods themselves using `if` checks and printing specific error messages to `System.err`.
 *     *   **Output:** `System.out` is used for normal program output (menu, confirmations, lists), while `System.err` is strictly used for error messages, fulfilling the requirement to separate standard and error output streams.
 *     *   **Resource Management:** The `Scanner` is closed in a `finally` block to ensure it's released regardless of whether an exception occurs or the loop terminates normally.
 * 4.  **Best Practices:**
 *     *   **Encapsulation:** Private fields and public getters/methods are used in `Task` and `ProductionLine`.
 *     *   **Naming:** Variables (`taskId`, `pendingTasks`), methods (`addTask`, `processNextTask`), and classes (`Task`, `ProductionLine`) have descriptive names.
 *     *   **Comments and Documentation:** Javadoc-style comments explain the purpose of classes and methods, and inline comments clarify specific code logic.
 *     *   **Code Structure:** The code is organized into logical classes, making it modular and readable.
 * 
 * This solution effectively integrates all required Java components within a practical scenario, demonstrating proper data structure usage, user interaction handling, input validation, and robust error management using `try-catch` and dedicated error streams (`System.err`).
 */

import java.util.Queue;
import java.util.LinkedList; // LinkedList is a common implementation of Queue
import java.util.List;
import java.util.ArrayList;
import java.util.Scanner;
import java.util.InputMismatchException;

/**
 * Represents a single task in the production line.
 */
class Task {
    private final int taskId;
    private final String description;

    /**
     * Constructs a new Task.
     * @param taskId The unique identifier for the task.
     * @param description A brief description of the task.
     */
    public Task(int taskId, String description) {
        this.taskId = taskId;
        this.description = description;
    }

    /**
     * Gets the task ID.
     * @return The task ID.
     */
    public int getTaskId() {
        return taskId;
    }

    /**
     * Gets the task description.
     * @return The task description.
     */
    public String getDescription() {
        return description;
    }

    @Override
    public String toString() {
        return "ID: " + taskId + ", Description: " + description;
    }
}

/**
 * Manages the pending and completed tasks for a production line.
 */
class ProductionLine {
    // Use Queue for pending tasks (FIFO)
    private final Queue<Task> pendingTasks;
    // Use List for completed tasks (order of completion)
    private final List<Task> completedTasks;

    /**
     * Constructs a ProductionLine with empty task queues and lists.
     */
    public ProductionLine() {
        this.pendingTasks = new LinkedList<>(); // LinkedList implements Queue
        this.completedTasks = new ArrayList<>();
    }

    /**
     * Adds a new task to the pending queue.
     * Validates that the task ID is positive.
     * @param taskId The unique identifier for the task.
     * @param description A brief description of the task.
     */
    public void addTask(int taskId, String description) {
        if (taskId <= 0) {
            System.err.println("Error: Task ID must be a positive integer.");
            return;
        }
        // Basic check, could add more complex validation like unique ID
        Task newTask = new Task(taskId, description);
        pendingTasks.offer(newTask); // offer is generally preferred over add for queues
        System.out.println("Task " + taskId + " added to pending queue.");
    }

    /**
     * Processes the next task from the pending queue.
     * Removes the task from pending and adds it to completed.
     * Handles the case where the pending queue is empty.
     */
    public void processNextTask() {
        Task taskToProcess = pendingTasks.poll(); // poll retrieves and removes, returns null if empty

        if (taskToProcess == null) {
            System.err.println("Error: No tasks in the pending queue to process.");
        } else {
            System.out.println("Processing task: " + taskToProcess);
            completedTasks.add(taskToProcess);
            System.out.println("Task " + taskToProcess.getTaskId() + " moved to completed list.");
        }
    }

    /**
     * Prints all tasks currently in the pending queue.
     */
    public void viewPendingTasks() {
        System.out.println("--- Pending Tasks ---");
        if (pendingTasks.isEmpty()) {
            System.out.println("No pending tasks.");
        } else {
            // Iterating over a Queue does not remove elements
            for (Task task : pendingTasks) {
                System.out.println(task);
            }
        }
        System.out.println("---------------------");
    }

    /**
     * Prints all tasks currently in the completed list.
     */
    public void viewCompletedTasks() {
        System.out.println("--- Completed Tasks ---");
        if (completedTasks.isEmpty()) {
            System.out.println("No completed tasks.");
        } else {
            for (Task task : completedTasks) {
                System.out.println(task);
            }
        }
        System.out.println("-----------------------");
    }
}

/**
 * Main class to run the Production Line Management System simulation.
 */
public class Main {

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        ProductionLine productionLine = new ProductionLine();
        boolean running = true;

        System.out.println("Production Line Management System");

        // Class-wide exception handling for the main command loop
        try {
            while (running) {
                printMenu();

                System.out.print("Enter command: ");
                int command = -1; // Default invalid command

                try {
                    command = scanner.nextInt();
                } catch (InputMismatchException e) {
                    System.err.println("Error: Invalid input. Please enter a number.");
                    scanner.next(); // Consume the invalid input
                    continue; // Skip to the next iteration
                } finally {
                     scanner.nextLine(); // Consume the newline character left by nextInt()
                }


                switch (command) {
                    case 1: // Add Task
                        System.out.print("Enter Task ID: ");
                        int taskId = -1;
                        try {
                            taskId = scanner.nextInt();
                            scanner.nextLine(); // Consume newline

                            System.out.print("Enter Task Description: ");
                            String description = scanner.nextLine();

                            productionLine.addTask(taskId, description);
                        } catch (InputMismatchException e) {
                             System.err.println("Error: Invalid Task ID. Please enter an integer.");
                             scanner.nextLine(); // Consume the invalid input line
                        }
                        break;

                    case 2: // Process Next Task
                        productionLine.processNextTask();
                        break;

                    case 3: // View Pending Tasks
                        productionLine.viewPendingTasks();
                        break;

                    case 4: // View Completed Tasks
                        productionLine.viewCompletedTasks();
                        break;

                    case 5: // Exit
                        running = false;
                        System.out.println("Exiting Production Line Management System.");
                        break;

                    default:
                        System.err.println("Error: Invalid command. Please enter a number between 1 and 5.");
                        break;
                }
                System.out.println(); // Add a newline for better readability between commands
            }
        } catch (Exception e) {
            // Catch any unexpected exceptions during the main execution flow
            System.err.println("An unexpected error occurred: " + e.getMessage());
            e.printStackTrace(System.err); // Print stack trace to error stream
        } finally {
            // Ensure scanner is closed
            scanner.close();
            System.out.println("Scanner closed.");
        }
    }

    /**
     * Prints the main menu options to the console.
     */
    private static void printMenu() {
        System.out.println("Choose an action:");
        System.out.println("1. Add Task");
        System.out.println("2. Process Next Task");
        System.out.println("3. View Pending Tasks");
        System.out.println("4. View Completed Tasks");
        System.out.println("5. Exit");
    }
}
