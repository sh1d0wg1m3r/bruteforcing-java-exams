/*
 * Exam Question #314
 * Generated on: 2025-05-11 22:53:40
 * Generated by: Account 5
 * 
 * QUESTION:
 * ## Java Programming Exam: Advanced Task Management System
 * 
 * **Objective:** Design and implement a command-line Task Management System that allows users to add tasks, process the next task in a queue, and view task history. This problem requires demonstrating proficiency in using core Java data structures, input handling, control flow, and error management.
 * 
 * **Scenario:** You are building a simple backend system for managing tasks in a first-in, first-out (FIFO) order. Tasks are added to a waiting queue. When a task is processed, it is removed from the queue and moved to a history list.
 * 
 * **Requirements:**
 * 
 * 1.  **Task Representation:** Create a `Task` class with a private field for the task description (String). Include a constructor and a public getter method for the description.
 * 2.  **Task Management Logic:** Create a `TaskManager` class responsible for managing the tasks.
 *     *   It must use a `java.util.Queue` (specifically, an implementation like `java.util.LinkedList` which implements `Queue`) to store tasks waiting to be processed.
 *     *   It must use a `java.util.ArrayList` to store tasks that have been completed.
 *     *   The `ArrayList` must be referred to using the `java.util.List` interface type in method signatures or field declarations where appropriate (e.g., return type for viewing history).
 *     *   Implement the following methods:
 *         *   `addTask(String description)`: Adds a new `Task` to the waiting queue. Validate that the description is not null or empty. If invalid, print an error to `System.err` and do not add the task.
 *         *   `processNextTask()`: Removes the task at the front of the queue and adds it to the completed tasks list. If the queue is empty, print an error message to `System.err` and return `null`. Otherwise, return the processed `Task` object.
 *         *   `viewCurrentTasks()`: Returns a `List<Task>` containing the tasks currently in the waiting queue (without removing them). The order should reflect the queue's FIFO nature.
 *         *   `viewCompletedTasks()`: Returns a `List<Task>` containing the tasks that have been processed.
 * 3.  **User Interface:** Create a main class (e.g., `TaskManagerApp`) with a `main` method to interact with the user via the console.
 *     *   Use `java.util.Scanner` to read user input.
 *     *   Present a menu of options to the user:
 *         1.  Add New Task
 *         2.  Process Next Task
 *         3.  View Current Tasks
 *         4.  View Completed Tasks
 *         5.  Exit
 *     *   Use a `switch` statement to handle the user's menu choice.
 *     *   Implement a loop that continues until the user chooses to exit.
 * 4.  **Error Handling:**
 *     *   Use `System.err` for all error messages (e.g., invalid input, attempting to process an empty queue).
 *     *   Use `System.out` for all normal output (menu, prompts, success messages, task lists).
 *     *   Implement class-wide exception handling using `try-catch` blocks. Specifically, handle potential `java.util.InputMismatchException` when reading integer input from the `Scanner` for the menu choice. If this exception occurs, print an error to `System.err` and clear the invalid input from the scanner.
 * 5.  **Best Practices:**
 *     *   Use proper encapsulation (private fields, public methods).
 *     *   Use meaningful variable and method names.
 *     *   Include appropriate comments explaining the purpose of classes, methods, and complex logic.
 *     *   Ensure input validation (e.g., task description).
 *     *   Structure code logically into separate classes.
 *     *   Close the `Scanner` resource when the application exits.
 * 
 * **Expected Output:**
 * 
 * The program should display a menu, prompt for input, and perform actions based on the user's choice. Output should be clear, using `System.out` for normal information and `System.err` for errors.
 * 
 * Example interaction flow:
 * ```
 * --- Task Manager Menu ---
 * 1. Add New Task
 * 2. Process Next Task
 * 3. View Current Tasks
 * 4. View Completed Tasks
 * 5. Exit
 * Enter your choice: 1
 * Enter task description: Buy groceries
 * Task added: Buy groceries
 * 
 * --- Task Manager Menu ---
 * 1. Add New Task
 * ...
 * Enter your choice: 1
 * Enter task description:
 * Error: Task description cannot be empty.
 * 
 * --- Task Manager Menu ---
 * ...
 * Enter your choice: 3
 * Current Tasks:
 * 1. Buy groceries
 * 
 * --- Task Manager Menu ---
 * ...
 * Enter your choice: 2
 * Processing task: Buy groceries
 * 
 * --- Task Manager Menu ---
 * ...
 * Enter your choice: 2
 * Error: No tasks in the queue to process.
 * 
 * --- Task Manager Menu ---
 * ...
 * Enter your choice: 4
 * Completed Tasks:
 * 1. Buy groceries
 * 
 * --- Task Manager Menu ---
 * ...
 * Enter your choice: invalid_input
 * Error: Invalid input. Please enter a number.
 * 
 * --- Task Manager Menu ---
 * ...
 * Enter your choice: 5
 * Exiting Task Manager.
 * ```
 * 
 * Your solution should be a single Java file containing all necessary classes.
 *
 * EXPLANATION:
 * The solution implements a simple command-line Task Management System as described in the problem statement, incorporating all the required Java components and best practices.
 * 
 * 1.  **`Task` Class:** A simple POJO (Plain Old Java Object) representing a task with a single private field `description`. It includes a constructor and a public getter (`getDescription()`) to adhere to encapsulation principles. The `toString()` method is overridden for easy printing of task details.
 * 
 * 2.  **`TaskManager` Class:** This class encapsulates the core logic and data structures.
 *     *   `private Queue<Task> taskQueue;`: Declares a field using the `Queue` interface type. It is initialized with a `LinkedList` instance in the constructor, as `LinkedList` is a common implementation of `Queue` that provides FIFO behavior.
 *     *   `private List<Task> completedTasks;`: Declares a field using the `List` interface type. It is initialized with an `ArrayList` instance in the constructor.
 *     *   `addTask(String description)`: This method takes a description, performs input validation (checking for null or empty string), and if valid, creates a new `Task` object and adds it to the `taskQueue` using the `offer()` method (preferred for queues as it doesn't throw an exception if the queue is capacity-constrained, though `LinkedList` is not capacity-constrained). It prints a success message using `System.out` or an error using `System.err`.
 *     *   `processNextTask()`: This method uses `taskQueue.poll()` to retrieve and remove the head of the queue. `poll()` is used because it safely returns `null` if the queue is empty, which is handled by printing an error to `System.err`. If a task is retrieved, it's added to the `completedTasks` `ArrayList`, and a success message is printed to `System.out`.
 *     *   `viewCurrentTasks()`: This method demonstrates using the `List` interface. It creates a *new* `ArrayList` populated with elements from the `taskQueue`. This is important to return a `List` view of the queue's current state *without* modifying the queue itself.
 *     *   `viewCompletedTasks()`: This method returns the `completedTasks` `ArrayList`, demonstrating the use of the `List` interface as a return type.
 * 
 * 3.  **`TaskManagerApp` Class (Main):**
 *     *   The `main` method contains the application's entry point and user interaction loop.
 *     *   A `Scanner` object is created for reading input from `System.in`.
 *     *   A `TaskManager` object is instantiated to manage the tasks.
 *     *   A `while` loop keeps the application running until the user chooses to exit.
 *     *   Inside the loop, `printMenu()` displays the options using `System.out`.
 *     *   **`try-catch` Block:** A `try-catch` block is used to handle potential exceptions when reading the user's menu choice. It specifically catches `InputMismatchException`, which occurs if the user enters non-integer input. If caught, an error message is printed to `System.err`, and `scanner.nextLine()` is called to consume the invalid input line, preventing an infinite loop. A general `Exception` catch is also included as a fallback, demonstrating broader exception handling.
 *     *   **`switch` Statement:** The user's valid integer choice is handled by a `switch` statement, directing the program flow to the appropriate action (add task, process task, view queue, view history, exit).
 *     *   Each case within the `switch` calls the relevant `TaskManager` method and prints results or messages using `System.out`. The `default` case handles invalid integer choices, printing an error to `System.err`.
 *     *   The loop continues until `running` becomes `false` (when the user chooses option 5).
 *     *   Finally, `scanner.close()` is called outside the loop to release the system resource used by the `Scanner`.
 * 
 * **Key Concepts Demonstrated:**
 * 
 * *   **Data Structures:** Effective use of `Queue` (implemented by `LinkedList`) for FIFO processing and `List` (implemented by `ArrayList`) for storing history.
 * *   **Interfaces:** Using `Queue` and `List` interfaces for type declarations promotes flexibility and good design.
 * *   **Object-Oriented Programming:** Encapsulation is used in both `Task` and `TaskManager` classes.
 * *   **User Input:** Handling command-line input using `Scanner`.
 * *   **Control Flow:** Using `while` loops for the application lifecycle and `switch` statements for menu-driven logic.
 * *   **Error Handling:**
 *     *   Input validation (task description).
 *     *   Handling specific operational errors (empty queue) with `System.err`.
 *     *   Handling input parsing errors (`InputMismatchException`) using `try-catch` blocks, including consuming invalid input.
 *     *   Using `System.out` for normal output and `System.err` for errors as required.
 * *   **Resource Management:** Closing the `Scanner` resource.
 * *   **Code Structure:** Organizing code into logical classes (`Task`, `TaskManager`, `TaskManagerApp`).
 * 
 * This solution effectively integrates the required components into a functional, well-structured program that simulates a practical task management scenario.
 */

import java.util.Queue;
import java.util.LinkedList;
import java.util.List;
import java.util.ArrayList;
import java.util.Scanner;
import java.util.InputMismatchException;

// Represents a single task
class Task {
    private String description;

    /**
     * Constructs a new Task with the given description.
     * @param description The description of the task.
     */
    public Task(String description) {
        this.description = description;
    }

    /**
     * Gets the description of the task.
     * @return The task description.
     */
    public String getDescription() {
        return description;
    }

    @Override
    public String toString() {
        return description;
    }
}

// Manages the queue of waiting tasks and the list of completed tasks
class TaskManager {
    // Queue for tasks waiting to be processed (FIFO)
    private Queue<Task> taskQueue;
    // List for tasks that have been completed
    private List<Task> completedTasks;

    /**
     * Constructs a new TaskManager, initializing the task queue and completed tasks list.
     */
    public TaskManager() {
        // LinkedList implements the Queue interface and provides FIFO behavior
        this.taskQueue = new LinkedList<>();
        // ArrayList is used for storing completed tasks
        this.completedTasks = new ArrayList<>();
    }

    /**
     * Adds a new task to the waiting queue.
     * Validates that the task description is not empty.
     * @param description The description of the task to add.
     */
    public void addTask(String description) {
        if (description == null || description.trim().isEmpty()) {
            System.err.println("Error: Task description cannot be empty.");
            return;
        }
        Task newTask = new Task(description.trim());
        taskQueue.offer(newTask); // offer is generally preferred over add for queues
        System.out.println("Task added: " + newTask.getDescription());
    }

    /**
     * Processes the next task in the queue.
     * Removes the task from the queue and adds it to the completed list.
     * @return The processed Task, or null if the queue was empty.
     */
    public Task processNextTask() {
        Task nextTask = taskQueue.poll(); // poll retrieves and removes the head, returns null if queue is empty
        if (nextTask == null) {
            System.err.println("Error: No tasks in the queue to process.");
            return null;
        } else {
            completedTasks.add(nextTask);
            System.out.println("Processing task: " + nextTask.getDescription());
            return nextTask;
        }
    }

    /**
     * Returns a list of tasks currently in the waiting queue.
     * Does not remove tasks from the queue.
     * @return A List containing tasks from the queue in order.
     */
    public List<Task> viewCurrentTasks() {
        // Create a new list from the queue elements to avoid modifying the queue
        // and to return a List interface type as requested.
        return new ArrayList<>(taskQueue);
    }

    /**
     * Returns a list of tasks that have been completed.
     * @return A List containing completed tasks.
     */
    public List<Task> viewCompletedTasks() {
        // Return the completedTasks list. Returning the list directly is acceptable
        // for this problem scope, though returning a copy might be preferred in larger systems.
        return completedTasks;
    }
}

// Main application class for user interaction
public class TaskManagerApp {

    public static void main(String[] args) {
        TaskManager taskManager = new TaskManager();
        Scanner scanner = new Scanner(System.in);
        boolean running = true;

        System.out.println("--- Welcome to Task Manager ---");

        while (running) {
            printMenu();

            int choice = -1; // Initialize with an invalid choice

            // Class-wide exception handling for scanner input
            try {
                System.out.print("Enter your choice: ");
                choice = scanner.nextInt();
                // Consume the newline character left by nextInt()
                scanner.nextLine();
            } catch (InputMismatchException e) {
                System.err.println("Error: Invalid input. Please enter a number.");
                scanner.nextLine(); // Consume the invalid input to prevent infinite loop
                continue; // Skip the rest of the loop iteration and show menu again
            } catch (Exception e) {
                 // Catch any other unexpected exceptions during input reading
                 System.err.println("An unexpected error occurred while reading input: " + e.getMessage());
                 scanner.nextLine(); // Attempt to clear input
                 continue;
            }


            // Switch statement for flow control based on user choice
            switch (choice) {
                case 1:
                    System.out.print("Enter task description: ");
                    String description = scanner.nextLine();
                    taskManager.addTask(description);
                    break;
                case 2:
                    taskManager.processNextTask(); // Method prints its own success/error message
                    break;
                case 3:
                    List<Task> currentTasks = taskManager.viewCurrentTasks();
                    System.out.println("Current Tasks:");
                    if (currentTasks.isEmpty()) {
                        System.out.println("  No tasks in the queue.");
                    } else {
                        for (int i = 0; i < currentTasks.size(); i++) {
                            System.out.println("  " + (i + 1) + ". " + currentTasks.get(i).getDescription());
                        }
                    }
                    break;
                case 4:
                    List<Task> completedTasks = taskManager.viewCompletedTasks();
                    System.out.println("Completed Tasks:");
                    if (completedTasks.isEmpty()) {
                        System.out.println("  No tasks completed yet.");
                    } else {
                        for (int i = 0; i < completedTasks.size(); i++) {
                            System.out.println("  " + (i + 1) + ". " + completedTasks.get(i).getDescription());
                        }
                    }
                    break;
                case 5:
                    running = false;
                    System.out.println("Exiting Task Manager.");
                    break;
                default:
                    System.err.println("Error: Invalid choice. Please enter a number between 1 and 5.");
                    break;
            }
            System.out.println(); // Add a blank line for readability between operations
        }

        scanner.close(); // Close the scanner resource
    }

    /**
     * Prints the main menu options to the console.
     */
    private static void printMenu() {
        System.out.println("--- Task Manager Menu ---");
        System.out.println("1. Add New Task");
        System.out.println("2. Process Next Task");
        System.out.println("3. View Current Tasks");
        System.out.println("4. View Completed Tasks");
        System.out.println("5. Exit");
    }
}
