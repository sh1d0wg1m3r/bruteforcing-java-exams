/*
 * Exam Question #520
 * Generated on: 2025-05-11 23:23:36
 * Generated by: Account 3
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Airport Security Checkpoint Simulation
 * 
 * **Scenario:**
 * 
 * You are tasked with creating a simplified simulation of an airport security checkpoint. People arrive and join a single waiting line (queue). When a security lane becomes free, the next person from the front of the waiting line is assigned to that lane for processing. Once a person is processed in a lane, the lane becomes free again.
 * 
 * Your program should allow a user to interact with the simulation through commands entered via the console.
 * 
 * **Task:**
 * 
 * Implement a Java program that simulates this airport security checkpoint.
 * 
 * **Requirements:**
 * 
 * 1.  **Classes:**
 *     *   A `Person` class to represent individuals (at least store a name).
 *     *   A `SecurityCheckpoint` class to manage the waiting queue and the security lanes.
 *     *   A main class (`AirportSecuritySimulation`) to handle user interaction and run the simulation loop.
 * 
 * 2.  **Data Structures:**
 *     *   Use a `java.util.Queue` to represent the waiting line of people.
 *     *   Use a `java.util.ArrayList` to represent the security lanes. Each element in the list will represent a lane, storing either a `Person` object (if occupied) or `null` (if free).
 *     *   Declare the collection of lanes using the `java.util.List` interface type.
 * 
 * 3.  **User Interaction:**
 *     *   Use `java.util.Scanner` to read commands from the console (`System.in`).
 *     *   Support the following commands (case-insensitive):
 *         *   `add <name>`: Creates a new `Person` with the given name and adds them to the waiting queue.
 *         *   `assign`: Attempts to move the next person from the waiting queue to the first available security lane. If the queue is empty or all lanes are occupied, print an informative message.
 *         *   `process <lane_number>`: "Processes" the person currently in the specified lane number (1-based index), making the lane free.
 *         *   `status`: Prints the current state of the waiting queue and all security lanes.
 *         *   `exit`: Terminates the simulation.
 *     *   Use a `switch` statement to handle the different commands.
 * 
 * 4.  **Output and Error Handling:**
 *     *   Use `System.out` for normal output (prompts, success messages, status).
 *     *   Use `System.err` for error messages (e.g., invalid command, invalid lane number, attempting to process an empty lane, incorrect command usage).
 *     *   Implement input validation where necessary (e.g., check if a name is provided for `add`, check if the lane number for `process` is a valid integer within the correct range).
 *     *   Include `try-catch` blocks for exception handling, particularly around operations that might fail (like parsing user input or accessing collection elements with invalid indices). A class-wide or main loop level `try-catch` is acceptable to catch unexpected errors.
 * 
 * 5.  **Best Practices:**
 *     *   Employ proper encapsulation (private fields, public methods).
 *     *   Use meaningful variable and method names.
 *     *   Include appropriate comments and documentation (e.g., Javadoc for classes and public methods).
 *     *   Maintain a clean code structure.
 *     *   Define a constant for the number of security lanes (e.g., 3).
 * 
 * **Expected Output:**
 * 
 * Your program should interact with the user and produce output similar to the following example session:
 * 
 * ```
 * --- Airport Security Checkpoint Simulation ---
 * Available commands: add <name>, assign, process <lane_number>, status, exit
 * 
 * Enter command: status
 * 
 * --- Security Checkpoint Status ---
 * Waiting Queue (0 people): Empty
 * Security Lanes:
 *   Lane 1: Free
 *   Lane 2: Free
 *   Lane 3: Free
 * ----------------------------------
 * 
 * Enter command: add Alice
 * Alice added to the waiting queue.
 * 
 * Enter command: add Bob
 * Bob added to the waiting queue.
 * 
 * Enter command: status
 * 
 * --- Security Checkpoint Status ---
 * Waiting Queue (2 people): [Alice, Bob]
 * Security Lanes:
 *   Lane 1: Free
 *   Lane 2: Free
 *   Lane 3: Free
 * ----------------------------------
 * 
 * Enter command: assign
 * Alice assigned to Lane 1.
 * 
 * Enter command: status
 * 
 * --- Security Checkpoint Status ---
 * Waiting Queue (1 people): [Bob]
 * Security Lanes:
 *   Lane 1: Occupied by Alice
 *   Lane 2: Free
 *   Lane 3: Free
 * ----------------------------------
 * 
 * Enter command: assign
 * Bob assigned to Lane 2.
 * 
 * Enter command: assign
 * Waiting queue is empty. No one to assign.
 * 
 * Enter command: status
 * 
 * --- Security Checkpoint Status ---
 * Waiting Queue (0 people): Empty
 * Security Lanes:
 *   Lane 1: Occupied by Alice
 *   Lane 2: Occupied by Bob
 *   Lane 3: Free
 * ----------------------------------
 * 
 * Enter command: add Charlie
 * Charlie added to the waiting queue.
 * 
 * Enter command: status
 * 
 * --- Security Checkpoint Status ---
 * Waiting Queue (1 people): [Charlie]
 * Security Lanes:
 *   Lane 1: Occupied by Alice
 *   Lane 2: Occupied by Bob
 *   Lane 3: Free
 * ----------------------------------
 * 
 * Enter command: assign
 * Charlie assigned to Lane 3.
 * 
 * Enter command: add David
 * David added to the waiting queue.
 * 
 * Enter command: status
 * 
 * --- Security Checkpoint Status ---
 * Waiting Queue (1 people): [David]
 * Security Lanes:
 *   Lane 1: Occupied by Alice
 *   Lane 2: Occupied by Bob
 *   Lane 3: Occupied by Charlie
 * ----------------------------------
 * 
 * Enter command: assign
 * All lanes are currently occupied. David is waiting.
 * 
 * Enter command: process 1
 * Alice processed in Lane 1. Lane is now free.
 * 
 * Enter command: status
 * 
 * --- Security Checkpoint Status ---
 * Waiting Queue (1 people): [David]
 * Security Lanes:
 *   Lane 1: Free
 *   Lane 2: Occupied by Bob
 *   Lane 3: Occupied by Charlie
 * ----------------------------------
 * 
 * Enter command: assign
 * David assigned to Lane 1.
 * 
 * Enter command: status
 * 
 * --- Security Checkpoint Status ---
 * Waiting Queue (0 people): Empty
 * Security Lanes:
 *   Lane 1: Occupied by David
 *   Lane 2: Occupied by Bob
 *   Lane 3: Occupied by Charlie
 * ----------------------------------
 * 
 * Enter command: process 2
 * Bob processed in Lane 2. Lane is now free.
 * 
 * Enter command: process 4
 * Invalid lane number. Please use a lane number between 1 and 3.
 * 
 * Enter command: process 2
 * Lane 2 is already free.
 * 
 * Enter command: process abc
 * Invalid lane number format. Please enter a number.
 * 
 * Enter command: exit
 * Exiting simulation.
 * Simulation ended.
 * ```
 *
 * EXPLANATION:
 * The provided solution simulates an airport security checkpoint, demonstrating the required Java concepts and best practices.
 * 
 * 1.  **`Person` Class:** A simple class encapsulating a person's `name`. It follows encapsulation principles with a private field and a public getter. The `toString()` method is overridden for convenient printing in the status updates.
 * 
 * 2.  **`SecurityCheckpoint` Class:** This is the core class managing the simulation state.
 *     *   It uses a `private Queue<Person> waitingQueue` implemented by `LinkedList` to store people waiting in line. `LinkedList` is a suitable choice as it efficiently supports the queue operations (`offer` to add to the end, `poll` to remove from the front, `peek` to view the front).
 *     *   It uses a `private List<Person> securityLanes` implemented by `ArrayList` to represent the fixed number of security lanes. Using the `List` interface for the variable declaration promotes programming to the interface. The `ArrayList` is initialized to a fixed size (`numberOfLanes`), and each element represents a lane's state (`null` for free, `Person` object for occupied).
 *     *   The constructor initializes the lanes list with `null` values and includes input validation for the number of lanes, throwing an `IllegalArgumentException` if invalid.
 *     *   `addPerson(Person person)`: Adds a person to the `waitingQueue` using `offer()`.
 *     *   `assignToLane()`: Checks if the `waitingQueue` is not empty and if there is a free lane (`findFreeLane()` method). If both conditions are met, it removes the next person from the queue using `poll()` and places them into the free lane using `securityLanes.set(index, person)`.
 *     *   `processLane(int laneIndex)`: Takes a 0-based lane index (derived from user's 1-based input) and checks if the lane is occupied (`securityLanes.get(index) != null`). If occupied, it sets the lane's state back to `null` using `securityLanes.set(index, null)`. It includes validation to ensure the provided index is within the valid range.
 *     *   `findFreeLane()`: A helper method to find the index of the first available lane by iterating through the `securityLanes` list and checking for `null`.
 *     *   `getStatus()`: Prints the current contents of the `waitingQueue` and the state of each lane in the `securityLanes` list.
 * 
 * 3.  **`AirportSecuritySimulation` Class (Main):**
 *     *   Contains the `main` method where the simulation execution begins.
 *     *   A constant `NUMBER_OF_LANES` is defined for configuration.
 *     *   A `Scanner` is initialized to read user input.
 *     *   A main `while` loop runs the simulation until the user enters the `exit` command.
 *     *   Inside the loop, it reads a line of input, splits it into a command and potential arguments.
 *     *   A `switch` statement directs the program flow based on the command string.
 *     *   **Input Validation and Error Handling:**
 *         *   For the `add` command, it checks if a name argument was provided.
 *         *   For the `process` command, it first checks if an argument was provided. It then uses a specific `try-catch(NumberFormatException)` block to handle cases where the lane number argument is not a valid integer. It also converts the user's 1-based lane number to the internal 0-based index before calling `processLane`. The `processLane` method itself performs further validation on the index range and checks if the lane is actually occupied.
 *         *   A general `try-catch(Exception e)` block wraps the core command processing logic within the `while` loop. This provides a safety net to catch any other unexpected runtime exceptions that might occur during command execution, printing an error message using `System.err` without crashing the program.
 *         *   `System.err` is consistently used for all error messages (invalid input, usage errors, runtime exceptions), while `System.out` is used for normal output, prompts, and status information, fulfilling the requirement to differentiate output streams.
 * 
 * 4.  **Required Components Usage:**
 *     *   `Queue`: Used for `waitingQueue` (`LinkedList` implementation).
 *     *   `ArrayList`: Used for `securityLanes` (`ArrayList` implementation).
 *     *   `List`: `securityLanes` is declared as `List<Person>`.
 *     *   `Scanner`: Used in `main` to read user input.
 *     *   `Switch`: Used in `main` to process commands.
 *     *   `System.err`: Used for error messages in `main` and `SecurityCheckpoint`.
 *     *   `System.out`: Used for normal output, prompts, and status in `main` and `SecurityCheckpoint`.
 *     *   `try-catch`: Used in `main` for parsing errors (`NumberFormatException`) and general unexpected errors (`Exception`), and implicitly handled for `IllegalArgumentException` during initialization.
 * 
 * This solution effectively combines various core Java concepts and libraries to build a functional simulation, demonstrating understanding of data structures, object-oriented design, user interaction, control flow, and robust error handling.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.InputMismatchException;

// Represents a person in the simulation
class Person {
    private String name;

    /**
     * Constructs a Person object.
     * @param name The name of the person.
     */
    public Person(String name) {
        this.name = name;
    }

    /**
     * Gets the name of the person.
     * @return The person's name.
     */
    public String getName() {
        return name;
    }

    /**
     * Provides a string representation of the person, useful for printing status.
     * @return The person's name.
     */
    @Override
    public String toString() {
        return name;
    }
}

// Manages the waiting queue and security lanes
class SecurityCheckpoint {
    private Queue<Person> waitingQueue;
    private List<Person> securityLanes; // Using List interface, implemented by ArrayList
    private final int numberOfLanes;

    /**
     * Constructs a SecurityCheckpoint with a specified number of lanes.
     *
     * @param numberOfLanes The number of security lanes. Must be positive.
     */
    public SecurityCheckpoint(int numberOfLanes) {
        if (numberOfLanes <= 0) {
            // Using System.err for critical initialization error
            System.err.println("Error: Number of lanes must be positive. Provided: " + numberOfLanes);
            throw new IllegalArgumentException("Number of lanes must be positive.");
        }
        this.numberOfLanes = numberOfLanes;
        this.waitingQueue = new LinkedList<>(); // LinkedList implements Queue
        this.securityLanes = new ArrayList<>(numberOfLanes); // ArrayList implements List
        // Initialize lanes as free (null)
        for (int i = 0; i < numberOfLanes; i++) {
            this.securityLanes.add(null);
        }
        System.out.println("Security checkpoint initialized with " + numberOfLanes + " lanes.");
    }

    /**
     * Adds a person to the waiting queue.
     *
     * @param person The person to add.
     */
    public void addPerson(Person person) {
        if (person != null) {
            waitingQueue.offer(person); // offer is preferred over add for queues, returns boolean
            System.out.println(person.getName() + " added to the waiting queue."); // Use System.out for normal success
        } else {
            System.err.println("Cannot add null person."); // Use System.err for error
        }
    }

    /**
     * Attempts to assign the next person from the waiting queue to a free lane.
     */
    public void assignToLane() {
        if (waitingQueue.isEmpty()) {
            System.out.println("Waiting queue is empty. No one to assign."); // Use System.out for informational message
            return;
        }

        int freeLaneIndex = findFreeLane();

        if (freeLaneIndex == -1) {
            // Use System.out for informational message about state
            System.out.println("All lanes are currently occupied. " + waitingQueue.peek().getName() + " is waiting.");
            return;
        }

        Person nextPerson = waitingQueue.poll(); // Remove from queue (FIFO)
        securityLanes.set(freeLaneIndex, nextPerson); // Assign to lane in the List
        System.out.println(nextPerson.getName() + " assigned to Lane " + (freeLaneIndex + 1) + "."); // Use System.out for success
    }

    /**
     * Processes the person in the specified lane, making the lane free.
     * Lane number is 1-based for user input, converted to 0-based index internally.
     *
     * @param laneIndex The index of the lane (0-based).
     */
    public void processLane(int laneIndex) {
        // Validate lane index before accessing the list
        if (laneIndex < 0 || laneIndex >= numberOfLanes) {
            // Use System.err for invalid input error
            System.err.println("Invalid lane number. Please use a lane number between 1 and " + numberOfLanes + ".");
            return;
        }

        Person personInLane = securityLanes.get(laneIndex); // Access element in List

        if (personInLane == null) {
            // Use System.err for processing error (lane already free)
            System.err.println("Lane " + (laneIndex + 1) + " is already free.");
        } else {
            System.out.println(personInLane.getName() + " processed in Lane " + (laneIndex + 1) + ". Lane is now free."); // Use System.out for success
            securityLanes.set(laneIndex, null); // Make lane free (update element in List)
        }
    }

    /**
     * Finds the index of the first free lane.
     *
     * @return The 0-based index of the free lane, or -1 if no lane is free.
     */
    private int findFreeLane() {
        for (int i = 0; i < numberOfLanes; i++) {
            if (securityLanes.get(i) == null) {
                return i;
            }
        }
        return -1; // No free lane found
    }

    /**
     * Prints the current status of the waiting queue and security lanes.
     */
    public void getStatus() {
        System.out.println("\n--- Security Checkpoint Status ---"); // Use System.out for status header

        // Queue status
        System.out.print("Waiting Queue (" + waitingQueue.size() + " people): "); // Use System.out
        if (waitingQueue.isEmpty()) {
            System.out.println("Empty"); // Use System.out
        } else {
            // Print queue elements without removing them. LinkedList's toString works well.
            System.out.println(waitingQueue.toString()); // Use System.out
        }

        // Lanes status
        System.out.println("Security Lanes:"); // Use System.out
        for (int i = 0; i < numberOfLanes; i++) {
            Person personInLane = securityLanes.get(i); // Access element in List
            System.out.print("  Lane " + (i + 1) + ": "); // Use System.out
            if (personInLane == null) {
                System.out.println("Free"); // Use System.out
            } else {
                System.out.println("Occupied by " + personInLane.getName()); // Use System.out
            }
        }
        System.out.println("----------------------------------"); // Use System.out
    }
}

// Main class to run the simulation
public class AirportSecuritySimulation {

    private static final int NUMBER_OF_LANES = 3; // Constant for number of lanes

    public static void main(String[] args) {
        SecurityCheckpoint checkpoint;
        try {
             // Attempt to initialize the checkpoint
             checkpoint = new SecurityCheckpoint(NUMBER_OF_LANES);
        } catch (IllegalArgumentException e) {
             // Catch initialization errors using System.err and exit
             System.err.println("Simulation startup failed. Exiting.");
             return;
        }

        Scanner scanner = new Scanner(System.in);
        boolean running = true;

        System.out.println("--- Airport Security Checkpoint Simulation ---");
        System.out.println("Available commands: add <name>, assign, process <lane_number>, status, exit");

        while (running) {
            System.out.print("\nEnter command: "); // Use System.out for prompt
            String inputLine = scanner.nextLine().trim(); // Read user input
            String[] parts = inputLine.split(" ", 2); // Split command and arguments
            String command = parts[0].toLowerCase(); // Get command, make case-insensitive

            // Class-wide or main loop level try-catch for general unexpected errors
            try {
                switch (command) {
                    case "add":
                        // Input validation for 'add' command
                        if (parts.length > 1 && !parts[1].trim().isEmpty()) {
                            String personName = parts[1].trim();
                            checkpoint.addPerson(new Person(personName));
                        } else {
                            System.err.println("Usage: add <name>"); // Use System.err for usage error
                        }
                        break;

                    case "assign":
                        checkpoint.assignToLane();
                        break;

                    case "process":
                        // Input validation and specific error handling for 'process' command
                        if (parts.length > 1) {
                            try {
                                // Attempt to parse lane number (1-based)
                                int laneNumber = Integer.parseInt(parts[1]);
                                // Convert 1-based user input to 0-based index for internal List access
                                checkpoint.processLane(laneNumber - 1);
                            } catch (NumberFormatException e) {
                                // Catch specific error for non-integer input using System.err
                                System.err.println("Invalid lane number format. Please enter a number.");
                            }
                        } else {
                            System.err.println("Usage: process <lane_number>"); // Use System.err for usage error
                        }
                        break;

                    case "status":
                        checkpoint.getStatus();
                        break;

                    case "exit":
                        System.out.println("Exiting simulation."); // Use System.out for exit message
                        running = false; // Set flag to end loop
                        break;

                    default:
                        // Handle unknown commands using System.err
                        System.err.println("Unknown command: " + command);
                        System.out.println("Available commands: add <name>, assign, process <lane_number>, status, exit"); // Use System.out for help
                        break;
                }
            } catch (Exception e) {
                // General catch-all for any other unexpected runtime exceptions
                System.err.println("An unexpected error occurred during command execution: " + e.getMessage());
                // Optional: e.printStackTrace(); for detailed debugging
            }
        }

        scanner.close(); // Close the scanner resource
        System.out.println("Simulation ended."); // Use System.out for final message
    }
}
