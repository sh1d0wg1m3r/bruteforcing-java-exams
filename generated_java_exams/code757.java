/*
 * Exam Question #757
 * Generated on: 2025-05-12 16:36:24
 * Generated by: Account 4
 * 
 * QUESTION:
 * **Advanced Task Scheduling System**
 * 
 * You are tasked with developing a command-line application for a simple task scheduling system. The system should allow users to add new tasks, view pending tasks, process the next available task, and view a history of completed tasks. The system must handle user input, manage tasks using appropriate data structures, and provide clear output and error handling.
 * 
 * **Requirements:**
 * 
 * 1.  **Task Representation:** Create a class `Task` with private fields for `description` (String) and `type` (String, e.g., "Feature", "Bug", "Refactor"). Include a constructor and public getter methods. Override `toString()` for easy printing.
 * 2.  **Task Management:** Create a class `TaskScheduler` that manages the tasks.
 *     *   It must use a `java.util.Queue` (specifically, a `LinkedList` implementation) to store tasks that are pending processing. Tasks should be processed in the order they were added (FIFO).
 *     *   It must use a `java.util.ArrayList` to store tasks that have been successfully processed.
 *     *   Provide public methods:
 *         *   `addTask(Task task)`: Adds a task to the pending queue.
 *         *   `processNextTask()`: Removes the next task from the pending queue, simulates processing (print a message), and adds it to the processed list. If the queue is empty, it should indicate an error using `System.err`.
 *         *   `getPendingTasks()`: Returns a `List` (use the interface type) containing the current tasks in the pending queue *without* removing them.
 *         *   `getProcessedTasks()`: Returns a `List` (use the interface type) containing the tasks in the processed list.
 *         *   `getPendingTaskCount()`: Returns the number of tasks in the pending queue.
 *         *   `getProcessedTaskCount()`: Returns the number of tasks in the processed list.
 * 3.  **User Interface:** Implement a main application class (e.g., `TaskSchedulerApp`) with a `main` method.
 *     *   Use `java.util.Scanner` to get user input from the console.
 *     *   Present a menu of options to the user:
 *         1.  Add New Task
 *         2.  View Pending Tasks
 *         3.  Process Next Task
 *         4.  View Processed Tasks
 *         5.  Exit
 *     *   Use a `switch` statement to handle the user's menu choice.
 *     *   Implement input validation for menu choices (ensure it's an integer within the valid range). Handle non-integer input gracefully.
 *     *   Implement input validation for task details (e.g., description cannot be empty).
 *     *   Use `System.out` for menu display, prompts, successful actions, and task listings.
 *     *   Use `System.err` for *all* error messages (e.g., invalid input, empty queue when processing).
 * 4.  **Exception Handling:** Implement class-wide exception handling in the `main` method using a `try-catch` block to catch potential unexpected errors during the application's execution (e.g., `InputMismatchException` from Scanner, or other runtime errors). The `catch` block should print an error message using `System.err` before the application potentially exits or continues.
 * 5.  **Best Practices:** Adhere to Java best practices:
 *     *   Proper encapsulation (private fields, public getters/methods).
 *     *   Meaningful variable and method names.
 *     *   Appropriate comments and documentation (JavaDocs).
 *     *   Clean code structure.
 * 
 * **Expected Output:**
 * 
 * The application should display a menu, prompt for input, and perform actions based on the user's choice. Error messages should go to `System.err`. Successful output and prompts should go to `System.out`.
 * 
 * Example Interaction Flow:
 * 
 * ```
 * --- Task Scheduler Menu ---
 * 1. Add New Task
 * 2. View Pending Tasks
 * 3. Process Next Task
 * 4. View Processed Tasks
 * 5. Exit
 * Enter your choice: 1
 * Enter task description: Implement login feature
 * Enter task type (Feature, Bug, Refactor): Feature
 * Task added to the queue. Pending tasks: 1
 * 
 * --- Task Scheduler Menu ---
 * 1. Add New Task
 * ...
 * Enter your choice: 2
 * Pending Tasks (1 total):
 * Task{description='Implement login feature', type='Feature'}
 * 
 * --- Task Scheduler Menu ---
 * ...
 * Enter your choice: 3
 * Processing task: Task{description='Implement login feature', type='Feature'}
 * Task processed successfully. Processed tasks: 1
 * 
 * --- Task Scheduler Menu ---
 * ...
 * Enter your choice: 3
 * (If queue is empty)
 * Error: No tasks are pending processing. (This goes to System.err)
 * 
 * --- Task Scheduler Menu ---
 * ...
 * Enter your choice: 4
 * Processed Tasks (1 total):
 * Task{description='Implement login feature', type='Feature'}
 * 
 * --- Task Scheduler Menu ---
 * ...
 * Enter your choice: 6 (Invalid input)
 * Error: Invalid menu choice. Please enter a number between 1 and 5. (This goes to System.err)
 * 
 * --- Task Scheduler Menu ---
 * ...
 * Enter your choice: abc (Invalid input type)
 * Error: Invalid input. Please enter a number. (This goes to System.err, caught by try-catch)
 * 
 * --- Task Scheduler Menu ---
 * ...
 * Enter your choice: 5
 * Exiting Task Scheduler.
 * ```
 * 
 * Your solution should provide the complete Java code for the `Task`, `TaskScheduler`, and `TaskSchedulerApp` classes.
 *
 * EXPLANATION:
 * The provided solution implements a simple task scheduling system demonstrating the required Java concepts and best practices.
 * 
 * 1.  **`Task` Class:** This class serves as a simple data structure representing a task. It encapsulates the `description` and `type` fields as private, providing public getter methods. The `toString()` method is overridden for convenient display of task information. This fulfills the requirement for encapsulation and a basic object representation.
 * 
 * 2.  **`TaskScheduler` Class:** This is the core logic class.
 *     *   It uses `java.util.Queue<Task>` implemented by `java.util.LinkedList<Task>` (`pendingTasksQueue`) to store tasks awaiting processing. The `offer()` method adds tasks to the tail, and `poll()` retrieves and removes tasks from the head, ensuring FIFO order as required by a queue.
 *     *   It uses `java.util.ArrayList<Task>` (`processedTasksList`) to store tasks once they have been processed.
 *     *   `addTask()` adds a task to the `pendingTasksQueue`.
 *     *   `processNextTask()` uses `poll()` to get the next task. It checks if `poll()` returned `null` (indicating an empty queue) and prints an error to `System.err` if so. Otherwise, it simulates processing by printing to `System.out` and adds the task to `processedTasksList`.
 *     *   `getPendingTasks()` and `getProcessedTasks()` methods return copies of the internal lists (using `new ArrayList<>(...)`) and are declared to return the `java.util.List` interface type. This demonstrates using the interface rather than the concrete implementation type in method signatures, promoting flexibility.
 *     *   `getPendingTaskCount()` and `getProcessedTaskCount()` provide the sizes of the respective collections.
 * 
 * 3.  **`TaskSchedulerApp` Class:** This is the main application class with the `main` method.
 *     *   It initializes a `TaskScheduler` and a `java.util.Scanner` for user input.
 *     *   The `run()` method contains the main application loop.
 *     *   The `displayMenu()` method prints the available options to `System.out`.
 *     *   A `while` loop keeps the application running until the user chooses to exit (option 5).
 *     *   Inside the loop, a `try-catch (InputMismatchException e)` block is used specifically to handle cases where the user enters non-integer input for the menu choice. It prints an error to `System.err` and consumes the invalid input using `scanner.next()` to prevent an infinite loop.
 *     *   A `switch` statement handles the valid integer menu choices, calling the appropriate methods (`addNewTask`, `viewPendingTasks`, `scheduler.processNextTask`, `viewProcessedTasks`).
 *     *   Invalid integer choices (outside 1-5) are caught by the `default` case in the `switch`, printing an error to `System.err`.
 *     *   `addNewTask()` prompts the user for task details using `scanner.nextLine()`. It includes basic input validation to check if the description or type is empty, printing errors to `System.err` if they are. Valid tasks are then added to the scheduler.
 *     *   `viewPendingTasks()` and `viewProcessedTasks()` retrieve the task lists from the scheduler and iterate through them, printing each task's details to `System.out`.
 *     *   **Class-wide Exception Handling:** The entire `while` loop within the `run()` method is wrapped in a broader `try-catch (Exception e)` block. This catches any *other* unexpected runtime exceptions that might occur during the program's execution, providing a general error message to `System.err` and printing the stack trace to `System.err` for debugging. A `finally` block ensures the `Scanner` is closed.
 *     *   `System.out` is used for all standard output (menu, prompts, task listings, success messages).
 *     *   `System.err` is exclusively used for all error messages (invalid input, empty queue, unexpected exceptions).
 * 
 * This solution effectively integrates all required components (`Queue`, `ArrayList`, `List`, `Scanner`, `Switch`, `System.err`, `System.out`, `try-catch`) into a practical, albeit simple, application while adhering to good programming practices like encapsulation, meaningful names, and error handling.
 */

import java.util.LinkedList;
import java.util.Queue;
import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;
import java.util.InputMismatchException;

/**
 * Represents a single task in the scheduler.
 */
class Task {
    private String description;
    private String type; // e.g., "Feature", "Bug", "Refactor"

    /**
     * Constructs a new Task.
     *
     * @param description The description of the task.
     * @param type        The type of the task.
     */
    public Task(String description, String type) {
        this.description = description;
        this.type = type;
    }

    /**
     * Gets the description of the task.
     *
     * @return The task description.
     */
    public String getDescription() {
        return description;
    }

    /**
     * Gets the type of the task.
     *
     * @return The task type.
     */
    public String getType() {
        return type;
    }

    /**
     * Returns a string representation of the Task.
     *
     * @return A formatted string describing the task.
     */
    @Override
    public String toString() {
        return "Task{description='" + description + "', type='" + type + "'}";
    }
}

/**
 * Manages the pending and processed tasks.
 */
class TaskScheduler {
    // Use LinkedList as a Queue implementation for pending tasks (FIFO)
    private Queue<Task> pendingTasksQueue;
    // Use ArrayList to store processed tasks
    private ArrayList<Task> processedTasksList;

    /**
     * Constructs a new TaskScheduler.
     */
    public TaskScheduler() {
        this.pendingTasksQueue = new LinkedList<>();
        this.processedTasksList = new ArrayList<>();
    }

    /**
     * Adds a task to the pending queue.
     *
     * @param task The task to add.
     */
    public void addTask(Task task) {
        if (task != null) {
            pendingTasksQueue.offer(task); // offer is generally preferred over add for queues
        }
    }

    /**
     * Processes the next task from the pending queue.
     * Removes the task from the queue, simulates processing, and adds it to the processed list.
     * Prints an error to System.err if the queue is empty.
     */
    public void processNextTask() {
        Task nextTask = pendingTasksQueue.poll(); // Retrieves and removes the head of the queue
        if (nextTask != null) {
            System.out.println("Processing task: " + nextTask);
            // Simulate processing...
            processedTasksList.add(nextTask);
            System.out.println("Task processed successfully. Processed tasks: " + processedTasksList.size());
        } else {
            System.err.println("Error: No tasks are pending processing.");
        }
    }

    /**
     * Gets a list of tasks currently in the pending queue.
     * The tasks remain in the queue.
     *
     * @return A List of pending tasks. Returns an empty list if the queue is empty.
     */
    public List<Task> getPendingTasks() {
        // Create a new list to avoid exposing the internal queue structure directly
        // Iterating over the queue provides the elements without removing them
        return new ArrayList<>(pendingTasksQueue);
    }

    /**
     * Gets a list of tasks that have been processed.
     *
     * @return A List of processed tasks. Returns an empty list if no tasks have been processed.
     */
    public List<Task> getProcessedTasks() {
        // Return a copy to maintain encapsulation, though ArrayList is often copied implicitly
        // when returned, returning a new list is safer if internal modifications were possible.
        // For this simple case, returning the list directly is acceptable per common practice
        // in simpler examples, but returning a copy is better practice for complex systems.
        // Let's return a copy to be explicit about not modifying the internal list externally.
        return new ArrayList<>(processedTasksList);
    }

    /**
     * Gets the number of tasks currently in the pending queue.
     *
     * @return The count of pending tasks.
     */
    public int getPendingTaskCount() {
        return pendingTasksQueue.size();
    }

    /**
     * Gets the number of tasks that have been processed.
     *
     * @return The count of processed tasks.
     */
    public int getProcessedTaskCount() {
        return processedTasksList.size();
    }
}

/**
 * Main application class for the Task Scheduler.
 * Handles user interaction, menu, and orchestrates the TaskScheduler.
 */
public class TaskSchedulerApp {

    private TaskScheduler scheduler;
    private Scanner scanner;

    /**
     * Constructs the TaskSchedulerApp.
     */
    public TaskSchedulerApp() {
        this.scheduler = new TaskScheduler();
        this.scanner = new Scanner(System.in);
    }

    /**
     * Displays the main menu to the user.
     */
    private void displayMenu() {
        System.out.println("\n--- Task Scheduler Menu ---");
        System.out.println("1. Add New Task");
        System.out.println("2. View Pending Tasks (" + scheduler.getPendingTaskCount() + ")");
        System.out.println("3. Process Next Task");
        System.out.println("4. View Processed Tasks (" + scheduler.getProcessedTaskCount() + ")");
        System.out.println("5. Exit");
        System.out.print("Enter your choice: ");
    }

    /**
     * Runs the main application loop.
     * Includes class-wide exception handling.
     */
    public void run() {
        int choice = -1;

        // Class-wide exception handling for the main application loop
        try {
            while (choice != 5) {
                displayMenu();

                try {
                    choice = scanner.nextInt();
                    scanner.nextLine(); // Consume the newline character

                    switch (choice) {
                        case 1:
                            addNewTask();
                            break;
                        case 2:
                            viewPendingTasks();
                            break;
                        case 3:
                            scheduler.processNextTask();
                            break;
                        case 4:
                            viewProcessedTasks();
                            break;
                        case 5:
                            System.out.println("Exiting Task Scheduler.");
                            break;
                        default:
                            System.err.println("Error: Invalid menu choice. Please enter a number between 1 and 5.");
                    }
                } catch (InputMismatchException e) {
                    System.err.println("Error: Invalid input. Please enter a number.");
                    scanner.next(); // Consume the invalid input to prevent infinite loop
                    choice = -1; // Reset choice to stay in the loop
                }
            }
        } catch (Exception e) {
            // Catch any other unexpected exceptions
            System.err.println("An unexpected error occurred: " + e.getMessage());
            e.printStackTrace(System.err); // Print stack trace to System.err
        } finally {
            // Ensure scanner is closed
            if (scanner != null) {
                scanner.close();
            }
        }
    }

    /**
     * Handles adding a new task based on user input.
     */
    private void addNewTask() {
        System.out.print("Enter task description: ");
        String description = scanner.nextLine().trim();

        if (description.isEmpty()) {
            System.err.println("Error: Task description cannot be empty.");
            return;
        }

        System.out.print("Enter task type (e.g., Feature, Bug, Refactor): ");
        String type = scanner.nextLine().trim();

        // Basic type validation (optional but good practice)
        // Could make this more robust with enums or a predefined list
        if (type.isEmpty()) {
             System.err.println("Error: Task type cannot be empty.");
             return;
        }

        Task newTask = new Task(description, type);
        scheduler.addTask(newTask);
        System.out.println("Task added to the queue. Pending tasks: " + scheduler.getPendingTaskCount());
    }

    /**
     * Displays the list of pending tasks.
     */
    private void viewPendingTasks() {
        List<Task> pending = scheduler.getPendingTasks();
        System.out.println("Pending Tasks (" + pending.size() + " total):");
        if (pending.isEmpty()) {
            System.out.println("No pending tasks.");
        } else {
            for (int i = 0; i < pending.size(); i++) {
                System.out.println((i + 1) + ". " + pending.get(i));
            }
        }
    }

    /**
     * Displays the list of processed tasks.
     */
    private void viewProcessedTasks() {
        List<Task> processed = scheduler.getProcessedTasks();
        System.out.println("Processed Tasks (" + processed.size() + " total):");
        if (processed.isEmpty()) {
            System.out.println("No processed tasks.");
        } else {
            for (int i = 0; i < processed.size(); i++) {
                System.out.println((i + 1) + ". " + processed.get(i));
            }
        }
    }

    /**
     * Main entry point of the application.
     *
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        TaskSchedulerApp app = new TaskSchedulerApp();
        app.run();
    }
}
