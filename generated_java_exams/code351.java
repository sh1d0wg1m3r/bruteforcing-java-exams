/*
 * Exam Question #351
 * Generated on: 2025-05-11 22:59:10
 * Generated by: Account 1
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Hospital Appointment and Waiting List System
 * 
 * **Scenario:**
 * 
 * You are tasked with developing a simplified console-based system for managing patient appointments and waiting lists at a small hospital. The system needs to keep track of registered patients, available doctors, scheduled appointments, and patients who are waiting for an appointment because their requested doctor is busy or no specific doctor was chosen.
 * 
 * **Requirements:**
 * 
 * 1.  **Core Functionality:**
 *     *   Allow registration of new patients (ID, Name, Condition).
 *     *   Allow patients to request an appointment. The user should specify the patient ID and optionally a doctor ID.
 *     *   If a specific doctor is requested and is available, schedule the appointment.
 *     *   If a specific doctor is requested but is busy, or if no specific doctor is requested, the patient should be added to a waiting list.
 *     *   Allow processing the waiting list. This action should attempt to schedule the first patient in the waiting list with the first available doctor found. If no doctors are available, the patient remains in the waiting list (or is handled appropriately, e.g., a message is shown).
 *     *   Allow viewing lists of all registered patients, all hospital doctors (pre-populated), all scheduled appointments, and the current waiting list.
 * 
 * 2.  **Java Components:** Your solution *must* use **ALL** of the following Java components:
 *     *   `java.util.Queue`: To manage the waiting list.
 *     *   `java.util.ArrayList`: To store lists of patients, doctors, and appointments.
 *     *   `java.util.List` interface: Declare your list collections using the `List` interface type.
 *     *   `java.util.Scanner`: To handle all user input from the console.
 *     *   `switch` statement: To control the main menu flow.
 *     *   `System.err`: To output error messages (e.g., invalid input, patient/doctor not found).
 *     *   `System.out`: To output normal messages (menu, prompts, success messages, list contents).
 *     *   Class-wide exception handling with `try-catch` blocks: Implement exception handling, particularly for user input errors (`InputMismatchException`) and potentially other unexpected issues. A `try-catch` block should wrap the main application loop.
 * 
 * 3.  **Best Practices:**
 *     *   Implement appropriate classes for `Patient`, `Doctor`, and `Appointment` with private fields and public getter methods (encapsulation).
 *     *   Use meaningful variable and method names.
 *     *   Include comments and basic documentation (e.g., method descriptions).
 *     *   Implement input validation (e.g., check if patient/doctor IDs exist, handle non-numeric input).
 *     *   Ensure proper error handling is demonstrated using `try-catch` and `System.err`.
 *     *   Structure the code cleanly (e.g., main logic in a dedicated system class).
 *     *   Ensure the `Scanner` resource is properly managed (e.g., using try-with-resources).
 * 
 * **Pre-populated Data:**
 * *   You should pre-populate a small list of doctors when the system starts.
 * 
 * **Expected Output:**
 * 
 * The system should present a menu to the user, allowing them to perform the required actions. Output should be clear, using `System.out` for normal operations and `System.err` for errors. The system should gracefully handle incorrect menu choices or invalid input without crashing. Viewing lists should print the current state of each collection.
 * 
 * **Example Interaction Flow (Illustrative):**
 * 
 * ```
 * --- Hospital Appointment System Menu ---
 * 1. Register Patient
 * 2. Request Appointment
 * 3. Process Waiting List
 * 4. View All Lists
 * 5. Exit
 * Enter choice: 1
 * --- Register New Patient ---
 * Enter patient name: Alice
 * Enter patient condition description: Fever
 * Patient registered successfully: Patient [ID=1, Name=Alice, Condition=Fever]
 * 
 * --- Hospital Appointment System Menu ---
 * ...
 * Enter choice: 4
 * --- Registered Patients ---
 * Patient [ID=1, Name=Alice, Condition=Fever]
 * --- Hospital Doctors ---
 * Doctor [ID=1, Name=Dr. Alan Turing, Specialty=General Practice]
 * ...
 * --- Scheduled Appointments ---
 * No appointments scheduled.
 * --- Waiting List ---
 * Waiting list is empty.
 * 
 * --- Hospital Appointment System Menu ---
 * ...
 * Enter choice: 2
 * --- Request Appointment ---
 * Enter patient ID: 1
 * Available Doctors:
 * Doctor [ID=1, Name=Dr. Alan Turing, Specialty=General Practice]
 * ...
 * Enter desired Doctor ID (or 0 for any available doctor): 1
 * Appointment scheduled successfully: Appointment [ID=1, Patient=Alice (ID:1), Doctor=Dr. Alan Turing (ID:1), Time=Scheduled Time Slot 1]
 * 
 * --- Hospital Appointment System Menu ---
 * ...
 * Enter choice: 2
 * --- Request Appointment ---
 * Enter patient ID: 1
 * Available Doctors:
 * ...
 * Enter desired Doctor ID (or 0 for any available doctor): 1
 * Doctor Dr. Alan Turing is currently busy.
 * Adding Patient Alice to the waiting list.
 * Waiting list size: 1
 * 
 * --- Hospital Appointment System Menu ---
 * ...
 * Enter choice: 3
 * --- Processing Waiting List ---
 * Attempting to schedule patients from the waiting list...
 * Successfully scheduled appointment for Alice with Dr. Grace Hopper
 * Finished processing waiting list round. Scheduled 1 appointments.
 * Remaining waiting list size: 0
 * 
 * --- Hospital Appointment System Menu ---
 * ...
 * Enter choice: 5
 * Exiting Hospital Appointment System. Goodbye!
 * Scanner closed. Program finished.
 * ```
 * 
 * Implement the Java code for this system.
 *
 * EXPLANATION:
 * This solution implements a basic hospital appointment system demonstrating the required Java concepts and best practices.
 * 
 * **Class Structure:**
 * *   `Patient`, `Doctor`, and `Appointment`: These are simple Plain Old Java Objects (POJOs) representing the core entities. They have private fields (`id`, `name`, etc.) and public getter methods, demonstrating encapsulation. `toString()` methods are provided for easy printing.
 * *   `HospitalSystem`: This class acts as the controller for the system. It holds the collections (`registeredPatients`, `hospitalDoctors`, `scheduledAppointments`, `waitingList`) and contains methods for all system operations (registration, appointment requests, processing the waiting list, viewing data).
 * 
 * **Required Java Components Usage:**
 * *   `java.util.Queue`: The `waitingList` is declared as a `Queue<Patient>` and instantiated as a `LinkedList`. Patients are added using `offer()` when an appointment cannot be immediately scheduled, and removed using `poll()` when processing the waiting list. `peek()` is used to look at the next patient without removing them.
 * *   `java.util.ArrayList`: The collections `registeredPatients`, `hospitalDoctors`, and `scheduledAppointments` are instantiated as `ArrayList`. `ArrayList` is suitable here for storing and iterating over lists of objects where elements are typically accessed by index or iterated sequentially.
 * *   `java.util.List` interface: All list collections (`registeredPatients`, `hospitalDoctors`, `scheduledAppointments`) are declared using the `List` interface (`List<Patient>`, `List<Doctor>`, `List<Appointment>`). This promotes good practice by programming to the interface rather than the concrete implementation.
 * *   `java.util.Scanner`: Used in the `main` method and passed to methods like `registerPatient` and `requestAppointment` to read user input from `System.in`. It's managed using a try-with-resources block in `main` to ensure it's closed automatically.
 * *   `switch` statement: The `main` method uses a `switch` statement to handle the user's menu choice, directing the program flow to the appropriate method call.
 * *   `System.err`: Used to print error messages, such as when input is invalid (`InputMismatchException`), when a patient or doctor ID is not found, or for unexpected system errors caught by the main `try-catch` block.
 * *   `System.out`: Used for all standard output, including displaying the menu, prompting the user for input, printing success messages, and displaying the contents of the various lists and the waiting list.
 * *   `Class-wide exception handling with try-catch blocks`:
 *     *   The main `while` loop in the `main` method is wrapped in a `try-catch(Exception e)`. This provides a top-level handler for any unexpected exceptions that might occur during the system's operation, preventing the program from crashing abruptly and printing the error to `System.err`.
 *     *   Specific `try-catch(InputMismatchException e)` blocks are used when reading integer input (`scanner.nextInt()`) in `main` and `requestAppointment` to catch cases where the user enters non-numeric text. The `catch` block prints an error message to `System.err` and consumes the invalid input using `scanner.nextLine()` to prevent an infinite loop.
 *     *   A `finally` block is used in `requestAppointment`'s `nextInt()` calls to ensure `scanner.nextLine()` is called to consume the remaining newline character, regardless of whether `nextInt()` succeeded or threw an exception. This is crucial before subsequent `scanner.nextLine()` calls that read entire lines.
 * 
 * **Functionality Details:**
 * *   **Registration:** `registerPatient` reads name and condition, performs basic validation for empty strings, creates a `Patient` object, and adds it to the `registeredPatients ArrayList`.
 * *   **Appointment Request:** `requestAppointment` reads patient and doctor IDs, validates their existence using helper methods (`findPatientById`, `findDoctorById`). It checks doctor availability using `isDoctorBusy`. If a doctor is available (either requested or any if 0 was entered), an `Appointment` is created and added to the `scheduledAppointments ArrayList`. Otherwise, the patient is added to the `waitingList Queue` using `offer()`.
 * *   **Waiting List Processing:** `processWaitingList` checks if the `waitingList` is empty. If not, it loops, attempting to find an `availableDoctor` using a helper method. If a doctor is found, it `poll()`s the first patient from the `waitingList` and schedules an appointment, adding it to the `scheduledAppointments ArrayList`. If no doctor is available, the loop breaks, leaving remaining patients in the queue.
 * *   **Viewing Lists:** `viewLists` iterates through each collection (`ArrayList`s and `Queue`) and prints the `toString()` representation of each element. `forEach` loops are used for conciseness.
 * *   **Helper Methods:** `findPatientById`, `findDoctorById`, `isDoctorBusy`, and `findAvailableDoctor` encapsulate specific logic, making the main methods cleaner. They iterate over the `List` collections.
 * 
 * **Best Practices Implementation:**
 * *   **Encapsulation:** Achieved through private fields and public getters in entity classes.
 * *   **Naming:** Variable and method names are descriptive (e.g., `waitingList`, `requestAppointment`, `findAvailableDoctor`).
 * *   **Comments:** Javadoc-style comments explain the purpose of classes and methods.
 * *   **Input Validation:** Checks for empty strings and verifies if IDs correspond to existing objects. `InputMismatchException` handling validates input type.
 * *   **Error Handling:** Clear error messages are printed to `System.err`, and `try-catch` blocks handle potential runtime issues.
 * *   **Clean Structure:** Logic is divided into methods within the `HospitalSystem` class, separating concerns from the main execution loop.
 * 
 * This solution effectively combines the required Java components in a practical scenario, demonstrating understanding of collection types, control flow, object-oriented principles, and robust error handling.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.InputMismatchException;

/**
 * Represents a patient in the hospital system.
 */
class Patient {
    private int id;
    private String name;
    private String condition;

    /**
     * Constructs a new Patient.
     * @param id The unique patient ID.
     * @param name The patient's name.
     * @param condition A description of the patient's condition.
     */
    public Patient(int id, String name, String condition) {
        this.id = id;
        this.name = name;
        this.condition = condition;
    }

    // --- Getters ---
    public int getId() { return id; }
    public String getName() { return name; }
    public String getCondition() { return condition; }

    @Override
    public String toString() {
        return "Patient [ID=" + id + ", Name=" + name + ", Condition=" + condition + "]";
    }
}

/**
 * Represents a doctor in the hospital system.
 */
class Doctor {
    private int id;
    private String name;
    private String specialty;

    /**
     * Constructs a new Doctor.
     * @param id The unique doctor ID.
     * @param name The doctor's name.
     * @param specialty The doctor's medical specialty.
     */
    public Doctor(int id, String name, String specialty) {
        this.id = id;
        this.name = name;
        this.specialty = specialty;
    }

    // --- Getters ---
    public int getId() { return id; }
    public String getName() { return name; }
    public String getSpecialty() { return specialty; }

    @Override
    public String toString() {
        return "Doctor [ID=" + id + ", Name=" + name + ", Specialty=" + specialty + "]";
    }
}

/**
 * Represents a scheduled appointment.
 */
class Appointment {
    private int id;
    private Patient patient;
    private Doctor doctor;
    private String timeSlot; // Simplified time slot representation

    /**
     * Constructs a new Appointment.
     * @param id The unique appointment ID.
     * @param patient The patient for the appointment.
     * @param doctor The doctor for the appointment.
     * @param timeSlot The time slot for the appointment.
     */
    public Appointment(int id, Patient patient, Doctor doctor, String timeSlot) {
        this.id = id;
        this.patient = patient;
        this.doctor = doctor;
        this.timeSlot = timeSlot;
    }

    // --- Getters ---
    public int getId() { return id; }
    public Patient getPatient() { return patient; }
    public Doctor getDoctor() { return doctor; }
    public String getTimeSlot() { return timeSlot; }

    @Override
    public String toString() {
        return "Appointment [ID=" + id + ", Patient=" + patient.getName() + " (ID:" + patient.getId() + "), Doctor=" + doctor.getName() + " (ID:" + doctor.getId() + "), Time=" + timeSlot + "]";
    }
}

/**
 * The main class managing the hospital appointment system.
 */
public class HospitalSystem {

    // Collections as required, using List interface and ArrayList/LinkedList implementations
    private List<Patient> registeredPatients = new ArrayList<>();
    private List<Doctor> hospitalDoctors = new ArrayList<>();
    private List<Appointment> scheduledAppointments = new ArrayList<>();
    private Queue<Patient> waitingList = new LinkedList<>(); // Queue for waiting patients

    private int patientIdCounter = 1;
    private int doctorIdCounter = 1;
    private int appointmentIdCounter = 1;

    /**
     * Constructs the HospitalSystem and pre-populates doctors.
     */
    public HospitalSystem() {
        // Pre-populate some doctors
        hospitalDoctors.add(new Doctor(doctorIdCounter++, "Dr. Alan Turing", "General Practice"));
        hospitalDoctors.add(new Doctor(doctorIdCounter++, "Dr. Grace Hopper", "Internal Medicine"));
        hospitalDoctors.add(new Doctor(doctorIdCounter++, "Dr. Ada Lovelace", "Pediatrics"));
        hospitalDoctors.add(new Doctor(doctorIdCounter++, "Dr. Marie Curie", "Oncology"));
    }

    // --- Core Functionality Methods ---

    /**
     * Registers a new patient in the system based on user input.
     * @param scanner Scanner for user input.
     */
    public void registerPatient(Scanner scanner) {
        System.out.println("\n--- Register New Patient ---");
        System.out.print("Enter patient name: ");
        String name = scanner.nextLine();
        if (name.trim().isEmpty()) {
             System.err.println("Error: Patient name cannot be empty.");
             return;
        }

        System.out.print("Enter patient condition description: ");
        String condition = scanner.nextLine();
         if (condition.trim().isEmpty()) {
             System.err.println("Error: Patient condition cannot be empty.");
             return;
        }

        Patient newPatient = new Patient(patientIdCounter++, name, condition);
        registeredPatients.add(newPatient); // Add to ArrayList
        System.out.println("Patient registered successfully: " + newPatient);
    }

    /**
     * Requests an appointment for a patient. Schedules if possible, otherwise adds to waiting list.
     * Handles user input and validation.
     * @param scanner Scanner for user input.
     */
    public void requestAppointment(Scanner scanner) {
        System.out.println("\n--- Request Appointment ---");

        System.out.print("Enter patient ID: ");
        int patientId;
        try {
            patientId = scanner.nextInt();
        } catch (InputMismatchException e) {
            System.err.println("Error: Invalid input for patient ID. Please enter a number.");
            return; // Exit method on error
        } finally {
             scanner.nextLine(); // Consume the newline character left by nextInt()
        }

        Patient patient = findPatientById(patientId);
        if (patient == null) {
            System.err.println("Error: Patient with ID " + patientId + " not found.");
            return; // Exit method if patient doesn't exist
        }

        System.out.println("Available Doctors:");
        viewDoctors(); // Helper to show doctors
        System.out.print("Enter desired Doctor ID (or 0 for any available doctor): ");
        int doctorId;
         try {
            doctorId = scanner.nextInt();
        } catch (InputMismatchException e) {
            System.err.println("Error: Invalid input for doctor ID. Please enter a number.");
            return; // Exit method on error
        } finally {
             scanner.nextLine(); // Consume the newline character left by nextInt()
        }

        Doctor doctor = null;
        if (doctorId != 0) {
            doctor = findDoctorById(doctorId);
            if (doctor == null) {
                System.err.println("Error: Doctor with ID " + doctorId + " not found. Attempting to find any available doctor instead.");
                // Doctor not found, proceed as if no specific doctor was requested
            }
        }

        // If a specific doctor was found, check their availability
        if (doctor != null && isDoctorBusy(doctor)) {
             System.out.println("Doctor " + doctor.getName() + " is currently busy.");
             doctor = null; // Treat as if no specific doctor was available/requested
        }

        // Attempt to schedule if an available doctor (either requested or any) is found
        if (doctor != null) {
            // Schedule appointment with the requested/found available doctor
            String timeSlot = "Slot " + appointmentIdCounter; // Simple unique slot

            Appointment newAppointment = new Appointment(appointmentIdCounter++, patient, doctor, timeSlot);
            scheduledAppointments.add(newAppointment); // Add to ArrayList
            System.out.println("Appointment scheduled successfully: " + newAppointment);
        } else {
            // Add patient to waiting list if no specific doctor requested, or doctor not found, or doctor busy
            System.out.println("No specific doctor available or requested. Adding Patient " + patient.getName() + " to the waiting list.");
            waitingList.offer(patient); // Add to the Queue
            System.out.println("Waiting list size: " + waitingList.size());
        }
    }

    /**
     * Processes the waiting list, attempting to schedule appointments with available doctors.
     */
    public void processWaitingList() {
        System.out.println("\n--- Processing Waiting List ---");
        if (waitingList.isEmpty()) {
            System.out.println("Waiting list is empty.");
            return;
        }

        System.out.println("Attempting to schedule patients from the waiting list...");
        int scheduledCount = 0;

        // Process patients one by one from the queue as long as there are patients and doctors
        while (!waitingList.isEmpty()) {
            Doctor availableDoctor = findAvailableDoctor();

            if (availableDoctor != null) {
                // Remove from queue and schedule
                Patient waitingPatient = waitingList.poll(); // Remove from the Queue
                if (waitingPatient == null) { // Should not happen if isEmpty() is false, but safe check
                    System.err.println("Internal error: Polled null from non-empty waiting list.");
                    continue;
                }

                String timeSlot = "Slot " + appointmentIdCounter; // Simple unique slot

                Appointment newAppointment = new Appointment(appointmentIdCounter++, waitingPatient, availableDoctor, timeSlot);
                scheduledAppointments.add(newAppointment); // Add to ArrayList
                System.out.println("Successfully scheduled appointment for " + waitingPatient.getName() + " (ID:" + waitingPatient.getId() + ") with " + availableDoctor.getName() + " (ID:" + availableDoctor.getId() + ")");
                scheduledCount++;
            } else {
                // No doctors available right now. Stop processing the queue for this round.
                System.out.println("No available doctors found to process remaining waiting list patients.");
                break; // Exit the while loop
            }
        }
         System.out.println("Finished processing waiting list round. Scheduled " + scheduledCount + " appointments.");
         System.out.println("Remaining waiting list size: " + waitingList.size());
    }

    /**
     * Views all registered patients, doctors, scheduled appointments, and the waiting list.
     */
    public void viewLists() {
        System.out.println("\n--- Registered Patients ---");
        if (registeredPatients.isEmpty()) {
            System.out.println("No patients registered.");
        } else {
            registeredPatients.forEach(System.out::println); // Using List and stream/forEach
        }

        System.out.println("\n--- Hospital Doctors ---");
         if (hospitalDoctors.isEmpty()) {
            System.out.println("No doctors registered.");
        } else {
            viewDoctors(); // Helper to show doctors using List
        }

        System.out.println("\n--- Scheduled Appointments ---");
        if (scheduledAppointments.isEmpty()) {
            System.out.println("No appointments scheduled.");
        } else {
            scheduledAppointments.forEach(System.out::println); // Using List and stream/forEach
        }

        System.out.println("\n--- Waiting List ---");
        if (waitingList.isEmpty()) {
            System.out.println("Waiting list is empty.");
        } else {
            // Iterate the queue for viewing without removing elements
            waitingList.forEach(patient -> System.out.println("Waiting: " + patient.getName() + " (ID:" + patient.getId() + ")")); // Using Queue and forEach
        }
    }

     /**
     * Helper method to display doctors from the list.
     */
    private void viewDoctors() {
         hospitalDoctors.forEach(System.out::println);
    }


    // --- Helper Methods ---

    /**
     * Finds a patient by their ID in the registered patients list.
     * @param id The patient ID.
     * @return The Patient object or null if not found.
     */
    private Patient findPatientById(int id) {
        for (Patient patient : registeredPatients) { // Iterating over List
            if (patient.getId() == id) {
                return patient;
            }
        }
        return null;
    }

    /**
     * Finds a doctor by their ID in the hospital doctors list.
     * @param id The doctor ID.
     * @return The Doctor object or null if not found.
     */
    private Doctor findDoctorById(int id) {
        for (Doctor doctor : hospitalDoctors) { // Iterating over List
            if (doctor.getId() == id) {
                return doctor;
            }
        }
        return null;
    }

    /**
     * Checks if a doctor is currently busy (has a scheduled appointment).
     * In this simple model, a doctor is busy if they appear in *any* scheduled appointment.
     * @param doctor The doctor to check.
     * @return true if the doctor is busy, false otherwise.
     */
    private boolean isDoctorBusy(Doctor doctor) {
        for (Appointment appointment : scheduledAppointments) { // Iterating over List
            if (appointment.getDoctor().getId() == doctor.getId()) {
                return true;
            }
        }
        return false;
    }

    /**
     * Finds the first available doctor from the hospital doctors list.
     * @return An available Doctor object or null if none are available.
     */
    private Doctor findAvailableDoctor() {
        for (Doctor doctor : hospitalDoctors) { // Iterating over List
            if (!isDoctorBusy(doctor)) {
                return doctor;
            }
        }
        return null; // No available doctors
    }


    // --- Main Method with Menu ---

    public static void main(String[] args) {
        // Use try-with-resources for Scanner to ensure it's closed automatically
        try (Scanner scanner = new Scanner(System.in)) {
            HospitalSystem system = new HospitalSystem();
            boolean running = true;

            // Class-wide exception handling with try-catch block around the main loop
            try {
                while (running) {
                    System.out.println("\n--- Hospital Appointment System Menu ---");
                    System.out.println("1. Register Patient");
                    System.out.println("2. Request Appointment");
                    System.out.println("3. Process Waiting List");
                    System.out.println("4. View All Lists");
                    System.out.println("5. Exit");
                    System.out.print("Enter choice: ");

                    int choice = -1;
                    try {
                        choice = scanner.nextInt();
                        // Consume the newline character left by nextInt() immediately after successful read
                        scanner.nextLine();
                    } catch (InputMismatchException e) {
                        System.err.println("Invalid input. Please enter a number between 1 and 5.");
                        scanner.nextLine(); // Consume the invalid input AND the newline
                        continue; // Skip to next iteration of the main loop
                    }

                    // Use switch statement for flow control
                    switch (choice) {
                        case 1:
                            system.registerPatient(scanner);
                            break;
                        case 2:
                            system.requestAppointment(scanner);
                            break;
                        case 3:
                            system.processWaitingList();
                            break;
                        case 4:
                            system.viewLists();
                            break;
                        case 5:
                            System.out.println("Exiting Hospital Appointment System. Goodbye!");
                            running = false;
                            break;
                        default:
                            System.err.println("Invalid choice. Please enter a number between 1 and 5.");
                            break;
                    }
                }
            } catch (Exception e) {
                // Catch any unexpected exceptions during the main loop execution
                System.err.println("An unexpected system error occurred: " + e.getMessage());
                e.printStackTrace(System.err); // Print stack trace to System.err for debugging
            }

        } // Scanner is automatically closed here by try-with-resources
        System.out.println("Scanner closed. Program finished.");
    }
}
