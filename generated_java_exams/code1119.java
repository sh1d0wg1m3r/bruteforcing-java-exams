/*
 * Exam Question #1119
 * Generated on: 2025-05-12 17:27:32
 * Generated by: Account 2
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Print Job Management System
 * 
 * **Problem Description:**
 * 
 * Design and implement a simple console-based Print Job Management System. This system will allow users to add print jobs to a queue, process the next job in the queue, and view the list of pending and completed jobs.
 * 
 * The system should simulate a real-world scenario where print requests arrive and are processed sequentially.
 * 
 * **Requirements:**
 * 
 * 1.  **Data Structures:**
 *     *   Use a `java.util.Queue` to store pending print jobs. Jobs should be processed in the order they are added (FIFO - First-In, First-Out).
 *     *   Use a `java.util.ArrayList` to store completed print jobs.
 *     *   Use the `java.util.List` interface when returning collections of jobs (pending or completed) from the manager class to the main application logic, demonstrating abstraction.
 * 
 * 2.  **User Interaction:**
 *     *   Use `java.util.Scanner` to read user input from the console.
 *     *   Present a menu of options to the user: Add Job, Process Next Job, View Print Queue, View Completed Jobs, Exit.
 *     *   Use a `switch` statement to handle the user's menu choice.
 * 
 * 3.  **Error Handling:**
 *     *   Implement input validation. For example, the number of pages for a print job must be a positive integer.
 *     *   Use `System.err` to display all error messages (e.g., invalid input, queue empty when processing).
 *     *   Use `System.out` for all normal output (menu, prompts, status messages, job details).
 *     *   Implement class-wide exception handling using `try-catch` blocks to gracefully handle potential issues like invalid numeric input (`InputMismatchException`) or other unexpected errors, ensuring the program doesn't crash unexpectedly. Include a mechanism to ensure the `Scanner` resource is closed.
 * 
 * 4.  **Object-Oriented Design:**
 *     *   Create a `PrintJob` class to represent a single print job (should have fields like Job ID, Document Name, Number of Pages).
 *     *   Create a `PrintJobManager` class responsible for managing the queue and list of jobs (adding, processing, viewing). This class should encapsulate the data structures.
 *     *   The main application logic should reside in a separate class (e.g., `PrintJobSystem`) that interacts with the `PrintJobManager`.
 * 
 * 5.  **Best Practices:**
 *     *   Use appropriate access modifiers (`private`, `public`) for encapsulation.
 *     *   Use meaningful variable and method names.
 *     *   Include comments or basic documentation (e.g., method descriptions).
 *     *   Ensure clean code structure.
 * 
 * **Expected Output:**
 * 
 * The program should display a menu, prompt the user for input, and perform the requested action.
 * 
 * Example Interaction Flow:
 * 
 * ```
 * --- Print Job Management System ---
 * 1. Add New Print Job
 * 2. Process Next Job
 * 3. View Print Queue
 * 4. View Completed Jobs
 * 5. Exit
 * -----------------------------------
 * Enter your choice: 1
 * 
 * --- Add New Print Job ---
 * Enter document name: Report.pdf
 * Enter number of pages: 15
 * Added job: Job ID: 1, Document: 'Report.pdf', Pages: 15
 * 
 * --- Print Job Management System ---
 * ... (menu repeats) ...
 * Enter your choice: 1
 * 
 * --- Add New Print Job ---
 * Enter document name: Image.jpg
 * Enter number of pages: 2
 * Added job: Job ID: 2, Document: 'Image.jpg', Pages: 2
 * 
 * --- Print Job Management System ---
 * ... (menu repeats) ...
 * Enter your choice: 3
 * 
 * --- Current Print Queue ---
 * 1. Job ID: 1, Document: 'Report.pdf', Pages: 15
 * 2. Job ID: 2, Document: 'Image.jpg', Pages: 2
 * 
 * --- Print Job Management System ---
 * ... (menu repeats) ...
 * Enter your choice: 2
 * 
 * --- Process Next Job ---
 * Processed job: Job ID: 1, Document: 'Report.pdf', Pages: 15
 * 
 * --- Print Job Management System ---
 * ... (menu repeats) ...
 * Enter your choice: 3
 * 
 * --- Current Print Queue ---
 * 1. Job ID: 2, Document: 'Image.jpg', Pages: 2
 * 
 * --- Print Job Management System ---
 * ... (menu repeats) ...
 * Enter your choice: 4
 * 
 * --- Completed Jobs ---
 * 1. Job ID: 1, Document: 'Report.pdf', Pages: 15
 * 
 * --- Print Job Management System ---
 * ... (menu repeats) ...
 * Enter your choice: 6
 * Invalid choice. Please enter a number between 1 and 5.
 * 
 * --- Print Job Management System ---
 * ... (menu repeats) ...
 * Enter your choice: abc
 * Invalid input. Please enter a number.
 * 
 * --- Print Job Management System ---
 * ... (menu repeats) ...
 * Enter your choice: 1
 * 
 * --- Add New Print Job ---
 * Enter document name: ImportantDoc
 * Enter number of pages: -5
 * Error adding job: Number of pages must be positive.
 * 
 * --- Print Job Management System ---
 * ... (menu repeats) ...
 * Enter your choice: 5
 * Exiting Print Job System. Goodbye!
 * Scanner closed.
 * ```
 * 
 * **Evaluation:**
 * 
 * Your solution will be evaluated based on:
 * *   Correct implementation and usage of ALL required Java components (`Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.err`, `System.out`, `try-catch`).
 * *   Correct logic for managing the print queue (FIFO) and completed jobs.
 * *   Effective input validation and error handling.
 * *   Adherence to object-oriented principles (encapsulation, class separation).
 * *   Code readability, comments, and adherence to best practices.
 * 
 * You must provide the complete Java code for the solution.
 *
 * EXPLANATION:
 * The provided solution implements a simple console-based Print Job Management System, fulfilling all the requirements of the exam task.
 * 
 * **Key Concepts and Components Demonstrated:**
 * 
 * 1.  **`Queue` (`java.util.Queue`)**: The `printQueue` in the `PrintJobManager` class is declared as a `Queue`. It is initialized with `java.util.LinkedList`, which is a common implementation of the `Queue` interface, ensuring FIFO (First-In, First-Out) behavior. Jobs are added using `offer()` and removed using `poll()`, adhering to standard queue operations.
 * 2.  **`ArrayList` (`java.util.ArrayList`)**: The `completedJobs` list in the `PrintJobManager` is implemented using `ArrayList`. This structure is suitable for storing completed jobs where order of completion is maintained, and random access (though not heavily used here) is efficient.
 * 3.  **`List` interface (`java.util.List`)**: The `viewPrintQueue()` and `viewCompletedJobs()` methods in `PrintJobManager` are designed to return `List<PrintJob>`. This demonstrates the use of the interface for abstraction. The actual collections (`LinkedList` for queue, `ArrayList` for completed) are internal implementation details of the manager. The main `PrintJobSystem` class interacts with these collections via the `List` interface, promoting flexibility and good design. `Collections.unmodifiableList()` is used to return a read-only view, preventing external code from modifying the internal state of the manager.
 * 4.  **`Scanner` (`java.util.Scanner`)**: A `Scanner` object is used in the `main` method of `PrintJobSystem` to read user input for menu choices, document names, and page numbers. It's initialized to read from `System.in`.
 * 5.  **`switch` statement**: The main application loop in `PrintJobSystem.main` uses a `switch` statement based on the user's menu choice (`choice`). This provides a clear and structured way to direct program flow to the appropriate action handler (Add Job, Process Job, etc.).
 * 6.  **`System.err`**: Error messages, such as invalid menu choices, `InputMismatchException` errors during input reading, and `IllegalArgumentException` from validation in `addJob`, are printed to `System.err`. This is standard practice for distinguishing error output from normal program output.
 * 7.  **`System.out`**: All normal program output, including the menu, prompts for input, success messages (like job added or processed), and the lists of pending/completed jobs, is printed to `System.out`.
 * 8.  **Class-wide exception handling with `try-catch`**:
 *     *   The main `while` loop in `PrintJobSystem.main` is wrapped in a `try-catch(Exception e)` block. This serves as a general catch-all for any unexpected errors that might occur during the program's execution, preventing the program from crashing abruptly.
 *     *   Specific `try-catch` blocks are used around `scanner.nextInt()` calls to handle `java.util.InputMismatchException` if the user enters non-numeric input when a number is expected. This specific handling allows the program to print an informative error message using `System.err` and recover by consuming the invalid input and continuing the loop.
 *     *   A `try-catch` block is also used when adding a job to catch the `IllegalArgumentException` thrown by the `PrintJobManager.addJob` method if validation fails (e.g., non-positive pages).
 *     *   A `try-with-resources` statement is used for the `Scanner` object (`try (Scanner scanner = new Scanner(System.in))`). This ensures that the `scanner.close()` method is automatically called when the `try` block is exited, whether normally or due to an exception, preventing resource leaks.
 * 
 * **Object-Oriented Design and Best Practices:**
 * 
 * *   **Encapsulation:** The `PrintJob` and `PrintJobManager` classes encapsulate their data (private fields like `jobId`, `printQueue`, `completedJobs`) and expose controlled access through public methods (`getters`, `addJob`, `processNextJob`, `viewPrintQueue`, etc.).
 * *   **Meaningful Names:** Variables (`documentName`, `numberOfPages`, `printQueue`, `completedJobs`, `nextJobId`), methods (`addJob`, `processNextJob`, `viewPrintQueue`, `printMenu`), and classes (`PrintJob`, `PrintJobManager`, `PrintJobSystem`) are named descriptively, enhancing code readability.
 * *   **Comments/Documentation:** Basic Javadoc-style comments explain the purpose of classes and methods, and inline comments clarify specific logic where needed.
 * *   **Input Validation:** The `addJob` method explicitly checks for empty document names and non-positive page counts, throwing an `IllegalArgumentException`. The `main` method handles `InputMismatchException` for numeric inputs.
 * *   **Clean Code Structure:** The code is organized into logical classes, each with a specific responsibility (`PrintJob` for data, `PrintJobManager` for business logic, `PrintJobSystem` for user interaction). The `printMenu` method is separated for clarity.
 * 
 * This solution effectively integrates the required Java components within a practical scenario, demonstrating robust error handling, proper object-oriented design, and adherence to good programming practices suitable for an advanced exam task.
 */

import java.util.Queue;
import java.util.LinkedList; // A common implementation for Queue
import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;
import java.util.Collections; // To return unmodifiable lists

// Class to represent a single Print Job
class PrintJob {
    private int jobId;
    private String documentName;
    private int numberOfPages;

    /**
     * Constructs a new PrintJob.
     * @param jobId The unique ID for the job.
     * @param documentName The name of the document.
     * @param numberOfPages The number of pages.
     */
    public PrintJob(int jobId, String documentName, int numberOfPages) {
        this.jobId = jobId;
        this.documentName = documentName;
        this.numberOfPages = numberOfPages;
    }

    // Getters for accessing private fields
    public int getJobId() { return jobId; }
    public String getDocumentName() { return documentName; }
    public int getNumberOfPages() { return numberOfPages; }

    /**
     * Provides a string representation of the PrintJob.
     */
    @Override
    public String toString() {
        return "Job ID: " + jobId + ", Document: '" + documentName + "', Pages: " + numberOfPages;
    }
}

// Class to manage the Print Job Queue and Completed Jobs
class PrintJobManager {
    // Use Queue for pending jobs (FIFO)
    private Queue<PrintJob> printQueue;
    // Use ArrayList for completed jobs (order added to completed list)
    private ArrayList<PrintJob> completedJobs;
    private int nextJobId; // Counter for assigning unique job IDs

    /**
     * Constructs a new PrintJobManager, initializing the queue and list.
     */
    public PrintJobManager() {
        this.printQueue = new LinkedList<>(); // LinkedList implements Queue
        this.completedJobs = new ArrayList<>();
        this.nextJobId = 1; // Start job IDs from 1
    }

    /**
     * Adds a new print job to the queue.
     * Performs basic validation on input parameters.
     * @param documentName The name of the document.
     * @param numberOfPages The number of pages in the document.
     * @throws IllegalArgumentException if documentName is null/empty or numberOfPages is not positive.
     */
    public void addJob(String documentName, int numberOfPages) {
        // Input validation
        if (documentName == null || documentName.trim().isEmpty()) {
            throw new IllegalArgumentException("Document name cannot be empty.");
        }
        if (numberOfPages <= 0) {
            throw new IllegalArgumentException("Number of pages must be positive.");
        }

        PrintJob newJob = new PrintJob(nextJobId++, documentName.trim(), numberOfPages);
        printQueue.offer(newJob); // offer() is a good practice for adding to a queue
        System.out.println("Added job: " + newJob);
    }

    /**
     * Processes the next job at the front of the queue.
     * Moves the job from the pending queue to the completed list.
     * @return The processed PrintJob, or null if the queue was empty.
     */
    public PrintJob processNextJob() {
        PrintJob jobToProcess = printQueue.poll(); // poll() removes and returns the head, or null if empty
        if (jobToProcess != null) {
            completedJobs.add(jobToProcess); // Add to the list of completed jobs
            return jobToProcess;
        }
        return null; // Indicate nothing was processed
    }

    /**
     * Returns an unmodifiable view of the current print queue.
     * Uses the List interface for the return type.
     * @return A List representing the jobs currently in the queue.
     */
    public List<PrintJob> viewPrintQueue() {
        // Return an unmodifiable list to prevent external modification of the internal queue state
        // Create a new ArrayList from the queue's elements to maintain order
        return Collections.unmodifiableList(new ArrayList<>(printQueue));
    }

     /**
     * Returns an unmodifiable view of the completed jobs list.
     * Uses the List interface for the return type.
     * @return A List representing the jobs that have been completed.
     */
    public List<PrintJob> viewCompletedJobs() {
        // Return an unmodifiable list to prevent external modification
        return Collections.unmodifiableList(completedJobs);
    }

    /**
     * Checks if the print queue is empty.
     * @return true if the queue is empty, false otherwise.
     */
    public boolean isQueueEmpty() {
        return printQueue.isEmpty();
    }
}

// Main class for the Print Job Management System application
public class PrintJobSystem {

    /**
     * Main method to run the Print Job Management System.
     * Sets up the manager, scanner, and main application loop.
     * Includes class-wide exception handling.
     */
    public static void main(String[] args) {
        PrintJobManager manager = new PrintJobManager();
        // Use try-with-resources for Scanner to ensure it's closed
        try (Scanner scanner = new Scanner(System.in)) {
            boolean running = true;

            // Outer try-catch for general unexpected errors during the application lifecycle
            try {
                while (running) {
                    printMenu(); // Display the menu

                    int choice = -1; // Variable to hold user's menu choice

                    // Inner try-catch for handling potential InputMismatchException for menu choice
                    try {
                        System.out.print("Enter your choice: ");
                        choice = scanner.nextInt();
                        scanner.nextLine(); // Consume the leftover newline character
                    } catch (java.util.InputMismatchException e) {
                        System.err.println("Invalid input. Please enter a number for your choice.");
                        scanner.nextLine(); // Consume the invalid input to prevent infinite loop
                        continue; // Skip the rest of the loop iteration and show menu again
                    }

                    // Use a switch statement to handle different menu options
                    switch (choice) {
                        case 1: // Add Job
                            System.out.println("\n--- Add New Print Job ---");
                            System.out.print("Enter document name: ");
                            String docName = scanner.nextLine();

                            int pages = -1;
                            // Try-catch for reading number of pages and adding the job
                            try {
                                System.out.print("Enter number of pages: ");
                                pages = scanner.nextInt();
                                scanner.nextLine(); // Consume newline

                                // Call the manager method to add the job
                                manager.addJob(docName, pages);
                            } catch (java.util.InputMismatchException e) {
                                System.err.println("Invalid input for pages. Please enter a valid positive number.");
                                scanner.nextLine(); // Consume invalid input
                            } catch (IllegalArgumentException e) {
                                // Catch validation errors from addJob method
                                System.err.println("Error adding job: " + e.getMessage());
                            }
                            break; // End of Case 1

                        case 2: // Process Next Job
                            System.out.println("\n--- Process Next Job ---");
                            PrintJob processedJob = manager.processNextJob();
                            if (processedJob != null) {
                                System.out.println("Processed job: " + processedJob);
                            } else {
                                // Use System.out for informational messages like empty queue
                                System.out.println("Print queue is empty. No jobs to process.");
                            }
                            break; // End of Case 2

                        case 3: // View Print Queue
                            System.out.println("\n--- Current Print Queue ---");
                            List<PrintJob> queueView = manager.viewPrintQueue(); // Get view using List interface
                            if (queueView.isEmpty()) {
                                System.out.println("The print queue is empty.");
                            } else {
                                // Iterate through the List view and print jobs
                                for (int i = 0; i < queueView.size(); i++) {
                                    System.out.println((i + 1) + ". " + queueView.get(i));
                                }
                            }
                            break; // End of Case 3

                        case 4: // View Completed Jobs
                             System.out.println("\n--- Completed Jobs ---");
                            List<PrintJob> completedView = manager.viewCompletedJobs(); // Get view using List interface
                            if (completedView.isEmpty()) {
                                System.out.println("No jobs have been completed yet.");
                            } else {
                                // Iterate through the List view and print jobs
                                for (int i = 0; i < completedView.size(); i++) {
                                    System.out.println((i + 1) + ". " + completedView.get(i));
                                }
                            }
                            break; // End of Case 4

                        case 5: // Exit
                            System.out.println("Exiting Print Job System. Goodbye!");
                            running = false; // Set flag to exit the loop
                            break; // End of Case 5

                        default: // Handle invalid menu choices
                            System.err.println("Invalid choice. Please enter a number between 1 and 5.");
                            break; // End of Default
                    }
                    System.out.println(); // Print a blank line for better readability between menu cycles
                }
            } catch (Exception e) {
                // This catch block handles any unexpected exceptions not caught by specific handlers
                System.err.println("An unexpected system error occurred: " + e.getMessage());
                e.printStackTrace(); // Print stack trace for debugging unexpected errors
            }
        } // Scanner is automatically closed here by try-with-resources
        System.out.println("Scanner resource closed."); // Confirmation message
    }

    /**
     * Prints the main menu options to the console.
     */
    private static void printMenu() {
        System.out.println("--- Print Job Management System ---");
        System.out.println("1. Add New Print Job");
        System.out.println("2. Process Next Job");
        System.out.println("3. View Print Queue");
        System.out.println("4. View Completed Jobs");
        System.out.println("5. Exit");
        System.out.println("-----------------------------------");
    }
}
