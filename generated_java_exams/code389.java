/*
 * Exam Question #389
 * Generated on: 2025-05-11 23:03:54
 * Generated by: Account 3
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Simple Task Scheduler Simulation
 * 
 * **Objective:** Implement a command-line application that simulates a basic task scheduler. The scheduler manages a queue of pending tasks and a list of completed tasks, demonstrating core Java data structures and control flow mechanisms.
 * 
 * **Scenario:** You need to build a system where users can add tasks to a waiting list, process the next task in line, and view both waiting and completed tasks. Tasks are processed in the order they are added (First-In, First-Out).
 * 
 * **Task Definition:**
 * A `Task` object must represent a unit of work. It should contain:
 * -   A `String` for the task's `name`.
 * -   An `int` for the task's `priority` (although the scheduler processes tasks FIFO, this field must be included in the `Task` class).
 * 
 * **Task Scheduler Functionality:**
 * The application should provide the following command-line menu options:
 * 1.  **Add New Task:** Prompt the user for a task name and priority. Create a `Task` object and add it to the queue of pending tasks.
 * 2.  **Process Next Task:** Take the task at the front of the pending queue, remove it, and add it to the list of completed tasks.
 * 3.  **View Pending Tasks:** Display all tasks currently waiting in the pending queue without removing them.
 * 4.  **View Completed Tasks:** Display all tasks that have been processed and moved to the completed list.
 * 5.  **Exit:** Terminate the application.
 * 
 * **Technical Requirements:**
 * Your solution must adhere to the following technical specifications:
 * -   Use `java.util.Queue` (specifically, use `java.util.LinkedList` as the implementation) for managing the collection of **pending tasks**.
 * -   Use `java.util.ArrayList` for storing the collection of **completed tasks**.
 * -   Declare the variable holding the completed tasks using the `java.util.List` **interface**.
 * -   Use `java.util.Scanner` to read user input from the console for menu selection and task details.
 * -   Implement the main menu logic using a `switch` statement.
 * -   Use `System.err.println()` to display all error messages (e.g., invalid menu choice, invalid input type, attempting to process a task when the queue is empty).
 * -   Use `System.out.println()` for all normal output (menu display, prompts, task information, success messages).
 * -   Implement **class-wide exception handling** using `try-catch` blocks to gracefully handle potential runtime errors, especially around user input operations (`InputMismatchException`) and potential issues like invalid task data (`IllegalArgumentException`). The main application loop should be covered by exception handling.
 * -   Follow Java best practices:
 *     -   Employ proper encapsulation (private fields, public getter methods) for the `Task` class and within the scheduler logic.
 *     -   Use meaningful and descriptive variable, method, and class names.
 *     -   Include appropriate comments to explain complex parts or logic.
 *     -   Implement basic input validation (e.g., handle non-integer input for choices/priority, handle empty task name).
 *     -   Handle edge cases gracefully (e.g., processing task when queue is empty, viewing empty lists/queues).
 *     -   Structure your code into appropriate classes (`Task`, `TaskScheduler`, and a main class for the application entry point).
 * 
 * **Expected Output:**
 * The program should start by displaying a menu. It should then loop, accepting user input. Based on the input, it should perform the corresponding action, print results to `System.out`, and print errors or warnings to `System.err`. The loop continues until the user chooses to exit.
 * 
 * Example interaction snippets:
 * -   Adding a task: Prompt for name and priority, print confirmation to `System.out`. Handle non-integer priority input with `System.err`.
 * -   Processing a task: If queue is not empty, print "Task processed: [task name]" to `System.out`. If queue is empty, print an error message to `System.err`.
 * -   Viewing tasks: Print lists of tasks to `System.out`. If a list/queue is empty, print an appropriate message to `System.out`.
 * -   Invalid menu input: Print an error message to `System.err`.
 * 
 * **Assessment:** Your solution will be evaluated on:
 * -   Correct usage and integration of all required Java components.
 * -   Adherence to technical requirements and best practices.
 * -   Correct implementation of the task scheduler logic.
 * -   Robustness in handling user input errors and edge cases using `try-catch` and `System.err`.
 * -   Code clarity, structure, and documentation.
 * 
 * ```java
 * // You should provide the complete Java code solution here,
 * // structured into appropriate classes and including necessary imports.
 * ```
 *
 * EXPLANATION:
 * This solution implements a simple task scheduler simulation demonstrating the required Java concepts.
 * 
 * 1.  **`Task` Class:**
 *     -   Represents a task with `name` and `priority` as private fields, ensuring encapsulation.
 *     -   Includes a constructor with basic input validation (non-empty name, non-negative priority) throwing `IllegalArgumentException`.
 *     -   Provides public getter methods (`getName`, `getPriority`).
 *     -   Overrides `toString()` for easy printing of task details.
 * 
 * 2.  **`TaskScheduler` Class:**
 *     -   Manages two collections: `pendingTasks` (a `Queue<Task>`) and `completedTasks` (a `List<Task>`).
 *     -   `pendingTasks` is declared as the `Queue` interface and instantiated as a `LinkedList`, fulfilling the `Queue` and `LinkedList` requirements. `LinkedList` is a common choice for implementing `Queue`.
 *     -   `completedTasks` is declared as the `List` interface and instantiated as an `ArrayList`, fulfilling the `List` and `ArrayList` requirements and demonstrating interface usage.
 *     -   `addTask(Task task)`: Uses `Queue.offer()` to add a task to the end of the pending queue. Prints a success message to `System.out`.
 *     -   `processNextTask()`: Uses `Queue.poll()` to remove and retrieve the task at the head of the pending queue. If a task is retrieved (queue was not empty), it's added to the `completedTasks` list, and a success message is printed to `System.out`. If `poll()` returns `null` (queue was empty), an error message is printed to `System.err`.
 *     -   `viewPendingTasks()`: Checks if the pending queue is empty. If not, it iterates through the queue using an `Iterator` (to avoid removing elements) and prints each task to `System.out`.
 *     -   `viewCompletedTasks()`: Checks if the completed list is empty. If not, it iterates through the list (using an enhanced for loop) and prints each task to `System.out`.
 *     -   Both view methods print appropriate messages to `System.out` if their respective collections are empty.
 * 
 * 3.  **`Main` Class:**
 *     -   Contains the `main` method, the application entry point.
 *     -   Creates a `TaskScheduler` instance and a `Scanner` for user input.
 *     -   The core logic is within a `while(running)` loop that continues until the user chooses to exit.
 *     -   A `printMenu()` helper method displays the options to `System.out`.
 *     -   **Scanner and Input Handling:** Reads user input for the menu choice and task details using `scanner.nextInt()` and `scanner.nextLine()`. `scanner.nextLine()` is used after `nextInt()` to consume the leftover newline character.
 *     -   **Switch Statement:** A `switch` statement is used to direct control flow based on the user's menu choice, fulfilling the `switch` requirement.
 *     -   **System.out and System.err:** `System.out.println()` is used for displaying the menu, prompts, task details, and success messages. `System.err.println()` is used specifically for error messages, such as invalid menu choices or input type mismatches.
 *     -   **Class-wide Exception Handling (`try-catch`):**
 *         -   The entire main `while` loop is wrapped in a `try-catch(Exception e)` block. This serves as a "class-wide" or application-level handler for any unexpected exceptions that might propagate up, preventing the program from crashing abruptly.
 *         -   Specific `try-catch(InputMismatchException e)` blocks are used around `scanner.nextInt()` calls (for both menu choice and task priority) to handle cases where the user enters non-integer input. Upon catching this, an error message is printed to `System.err`, the invalid input is consumed from the scanner buffer (`scanner.nextLine()`), and the loop continues or prompts again for valid input.
 *         -   A `try-catch(IllegalArgumentException e)` block is used when creating a `Task` object to catch validation errors (like empty name or negative priority) thrown by the `Task` constructor. The error message from the exception is printed to `System.err`.
 *     -   **`finally` Block:** A `finally` block is used to ensure the `Scanner` resource is closed properly, regardless of whether an exception occurred or the loop terminated normally.
 * 
 * This solution effectively integrates all the required Java components within a practical scenario, demonstrates best practices like encapsulation and meaningful naming, and includes robust error handling for user input and potential issues.
 */

package com.taskscheduler;

import java.util.InputMismatchException;
import java.util.LinkedList;
import java.util.Queue;
import java.util.List;
import java.util.ArrayList;
import java.util.Scanner;
import java.util.Iterator; // Needed to iterate Queue without removing

/**
 * Represents a single task with a name and priority.
 */
class Task {
    private String name;
    private int priority; // Priority is stored but not used for Queue ordering in this simple FIFO scheduler

    /**
     * Constructs a new Task.
     *
     * @param name     The name of the task. Cannot be null or empty.
     * @param priority The priority of the task. Must be non-negative.
     * @throws IllegalArgumentException if name is invalid or priority is negative.
     */
    public Task(String name, int priority) {
        if (name == null || name.trim().isEmpty()) {
            throw new IllegalArgumentException("Task name cannot be empty.");
        }
        if (priority < 0) {
             throw new IllegalArgumentException("Task priority cannot be negative.");
        }
        this.name = name.trim();
        this.priority = priority;
    }

    public String getName() {
        return name;
    }

    public int getPriority() {
        return priority;
    }

    @Override
    public String toString() {
        return "Task [Name: " + name + ", Priority: " + priority + "]";
    }
}

/**
 * Manages the pending and completed tasks using a Queue and a List.
 */
class TaskScheduler {
    // Use Queue interface with LinkedList implementation for pending tasks (FIFO)
    private Queue<Task> pendingTasks;
    // Use List interface with ArrayList implementation for completed tasks
    private List<Task> completedTasks;

    /**
     * Constructs a new TaskScheduler, initializing the task collections.
     */
    public TaskScheduler() {
        this.pendingTasks = new LinkedList<>();
        this.completedTasks = new ArrayList<>();
    }

    /**
     * Adds a task to the pending queue.
     *
     * @param task The task to add.
     */
    public void addTask(Task task) {
        if (task != null) {
            // offer() is generally preferred for queues as it handles capacity restrictions (though LinkedList doesn't have a fixed capacity)
            pendingTasks.offer(task);
            System.out.println("Task added: " + task.getName());
        } else {
            // This case should ideally be caught before calling this method with null,
            // but included for robustness.
             System.err.println("Error: Cannot add a null task.");
        }
    }

    /**
     * Processes the next task in the pending queue.
     * Removes the task from pending and adds it to completed.
     * Handles the case where the queue is empty.
     */
    public void processNextTask() {
        // poll() removes and returns the head of the queue, or null if the queue is empty
        Task nextTask = pendingTasks.poll();
        if (nextTask != null) {
            completedTasks.add(nextTask);
            System.out.println("Task processed: " + nextTask.getName());
        } else {
            // Use System.err for error/warning message
            System.err.println("No tasks in the pending queue to process.");
        }
    }

    /**
     * Displays all tasks currently in the pending queue without removing them.
     */
    public void viewPendingTasks() {
        if (pendingTasks.isEmpty()) {
            System.out.println("Pending tasks queue is empty.");
        } else {
            System.out.println("--- Pending Tasks ---");
            // Iterate over the queue using an Iterator to avoid removing elements
            Iterator<Task> iterator = pendingTasks.iterator();
            while (iterator.hasNext()) {
                System.out.println(iterator.next());
            }
            System.out.println("---------------------");
        }
    }

    /**
     * Displays all tasks that have been completed.
     */
    public void viewCompletedTasks() {
        if (completedTasks.isEmpty()) {
            System.out.println("No tasks have been completed yet.");
        } else {
            System.out.println("--- Completed Tasks ---");
            // Enhanced for loop works well for List iteration
            for (Task task : completedTasks) {
                System.out.println(task);
            }
            System.out.println("-----------------------");
        }
    }
}

/**
 * Main class to run the Task Scheduler application.
 * Contains the main menu loop and handles user interaction.
 */
public class Main {

    public static void main(String[] args) {
        TaskScheduler scheduler = new TaskScheduler();
        Scanner scanner = new Scanner(System.in);
        boolean running = true;

        System.out.println("--- Simple Task Scheduler Simulation ---");

        // Class-wide exception handling around the main application loop
        try {
            while (running) {
                printMenu();
                System.out.print("Enter your choice: ");

                int choice = -1; // Default value for invalid input
                try {
                    // Attempt to read the integer choice
                    choice = scanner.nextInt();
                    // Consume the rest of the line after the integer
                    scanner.nextLine();
                } catch (InputMismatchException e) {
                    // Handle non-integer input for the menu choice
                    System.err.println("Invalid input. Please enter a number.");
                    // Consume the invalid input to prevent an infinite loop
                    scanner.nextLine();
                    // Skip the rest of the loop iteration and show menu again
                    continue;
                }

                // Use switch statement for menu navigation
                switch (choice) {
                    case 1:
                        // Add New Task
                        System.out.print("Enter task name: ");
                        String name = scanner.nextLine();

                        int priority = -1;
                        boolean validPriorityInput = false;
                        // Loop until a valid integer priority is entered
                        while (!validPriorityInput) {
                            System.out.print("Enter task priority (integer): ");
                            try {
                                priority = scanner.nextInt();
                                scanner.nextLine(); // Consume newline
                                validPriorityInput = true; // Input was successful
                            } catch (InputMismatchException e) {
                                System.err.println("Invalid priority input. Please enter an integer.");
                                scanner.nextLine(); // Consume invalid input
                            }
                        }

                        try {
                            // Attempt to create the Task object
                            Task newTask = new Task(name, priority);
                            scheduler.addTask(newTask);
                        } catch (IllegalArgumentException e) {
                            // Handle validation errors from Task constructor
                            System.err.println("Error creating task: " + e.getMessage());
                        }
                        break;

                    case 2:
                        // Process Next Task
                        scheduler.processNextTask();
                        break;

                    case 3:
                        // View Pending Tasks
                        scheduler.viewPendingTasks();
                        break;

                    case 4:
                        // View Completed Tasks
                        scheduler.viewCompletedTasks();
                        break;

                    case 5:
                        // Exit
                        System.out.println("Exiting Task Scheduler. Goodbye!");
                        running = false;
                        break;

                    default:
                        // Handle choices outside the valid range
                        System.err.println("Invalid choice. Please enter a number between 1 and 5.");
                }
                System.out.println(); // Add a blank line for better readability between actions
            }
        } catch (Exception e) {
            // Catch any other unexpected exceptions that might occur
            System.err.println("An unexpected error occurred: " + e.getMessage());
            e.printStackTrace(); // Print stack trace for debugging purposes
        } finally {
            // Ensure the scanner resource is closed properly
            if (scanner != null) {
                scanner.close();
            }
            System.out.println("Scanner closed."); // Optional: confirmation
        }
    }

    /**
     * Prints the main menu options to standard output.
     */
    private static void printMenu() {
        System.out.println("--- Menu ---");
        System.out.println("1. Add New Task");
        System.out.println("2. Process Next Task");
        System.out.println("3. View Pending Tasks");
        System.out.println("4. View Completed Tasks");
        System.out.println("5. Exit");
        System.out.println("------------");
    }
}
