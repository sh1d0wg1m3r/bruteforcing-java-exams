/*
 * Exam Question #212
 * Generated on: 2025-05-11 22:32:49
 * Generated by: Account 4
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Package Sorting and Delivery Hub Simulation
 * 
 * **Scenario:**
 * 
 * You are tasked with simulating a simple Package Sorting and Delivery Hub. The hub receives packages, places them in an incoming queue, and then dispatches them to specific delivery routes. The system needs to manage the incoming packages, the packages assigned to different routes, and keep a record of all packages that have been processed (dispatched to a route).
 * 
 * **Task:**
 * 
 * Implement a Java program that simulates this Package Sorting Hub. Your program should provide a command-line interface for a hub operator to interact with the system.
 * 
 * **Requirements:**
 * 
 * 1.  **Core Functionality:**
 *     *   Allow the operator to add new packages to an **incoming queue**. Packages can be identified by a unique ID (String).
 *     *   Allow the operator to dispatch the next package from the head of the incoming queue to a specified **delivery route**.
 *     *   Allow the operator to view the packages currently in the **incoming queue**.
 *     *   Allow the operator to view the packages currently assigned to a specific **delivery route**.
 *     *   Maintain and allow viewing of a list of all **processed packages** (packages that have been dispatched from the queue to a route).
 *     *   Provide an option to exit the program.
 * 
 * 2.  **Java Components:** Your solution MUST utilize ALL of the following Java components:
 *     *   `java.util.Queue`
 *     *   `java.util.ArrayList`
 *     *   `java.util.List` interface (used for declaring variables/types)
 *     *   `java.util.Scanner` for reading user input from the console.
 *     *   `switch` statement for handling the main menu options.
 *     *   `System.err` for printing error messages (e.g., invalid input, operation failed).
 *     *   `System.out` for printing normal output (menu, prompts, status messages, list contents).
 *     *   Class-wide exception handling using `try-catch` blocks to manage potential runtime errors, especially related to user input and accessing collections.
 * 
 * 3.  **Design and Best Practices:**
 *     *   Create a `Package` class to represent a package with at least a package ID.
 *     *   Create a main class (e.g., `PackageSortingHub`) that encapsulates the hub's state (queues, lists, routes).
 *     *   Use private fields and public methods (encapsulation).
 *     *   Use meaningful variable and method names.
 *     *   Include appropriate comments to explain the code.
 *     *   Implement input validation (e.g., check for valid menu choices, valid route numbers, non-empty package ID, attempting to dispatch from an empty queue).
 *     *   Handle potential exceptions gracefully (e.g., non-numeric input when a number is expected).
 *     *   Structure the code cleanly.
 *     *   Assume a fixed number of delivery routes (e.g., 3 routes, numbered 0, 1, and 2) for simplicity.
 * 
 * **Expected Output:**
 * 
 * The program should present a menu to the user. Based on the user's input, it should perform the requested action, print informative messages to `System.out` upon success or for displaying data, and print error messages to `System.err` when an operation fails or input is invalid.
 * 
 * Example Interaction Flow:
 * 
 * ```
 * --- Package Sorting Hub Simulation ---
 * 
 * Select an action:
 * 1. Add new package to incoming queue
 * 2. Dispatch next package from queue to a route
 * 3. View incoming queue
 * 4. View packages on a delivery route
 * 5. View processed packages
 * 6. Exit
 * Enter your choice: 1
 * Enter package ID: PKG001
 * Package 'PKG001' added to incoming queue.
 * 
 * Select an action:
 * ...
 * Enter your choice: 1
 * Enter package ID: PKG002
 * Package 'PKG002' added to incoming queue.
 * 
 * Select an action:
 * ...
 * Enter your choice: 3
 * --- Incoming Queue ---
 * 0: PKG001
 * 1: PKG002
 * 
 * Select an action:
 * ...
 * Enter your choice: 2
 * Next package to dispatch: PKG001
 * Enter destination route number (0 to 2): 0
 * Package 'PKG001' dispatched to Route 0.
 * 
 * Select an action:
 * ...
 * Enter your choice: 3
 * --- Incoming Queue ---
 * 0: PKG002
 * 
 * Select an action:
 * ...
 * Enter your choice: 4
 * Enter route number to view (0 to 2): 0
 * --- Packages on Route 0 ---
 * 0: PKG001
 * 
 * Select an action:
 * ...
 * Enter your choice: 5
 * --- Processed Packages (Dispatched) ---
 * 0: PKG001
 * 
 * Select an action:
 * ...
 * Enter your choice: 2
 * Next package to dispatch: PKG002
 * Enter destination route number (0 to 2): 1
 * Package 'PKG002' dispatched to Route 1.
 * 
 * Select an action:
 * ...
 * Enter your choice: 3
 * --- Incoming Queue ---
 * Queue is empty.
 * 
 * Select an action:
 * ...
 * Enter your choice: 2
 * Incoming queue is empty. Cannot dispatch packages. // Printed to System.err
 * 
 * Select an action:
 * ...
 * Enter your choice: 4
 * Enter route number to view (0 to 2): 5
 * Invalid route number. Please enter a number between 0 and 2. // Printed to System.err
 * 
 * Select an action:
 * ...
 * Enter your choice: abc
 * Invalid input. Please enter a number. // Printed to System.err
 * 
 * Select an action:
 * ...
 * Enter your choice: 6
 * Exiting simulation. Goodbye!
 * ```
 *
 * EXPLANATION:
 * The provided solution implements the `Package Sorting and Delivery Hub` simulation as described in the exam question. It demonstrates the required Java concepts and adheres to best practices.
 * 
 * **Key Components and Concepts Demonstrated:**
 * 
 * 1.  **`Package` Class:** A simple class encapsulating package data (`packageId`). It follows encapsulation principles with a private field and a public getter. The `toString()` method is overridden for convenient representation, though the view methods format the output specifically for the user.
 * 
 * 2.  **`PackageSortingHub` Class:** This is the main class managing the hub's state and logic.
 *     *   **`Queue<Package> incomingQueue`:** A `LinkedList` (which implements `Queue`) is used to model the incoming packages waiting to be sorted. Packages are added to the end (`offer`) and removed from the front (`poll`). `peek` is used to view the next package without removing it.
 *     *   **`List<List<Package>> deliveryRoutes`:** An `ArrayList` is used to hold multiple delivery routes. Each route is itself an `ArrayList` of `Package` objects. This demonstrates the use of nested collections and the `List` interface when declaring the variable type.
 *     *   **`List<Package> processedPackages`:** An `ArrayList` is used to maintain a history of all packages that have been successfully dispatched from the queue to a route. This also uses the `List` interface declaration.
 *     *   **`Scanner scanner`:** Used to read user input from `System.in`.
 *     *   **`numberOfRoutes`:** A `final` field defining the fixed number of routes.
 * 
 * 3.  **User Interaction (`start()` method):**
 *     *   The `start()` method contains the main simulation loop (`while(running)`).
 *     *   It displays a menu using `displayMenu()`.
 *     *   It reads the user's choice using `scanner.nextInt()`.
 *     *   A **`switch` statement** is used to process the integer choice, directing execution to the appropriate method (`addPackage`, `dispatchNextPackage`, etc.).
 *     *   `scanner.nextLine()` is called after `scanner.nextInt()` to consume the remaining newline character, preventing issues in subsequent `scanner.nextLine()` calls.
 * 
 * 4.  **Input Validation and Error Handling (`try-catch`, `System.err`):**
 *     *   **`try-catch(InputMismatchException)`:** Specific `try-catch` blocks are wrapped around `scanner.nextInt()` calls (in `start()`, `dispatchNextPackage()`, `viewRoutePackages()`) to gracefully handle cases where the user enters non-numeric input when a number is expected. An error message is printed to `System.err`, and the invalid input is consumed, allowing the loop to continue without crashing.
 *     *   **Input Validation Logic:** Methods like `addPackage()` check for empty input. `dispatchNextPackage()` and `viewRoutePackages()` validate the entered route number to ensure it's within the valid range (`0` to `numberOfRoutes - 1`) before attempting to access the corresponding route list.
 *     *   **Operation Validation:** `dispatchNextPackage()` checks if the `incomingQueue` is empty before attempting to poll from it, preventing potential errors and providing an informative message via `System.err`.
 *     *   **Class-wide `try-catch(Exception)`:** The main `while` loop in `start()` is wrapped in a broad `try-catch(Exception e)` block. This serves as a fallback to catch any unexpected runtime exceptions that might occur within the loop's execution, printing an error message and stack trace to `System.err` before the program terminates or enters the `finally` block. A similar `try-catch` is in `main` for initial setup errors.
 *     *   **`System.err`:** Used consistently for all error messages resulting from invalid operations or input.
 *     *   **`System.out`:** Used for all normal output, including the menu, prompts, success confirmations, and displaying the contents of queues and lists.
 * 
 * 5.  **Collection Usage:**
 *     *   `Queue` (`LinkedList`): Demonstrates FIFO (First-In, First-Out) behavior for incoming packages. Methods `offer`, `poll`, `peek` are used. Iteration is shown in `viewQueue`.
 *     *   `List` (`ArrayList`): Used for dynamic arrays to store processed packages and the packages within each delivery route. Demonstrates adding elements (`add`) and iterating through elements by index or enhanced for loop.
 *     *   The use of `List` as the type declaration (`List<List<Package>>`, `List<Package>`) when the implementation is `ArrayList` demonstrates programming to the interface, a key OOP principle.
 * 
 * 6.  **Code Structure and Best Practices:**
 *     *   The code is divided into logical methods, each responsible for a specific task (adding package, dispatching, viewing, displaying menu).
 *     *   Private helper methods (`displayMenu`, `addPackage`, etc.) encapsulate internal logic.
 *     *   Fields are private, accessed/modified via methods where necessary.
 *     *   Comments explain the purpose of classes, fields, and methods.
 *     *   The `finally` block in `start()` ensures the `Scanner` resource is closed, preventing resource leaks.
 * 
 * This solution effectively integrates the required Java components within a practical simulation, demonstrating understanding of collections, control flow, user interaction, and robust error handling.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.InputMismatchException; // Required for catching non-integer input

// Represents a package to be processed in the hub.
class Package {
    private String packageId; // Unique identifier for the package.

    // Constructor
    public Package(String packageId) {
        this.packageId = packageId;
    }

    // Getter for packageId
    public String getPackageId() {
        return packageId;
    }

    // toString method for easy printing (used internally, view methods format output)
    @Override
    public String toString() {
        return "Package{" +
               "id='" + packageId + '\'' +
               '}';
    }
}

// Main class representing the Package Sorting Hub simulation.
public class PackageSortingHub {

    // Queue to hold incoming packages before sorting.
    private Queue<Package> incomingQueue;
    // List of lists, where each inner list represents a delivery route.
    private List<List<Package>> deliveryRoutes;
    // List to keep track of all packages that have been dispatched.
    private List<Package> processedPackages;
    // Scanner for reading user input from the console.
    private Scanner scanner;
    // The fixed number of delivery routes available.
    private final int numberOfRoutes;

    /**
     * Constructor for the PackageSortingHub.
     * Initializes the queues, lists, and scanner.
     * @param numberOfRoutes The number of delivery routes to initialize. Must be positive.
     * @throws IllegalArgumentException if numberOfRoutes is not positive.
     */
    public PackageSortingHub(int numberOfRoutes) {
        // Validate input for number of routes.
        if (numberOfRoutes <= 0) {
            throw new IllegalArgumentException("Number of routes must be positive.");
        }
        this.numberOfRoutes = numberOfRoutes;
        // LinkedList is a common and efficient implementation of the Queue interface.
        this.incomingQueue = new LinkedList<>();
        // ArrayList is used to hold the lists representing routes.
        this.deliveryRoutes = new ArrayList<>(numberOfRoutes);
        // Initialize each route as an empty ArrayList.
        for (int i = 0; i < numberOfRoutes; i++) {
            this.deliveryRoutes.add(new ArrayList<>());
        }
        // ArrayList is used to store processed packages.
        this.processedPackages = new ArrayList<>();
        // Initialize scanner to read from standard input.
        this.scanner = new Scanner(System.in);
    }

    /**
     * Starts the main simulation loop, displaying the menu and processing user input.
     * Includes class-wide exception handling.
     */
    public void start() {
        System.out.println("--- Package Sorting Hub Simulation ---");
        displayMenu(); // Show menu initially

        boolean running = true;
        // Class-wide try-catch block to handle unexpected exceptions during the main loop execution.
        try {
            while (running) {
                System.out.print("Enter your choice: ");
                int choice = -1; // Default invalid choice

                // Specific try-catch for reading integer input to handle non-numeric input.
                try {
                    choice = scanner.nextInt();
                    scanner.nextLine(); // Consume the leftover newline character after reading int.
                } catch (InputMismatchException e) {
                    System.err.println("Invalid input. Please enter a number.");
                    scanner.nextLine(); // Consume the entire line of invalid input to prevent infinite loop.
                    displayMenu(); // Show menu again after invalid input
                    continue; // Skip the rest of the loop iteration.
                }

                // Switch statement to direct control flow based on user's valid integer choice.
                switch (choice) {
                    case 1:
                        addPackage();
                        break;
                    case 2:
                        dispatchNextPackage();
                        break;
                    case 3:
                        viewQueue();
                        break;
                    case 4:
                        viewRoutePackages();
                        break;
                    case 5:
                        viewProcessedPackages();
                        break;
                    case 6:
                        running = false; // Set flag to exit loop.
                        System.out.println("Exiting simulation. Goodbye!");
                        break;
                    default:
                        // Handle choices that are integers but not within the menu options.
                        System.err.println("Invalid choice. Please select a number from the menu.");
                        displayMenu(); // Show menu again after invalid choice.
                }
                System.out.println(); // Add a newline for better readability between different actions.
            }
        } catch (Exception e) {
            // Catch any other unexpected runtime exceptions not handled specifically.
            System.err.println("An unexpected error occurred: " + e.getMessage());
            e.printStackTrace(System.err); // Print stack trace to standard error stream for debugging.
        } finally {
            // Ensure the scanner resource is closed when the simulation ends (either normally or via exception).
            if (scanner != null) {
                scanner.close();
            }
        }
    }

    /**
     * Displays the available menu options to the user.
     */
    private void displayMenu() {
        System.out.println("\nSelect an action:");
        System.out.println("1. Add new package to incoming queue");
        System.out.println("2. Dispatch next package from queue to a route");
        System.out.println("3. View incoming queue");
        System.out.println("4. View packages on a delivery route");
        System.out.println("5. View processed packages");
        System.out.println("6. Exit");
    }

    /**
     * Prompts the user for a package ID and adds a new package to the incoming queue.
     * Includes input validation for the package ID.
     */
    private void addPackage() {
        System.out.print("Enter package ID: ");
        String packageId = scanner.nextLine().trim(); // Read the whole line and trim whitespace.

        // Input validation: Check if the package ID is empty.
        if (packageId.isEmpty()) {
            System.err.println("Package ID cannot be empty.");
            return; // Exit the method if input is invalid.
        }

        Package newPackage = new Package(packageId);
        // offer() is generally preferred over add() for queues as it handles capacity restricted queues better (though LinkedList is not capacity restricted).
        incomingQueue.offer(newPackage);
        System.out.println("Package '" + packageId + "' added to incoming queue.");
    }

    /**
     * Dispatches the next package from the incoming queue to a specified delivery route.
     * Handles empty queue and invalid route number input.
     */
    private void dispatchNextPackage() {
        // Check if the incoming queue is empty before attempting to dispatch.
        if (incomingQueue.isEmpty()) {
            System.err.println("Incoming queue is empty. Cannot dispatch packages.");
            return;
        }

        // Peek at the next package without removing it yet, for confirmation message.
        Package packageToDispatch = incomingQueue.peek();
        System.out.println("Next package to dispatch: " + packageToDispatch.getPackageId());

        System.out.print("Enter destination route number (0 to " + (numberOfRoutes - 1) + "): ");
        int routeNumber = -1; // Default invalid route number.

        // Specific try-catch for reading integer route number input.
        try {
            routeNumber = scanner.nextInt();
            scanner.nextLine(); // Consume the newline.
        } catch (InputMismatchException e) {
            System.err.println("Invalid input. Please enter a valid route number.");
            scanner.nextLine(); // Consume invalid input.
            return; // Exit the method.
        }

        // Validate the entered route number against the available routes.
        if (routeNumber < 0 || routeNumber >= numberOfRoutes) {
            System.err.println("Invalid route number. Please enter a number between 0 and " + (numberOfRoutes - 1) + ".");
            return; // Exit the method if route number is invalid.
        }

        // Remove the package from the incoming queue. poll() returns null if queue is empty,
        // but we've already checked for emptiness.
        Package dispatchedPackage = incomingQueue.poll();

        // Should not be null due to the isEmpty check at the beginning, but defensive programming is good.
        if (dispatchedPackage != null) {
             // Add the dispatched package to the specified delivery route list.
             deliveryRoutes.get(routeNumber).add(dispatchedPackage);
             // Add the dispatched package to the list of all processed packages.
             processedPackages.add(dispatchedPackage);
             System.out.println("Package '" + dispatchedPackage.getPackageId() + "' dispatched to Route " + routeNumber + ".");
        } else {
             // This case should ideally not be reached if isEmpty() check is correct.
             System.err.println("Error: Could not retrieve package from queue.");
        }
    }

    /**
     * Displays the contents of the incoming queue.
     */
    private void viewQueue() {
        System.out.println("--- Incoming Queue ---");
        if (incomingQueue.isEmpty()) {
            System.out.println("Queue is empty.");
        } else {
            // Iterate through the queue elements without removing them.
            int index = 0;
            for (Package pkg : incomingQueue) {
                // Print index and package ID.
                System.out.println(index + ": " + pkg.getPackageId());
                index++;
            }
        }
    }

    /**
     * Prompts the user for a route number and displays the packages assigned to that route.
     * Handles invalid route number input.
     */
    private void viewRoutePackages() {
        System.out.print("Enter route number to view (0 to " + (numberOfRoutes - 1) + "): ");
        int routeNumber = -1; // Default invalid route number.

        // Specific try-catch for reading integer route number input.
        try {
            routeNumber = scanner.nextInt();
            scanner.nextLine(); // Consume the newline.
        } catch (InputMismatchException e) {
            System.err.println("Invalid input. Please enter a valid route number.");
            scanner.nextLine(); // Consume invalid input.
            return; // Exit the method.
        }

        // Validate the entered route number. Accessing deliveryRoutes.get() without
        // validation could throw IndexOutOfBoundsException, which the main try-catch could catch,
        // but specific validation provides a more user-friendly error message.
        if (routeNumber < 0 || routeNumber >= numberOfRoutes) {
            System.err.println("Invalid route number. Please enter a number between 0 and " + (numberOfRoutes - 1) + ".");
            return; // Exit the method if route number is invalid.
        }

        // Retrieve the specific route list using the valid index.
        List<Package> route = deliveryRoutes.get(routeNumber);
        System.out.println("--- Packages on Route " + routeNumber + " ---");
        if (route.isEmpty()) {
            System.out.println("Route " + routeNumber + " is empty.");
        } else {
            // Iterate through the list of packages on the route.
            for (int i = 0; i < route.size(); i++) {
                // Print index and package ID.
                System.out.println(i + ": " + route.get(i).getPackageId());
            }
        }
    }

    /**
     * Displays all packages that have been processed (dispatched from the queue).
     */
    private void viewProcessedPackages() {
        System.out.println("--- Processed Packages (Dispatched) ---");
        if (processedPackages.isEmpty()) {
            System.out.println("No packages have been processed yet.");
        } else {
            // Iterate through the list of processed packages.
            for (int i = 0; i < processedPackages.size(); i++) {
                // Print index and package ID.
                System.out.println(i + ": " + processedPackages.get(i).getPackageId());
            }
        }
    }

    /**
     * Main method to create a PackageSortingHub instance and start the simulation.
     * Includes basic error handling for hub initialization.
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        // Example: Create a hub with 3 delivery routes as specified in the requirements.
        int numberOfRoutes = 3;
        try {
             // Create the hub instance. Constructor validates numberOfRoutes.
             PackageSortingHub hub = new PackageSortingHub(numberOfRoutes);
             // Start the simulation. The start() method contains the main loop and its exception handling.
             hub.start();
        } catch (IllegalArgumentException e) {
             // Catch specific exception from constructor if numberOfRoutes is invalid.
             System.err.println("Error initializing hub: " + e.getMessage());
        } catch (Exception e) {
             // Catch any other unexpected exceptions during startup before the main loop's try-catch takes over.
             System.err.println("An unexpected error occurred during hub initialization or startup.");
             e.printStackTrace(System.err);
        }
    }
}
