/*
 * Exam Question #313
 * Generated on: 2025-05-11 22:53:39
 * Generated by: Account 4
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Research Lab Equipment Scheduler
 * 
 * **Problem Description:**
 * 
 * You are tasked with developing a simplified command-line application for managing equipment requests and allocations in a research lab. The system needs to handle incoming requests from researchers for specific equipment and manage the availability of limited resources.
 * 
 * The core functionality involves:
 * 1.  Submitting new equipment requests, which are added to a waiting queue.
 * 2.  Viewing the list of pending requests in the queue.
 * 3.  Viewing the list of equipment currently available for use.
 * 4.  Viewing the list of equipment currently allocated (in use).
 * 5.  Attempting to allocate the equipment requested by the researcher at the front of the queue. Allocation is only successful if the requested equipment is currently available. If not available, the request remains at the front of the queue, and an error is reported.
 * 6.  Releasing equipment that is currently allocated, making it available for future requests.
 * 
 * The system should interact with the user via the console using specific commands.
 * 
 * **Initial State:**
 * The lab has a predefined set of equipment. Initially, all equipment is available.
 * 
 * **Required Commands:**
 * 
 * *   `submit <equipment_name>`: Adds a new request for the specified equipment to the end of the queue.
 * *   `view queue`: Displays all requests currently waiting in the queue.
 * *   `view available`: Displays all equipment currently marked as available.
 * *   `view allocated`: Displays all equipment currently marked as allocated.
 * *   `allocate`: Attempts to allocate the equipment requested by the request at the head of the queue.
 * *   `release <equipment_name>`: Marks the specified equipment as available again.
 * *   `exit`: Terminates the application.
 * 
 * **Constraints and Requirements:**
 * 
 * 1.  You **must** use the following Java components from the `java.util` package:
 *     *   `Queue` (specifically, use an implementation like `LinkedList` or `ArrayDeque`)
 *     *   `ArrayList`
 *     *   `List` interface (use `List` as the type for variables where appropriate)
 * 2.  Use `Scanner` for reading user input from the console.
 * 3.  Use a `switch` statement to process user commands.
 * 4.  Use `System.err` to print all error messages (e.g., invalid command, allocation failure, invalid equipment name, releasing unavailable equipment).
 * 5.  Use `System.out` to print all normal output (e.g., prompts, success messages, list contents).
 * 6.  Implement class-wide exception handling using `try-catch` blocks to gracefully handle potential unexpected errors during the application's execution loop.
 * 7.  Follow best practices:
 *     *   Use proper encapsulation (private fields, public methods).
 *     *   Use meaningful variable and method names.
 *     *   Include appropriate comments and documentation (e.g., Javadoc for methods).
 *     *   Implement input validation (e.g., check if submitted/released equipment names are valid, check if commands have required arguments).
 *     *   Implement proper error handling using `System.err` for user-facing issues and `try-catch` for system issues.
 *     *   Structure the code cleanly with appropriate classes/methods.
 * 
 * **Equipment List (Predefined):**
 * *   High-Resolution Microscope
 * *   Spectrometer
 * *   Centrifuge
 * *   PCR Machine
 * 
 * **Expected Output Examples:**
 * 
 * ```
 * --- Research Lab Equipment Scheduler ---
 * Available commands: submit <equipment>, view queue, view available, view allocated, allocate, release <equipment>, exit
 * Available equipment types: High-Resolution Microscope, Spectrometer, Centrifuge, PCR Machine
 * 
 * Enter command: submit Spectrometer
 * Request for 'Spectrometer' submitted successfully.
 * 
 * Enter command: submit Centrifuge
 * Request for 'Centrifuge' submitted successfully.
 * 
 * Enter command: view queue
 * --- Pending Requests ---
 * Request [Equipment: Spectrometer]
 * Request [Equipment: Centrifuge]
 * ------------------------
 * 
 * Enter command: view available
 * --- Available Equipment ---
 * High-Resolution Microscope
 * Spectrometer
 * Centrifuge
 * PCR Machine
 * ---------------------------
 * 
 * Enter command: allocate
 * Successfully allocated 'Spectrometer'. Request processed.
 * 
 * Enter command: view queue
 * --- Pending Requests ---
 * Request [Equipment: Centrifuge]
 * ------------------------
 * 
 * Enter command: view allocated
 * --- Allocated Equipment ---
 * Spectrometer
 * ---------------------------
 * 
 * Enter command: allocate
 * Successfully allocated 'Centrifuge'. Request processed.
 * 
 * Enter command: view available
 * --- Available Equipment ---
 * High-Resolution Microscope
 * PCR Machine
 * ---------------------------
 * 
 * Enter command: allocate
 * Error: Request queue is empty. Cannot allocate.
 * 
 * Enter command: release Spectrometer
 * Successfully released 'Spectrometer'. It is now available.
 * 
 * Enter command: view available
 * --- Available Equipment ---
 * High-Resolution Microscope
 * PCR Machine
 * Spectrometer
 * ---------------------------
 * 
 * Enter command: release InvalidEquipment
 * Error: Invalid equipment name 'InvalidEquipment'.
 * 
 * Enter command: release High-Resolution Microscope
 * Error: 'High-Resolution Microscope' is already available or was never allocated.
 * 
 * Enter command: exit
 * Exiting scheduler. Goodbye!
 * ```
 * 
 * Your solution should provide the complete Java code for this application.
 *
 * EXPLANATION:
 * This solution implements the `Research Lab Equipment Scheduler` application demonstrating the required Java concepts and best practices.
 * 
 * **Key Concepts Demonstrated:**
 * 
 * 1.  **`Queue` (`java.util.Queue`)**: The `requestQueue` is declared as a `Queue<Request>` and initialized with `LinkedList`. This correctly uses the `Queue` interface and a common implementation. `offer()` is used to add requests to the tail, `peek()` is used to view the request at the head without removing it, and `poll()` is used to remove the request from the head upon successful allocation. This adheres to the First-In, First-Out (FIFO) nature of a queue for managing requests.
 * 2.  **`ArrayList` (`java.util.ArrayList`)**: `ArrayList` is used as the concrete implementation for storing the list of `allEquipment` and `availableEquipment`. `ArrayList` is suitable here because we need dynamic lists where elements can be added/removed, and we might iterate or check for containment (`contains`, `remove`).
 * 3.  **`List` interface (`java.util.List`)**: The fields `allEquipment` and `availableEquipment` are declared using the `List` interface type (`List<String>`). This demonstrates programming to the interface, which is a key principle for flexibility and good design. Although initialized with `ArrayList`, the code interacts with these lists using methods defined in the `List` interface.
 * 4.  **`Scanner` (`java.util.Scanner`)**: A `Scanner` object is created in the `main` method to read user input line by line from `System.in`.
 * 5.  **`Switch` statement**: A `switch` statement in the `main` method is used to determine which command the user entered (`submit`, `view`, `allocate`, `release`, `exit`) and execute the corresponding logic. A nested `switch` is used within the `view` command to handle the different view targets (`queue`, `available`, `allocated`).
 * 6.  **`System.err`**: Error messages resulting from invalid user actions (e.g., invalid command, missing arguments, attempting to allocate unavailable equipment, attempting to release equipment that's already available) are printed to `System.err`. This separates error output from standard program output.
 * 7.  **`System.out`**: All normal program output, including prompts, success messages, and the contents of the lists and queue when viewed, is printed to `System.out`.
 * 8.  **Class-wide `try-catch`**: The main `while` loop in the `main` method, which processes user commands, is wrapped in a `try-catch` block. This provides a top-level handler for any unexpected exceptions that might occur during the execution of commands, preventing the program from crashing abruptly. It catches `Exception` for general handling and includes a `finally` block to ensure the `Scanner` is closed. A specific catch for `NoSuchElementException` is added as `scanner.nextLine()` can throw it if the input stream is closed.
 * 
 * **Best Practices Implementation:**
 * 
 * *   **Encapsulation**: The data fields (`allEquipment`, `availableEquipment`, `requestQueue`) are declared as `private`. Public methods (`submitRequest`, `viewRequestQueue`, etc.) are provided to interact with this data, controlling access and modification. The `Request` class also encapsulates its data.
 * *   **Meaningful Names**: Variable names (`requestQueue`, `availableEquipment`, `equipmentName`), method names (`submitRequest`, `allocateEquipment`), and class names (`LabEquipmentScheduler`, `Request`) are descriptive and indicate their purpose.
 * *   **Comments and Documentation**: Javadoc comments are used for the public methods to explain their function, parameters, and return values. Inline comments are used where necessary to clarify specific logic.
 * *   **Input Validation**: The `isValidEquipment` helper method checks if an entered equipment name is one of the predefined valid names. The command parsing logic checks if commands like `submit` and `release` have the required arguments.
 * *   **Error Handling**: Specific `if` conditions check for various error scenarios (empty queue, unavailable equipment, invalid release target) and print informative error messages to `System.err`. The `try-catch` in `main` handles broader exceptions.
 * *   **Clean Code Structure**: The logic is divided into a main class (`LabEquipmentScheduler`) and a simple data class (`Request`). The `LabEquipmentScheduler` class contains methods for each distinct operation, keeping the `main` method clean and focused on handling the command loop and user interaction. The `view allocated` logic demonstrates calculating derived state.
 * 
 * This solution effectively integrates the required components within a practical scenario, demonstrating a solid understanding of core and intermediate Java programming concepts suitable for a challenging exam task.
 */

import java.util.ArrayList;
import java.util.Arrays;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.NoSuchElementException; // Useful for queue operations

/**
 * Represents a single equipment request.
 */
class Request {
    private String equipmentName;

    /**
     * Constructs a new Request object.
     * @param equipmentName The name of the equipment being requested.
     */
    public Request(String equipmentName) {
        this.equipmentName = equipmentName;
    }

    /**
     * Gets the name of the equipment requested.
     * @return The equipment name.
     */
    public String getEquipmentName() {
        return equipmentName;
    }

    /**
     * Provides a string representation of the request.
     * @return A formatted string for the request.
     */
    @Override
    public String toString() {
        return "Request [Equipment: " + equipmentName + "]";
    }
}

/**
 * Manages equipment requests and allocations for a research lab.
 */
public class LabEquipmentScheduler {

    // Use List interface type, initialize with ArrayList
    private List<String> allEquipment;
    // Use List interface type, initialize with ArrayList
    private List<String> availableEquipment;
    // Use Queue interface type, initialize with LinkedList
    private Queue<Request> requestQueue;

    /**
     * Constructs a new LabEquipmentScheduler.
     * Initializes the equipment lists and request queue.
     */
    public LabEquipmentScheduler() {
        // Initialize the list of all possible equipment
        this.allEquipment = new ArrayList<>(Arrays.asList(
            "High-Resolution Microscope",
            "Spectrometer",
            "Centrifuge",
            "PCR Machine"
        ));

        // Initially, all equipment is available
        this.availableEquipment = new ArrayList<>(this.allEquipment);

        // Initialize the request queue using LinkedList
        this.requestQueue = new LinkedList<>();
    }

    /**
     * Validates if an equipment name is in the list of all known equipment.
     * @param equipmentName The name to validate.
     * @return true if the name is valid, false otherwise.
     */
    private boolean isValidEquipment(String equipmentName) {
        return this.allEquipment.contains(equipmentName);
    }

    /**
     * Submits a new equipment request to the queue.
     * @param equipmentName The name of the equipment being requested.
     */
    public void submitRequest(String equipmentName) {
        if (!isValidEquipment(equipmentName)) {
            System.err.println("Error: Invalid equipment name '" + equipmentName + "'.");
            return;
        }

        Request newRequest = new Request(equipmentName);
        // offer() is preferred over add() for queues as it doesn't throw exception if queue is full (though LinkedList won't be full)
        this.requestQueue.offer(newRequest);
        System.out.println("Request for '" + equipmentName + "' submitted successfully.");
    }

    /**
     * Displays all pending requests currently in the queue.
     */
    public void viewRequestQueue() {
        if (this.requestQueue.isEmpty()) {
            System.out.println("No pending requests in the queue.");
            return;
        }

        System.out.println("--- Pending Requests ---");
        // Iterate through the queue without removing elements
        // The Queue interface is Iterable
        for (Request request : this.requestQueue) {
            System.out.println(request);
        }
        System.out.println("------------------------");
    }

    /**
     * Displays all equipment currently marked as available.
     */
    public void viewAvailableEquipment() {
        if (this.availableEquipment.isEmpty()) {
            System.out.println("No equipment is currently available.");
            return;
        }
        System.out.println("--- Available Equipment ---");
        // List is Iterable
        for (String equipment : this.availableEquipment) {
            System.out.println(equipment);
        }
        System.out.println("---------------------------");
    }

    /**
     * Displays all equipment currently marked as allocated.
     * This is calculated by finding equipment in allEquipment that is NOT in availableEquipment.
     */
    public void viewAllocatedEquipment() {
        // Create a temporary list of allocated equipment
        List<String> allocated = new ArrayList<>(this.allEquipment); // Start with all equipment
        allocated.removeAll(this.availableEquipment); // Remove all that are available

        if (allocated.isEmpty()) {
            System.out.println("No equipment is currently allocated.");
            return;
        }
        System.out.println("--- Allocated Equipment ---");
        for (String equipment : allocated) {
            System.out.println(equipment);
        }
        System.out.println("---------------------------");
    }

    /**
     * Attempts to allocate the equipment requested by the first request in the queue.
     * Allocation succeeds only if the requested equipment is available.
     */
    public void allocateEquipment() {
        // Check if the queue is empty
        if (this.requestQueue.isEmpty()) {
            System.err.println("Error: Request queue is empty. Cannot allocate.");
            return;
        }

        // Peek at the head of the queue without removing it
        Request currentRequest = this.requestQueue.peek();
        String requestedEquipment = currentRequest.getEquipmentName();

        // Check if the requested equipment is currently in the available list
        if (this.availableEquipment.contains(requestedEquipment)) {
            // Allocation successful:
            // 1. Remove the equipment from the available list
            this.availableEquipment.remove(requestedEquipment);
            // 2. Remove the request from the head of the queue
            // poll() is preferred over remove() as it returns null if queue is empty (though we checked already)
            this.requestQueue.poll();
            System.out.println("Successfully allocated '" + requestedEquipment + "'. Request processed.");
        } else {
            // Allocation failed: Equipment not available
            System.err.println("Error: '" + requestedEquipment + "' is not currently available. Request remains in queue.");
            // The request remains at the head of the queue because we used peek() and allocation failed.
        }
    }

    /**
     * Releases an allocated equipment, making it available again.
     * @param equipmentName The name of the equipment to release.
     */
    public void releaseEquipment(String equipmentName) {
        // Input validation: Check if equipment name is valid
        if (!isValidEquipment(equipmentName)) {
            System.err.println("Error: Invalid equipment name '" + equipmentName + "'.");
            return;
        }

        // Check if the equipment is currently NOT in the available list (meaning it's allocated)
        if (!this.availableEquipment.contains(equipmentName)) {
            // Release successful: Add it back to the available list
            this.availableEquipment.add(equipmentName);
            System.out.println("Successfully released '" + equipmentName + "'. It is now available.");
        } else {
            // Equipment is already available
            System.err.println("Error: '" + equipmentName + "' is already available or was never allocated.");
        }
    }

    /**
     * The main method to run the Lab Equipment Scheduler application.
     * Handles user input and command processing.
     * Includes class-wide exception handling.
     */
    public static void main(String[] args) {
        LabEquipmentScheduler scheduler = new LabEquipmentScheduler();
        Scanner scanner = new Scanner(System.in);
        boolean running = true;

        System.out.println("--- Research Lab Equipment Scheduler ---");
        System.out.println("Available commands: submit <equipment>, view queue, view available, view allocated, allocate, release <equipment>, exit");
        System.out.println("Available equipment types: " + String.join(", ", scheduler.allEquipment)); // Display available types dynamically

        // Class-wide exception handling for the main application loop
        try {
            while (running) {
                System.out.print("\nEnter command: ");
                String inputLine = scanner.nextLine().trim();

                // Split the input into command and argument(s)
                String[] parts = inputLine.split(" ", 2); // Split into command and potential argument string
                String command = parts[0].toLowerCase(); // Get the command, case-insensitive

                // Use switch statement for command processing
                switch (command) {
                    case "submit":
                        if (parts.length < 2) {
                            System.err.println("Error: submit command requires an equipment name.");
                        } else {
                            scheduler.submitRequest(parts[1]); // parts[1] is the equipment name
                        }
                        break;

                    case "view":
                        if (parts.length < 2) {
                            System.err.println("Error: view command requires a target (queue, available, allocated).");
                            break; // Exit the inner switch for view target
                        }
                        String viewTarget = parts[1].toLowerCase();
                        // Nested switch for view command targets
                        switch(viewTarget) {
                            case "queue":
                                scheduler.viewRequestQueue();
                                break;
                            case "available":
                                scheduler.viewAvailableEquipment();
                                break;
                            case "allocated":
                                scheduler.viewAllocatedEquipment();
                                break;
                            default:
                                System.err.println("Error: Unknown view target '" + viewTarget + "'. Use 'queue', 'available', or 'allocated'.");
                        }
                        break; // Exit the outer switch for 'view'

                    case "allocate":
                        scheduler.allocateEquipment();
                        break;

                    case "release":
                        if (parts.length < 2) {
                            System.err.println("Error: release command requires an equipment name.");
                        } else {
                            scheduler.releaseEquipment(parts[1]); // parts[1] is the equipment name
                        }
                        break;

                    case "exit":
                        System.out.println("Exiting scheduler. Goodbye!");
                        running = false; // Set flag to exit loop
                        break;

                    case "": // Handle empty input line
                        break;

                    default: // Handle unknown commands
                        System.err.println("Error: Unknown command '" + command + "'.");
                        System.out.println("Available commands: submit <equipment>, view queue, view available, view allocated, allocate, release <equipment>, exit");
                        System.out.println("Available equipment types: " + String.join(", ", scheduler.allEquipment));
                        break;
                }
            }
        } catch (NoSuchElementException e) {
             // Catch potential errors from scanner if input stream is closed unexpectedly
             System.err.println("Input error: Could not read from console. Exiting.");
             e.printStackTrace(); // Print stack trace for debugging
        } catch (Exception e) {
            // Catch any other unexpected runtime exceptions
            System.err.println("An unexpected error occurred: " + e.getMessage());
            e.printStackTrace(); // Print stack trace for debugging
        } finally {
            // Ensure the scanner resource is closed properly
            if (scanner != null) {
                scanner.close();
            }
            System.out.println("Application terminated.");
        }
    }
}
