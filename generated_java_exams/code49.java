/*
 * Exam Question #49
 * Generated on: 2025-05-11 22:05:10
 * Generated by: Account 4
 * 
 * QUESTION:
 * **Java Programming Exam Task: Restaurant Order Management System**
 * 
 * **Scenario:**
 * You are tasked with developing a simplified order management system for a small restaurant. The system needs to handle incoming customer orders, allow staff to process orders in the order they were received, and display the current state of the system (menu, order queue).
 * 
 * **Requirements:**
 * 
 * 1.  **Classes:**
 *     *   `MenuItem`: Represents an item on the menu. Should have `name` (String) and `price` (double). Implement proper encapsulation (private fields, public getters).
 *     *   `Order`: Represents a customer order. Should have a unique identifier (e.g., an incrementing integer ID) and a `List` of `MenuItem` objects. Implement proper encapsulation and a method to calculate the total order price.
 *     *   `RestaurantSystem`: This class will manage the restaurant's operations. It should contain:
 *         *   A `List<MenuItem>` representing the restaurant's menu. Initialize this with a few sample items.
 *         *   A `Queue<Order>` representing the queue of incoming orders waiting to be processed.
 *         *   A counter for generating unique order IDs.
 *         *   Methods to:
 *             *   Display the menu with indices.
 *             *   Create a new order (add items from the menu by index, then add the completed `Order` to the queue).
 *             *   Process the next order from the queue (remove it and display confirmation).
 *             *   View the current order queue.
 *             *   Handle user interaction via a menu-driven interface in a `run` method.
 * 
 * 2.  **Main Application Flow (`main` method):**
 *     *   Create an instance of `RestaurantSystem`.
 *     *   Use a `Scanner` to read user input from the console.
 *     *   Present the user with a menu of actions (e.g., 1. Add New Order, 2. Process Next Order, 3. View Order Queue, 4. Exit).
 *     *   Use a `switch` statement based on the user's choice to call the appropriate `RestaurantSystem` methods.
 *     *   The application should loop until the user chooses to exit.
 * 
 * 3.  **Required Java Components:**
 *     *   `java.util.Queue`: Must be used for the order queue.
 *     *   `java.util.ArrayList`: Must be used for the menu and for storing items within an `Order`.
 *     *   `java.util.List`: Must be used as the interface type for variables/fields holding lists (`List<MenuItem> menu`, `List<MenuItem> itemsInOrder`).
 *     *   `java.util.Scanner`: Must be used for all user input.
 *     *   `switch` statement: Must be used in the main application loop for menu navigation.
 *     *   `System.err`: Must be used for displaying error messages (e.g., invalid input, trying to process an empty queue).
 *     *   `System.out`: Must be used for all normal output (menu display, prompts, order details, queue status, success messages).
 *     *   Class-wide exception handling: Implement `try-catch` blocks to gracefully handle potential runtime errors, especially around user input operations (`Scanner`). A top-level `try-catch` in the `main` method or the `run` method of `RestaurantSystem` is expected to catch unexpected exceptions, while specific input validation should also be handled.
 * 
 * 4.  **Best Practices:**
 *     *   Proper encapsulation (private fields, public methods/getters).
 *     *   Meaningful variable and method names.
 *     *   Appropriate comments and documentation (Javadoc is a plus).
 *     *   Input validation (e.g., ensuring menu item indices are within bounds, handling non-integer input).
 *     *   Proper error handling (using `try-catch`, checking for empty queue).
 *     *   Clean code structure (separate classes, logical flow).
 * 
 * **Expected Output:**
 * The program should display a menu of options. Based on user input, it should perform the requested action, providing feedback to the user via `System.out` or `System.err` as appropriate. Examples:
 * *   Displaying the menu with indices.
 * *   Prompting the user to add items to a new order by index.
 * *   Confirming when an order is added to the queue.
 * *   Displaying the details (ID, items, total) of the processed order.
 * *   Displaying the current orders in the queue (IDs).
 * *   Displaying error messages for invalid input or actions (e.g., "Invalid menu choice.", "Menu item index out of bounds.", "No orders in the queue to process.").
 * 
 * **Evaluation:**
 * Your solution will be evaluated based on:
 * *   Correct implementation of all requirements.
 * *   Effective and correct usage of the specified Java components.
 * *   Adherence to best practices.
 * *   Robust error handling and input validation.
 * *   Clarity and readability of the code.
 * 
 * **Note:** Focus on the core logic and component usage. You don't need a complex GUI or database. All data can be held in memory.
 *
 * EXPLANATION:
 * This solution implements a basic Restaurant Order Management System demonstrating the required Java concepts and best practices.
 * 
 * 1.  **Class Structure:**
 *     *   `MenuItem`: A simple POJO (Plain Old Java Object) with `name` and `price`. Encapsulation is achieved with `private` fields and `public` getters. `toString()` is overridden for easy printing.
 *     *   `Order`: Represents an order with a unique `orderId` and a `List<MenuItem>` to hold the items. It uses an `ArrayList` internally for the list of items, but the `getItems()` method returns a copy to maintain encapsulation. It includes a method to calculate the total price and an overridden `toString()` for displaying order details. A static counter `nextOrderId` ensures unique IDs.
 *     *   `RestaurantSystem`: This is the core class managing the restaurant's state and operations. It holds the `List<MenuItem> menu` (implemented as `ArrayList`) and the `Queue<Order> orderQueue` (implemented as `LinkedList`). It contains methods for displaying the menu, creating orders, processing orders, and viewing the queue. The `run()` method contains the main application loop and user interaction logic.
 *     *   `RestaurantApp`: The main class with the `main` method, responsible for initializing the `Scanner` and `RestaurantSystem` and starting the application loop.
 * 
 * 2.  **Required Component Usage:**
 *     *   `Queue`: The `orderQueue` in `RestaurantSystem` is declared as `Queue<Order>` and initialized with `new LinkedList<>()`. `offer()` is used to add new orders, and `poll()` is used to remove and retrieve the next order.
 *     *   `ArrayList`: Used in `RestaurantSystem` to store the `menu` (`new ArrayList<>()`) and in `Order` to store the `items` (`new ArrayList<>()`).
 *     *   `List interface`: Used for declaring the `menu` field (`List<MenuItem> menu`) and the `items` field in `Order` (`List<MenuItem> items`), promoting good practice by programming to the interface.
 *     *   `Scanner`: Used in `RestaurantApp.main` to create a `Scanner` object, which is then passed to the `RestaurantSystem` to handle all user input (`scanner.nextInt()`, `scanner.nextLine()`).
 *     *   `switch statement`: Used in the `RestaurantSystem.run()` method to handle the different menu options selected by the user.
 *     *   `System.err`: Used specifically for printing error messages, such as invalid user input (`InputMismatchException`), invalid menu item indices, or attempting to process an empty queue. This distinguishes errors from normal output.
 *     *   `System.out`: Used for all regular output, including displaying the main menu, the restaurant menu, prompts, order details, and queue status.
 *     *   Class-wide exception handling (`try-catch`):
 *         *   A `try-catch` block wraps the main `while` loop in `RestaurantSystem.run()` to catch potential unexpected exceptions during the execution of menu options.
 *         *   Specific `try-catch` blocks are used around `scanner.nextInt()` calls within `createNewOrder()` and `run()` to handle `InputMismatchException` when the user enters non-integer input, preventing the program from crashing.
 *         *   The `main` method also includes a `try-catch-finally` block to handle potential issues during system initialization and ensure the `Scanner` is closed.
 * 
 * 3.  **Best Practices:**
 *     *   **Encapsulation:** All fields in `MenuItem` and `Order` are `private` with `public` getters. `Order.getItems()` returns a copy to protect the internal list.
 *     *   **Naming:** Variable and method names are descriptive (e.g., `orderQueue`, `processNextOrder`, `createNewOrder`, `itemNumber`).
 *     *   **Comments/Documentation:** Basic Javadoc-style comments explain the purpose of each class and key methods. Inline comments explain specific logic points.
 *     *   **Input Validation:** Checks are performed to ensure the user selects valid menu item numbers (within the range 1 to menu size) and valid main menu choices (1 to 4). `InputMismatchException` is handled for non-integer input.
 *     *   **Error Handling:** `System.err` is used for errors. The code checks if the `orderQueue` is empty before attempting to process an order. `try-catch` blocks handle input format errors and potential runtime exceptions.
 *     *   **Clean Code:** The logic is separated into distinct classes with clear responsibilities. The `run()` method provides a clean, menu-driven interface.
 * 
 * This solution effectively integrates all the required components into a practical scenario, demonstrating an understanding of data structures (`List`, `Queue`), control flow (`switch`, loops), input/output (`Scanner`, `System.out`, `System.err`), object-oriented principles (encapsulation), and robust error handling (`try-catch`).
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.InputMismatchException;

// Represents an item on the restaurant menu
class MenuItem {
    private String name;
    private double price;

    public MenuItem(String name, double price) {
        this.name = name;
        this.price = price;
    }

    // Getters
    public String getName() {
        return name;
    }

    public double getPrice() {
        return price;
    }

    @Override
    public String toString() {
        return name + " ($" + String.format("%.2f", price) + ")";
    }
}

// Represents a customer order
class Order {
    private static int nextOrderId = 1; // Static counter for unique IDs
    private int orderId;
    private List<MenuItem> items;

    public Order() {
        this.orderId = nextOrderId++;
        this.items = new ArrayList<>(); // Using ArrayList for order items
    }

    public int getOrderId() {
        return orderId;
    }

    public void addItem(MenuItem item) {
        if (item != null) {
            this.items.add(item);
        }
    }

    public List<MenuItem> getItems() {
        // Return a copy or unmodifiable list to prevent external modification
        return new ArrayList<>(items);
    }

    public double getTotalPrice() {
        double total = 0;
        for (MenuItem item : items) {
            total += item.getPrice();
        }
        return total;
    }

    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        sb.append("Order #").append(orderId).append(" (Total: $").append(String.format("%.2f", getTotalPrice())).append(")\n");
        if (items.isEmpty()) {
            sb.append("  (No items)");
        } else {
            for (MenuItem item : items) {
                sb.append("  - ").append(item.getName()).append("\n");
            }
        }
        return sb.toString();
    }
}

// Manages the restaurant's menu and order queue
class RestaurantSystem {
    private List<MenuItem> menu; // Using List interface, implemented by ArrayList
    private Queue<Order> orderQueue; // Using Queue interface, implemented by LinkedList
    private Scanner scanner;

    public RestaurantSystem(Scanner scanner) {
        this.scanner = scanner;
        initializeMenu();
        this.orderQueue = new LinkedList<>(); // LinkedList is a common Queue implementation
    }

    // Initializes the restaurant menu
    private void initializeMenu() {
        menu = new ArrayList<>(); // Using ArrayList
        menu.add(new MenuItem("Burger", 8.99));
        menu.add(new MenuItem("Pizza Slice", 3.50));
        menu.add(new MenuItem("Fries", 2.49));
        menu.add(new MenuItem("Soda", 1.99));
        menu.add(new MenuItem("Salad", 7.50));
    }

    // Displays the current menu with indices
    public void displayMenu() {
        System.out.println("\n--- Menu ---");
        if (menu.isEmpty()) {
            System.out.println("Menu is empty.");
        } else {
            for (int i = 0; i < menu.size(); i++) {
                System.out.println((i + 1) + ". " + menu.get(i));
            }
        }
        System.out.println("------------");
    }

    // Creates a new order based on user input and adds it to the queue
    public void createNewOrder() {
        Order newOrder = new Order();
        System.out.println("\n--- Creating New Order #" + newOrder.getOrderId() + " ---");
        displayMenu();

        while (true) {
            System.out.print("Enter menu item number to add (0 to finish order): ");
            int itemNumber = -1;
            try {
                itemNumber = scanner.nextInt();
                scanner.nextLine(); // Consume newline left-over

                if (itemNumber == 0) {
                    break; // Finish order
                }

                if (itemNumber > 0 && itemNumber <= menu.size()) {
                    MenuItem selectedItem = menu.get(itemNumber - 1);
                    newOrder.addItem(selectedItem);
                    System.out.println(selectedItem.getName() + " added to order.");
                } else {
                    System.err.println("Invalid menu item number. Please enter a number between 1 and " + menu.size() + ", or 0 to finish.");
                }
            } catch (InputMismatchException e) {
                System.err.println("Invalid input. Please enter a number.");
                scanner.nextLine(); // Consume the invalid input to prevent infinite loop
            } catch (Exception e) {
                 // Catch any other unexpected exceptions during item selection
                 System.err.println("An unexpected error occurred while adding item: " + e.getMessage());
                 // Optionally, log the exception details
            }
        }

        if (newOrder.getItems().isEmpty()) {
            System.out.println("Order #" + newOrder.getOrderId() + " cancelled as no items were added.");
            // No need to add to queue if empty
        } else {
            orderQueue.offer(newOrder); // Add the completed order to the queue
            System.out.println("\nOrder #" + newOrder.getOrderId() + " created and added to the queue.");
            System.out.println(newOrder); // Display the order details
        }
    }

    // Processes the next order in the queue
    public void processNextOrder() {
        System.out.println("\n--- Processing Next Order ---");
        Order processedOrder = orderQueue.poll(); // Retrieve and remove the head of the queue

        if (processedOrder != null) {
            System.out.println("Successfully processed:");
            System.out.println(processedOrder);
        } else {
            System.err.println("No orders in the queue to process.");
        .println("No orders in the queue to process."); // Using System.err for error message
        }
    }

    // Views the current orders waiting in the queue
    public void viewOrderQueue() {
        System.out.println("\n--- Current Order Queue ---");
        if (orderQueue.isEmpty()) {
            System.out.println("Queue is empty. No pending orders.");
        } else {
            System.out.println("Orders waiting (" + orderQueue.size() + "):");
            // Iterate through the queue without removing elements
            int position = 1;
            for (Order order : orderQueue) {
                System.out.println(position++ + ". Order #" + order.getOrderId());
            }
        }
        System.out.println("---------------------------");
    }

    // Runs the main application loop
    public void run() {
        int choice = -1;
        while (choice != 4) {
            System.out.println("\n--- Restaurant System Menu ---");
            System.out.println("1. Add New Order");
            System.out.println("2. Process Next Order");
            System.out.println("3. View Order Queue");
            System.out.println("4. Exit");
            System.out.print("Enter your choice: ");

            try {
                choice = scanner.nextInt();
                scanner.nextLine(); // Consume newline

                // Using switch statement for menu navigation
                switch (choice) {
                    case 1:
                        createNewOrder();
                        break;
                    case 2:
                        processNextOrder();
                        break;
                    case 3:
                        viewOrderQueue();
                        break;
                    case 4:
                        System.out.println("Exiting Restaurant System. Goodbye!");
                        break;
                    default:
                        System.err.println("Invalid choice. Please enter a number between 1 and 4."); // Using System.err
                }
            } catch (InputMismatchException e) {
                System.err.println("Invalid input. Please enter a number."); // Using System.err
                scanner.nextLine(); // Consume the invalid input
            } catch (Exception e) {
                 // Class-wide exception handling for unexpected errors in the main loop
                 System.err.println("An unexpected error occurred: " + e.getMessage());
                 // e.printStackTrace(); // Optional: for debugging
            }
        }
    }
}

// Main class to start the application
public class RestaurantApp {
    public static void main(String[] args) {
        Scanner scanner = null;
        try {
            scanner = new Scanner(System.in);
            RestaurantSystem system = new RestaurantSystem(scanner);
            system.run(); // Start the main application loop
        } catch (Exception e) {
            // Top-level catch for any errors during setup or initial run
            System.err.println("Application failed to start or encountered a critical error: " + e.getMessage());
            // e.printStackTrace(); // Optional: for debugging
        } finally {
            if (scanner != null) {
                scanner.close(); // Close the scanner resource
            }
        }
    }
}
