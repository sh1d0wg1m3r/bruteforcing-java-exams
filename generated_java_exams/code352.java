/*
 * Exam Question #352
 * Generated on: 2025-05-11 22:59:19
 * Generated by: Account 2
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Event Management System with Waiting List
 * 
 * **Objective:** Design and implement a command-line based event management system that handles attendee registration, check-in, and manages a waiting list when the event capacity is reached. This task requires demonstrating proficiency in using core Java collections, input handling, control flow, and exception management.
 * 
 * **Scenario:** You are developing a simple system for managing attendees for a conference session with a fixed capacity.
 * 
 * **Requirements:**
 * 
 * 1.  **Event Capacity:** The system must have a predefined maximum capacity for attendees.
 * 2.  **Attendee Management:**
 *     *   Maintain a list of attendees who are successfully registered (within capacity or moved from waiting list).
 *     *   Maintain a queue of attendees who registered after capacity was reached.
 * 3.  **Operations:** The system must support the following operations via a command-line menu:
 *     *   **Register Attendee:** Add a new attendee by name. If capacity is available, add to the registered list. If full, add to the waiting list. Prevent duplicate registrations (an attendee name should only appear once in either list combined).
 *     *   **Check-in Attendee:** Simulate an attendee checking in. This operation should find the attendee in the *registered* list, remove them (simulating them entering the event and freeing up a spot), and then attempt to move the next person from the waiting list to the registered list if the waiting list is not empty and a spot is now available.
 *     *   **View Registered Attendees:** Display the current list of registered attendees.
 *     *   **View Waiting List:** Display the current list of attendees on the waiting list.
 *     *   **Exit:** Terminate the program.
 * 4.  **Java Component Usage:** Your solution *must* utilize ALL of the following:
 *     *   `java.util.Queue` (e.g., `LinkedList` implementing `Queue`) for the waiting list.
 *     *   `java.util.ArrayList` for the registered attendees list.
 *     *   `java.util.List` interface for declaring the registered attendees list variable (`List<String> registeredAttendees = new ArrayList<>();`).
 *     *   `java.util.Scanner` for reading user input (menu choices and attendee names).
 *     *   `switch` statement for handling the main menu choices.
 *     *   `System.err` for outputting error messages (e.g., attendee not found, invalid input, event full when registering, waiting list empty).
 *     *   `System.out` for outputting normal information (menu, confirmations, lists).
 *     *   Class-wide exception handling using `try-catch` blocks (at minimum, wrap the main program loop or core logic to catch unexpected exceptions, and handle specific input errors).
 * 5.  **Best Practices:**
 *     *   Implement proper encapsulation (private fields for data structures and capacity).
 *     *   Use meaningful variable and method names.
 *     *   Include appropriate comments and documentation (JavaDocs where applicable).
 *     *   Implement input validation (e.g., ensure attendee names are not empty).
 *     *   Provide clear error messages using `System.err`.
 *     *   Structure the code logically within a class.
 * 
 * **Instructions:**
 * 
 * *   Create a single Java class, `EventManagementSystem`, containing the `main` method and other necessary methods.
 * *   Define the event capacity as a constant or a constructor parameter (e.g., capacity 5).
 * *   Implement the menu system to guide the user.
 * *   Ensure the system handles edge cases like empty lists/queues, full capacity, and attendees not being found.
 * 
 * **Expected Output:**
 * 
 * The program should present a menu. User interactions should result in appropriate output to `System.out` or error messages to `System.err`. List and Queue views should clearly label the output.
 * 
 * Example Interaction Flow:
 * 
 * ```
 * --- Event Management Menu (Capacity: 5) ---
 * 1. Register Attendee
 * 2. Check-in Attendee
 * 3. View Registered Attendees
 * 4. View Waiting List
 * 5. Exit
 * Enter your choice: 1
 * Enter attendee name: Alice
 * Alice registered successfully.
 * 
 * --- Event Management Menu (Capacity: 5) ---
 * ... (register 4 more people) ...
 * Enter your choice: 1
 * Enter attendee name: David
 * David registered successfully.
 * 
 * --- Event Management Menu (Capacity: 5) ---
 * Enter your choice: 1
 * Enter attendee name: Eve
 * Event is full. Eve added to waiting list.
 * 
 * --- Event Management Menu (Capacity: 5) ---
 * Enter your choice: 3
 * Registered Attendees:
 * - Alice
 * - Bob
 * - Charlie
 * - David
 * - Frank
 * 
 * --- Event Management Menu (Capacity: 5) ---
 * Enter your choice: 4
 * Waiting List:
 * - Eve
 * 
 * --- Event Management Menu (Capacity: 5) ---
 * Enter your choice: 2
 * Enter attendee name: Alice
 * Alice checked in successfully.
 * 
 * --- Event Management Menu (Capacity: 5) ---
 * Enter your choice: 3
 * Registered Attendees:
 * - Bob
 * - Charlie
 * - David
 * - Frank
 * - Eve (moved from waiting list)
 * 
 * --- Event Management Menu (Capacity: 5) ---
 * Enter your choice: 4
 * Waiting List:
 * (Waiting list is empty)
 * 
 * --- Event Management Menu (Capacity: 5) ---
 * Enter your choice: 2
 * Enter attendee name: NonExistentPerson
 * Error: Attendee 'NonExistentPerson' not found in registered list.
 * 
 * --- Event Management Menu (Capacity: 5) ---
 * Enter your choice: 5
 * Exiting system.
 * ```
 * 
 * Your solution should compile and run, demonstrating the correct usage of all specified Java components and adherence to best practices.
 *
 * EXPLANATION:
 * The provided solution implements a simple Event Management System following the requirements.
 * 
 * 1.  **Class Structure and Encapsulation:**
 *     *   The system logic is encapsulated within the `EventManagementSystem` class.
 *     *   Data structures (`registeredAttendees`, `waitingList`) and the `capacity` are declared as `private` fields, adhering to encapsulation principles.
 *     *   Public methods (`registerAttendee`, `checkInAttendee`, `viewRegisteredAttendees`, `viewWaitingList`, `runSystem`) provide the interface for interacting with the system. `displayMenu` and `processWaitingList` are helper methods marked `private`.
 * 
 * 2.  **Required Java Components:**
 *     *   `java.util.ArrayList`: Used to implement the `registeredAttendees` list. `ArrayList` is suitable here because we need to store registered attendees and occasionally remove specific elements by value (`remove(Object)`).
 *     *   `java.util.List`: The `registeredAttendees` variable is declared using the `List` interface (`List<String> registeredAttendees = new ArrayList<>();`), demonstrating the use of the interface rather than the concrete implementation type where appropriate.
 *     *   `java.util.Queue`: Used for the `waitingList`. A `LinkedList` is used to implement the `Queue` interface (`Queue<String> waitingList = new LinkedList<>();`). `Queue` methods like `offer()` (add to end) and `poll()` (remove from front) are ideal for managing a waiting list in FIFO (First-In, First-Out) order.
 *     *   `java.util.Scanner`: An instance is created in `runSystem()` to read user input from the console.
 *     *   `switch` statement: Used in the `runSystem()` method to direct program flow based on the user's menu choice.
 *     *   `System.err`: Used specifically for printing error messages (e.g., invalid input, attendee not found, full capacity).
 *     *   `System.out`: Used for printing normal program output (menu, successful registrations, check-ins, list contents).
 * 
 * 3.  **Core Logic Implementation:**
 *     *   `registerAttendee(String name)`: Checks for empty names and duplicates across both lists. If capacity is available, the attendee is added to `registeredAttendees`. Otherwise, they are added to the `waitingList` using `offer()`.
 *     *   `checkInAttendee(String name)`: Validates the input name. It attempts to remove the attendee from the `registeredAttendees` list. If successful, it prints a confirmation and calls `processWaitingList()` to potentially fill the freed spot. If the attendee is not found in the registered list, an error is printed to `System.err`.
 *     *   `processWaitingList()`: This private helper method checks if there is space in the `registeredAttendees` list and if the `waitingList` is not empty. If both conditions are true, it polls the next attendee from the `waitingList` and adds them to the `registeredAttendees` list, printing a confirmation. This continues until either the registered list is full or the waiting list is empty.
 *     *   `viewRegisteredAttendees()` and `viewWaitingList()`: These methods iterate through their respective collections and print the contents, handling the case where the collection is empty. The `viewWaitingList` method iterates using a for-each loop, which is safe as it doesn't remove elements while iterating.
 * 
 * 4.  **Exception Handling:**
 *     *   A broad `try-catch (Exception e)` block is wrapped around the main `while(running)` loop in `runSystem()`. This serves as a class-wide handler for any unexpected runtime exceptions that might occur during program execution, preventing the program from crashing abruptly. It prints an error to `System.err` and the stack trace.
 *     *   A specific `try-catch (InputMismatchException e)` is used within the loop to handle cases where the user enters non-integer input when a number is expected for the menu choice. It prints an error to `System.err` and consumes the invalid input using `scanner.nextLine()` before continuing the loop.
 * 
 * 5.  **Input Validation:**
 *     *   Attendee names are validated in `registerAttendee` and `checkInAttendee` to ensure they are not null or empty strings.
 * 
 * 6.  **Best Practices:**
 *     *   Meaningful names are used for variables (`capacity`, `registeredAttendees`, `waitingList`, `attendeeName`, `choice`) and methods (`registerAttendee`, `checkInAttendee`, `viewRegisteredAttendees`, `viewWaitingList`, `processWaitingList`, `runSystem`, `displayMenu`).
 *     *   Comments and Javadoc-style comments are included to explain the purpose of the class, constructor, and methods.
 *     *   The code is structured logically with separate methods for different operations and helper functions.
 *     *   The `Scanner` resource is properly closed in a `finally` block to prevent resource leaks.
 * 
 * This solution effectively demonstrates the required Java components and programming best practices in a practical, albeit simplified, real-world scenario.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.InputMismatchException;

/**
 * Manages attendees for an event with a fixed capacity and a waiting list.
 */
public class EventManagementSystem {

    private final int capacity;
    private List<String> registeredAttendees; // Using List interface, implemented by ArrayList
    private Queue<String> waitingList;       // Using Queue interface, implemented by LinkedList

    /**
     * Constructs an EventManagementSystem with a specified capacity.
     * @param capacity The maximum number of registered attendees.
     */
    public EventManagementSystem(int capacity) {
        if (capacity <= 0) {
            // This is a critical error, maybe throw an exception or exit
            System.err.println("Error: Event capacity must be positive. Setting to default 1.");
            this.capacity = 1; // Default to a safe value
        } else {
            this.capacity = capacity;
        }
        this.registeredAttendees = new ArrayList<>(); // ArrayList for easy access/removal by index or object
        this.waitingList = new LinkedList<>();       // LinkedList is good for Queue operations (add/poll)
    }

    /**
     * Registers an attendee for the event. Adds to registered list if capacity available,
     * otherwise adds to the waiting list. Prevents duplicate registrations.
     * @param name The name of the attendee to register.
     */
    public void registerAttendee(String name) {
        if (name == null || name.trim().isEmpty()) {
            System.err.println("Error: Attendee name cannot be empty.");
            return;
        }
        String attendeeName = name.trim();

        // Check for duplicates in both lists
        if (registeredAttendees.contains(attendeeName) || waitingList.contains(attendeeName)) {
            System.err.println("Error: Attendee '" + attendeeName + "' is already registered or on the waiting list.");
            return;
        }

        if (registeredAttendees.size() < capacity) {
            registeredAttendees.add(attendeeName);
            System.out.println(attendeeName + " registered successfully.");
        } else {
            waitingList.offer(attendeeName); // offer is preferred over add for queues (returns false if fails)
            System.out.println("Event is full. " + attendeeName + " added to waiting list.");
        }
    }

    /**
     * Simulates an attendee checking in. Removes from registered list and
     * attempts to move someone from the waiting list if capacity is freed.
     * @param name The name of the attendee checking in.
     */
    public void checkInAttendee(String name) {
        if (name == null || name.trim().isEmpty()) {
            System.err.println("Error: Attendee name cannot be empty.");
            return;
        }
        String attendeeName = name.trim();

        boolean removed = registeredAttendees.remove(attendeeName); // Remove returns true if element was found and removed

        if (removed) {
            System.out.println(attendeeName + " checked in successfully.");
            processWaitingList(); // Try to fill the spot from the waiting list
        } else {
            System.err.println("Error: Attendee '" + attendeeName + "' not found in registered list.");
        }
    }

    /**
     * Attempts to move attendees from the waiting list to the registered list
     * if capacity is available.
     */
    private void processWaitingList() {
        while (registeredAttendees.size() < capacity && !waitingList.isEmpty()) {
            String nextAttendee = waitingList.poll(); // poll retrieves and removes the head
            if (nextAttendee != null) {
                registeredAttendees.add(nextAttendee);
                System.out.println(nextAttendee + " moved from waiting list to registered.");
            }
        }
    }

    /**
     * Displays all currently registered attendees.
     */
    public void viewRegisteredAttendees() {
        System.out.println("\nRegistered Attendees (" + registeredAttendees.size() + "/" + capacity + "):");
        if (registeredAttendees.isEmpty()) {
            System.out.println("(No attendees registered)");
        } else {
            for (int i = 0; i < registeredAttendees.size(); i++) {
                System.out.println("- " + registeredAttendees.get(i));
            }
        }
    }

    /**
     * Displays all attendees currently on the waiting list.
     */
    public void viewWaitingList() {
        System.out.println("\nWaiting List (" + waitingList.size() + "):");
        if (waitingList.isEmpty()) {
            System.out.println("(Waiting list is empty)");
        } else {
            // Iterate without removing using a for-each loop or iterator
            for (String attendee : waitingList) {
                System.out.println("- " + attendee);
            }
        }
    }

    /**
     * Displays the main menu options to the user.
     */
    private void displayMenu() {
        System.out.println("\n--- Event Management Menu (Capacity: " + capacity + ") ---");
        System.out.println("1. Register Attendee");
        System.out.println("2. Check-in Attendee");
        System.out.println("3. View Registered Attendees");
        System.out.println("4. View Waiting List");
        System.out.println("5. Exit");
        System.out.print("Enter your choice: ");
    }

    /**
     * Runs the main loop of the event management system, handling user interaction.
     */
    public void runSystem() {
        Scanner scanner = new Scanner(System.in);
        boolean running = true;

        // Class-wide exception handling for the main operational loop
        try {
            while (running) {
                displayMenu();
                int choice = -1;
                try {
                    choice = scanner.nextInt();
                    scanner.nextLine(); // Consume newline left-over
                } catch (InputMismatchException e) {
                    System.err.println("Error: Invalid input. Please enter a number.");
                    scanner.nextLine(); // Consume the invalid input
                    continue; // Skip to the next iteration
                }

                switch (choice) {
                    case 1:
                        System.out.print("Enter attendee name: ");
                        String regName = scanner.nextLine();
                        registerAttendee(regName);
                        break;
                    case 2:
                        System.out.print("Enter attendee name: ");
                        String checkinName = scanner.nextLine();
                        checkInAttendee(checkinName);
                        break;
                    case 3:
                        viewRegisteredAttendees();
                        break;
                    case 4:
                        viewWaitingList();
                        break;
                    case 5:
                        System.out.println("Exiting system.");
                        running = false;
                        break;
                    default:
                        System.err.println("Error: Invalid choice. Please enter a number between 1 and 5.");
                }
            }
        } catch (Exception e) {
            // Catch any unexpected exceptions during the main loop
            System.err.println("An unexpected error occurred: " + e.getMessage());
            e.printStackTrace(); // Print stack trace for debugging
        } finally {
            // Ensure scanner is closed
            if (scanner != null) {
                scanner.close();
            }
        }
    }

    /**
     * Main method to start the event management system.
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        // Set event capacity
        int eventCapacity = 5;
        EventManagementSystem system = new EventManagementSystem(eventCapacity);
        system.runSystem();
    }
}
