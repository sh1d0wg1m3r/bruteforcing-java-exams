/*
 * Exam Question #253
 * Generated on: 2025-05-11 22:39:48
 * Generated by: Account 4
 * 
 * QUESTION:
 * ## Advanced Java Programming Exam: Package Delivery Assignment System
 * 
 * **Objective:** Design and implement a simplified Package Delivery Assignment System using core Java data structures and control flow mechanisms. This task assesses your ability to integrate various Java components, handle user input, manage data structures, implement error handling, and follow best practices.
 * 
 * **Scenario:** You are building the core logic for a package delivery hub. New packages arrive and are placed in a queue for processing. Delivery routes are managed separately. An operator needs to be able to assign the next package from the queue to a specific delivery route.
 * 
 * **Requirements:**
 * 
 * 1.  **Data Structures:**
 *     *   Use a `java.util.Queue` to represent the incoming packages waiting to be assigned.
 *     *   Use a `java.util.ArrayList` to store the list of available delivery routes.
 *     *   Use the `java.util.List` interface for declaring variables that hold lists (e.g., the list of routes, or the list of packages assigned to a route).
 * 
 * 2.  **User Interaction:**
 *     *   Use `java.util.Scanner` to get user input from the console.
 *     *   Implement a menu-driven interface with options for different operations.
 * 
 * 3.  **Control Flow:**
 *     *   Use a `switch` statement to process the user's menu choice.
 *     *   Use loops (e.g., `while`, `for`) for menu processing and iterating through lists/queues.
 * 
 * 4.  **Input/Output:**
 *     *   Use `System.out` for displaying the menu, prompts, success messages, and system state (e.g., queue contents, route details).
 *     *   Use `System.err` for displaying error messages (e.g., invalid input, queue is empty, route not found).
 * 
 * 5.  **Error Handling:**
 *     *   Implement input validation (e.g., check for non-numeric input where numbers are expected).
 *     *   Use `try-catch` blocks for exception handling. Include a class-wide `try-catch` block around the main application loop to catch unexpected runtime errors. Include specific `try-catch` or input validation checks for expected issues like `InputMismatchException`.
 * 
 * 6.  **Object-Oriented Design:**
 *     *   Create separate classes for `Package` and `Route` with appropriate private fields and public getter methods (encapsulation).
 *     *   The main application class should manage the collection of packages and routes.
 * 
 * 7.  **Functionality:**
 *     *   **Add Package:** Prompt for Package ID (int) and Destination Address (String). Add the new `Package` object to the processing queue.
 *     *   **View Processing Queue:** Display the details of all packages currently in the processing queue without removing them. Handle the case where the queue is empty.
 *     *   **Add Route:** Prompt for Route ID (int) and Driver Name (String). Create a new `Route` object and add it to the list of routes. Each `Route` should maintain its own list of assigned packages.
 *     *   **View Routes:** Display the details (ID, Driver) of all available routes. Handle the case where no routes have been added.
 *     *   **Assign Package to Route:**
 *         *   Check if the processing queue is empty. If so, print an error to `System.err`.
 *         *   If not empty, prompt the user for the Route ID to assign the package to.
 *         *   Find the specified route in the list of routes. If not found, print an error to `System.err`.
 *         *   If the route is found, take the *next* package from the processing queue (using `poll()`) and add it to the list of assigned packages for that route. Print a success message to `System.out`.
 *     *   **View Packages on Route:** Prompt the user for a Route ID. Find the route and display the details of all packages assigned to it. Handle cases where the route doesn't exist or has no packages assigned.
 *     *   **Exit:** Terminate the application.
 * 
 * 8.  **Best Practices:**
 *     *   Use meaningful variable and method names.
 *     *   Include appropriate comments and documentation (e.g., Javadoc for classes/methods).
 *     *   Ensure clean code structure and formatting.
 *     *   Close the `Scanner` resource when the application exits.
 * 
 * **Expected Output:**
 * The program should run interactively, presenting a menu. Based on user input, it should perform the requested operation, printing results or errors to the console using `System.out` or `System.err` as required. Example flow: adding packages, viewing the queue, adding routes, viewing routes, assigning a package (showing it removed from the queue and added to a route), viewing packages on a route.
 * 
 * ```
 * --- Package Delivery Assignment System Menu ---
 * 1. Add New Package
 * 2. View Processing Queue
 * 3. Add New Delivery Route
 * 4. View Available Routes
 * 5. Assign Next Package to Route
 * 6. View Packages on Route
 * 7. Exit
 * -----------------------------------------------
 * Enter your choice:
 * ```
 * *(Followed by prompts and output/error messages based on the selected option)*
 * 
 * **Time Estimate:** 45-60 minutes
 *
 * EXPLANATION:
 * This solution implements the Package Delivery Assignment System as described in the exam question, demonstrating the required Java concepts and best practices.
 * 
 * 1.  **Data Structures (`Queue`, `ArrayList`, `List`)**:
 *     *   `processingQueue`: Declared as `Queue<Package>` and instantiated as `new LinkedList<>()`. `LinkedList` is a common implementation of the `Queue` interface in Java, providing efficient insertion and removal from the ends. It holds packages waiting for assignment.
 *     *   `routes`: Declared as `List<Route>` and instantiated as `new ArrayList<>()`. `ArrayList` is used to store the collection of `Route` objects, allowing efficient access by index and dynamic resizing.
 *     *   `assignedPackages`: Within the `Route` class, the list of packages assigned to that specific route is declared as `List<Package>` and instantiated as `new ArrayList<>()`, fulfilling the requirement to use `List` interface with `ArrayList`.
 * 
 * 2.  **User Interaction (`Scanner`)**:
 *     *   A `Scanner` object is initialized to read input from `System.in`. It's used throughout the application to get menu choices, package details, and route details from the user. The `scanner.nextLine()` calls are crucial after `nextInt()` to consume the leftover newline character, preventing issues in subsequent `nextLine()` calls.
 * 
 * 3.  **Control Flow (`switch`, loops)**:
 *     *   The `run()` method contains a `while(true)` loop that keeps the application running until the user chooses to exit.
 *     *   The `processChoice()` method uses a `switch` statement to direct execution based on the integer input received from the user's menu selection.
 *     *   `for` loops are used to iterate through the `processingQueue` (for viewing) and the `routes` list (for viewing or finding a specific route).
 * 
 * 4.  **Input/Output (`System.out`, `System.err`)**:
 *     *   `System.out.println()` and `System.out.print()` are used for all standard output: displaying the menu, prompts, success messages, and listing packages/routes.
 *     *   `System.err.println()` is specifically used for error messages, such as invalid input, attempting to assign from an empty queue, or trying to access a non-existent route. This directs errors to the standard error stream, which is good practice.
 * 
 * 5.  **Error Handling (`try-catch`, Input Validation)**:
 *     *   A broad `try-catch(Exception e)` block is wrapped around the `while` loop in the `run()` method. This serves as a class-wide catch-all for any unexpected exceptions that might occur during the program's execution, printing an error message using `System.err`.
 *     *   Specific input validation is performed before reading integers using `scanner.hasNextInt()`. If the input is not an integer, an error is printed to `System.err`, the invalid input is consumed using `scanner.nextLine()`, and the method returns to the menu, preventing `InputMismatchException`.
 *     *   Inside methods like `addPackage`, `addRoute`, `assignPackageToRoute`, and `viewPackagesOnRoute`, specific `try-catch` blocks are also included around the core logic (like reading input or performing operations) to catch potential issues within those specific tasks, providing more localized error reporting.
 *     *   Checks for empty data structures (e.g., `processingQueue.isEmpty()`, `routes.isEmpty()`) and null values are performed before attempting operations that would fail (like `poll()` on an empty queue or searching for a route in an empty list).
 * 
 * 6.  **Object-Oriented Design**:
 *     *   Separate `Package` and `Route` classes are created to model the entities in the system.
 *     *   Fields within `Package` and `Route` are `private` (e.g., `packageId`, `destinationAddress`, `routeId`, `driverName`, `assignedPackages`).
 *     *   Public getter methods (`getPackageId`, `getDestinationAddress`, `getRouteId`, `getDriverName`, `getAssignedPackages`) are provided to access the private data, adhering to encapsulation principles. The `Route` class also has an `addPackage` method to manage its list of assigned packages.
 *     *   The `DeliverySystem` class orchestrates the interactions between packages, routes, and user input.
 * 
 * 7.  **Functionality**:
 *     *   Each menu option corresponds to a dedicated private method (`addPackage`, `viewProcessingQueue`, etc.) within the `DeliverySystem` class, making the code modular and readable.
 *     *   `addPackage()` uses `queue.offer()`.
 *     *   `viewProcessingQueue()` iterates using an enhanced `for` loop without removing elements.
 *     *   `addRoute()` creates a new `Route` and adds it to the `routes` list.
 *     *   `viewRoutes()` iterates through the `routes` list.
 *     *   `assignPackageToRoute()` checks the queue, finds the route by iterating the `routes` list, uses `queue.poll()` to remove the next package, and calls `route.addPackage()` to add it to the route's list.
 *     *   `viewPackagesOnRoute()` finds the route and iterates through its `assignedPackages` list.
 *     *   Option 7 uses `System.exit(0)` to terminate the application cleanly from the `switch` statement.
 * 
 * 8.  **Best Practices**:
 *     *   Method and variable names are descriptive (e.g., `processingQueue`, `assignPackageToRoute`, `destinationAddress`).
 *     *   Basic Javadoc comments are included for classes and methods explaining their purpose.
 *     *   The code is structured logically with helper methods for each menu option.
 *     *   The `Scanner` is closed in a `finally` block associated with the main `try` block in `run()`, ensuring resource cleanup regardless of whether an exception occurs or the application exits normally (though with `System.exit`, the `finally` block might not always execute depending on the JVM's behavior; a more robust pattern for resource management in modern Java might use try-with-resources if applicable, but for a class-level scanner managed over the app lifecycle, this is a common approach).
 * 
 * This solution effectively combines the required Java components to build a functional, albeit simplified, system while demonstrating key programming concepts and error handling techniques suitable for an advanced exam.
 */

import java.util.Queue;
import java.util.LinkedList; // LinkedList implements Queue
import java.util.List;
import java.util.ArrayList;
import java.util.Scanner;
import java.util.InputMismatchException;

/**
 * Represents a package to be delivered.
 */
class Package {
    private int packageId;
    private String destinationAddress;

    /**
     * Constructs a new Package.
     * @param packageId The unique ID of the package.
     * @param destinationAddress The destination address for the package.
     */
    public Package(int packageId, String destinationAddress) {
        this.packageId = packageId;
        this.destinationAddress = destinationAddress;
    }

    // --- Getters (Encapsulation) ---
    public int getPackageId() {
        return packageId;
    }

    public String getDestinationAddress() {
        return destinationAddress;
    }

    @Override
    public String toString() {
        return "Package [ID=" + packageId + ", Dest='" + destinationAddress + "']";
    }
}

/**
 * Represents a delivery route with assigned packages.
 */
class Route {
    private int routeId;
    private String driverName;
    private List<Package> assignedPackages; // Using List interface with ArrayList implementation

    /**
     * Constructs a new Delivery Route.
     * @param routeId The unique ID of the route.
     * @param driverName The name of the driver for this route.
     */
    public Route(int routeId, String driverName) {
        this.routeId = routeId;
        this.driverName = driverName;
        this.assignedPackages = new ArrayList<>(); // Using ArrayList
    }

    // --- Getters (Encapsulation) ---
    public int getRouteId() {
        return routeId;
    }

    public String getDriverName() {
        return driverName;
    }

    /**
     * Gets the list of packages assigned to this route.
     * Note: Returning a reference allows external modification.
     * For read-only access, one might return Collections.unmodifiableList(assignedPackages).
     * Given the problem context (adding packages to this list), returning the direct reference is acceptable here.
     */
    public List<Package> getAssignedPackages() {
        return assignedPackages;
    }

    /**
     * Adds a package to this route's assignment list.
     * @param pkg The package to add.
     */
    public void addPackage(Package pkg) {
        if (pkg != null) {
            assignedPackages.add(pkg);
        }
    }

    @Override
    public String toString() {
        return "Route [ID=" + routeId + ", Driver='" + driverName + "']";
    }
}

/**
 * Main class for the Package Delivery Assignment System.
 * Manages the processing queue and delivery routes.
 */
public class DeliverySystem {

    // --- Data Structures ---
    private Queue<Package> processingQueue; // Packages waiting for assignment (using Queue interface)
    private List<Route> routes;           // Available delivery routes (using List interface with ArrayList)
    private Scanner scanner;              // Scanner for user input

    /**
     * Constructs the DeliverySystem.
     * Initializes the queue, list, and scanner.
     */
    public DeliverySystem() {
        this.processingQueue = new LinkedList<>(); // LinkedList implements Queue
        this.routes = new ArrayList<>();          // Using ArrayList
        this.scanner = new Scanner(System.in);
    }

    /**
     * Displays the main menu options.
     */
    private void displayMenu() {
        System.out.println("\n--- Package Delivery Assignment System Menu ---");
        System.out.println("1. Add New Package");
        System.out.println("2. View Processing Queue");
        System.out.println("3. Add New Delivery Route");
        System.out.println("4. View Available Routes");
        System.out.println("5. Assign Next Package to Route");
        System.out.println("6. View Packages on Route");
        System.out.println("7. Exit");
        System.out.println("-----------------------------------------------");
    }

    /**
     * Adds a new package to the processing queue based on user input.
     */
    private void addPackage() {
        System.out.println("\n--- Add New Package ---");
        try {
            System.out.print("Enter Package ID: ");
            int packageId;
            // Input validation for integer ID
            if (scanner.hasNextInt()) {
                packageId = scanner.nextInt();
                scanner.nextLine(); // Consume newline
            } else {
                System.err.println("Invalid input. Please enter a numeric Package ID.");
                scanner.nextLine(); // Consume the invalid input
                return; // Exit the method
            }

            System.out.print("Enter Destination Address: ");
            String destinationAddress = scanner.nextLine();
            // Input validation for non-empty address
            if (destinationAddress == null || destinationAddress.trim().isEmpty()) {
                 System.err.println("Destination address cannot be empty.");
                 return; // Exit the method
            }

            Package newPackage = new Package(packageId, destinationAddress.trim());
            processingQueue.offer(newPackage); // Add to the end of the queue
            System.out.println("Success: Package " + packageId + " added to the processing queue.");

        } catch (Exception e) {
            // Catch any other unexpected errors during package addition
            System.err.println("An unexpected error occurred while adding package: " + e.getMessage());
        }
    }

    /**
     * Displays all packages currently in the processing queue.
     */
    private void viewProcessingQueue() {
        System.out.println("\n--- Processing Queue ---");
        if (processingQueue.isEmpty()) {
            System.out.println("The processing queue is empty.");
        } else {
            // Iterate through the queue without removing elements
            int count = 1;
            for (Package pkg : processingQueue) {
                System.out.println(count++ + ". " + pkg);
            }
        }
    }

    /**
     * Adds a new delivery route based on user input.
     */
    private void addRoute() {
        System.out.println("\n--- Add New Delivery Route ---");
        try {
            System.out.print("Enter Route ID: ");
            int routeId;
             // Input validation for integer ID
            if (scanner.hasNextInt()) {
                routeId = scanner.nextInt();
                scanner.nextLine(); // Consume newline
            } else {
                System.err.println("Invalid input. Please enter a numeric Route ID.");
                scanner.nextLine(); // Consume the invalid input
                return; // Exit the method
            }

            System.out.print("Enter Driver Name: ");
            String driverName = scanner.nextLine();
             // Input validation for non-empty name
            if (driverName == null || driverName.trim().isEmpty()) {
                 System.err.println("Driver name cannot be empty.");
                 return; // Exit the method
            }

            Route newRoute = new Route(routeId, driverName.trim());
            routes.add(newRoute); // Add to the list of routes
            System.out.println("Success: Route " + routeId + " added.");

        } catch (Exception e) {
            // Catch any other unexpected errors during route addition
            System.err.println("An unexpected error occurred while adding route: " + e.getMessage());
        }
    }

    /**
     * Displays all available delivery routes.
     */
    private void viewRoutes() {
        System.out.println("\n--- Available Routes ---");
        if (routes.isEmpty()) {
            System.out.println("No delivery routes have been added yet.");
        } else {
            int count = 1;
            for (Route route : routes) {
                System.out.println(count++ + ". " + route);
            }
        }
    }

    /**
     * Assigns the next package from the queue to a specified route.
     */
    private void assignPackageToRoute() {
        System.out.println("\n--- Assign Package to Route ---");
        if (processingQueue.isEmpty()) {
            System.err.println("Error: Processing queue is empty. No packages to assign.");
            return;
        }

        viewRoutes(); // Help user choose a route
        if (routes.isEmpty()) {
             System.err.println("Error: No routes available to assign packages to.");
             return;
        }

        System.out.print("Enter the Route ID to assign the package to: ");
        int routeId;
        try {
            // Input validation for integer ID
            if (scanner.hasNextInt()) {
                routeId = scanner.nextInt();
                scanner.nextLine(); // Consume newline
            } else {
                System.err.println("Invalid input. Please enter a numeric Route ID.");
                scanner.nextLine(); // Consume the invalid input
                return; // Exit the method
            }

            // Find the route
            Route targetRoute = null;
            for (Route route : routes) {
                if (route.getRouteId() == routeId) {
                    targetRoute = route;
                    break;
                }
            }

            if (targetRoute == null) {
                System.err.println("Error: Route with ID " + routeId + " not found.");
                return;
            }

            // Get the next package from the queue
            Package packageToAssign = processingQueue.poll(); // Removes the head of the queue

            if (packageToAssign != null) {
                targetRoute.addPackage(packageToAssign); // Add package to route's list
                System.out.println("Success: Package " + packageToAssign.getPackageId() +
                                   " assigned to Route " + targetRoute.getRouteId() + " (" + targetRoute.getDriverName() + ").");
            } else {
                 // This case should ideally not be reached due to the initial isEmpty() check,
                 // but it's good practice to handle poll() returning null.
                 System.err.println("Error: Could not retrieve package from queue.");
            }

        } catch (Exception e) {
            // Catch any other unexpected errors during assignment
            System.err.println("An unexpected error occurred while assigning package: " + e.getMessage());
        }
    }

    /**
     * Displays packages assigned to a specific route.
     */
    private void viewPackagesOnRoute() {
        System.out.println("\n--- View Packages on Route ---");
        if (routes.isEmpty()) {
            System.out.println("No routes available to view packages from.");
            return;
        }

        viewRoutes(); // Help user choose a route

        System.out.print("Enter the Route ID to view packages for: ");
        int routeId;
         try {
            // Input validation for integer ID
            if (scanner.hasNextInt()) {
                routeId = scanner.nextInt();
                scanner.nextLine(); // Consume newline
            } else {
                System.err.println("Invalid input. Please enter a numeric Route ID.");
                scanner.nextLine(); // Consume the invalid input
                return; // Exit the method
            }

            // Find the route
            Route targetRoute = null;
            for (Route route : routes) {
                if (route.getRouteId() == routeId) {
                    targetRoute = route;
                    break;
                }
            }

            if (targetRoute == null) {
                System.err.println("Error: Route with ID " + routeId + " not found.");
                return;
            }

            // Display packages on the route
            List<Package> assigned = targetRoute.getAssignedPackages();
            System.out.println("Packages assigned to Route " + targetRoute.getRouteId() + " (" + targetRoute.getDriverName() + "):");
            if (assigned.isEmpty()) {
                System.out.println("No packages assigned to this route yet.");
            } else {
                int count = 1;
                for (Package pkg : assigned) {
                    System.out.println(count++ + ". " + pkg);
                }
            }

        } catch (Exception e) {
            // Catch any other unexpected errors during viewing
            System.err.println("An unexpected error occurred while viewing route packages: " + e.getMessage());
        }
    }

    /**
     * The main application loop.
     */
    public void run() {
        int choice;
        // Class-wide exception handling around the main loop
        try {
            while (true) {
                displayMenu();
                System.out.print("Enter your choice: ");

                // Validate that the next input is an integer for the menu choice
                if (scanner.hasNextInt()) {
                    choice = scanner.nextInt();
                    scanner.nextLine(); // Consume the newline character left by nextInt()
                    processChoice(choice);
                } else {
                    // Handle non-integer input for menu choice
                    System.err.println("Invalid input. Please enter a number from the menu.");
                    scanner.nextLine(); // Consume the invalid input to prevent infinite loop
                }
            }
        } catch (Exception e) {
            // Catch any unexpected runtime errors that escape specific handling
            System.err.println("An unexpected system error occurred: " + e.getMessage());
            // Optional: e.printStackTrace(); for detailed debugging info
        } finally {
            // Ensure the scanner is closed when the application terminates
            if (scanner != null) {
                scanner.close();
                System.out.println("Scanner closed.");
            }
        }
    }

    /**
     * Processes the user's menu choice using a switch statement.
     * @param choice The integer choice made by the user.
     */
    private void processChoice(int choice) {
        switch (choice) {
            case 1:
                addPackage();
                break;
            case 2:
                viewProcessingQueue();
                break;
            case 3:
                addRoute();
                break;
            case 4:
                viewRoutes();
                break;
            case 5:
                assignPackageToRoute();
                break;
            case 6:
                viewPackagesOnRoute();
                break;
            case 7:
                System.out.println("Exiting Delivery System. Goodbye!");
                // System.exit(0); // Use System.exit to terminate the application
                // Alternatively, break the loop in run() and let finally block execute
                // Breaking the loop is cleaner as it ensures finally runs.
                // We can achieve this by having run() return or setting a flag.
                // Let's use a flag for clarity.
                // For a simple exam answer, System.exit(0) is also acceptable if loop break logic is complex.
                // Let's modify run() to use a flag.
                // For this specific structure where processChoice is called in an infinite loop,
                // System.exit(0) is the most straightforward way to exit from the switch case.
                System.exit(0);
                break; // This break is technically unreachable after System.exit(0)
            default:
                System.err.println("Invalid choice. Please enter a number between 1 and 7.");
        }
    }

    /**
     * Main method to start the application.
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        DeliverySystem system = new DeliverySystem();
        system.run(); // Start the main application loop
    }
}
