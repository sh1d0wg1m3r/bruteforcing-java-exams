/*
 * Exam Question #291
 * Generated on: 2025-05-11 22:50:33
 * Generated by: Account 1
 * 
 * QUESTION:
 * ## Java Programming Exam - Advanced Concepts
 * 
 * **Duration:** 60 minutes
 * 
 * **Problem Description:**
 * 
 * You are tasked with developing a simple **Task Management System** for a small project team. The system should allow users to add tasks, view all tasks, and process high-priority tasks. Tasks have a unique ID, a description, and a priority level (HIGH, MEDIUM, LOW). High-priority tasks need to be processed in a specific order (first-in, first-out) before other tasks.
 * 
 * Your system must fulfill the following requirements:
 * 
 * 1.  **Task Representation:** Create a `Task` class with private fields for `id` (auto-generated integer), `description` (String), `priority` (enum or String), and `isCompleted` (boolean). Include a constructor and public getter methods.
 * 2.  **Task Manager:** Create a `TaskManager` class that manages the tasks.
 *     *   It must store *all* tasks (completed or not) in a data structure declared using the `java.util.List` interface. Use `java.util.ArrayList` as the concrete implementation.
 *     *   It must maintain a separate processing queue specifically for *high-priority* tasks, declared using the `java.util.Queue` interface. Use `java.util.LinkedList` as the concrete implementation for this queue.
 * 3.  **Functionality:**
 *     *   **Add Task:** Allow the user to input a task description and priority. Assign a unique, incrementing ID starting from 1. Add the task to the main list. If the task is HIGH priority, also add it to the high-priority processing queue.
 *     *   **View All Tasks:** Display details of all tasks currently in the system (from the main list), including their ID, description, priority, and completion status.
 *     *   **Process High Priority Task:** Take the *next* task from the high-priority processing queue, mark it as completed in the main list (find the task by ID), and print a confirmation message. If the queue is empty, print a message indicating that no high-priority tasks are waiting.
 *     *   **Exit:** Terminate the program.
 * 4.  **User Interface:**
 *     *   Use `java.util.Scanner` to get user input from the console.
 *     *   Present a menu with options for the above functionalities.
 *     *   Use a `switch` statement to handle the user's menu selection.
 *     *   Use `System.out` for displaying the menu, prompts, task details, and success messages.
 *     *   Use `System.err` to display error messages (e.g., invalid menu input, attempting to process from an empty queue - although the requirement is to print a message, not an error for an empty queue, reserve `System.err` for actual input parsing errors).
 * 5.  **Error Handling:**
 *     *   Implement class-wide exception handling within the `TaskManager` (e.g., in the main loop or input handling methods) using `try-catch` blocks to gracefully handle unexpected issues, particularly related to input parsing.
 *     *   Validate user input where appropriate (e.g., ensure menu choice is a valid integer within the range).
 * 6.  **Best Practices:**
 *     *   Employ proper encapsulation (private fields, public methods).
 *     *   Use meaningful variable and method names.
 *     *   Include basic comments explaining key parts.
 *     *   Ensure the `Scanner` is closed properly.
 * 
 * **Expected Output:**
 * 
 * The program should loop, presenting a menu and processing user commands until the 'Exit' option is chosen. Output should be clear, indicating the result of each operation (task added, tasks listed, task processed, or error message).
 * 
 * ```
 * --- Task Management System ---
 * 1. Add Task
 * 2. View All Tasks
 * 3. Process High Priority Task
 * 4. Exit
 * Enter your choice:
 * ```
 * 
 * *(Subsequent output depends on user actions)*
 * 
 * **Example Interaction Snippet:**
 * 
 * ```
 * --- Task Management System ---
 * 1. Add Task
 * 2. View All Tasks
 * 3. Process High Priority Task
 * 4. Exit
 * Enter your choice: 1
 * Enter task description: Write report
 * Enter priority (HIGH, MEDIUM, LOW): HIGH
 * Task 1 (Write report) added with HIGH priority. Added to processing queue.
 * --- Task Management System ---
 * ...
 * Enter your choice: 1
 * Enter task description: Schedule meeting
 * Enter priority (HIGH, MEDIUM, LOW): MEDIUM
 * Task 2 (Schedule meeting) added with MEDIUM priority.
 * --- Task Management System ---
 * ...
 * Enter your choice: 1
 * Enter task description: Review code
 * Enter priority (HIGH, MEDIUM, LOW): HIGH
 * Task 3 (Review code) added with HIGH priority. Added to processing queue.
 * --- Task Management System ---
 * ...
 * Enter your choice: 3
 * Processing next high priority task...
 * Task 1 (Write report) marked as completed.
 * --- Task Management System ---
 * ...
 * Enter your choice: 2
 * --- All Tasks ---
 * ID: 1, Description: Write report, Priority: HIGH, Completed: true
 * ID: 2, Description: Schedule meeting, Priority: MEDIUM, Completed: false
 * ID: 3, Description: Review code, Priority: HIGH, Completed: false
 * -------------------
 * --- Task Management System ---
 * ...
 * Enter your choice: 3
 * Processing next high priority task...
 * Task 3 (Review code) marked as completed.
 * --- Task Management System ---
 * ...
 * Enter your choice: 3
 * Processing next high priority task...
 * No high priority tasks in the queue.
 * --- Task Management System ---
 * ...
 * Enter your choice: 4
 * Exiting Task Management System.
 * ```
 * 
 * **Task:** Implement the complete Java code for this Task Management System according to the requirements.
 *
 * EXPLANATION:
 * This solution implements a basic Task Management System demonstrating the required Java concepts and best practices.
 * 
 * 1.  **`Task` Class:**
 *     *   Represents a single task entity.
 *     *   Uses `private` fields (`id`, `description`, `priority`, `isCompleted`) for encapsulation.
 *     *   `id` is auto-generated using a `static` counter (`nextId`) ensuring uniqueness.
 *     *   Includes a constructor and public getter methods.
 *     *   The `markCompleted()` method modifies the internal state, demonstrating object behavior.
 *     *   `toString()` provides a formatted representation for easy printing.
 *     *   An `enum Priority` is used for type safety and readability for task priority levels.
 * 
 * 2.  **`TaskManager` Class:**
 *     *   This is the main class orchestrating the system.
 *     *   `private List<Task> allTasks = new ArrayList<>();`: Declares a list using the `List` interface and initializes it with an `ArrayList`. This list holds *all* tasks created, regardless of their priority or completion status. `ArrayList` is suitable here for dynamic storage and easy iteration/access.
 *     *   `private Queue<Task> highPriorityQueue = new LinkedList<>();`: Declares a queue using the `Queue` interface and initializes it with a `LinkedList`. `LinkedList` implements `Queue` and provides the necessary FIFO (First-In, First-Out) behavior required for processing high-priority tasks in the order they were added to the queue. The `Queue` interface methods like `offer()` (add) and `poll()` (retrieve and remove) are used.
 *     *   `private Scanner scanner = new Scanner(System.in);`: Used for reading user input from the console.
 *     *   **`run()` Method:** Contains the main application loop. It repeatedly prints the menu, gets user input, and uses a `switch` statement to dispatch to the appropriate methods.
 *     *   **Class-wide `try-catch`:** The `run()` method is wrapped in a `try-catch(Exception e)` block. While more granular error handling exists (like in `getUserChoice`), this outer block serves as a fallback to catch any unexpected runtime exceptions that might occur within the main loop, demonstrating class-wide handling as required. The `finally` block ensures the `Scanner` is closed.
 *     *   **`printMenu()`:** A simple helper to display the menu options using `System.out`.
 *     *   **`getUserChoice()`:** Handles reading the user's menu selection. It uses a `try-catch(InputMismatchException)` specifically for handling cases where the user enters non-integer input, printing an error message to `System.err` and consuming the invalid input before returning an invalid choice value (-1) which the `switch` can handle or the loop can re-prompt for. This demonstrates specific input validation and error handling.
 *     *   **`addTask()`:** Prompts the user for task details, creates a `Task` object, adds it to the `allTasks` list. It validates the priority input using a loop and `try-catch(IllegalArgumentException)` with `Priority.valueOf()`. If the priority is `HIGH`, it also adds the task to the `highPriorityQueue` using `offer()`. Uses `System.out` for prompts and success messages.
 *     *   **`viewAllTasks()`:** Iterates through the `allTasks` list and prints the `toString()` representation of each task using `System.out`.
 *     *   **`processHighPriorityTask()`:** Calls `highPriorityQueue.poll()` to retrieve and remove the next task from the queue. If `poll()` returns `null` (queue is empty), it prints a message to `System.out`. If a task is retrieved, it iterates through `allTasks` to find the corresponding task by ID and calls its `markCompleted()` method. Uses `System.out` for success/status messages and `System.err` for a potential (though unlikely in this logic) internal error scenario.
 *     *   **`closeScanner()`:** A private helper method called in the `finally` block of `run()` to ensure the `Scanner` resource is properly released, preventing resource leaks.
 * 
 * 3.  **Required Components Usage:**
 *     *   `Queue`: Used for `highPriorityQueue` (specifically `LinkedList` implementation).
 *     *   `ArrayList`: Used for `allTasks`.
 *     *   `List interface`: `allTasks` is declared as `List<Task>`.
 *     *   `Scanner`: Used in `TaskManager` for user input.
 *     *   `Switch statement`: Used in `run()` for menu navigation.
 *     *   `System.err`: Used for invalid input errors (`getUserChoice`, `addTask`) and potential internal errors (`processHighPriorityTask`).
 *     *   `System.out`: Used for all normal output (menu, prompts, task details, success messages).
 *     *   Class-wide `try-catch`: Implemented around the main `run()` loop.
 * 
 * 4.  **Best Practices:**
 *     *   Encapsulation is used in the `Task` class.
 *     *   Variable names (`allTasks`, `highPriorityQueue`, `description`, `priority`, etc.) and method names (`addTask`, `viewAllTasks`, `processHighPriorityTask`, etc.) are meaningful.
 *     *   Comments explain the purpose of classes, fields, and key methods.
 *     *   Input validation and specific error handling (`InputMismatchException`, `IllegalArgumentException`) are implemented.
 *     *   General exception handling (`Exception`) is present in the `run` loop.
 *     *   Resource management (`scanner.close()`) is handled in a `finally` block.
 *     *   Code is structured into logical methods within the `TaskManager` class.
 * 
 * This solution effectively integrates all required components into a functional, albeit simple, application, demonstrating a solid understanding of core and advanced Java concepts suitable for an exam.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.InputMismatchException;

// Enum for Task Priority
enum Priority {
    HIGH, MEDIUM, LOW
}

// Represents a single task
class Task {
    private int id;
    private String description;
    private Priority priority;
    private boolean isCompleted;

    // Static counter for unique IDs
    private static int nextId = 1;

    public Task(String description, Priority priority) {
        this.id = nextId++;
        this.description = description;
        this.priority = priority;
        this.isCompleted = false; // Tasks start as not completed
    }

    // Getters
    public int getId() {
        return id;
    }

    public String getDescription() {
        return description;
    }

    public Priority getPriority() {
        return priority;
    }

    public boolean isCompleted() {
        return isCompleted;
    }

    // Method to mark task as completed
    public void markCompleted() {
        this.isCompleted = true;
    }

    @Override
    public String toString() {
        return String.format("ID: %d, Description: %s, Priority: %s, Completed: %b",
                id, description, priority, isCompleted);
    }
}

// Manages the collection of tasks
public class TaskManager {
    // Use List interface with ArrayList implementation for all tasks
    private List<Task> allTasks;
    // Use Queue interface with LinkedList implementation for high priority tasks waiting processing
    private Queue<Task> highPriorityQueue;
    private Scanner scanner;

    public TaskManager() {
        this.allTasks = new ArrayList<>();
        this.highPriorityQueue = new LinkedList<>();
        this.scanner = new Scanner(System.in);
    }

    // Main method to run the application
    public static void main(String[] args) {
        TaskManager manager = new TaskManager();
        manager.run();
    }

    // Runs the main application loop
    public void run() {
        int choice = -1;
        // Class-wide try-catch block for the main loop
        try {
            while (choice != 4) {
                printMenu();
                choice = getUserChoice();

                // Switch statement for menu options
                switch (choice) {
                    case 1:
                        addTask();
                        break;
                    case 2:
                        viewAllTasks();
                        break;
                    case 3:
                        processHighPriorityTask();
                        break;
                    case 4:
                        System.out.println("Exiting Task Management System.");
                        break;
                    default:
                        // This case should ideally not be reached if getUserChoice validates input
                        System.err.println("Invalid choice. Please try again.");
                }
                System.out.println(); // Add a blank line for readability
            }
        } catch (Exception e) {
            // Catch any unexpected exceptions during runtime
            System.err.println("An unexpected error occurred: " + e.getMessage());
            // e.printStackTrace(); // Uncomment for debugging
        } finally {
            // Ensure scanner is closed
            closeScanner();
        }
    }

    // Prints the main menu
    private void printMenu() {
        System.out.println("--- Task Management System ---");
        System.out.println("1. Add Task");
        System.out.println("2. View All Tasks");
        System.out.println("3. Process High Priority Task");
        System.out.println("4. Exit");
        System.out.print("Enter your choice: ");
    }

    // Gets and validates user's menu choice
    private int getUserChoice() {
        int choice = -1;
        try {
            choice = scanner.nextInt();
            // Consume the rest of the line after the integer
            scanner.nextLine();
        } catch (InputMismatchException e) {
            // Handle non-integer input
            System.err.println("Invalid input. Please enter a number.");
            scanner.nextLine(); // Consume the invalid input
            choice = -1; // Set choice to invalid value
        }
        return choice;
    }

    // Adds a new task based on user input
    private void addTask() {
        System.out.print("Enter task description: ");
        String description = scanner.nextLine();

        Priority priority = null;
        boolean validPriority = false;
        while (!validPriority) {
            System.out.print("Enter priority (HIGH, MEDIUM, LOW): ");
            String priorityString = scanner.nextLine().trim().toUpperCase();
            try {
                priority = Priority.valueOf(priorityString);
                validPriority = true;
            } catch (IllegalArgumentException e) {
                System.err.println("Invalid priority. Please enter HIGH, MEDIUM, or LOW.");
            }
        }

        Task newTask = new Task(description, priority);
        allTasks.add(newTask);
        System.out.printf("Task %d (%s) added with %s priority.\n", newTask.getId(), newTask.getDescription(), newTask.getPriority());

        // Add to high priority queue if applicable
        if (newTask.getPriority() == Priority.HIGH) {
            highPriorityQueue.offer(newTask); // offer is preferred over add in queues
            System.out.println("Added to high priority processing queue.");
        }
    }

    // Displays all tasks in the system
    private void viewAllTasks() {
        System.out.println("--- All Tasks ---");
        if (allTasks.isEmpty()) {
            System.out.println("No tasks in the system.");
        } else {
            for (Task task : allTasks) {
                System.out.println(task);
            }
        }
        System.out.println("-------------------");
    }

    // Processes the next high priority task from the queue
    private void processHighPriorityTask() {
        System.out.println("Processing next high priority task...");
        Task taskToProcess = highPriorityQueue.poll(); // poll retrieves and removes, returns null if empty

        if (taskToProcess == null) {
            System.out.println("No high priority tasks in the queue.");
        } else {
            // Find the task in the main list and mark as completed
            // We iterate because we need to modify the task object within the list
            boolean found = false;
            for (Task task : allTasks) {
                if (task.getId() == taskToProcess.getId()) {
                    task.markCompleted();
                    found = true;
                    System.out.printf("Task %d (%s) marked as completed.\n", task.getId(), task.getDescription());
                    break; // Found the task, no need to continue
                }
            }
            if (!found) {
                 // This case should ideally not happen if logic is correct,
                 // but good practice to handle unexpected states.
                 System.err.println("Error: Processed task not found in main list! ID: " + taskToProcess.getId());
            }
        }
    }

    // Closes the scanner resource
    private void closeScanner() {
        if (scanner != null) {
            scanner.close();
            System.out.println("Scanner closed."); // Optional: confirm closure
        }
    }
}
