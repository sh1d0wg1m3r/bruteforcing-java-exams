/*
 * Exam Question #727
 * Generated on: 2025-05-12 16:31:48
 * Generated by: Account 1
 * 
 * QUESTION:
 * **Advanced Java Programming Exam: Task Management System**
 * 
 * **Problem Description:**
 * 
 * You are tasked with developing a simple console-based task management system for a small team. The system should allow users to add new tasks, process the next pending task, view all tasks ever created, and view only the tasks currently waiting to be processed.
 * 
 * The system must manage tasks using two distinct collections: a queue for tasks waiting to be processed (maintaining their order of readiness) and a list containing a historical record of *all* tasks ever added to the system.
 * 
 * Your solution must adhere to the following specific requirements:
 * 
 * 1.  **Task Class:** Create a `Task` class with private fields for a unique integer `taskId` and a `String description`. Include a constructor and public getter methods for these fields. The `taskId` should be automatically assigned sequentially when a new task is created.
 * 2.  **TaskManager Class:** Create a `TaskManager` class responsible for managing the task collections.
 *     *   It must have private fields: a `Queue<Task>` for pending tasks and a `List<Task>` for all tasks.
 *     *   Initialize these collections in the constructor using concrete implementations (`LinkedList` for the Queue, `ArrayList` for the List).
 *     *   Implement the following public methods:
 *         *   `addTask(String description)`: Creates a new `Task` object, adds it to *both* the pending task queue and the all tasks list. Assigns a unique, incrementing `taskId`.
 *         *   `processNextTask()`: Removes and returns the task at the front of the pending task queue. If the queue is empty, it should indicate this appropriately.
 *         *   `getAllTasks()`: Returns the `List<Task>` containing all tasks ever added.
 *         *   `getPendingTasks()`: Returns the `Queue<Task>` containing tasks currently waiting to be processed.
 * 3.  **Main Application Class:** Create a main class (e.g., `TaskSystem`) containing the `main` method.
 *     *   Use `java.util.Scanner` to read user input from the console.
 *     *   Implement a menu-driven interface with the following options:
 *         *   1. Add New Task
 *         *   2. Process Next Task
 *         *   3. List All Tasks
 *         *   4. List Pending Tasks
 *         *   5. Exit
 *     *   Use a `switch` statement to handle the user's menu choice.
 *     *   Display the menu and prompt for input repeatedly until the user chooses to exit.
 *     *   Use `System.out.println()` for normal output (menu, prompts, task details, success messages).
 *     *   Use `System.err.println()` for error messages (e.g., invalid menu choice, invalid input format, attempting to process when the queue is empty).
 *     *   Implement class-wide exception handling using `try-catch` blocks to gracefully handle potential runtime errors during program execution (e.g., input errors). The program should not crash due to unexpected issues; it should print an error message and continue the menu loop.
 * 4.  **Input Validation:** Validate user input for menu choices and task descriptions (e.g., ensure description is not empty).
 * 5.  **Best Practices:** Employ proper encapsulation (private fields, public getters/methods), meaningful variable and method names, and add comments to explain key parts of the code.
 * 
 * **Expected Output:**
 * 
 * The program should run interactively. Example interactions might look like:
 * 
 * ```
 * Task Management System Menu:
 * 1. Add New Task
 * 2. Process Next Task
 * 3. List All Tasks
 * 4. List Pending Tasks
 * 5. Exit
 * Enter your choice: 1
 * Enter task description: Implement feature X
 * Task added: [ID: 1, Description: Implement feature X]
 * 
 * Task Management System Menu:
 * 1. Add New Task
 * 2. Process Next Task
 * 3. List All Tasks
 * 4. List Pending Tasks
 * 5. Exit
 * Enter your choice: 1
 * Enter task description: Write documentation
 * Task added: [ID: 2, Description: Write documentation]
 * 
 * Task Management System Menu:
 * 1. Add New Task
 * 2. Process Next Task
 * 3. List All Tasks
 * 4. List Pending Tasks
 * 5. Exit
 * Enter your choice: 4
 * Pending Tasks:
 * [ID: 1, Description: Implement feature X]
 * [ID: 2, Description: Write documentation]
 * 
 * Task Management System Menu:
 * 1. Add New Task
 * 2. Process Next Task
 * 3. List All Tasks
 * 4. List Pending Tasks
 * 5. Exit
 * Enter your choice: 2
 * Processing task: [ID: 1, Description: Implement feature X]
 * Task processed successfully.
 * 
 * Task Management System Menu:
 * 1. Add New Task
 * 2. Process Next Task
 * 3. List All Tasks
 * 4. List Pending Tasks
 * 5. Exit
 * Enter your choice: 4
 * Pending Tasks:
 * [ID: 2, Description: Write documentation]
 * 
 * Task Management System Menu:
 * 1. Add New Task
 * 2. Process Next Task
 * 3. List All Tasks
 * 4. List Pending Tasks
 * 5. Exit
 * Enter your choice: 3
 * All Tasks:
 * [ID: 1, Description: Implement feature X]
 * [ID: 2, Description: Write documentation]
 * 
 * Task Management System Menu:
 * 1. Add New Task
 * 2. Process Next Task
 * 3. List All Tasks
 * 4. List Pending Tasks
 * 5. Exit
 * Enter your choice: 6
 * Invalid choice. Please enter a number between 1 and 5.
 * ```
 * (And similar error messages for invalid input types or processing an empty queue).
 * 
 * Your code should be well-structured, demonstrating a solid understanding of object-oriented principles and the required Java collections and control flow structures.
 *
 * EXPLANATION:
 * The provided solution implements a simple Task Management System demonstrating the required Java concepts.
 * 
 * 1.  **`Task` Class:** This is a simple Plain Old Java Object (POJO) representing a task. It encapsulates `taskId` and `description` with private fields and public getters, adhering to encapsulation principles. The `toString()` method provides a convenient way to print task details.
 * 
 * 2.  **`TaskManager` Class:** This class is the core logic handler.
 *     *   It uses a `private Queue<Task> taskQueue;` initialized with `new LinkedList<>()`. A `Queue` is ideal for managing tasks in a first-in, first-out (FIFO) manner, which is typical for processing pending items. `LinkedList` is a common implementation of the `Queue` interface.
 *     *   It uses a `private List<Task> allTasks;` initialized with `new ArrayList<>()`. A `List` (specifically `ArrayList` here) is suitable for storing a dynamic, ordered collection of *all* tasks, allowing easy iteration and access to the full history.
 *     *   The `addTask` method demonstrates adding the same object reference to two different collections, serving different purposes (pending vs. historical record). It also manages the sequential `taskId`.
 *     *   The `processNextTask` method uses `taskQueue.poll()`, which is the standard `Queue` method to retrieve and remove the head. It returns `null` if the queue is empty, which is handled in the main application logic.
 *     *   `getAllTasks` and `getPendingTasks` provide access to the respective collections. Note that returning the collection references directly is acceptable for this problem's scope, though in a more complex system, returning defensive copies might be considered depending on requirements.
 * 
 * 3.  **`TaskSystem` Class:** This contains the `main` method, which drives the application.
 *     *   `Scanner` is used to read user input from `System.in`.
 *     *   A `TaskManager` instance is created to manage the tasks.
 *     *   A `while (running)` loop keeps the application running until the user chooses to exit.
 *     *   Inside the loop, `displayMenu()` prints the options using `System.out`.
 *     *   Input for the menu choice is read using `scanner.nextInt()`. A `try-catch (InputMismatchException e)` block is specifically used here to handle cases where the user enters non-integer input, printing an error to `System.err` and consuming the invalid input before continuing the loop.
 *     *   A `switch (choice)` statement handles the different menu options. Each case calls the appropriate `TaskManager` method and prints results or error messages using `System.out` or `System.err`.
 *     *   Case 1 (`addTask`): Prompts for description, uses `scanner.nextLine()` (with a preceding `nextLine()` to consume the leftover newline from `nextInt()`), validates that the description is not empty, and calls `taskManager.addTask()`.
 *     *   Case 2 (`processNextTask`): Calls `taskManager.processNextTask()`. It checks if the returned task is `null` (indicating an empty queue) and prints an error to `System.err` if so, otherwise prints the processed task details to `System.out`.
 *     *   Case 3 (`listAllTasks`): Retrieves the `List` from `taskManager.getAllTasks()` and iterates through it to print all tasks to `System.out`.
 *     *   Case 4 (`listPendingTasks`): Retrieves the `Queue` from `taskManager.getPendingTasks()`. It iterates through the queue to print pending tasks. Note that iterating a `Queue` typically doesn't remove elements unless methods like `poll()` or `remove()` are used within the loop.
 *     *   Case 5 (`Exit`): Sets `running` to `false` to terminate the loop.
 *     *   The `default` case in the `switch` handles invalid integer choices, printing an error to `System.err`.
 *     *   **Class-wide Exception Handling:** The entire `while` loop (the core application logic) is wrapped in a `try { ... } catch (Exception e) { ... }` block. This fulfills the requirement for class-wide exception handling. While more specific catches are used for expected input errors (`InputMismatchException`), this outer block ensures that any *other* unexpected runtime exception that might occur within the loop is caught, an error message is printed to `System.err` (including the stack trace for debugging), and the program terminates gracefully (or could potentially attempt to continue, though exiting is safer for unexpected errors).
 *     *   A `finally` block ensures that the `scanner.close()` method is called, releasing the system resource regardless of whether an exception occurred or the loop finished normally.
 * 
 * This solution effectively combines the required Java components (`Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.out`, `System.err`, `try-catch`) into a functional, albeit simple, real-world simulation while adhering to best practices like encapsulation, naming, and basic input/error handling.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.InputMismatchException;

// Represents a single task
class Task {
    private int taskId;
    private String description;

    /**
     * Constructs a new Task.
     * @param taskId The unique identifier for the task.
     * @param description The description of the task.
     */
    public Task(int taskId, String description) {
        this.taskId = taskId;
        this.description = description;
    }

    // --- Getters ---
    public int getTaskId() {
        return taskId;
    }

    public String getDescription() {
        return description;
    }

    @Override
    public String toString() {
        return "[ID: " + taskId + ", Description: " + description + "]";
    }
}

// Manages collections of tasks
class TaskManager {
    private Queue<Task> taskQueue; // Tasks waiting to be processed
    private List<Task> allTasks;   // All tasks ever created
    private int nextTaskId;        // Counter for unique task IDs

    /**
     * Constructs a new TaskManager, initializing task collections.
     */
    public TaskManager() {
        this.taskQueue = new LinkedList<>(); // LinkedList implements Queue
        this.allTasks = new ArrayList<>();   // ArrayList implements List
        this.nextTaskId = 1;                 // Start task IDs from 1
    }

    /**
     * Creates a new task and adds it to both the queue and the list of all tasks.
     * @param description The description of the task.
     * @return The newly created Task object.
     */
    public Task addTask(String description) {
        Task newTask = new Task(nextTaskId++, description);
        taskQueue.offer(newTask); // Add to the end of the queue
        allTasks.add(newTask);    // Add to the list of all tasks
        return newTask;
    }

    /**
     * Removes and returns the next task from the processing queue.
     * Returns null if the queue is empty.
     * @return The next task to process, or null if the queue is empty.
     */
    public Task processNextTask() {
        return taskQueue.poll(); // Retrieves and removes the head of this queue, or returns null if this queue is empty.
    }

    /**
     * Returns the list of all tasks ever created.
     * @return A List containing all tasks.
     */
    public List<Task> getAllTasks() {
        return allTasks;
    }

    /**
     * Returns the queue of tasks currently waiting to be processed.
     * @return A Queue containing pending tasks.
     */
    public Queue<Task> getPendingTasks() {
        return taskQueue;
    }
}

// Main application class
public class TaskSystem {

    /**
     * Displays the main menu options to the user.
     */
    private static void displayMenu() {
        System.out.println("\nTask Management System Menu:");
        System.out.println("1. Add New Task");
        System.out.println("2. Process Next Task");
        System.out.println("3. List All Tasks");
        System.out.println("4. List Pending Tasks");
        System.out.println("5. Exit");
        System.out.print("Enter your choice: ");
    }

    /**
     * Main method to run the Task Management System.
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        TaskManager taskManager = new TaskManager();
        boolean running = true;

        // Class-wide exception handling loop
        try {
            while (running) {
                displayMenu();
                int choice = -1; // Default invalid choice

                // Input validation for menu choice
                try {
                    choice = scanner.nextInt();
                } catch (InputMismatchException e) {
                    System.err.println("Invalid input. Please enter a number.");
                    scanner.next(); // Consume the invalid input
                    continue; // Skip to the next iteration of the while loop
                }

                // Switch statement for menu navigation
                switch (choice) {
                    case 1: // Add New Task
                        System.out.print("Enter task description: ");
                        scanner.nextLine(); // Consume the newline left by nextInt()
                        String description = scanner.nextLine().trim();

                        if (description.isEmpty()) {
                            System.err.println("Task description cannot be empty.");
                        } else {
                            Task addedTask = taskManager.addTask(description);
                            System.out.println("Task added: " + addedTask);
                        }
                        break;

                    case 2: // Process Next Task
                        Task processedTask = taskManager.processNextTask();
                        if (processedTask != null) {
                            System.out.println("Processing task: " + processedTask);
                            System.out.println("Task processed successfully.");
                        } else {
                            System.err.println("No pending tasks to process.");
                        }
                        break;

                    case 3: // List All Tasks
                        List<Task> allTasks = taskManager.getAllTasks();
                        if (allTasks.isEmpty()) {
                            System.out.println("No tasks have been added yet.");
                        } else {
                            System.out.println("All Tasks:");
                            for (Task task : allTasks) {
                                System.out.println(task);
                            }
                        }
                        break;

                    case 4: // List Pending Tasks
                        Queue<Task> pendingTasks = taskManager.getPendingTasks();
                        if (pendingTasks.isEmpty()) {
                            System.out.println("No tasks are currently pending.");
                        } else {
                            System.out.println("Pending Tasks:");
                            // Iterate through the queue without removing elements
                            for (Task task : pendingTasks) {
                                System.out.println(task);
                            }
                        }
                        break;

                    case 5: // Exit
                        System.out.println("Exiting Task Management System. Goodbye!");
                        running = false;
                        break;

                    default: // Invalid choice
                        System.err.println("Invalid choice. Please enter a number between 1 and 5.");
                        break;
                }
            }
        } catch (Exception e) {
            // Catch any unexpected exceptions during the main loop execution
            System.err.println("An unexpected error occurred: " + e.getMessage());
            e.printStackTrace(System.err); // Print stack trace to error stream
        } finally {
            // Ensure the scanner is closed
            scanner.close();
        }
    }
}
