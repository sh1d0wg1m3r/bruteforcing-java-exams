/*
 * Exam Question #609
 * Generated on: 2025-05-12 16:14:13
 * Generated by: Account 2
 * 
 * QUESTION:
 * ## Java Advanced Programming Exam Task: Technical Support Ticket System
 * 
 * **Problem Description:**
 * 
 * You are tasked with developing a simplified Technical Support Ticket Management System. This system will manage incoming support requests, allow support agents to view and resolve tickets, and maintain a history of resolved tickets.
 * 
 * The system should present a menu-driven interface to the user (simulating an administrator or support agent).
 * 
 * **Required Functionality:**
 * 
 * 1.  **Add New Ticket:** Prompt the user for a ticket description and add it to a queue of pending tickets. Assign a unique ID to each ticket.
 * 2.  **View Next Pending Ticket:** Display the details of the ticket at the front of the pending queue without removing it. Handle the case where the queue is empty.
 * 3.  **Resolve Next Pending Ticket:** Remove the ticket from the front of the pending queue, mark it as resolved, and move it to a list of resolved tickets. Handle the case where the queue is empty.
 * 4.  **View All Tickets:** Display all tickets currently in the pending queue and all tickets in the resolved list.
 * 5.  **Exit:** Terminate the application.
 * 
 * **Technical Requirements:**
 * 
 * Your solution must use and demonstrate understanding of the following Java components:
 * 
 * *   `java.util.Queue`: To manage the pending support tickets in a First-In, First-Out (FIFO) manner.
 * *   `java.util.ArrayList`: To store the history of resolved tickets.
 * *   `java.util.List`: Use the `List` interface type when declaring variables that hold `ArrayList` instances where appropriate (e.g., for method parameters or variable declarations).
 * *   `java.util.Scanner`: To read user input from the console.
 * *   `switch` statement: To process the user's menu selection.
 * *   `System.err`: To print error messages (e.g., invalid input, attempting to resolve/view from an empty queue).
 * *   `System.out`: To print normal output (menu, ticket details, success messages).
 * *   Class-wide exception handling with `try-catch` blocks: Implement a `try-catch` block that wraps the main application loop to handle potential runtime errors gracefully and print error information to `System.err`.
 * 
 * **Design and Best Practices Requirements:**
 * 
 * *   Create a `Ticket` class to represent a support ticket with attributes like ID, description, and status. Use proper encapsulation (private fields, public getters).
 * *   Create a main system class (e.g., `SupportSystem`) to manage the queues and lists and handle user interaction.
 * *   Use meaningful variable and method names.
 * *   Include appropriate comments to explain key logic or complex parts.
 * *   Implement basic input validation for the menu selection.
 * *   Provide clear messages to the user for success, errors, and system status (e.g., queue empty).
 * *   Ensure resources like `Scanner` are properly closed.
 * 
 * **Expected Output:**
 * 
 * The program should display a menu, accept user input, and perform the requested actions, printing output to `System.out` and errors to `System.err` as specified.
 * 
 * ```
 * --- Support Ticket System Menu ---
 * 1. Add New Ticket
 * 2. View Next Pending Ticket
 * 3. Resolve Next Pending Ticket
 * 4. View All Tickets
 * 5. Exit
 * Enter your choice:
 * ```
 * (Followed by appropriate output based on user selection)
 * 
 * **Evaluation Criteria:**
 * 
 * *   Correct implementation of all required functionalities.
 * *   Proper and effective use of all specified Java components (`Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.err`, `System.out`, `try-catch`).
 * *   Adherence to design principles and best practices (encapsulation, naming, comments, validation, error handling).
 * *   Code clarity and structure.
 * 
 * Good luck!
 *
 * EXPLANATION:
 * This solution implements a simplified Technical Support Ticket System demonstrating the required Java concepts and best practices.
 * 
 * 1.  **`Ticket` Class:**
 *     *   Represents the data structure for a single ticket.
 *     *   Uses `private` fields (`id`, `description`, `status`) for encapsulation.
 *     *   Provides public getter methods (`getId`, `getDescription`, `getStatus`) to access the data.
 *     *   Includes a `setStatus` method to change the ticket's state when it's resolved.
 *     *   Uses an `enum TicketStatus` for type-safe representation of status (PENDING, RESOLVED).
 *     *   Overrides `toString()` for easy printing of ticket details.
 * 
 * 2.  **`SupportSystem` Class:**
 *     *   This is the main class managing the system's state and logic.
 *     *   **`Queue<Ticket> pendingTickets`**: A `LinkedList` is used here, which implements the `Queue` interface. This is perfect for managing pending tickets as they are processed in a FIFO (First-In, First-Out) order. `add()` is used to enqueue (add to the end), `peek()` to view the head without removing, and `poll()` to dequeue (remove from the head).
 *     *   **`List<Ticket> resolvedTickets`**: An `ArrayList` is used here, declared with the `List` interface type. This stores tickets after they have been resolved, maintaining a history in the order they were resolved. `add()` is used to append to this list.
 *     *   **`Scanner scanner`**: Used to read user input from `System.in`. It's initialized in the constructor.
 *     *   **`nextTicketId`**: A simple counter to assign unique IDs to new tickets.
 *     *   **`displayMenu()`**: A helper method to print the available options to `System.out`.
 *     *   **`addTicket()`**: Prompts for description, creates a `Ticket` object, increments `nextTicketId`, and adds the ticket to the `pendingTickets` queue using `add()`. Includes basic validation for empty description and uses `scanner.nextLine()` carefully after `scanner.nextInt()`.
 *     *   **`viewNextPendingTicket()`**: Uses `pendingTickets.peek()` to look at the next ticket without removing it. Checks if the result is `null` (queue is empty) and prints an appropriate message to `System.out`.
 *     *   **`resolveNextPendingTicket()`**: Uses `pendingTickets.poll()` to remove the next ticket. If `poll()` returns a ticket (queue was not empty), its status is updated, and it's added to the `resolvedTickets` list. Success message is printed to `System.out`. If `poll()` returns `null`, an empty queue message is printed to `System.out`.
 *     *   **`viewAllTickets()`**: Iterates through both the `pendingTickets` queue and the `resolvedTickets` list, printing each ticket's details to `System.out`. Checks for empty collections and prints messages accordingly.
 *     *   **`run()`**: This method contains the main application loop (`while(running)`).
 *         *   **Class-wide `try-catch`**: The entire `while` loop is wrapped in a `try-catch(Exception e)` block. This fulfills the requirement for class-wide exception handling. If any unexpected `RuntimeException` occurs within the loop that isn't caught by more specific blocks, this outer catch will handle it, print an error message to `System.err`, and prevent the program from crashing abruptly.
 *         *   **Inner `try-catch` for `InputMismatchException`**: Inside the loop, there's a specific `try-catch` around `scanner.nextInt()`. This handles the common case where the user enters non-integer input for the menu choice. It prints an error to `System.err` and consumes the invalid input (`scanner.next()`) to avoid an infinite loop.
 *         *   **`switch` statement**: Processes the integer `choice` read from the user, directing execution to the appropriate method (`addTicket`, `viewNextPendingTicket`, etc.). Includes a `default` case for invalid numeric choices, printing an error to `System.err`.
 *         *   **`finally` block**: Ensures `scanner.close()` is called when the `try` block is exited, whether normally or due to an exception. This is crucial for resource management.
 *     *   **`closeScanner()`**: A private helper method to encapsulate the scanner closing logic.
 *     *   **`main(String[] args)`**: The entry point of the application, creates a `SupportSystem` instance and calls its `run()` method.
 * 
 * This solution effectively uses all the required components in a practical context, demonstrates encapsulation, clear naming, basic input validation, specific error handling (`InputMismatchException`, empty queue checks), general error handling (`try-catch` around the loop), and proper resource management (`Scanner` closing). Error messages are directed to `System.err`, while normal output goes to `System.out`.
 */

import java.util.LinkedList;
import java.util.Queue;
import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;
import java.util.InputMismatchException;

// Enum for ticket status
enum TicketStatus {
    PENDING,
    RESOLVED
}

// Represents a single support ticket
class Ticket {
    private int id;
    private String description;
    private TicketStatus status;

    public Ticket(int id, String description) {
        this.id = id;
        this.description = description;
        this.status = TicketStatus.PENDING; // New tickets are always pending
    }

    // Getters
    public int getId() {
        return id;
    }

    public String getDescription() {
        return description;
    }

    public TicketStatus getStatus() {
        return status;
    }

    // Method to update status (used when resolving)
    public void setStatus(TicketStatus status) {
        this.status = status;
    }

    @Override
    public String toString() {
        return "Ticket [ID=" + id + ", Description='" + description + "', Status=" + status + "]";
    }
}

// Main class for the Support Ticket System
public class SupportSystem {
    // Use Queue for pending tickets (FIFO)
    private Queue<Ticket> pendingTickets;
    // Use List (implemented by ArrayList) for resolved tickets history
    private List<Ticket> resolvedTickets;
    private int nextTicketId;
    private Scanner scanner;

    public SupportSystem() {
        // LinkedList is a common implementation of Queue
        this.pendingTickets = new LinkedList<>();
        // ArrayList is used to store resolved tickets
        this.resolvedTickets = new ArrayList<>();
        this.nextTicketId = 1; // Start ticket IDs from 1
        this.scanner = new Scanner(System.in);
    }

    // Displays the main menu
    private void displayMenu() {
        System.out.println("\n--- Support Ticket System Menu ---");
        System.out.println("1. Add New Ticket");
        System.out.println("2. View Next Pending Ticket");
        System.out.println("3. Resolve Next Pending Ticket");
        System.out.println("4. View All Tickets");
        System.out.println("5. Exit");
        System.out.print("Enter your choice: ");
    }

    // Adds a new ticket to the pending queue
    private void addTicket() {
        System.out.print("Enter ticket description: ");
        // Consume the newline character left by previous input if any
        scanner.nextLine(); // Important if previous input was nextInt()
        String description = scanner.nextLine();
        if (description == null || description.trim().isEmpty()) {
             System.err.println("Error: Ticket description cannot be empty.");
             return;
        }

        Ticket newTicket = new Ticket(nextTicketId++, description);
        pendingTickets.add(newTicket); // Add to the end of the queue
        System.out.println("Ticket #" + newTicket.getId() + " added successfully.");
    }

    // Views the next ticket in the pending queue without removing it
    private void viewNextPendingTicket() {
        Ticket nextTicket = pendingTickets.peek(); // Peek at the front of the queue
        if (nextTicket == null) {
            System.out.println("No pending tickets in the queue.");
        } else {
            System.out.println("Next Pending Ticket: " + nextTicket);
        }
    }

    // Resolves the next ticket in the pending queue and moves it to resolved list
    private void resolveNextPendingTicket() {
        Ticket resolvedTicket = pendingTickets.poll(); // Remove from the front of the queue
        if (resolvedTicket == null) {
            System.out.println("No pending tickets to resolve.");
        } else {
            resolvedTicket.setStatus(TicketStatus.RESOLVED); // Update status
            resolvedTickets.add(resolvedTicket); // Add to the resolved list
            System.out.println("Ticket #" + resolvedTicket.getId() + " resolved and moved to history.");
        }
    }

    // Views all tickets (pending and resolved)
    private void viewAllTickets() {
        System.out.println("\n--- Pending Tickets ---");
        if (pendingTickets.isEmpty()) {
            System.out.println("No pending tickets.");
        } else {
            // Iterate through the queue (order is preserved)
            for (Ticket ticket : pendingTickets) {
                System.out.println(ticket);
            }
        }

        System.out.println("\n--- Resolved Tickets ---");
        if (resolvedTickets.isEmpty()) {
            System.out.println("No resolved tickets.");
        } else {
            // Iterate through the list
            for (Ticket ticket : resolvedTickets) {
                System.out.println(ticket);
            }
        }
    }

    // Runs the main application loop
    public void run() {
        int choice = 0;
        boolean running = true;

        // Class-wide try-catch block wrapping the main operational loop
        try {
            while (running) {
                displayMenu();
                try {
                    // Read user choice, handle non-integer input specifically
                    choice = scanner.nextInt();

                    switch (choice) {
                        case 1:
                            addTicket();
                            break;
                        case 2:
                            viewNextPendingTicket();
                            break;
                        case 3:
                            resolveNextPendingTicket();
                            break;
                        case 4:
                            viewAllTickets();
                            break;
                        case 5:
                            System.out.println("Exiting Support Ticket System. Goodbye!");
                            running = false;
                            break;
                        default:
                            // Handle choices outside the valid range
                            System.err.println("Invalid choice. Please enter a number between 1 and 5.");
                    }
                } catch (InputMismatchException e) {
                    // Catch non-integer input specifically
                    System.err.println("Invalid input. Please enter a number corresponding to the menu option.");
                    scanner.next(); // Consume the invalid input to prevent infinite loop
                }
                // No need for a general catch here if specific exceptions are handled above,
                // but a broader catch could be added for unexpected runtime errors.
                // For this exercise, the outer try-catch serves the 'class-wide' requirement.
            }
        } catch (Exception e) {
            // This broader catch handles any other unexpected exceptions during the system's operation
            System.err.println("An unexpected error occurred: " + e.getMessage());
            // Optionally print stack trace for debugging: e.printStackTrace(System.err);
        } finally {
            // Ensure the scanner is closed when the application finishes or crashes
            closeScanner();
        }
    }

    // Closes the scanner resource
    private void closeScanner() {
        if (scanner != null) {
            scanner.close();
            System.out.println("Scanner closed."); // Optional confirmation
        }
    }

    // Main method to start the application
    public static void main(String[] args) {
        SupportSystem system = new SupportSystem();
        system.run();
    }
}
