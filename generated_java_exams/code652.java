/*
 * Exam Question #652
 * Generated on: 2025-05-12 16:20:13
 * Generated by: Account 3
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Software Build and Deployment System
 * 
 * **Scenario:**
 * 
 * You are tasked with developing a simplified system to manage software build requests. Build requests are submitted and added to a queue for processing. The system processes these requests one by one in the order they were submitted. After a request is processed (either successfully or failing), it is moved to a history log. The system should allow users to add new build requests, process the next pending request, view pending requests, and view the history of processed requests via a command-line interface.
 * 
 * **Requirements:**
 * 
 * Implement a Java program that fulfills the following requirements:
 * 
 * 1.  **BuildRequest Class:**
 *     *   Create a class `BuildRequest` with private fields for `projectId` (String), `version` (String), and `status` (an enum `BuildStatus`).
 *     *   The `BuildStatus` enum should have values like `PENDING`, `PROCESSING`, `SUCCESS`, `FAILURE`.
 *     *   Include a constructor to initialize `projectId` and `version`, setting the initial status to `PENDING`.
 *     *   Provide public getter methods for all fields.
 *     *   Provide a public method `setStatus(BuildStatus status)` to update the status.
 *     *   Override the `toString()` method to provide a user-friendly representation of the build request (e.g., "ProjectX v1.0 [PENDING]").
 * 
 * 2.  **BuildManager Class:**
 *     *   Create a class `BuildManager` to manage the build requests.
 *     *   It must have a private field `pendingBuilds` of type `Queue<BuildRequest>` to store requests awaiting processing.
 *     *   It must have a private field `processedBuilds` of type `List<BuildRequest>` (implemented using `ArrayList`) to store requests after processing.
 *     *   Implement a public method `addRequest(String projectId, String version)`:
 *         *   Validates that `projectId` and `version` are not null or empty. If invalid, print an error to `System.err` and do not add the request.
 *         *   Creates a new `BuildRequest` object.
 *         *   Adds the new request to the `pendingBuilds` queue.
 *         *   Prints a confirmation message to `System.out`.
 *     *   Implement a public method `processNextRequest()`:
 *         *   Checks if the `pendingBuilds` queue is empty. If so, throw an `IllegalStateException` with a descriptive message.
 *         *   Retrieves the next request from the `pendingBuilds` queue (using `poll()`).
 *         *   Sets the status of the retrieved request to `PROCESSING`.
 *         *   Simulates a build process: Randomly (e.g., 70% chance) set the status to `SUCCESS`, otherwise set to `FAILURE`.
 *         *   Adds the processed request to the `processedBuilds` list.
 *         *   Prints the result of the processing (success or failure) to `System.out`.
 *     *   Implement a public method `getPendingRequests()`:
 *         *   Returns a `List<BuildRequest>` containing all requests currently in the `pendingBuilds` queue. The returned list should be a snapshot and not allow modification of the original queue.
 *     *   Implement a public method `getProcessedRequests()`:
 *         *   Returns the `processedBuilds` list. The returned list should be a snapshot or a copy to prevent external modification of the internal list.
 * 
 * 3.  **Main Application Class (e.g., `BuildSystem`):**
 *     *   Create a class with a `main` method to run the application.
 *     *   Instantiate `BuildManager` and `Scanner`.
 *     *   Implement a command-line menu using a loop and a `switch` statement with the following options:
 *         1.  Add Build Request
 *         2.  Process Next Build
 *         3.  View Pending Builds
 *         4.  View Processed Builds
 *         5.  Exit
 *     *   Use `Scanner` to read user input for menu choices and build request details.
 *     *   Use `System.out` for displaying the menu, prompts, and successful output.
 *     *   Use `System.err` for displaying error messages (e.g., invalid input, cannot process).
 *     *   Implement robust input validation for the menu choice (handle non-integer input and invalid options).
 *     *   Implement class-wide exception handling using a `try-catch` block to catch potential exceptions during the program execution (e.g., the `IllegalStateException` from `processNextRequest`, or unexpected issues). Print an informative error message to `System.err` if an exception occurs.
 *     *   Ensure the `Scanner` is closed properly.
 * 
 * **Required Java Components:**
 * 
 * Your solution *must* explicitly use and demonstrate the functionality of:
 * 
 * *   `java.util.Queue`
 * *   `java.util.ArrayList`
 * *   `java.util.List` (used as the type for a variable/field/return type)
 * *   `java.util.Scanner`
 * *   `switch` statement
 * *   `System.err`
 * *   `System.out`
 * *   `try-catch` blocks (at least one encompassing a significant part of the program flow)
 * 
 * **Best Practices:**
 * 
 * *   Follow proper encapsulation (private fields, public methods).
 * *   Use meaningful variable and method names.
 * *   Include appropriate comments and documentation (e.g., Javadoc).
 * *   Implement input validation where necessary.
 * *   Handle errors gracefully (using `System.err`, exceptions).
 * *   Maintain a clean code structure (separate classes).
 * 
 * **Expected Output:**
 * 
 * The program should present a menu, accept user input, and display information or error messages based on the chosen option. Output for listing requests should clearly show the project, version, and status. Processing output should indicate which request was processed and its final status.
 * 
 * Example Interaction Snippet:
 * 
 * ```
 * Software Build System Menu:
 * 1. Add Build Request
 * 2. Process Next Build
 * 3. View Pending Builds
 * 4. View Processed Builds
 * 5. Exit
 * Enter your choice: 1
 * Enter Project ID: ProjectA
 * Enter Version: 1.0
 * Build request added: ProjectA v1.0 [PENDING]
 * 
 * Software Build System Menu:
 * ...
 * Enter your choice: 3
 * Pending Builds:
 * - ProjectA v1.0 [PENDING]
 * 
 * Software Build System Menu:
 * ...
 * Enter your choice: 2
 * Processing build: ProjectA v1.0 [PROCESSING]
 * Build ProjectA v1.0 finished with status: SUCCESS
 * 
 * Software Build System Menu:
 * ...
 * Enter your choice: 4
 * Processed Builds:
 * - ProjectA v1.0 [SUCCESS]
 * 
 * Software Build System Menu:
 * ...
 * Enter your choice: 2
 * Error: No pending builds to process.
 * 
 * Software Build System Menu:
 * ...
 * Enter your choice: 6
 * Error: Invalid menu choice. Please enter a number between 1 and 5.
 * 
 * Software Build System Menu:
 * ...
 * Enter your choice: abc
 * Error: Invalid input. Please enter a number.
 * 
 * Software Build System Menu:
 * ...
 * Enter your choice: 5
 * Exiting Build System.
 * ```
 * 
 * Your code should compile and run, demonstrating all specified requirements.
 *
 * EXPLANATION:
 * This solution implements a simplified software build management system using the required Java components and best practices.
 * 
 * 1.  **BuildRequest Enum and Class:**
 *     *   `BuildStatus` enum clearly defines the possible states of a build request, improving readability and preventing invalid status values.
 *     *   `BuildRequest` class encapsulates the data for a single build request (`projectId`, `version`, `status`). Fields are `private`, and public getters are provided. `setStatus` allows state transitions. The constructor includes basic input validation, throwing `IllegalArgumentException` for null/empty project/version. The `toString()` method provides a convenient string representation for printing.
 * 
 * 2.  **BuildManager Class:**
 *     *   This class acts as the core manager.
 *     *   `pendingBuilds`: Declared as `Queue<BuildRequest>` and instantiated as `LinkedList<BuildRequest>`. `LinkedList` is a common implementation of `Queue` in Java, providing FIFO (First-In, First-Out) behavior suitable for a processing queue.
 *     *   `processedBuilds`: Declared as `List<BuildRequest>` and instantiated as `ArrayList<BuildRequest>`. `ArrayList` is a common implementation of `List`, suitable for storing a dynamic collection of processed items in order.
 *     *   `addRequest`: Takes project ID and version, validates them, creates a `BuildRequest`, and adds it to the `pendingBuilds` queue using `offer()` (which is generally preferred over `add()` for queues as it returns `false` if the element cannot be added, though `LinkedList`'s `offer` won't fail unless memory is exhausted). It includes a `try-catch` block specifically for the `IllegalArgumentException` from the `BuildRequest` constructor, printing an error to `System.err`.
 *     *   `processNextRequest`:
 *         *   Uses `peek()` to check if the queue is empty *before* attempting to `poll()`.
 *         *   If empty, it throws an `IllegalStateException` as required, indicating that the operation cannot be performed in the current state. This demonstrates appropriate use of standard exceptions for state-related errors.
 *         *   If not empty, `poll()` retrieves and removes the head of the queue.
 *         *   The status is updated to `PROCESSING`.
 *         *   `ThreadLocalRandom` is used to simulate a random outcome (success or failure).
 *         *   `Thread.sleep(500)` is included to simulate a delay in processing.
 *         *   The status is updated to `SUCCESS` or `FAILURE`.
 *         *   Crucially, the processed request is added to the `processedBuilds` list.
 *         *   A `finally` block ensures the request is added to the processed list even if an `InterruptedException` occurs during the simulated sleep.
 *         *   The method prints the result to `System.out`.
 *     *   `getPendingRequests` and `getProcessedRequests`: These methods return *new* `ArrayList` instances populated with the elements from the internal collections. This is a best practice to prevent external code from directly modifying the internal state (the queue or list) of the `BuildManager`. They fulfill the requirement of returning a `List`.
 * 
 * 3.  **BuildSystem Class (Main Application):**
 *     *   The `main` method orchestrates the application flow.
 *     *   `Scanner` is used to read input from `System.in`.
 *     *   A `while(running)` loop keeps the application active until the user chooses to exit.
 *     *   The main logic inside the loop, including reading input and the `switch` statement, is wrapped in a `try-catch(Exception e)` block. This provides class-wide exception handling, catching any unexpected runtime errors that might occur and printing an error message to `System.err` before potentially exiting or continuing the loop (depending on the error).
 *     *   Input validation for the menu choice is done using `scanner.hasNextInt()` and consuming invalid input with `scanner.next()` to prevent infinite loops on non-integer input.
 *     *   A `switch` statement is used to handle the different menu options, directing the flow to the appropriate `BuildManager` methods or application logic.
 *     *   Specific `try-catch` blocks are used within the `switch` cases where specific exceptions are expected (e.g., catching `IllegalStateException` from `processNextRequest` to provide a user-friendly error message via `System.err` instead of crashing).
 *     *   `System.out` is used for displaying the menu, prompts, confirmation messages, and successful results.
 *     *   `System.err` is used exclusively for error messages (invalid input, cannot process, unexpected system errors).
 *     *   A `finally` block ensures the `scanner` is closed when the `try` block is exited (either normally or due to an exception).
 * 
 * This solution effectively demonstrates the required Java components (`Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.err`, `System.out`, `try-catch`) within a practical scenario, incorporating best practices like encapsulation, input validation, and error handling.
 */

import java.util.ArrayList;
import java.util.LinkedList; // LinkedList implements Queue
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.concurrent.ThreadLocalRandom; // For simulating random success/failure

// 1. BuildStatus Enum
enum BuildStatus {
    PENDING, PROCESSING, SUCCESS, FAILURE
}

// 2. BuildRequest Class
/**
 * Represents a software build request with project details and status.
 */
class BuildRequest {
    private String projectId;
    private String version;
    private BuildStatus status;

    /**
     * Constructs a new BuildRequest.
     *
     * @param projectId The ID of the project.
     * @param version   The version of the build.
     */
    public BuildRequest(String projectId, String version) {
        if (projectId == null || projectId.trim().isEmpty() || version == null || version.trim().isEmpty()) {
            throw new IllegalArgumentException("Project ID and Version cannot be null or empty.");
        }
        this.projectId = projectId.trim();
        this.version = version.trim();
        this.status = BuildStatus.PENDING;
    }

    // Getters
    public String getProjectId() {
        return projectId;
    }

    public String getVersion() {
        return version;
    }

    public BuildStatus getStatus() {
        return status;
    }

    /**
     * Sets the status of the build request.
     *
     * @param status The new status.
     */
    public void setStatus(BuildStatus status) {
        this.status = status;
    }

    @Override
    public String toString() {
        return projectId + " v" + version + " [" + status + "]";
    }
}

// 3. BuildManager Class
/**
 * Manages the queue of pending build requests and the history of processed builds.
 */
class BuildManager {
    private Queue<BuildRequest> pendingBuilds;
    private List<BuildRequest> processedBuilds;

    /**
     * Constructs a new BuildManager, initializing the collections.
     */
    public BuildManager() {
        this.pendingBuilds = new LinkedList<>(); // LinkedList implements Queue
        this.processedBuilds = new ArrayList<>(); // ArrayList implements List
    }

    /**
     * Adds a new build request to the pending queue.
     *
     * @param projectId The ID of the project.
     * @param version   The version of the build.
     */
    public void addRequest(String projectId, String version) {
        try {
            BuildRequest request = new BuildRequest(projectId, version);
            if (pendingBuilds.offer(request)) { // offer is safer than add
                System.out.println("Build request added: " + request);
            } else {
                // This case is unlikely with LinkedList but good practice
                System.err.println("Error: Failed to add build request to the queue.");
            }
        } catch (IllegalArgumentException e) {
            System.err.println("Error adding request: " + e.getMessage());
        } catch (Exception e) {
            // Catch any other unexpected errors during request creation/addition
            System.err.println("An unexpected error occurred while adding the request: " + e.getMessage());
        }
    }

    /**
     * Processes the next build request from the pending queue.
     * Moves the processed request to the history list.
     *
     * @throws IllegalStateException if there are no pending builds to process.
     */
    public void processNextRequest() throws IllegalStateException {
        BuildRequest request = pendingBuilds.peek(); // Peek first to check if null
        if (request == null) {
            throw new IllegalStateException("No pending builds to process.");
        }

        // Retrieve and remove from queue
        request = pendingBuilds.poll();

        System.out.println("Processing build: " + request);
        request.setStatus(BuildStatus.PROCESSING);

        // Simulate build process success or failure (e.g., 70% success rate)
        boolean success = ThreadLocalRandom.current().nextDouble() < 0.7; // 0.0 to 1.0

        try {
            // Simulate some work
            Thread.sleep(500); // Pause for a moment to simulate work

            if (success) {
                request.setStatus(BuildStatus.SUCCESS);
                System.out.println("Build " + request.getProjectId() + " v" + request.getVersion() + " finished with status: SUCCESS");
            } else {
                request.setStatus(BuildStatus.FAILURE);
                System.out.println("Build " + request.getProjectId() + " v" + request.getVersion() + " finished with status: FAILURE");
                // Optionally, add a failure reason
            }
        } catch (InterruptedException e) {
            // Handle interruption during sleep
            System.err.println("Processing interrupted: " + e.getMessage());
            request.setStatus(BuildStatus.FAILURE); // Assume failure on interruption
        } finally {
             // Ensure request is added to processed list regardless of success/failure/interruption
             processedBuilds.add(request);
        }
    }

    /**
     * Gets a list of all pending build requests.
     * Returns a new list to protect the internal queue.
     *
     * @return A list of pending build requests.
     */
    public List<BuildRequest> getPendingRequests() {
        // Return a new ArrayList containing elements from the queue
        return new ArrayList<>(pendingBuilds);
    }

    /**
     * Gets a list of all processed build requests.
     * Returns a new list to protect the internal list.
     *
     * @return A list of processed build requests.
     */
    public List<BuildRequest> getProcessedRequests() {
        // Return a new ArrayList containing elements from the processed list
        return new ArrayList<>(processedBuilds);
    }
}

// 4. Main Application Class
/**
 * Main class for the Software Build System.
 * Provides a command-line interface for managing build requests.
 */
public class BuildSystem {

    public static void main(String[] args) {
        BuildManager buildManager = new BuildManager();
        Scanner scanner = new Scanner(System.in);
        boolean running = true;

        // Class-wide exception handling (covers the main loop)
        try {
            while (running) {
                printMenu();
                int choice = -1; // Default invalid choice

                // Input validation for menu choice
                System.out.print("Enter your choice: ");
                if (scanner.hasNextInt()) {
                    choice = scanner.nextInt();
                } else {
                    System.err.println("Error: Invalid input. Please enter a number.");
                    scanner.next(); // Consume the invalid input
                    continue; // Skip the rest of the loop iteration
                }
                scanner.nextLine(); // Consume the newline character after reading the integer

                // Switch statement for menu navigation
                switch (choice) {
                    case 1:
                        System.out.print("Enter Project ID: ");
                        String projectId = scanner.nextLine();
                        System.out.print("Enter Version: ");
                        String version = scanner.nextLine();
                        buildManager.addRequest(projectId, version);
                        break;
                    case 2:
                        try {
                            buildManager.processNextRequest();
                        } catch (IllegalStateException e) {
                            System.err.println("Error: " + e.getMessage());
                        }
                        break;
                    case 3:
                        List<BuildRequest> pending = buildManager.getPendingRequests();
                        System.out.println("\n--- Pending Builds ---");
                        if (pending.isEmpty()) {
                            System.out.println("No pending builds.");
                        } else {
                            for (int i = 0; i < pending.size(); i++) {
                                System.out.println((i + 1) + ". " + pending.get(i));
                            }
                        }
                        System.out.println("----------------------\n");
                        break;
                    case 4:
                        List<BuildRequest> processed = buildManager.getProcessedRequests();
                        System.out.println("\n--- Processed Builds History ---");
                        if (processed.isEmpty()) {
                            System.out.println("No processed builds history.");
                        } else {
                            for (int i = 0; i < processed.size(); i++) {
                                System.out.println((i + 1) + ". " + processed.get(i));
                            }
                        }
                        System.out.println("------------------------------\n");
                        break;
                    case 5:
                        running = false;
                        System.out.println("Exiting Build System.");
                        break;
                    default:
                        System.err.println("Error: Invalid menu choice. Please enter a number between 1 and 5.");
                }
            }
        } catch (Exception e) {
            // Catch any unexpected exceptions during the main program flow
            System.err.println("\nAn unexpected system error occurred: " + e.getMessage());
            e.printStackTrace(); // Print stack trace for debugging unexpected errors
        } finally {
            // Ensure scanner is closed
            if (scanner != null) {
                scanner.close();
            }
        }
    }

    /**
     * Prints the main menu options to the console.
     */
    private static void printMenu() {
        System.out.println("Software Build System Menu:");
        System.out.println("1. Add Build Request");
        System.out.println("2. Process Next Build");
        System.out.println("3. View Pending Builds");
        System.out.println("4. View Processed Builds");
        System.out.println("5. Exit");
    }
}
