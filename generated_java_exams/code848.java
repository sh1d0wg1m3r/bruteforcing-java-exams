/*
 * Exam Question #848
 * Generated on: 2025-05-12 16:49:58
 * Generated by: Account 5
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Report Processing System
 * 
 * **Scenario:**
 * 
 * You are tasked with developing a simple command-line application for an internal company system that manages reports submitted by employees. Reports are first placed into a queue for processing. Once processed, they are moved to a list of completed reports. Your system should allow users to submit new reports, process the next available report, and view both pending and processed reports.
 * 
 * **Requirements:**
 * 
 * Implement a Java application that fulfills the following requirements:
 * 
 * 1.  **Data Structures:**
 *     *   Use `java.util.Queue` to store reports that are awaiting processing.
 *     *   Use `java.util.ArrayList` to store reports that have been processed.
 *     *   When declaring variables that hold the processed reports, use the `java.util.List` interface type.
 * 
 * 2.  **Classes:**
 *     *   Create a `Report` class to represent a single report. It should contain:
 *         *   A unique integer ID.
 *         *   A `String` for the report type (e.g., "Bug", "Feature Request", "Urgent Issue").
 *         *   A `String` for the report description.
 *         *   An appropriate type (e.g., an `enum`) to represent the report's status (e.g., PENDING, PROCESSED).
 *         *   Appropriate constructors, getters, and a `toString()` method for easy printing.
 *     *   Create a `ReportProcessingSystem` class to manage the report queues and lists. This class should contain:
 *         *   The `Queue` of pending reports.
 *         *   The `List` of processed reports.
 *         *   A mechanism to generate unique report IDs.
 *         *   Methods for:
 *             *   Submitting a new report (adds to the pending queue).
 *             *   Processing the next report (takes from the queue, updates status, adds to processed list).
 *             *   Retrieving the list of pending reports for viewing.
 *             *   Retrieving the list of processed reports for viewing.
 *         *   Adhere to principles of encapsulation (private fields, public methods).
 * 
 * 3.  **User Interface:**
 *     *   Use `java.util.Scanner` to read user input from the console.
 *     *   Present a menu of options to the user:
 *         1.  Submit New Report
 *         2.  Process Next Report
 *         3.  View Pending Reports
 *         4.  View Processed Reports
 *         5.  Exit
 *     *   Use a `switch` statement to handle the user's menu choice.
 *     *   Print normal output (menu, prompts, success messages, report details) to `System.out`.
 *     *   Print error messages (e.g., invalid input, no reports to process) to `System.err`.
 * 
 * 4.  **Error Handling:**
 *     *   Implement input validation for the user's menu choice (ensure it's an integer within the valid range). Handle `InputMismatchException` gracefully.
 *     *   Implement a check when processing the next report: if the pending queue is empty, inform the user via `System.out` and do nothing.
 *     *   Implement **class-wide exception handling** using `try-catch` blocks in your main application logic (e.g., wrapping the main menu loop) to catch and report any unexpected runtime errors to `System.err`.
 * 
 * 5.  **Best Practices:**
 *     *   Use meaningful variable and method names.
 *     *   Include appropriate comments and basic documentation (e.g., Javadoc-style comments for classes and public methods).
 *     *   Structure your code logically across classes.
 * 
 * **Expected Output:**
 * 
 * The application should run continuously until the user chooses to exit. It should display the menu, prompt for input, and provide informative feedback or error messages based on the user's actions.
 * 
 * Example interaction snippets:
 * 
 * ```
 * --- Report Processing System Menu ---
 * ... menu options ...
 * Enter your choice: 1
 * --- Submit New Report ---
 * Enter report type: Bug
 * Enter report description: App crashes on login
 * Report submitted successfully. ID: 1
 * 
 * --- Report Processing System Menu ---
 * ... menu options ...
 * Enter your choice: 3
 * --- Pending Reports ---
 * Report [ID=1, Type='Bug', Status=PENDING, Description='App crashes on login']
 * 
 * --- Report Processing System Menu ---
 * ... menu options ...
 * Enter your choice: 2
 * --- Processing Next Report ---
 * Report ID 1 processed.
 * 
 * --- Report Processing System Menu ---
 * ... menu options ...
 * Enter your choice: 3
 * --- Pending Reports ---
 * No reports currently pending.
 * 
 * --- Report Processing System Menu ---
 * ... menu options ...
 * Enter your choice: 4
 * --- Processed Reports ---
 * Report [ID=1, Type='Bug', Status=PROCESSED, Description='App crashes on login']
 * 
 * --- Report Processing System Menu ---
 * ... menu options ...
 * Enter your choice: invalid
 * Invalid input. Please enter a number.
 * ... menu reappears ...
 * 
 * --- Report Processing System Menu ---
 * ... menu options ...
 * Enter your choice: 5
 * Exiting Report Processing System. Goodbye!
 * Scanner closed.
 * ```
 * 
 * Your solution should compile and run as a single Java application.
 * 
 * **Deliverables:**
 * 
 * Provide the complete Java source code for the application.
 *
 * EXPLANATION:
 * This solution implements a simple Report Processing System command-line application using the specified Java components and best practices.
 * 
 * **Key Concepts Demonstrated:**
 * 
 * 1.  **Object-Oriented Design:** The problem is broken down into logical classes (`Report`, `ReportProcessingSystem`) with encapsulated data and defined behaviors.
 * 2.  **Data Structures (`Queue`, `List`, `ArrayList`):**
 *     *   A `Queue` (`LinkedList` implementation) is used for `pendingReports`. This correctly models the requirement that reports are processed in the order they are submitted (FIFO - First-In, First-Out). `offer()` is used for adding and `poll()` for removing, which are standard `Queue` operations suitable for managing tasks.
 *     *   An `ArrayList` is used for `processedReports`. `ArrayList` is a suitable choice for storing processed items where order might matter (order of processing) and random access is possible, although not strictly needed in this simple example.
 *     *   The `List` interface is used for declaring the `processedReports` field and for the return types of `getPendingReports()` and `getProcessedReports()`. This demonstrates coding to an interface, promoting flexibility and abstraction.
 * 3.  **User Input (`Scanner`):** The `Scanner` class is used in the `main` method to read integer choices and string inputs from the console, facilitating user interaction.
 * 4.  **Control Flow (`switch`):** A `switch` statement is effectively used in the `main` loop to direct the program flow based on the user's numeric menu selection, providing a clear and readable way to handle multiple options.
 * 5.  **Output Streams (`System.out`, `System.err`):**
 *     *   `System.out.println()` is used for displaying the menu, prompts, successful action messages, and the contents of the report lists, representing standard application output.
 *     *   `System.err.println()` is used specifically for displaying error messages, such as invalid user input or unexpected system errors, adhering to the convention of separating error output.
 * 6.  **Exception Handling (`try-catch`):**
 *     *   **Input Validation:** A specific `try-catch (InputMismatchException e)` block is used around `scanner.nextInt()` to catch cases where the user enters non-integer input for the menu choice. This prevents the program from crashing due to invalid input format and prompts the user to try again. `scanner.nextLine()` is used within the catch block to consume the invalid input and prevent an infinite loop.
 *     *   **Logical Error Handling:** The `processNextReport()` method checks if `pendingReports.poll()` returns `null` (indicating an empty queue) and prints an informative message instead of throwing an exception.
 *     *   **Class-wide Handling:** A broad `try { ... } catch (Exception e) { ... }` block is placed around the entire `while (running)` loop in the `main` method. This serves as a catch-all for any unexpected runtime exceptions that might occur anywhere within the core application logic, ensuring the program doesn't terminate abruptly and logs the error to `System.err` before attempting cleanup in the `finally` block.
 * 7.  **Best Practices Implementation:**
 *     *   **Encapsulation:** Fields in `Report` and `ReportProcessingSystem` are `private`, with access provided through `public` methods (getters, setters, action methods).
 *     *   **Meaningful Names:** Variable names (e.g., `pendingReports`, `reportToProcess`, `choice`) and method names (e.g., `submitReport`, `processNextReport`, `printMenu`) clearly indicate their purpose.
 *     *   **Comments/Documentation:** Javadoc comments explain the purpose of classes and methods, while inline comments clarify specific logic points.
 *     *   **Input Validation:** Basic checks are included for empty strings in `submitReport` and for integer input in the main loop.
 *     *   **Code Structure:** The code is organized into distinct classes, separating concerns: `Report` (data model), `ReportProcessingSystem` (business logic/state management), and `ExamQuestion` (user interface/application entry).
 *     *   **Resource Management:** The `finally` block ensures that the `Scanner` object is closed when the application loop terminates, releasing system resources.
 * 
 * This solution effectively integrates all required components into a functional system, demonstrating a solid understanding of core Java programming concepts, data structures, object-oriented design, and error handling.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.InputMismatchException; // Specific exception for Scanner

// Enum to represent the status of a report
enum ReportStatus {
    PENDING, PROCESSED
}

/**
 * Represents a single report in the system.
 */
class Report {
    private int id;
    private String type;
    private String description;
    private ReportStatus status;

    /**
     * Constructs a new Report with initial status PENDING.
     *
     * @param id The unique identifier for the report.
     * @param type The category or type of the report.
     * @param description A detailed description of the report issue or request.
     */
    public Report(int id, String type, String description) {
        this.id = id;
        this.type = type;
        this.description = description;
        this.status = ReportStatus.PENDING; // Reports are pending upon creation
    }

    // --- Getters ---
    public int getId() {
        return id;
    }

    public String getType() {
        return type;
    }

    public String getDescription() {
        return description;
    }

    public ReportStatus getStatus() {
        return status;
    }

    /**
     * Sets the status of the report. Used when processing.
     *
     * @param status The new status for the report.
     */
    public void setStatus(ReportStatus status) {
        this.status = status;
    }

    /**
     * Provides a string representation of the Report object.
     *
     * @return A formatted string detailing the report's properties.
     */
    @Override
    public String toString() {
        return "Report [ID=" + id + ", Type='" + type + "', Status=" + status + ", Description='" + description + "']";
    }
}

/**
 * Manages the lifecycle of reports, including submission, processing,
 * and storage of pending and processed reports.
 */
class ReportProcessingSystem {
    // Queue to hold reports awaiting processing (FIFO order)
    private Queue<Report> pendingReports;
    // List to hold reports that have been processed
    private List<Report> processedReports;

    private int reportCounter; // Counter to generate sequential unique report IDs

    /**
     * Constructs a new ReportProcessingSystem, initializing the data structures.
     */
    public ReportProcessingSystem() {
        // LinkedList is a common implementation of the Queue interface
        this.pendingReports = new LinkedList<>();
        // ArrayList is a common implementation of the List interface
        this.processedReports = new ArrayList<>();
        this.reportCounter = 0; // Initialize report ID counter
    }

    /**
     * Submits a new report to the system by adding it to the pending queue.
     * Assigns a unique ID to the new report.
     *
     * @param type The type of the report.
     * @param description The description of the report.
     */
    public void submitReport(String type, String description) {
        // Basic validation for input strings
        if (type == null || type.trim().isEmpty() || description == null || description.trim().isEmpty()) {
            System.err.println("Error: Report type and description cannot be empty.");
            return; // Exit method if input is invalid
        }

        // Generate the next unique ID
        int newId = ++reportCounter;
        // Create a new Report object
        Report newReport = new Report(newId, type.trim(), description.trim());

        // Add the new report to the end of the pending queue
        pendingReports.offer(newReport); // offer() is safer than add() for capacity-constrained queues

        System.out.println("Report submitted successfully. ID: " + newId);
    }

    /**
     * Processes the next report available in the pending queue.
     * The oldest report (based on submission order) is processed.
     * If the queue is empty, a message is printed.
     *
     * @return The Report object that was processed, or null if the queue was empty.
     */
    public Report processNextReport() {
        // Retrieve and remove the head of the queue. Returns null if queue is empty.
        Report reportToProcess = pendingReports.poll();

        if (reportToProcess != null) {
            // Update the status of the retrieved report
            reportToProcess.setStatus(ReportStatus.PROCESSED);
            // Add the processed report to the list of processed reports
            processedReports.add(reportToProcess);
            System.out.println("Report ID " + reportToProcess.getId() + " processed.");
            return reportToProcess; // Return the report that was processed
        } else {
            // Inform the user if there are no reports to process
            System.out.println("No pending reports to process.");
            return null; // Indicate that no report was processed
        }
    }

    /**
     * Retrieves a list of all reports currently in the pending queue.
     * Returns a copy to prevent external modification of the internal queue.
     *
     * @return A List containing the pending reports.
     */
    public List<Report> getPendingReports() {
        // Create and return a new ArrayList populated with elements from the queue.
        // This uses the List interface as the return type.
        return new ArrayList<>(pendingReports);
    }

    /**
     * Retrieves a list of all reports that have been processed.
     * Returns the internal list.
     *
     * @return The List containing the processed reports.
     */
    public List<Report> getProcessedReports() {
        // Return the internal list directly.
        // For maximum robustness, one might return Collections.unmodifiableList(processedReports);
        // Using the List interface as the return type.
        return processedReports;
    }
}

/**
 * Main class for the Report Processing System application.
 * Handles user interaction via a command-line interface.
 */
public class ExamQuestion { // Renamed from a generic name to match potential exam context

    /**
     * The main entry point for the Report Processing System application.
     * Manages the main application loop, menu display, user input,
     * and delegates tasks to the ReportProcessingSystem.
     * Implements class-wide exception handling.
     *
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        // Scanner for reading user input from the console
        Scanner scanner = new Scanner(System.in);
        // Instance of the system that manages reports
        ReportProcessingSystem system = new ReportProcessingSystem();
        // Flag to control the main application loop
        boolean running = true;

        // --- Class-wide exception handling block ---
        // This try-catch block wraps the core application loop
        // to catch any unexpected runtime exceptions and prevent the program from crashing abruptly.
        try {
            // Main application loop
            while (running) {
                printMenu(); // Display the menu options

                int choice = -1; // Variable to store user's menu choice

                // --- Input Handling and Validation ---
                try {
                    System.out.print("Enter your choice: ");
                    choice = scanner.nextInt(); // Attempt to read an integer
                    scanner.nextLine(); // Consume the leftover newline character after reading the integer

                } catch (InputMismatchException e) {
                    // Catch specific exception for non-integer input
                    System.err.println("Invalid input. Please enter a number.");
                    scanner.nextLine(); // Consume the invalid input to prevent an infinite loop
                    continue; // Skip the rest of this loop iteration and show menu again
                }

                // --- Menu Navigation using Switch Statement ---
                switch (choice) {
                    case 1: // Submit New Report
                        System.out.println("\n--- Submit New Report ---");
                        System.out.print("Enter report type: ");
                        String type = scanner.nextLine();
                        System.out.print("Enter report description: ");
                        String description = scanner.nextLine();
                        system.submitReport(type, description); // Delegate submission to the system
                        break; // Exit switch case

                    case 2: // Process Next Report
                        System.out.println("\n--- Processing Next Report ---");
                        system.processNextReport(); // Delegate processing to the system
                        // The method itself handles the "no reports" message
                        break; // Exit switch case

                    case 3: // View Pending Reports
                        System.out.println("\n--- Pending Reports ---");
                        // Retrieve pending reports using the List interface type
                        List<Report> pending = system.getPendingReports();
                        if (pending.isEmpty()) {
                            System.out.println("No reports currently pending.");
                        } else {
                            // Iterate and print each pending report
                            pending.forEach(System.out::println); // Using Java 8 lambda expression
                        }
                        break; // Exit switch case

                    case 4: // View Processed Reports
                        System.out.println("\n--- Processed Reports ---");
                        // Retrieve processed reports using the List interface type
                        List<Report> processed = system.getProcessedReports();
                        if (processed.isEmpty()) {
                            System.out.println("No reports have been processed yet.");
                        } else {
                            // Iterate and print each processed report
                            processed.forEach(System.out::println); // Using Java 8 lambda expression
                        }
                        break; // Exit switch case

                    case 5: // Exit Application
                        running = false; // Set flag to false to terminate the loop
                        System.out.println("Exiting Report Processing System. Goodbye!");
                        break; // Exit switch case

                    default: // Handle invalid menu choices (numbers outside 1-5)
                        System.err.println("Invalid choice. Please enter a number between 1 and 5.");
                        break; // Exit switch case
                }
                System.out.println(); // Print a newline for better spacing after each action
            }
        } catch (Exception e) {
            // Catch any other unexpected exceptions that weren't specifically handled.
            // This provides a fallback for unforeseen errors.
            System.err.println("An unexpected system error occurred: " + e.getMessage());
            e.printStackTrace(); // Print the stack trace for debugging purposes
        } finally {
            // This block ensures the scanner resource is closed
            // regardless of whether an exception occurred or the loop finished normally.
            if (scanner != null) {
                scanner.close();
                System.out.println("Scanner closed.");
            }
        }
    }

    /**
     * Prints the main menu options to the standard output.
     */
    private static void printMenu() {
        System.out.println("--- Report Processing System Menu ---");
        System.out.println("1. Submit New Report");
        System.out.println("2. Process Next Report");
        System.out.println("3. View Pending Reports");
        System.out.println("4. View Processed Reports");
        System.out.println("5. Exit");
        System.out.println("-------------------------------------");
    }
}
