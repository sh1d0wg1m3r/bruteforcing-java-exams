/*
 * Exam Question #90
 * Generated on: 2025-05-11 22:12:22
 * Generated by: Account 4
 * 
 * QUESTION:
 * **Java Programming Exam Task: Package Sorting Facility Simulation**
 * 
 * **Scenario:**
 * You are tasked with simulating the core operations of a small package sorting facility. Packages arrive and are placed in an incoming queue. A sorting machine (simulated by user action) processes packages one by one from the front of the queue. Processed packages are then sorted into different destination bins.
 * 
 * **Task:**
 * Implement a Java program that simulates this process. Your program should allow a user to:
 * 1.  Add a new package to the incoming queue.
 * 2.  Process the next package from the incoming queue.
 * 3.  View the packages currently sorted into each destination bin.
 * 4.  Exit the simulation.
 * 
 * **Requirements:**
 * 
 * 1.  **Data Structures:**
 *     *   Use a `java.util.Queue` to represent the incoming packages waiting to be processed.
 *     *   Use `java.util.ArrayList` and the `java.util.List` interface to manage the destination bins and the packages within them. You should maintain a dynamic list of destination bins, where each bin is itself a `List<Package>`.
 * 2.  **User Interaction:**
 *     *   Use `java.util.Scanner` to read user commands and package details (ID, destination).
 *     *   Present a menu of options to the user (Add Package, Process Package, View Bins, Exit).
 * 3.  **Control Flow:**
 *     *   Use a `switch` statement to handle the different user commands.
 *     *   The program should loop, allowing multiple operations until the user chooses to exit.
 * 4.  **Output:**
 *     *   Use `System.out` for displaying the menu, prompts, processing status, and the contents of the destination bins.
 *     *   Use `System.err` to display error messages (e.g., invalid input, attempting to process an empty queue).
 * 5.  **Error Handling:**
 *     *   Implement robust input validation (e.g., ensuring package ID and destination are not empty).
 *     *   Use `try-catch` blocks for class-wide exception handling, particularly around the main interaction loop, to catch unexpected errors gracefully. Also, handle specific expected errors like trying to process a package when the queue is empty.
 * 6.  **Best Practices:**
 *     *   Design a `Package` class with private fields (`packageId`, `destination`) and public getter methods.
 *     *   Implement a `SortingFacility` class to manage the queue, bins, and operations. Use private fields for the data structures and public methods for the operations (add, process, view).
 *     *   Use meaningful variable and method names.
 *     *   Include appropriate comments and Javadoc where necessary.
 *     *   Ensure clean code structure and proper encapsulation.
 * 
 * **Execution Flow:**
 * The program should start, display the menu, and wait for user input. Based on the input, it performs the requested action. If the input is invalid, it should display an error and show the menu again. The program continues until the user selects the exit option.
 * 
 * **Example Interaction (partial):**
 * 
 * ```
 * --- Package Sorting Facility ---
 * 1. Add Package
 * 2. Process Next Package
 * 3. View Destination Bins
 * 4. Exit
 * Enter your choice: 1
 * Enter Package ID: PKG001
 * Enter Destination: NYC
 * Package PKG001 added to queue.
 * 
 * --- Package Sorting Facility ---
 * 1. Add Package
 * 2. Process Next Package
 * 3. View Destination Bins
 * 4. Exit
 * Enter your choice: 1
 * Enter Package ID: PKG002
 * Enter Destination: LAX
 * Package PKG002 added to queue.
 * 
 * --- Package Sorting Facility ---
 * 1. Add Package
 * 2. Process Next Package
 * 3. View Destination Bins
 * 4. Exit
 * Enter your choice: 2
 * Processing package PKG001 for destination NYC...
 * Package PKG001 sorted into bin for NYC.
 * 
 * --- Package Sorting Facility ---
 * 1. Add Package
 * 2. Process Next Package
 * 3. View Destination Bins
 * 4. Exit
 * Enter your choice: 3
 * --- Destination Bins ---
 * Destination: NYC
 *   - PKG001
 * Destination: LAX
 *   (Empty)
 * --- End of Bins ---
 * 
 * --- Package Sorting Facility ---
 * ... (user continues)
 * ```
 * 
 * Your solution should be a single Java file containing the `Package` class and the `SortingFacility` class with the `main` method.
 * 
 * **Evaluation Criteria:**
 * *   Correct implementation of the package sorting logic.
 * *   Effective use of all required Java components (`Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.err`, `System.out`, `try-catch`).
 * *   Adherence to best practices (encapsulation, naming, comments, validation, error handling).
 * *   Clear and correct output.
 *
 * EXPLANATION:
 * This solution implements the `Package Sorting Facility Simulation` task, demonstrating the required Java concepts and best practices.
 * 
 * **Key Components and Their Usage:**
 * 
 * 1.  **`Queue` (`java.util.Queue`)**: The `incomingQueue` is declared as a `Queue<Package>` and initialized with a `LinkedList`. The `Queue` interface is used to model the incoming packages waiting to be processed in a First-In, First-Out (FIFO) manner. `offer()` is used to add packages to the rear of the queue, and `poll()` is used to remove and retrieve packages from the front.
 * 2.  **`ArrayList` (`java.util.ArrayList`)**: `ArrayList` is used to implement the dynamic lists.
 *     *   `destinationBins`: This is a `List<List<Package>>`, where the outer list is an `ArrayList` and each inner list (representing a bin) is also an `ArrayList`. This structure allows for dynamically adding new destination bins as needed.
 *     *   `binDestinations`: This `List<String>` (implemented as `ArrayList`) keeps track of the destination string associated with each index in the `destinationBins` list, allowing us to find the correct bin for a processed package.
 * 3.  **`List interface` (`java.util.List`)**: The `List` interface is used in the declaration `List<List<Package>> destinationBins` and `List<String> binDestinations`. This promotes good practice by programming to the interface rather than the specific implementation (`ArrayList`), although `ArrayList` is used for instantiation as required. The inner lists within `destinationBins` are also declared as `List<Package>`.
 * 4.  **`Scanner` (`java.util.Scanner`)**: Used in the `main` method to read user input from the console (`System.in`). It reads integer choices (`nextInt()`) and string inputs (`nextLine()`).
 * 5.  **`Switch statement`**: A `switch` statement in the `main` method handles the user's menu choice, directing execution to the appropriate logic (`addPackage`, `processNextPackage`, `viewDestinationBins`, or exit).
 * 6.  **`System.err`**: Used to print error messages to the standard error stream, such as invalid user input, empty package details, or attempting to process an empty queue. This distinguishes error output from normal program output.
 * 7.  **`System.out`**: Used for all standard output, including displaying the menu, prompts, confirmation messages, and the contents of the bins.
 * 8.  **`try-catch` (Class-wide Exception Handling)**:
 *     *   A large `try-catch(Exception e)` block wraps the main `while` loop in the `main` method. This provides a top-level, "class-wide" handler for any unexpected exceptions that might occur during the program's execution loop.
 *     *   A specific `try-catch(InputMismatchException e)` is used when reading the user's menu choice to handle cases where the user enters non-integer input.
 *     *   Specific checks (`incomingQueue.poll() == null`) are used within `processNextPackage` to gracefully handle the expected scenario of an empty queue without relying solely on generic exception handling.
 * 
 * **Best Practices:**
 * 
 * *   **Encapsulation:** The `Package` class has private fields (`packageId`, `destination`) and public getter methods. The `SortingFacility` class also uses private fields for its data structures (`incomingQueue`, `destinationBins`, `binDestinations`) and public methods (`addPackage`, `processNextPackage`, `viewDestinationBins`) to manage access and operations.
 * *   **Meaningful Names:** Variables (`incomingQueue`, `destinationBins`, `binDestinations`, `nextPackage`, `binIndex`) and methods (`addPackage`, `processNextPackage`, `sortPackageIntoBin`, `viewDestinationBins`, `displayMenu`) are named clearly to reflect their purpose.
 * *   **Comments and Documentation:** Javadoc comments are provided for classes and methods, explaining their purpose, parameters, and return values. Inline comments clarify specific logic points.
 * *   **Input Validation:** The code checks if package ID and destination strings are empty before creating and adding a package.
 * *   **Error Handling:** Specific error messages are printed using `System.err` for different error conditions (invalid choice, empty queue, empty input). The `try-catch` blocks handle potential exceptions during input reading and provide a fallback for unexpected errors.
 * *   **Clean Code Structure:** The code is organized into logical classes (`Package`, `SortingFacility`) with well-defined methods, making it readable and maintainable. The `main` method orchestrates the user interaction and calls the facility's methods.
 * 
 * The solution effectively combines various Java collection types, control flow statements, and exception handling mechanisms to simulate a practical scenario, fulfilling all the requirements of the complex exam task.
 */

import java.util.LinkedList;
import java.util.Queue;
import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;
import java.util.InputMismatchException;

/**
 * Represents a package with an ID and a destination.
 */
class Package {
    private String packageId;
    private String destination;

    /**
     * Constructs a new Package object.
     *
     * @param packageId The unique identifier for the package.
     * @param destination The destination of the package.
     */
    public Package(String packageId, String destination) {
        this.packageId = packageId;
        this.destination = destination;
    }

    /**
     * Gets the package ID.
     *
     * @return The package ID.
     */
    public String getPackageId() {
        return packageId;
    }

    /**
     * Gets the package destination.
     *
     * @return The package destination.
     */
    public String getDestination() {
        return destination;
    }

    @Override
    public String toString() {
        return packageId;
    }
}

/**
 * Simulates a package sorting facility.
 * Manages an incoming queue and sorts packages into destination bins.
 */
public class SortingFacility {

    // Queue for packages waiting to be processed
    private Queue<Package> incomingQueue;

    // List of lists, where each inner list represents a destination bin
    private List<List<Package>> destinationBins;

    // List to keep track of the destinations corresponding to the bins list indices
    private List<String> binDestinations;

    /**
     * Constructs a new SortingFacility.
     * Initializes the queue and destination bins.
     */
    public SortingFacility() {
        this.incomingQueue = new LinkedList<>(); // LinkedList implements Queue
        this.destinationBins = new ArrayList<>();
        this.binDestinations = new ArrayList<>();
    }

    /**
     * Adds a package to the incoming queue.
     *
     * @param pkg The package to add.
     */
    public void addPackage(Package pkg) {
        if (pkg != null) {
            incomingQueue.offer(pkg); // offer is preferred over add for queues (returns false instead of throwing exception)
            System.out.println("Package " + pkg.getPackageId() + " added to queue.");
        } else {
            System.err.println("Error: Cannot add a null package.");
        }
    }

    /**
     * Processes the next package from the incoming queue.
     * Removes the package from the queue and sorts it into the appropriate bin.
     */
    public void processNextPackage() {
        Package nextPackage = incomingQueue.poll(); // poll retrieves and removes the head, returns null if queue is empty

        if (nextPackage == null) {
            System.err.println("Error: Incoming queue is empty. No packages to process.");
            return;
        }

        System.out.println("Processing package " + nextPackage.getPackageId() + " for destination " + nextPackage.getDestination() + "...");
        sortPackageIntoBin(nextPackage);
        System.out.println("Package " + nextPackage.getPackageId() + " sorted into bin for " + nextPackage.getDestination() + ".");
    }

    /**
     * Sorts a processed package into the correct destination bin.
     * Creates a new bin if the destination does not exist yet.
     *
     * @param pkg The package to sort.
     */
    private void sortPackageIntoBin(Package pkg) {
        String destination = pkg.getDestination();
        int binIndex = binDestinations.indexOf(destination);

        if (binIndex == -1) {
            // Destination bin does not exist, create a new one
            List<Package> newBin = new ArrayList<>();
            newBin.add(pkg);
            destinationBins.add(newBin);
            binDestinations.add(destination);
            // System.out.println("Created new bin for destination: " + destination); // Optional debug output
        } else {
            // Destination bin exists, add package to the existing bin
            destinationBins.get(binIndex).add(pkg);
        }
    }

    /**
     * Displays the contents of all destination bins.
     */
    public void viewDestinationBins() {
        System.out.println("--- Destination Bins ---");
        if (destinationBins.isEmpty()) {
            System.out.println("No packages have been sorted yet.");
        } else {
            for (int i = 0; i < destinationBins.size(); i++) {
                String destination = binDestinations.get(i);
                List<Package> bin = destinationBins.get(i);

                System.out.println("Destination: " + destination);
                if (bin.isEmpty()) {
                    System.out.println("  (Empty)");
                } else {
                    for (Package pkg : bin) {
                        System.out.println("  - " + pkg.getPackageId());
                    }
                }
            }
        }
        System.out.println("--- End of Bins ---");
    }

    /**
     * Displays the main menu options to the user.
     */
    private void displayMenu() {
        System.out.println("\n--- Package Sorting Facility ---");
        System.out.println("1. Add Package");
        System.out.println("2. Process Next Package");
        System.out.println("3. View Destination Bins");
        System.out.println("4. Exit");
        System.out.print("Enter your choice: ");
    }

    /**
     * The main method to run the simulation.
     * Handles user input and calls appropriate methods.
     * Includes class-wide exception handling.
     *
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        SortingFacility facility = new SortingFacility();
        Scanner scanner = new Scanner(System.in);
        boolean running = true;

        // Class-wide exception handling for the main loop
        try {
            while (running) {
                facility.displayMenu();
                int choice = -1;
                try {
                    choice = scanner.nextInt();
                } catch (InputMismatchException e) {
                    System.err.println("Invalid input. Please enter a number.");
                    scanner.next(); // Consume the invalid input
                    continue; // Skip to the next loop iteration
                } finally {
                    scanner.nextLine(); // Consume the newline character left by nextInt()
                }

                switch (choice) {
                    case 1:
                        System.out.print("Enter Package ID: ");
                        String id = scanner.nextLine().trim();
                        System.out.print("Enter Destination: ");
                        String destination = scanner.nextLine().trim();

                        if (id.isEmpty() || destination.isEmpty()) {
                            System.err.println("Error: Package ID and Destination cannot be empty.");
                        } else {
                            Package newPackage = new Package(id, destination);
                            facility.addPackage(newPackage);
                        }
                        break;
                    case 2:
                        facility.processNextPackage();
                        break;
                    case 3:
                        facility.viewDestinationBins();
                        break;
                    case 4:
                        System.out.println("Exiting simulation. Goodbye!");
                        running = false;
                        break;
                    default:
                        System.err.println("Invalid choice. Please enter a number between 1 and 4.");
                        break;
                }
            }
        } catch (Exception e) {
            // Generic catch-all for unexpected errors during the main loop
            System.err.println("An unexpected error occurred: " + e.getMessage());
            e.printStackTrace(); // Print stack trace for debugging unexpected errors
        } finally {
            // Ensure scanner is closed
            scanner.close();
            System.out.println("Scanner closed.");
        }
    }
}
