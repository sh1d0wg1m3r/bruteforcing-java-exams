/*
 * Exam Question #855
 * Generated on: 2025-05-12 16:51:02
 * Generated by: Account 3
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Advanced Task Scheduler Simulation
 * 
 * **Scenario:**
 * 
 * You are tasked with developing a simplified simulation of a task scheduler within an operating system. The scheduler manages tasks that are submitted for execution. Tasks are added to a queue of ready tasks. When the scheduler "executes" a task, it takes the next task from the queue, simulates its running process, and moves it to a list of all tasks, marking its final state (Completed or Error). The system should allow users to submit new tasks, view tasks waiting in the queue, view all tasks processed or pending, and trigger the execution of the next task.
 * 
 * **Requirements:**
 * 
 * 1.  **Task Representation:** Create a `Task` class with the following private fields:
 *     *   `id` (int): A unique identifier for the task.
 *     *   `name` (String): The name or description of the task.
 *     *   `priority` (int): A priority level (higher number = higher priority, though the basic scheduler queue will be FIFO).
 *     *   `state` (enum `TaskState`): The current state of the task. Define an enum `TaskState` with values like `READY`, `RUNNING`, `COMPLETED`, `ERROR`.
 *     *   Implement a constructor to initialize `id`, `name`, `priority`, setting the initial state to `READY`.
 *     *   Provide public getter methods for all fields.
 *     *   Add methods `markAsRunning()`, `markAsCompleted()`, `markAsError()` to update the state.
 *     *   Override the `toString()` method to provide a clear string representation of a task.
 * 
 * 2.  **Scheduler Logic:** Create a `TaskScheduler` class with the following private fields:
 *     *   `taskQueue` (Queue<Task>): A queue to hold tasks that are ready to be executed. Use `java.util.Queue`.
 *     *   `allTasks` (List<Task>): A list to keep track of all tasks ever created, regardless of their current state (pending, running, completed, or error). Use `java.util.List` interface type, implemented by `java.util.ArrayList`.
 *     *   `nextTaskId` (int): A counter to generate unique task IDs, starting from 1.
 *     *   Implement a constructor to initialize the queue, list, and task ID counter.
 *     *   Implement `addTask(String name, int priority)`: Creates a new `Task` with the next available ID, adds it to `allTasks`, and adds it to `taskQueue`.
 *     *   Implement `viewPendingTasks()`: Prints the details of all tasks currently in `taskQueue`. If the queue is empty, print a message indicating that.
 *     *   Implement `viewAllTasks()`: Prints the details of all tasks ever added to the system (from `allTasks`). If the list is empty, print a message indicating that.
 *     *   Implement `executeNextTask()`:
 *         *   Takes the next task from `taskQueue`. If the queue is empty, print an error message to `System.err` and return.
 *         *   Simulate execution: Print a message indicating the task is starting.
 *         *   Introduce a *simulated* chance of failure (e.g., 20% chance).
 *         *   If execution *fails* (simulated): Print an error message to `System.err`, update the task's state to `ERROR`.
 *         *   If execution *succeeds*: Print a success message to `System.out`, update the task's state to `COMPLETED`.
 *         *   *Note:* The task remains in the `allTasks` list, just its state is updated.
 * 
 * 3.  **Main Application (`SchedulerApp`):**
 *     *   Create a `main` method to run the simulation.
 *     *   Use `java.util.Scanner` to read user input from the console.
 *     *   Present a menu of options to the user:
 *         1.  Add New Task
 *         2.  View Pending Tasks
 *         3.  View All Tasks
 *         4.  Execute Next Task
 *         5.  Exit
 *     *   Use a `switch` statement to process the user's choice.
 *     *   Implement input validation for user choices and task details (e.g., priority must be an integer). If input is invalid, print an error message using `System.err`.
 *     *   Implement **class-wide exception handling** using `try-catch` blocks. A single `try-catch` block in the `main` method wrapping the main application loop is sufficient for this requirement, catching general `Exception` and printing an error message using `System.err`.
 *     *   Use `System.out` for displaying the menu, success messages, and task details.
 *     *   Use `System.err` for displaying error messages (invalid input, queue empty, execution failure, general exceptions).
 *     *   Ensure the `Scanner` is closed when the application exits.
 * 
 * 4.  **Best Practices:**
 *     *   Use meaningful variable and method names.
 *     *   Apply proper encapsulation (private fields, public methods).
 *     *   Include appropriate comments and documentation (e.g., Javadoc).
 *     *   Maintain clean code structure.
 * 
 * **Expected Output:**
 * 
 * The program should interact with the user via the console, displaying a menu, prompting for input, and showing the results of operations or error messages.
 * 
 * *   Adding a task: Confirmation message.
 * *   Viewing tasks: List of tasks with details or an empty message.
 * *   Executing task: Message indicating start/completion/error.
 * *   Errors: Messages on `System.err`.
 * *   General Exceptions: Message on `System.err` caught by the top-level handler.
 * 
 * **Example Interaction Flow (Illustrative):**
 * 
 * ```
 * --- Task Scheduler Menu ---
 * 1. Add New Task
 * 2. View Pending Tasks
 * 3. View All Tasks
 * 4. Execute Next Task
 * 5. Exit
 * Enter choice: 1
 * Enter task name: Clean Room
 * Enter priority: 5
 * Task added: Task{id=1, name='Clean Room', priority=5, state=READY}
 * 
 * --- Task Scheduler Menu ---
 * ...
 * Enter choice: 1
 * Enter task name: Do Laundry
 * Enter priority: 3
 * Task added: Task{id=2, name='Do Laundry', priority=3, state=READY}
 * 
 * --- Task Scheduler Menu ---
 * ...
 * Enter choice: 2
 * Pending Tasks:
 * Task{id=1, name='Clean Room', priority=5, state=READY}
 * Task{id=2, name='Do Laundry', priority=3, state=READY}
 * 
 * --- Task Scheduler Menu ---
 * ...
 * Enter choice: 4
 * Executing task: Task{id=1, name='Clean Room', priority=5, state=READY}
 * Task completed successfully: Task{id=1, name='Clean Room', priority=5, state=COMPLETED}
 * 
 * --- Task Scheduler Menu ---
 * ...
 * Enter choice: 4
 * Executing task: Task{id=2, name='Do Laundry', priority=3, state=READY}
 * [Simulated Error] Task execution failed: Task{id=2, name='Do Laundry', priority=3, state=ERROR}  <-- This goes to System.err
 * 
 * --- Task Scheduler Menu ---
 * ...
 * Enter choice: 3
 * All Tasks:
 * Task{id=1, name='Clean Room', priority=5, state=COMPLETED}
 * Task{id=2, name='Do Laundry', priority=3, state=ERROR}
 * 
 * --- Task Scheduler Menu ---
 * ...
 * Enter choice: 5
 * Exiting scheduler.
 * ```
 *
 * EXPLANATION:
 * This solution implements a basic task scheduler simulation demonstrating the required Java concepts.
 * 
 * 1.  **`TaskState` Enum:** Defines the possible states a task can be in (`READY`, `RUNNING`, `COMPLETED`, `ERROR`), providing a clear and type-safe way to manage task status.
 * 2.  **`Task` Class:** Represents the fundamental unit of work.
 *     *   It adheres to **encapsulation** with private fields (`id`, `name`, `priority`, `state`) and public getter methods.
 *     *   `markAsRunning`, `markAsCompleted`, `markAsError` methods provide controlled ways to change the task's state.
 *     *   The `toString()` method provides a convenient, readable representation of the task object for output.
 * 3.  **`TaskScheduler` Class:** Manages the collection and processing of tasks.
 *     *   `taskQueue` (declared as `Queue<Task>`, implemented with `LinkedList`) holds tasks waiting for execution, adhering to the FIFO (First-In, First-Out) principle typical of a basic queue.
 *     *   `allTasks` (declared as `List<Task>`, implemented with `ArrayList`) stores a historical record of all tasks ever created, meeting the `List` and `ArrayList` requirements.
 *     *   `nextTaskId` ensures each task gets a unique ID.
 *     *   `addTask()` demonstrates adding elements to both the `List` and the `Queue`.
 *     *   `viewPendingTasks()` iterates through the `taskQueue` (using an enhanced for loop, which doesn't remove elements) to display tasks currently waiting.
 *     *   `viewAllTasks()` iterates through the `allTasks` `List` to display all tasks in the system.
 *     *   `executeNextTask()` uses `taskQueue.poll()` to retrieve and remove the next task from the queue. It simulates execution, including a random chance of failure, and updates the task's state in place (since the task object reference exists in `allTasks`). It uses `System.err` for the error message when the queue is empty or simulation fails, and `System.out` for success messages.
 * 4.  **`SchedulerApp` Class (`main` method):** This is the entry point and handles user interaction.
 *     *   **`Scanner`:** Used to read user input from `System.in` for menu choices and task details.
 *     *   **`displayMenu()`:** A helper method for clean presentation of options.
 *     *   **`try-catch` (Class-wide Exception Handling):** A large `try` block wraps the main `while` loop. This demonstrates a top-level exception handler that catches any unhandled `Exception` occurring within the application loop, printing a generic error message and stack trace to `System.err`. This fulfills the requirement for "class-wide exception handling" in the context of a simple console application.
 *     *   **Input Validation:** Inside the `try` block, `try-catch(NumberFormatException)` is used specifically when parsing integer inputs (choice, priority) to handle non-numeric input gracefully using `System.err`. Task name is checked for emptiness.
 *     *   **`switch` Statement:** Controls the application flow based on the validated user choice, calling the appropriate methods of the `TaskScheduler`. The `default` case handles invalid numerical choices, printing an error to `System.err`.
 *     *   **`System.out` and `System.err`:** Used distinctly as required â€“ `System.out` for normal output (menu, task lists, success messages) and `System.err` for error conditions (invalid input, empty queue, execution failure, caught exceptions).
 *     *   **`finally` Block:** Ensures `scanner.close()` is called regardless of whether the `while` loop finishes normally or an exception is caught, preventing resource leaks.
 * 
 * This solution effectively combines the required Java components (`Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.err`, `System.out`, `try-catch`) within a practical simulation, demonstrating object-oriented principles (encapsulation) and robust error handling.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.Random; // For simulating task execution failure

// Enum to represent the state of a task
enum TaskState {
    READY, RUNNING, COMPLETED, ERROR
}

/**
 * Represents a single task in the scheduler system.
 */
class Task {
    private int id;
    private String name;
    private int priority;
    private TaskState state;

    /**
     * Constructs a new Task.
     * @param id The unique identifier for the task.
     * @param name The name/description of the task.
     * @param priority The priority level of the task.
     */
    public Task(int id, String name, int priority) {
        this.id = id;
        this.name = name;
        this.priority = priority;
        this.state = TaskState.READY; // Tasks start in the READY state
    }

    // --- Getters ---
    public int getId() {
        return id;
    }

    public String getName() {
        return name;
    }

    public int getPriority() {
        return priority;
    }

    public TaskState getState() {
        return state;
    }

    // --- State Update Methods ---
    public void markAsRunning() {
        this.state = TaskState.RUNNING;
    }

    public void markAsCompleted() {
        this.state = TaskState.COMPLETED;
    }

    public void markAsError() {
        this.state = TaskState.ERROR;
    }

    /**
     * Provides a string representation of the Task.
     * @return A formatted string describing the task.
     */
    @Override
    public String toString() {
        return String.format("Task{id=%d, name='%s', priority=%d, state=%s}",
                             id, name, priority, state);
    }
}

/**
 * Manages the collection and execution of tasks.
 */
class TaskScheduler {
    private Queue<Task> taskQueue;
    private List<Task> allTasks; // Using List interface type for ArrayList implementation
    private int nextTaskId;
    private Random random; // For simulating execution failure

    /**
     * Constructs a new TaskScheduler.
     */
    public TaskScheduler() {
        this.taskQueue = new LinkedList<>(); // LinkedList implements Queue
        this.allTasks = new ArrayList<>();   // ArrayList implements List
        this.nextTaskId = 1;
        this.random = new Random();
    }

    /**
     * Adds a new task to the scheduler.
     * The task is added to the list of all tasks and the pending queue.
     * @param name The name of the task.
     * @param priority The priority of the task.
     */
    public void addTask(String name, int priority) {
        Task newTask = new Task(nextTaskId++, name, priority);
        allTasks.add(newTask);
        taskQueue.offer(newTask); // offer is preferred over add for queues
        System.out.println("Task added: " + newTask);
    }

    /**
     * Displays all tasks currently waiting in the queue.
     */
    public void viewPendingTasks() {
        if (taskQueue.isEmpty()) {
            System.out.println("No tasks currently pending in the queue.");
        } else {
            System.out.println("--- Pending Tasks ---");
            // Iterate through the queue without removing elements
            for (Task task : taskQueue) {
                System.out.println(task);
            }
        }
    }

    /**
     * Displays all tasks ever added to the scheduler, regardless of state.
     */
    public void viewAllTasks() {
        if (allTasks.isEmpty()) {
            System.out.println("No tasks have been added to the system yet.");
        } else {
            System.out.println("--- All Tasks ---");
            for (Task task : allTasks) {
                System.out.println(task);
            }
        }
    }

    /**
     * Simulates the execution of the next task in the queue.
     * The task is removed from the queue and its state is updated based on
     * a simulated success or failure.
     */
    public void executeNextTask() {
        Task taskToExecute = taskQueue.poll(); // poll retrieves and removes the head of the queue

        if (taskToExecute == null) {
            System.err.println("[ERROR] No tasks in the queue to execute.");
            return;
        }

        System.out.println("Executing task: " + taskToExecute);
        taskToExecute.markAsRunning(); // Mark as running (briefly for simulation)

        // Simulate execution failure (e.g., 20% chance)
        if (random.nextInt(100) < 20) {
            System.err.println("[Simulated Error] Task execution failed: " + taskToExecute);
            taskToExecute.markAsError();
        } else {
            System.out.println("Task completed successfully: " + taskToExecute);
            taskToExecute.markAsCompleted();
        }
        // Note: The task remains in the 'allTasks' list with its updated state.
    }
}

/**
 * Main application class for the Task Scheduler simulation.
 * Handles user interaction and manages the TaskScheduler instance.
 */
public class SchedulerApp {

    /**
     * Displays the main menu options to the user.
     */
    private static void displayMenu() {
        System.out.println("\n--- Task Scheduler Menu ---");
        System.out.println("1. Add New Task");
        System.out.println("2. View Pending Tasks");
        System.out.println("3. View All Tasks");
        System.out.println("4. Execute Next Task");
        System.out.println("5. Exit");
        System.out.print("Enter choice: ");
    }

    /**
     * Main method to run the scheduler application.
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        TaskScheduler scheduler = new TaskScheduler();
        boolean running = true;

        // Class-wide exception handling using a try-catch around the main loop
        try {
            while (running) {
                displayMenu();
                int choice = -1;
                try {
                    choice = Integer.parseInt(scanner.nextLine());
                } catch (NumberFormatException e) {
                    System.err.println("[ERROR] Invalid input. Please enter a number.");
                    continue; // Skip to next loop iteration
                }

                // Use a switch statement for flow control based on user choice
                switch (choice) {
                    case 1: // Add New Task
                        System.out.print("Enter task name: ");
                        String name = scanner.nextLine();
                        if (name == null || name.trim().isEmpty()) {
                            System.err.println("[ERROR] Task name cannot be empty.");
                            break; // Stay in the loop, don't add task
                        }

                        int priority = -1;
                        System.out.print("Enter priority (integer): ");
                        try {
                            priority = Integer.parseInt(scanner.nextLine());
                            scheduler.addTask(name.trim(), priority);
                        } catch (NumberFormatException e) {
                            System.err.println("[ERROR] Invalid priority input. Please enter an integer.");
                        }
                        break;

                    case 2: // View Pending Tasks
                        scheduler.viewPendingTasks();
                        break;

                    case 3: // View All Tasks
                        scheduler.viewAllTasks();
                        break;

                    case 4: // Execute Next Task
                        scheduler.executeNextTask();
                        break;

                    case 5: // Exit
                        System.out.println("Exiting scheduler.");
                        running = false;
                        break;

                    default: // Invalid Choice
                        System.err.println("[ERROR] Invalid choice. Please enter a number between 1 and 5.");
                }
            }
        } catch (Exception e) {
            // Generic catch block for unexpected errors during execution
            System.err.println("[FATAL ERROR] An unexpected error occurred: " + e.getMessage());
            e.printStackTrace(System.err); // Print stack trace to System.err
        } finally {
            // Ensure scanner is closed even if an exception occurs or loop ends
            scanner.close();
            System.out.println("Scanner closed.");
        }
    }
}
