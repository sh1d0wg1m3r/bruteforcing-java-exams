/*
 * Exam Question #521
 * Generated on: 2025-05-11 23:23:45
 * Generated by: Account 1
 * 
 * QUESTION:
 * ## Advanced Java Programming Exam Task: Warehouse Order Fulfillment Simulation
 * 
 * **Scenario:**
 * 
 * You are tasked with developing a simplified simulation of a warehouse order fulfillment system. The warehouse receives incoming stock of various items and processes customer orders from a queue. Your system needs to manage the inventory, accept new stock, queue incoming orders, and process orders sequentially, checking for item availability.
 * 
 * **Requirements:**
 * 
 * Implement a Java program that simulates this warehouse process. Your solution MUST utilize **ALL** of the following Java components:
 * 
 * 1.  `java.util.Queue`: To hold incoming customer orders waiting to be processed.
 * 2.  `java.util.ArrayList`: To store the current inventory of items.
 * 3.  `java.util.List`: Used as the type for collections where appropriate (e.g., the inventory, the items within an order).
 * 4.  `java.util.Scanner`: To read user input for various operations.
 * 5.  `switch` statement: To control the main menu flow based on user selection.
 * 6.  `System.err`: To display error messages (e.g., insufficient stock, invalid input).
 * 7.  `System.out`: To display normal output (menu, successful operations, inventory status).
 * 8.  Class-wide exception handling with `try-catch` blocks: To handle potential issues like invalid input format or operational errors gracefully.
 * 
 * **Functionality:**
 * 
 * Your program should present a menu to the user with the following options:
 * 
 * 1.  **Add Stock:** Allows adding quantity to an existing item or adding a new item to the inventory.
 *     *   Input: Item ID (String), Item Name (String), Quantity (int).
 *     *   Validation: Quantity must be positive. If the item ID already exists, update the quantity; otherwise, add a new item.
 *     *   Output: Confirmation message to `System.out` or error message to `System.err`.
 * 2.  **Place Order:** Creates a new order and adds it to the order queue. An order consists of an Order ID and a list of items with quantities.
 *     *   Input: Order ID (String), then for each item in the order: Item ID (String), Quantity (int). The user should be able to specify multiple items per order. A specific input (e.g., "done") should signal the end of the order items.
 *     *   Validation: Order ID should be unique (for simplicity, you can skip this validation in the exam if time is short, but state it as a potential improvement). Item quantities within the order must be positive.
 *     *   Output: Confirmation message to `System.out` or error message to `System.err`.
 * 3.  **Process Next Order:** Dequeues the next order from the queue and attempts to fulfill it.
 *     *   Process items one by one. If sufficient stock is available for all items in the order, decrement inventory quantities and print a success message to `System.out`.
 *     *   If insufficient stock for *any* item in the order, the order *cannot* be fulfilled *at this time*. Print an error message to `System.err` indicating which item caused the failure, and the order remains unfulfilled (you can choose to discard it or requeue it; for this exam, discard it and print the failure). Do *not* modify inventory if fulfillment fails.
 *     *   Output: Success or failure message to `System.out` or `System.err`. Message if the queue is empty.
 * 4.  **View Inventory:** Displays the current stock of all items in the warehouse.
 *     *   Output: List of Item ID, Item Name, and Quantity to `System.out`.
 * 5.  **View Order Queue:** Displays the Order IDs of orders currently in the queue.
 *     *   Output: List of Order IDs to `System.out`.
 * 6.  **Exit:** Terminates the program.
 * 
 * **Data Structures:**
 * 
 * *   Represent items in inventory using a class `Item` with fields: `itemId`, `name`, `quantity`.
 * *   Represent items within an order using a class `OrderItem` with fields: `itemId`, `quantity`.
 * *   Represent an order using a class `Order` with fields: `orderId`, `List<OrderItem> items`.
 * *   Manage inventory using a `List<Item>`.
 * *   Manage the order queue using a `Queue<Order>`.
 * 
 * **Best Practices:**
 * 
 * *   Use meaningful variable and method names.
 * *   Apply proper encapsulation (private fields, public getters/setters where necessary, public methods for operations).
 * *   Include comments where logic is complex.
 * *   Implement robust input validation and error handling using `try-catch` and `System.err`.
 * *   Structure your code into appropriate classes (`Item`, `OrderItem`, `Order`, `Warehouse`, and a main application class).
 * 
 * **Example Interaction (Illustrative):**
 * 
 * ```
 * --- Warehouse Simulation Menu ---
 * 1. Add Stock
 * 2. Place Order
 * 3. Process Next Order
 * 4. View Inventory
 * 5. View Order Queue
 * 6. Exit
 * Enter your choice: 1
 * Enter Item ID: A101
 * Enter Item Name: Laptop
 * Enter Quantity: 10
 * Stock added: A101 (Laptop), Quantity: 10
 * 
 * --- Warehouse Simulation Menu ---
 * ...
 * Enter your choice: 1
 * Enter Item ID: B202
 * Enter Item Name: Mouse
 * Enter Quantity: 50
 * Stock added: B202 (Mouse), Quantity: 50
 * 
 * --- Warehouse Simulation Menu ---
 * ...
 * Enter your choice: 4
 * Current Inventory:
 * ID: A101, Name: Laptop, Quantity: 10
 * ID: B202, Name: Mouse, Quantity: 50
 * 
 * --- Warehouse Simulation Menu ---
 * ...
 * Enter your choice: 2
 * Enter Order ID: O001
 * Enter Item details (or 'done' to finish):
 * Enter Item ID: A101
 * Enter Quantity: 2
 * Enter Item details (or 'done' to finish):
 * Enter Item ID: B202
 * Enter Quantity: 5
 * Enter Item details (or 'done' to finish):
 * done
 * Order O001 placed successfully.
 * 
 * --- Warehouse Simulation Menu ---
 * ...
 * Enter your choice: 2
 * Enter Order ID: O002
 * Enter Item details (or 'done' to finish):
 * Enter Item ID: A101
 * Enter Quantity: 15
 * Enter Item details (or 'done' to finish):
 * done
 * Order O002 placed successfully.
 * 
 * --- Warehouse Simulation Menu ---
 * ...
 * Enter your choice: 5
 * Order Queue: [O001, O002]
 * 
 * --- Warehouse Simulation Menu ---
 * ...
 * Enter your choice: 3
 * Processing Order: O001
 * Order O001 processed successfully. Inventory updated.
 * 
 * --- Warehouse Simulation Menu ---
 * ...
 * Enter your choice: 4
 * Current Inventory:
 * ID: A101, Name: Laptop, Quantity: 8
 * ID: B202, Name: Mouse, Quantity: 45
 * 
 * --- Warehouse Simulation Menu ---
 * ...
 * Enter your choice: 3
 * Processing Order: O002
 * Error processing Order O002: Insufficient stock for item A101. Required: 15, Available: 8. Order could not be fulfilled.
 * 
 * --- Warehouse Simulation Menu ---
 * ...
 * Enter your choice: 5
 * Order Queue: []
 * 
 * --- Warehouse Simulation Menu ---
 * ...
 * Enter your choice: 6
 * Exiting simulation.
 * ```
 * 
 * Your solution should handle various edge cases like empty inventory, empty queue, non-integer input for quantity/choice, negative quantities, items not in inventory during order processing, etc.
 * 
 * **Expected Output:**
 * 
 * The program should run interactively, displaying the menu, prompting for input, and printing status/error messages as described above using `System.out` and `System.err` appropriately.
 *
 * EXPLANATION:
 * This solution implements the Warehouse Order Fulfillment Simulation as requested, demonstrating the use of all specified Java components and adhering to best practices.
 * 
 * 1.  **Class Structure:**
 *     *   `Item`: Represents a single product type in the inventory. It uses private fields (`itemId`, `name`, `quantity`) and public methods (`get...`, `addQuantity`, `removeQuantity`) for encapsulation. `removeQuantity` includes basic stock availability check.
 *     *   `OrderItem`: A simple class representing a specific item and its required quantity within the context of a single order.
 *     *   `Order`: Represents a customer order, containing an `orderId` and a `List<OrderItem>` detailing the items requested.
 *     *   `Warehouse`: This is the core class managing the simulation state. It holds the `inventory` (`List<Item>`) and the `orderQueue` (`Queue<Order>`). It contains the main business logic methods: `addStock`, `placeOrder`, `processNextOrder`, `viewInventory`, and `viewOrderQueue`. Encapsulation is used here as well.
 *     *   `WarehouseSimulation`: The main application class containing the `main` method and the primary application loop (`run`). It handles user interaction via `Scanner` and delegates tasks to the `Warehouse` object.
 * 
 * 2.  **Required Component Usage:**
 *     *   `java.util.Queue`: `Warehouse` uses a `java.util.Queue<Order>` (`orderQueue`) to store orders waiting to be processed. `LinkedList` is used as a concrete implementation of the `Queue` interface, suitable for this purpose. `offer()` is used to add orders, `peek()` to view the next order without removing it, and `poll()` to remove the order after processing.
 *     *   `java.util.ArrayList`: `Warehouse` uses a `java.util.List<Item>` (`inventory`) which is instantiated as an `ArrayList`. `ArrayList` provides dynamic resizing and efficient access/iteration for managing the inventory items.
 *     *   `java.util.List`: Used as the interface type for `inventory` (`List<Item>`) and for the collection of items within an `Order` (`List<OrderItem>`). This is good practice, programming to the interface.
 *     *   `java.util.Scanner`: An instance is created in `WarehouseSimulation` to read user input from `System.in` for menu choices and operation details. `scanner.nextLine()` is used consistently to avoid common Scanner pitfalls with mixed next methods.
 *     *   `switch` statement: Used in the `WarehouseSimulation.run()` method to direct the program flow based on the user's numeric menu choice.
 *     *   `System.err`: Used to print error messages, such as invalid input, insufficient stock during order processing, or other operational failures. This distinguishes errors from normal output.
 *     *   `System.out`: Used for all normal output, including the menu, prompts, confirmation messages for successful operations (adding stock, placing order, successful order processing), and displaying inventory/queue contents.
 *     *   `try-catch` blocks:
 *         *   A broad `try-catch(Exception e)` block wraps the main `while` loop in `WarehouseSimulation.run()` to catch unexpected errors during the simulation's execution, providing class-wide handling.
 *         *   Inner `try-catch(NumberFormatException e)` blocks are used specifically around `Integer.parseInt()` calls in `run()`, `addStockHandler()`, and `placeOrderHandler()` to handle cases where the user enters non-integer input for numbers.
 *         *   `try-catch(IllegalArgumentException e)` is used in `addStockHandler` to catch validation errors thrown by the `Warehouse.addStock` method (e.g., negative quantity).
 *         *   Error conditions within `processNextOrder` (like insufficient stock or item not found) are handled by printing to `System.err` and managing the order queue state directly within the method, effectively acting as specific error handling logic for that operation.
 * 
 * 3.  **Logic and Flow:**
 *     *   The `run` method in `WarehouseSimulation` provides the main application loop.
 *     *   It continuously prints the menu and reads the user's choice.
 *     *   The `switch` statement directs control to the appropriate handler method (`addStockHandler`, `placeOrderHandler`) or directly calls `Warehouse` methods (`processNextOrder`, `viewInventory`, `viewOrderQueue`).
 *     *   `addStockHandler` and `placeOrderHandler` are responsible for gathering input specific to those operations, performing basic input validation (like positive quantities), and then calling the corresponding methods on the `Warehouse` object.
 *     *   `Warehouse.addStock` updates existing items or adds new ones.
 *     *   `Warehouse.placeOrder` adds the new `Order` object to the `orderQueue`.
 *     *   `Warehouse.processNextOrder` first checks if the queue is empty. If not, it peeks at the head order. It then iterates through the items in the order, checking inventory availability *before* attempting to decrement stock. This two-phase approach (check all, then fulfill all) prevents partial fulfillment or leaving inventory in an inconsistent state if one item fails. If the check passes, it polls the order and updates inventory. If it fails, it polls the order and prints an error to `System.err`.
 *     *   `viewInventory` and `viewOrderQueue` simply iterate through the respective collections and print their contents.
 * 
 * 4.  **Best Practices:**
 *     *   Encapsulation is consistently applied in `Item`, `OrderItem`, `Order`, and `Warehouse` classes.
 *     *   Method and variable names are descriptive (e.g., `addStock`, `orderQueue`, `findItemInInventory`).
 *     *   Comments are included to explain the purpose of classes and key methods.
 *     *   Input validation is done both when reading input (e.g., checking for positive quantity, handling `NumberFormatException`) and within the `Warehouse` methods (e.g., `addStock` throws `IllegalArgumentException`).
 *     *   Error handling uses `try-catch` for expected input issues and operational errors, and `System.err` for outputting errors.
 *     *   The code is structured into logical classes, separating data representation (`Item`, `OrderItem`, `Order`) from business logic (`Warehouse`) and user interface/application flow (`WarehouseSimulation`).
 * 
 * This solution effectively combines the required Java features in a practical simulation, demonstrating understanding of data structures, object-oriented principles, user interaction, and robust error handling.
 */

import java.util.ArrayList;
import java.util.LinkedList; // LinkedList implements Queue
import java.util.List;
import java.util.Queue;
import java.util.Scanner;

// Represents an item in the warehouse inventory
class Item {
    private String itemId;
    private String name;
    private int quantity;

    public Item(String itemId, String name, int quantity) {
        this.itemId = itemId;
        this.name = name;
        this.quantity = quantity;
    }

    public String getItemId() {
        return itemId;
    }

    public String getName() {
        return name;
    }

    public int getQuantity() {
        return quantity;
    }

    public void addQuantity(int amount) {
        if (amount > 0) {
            this.quantity += amount;
        }
    }

    public boolean removeQuantity(int amount) {
        if (amount > 0 && this.quantity >= amount) {
            this.quantity -= amount;
            return true;
        }
        return false; // Insufficient stock
    }

    @Override
    public String toString() {
        return "ID: " + itemId + ", Name: " + name + ", Quantity: " + quantity;
    }
}

// Represents an item and its quantity within an order
class OrderItem {
    private String itemId;
    private int quantity;

    public OrderItem(String itemId, int quantity) {
        this.itemId = itemId;
        this.quantity = quantity;
    }

    public String getItemId() {
        return itemId;
    }

    public int getQuantity() {
        return quantity;
    }

    @Override
    public String toString() {
        return "Item ID: " + itemId + ", Quantity: " + quantity;
    }
}

// Represents a customer order
class Order {
    private String orderId;
    private List<OrderItem> items;

    public Order(String orderId, List<OrderItem> items) {
        this.orderId = orderId;
        this.items = items;
    }

    public String getOrderId() {
        return orderId;
    }

    public List<OrderItem> getItems() {
        return items;
    }

    @Override
    public String toString() {
        return "Order ID: " + orderId; // Simplified for queue display
    }
}

// Manages the warehouse operations: inventory and order queue
class Warehouse {
    private List<Item> inventory; // Using ArrayList as required
    private Queue<Order> orderQueue; // Using Queue (implemented by LinkedList) as required

    public Warehouse() {
        this.inventory = new ArrayList<>();
        this.orderQueue = new LinkedList<>(); // LinkedList implements Queue
    }

    /**
     * Adds stock for an item. If item exists, updates quantity. Otherwise, adds new item.
     * @param itemId The ID of the item.
     * @param name The name of the item.
     * @param quantity The quantity to add. Must be positive.
     * @throws IllegalArgumentException if quantity is not positive.
     */
    public void addStock(String itemId, String name, int quantity) {
        if (quantity <= 0) {
            throw new IllegalArgumentException("Quantity must be positive.");
        }

        Item existingItem = findItemInInventory(itemId);

        if (existingItem != null) {
            existingItem.addQuantity(quantity);
            System.out.println("Stock updated for " + existingItem.getName() + ". New quantity: " + existingItem.getQuantity());
        } else {
            Item newItem = new Item(itemId, name, quantity);
            inventory.add(newItem);
            System.out.println("New item added to inventory: " + newItem.getName() + " with quantity " + newItem.getQuantity());
        }
    }

    /**
     * Places a new order into the order queue.
     * @param order The order to place.
     */
    public void placeOrder(Order order) {
        if (order == null || order.getItems() == null || order.getItems().isEmpty()) {
             System.err.println("Error: Cannot place an empty order.");
             return;
        }
         // Basic validation for items in order
        for(OrderItem orderItem : order.getItems()) {
            if (orderItem.getQuantity() <= 0) {
                 System.err.println("Error: Order item quantity must be positive for item ID " + orderItem.getItemId());
                 return; // Reject the whole order if any item is invalid
            }
        }

        orderQueue.offer(order); // Add to the end of the queue
        System.out.println("Order " + order.getOrderId() + " placed successfully. Added to queue.");
    }

    /**
     * Processes the next order in the queue.
     * Attempts to fulfill the order from inventory.
     */
    public void processNextOrder() {
        Order orderToProcess = orderQueue.peek(); // Look at the head without removing

        if (orderToProcess == null) {
            System.out.println("Order queue is empty. Nothing to process.");
            return;
        }

        System.out.println("Processing Order: " + orderToProcess.getOrderId());

        // Check if fulfillment is possible for all items first
        boolean canFulfill = true;
        for (OrderItem orderItem : orderToProcess.getItems()) {
            Item inventoryItem = findItemInInventory(orderItem.getItemId());
            if (inventoryItem == null) {
                System.err.println("Error processing Order " + orderToProcess.getOrderId() + ": Item " + orderItem.getItemId() + " not found in inventory.");
                canFulfill = false;
                break; // Cannot fulfill if item doesn't exist
            }
            if (inventoryItem.getQuantity() < orderItem.getQuantity()) {
                System.err.println("Error processing Order " + orderToProcess.getOrderId() + ": Insufficient stock for item " + orderItem.getItemId() + ". Required: " + orderItem.getQuantity() + ", Available: " + inventoryItem.getQuantity() + ".");
                canFulfill = false;
                break; // Cannot fulfill if stock is insufficient
            }
        }

        if (canFulfill) {
            // If all items can be fulfilled, proceed to decrement inventory
            for (OrderItem orderItem : orderToProcess.getItems()) {
                Item inventoryItem = findItemInInventory(orderItem.getItemId());
                // This should not be null here due to the check above, but defensive programming
                if (inventoryItem != null) {
                    inventoryItem.removeQuantity(orderItem.getQuantity());
                }
            }
            orderQueue.poll(); // Remove the order from the queue after successful processing
            System.out.println("Order " + orderToProcess.getOrderId() + " processed successfully. Inventory updated.");
        } else {
            // If fulfillment failed, remove the order and report failure
            orderQueue.poll(); // Remove the failed order from the queue
            System.err.println("Order " + orderToProcess.getOrderId() + " could not be fulfilled and has been removed from the queue.");
            // The specific error message was already printed in the check loop
        }
    }

    /**
     * Displays the current inventory status.
     */
    public void viewInventory() {
        System.out.println("--- Current Inventory ---");
        if (inventory.isEmpty()) {
            System.out.println("Inventory is empty.");
        } else {
            for (Item item : inventory) {
                System.out.println(item);
            }
        }
        System.out.println("-------------------------");
    }

    /**
     * Displays the Order IDs currently in the queue.
     */
    public void viewOrderQueue() {
        System.out.println("--- Order Queue ---");
        if (orderQueue.isEmpty()) {
            System.out.println("Order queue is empty.");
        } else {
            // Iterating over the queue is safe and doesn't remove elements
            System.out.println(orderQueue); // LinkedList's toString is helpful here
        }
        System.out.println("-------------------");
    }

    /**
     * Helper method to find an item in the inventory by its ID.
     * @param itemId The ID of the item to find.
     * @return The Item object if found, null otherwise.
     */
    private Item findItemInInventory(String itemId) {
        for (Item item : inventory) {
            if (item.getItemId().equals(itemId)) {
                return item;
            }
        }
        return null;
    }
}

public class WarehouseSimulation {

    private Warehouse warehouse;
    private Scanner scanner;

    public WarehouseSimulation() {
        this.warehouse = new Warehouse();
        this.scanner = new Scanner(System.in);
    }

    public void run() {
        int choice = -1;
        // Class-wide exception handling for the main loop
        try {
            while (choice != 6) {
                printMenu();
                System.out.print("Enter your choice: ");

                try {
                    choice = Integer.parseInt(scanner.nextLine()); // Read line to avoid scanner issues

                    switch (choice) {
                        case 1:
                            addStockHandler();
                            break;
                        case 2:
                            placeOrderHandler();
                            break;
                        case 3:
                            warehouse.processNextOrder();
                            break;
                        case 4:
                            warehouse.viewInventory();
                            break;
                        case 5:
                            warehouse.viewOrderQueue();
                            break;
                        case 6:
                            System.out.println("Exiting simulation.");
                            break;
                        default:
                            System.err.println("Invalid choice. Please enter a number between 1 and 6.");
                    }
                } catch (NumberFormatException e) {
                    System.err.println("Invalid input. Please enter a number.");
                } catch (IllegalArgumentException e) {
                     System.err.println("Input validation error: " + e.getMessage());
                } catch (Exception e) {
                    // Catch any other unexpected exceptions during an operation
                    System.err.println("An unexpected error occurred during operation: " + e.getMessage());
                    // e.printStackTrace(); // Uncomment for debugging
                }
                System.out.println(); // Add a blank line for readability
            }
        } catch (Exception mainException) {
            // This catches exceptions that might escape the inner try-catch,
            // though the inner one is broad. Primarily for Scanner or setup issues.
            System.err.println("A critical error occurred: " + mainException.getMessage());
            // mainException.printStackTrace(); // Uncomment for debugging
        } finally {
            // Ensure scanner is closed
            if (scanner != null) {
                scanner.close();
            }
        }
    }

    private void printMenu() {
        System.out.println("--- Warehouse Simulation Menu ---");
        System.out.println("1. Add Stock");
        System.out.println("2. Place Order");
        System.out.println("3. Process Next Order");
        System.out.println("4. View Inventory");
        System.out.println("5. View Order Queue");
        System.out.println("6. Exit");
        System.out.println("---------------------------------");
    }

    private void addStockHandler() {
        System.out.print("Enter Item ID: ");
        String itemId = scanner.nextLine().trim();
        System.out.print("Enter Item Name: ");
        String itemName = scanner.nextLine().trim();
        System.out.print("Enter Quantity: ");
        String quantityStr = scanner.nextLine().trim();

        try {
            int quantity = Integer.parseInt(quantityStr);
            warehouse.addStock(itemId, itemName, quantity);
        } catch (NumberFormatException e) {
            System.err.println("Invalid quantity format. Please enter an integer.");
        } catch (IllegalArgumentException e) {
            System.err.println("Input validation error: " + e.getMessage());
        }
    }

    private void placeOrderHandler() {
        System.out.print("Enter Order ID: ");
        String orderId = scanner.nextLine().trim();

        List<OrderItem> orderItems = new ArrayList<>();
        System.out.println("Enter Item details (or 'done' to finish):");

        while (true) {
            System.out.print("Enter Item ID: ");
            String itemId = scanner.nextLine().trim();
            if (itemId.equalsIgnoreCase("done")) {
                break;
            }

            System.out.print("Enter Quantity: ");
            String quantityStr = scanner.nextLine().trim();

            try {
                int quantity = Integer.parseInt(quantityStr);
                if (quantity <= 0) {
                     System.err.println("Error: Item quantity must be positive. Skipping this item.");
                } else {
                    orderItems.add(new OrderItem(itemId, quantity));
                }
            } catch (NumberFormatException e) {
                System.err.println("Invalid quantity format. Please enter an integer. Skipping this item.");
            }
        }

        if (!orderItems.isEmpty()) {
            Order newOrder = new Order(orderId, orderItems);
            warehouse.placeOrder(newOrder);
        } else {
            System.err.println("No valid items entered for the order. Order not placed.");
        }
    }


    public static void main(String[] args) {
        WarehouseSimulation simulation = new WarehouseSimulation();
        simulation.run();
    }
}
