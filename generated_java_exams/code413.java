/*
 * Exam Question #413
 * Generated on: 2025-05-11 23:07:35
 * Generated by: Account 2
 * 
 * QUESTION:
 * **Java Programming Exam Task: Advanced Print Job Manager**
 * 
 * You are tasked with developing a simple command-line Print Job Management system. This system will manage a queue of print jobs, allowing users to add new jobs, process the next job in the queue, list pending jobs, and view processed jobs.
 * 
 * Your solution must be implemented in Java and adhere to the following requirements:
 * 
 * 1.  **PrintJob Class:** Create a class named `PrintJob` to represent a single print job.
 *     *   It must have private fields: `jobId` (int), `filename` (String), and `priority` (int).
 *     *   Include a constructor to initialize these fields.
 *     *   Provide public getter methods for all fields.
 *     *   Override the `toString()` method to provide a user-friendly string representation of a job (e.g., "Job ID: [id], File: [filename], Priority: [priority]").
 * 
 * 2.  **PrintJobManager Class:** Create a class named `PrintJobManager` to manage the collection of print jobs.
 *     *   It must have a private field `printQueue` of type `Queue<PrintJob>` to store jobs waiting to be processed. Use a `LinkedList` as the concrete implementation.
 *     *   It must have a private field `processedJobs` of type `List<PrintJob>` to store jobs that have been processed. Use an `ArrayList` as the concrete implementation.
 *     *   Implement the following public methods:
 *         *   `addJob(int jobId, String filename, int priority)`: Adds a new `PrintJob` to the `printQueue`.
 *             *   Perform input validation: `jobId` must be positive, `filename` must not be null or empty, `priority` must be positive. If validation fails, print an error message to `System.err` and do *not* add the job.
 *             *   Print a success message to `System.out` if the job is added successfully.
 *         *   `processNextJob()`: Removes and processes the next job from the `printQueue`.
 *             *   If the queue is empty, print a message to `System.out` indicating that there are no jobs to process.
 *             *   If a job is available, remove it from the `printQueue`, add it to the `processedJobs` list, and print a message to `System.out` indicating which job was processed.
 *         *   `listPendingJobs()`: Returns a `List<PrintJob>` containing all jobs currently in the `printQueue`. The returned list should be a *copy* or immutable view to prevent external modification of the internal queue state.
 *         *   `listProcessedJobs()`: Returns a `List<PrintJob>` containing all jobs currently in the `processedJobs` list. The returned list should be a *copy* or immutable view.
 *     *   Implement a public method `run()` that contains the main application loop:
 *         *   Use `Scanner` to read commands from the user via `System.in`.
 *         *   The application should continuously prompt the user for commands until they enter 'exit'.
 *         *   Use a `switch` statement to handle the following commands:
 *             *   `add [id] [filename] [priority]`: Calls `addJob` with the provided arguments. Handle potential `InputMismatchException` or `NumberFormatException` if the ID or priority are not valid integers, printing an error to `System.err`.
 *             *   `process`: Calls `processNextJob`.
 *             *   `list pending`: Calls `listPendingJobs`, iterates through the returned list, and prints each job using its `toString()` method to `System.out`. If the list is empty, print a message indicating no pending jobs.
 *             *   `list processed`: Calls `listProcessedJobs`, iterates through the returned list, and prints each job using its `toString()` method to `System.out`. If the list is empty, print a message indicating no processed jobs.
 *             *   `exit`: Terminates the application loop.
 *             *   Any other command: Print an "Unknown command" message to `System.err`.
 *         *   Implement class-wide exception handling using `try-catch` blocks within the `run()` method to catch potential unhandled exceptions during the command processing loop and print an error message to `System.err` before continuing or exiting gracefully.
 * 
 * 3.  **Main Class:** Create a class with a `main` method to instantiate `PrintJobManager` and call its `run()` method.
 * 
 * **Required Java Components Usage:**
 * *   `java.util.Queue`
 * *   `java.util.ArrayList`
 * *   `java.util.List`
 * *   `java.util.Scanner`
 * *   `switch` statement
 * *   `System.err`
 * *   `System.out`
 * *   Class-wide `try-catch` blocks
 * 
 * **Best Practices:**
 * *   Proper encapsulation (private fields, public methods).
 * *   Meaningful variable and method names.
 * *   Appropriate comments and documentation (e.g., Javadoc).
 * *   Input validation.
 * *   Proper error handling using `System.err` and exceptions.
 * *   Clean code structure.
 * 
 * **Example Interaction:**
 * 
 * ```
 * Enter command (add [id] [file] [priority], process, list pending, list processed, exit): add 1 report.pdf 5
 * Job added: Job ID: 1, File: report.pdf, Priority: 5
 * Enter command (add [id] [file] [priority], process, list pending, list processed, exit): add 2 presentation.pptx 1
 * Job added: Job ID: 2, File: presentation.pptx, Priority: 1
 * Enter command (add [id] [file] [priority], process, list pending, list processed, exit): list pending
 * Pending Jobs:
 * Job ID: 1, File: report.pdf, Priority: 5
 * Job ID: 2, File: presentation.pptx, Priority: 1
 * Enter command (add [id] [file] [priority], process, list pending, list processed, exit): process
 * Processing job: Job ID: 1, File: report.pdf, Priority: 5
 * Enter command (add [id] [file] [priority], process, list pending, list processed, exit): list processed
 * Processed Jobs:
 * Job ID: 1, File: report.pdf, Priority: 5
 * Enter command (add [id] [file] [priority], process, list pending, list processed, exit): list pending
 * Pending Jobs:
 * Job ID: 2, File: presentation.pptx, Priority: 1
 * Enter command (add [id] [file] [priority], process, list pending, list processed, exit): process
 * Processing job: Job ID: 2, File: presentation.pptx, Priority: 1
 * Enter command (add [id] [file] [priority], process, list pending, list processed, exit): process
 * No jobs to process.
 * Enter command (add [id] [file] [priority], process, list pending, list processed, exit): list processed
 * Processed Jobs:
 * Job ID: 1, File: report.pdf, Priority: 5
 * Job ID: 2, File: presentation.pptx, Priority: 1
 * Enter command (add [id] [file] [priority], process, list pending, list possible, exit): list possible
 * Unknown command: list possible
 * Enter command (add [id] [file] [priority], process, list pending, list processed, exit): add abc doc.txt 3
 * Error: Invalid job ID or priority. Please provide positive integers.
 * Enter command (add [id] [file] [priority], process, list pending, list processed, exit): exit
 * Exiting Print Job Manager.
 * ```
 * 
 * Your solution should compile and run, handling the specified commands and errors gracefully.
 *
 * EXPLANATION:
 * This solution implements the Print Job Management system as required, demonstrating the use of all specified Java components and adhering to best practices.
 * 
 * 1.  **`PrintJob` Class:**
 *     *   This is a simple Plain Old Java Object (POJO) representing a data structure.
 *     *   It uses `private final` fields (`jobId`, `filename`, `priority`) to ensure immutability after creation, promoting encapsulation.
 *     *   Public getter methods provide controlled access to the data.
 *     *   The overridden `toString()` method provides a convenient way to display job details.
 * 
 * 2.  **`PrintJobManager` Class:**
 *     *   This class encapsulates the core logic and data structures for managing jobs.
 *     *   `private final Queue<PrintJob> printQueue`: This field uses the `Queue` interface, implemented by `LinkedList`. The `Queue` is ideal for a waiting list where jobs are processed in a First-In, First-Out (FIFO) manner (or ordered by insertion in this simple case). `offer()` is used for adding (safer than `add` in capacity-constrained queues, though `LinkedList` is not capacity constrained), and `poll()` is used for removing from the head (returns `null` if empty, safer than `remove`).
 *     *   `private final List<PrintJob> processedJobs`: This field uses the `List` interface, implemented by `ArrayList`. The `ArrayList` is suitable for storing a dynamic list of jobs that have already been processed, allowing easy addition (`add`) and iteration.
 *     *   `private final Scanner scanner`: Used for reading user input from `System.in`. It's initialized once and closed upon exiting the application.
 *     *   **`addJob` Method:** Takes job details, performs basic input validation (checking for positive ID/priority and non-empty filename). If validation fails, it prints an error to `System.err`. Otherwise, it creates a `PrintJob` object and adds it to the `printQueue` using `offer()`, printing a success message to `System.out`.
 *     *   **`processNextJob` Method:** Uses `printQueue.poll()` to retrieve and remove the next job. If `poll()` returns `null` (queue is empty), it prints a message to `System.out`. Otherwise, it adds the retrieved job to the `processedJobs` list and prints a processing message to `System.out`.
 *     *   **`listPendingJobs` and `listProcessedJobs` Methods:** These methods return a *new* `ArrayList` containing the elements from the respective internal collections (`printQueue` or `processedJobs`). This is important for encapsulation; returning the internal collection directly would allow external code to modify the manager's state unexpectedly. They return the data via the `List` interface, adhering to the requirement.
 *     *   **`run` Method:** This is the heart of the command-line interface.
 *         *   It contains the main `while(running)` loop.
 *         *   **Class-wide `try-catch`:** The entire command processing logic inside the loop is wrapped in a `try-catch(Exception e)`. This catches any unhandled exceptions that might occur during command parsing or processing and prints an error message to `System.err`, preventing the program from crashing and allowing it to potentially continue (or exit gracefully).
 *         *   It reads a line of input using `scanner.nextLine()`.
 *         *   It splits the input line into parts to extract the command and arguments.
 *         *   **`switch` Statement:** A `switch` statement is used to dispatch control based on the first part of the input (the command). This fulfills the requirement for using a `switch`.
 *         *   Each case handles a specific command (`add`, `process`, `list`, `exit`), validating the number of arguments and calling the appropriate manager method.
 *         *   The `add` case includes a nested `try-catch(NumberFormatException)` specifically for handling cases where the provided ID or priority are not valid integers, printing an error to `System.err`.
 *         *   The `list` case has a nested `switch` to handle the different list types (`pending` or `processed`). It retrieves the list using the manager methods, checks if it's empty, and iterates through it using a `for-each` loop, printing each job using `System.out`.
 *         *   Invalid commands or incorrect argument counts print error messages to `System.err`.
 *         *   The `exit` command sets `running` to `false` to terminate the loop and closes the `Scanner`.
 * 
 * 3.  **Main Class:**
 *     *   A simple class with a `main` method is provided to create an instance of `PrintJobManager` and call its `run()` method to start the application.
 * 
 * **Key Concepts Demonstrated:**
 * 
 * *   **Object-Oriented Programming:** Using classes (`PrintJob`, `PrintJobManager`) with encapsulation.
 * *   **Data Structures:** Practical use of `Queue` (FIFO behavior for pending jobs) and `List` (`ArrayList` for history).
 * *   **Interfaces vs. Implementations:** Using `Queue` and `List` interfaces while using `LinkedList` and `ArrayList` as concrete implementations.
 * *   **Input/Output:** Reading user input with `Scanner`, printing normal output to `System.out`, and printing error messages to `System.err`.
 * *   **Control Flow:** Using `switch` statements for multi-way branching based on command input, and a `while` loop for the application lifecycle.
 * *   **Exception Handling:** Using `try-catch` blocks for both specific input parsing errors (`NumberFormatException`) and general unexpected errors (class-wide `catch(Exception)`), providing robustness.
 * *   **Input Validation:** Checking user-provided data for correctness before processing.
 * *   **Encapsulation Best Practices:** Returning copies of internal collections to protect state.
 * 
 * This solution integrates these concepts into a functional command-line application, providing a good test of a student's ability to combine multiple Java features effectively.
 */

import java.util.Queue;
import java.util.LinkedList;
import java.util.List;
import java.util.ArrayList;
import java.util.Scanner;
import java.util.InputMismatchException;

/**
 * Represents a single print job with ID, filename, and priority.
 */
class PrintJob {
    private final int jobId;
    private final String filename;
    private final int priority;

    /**
     * Constructs a new PrintJob.
     * @param jobId The unique identifier for the job.
     * @param filename The name of the file to print.
     * @param priority The priority of the job (higher number could mean higher priority,
     *                 but for this simple queue, it's just a data point).
     */
    public PrintJob(int jobId, String filename, int priority) {
        this.jobId = jobId;
        this.filename = filename;
        this.priority = priority;
    }

    /**
     * Gets the job ID.
     * @return The job ID.
     */
    public int getJobId() {
        return jobId;
    }

    /**
     * Gets the filename.
     * @return The filename.
     */
    public String getFilename() {
        return filename;
    }

    /**
     * Gets the priority.
     * @return The priority.
     */
    public int getPriority() {
        return priority;
    }

    /**
     * Provides a string representation of the print job.
     * @return String representation of the job.
     */
    @Override
    public String toString() {
        return "Job ID: " + jobId + ", File: " + filename + ", Priority: " + priority;
    }
}

/**
 * Manages a queue of print jobs and a history of processed jobs.
 */
public class PrintJobManager {

    private final Queue<PrintJob> printQueue;
    private final List<PrintJob> processedJobs;
    private final Scanner scanner;

    /**
     * Constructs a new PrintJobManager.
     */
    public PrintJobManager() {
        // Using LinkedList as a concrete implementation for Queue
        this.printQueue = new LinkedList<>();
        // Using ArrayList as a concrete implementation for List
        this.processedJobs = new ArrayList<>();
        this.scanner = new Scanner(System.in);
    }

    /**
     * Adds a new print job to the queue after validation.
     * @param jobId The job ID.
     * @param filename The filename.
     * @param priority The priority.
     */
    public void addJob(int jobId, String filename, int priority) {
        // Input validation
        if (jobId <= 0 || filename == null || filename.trim().isEmpty() || priority <= 0) {
            System.err.println("Error: Invalid job data. Job ID, filename, and priority must be valid.");
            return;
        }

        PrintJob newJob = new PrintJob(jobId, filename.trim(), priority);
        printQueue.offer(newJob); // offer is generally preferred over add for capacity-constrained queues
        System.out.println("Job added: " + newJob);
    }

    /**
     * Processes the next job from the queue.
     */
    public void processNextJob() {
        PrintJob jobToProcess = printQueue.poll(); // poll returns null if queue is empty

        if (jobToProcess == null) {
            System.out.println("No jobs to process.");
        } else {
            processedJobs.add(jobToProcess);
            System.out.println("Processing job: " + jobToProcess);
        }
    }

    /**
     * Returns a list of jobs currently in the pending queue.
     * @return A new List containing pending jobs.
     */
    public List<PrintJob> listPendingJobs() {
        // Return a new ArrayList containing the elements from the queue
        // This prevents external modification of the internal queue
        return new ArrayList<>(printQueue);
    }

    /**
     * Returns a list of jobs that have been processed.
     * @return A new List containing processed jobs.
     */
    public List<PrintJob> listProcessedJobs() {
        // Return a new ArrayList containing the elements from the processedJobs list
        // This prevents external modification of the internal list
        return new ArrayList<>(processedJobs);
    }

    /**
     * Runs the main command-line interface loop.
     */
    public void run() {
        System.out.println("Print Job Manager Started.");
        System.out.println("Enter command (add [id] [file] [priority], process, list pending, list processed, exit):");

        boolean running = true;
        while (running) {
            // Class-wide exception handling for the command loop
            try {
                System.out.print("> ");
                String inputLine = scanner.nextLine().trim();
                String[] parts = inputLine.split("\\s+", 4); // Split by whitespace, limit 4 parts

                if (parts.length == 0 || parts[0].isEmpty()) {
                    continue; // Skip empty input
                }

                String command = parts[0].toLowerCase();

                // Switch statement for command handling
                switch (command) {
                    case "add":
                        if (parts.length == 4) {
                            try {
                                int id = Integer.parseInt(parts[1]);
                                String filename = parts[2];
                                int priority = Integer.parseInt(parts[3]);
                                addJob(id, filename, priority);
                            } catch (NumberFormatException e) {
                                System.err.println("Error: Invalid job ID or priority. Please provide positive integers.");
                            }
                        } else {
                            System.err.println("Error: 'add' command requires arguments: add [id] [file] [priority]");
                        }
                        break;

                    case "process":
                        if (parts.length == 1) {
                            processNextJob();
                        } else {
                             System.err.println("Error: 'process' command takes no arguments.");
                        }
                        break;

                    case "list":
                        if (parts.length == 2) {
                            String listType = parts[1].toLowerCase();
                            switch (listType) {
                                case "pending":
                                    List<PrintJob> pending = listPendingJobs();
                                    System.out.println("Pending Jobs:");
                                    if (pending.isEmpty()) {
                                        System.out.println("(none)");
                                    } else {
                                        for (PrintJob job : pending) {
                                            System.out.println(job);
                                        }
                                    }
                                    break;
                                case "processed":
                                    List<PrintJob> processed = listProcessedJobs();
                                    System.out.println("Processed Jobs:");
                                    if (processed.isEmpty()) {
                                        System.out.println("(none)");
                                    } else {
                                        for (PrintJob job : processed) {
                                            System.out.println(job);
                                        }
                                    }
                                    break;
                                default:
                                    System.err.println("Error: Unknown list type. Use 'pending' or 'processed'.");
                                    break;
                            }
                        } else {
                            System.err.println("Error: 'list' command requires one argument: list [pending|processed]");
                        }
                        break;

                    case "exit":
                        if (parts.length == 1) {
                           running = false;
                           System.out.println("Exiting Print Job Manager.");
                        } else {
                            System.err.println("Error: 'exit' command takes no arguments.");
                        }
                        break;

                    default:
                        System.err.println("Unknown command: " + command);
                        break;
                }
            } catch (Exception e) {
                // Catch any unexpected exceptions during the loop
                System.err.println("An unexpected error occurred: " + e.getMessage());
                // e.printStackTrace(); // Uncomment for debugging
            }
        }
        scanner.close(); // Close the scanner when exiting
    }

    /**
     * Main method to start the application.
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        PrintJobManager manager = new PrintJobManager();
        manager.run();
    }
}
