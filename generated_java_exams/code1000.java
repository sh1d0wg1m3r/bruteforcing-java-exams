/*
 * Exam Question #1000
 * Generated on: 2025-05-12 17:11:00
 * Generated by: Account 1
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Warehouse Task Management System
 * 
 * **Problem Description:**
 * 
 * You are tasked with developing a simple command-line application for managing tasks in a small warehouse. The system needs to keep track of incoming tasks that require specific items and the current inventory of available items. Tasks are processed in the order they are received (First-In, First-Out).
 * 
 * The system should allow users to perform the following actions via a menu:
 * 
 * 1.  **Add Item to Warehouse:** Add a new item name to the list of available items.
 * 2.  **Add Task to Queue:** Create a new task for preparing a specific item. A task can only be added if the required item is currently available in the warehouse. If a task is successfully added, the required item is consumed from the available stock.
 * 3.  **Process Next Task:** Take the oldest task from the queue and simulate processing it.
 * 4.  **View Task Queue:** Display all tasks currently waiting in the queue without removing them.
 * 5.  **View Available Items:** Display the list of items currently available in the warehouse.
 * 6.  **Exit:** Terminate the application.
 * 
 * **Requirements:**
 * 
 * Your solution must be a single Java application that demonstrates the following:
 * 
 * 1.  **Data Structures:**
 *     *   Use `java.util.Queue` to manage the tasks waiting for processing.
 *     *   Use `java.util.ArrayList` to store the list of available items.
 *     *   Declare the collection for available items using the `java.util.List` interface type.
 * 2.  **User Interaction:**
 *     *   Use `java.util.Scanner` to read user input (menu choices and item names) from the console.
 * 3.  **Control Flow:**
 *     *   Use a `switch` statement to handle the different menu options selected by the user.
 * 4.  **Output:**
 *     *   Use `System.out.println()` for displaying the menu, prompts, success messages, and list contents.
 *     *   Use `System.err.println()` for displaying all error messages (e.g., invalid input, item not available, queue empty).
 * 5.  **Error Handling:**
 *     *   Implement robust input validation.
 *     *   Use `try-catch` blocks for class-wide exception handling, specifically to catch potential errors during user input processing (like non-integer input for menu choices) and other runtime exceptions.
 *     *   Handle specific error conditions like trying to add a task for a non-existent item or trying to process a task when the queue is empty.
 * 6.  **Object-Oriented Design:**
 *     *   Create separate classes where appropriate (e.g., a `Task` class, a `Warehouse` class to manage the collections and logic, and a main application class).
 *     *   Apply proper encapsulation (private fields, public methods).
 *     *   Use meaningful names for classes, methods, and variables.
 *     *   Include appropriate comments and basic documentation (e.g., Javadoc for key methods).
 *     *   Ensure clean code structure.
 * 
 * **Expected Output:**
 * 
 * The program should present a menu to the user, accept input, perform the requested action, and display relevant status or error messages. Examples:
 * 
 * *   Adding an item: `Item added to available stock: [item name]`
 * *   Adding a task for an available item: `Task added for item: [item name]`
 * *   Attempting to add a task for an unavailable item: `Error: Item '[item name]' not available in the warehouse.` (to `System.err`)
 * *   Processing a task from a non-empty queue: `Processing task: Task [Prepare: [item name]]`
 * *   Attempting to process a task from an empty queue: `No tasks in the queue to process.` (to `System.err`)
 * *   Viewing an empty queue: `--- Task Queue ---` followed by `Queue is empty.`
 * *   Viewing a non-empty queue: List of tasks with numbering.
 * *   Viewing an empty items list: `--- Available Items ---` followed by `No items available.`
 * *   Viewing a non-empty items list: List of items with numbering.
 * *   Invalid menu input (non-integer): `Invalid input. Please enter a number.` (to `System.err`)
 * *   Invalid menu input (out of range): `Invalid choice. Please enter a number from the menu.` (to `System.err`)
 * *   Exiting: `Exiting system. Goodbye!`
 * 
 * Your solution should be complete and runnable.
 *
 * EXPLANATION:
 * This solution implements a simple Warehouse Task Management System demonstrating the required Java concepts and best practices.
 * 
 * 1.  **Structure:** The application is organized into three classes:
 *     *   `Task`: A simple class representing a unit of work, holding the name of the item it concerns. It encapsulates the item name with a private field and a public getter.
 *     *   `Warehouse`: This class acts as the core logic handler. It manages the two main data structures (`taskQueue` and `availableItems`) and provides methods for performing operations like adding items, adding tasks, processing tasks, and viewing the collections. This demonstrates encapsulation by keeping the collections private and exposing functionality through public methods.
 *     *   `WarehouseApp`: This is the main application class containing the `main` method. It handles user interaction via the `Scanner`, presents the menu, reads input, and calls the appropriate methods on the `Warehouse` object. The main application loop and the primary exception handling are located here.
 * 
 * 2.  **Required Components Usage:**
 *     *   `Queue`: The `taskQueue` in the `Warehouse` class is declared as `Queue<Task>` and initialized with a `LinkedList` instance, which is a common `Queue` implementation. Tasks are added using `offer()` and removed using `poll()`, adhering to the FIFO principle.
 *     *   `ArrayList`: The `availableItems` list in the `Warehouse` class is initialized as an `ArrayList<String>`. It's used to store and manage the dynamic collection of item names.
 *     *   `List interface`: `availableItems` is declared using the `List<String>` interface type, promoting good practice by programming to the interface rather than the concrete implementation.
 *     *   `Scanner`: An instance of `Scanner` is used in the `WarehouseApp` class to read user input from `System.in`. `nextLine()` is used to read entire lines, which helps avoid issues with leftover newline characters after reading numbers.
 *     *   `Switch statement`: The `run()` method in `WarehouseApp` uses a `switch` statement to direct the program flow based on the integer choice entered by the user from the menu.
 *     *   `System.err`: Used consistently in `Warehouse` methods (`addItem`, `addTask`, `processNextTask`) and in `WarehouseApp.run()` to print error messages to the standard error stream, separating them from normal output.
 *     *   `System.out`: Used for all normal output, including printing the menu, prompts, success messages, and the contents of the task queue and available items list.
 *     *   `try-catch`: A `try-catch` block wraps the input reading and `switch` statement within the main `while` loop in `WarehouseApp.run()`. This provides class-wide handling for potential `NumberFormatException` if the user enters non-integer input for the menu choice. It also includes a general `catch (Exception e)` to handle any other unexpected runtime errors that might occur within that block, preventing the application from crashing and printing an error message to `System.err`.
 * 
 * 3.  **Best Practices:**
 *     *   **Encapsulation:** Data fields (`taskQueue`, `availableItems`, `itemName`) are private. Access and modification are controlled through public methods.
 *     *   **Meaningful Names:** Class, method, and variable names are descriptive (e.g., `addTask`, `availableItems`, `viewTaskQueue`).
 *     *   **Comments and Documentation:** Basic Javadoc comments explain the purpose of classes and key methods.
 *     *   **Input Validation:** The `addItem` and `addTask` methods check for null or empty item names. The `try-catch` in `WarehouseApp.run()` validates that the menu input is an integer.
 *     *   **Error Handling:** Specific error messages are printed to `System.err` for business logic failures (item unavailable, queue empty) and input errors. `try-catch` handles parsing errors.
 *     *   **Clean Code Structure:** Logic is separated into distinct methods and classes. The `Warehouse` class handles the core domain logic, while `WarehouseApp` handles the user interface layer. The `printMenu` method keeps the `run` method cleaner.
 * 
 * This solution effectively combines the required Java components within a practical scenario, demonstrating an understanding of data structures, control flow, input/output, and exception handling in an object-oriented manner suitable for an advanced programming exam.
 */

import java.util.Queue;
import java.util.LinkedList;
import java.util.List;
import java.util.ArrayList;
import java.util.Scanner;
import java.util.Iterator;

/**
 * Represents a single task in the warehouse.
 */
class Task {
    private String itemName;

    /**
     * Constructs a new Task.
     * @param itemName The name of the item required for this task.
     */
    public Task(String itemName) {
        this.itemName = itemName;
    }

    /**
     * Gets the name of the item required for this task.
     * @return The item name.
     */
    public String getItemName() {
        return itemName;
    }

    @Override
    public String toString() {
        return "Task [Prepare: " + itemName + "]";
    }
}

/**
 * Manages the warehouse tasks and available items.
 */
class Warehouse {
    private Queue<Task> taskQueue;
    private List<String> availableItems;

    /**
     * Constructs a new Warehouse manager.
     */
    public Warehouse() {
        // Use LinkedList as a Queue implementation
        this.taskQueue = new LinkedList<>();
        // Use ArrayList for available items, declared as List interface
        this.availableItems = new ArrayList<>();
    }

    /**
     * Adds a new item to the list of available items.
     * @param itemName The name of the item to add. Must not be null or empty.
     * @return true if the item was added, false otherwise.
     */
    public boolean addItem(String itemName) {
        if (itemName == null || itemName.trim().isEmpty()) {
            System.err.println("Error: Item name cannot be empty.");
            return false;
        }
        // Trim whitespace and add the item
        availableItems.add(itemName.trim());
        System.out.println("Item added to available stock: " + itemName.trim());
        return true;
    }

    /**
     * Adds a new task to the queue if the required item is available.
     * Removes the item from the available list upon successful task creation.
     * @param itemName The name of the item required for the task. Must not be null or empty.
     * @return true if the task was added, false otherwise (e.g., item not available, invalid name).
     */
    public boolean addTask(String itemName) {
        if (itemName == null || itemName.trim().isEmpty()) {
            System.err.println("Error: Item name cannot be empty.");
            return false;
        }

        String itemToFind = itemName.trim();

        // Check if item is available and remove it atomically
        // List.remove(Object) searches for the object and removes the first occurrence
        if (availableItems.remove(itemToFind)) {
            Task newTask = new Task(itemToFind);
            // Offer is preferred over add for queues as it handles capacity constraints gracefully (though LinkedList doesn't have one)
            taskQueue.offer(newTask);
            System.out.println("Task added for item: " + itemToFind);
            return true;
        } else {
            // Use System.err for error messages
            System.err.println("Error: Item '" + itemToFind + "' not available in the warehouse.");
            return false;
        }
    }

    /**
     * Processes the next task in the queue (FIFO).
     * Removes the task from the queue.
     * @return The processed Task object, or null if the queue was empty.
     */
    public Task processNextTask() {
        // poll() retrieves and removes the head of the queue, or returns null if the queue is empty
        Task nextTask = taskQueue.poll();
        if (nextTask != null) {
            System.out.println("Processing task: " + nextTask);
            // In a real system, more processing logic would go here
            return nextTask;
        } else {
            // Use System.err for error messages
            System.err.println("No tasks in the queue to process.");
            return null;
        }
    }

    /**
     * Displays the current tasks in the queue without removing them.
     */
    public void viewTaskQueue() {
        System.out.println("\n--- Task Queue ---");
        if (taskQueue.isEmpty()) {
            System.out.println("Queue is empty.");
        } else {
            // Iterate through the queue. Using an Iterator or enhanced for loop is safe.
            int index = 1;
            Iterator<Task> iterator = taskQueue.iterator();
            while (iterator.hasNext()) {
                System.out.println(index++ + ". " + iterator.next());
            }
        }
        System.out.println("------------------");
    }

    /**
     * Displays the current list of available items.
     */
    public void viewAvailableItems() {
        System.out.println("\n--- Available Items ---");
        if (availableItems.isEmpty()) {
            System.out.println("No items available.");
        } else {
            // Iterate through the list using index
            for (int i = 0; i < availableItems.size(); i++) {
                 System.out.println((i + 1) + ". " + availableItems.get(i));
            }
        }
        System.out.println("-----------------------");
    }
}

/**
 * Main application class for the Warehouse Task Management System.
 * Handles user interaction and orchestrates operations via the Warehouse class.
 */
public class WarehouseApp {

    private Warehouse warehouse;
    private Scanner scanner;

    /**
     * Constructs a new WarehouseApp, initializing the Warehouse and Scanner.
     */
    public WarehouseApp() {
        this.warehouse = new Warehouse();
        this.scanner = new Scanner(System.in);
    }

    /**
     * Runs the main application loop, displaying the menu and processing user input.
     * Includes class-wide exception handling for input processing.
     */
    public void run() {
        System.out.println("--- Warehouse Task Management System ---");

        boolean running = true;
        // Main application loop
        while (running) {
            printMenu();
            int choice = -1; // Default invalid choice

            // Class-wide try-catch block for handling input errors in the main loop
            try {
                System.out.print("Enter your choice: ");
                // Read the entire line to consume the newline character after the number
                String inputLine = scanner.nextLine();
                choice = Integer.parseInt(inputLine); // Potential NumberFormatException

                // Switch statement for flow control based on user choice
                switch (choice) {
                    case 1: // Add Item
                        System.out.print("Enter item name to add: ");
                        String itemToAdd = scanner.nextLine();
                        warehouse.addItem(itemToAdd); // Method handles validation
                        break;
                    case 2: // Add Task
                        System.out.print("Enter item name for the task: ");
                        String itemForTask = scanner.nextLine();
                        warehouse.addTask(itemForTask); // Method handles validation and availability check
                        break;
                    case 3: // Process Next Task
                        warehouse.processNextTask(); // Method handles empty queue
                        break;
                    case 4: // View Task Queue
                        warehouse.viewTaskQueue();
                        break;
                    case 5: // View Available Items
                        warehouse.viewAvailableItems();
                        break;
                    case 0: // Exit
                        System.out.println("Exiting system. Goodbye!");
                        running = false;
                        break;
                    default:
                        // Use System.err for invalid input messages
                        System.err.println("Invalid choice. Please enter a number from the menu.");
                }
            } catch (NumberFormatException e) {
                // Handle cases where input is not a valid integer
                System.err.println("Invalid input. Please enter a number.");
                // The loop continues, prompting for input again
            } catch (Exception e) {
                // Catch any other unexpected runtime exceptions within the loop
                System.err.println("An unexpected error occurred: " + e.getMessage());
                // e.printStackTrace(); // Uncomment for debugging purposes
            }
            System.out.println(); // Add a blank line for readability between operations
        }

        // Close the scanner when the application exits
        scanner.close();
    }

    /**
     * Prints the main menu options to the console.
     */
    private void printMenu() {
        System.out.println("\n--- Menu ---");
        System.out.println("1. Add Item to Warehouse");
        System.out.println("2. Add Task to Queue (requires available item)");
        System.out.println("3. Process Next Task");
        System.out.println("4. View Task Queue");
        System.out.println("5. View Available Items");
        System.out.println("0. Exit");
        System.out.println("------------");
    }

    /**
     * Main entry point of the application.
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        // Create and run the application instance
        WarehouseApp app = new WarehouseApp();
        app.run();
    }
}
