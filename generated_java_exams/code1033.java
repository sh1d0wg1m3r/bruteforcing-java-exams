/*
 * Exam Question #1033
 * Generated on: 2025-05-12 17:15:38
 * Generated by: Account 5
 * 
 * QUESTION:
 * **Java Programming Exam Task: Advanced Task Management System**
 * 
 * You are tasked with developing a simple command-line application for managing tasks. The system should allow users to add new tasks, prioritize existing tasks, complete the next highest-priority task, and view lists of tasks.
 * 
 * Your solution must demonstrate a strong understanding of core Java collections, user input handling, control flow, and exception handling.
 * 
 * **Requirements:**
 * 
 * 1.  **Task Representation:** Create a `Task` class with private fields for a unique integer ID, a String description, and a String status (e.g., "Pending", "Prioritized", "Completed"). Include a constructor, getters, and a `toString()` method. The ID should be automatically generated sequentially.
 * 2.  **Task Management Logic:** Create a `TaskManager` class that manages the tasks.
 *     *   It must use a `java.util.List` (specifically an `ArrayList`) to store tasks that are newly added and are currently "Pending".
 *     *   It must use a `java.util.Queue` (specifically a `LinkedList` implementing the `Queue` interface) to store tasks that have been "Prioritized" and are waiting for completion.
 *     *   Implement methods for:
 *         *   `addTask(String description)`: Creates a new `Task` with "Pending" status and adds it to the pending list.
 *         *   `prioritizeTask(int taskId)`: Finds a task with the given ID in the pending list, removes it from the pending list, updates its status to "Prioritized", and adds it to the priority queue. This method must handle the case where the task ID is not found in the pending list.
 *         *   `completeNextTask()`: Removes and returns the task at the head of the priority queue. Updates its status to "Completed". This method must handle the case where the priority queue is empty.
 *         *   `getPendingTasks()`: Returns a `List` of all tasks currently in the pending list.
 *         *   `getPriorityTasks()`: Returns a `List` of all tasks currently in the priority queue (you will need to convert the Queue contents to a List for display).
 * 3.  **User Interface:** Create a main class (`TaskManagerApp`) with a `main` method.
 *     *   Use `java.util.Scanner` to read user input from the console.
 *     *   Present a menu of options to the user: Add Task, Prioritize Task, Complete Next Task, View Pending Tasks, View Priority Tasks, Exit.
 *     *   Use a `switch` statement to process the user's menu choice.
 *     *   Display normal output (menu, task details, success messages) using `System.out`.
 *     *   Display error messages using `System.err`.
 * 4.  **Error Handling:**
 *     *   Implement custom exceptions: `TaskNotFoundException` (for `prioritizeTask`) and `QueueEmptyException` (for `completeNextTask`).
 *     *   Use `try-catch` blocks in the main application loop to handle:
 *         *   `java.util.InputMismatchException` if the user enters non-integer input for menu choices or task IDs.
 *         *   Your custom exceptions (`TaskNotFoundException`, `QueueEmptyException`).
 *         *   A general `Exception` to catch any other unexpected errors.
 *     *   Provide informative error messages to the user via `System.err`.
 * 5.  **Best Practices:**
 *     *   Ensure proper encapsulation (private fields, public methods).
 *     *   Use meaningful variable and method names.
 *     *   Include appropriate comments (e.g., Javadoc for methods) and documentation.
 *     *   Include basic input validation (e.g., for task description).
 *     *   Structure the code clearly into appropriate classes.
 * 
 * **Expected Output:**
 * 
 * The program should run interactively. Users should see a menu, provide input, and receive feedback (success messages, task lists, or error messages) on the console. Examples:
 * 
 * ```
 * --- Task Management System ---
 * 
 * --- Menu ---
 * 1. Add New Task
 * 2. Prioritize Task (move from Pending to Priority)
 * 3. Complete Next Priority Task
 * 4. View Pending Tasks
 * 5. View Priority Tasks
 * 0. Exit
 * ------------
 * Enter your choice: 1
 * Enter task description: Write report
 * Added task: Task [ID=1, Desc='Write report', Status=Pending]
 * 
 * --- Menu ---
 * ...
 * Enter your choice: 1
 * Enter task description: Schedule meeting
 * Added task: Task [ID=2, Desc='Schedule meeting', Status=Pending]
 * 
 * --- Menu ---
 * ...
 * Enter your choice: 4
 * 
 * --- Pending Tasks ---
 * Task [ID=1, Desc='Write report', Status=Pending]
 * Task [ID=2, Desc='Schedule meeting', Status=Pending]
 * ------------
 * 
 * --- Menu ---
 * ...
 * Enter your choice: 2
 * Enter ID of task to prioritize: 1
 * Prioritized task: Task [ID=1, Desc='Write report', Status=Prioritized]
 * 
 * --- Menu ---
 * ...
 * Enter your choice: 4
 * 
 * --- Pending Tasks ---
 * Task [ID=2, Desc='Schedule meeting', Status=Pending]
 * ------------
 * 
 * --- Menu ---
 * ...
 * Enter your choice: 5
 * 
 * --- Priority Queue Tasks ---
 * Task [ID=1, Desc='Write report', Status=Prioritized]
 * ------------
 * 
 * --- Menu ---
 * ...
 * Enter your choice: 3
 * Completed task: Task [ID=1, Desc='Write report', Status=Completed]
 * 
 * --- Menu ---
 * ...
 * Enter your choice: 5
 * 
 * --- Priority Queue Tasks ---
 * No tasks found.
 * ------------
 * 
 * --- Menu ---
 * ...
 * Enter your choice: 3
 * Error: Priority queue is empty. No tasks to complete.
 * 
 * --- Menu ---
 * ...
 * Enter your choice: 9
 * Invalid choice. Please enter a number between 0 and 5.
 * 
 * --- Menu ---
 * ...
 * Enter your choice: abc
 * Invalid input. Please enter a number.
 * 
 * --- Menu ---
 * ...
 * Enter your choice: 0
 * Exiting Task Management System. Goodbye!
 * ```
 * 
 * Your solution should be a single `.java` file containing all necessary classes.
 *
 * EXPLANATION:
 * The provided solution implements a simple Task Management System demonstrating the required Java concepts and best practices.
 * 
 * **Class Structure:**
 * -   `Task`: A simple POJO (Plain Old Java Object) representing a task with an auto-generated ID, description, and status. Encapsulation is achieved using private fields and public getters.
 * -   `TaskNotFoundException` and `QueueEmptyException`: Custom exceptions extending `Exception` are defined to signal specific error conditions within the `TaskManager` logic.
 * -   `TaskManager`: This class encapsulates the core business logic and data structures.
 *     -   `pendingTasks`: An `ArrayList` is used to store tasks that are waiting to be prioritized. `ArrayList` is suitable here because we need to efficiently add tasks and iterate through them to find/remove a specific task by ID.
 *     -   `priorityQueue`: A `Queue` implemented by `LinkedList` is used to hold tasks ready for completion. `Queue` provides methods like `offer()` (add to end) and `poll()` (remove from front), which are appropriate for processing tasks in a specific order (FIFO in this case).
 *     -   Methods like `addTask`, `prioritizeTask`, and `completeNextTask` manage the flow of tasks between these structures and update their status. `prioritizeTask` uses an `Iterator` to safely remove an element from the `pendingTasks` `ArrayList` while iterating. `getPendingTasks` and `getPriorityTasks` return `List` interfaces, adhering to the requirement and good practice, returning copies to protect the internal state.
 * -   `TaskManagerApp`: This is the main application class containing the `main` method. It handles the user interface, reads input using `Scanner`, processes menu choices using a `switch` statement, and manages the overall application flow.
 * 
 * **Required Components Usage:**
 * -   `java.util.Queue`: Used for `priorityQueue` in `TaskManager`.
 * -   `java.util.ArrayList`: Used for `pendingTasks` in `TaskManager` and for creating `List` copies in getter methods.
 * -   `java.util.List`: Used as the type for `pendingTasks` and as the return type for `getPendingTasks` and `getPriorityTasks`.
 * -   `java.util.Scanner`: Used in `TaskManagerApp` to read user input from `System.in`.
 * -   `switch` statement: Used in `TaskManagerApp.run()` to handle the different menu options.
 * -   `System.err`: Used in `TaskManagerApp` (and a basic check in `TaskManager`) to print error messages, such as invalid input, task not found, or queue empty conditions.
 * -   `System.out`: Used throughout `TaskManagerApp` and `TaskManager` for displaying the menu, prompts, success messages, and task details.
 * -   `try-catch` blocks: A comprehensive `try-catch` block is used in the `TaskManagerApp.run()` method to wrap the main logic within the loop. This block catches specific exceptions like `InputMismatchException` (for incorrect input types), the custom `TaskNotFoundException`, and `QueueEmptyException`, providing targeted error messages. A general `catch (Exception e)` is included as a fallback for any other unexpected runtime errors, demonstrating robust handling.
 * 
 * **Best Practices:**
 * -   **Encapsulation:** Fields in `Task` and `TaskManager` are private, accessed via public methods.
 * -   **Meaningful Names:** Class names, variable names (`pendingTasks`, `priorityQueue`, `taskIdToPrioritize`), and method names (`addTask`, `prioritizeTask`, `completeNextTask`, `printMenu`) are descriptive.
 * -   **Comments and Documentation:** Javadoc comments explain the purpose of classes and methods. Inline comments clarify specific logic (like iterator usage or scanner newline consumption).
 * -   **Input Validation:** Basic validation for an empty task description is included in `addTask`. The `try-catch` block in `TaskManagerApp` handles invalid input format for numbers.
 * -   **Error Handling:** Custom exceptions provide clarity on error types. `System.err` is used for errors. The `try-catch` structure is layered to handle specific and general exceptions.
 * -   **Clean Code Structure:** The code is organized into logical classes, separating data representation (`Task`), business logic (`TaskManager`), and the user interface/application flow (`TaskManagerApp`). Methods are focused on single responsibilities.
 * 
 * This solution effectively integrates the required Java components into a practical scenario, demonstrating key programming concepts like object-oriented design, data structures, user interaction, and comprehensive exception handling within a clean and well-documented structure.
 */

import java.util.ArrayList;
import java.util.InputMismatchException;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.Iterator;

// Custom Exception for Task Not Found
class TaskNotFoundException extends Exception {
    public TaskNotFoundException(String message) {
        super(message);
    }
}

// Custom Exception for Queue Empty
class QueueEmptyException extends Exception {
    public QueueEmptyException(String message) {
        super(message);
    }
}

/**
 * Represents a single task in the task management system.
 */
class Task {
    private static int nextId = 1; // Static counter for unique IDs
    private int id;
    private String description;
    private String status; // e.g., "Pending", "Prioritized", "Completed"

    /**
     * Constructs a new Task with a unique ID and "Pending" status.
     * @param description The description of the task.
     */
    public Task(String description) {
        this.id = nextId++; // Assign unique ID and increment counter
        this.description = description;
        this.status = "Pending";
    }

    // --- Getters ---
    public int getId() {
        return id;
    }

    public String getDescription() {
        return description;
    }

    public String getStatus() {
        return status;
    }

    // --- Setter (used internally by TaskManager) ---
    public void setStatus(String status) {
        this.status = status;
    }

    /**
     * Returns a string representation of the Task.
     */
    @Override
    public String toString() {
        return "Task [ID=" + id + ", Desc='" + description + "', Status=" + status + "]";
    }
}

/**
 * Manages a collection of tasks, separating them into pending and prioritized queues.
 */
class TaskManager {
    // Using ArrayList for pending tasks (easy to search/remove by ID)
    private List<Task> pendingTasks;
    // Using LinkedList as a Queue for prioritized tasks (FIFO or processing order)
    private Queue<Task> priorityQueue;

    /**
     * Constructs a new TaskManager with empty task lists.
     */
    public TaskManager() {
        pendingTasks = new ArrayList<>();
        priorityQueue = new LinkedList<>();
    }

    /**
     * Adds a new task to the pending list.
     * Performs basic validation on the description.
     * @param description The task description.
     */
    public void addTask(String description) {
        if (description == null || description.trim().isEmpty()) {
             System.err.println("Task description cannot be empty.");
             return; // Do not add task if description is invalid
        }
        Task newTask = new Task(description);
        pendingTasks.add(newTask);
        System.out.println("Added task: " + newTask);
    }

    /**
     * Moves a task from the pending list to the priority queue.
     * Searches for the task by ID in the pending list.
     * @param taskId The ID of the task to prioritize.
     * @throws TaskNotFoundException if the task with the given ID is not found in the pending list.
     */
    public void prioritizeTask(int taskId) throws TaskNotFoundException {
        Task taskToPrioritize = null;
        // Use iterator for safe removal while iterating
        Iterator<Task> iterator = pendingTasks.iterator();
        while (iterator.hasNext()) {
            Task task = iterator.next();
            if (task.getId() == taskId) {
                taskToPrioritize = task;
                iterator.remove(); // Safely remove the task from pendingTasks
                break; // Task found and removed, exit loop
            }
        }

        if (taskToPrioritize == null) {
            // Task not found in the pending list
            throw new TaskNotFoundException("Task with ID " + taskId + " not found in the pending list.");
        }

        // Update status and add to priority queue
        taskToPrioritize.setStatus("Prioritized");
        priorityQueue.offer(taskToPrioritize); // offer is a safe way to add to a queue
        System.out.println("Prioritized task: " + taskToPrioritize);
    }

    /**
     * Completes the next task in the priority queue.
     * Retrieves and removes the head of the queue.
     * @return The completed task.
     * @throws QueueEmptyException if the priority queue is empty.
     */
    public Task completeNextTask() throws QueueEmptyException {
        if (priorityQueue.isEmpty()) {
            throw new QueueEmptyException("Priority queue is empty. No tasks to complete.");
        }
        // poll() retrieves and removes the head of the queue, returns null if empty (handled by isEmpty check)
        Task completedTask = priorityQueue.poll();
        if (completedTask != null) {
             completedTask.setStatus("Completed");
             System.out.println("Completed task: " + completedTask);
        }
        return completedTask;
    }

    /**
     * Returns a list of tasks currently in the pending list.
     * Returns a copy to prevent external modification of the internal list.
     * @return A List of pending tasks.
     */
    public List<Task> getPendingTasks() {
        // Return a new ArrayList containing elements from pendingTasks
        return new ArrayList<>(pendingTasks);
    }

     /**
     * Returns a list of tasks currently in the priority queue.
     * Converts the Queue contents to a List for display.
     * @return A List of priority tasks.
     */
    public List<Task> getPriorityTasks() {
        // Return a new ArrayList containing elements from priorityQueue
        return new ArrayList<>(priorityQueue);
    }
}

/**
 * Main application class for the Task Management System.
 * Handles user interaction, menu display, and exception handling.
 */
public class TaskManagerApp {

    private TaskManager taskManager;
    private Scanner scanner;

    /**
     * Constructs the TaskManagerApp, initializing the TaskManager and Scanner.
     */
    public TaskManagerApp() {
        taskManager = new TaskManager();
        scanner = new Scanner(System.in);
    }

    /**
     * Runs the main application loop, displaying the menu and processing user input.
     * Includes class-wide exception handling for input and application logic errors.
     */
    public void run() {
        System.out.println("--- Task Management System ---");
        int choice = -1; // Initialize choice to a non-exit value

        // Main application loop
        while (choice != 0) {
            printMenu();
            try {
                System.out.print("Enter your choice: ");
                // Read the integer choice
                choice = scanner.nextInt();
                // Consume the rest of the line after the integer input
                scanner.nextLine();

                // Process the user's choice using a switch statement
                switch (choice) {
                    case 1:
                        System.out.print("Enter task description: ");
                        String description = scanner.nextLine();
                        taskManager.addTask(description);
                        break;
                    case 2:
                        System.out.print("Enter ID of task to prioritize: ");
                        int taskIdToPrioritize = scanner.nextInt();
                        scanner.nextLine(); // Consume newline after integer
                        taskManager.prioritizeTask(taskIdToPrioritize);
                        break;
                    case 3:
                        // completeNextTask handles its own success/error output
                        taskManager.completeNextTask();
                        break;
                    case 4:
                        displayTasks("Pending Tasks", taskManager.getPendingTasks());
                        break;
                    case 5:
                        displayTasks("Priority Queue Tasks", taskManager.getPriorityTasks());
                        break;
                    case 0:
                        System.out.println("Exiting Task Management System. Goodbye!");
                        break;
                    default:
                        // Handle invalid menu choices
                        System.err.println("Invalid choice. Please enter a number between 0 and 5.");
                }
            } catch (InputMismatchException e) {
                // Catch specific exception for non-integer input
                System.err.println("Invalid input. Please enter a number.");
                scanner.nextLine(); // IMPORTANT: Consume the invalid input to prevent infinite loop
                choice = -1; // Reset choice to ensure loop continues
            } catch (TaskNotFoundException e) {
                // Catch custom exception for task not found during prioritization
                System.err.println("Error: " + e.getMessage());
            } catch (QueueEmptyException e) {
                // Catch custom exception for completing task from empty queue
                System.err.println("Error: " + e.getMessage());
            } catch (Exception e) {
                // Catch any other unexpected runtime exceptions
                System.err.println("An unexpected error occurred: " + e.getMessage());
                // e.printStackTrace(); // Uncomment for detailed debugging output in exam
            }
            System.out.println(); // Add a newline for better readability between menu interactions
        }

        // Close the scanner when the application exits
        scanner.close();
    }

    /**
     * Prints the main menu options to the console.
     */
    private void printMenu() {
        System.out.println("\n--- Menu ---");
        System.out.println("1. Add New Task");
        System.out.println("2. Prioritize Task (move from Pending to Priority)");
        System.out.println("3. Complete Next Priority Task");
        System.out.println("4. View Pending Tasks");
        System.out.println("5. View Priority Tasks");
        System.out.println("0. Exit");
        System.out.println("------------");
    }

    /**
     * Displays a list of tasks with a given title.
     * @param title The title for the list display.
     * @param tasks The list of tasks to display.
     */
    private void displayTasks(String title, List<Task> tasks) {
        System.out.println("\n--- " + title + " ---");
        if (tasks.isEmpty()) {
            System.out.println("No tasks found.");
        } else {
            for (Task task : tasks) {
                System.out.println(task);
            }
        }
        System.out.println("------------");
    }

    /**
     * The entry point of the application.
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        TaskManagerApp app = new TaskManagerApp();
        app.run(); // Start the application
    }
}
