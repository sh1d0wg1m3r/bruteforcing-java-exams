/*
 * Exam Question #894
 * Generated on: 2025-05-12 16:56:15
 * Generated by: Account 3
 * 
 * QUESTION:
 * Subject: Advanced Java Programming
 * Duration: 60 minutes
 * 
 * **Task: Advanced Order Processing System**
 * 
 * Design and implement a console-based application that simulates a simple order processing system. The system should manage orders that are submitted and then processed in a First-In, First-Out (FIFO) manner.
 * 
 * Your solution must adhere to the following requirements:
 * 
 * 1.  **Order Representation:** Create a class named `Order` with private fields for `id` (an integer), `description` (a String, e.g., "Laptop and mouse"), and `status` (an enum, `OrderStatus`, with values `PENDING` and `PROCESSED`). Include a constructor and public getter methods for these fields, and a method to update the status.
 * 2.  **System Management:** Create a class named `OrderProcessingSystem` that manages the orders.
 *     *   It must use a `java.util.Queue<Order>` to hold orders that are waiting to be processed (`PENDING`).
 *     *   It must use a `java.util.List<Order>` (specifically an `ArrayList`) to store orders that have been processed (`PROCESSED`). Declare the variable using the `List` interface type.
 *     *   Implement methods:
 *         *   `addOrder(String description)`: Creates a new `Order` with a unique ID, sets its status to `PENDING`, and adds it to the pending queue. Input description must not be empty.
 *         *   `processNextOrder()`: Takes the next available order from the pending queue (FIFO), updates its status to `PROCESSED`, and moves it to the processed list. Handle the case where the pending queue is empty.
 *         *   `getPendingOrders()`: Returns a `List<Order>` containing the current pending orders (for display purposes).
 *         *   `getProcessedOrders()`: Returns a `List<Order>` containing the current processed orders (for display purposes).
 * 3.  **User Interface:** Implement a console-based menu in the `main` method of a class named `AdvancedOrderProcessor`. The menu should offer the following options:
 *     *   1. Add New Order
 *     *   2. Process Next Order
 *     *   3. View Pending Orders
 *     *   4. View Processed Orders
 *     *   5. Exit
 * 4.  **Input Handling:** Use `java.util.Scanner` to read user input for menu choices and order descriptions.
 * 5.  **Control Flow:** Use a `switch` statement to handle the different menu options.
 * 6.  **Error Handling:**
 *     *   Use `System.err` to print error messages (e.g., invalid menu input, empty description, attempting to process an empty queue).
 *     *   Use `System.out` for all other output (menu, prompts, success messages, displaying order details).
 *     *   Implement class-wide exception handling using `try-catch` blocks. At minimum, handle `InputMismatchException` for menu input and include a broader catch for unexpected errors within the main application loop.
 * 7.  **Best Practices:** Follow best practices including proper encapsulation, meaningful names, and clear code structure. Include basic comments or documentation where necessary.
 * 
 * **Expected Output:**
 * The program should present the menu, accept user input, perform the requested action, and print appropriate messages.
 * Example interaction:
 * ```
 * --- Order Processing Menu ---
 * 1. Add New Order
 * 2. Process Next Order
 * 3. View Pending Orders
 * 4. View Processed Orders
 * 5. Exit
 * ---------------------------
 * Enter choice: 1
 * Enter order description: Buy groceries
 * Order 1 added to the queue.
 * 
 * --- Order Processing Menu ---
 * ...
 * Enter choice: 1
 * Enter order description: Pay bills
 * Order 2 added to the queue.
 * 
 * --- Order Processing Menu ---
 * ...
 * Enter choice: 3
 * 
 * --- Pending Orders ---
 * Order [ID=1, Description='Buy groceries', Status=PENDING]
 * Order [ID=2, Description='Pay bills', Status=PENDING]
 * ----------------------
 * 
 * --- Order Processing Menu ---
 * ...
 * Enter choice: 2
 * Order 1 processed successfully.
 * 
 * --- Order Processing Menu ---
 * ...
 * Enter choice: 3
 * 
 * --- Pending Orders ---
 * Order [ID=2, Description='Pay bills', Status=PENDING]
 * ----------------------
 * 
 * --- Order Processing Menu ---
 * ...
 * Enter choice: 4
 * 
 * --- Processed Orders ---
 * Order [ID=1, Description='Buy groceries', Status=PROCESSED]
 * ----------------------
 * 
 * --- Order Processing Menu ---
 * ...
 * Enter choice: 2
 * Order 2 processed successfully.
 * 
 * --- Order Processing Menu ---
 * ...
 * Enter choice: 2
 * Error: No pending orders to process.
 * 
 * --- Order Processing Menu ---
 * ...
 * Enter choice: 6
 * Invalid choice. Please enter a number between 1 and 5.
 * 
 * --- Order Processing Menu ---
 * ...
 * Enter choice: abc
 * Invalid input. Please enter a number.
 * 
 * --- Order Processing Menu ---
 * ...
 * Enter choice: 5
 * Exiting Order Processing System.
 * ```
 * 
 * Your code should compile and run, demonstrating the correct usage of all required Java components and adhering to the specified requirements.
 *
 * EXPLANATION:
 * The provided solution implements a simple console-based Order Processing System, demonstrating the required Java concepts and best practices.
 * 
 * **Key Components and Concepts Demonstrated:**
 * 
 * 1.  **`Queue` (`java.util.Queue`)**: The `OrderProcessingSystem` class uses a `Queue<Order>` (`pendingOrders`) implemented by `java.util.LinkedList`. This structure correctly models the requirement for pending orders to be processed in a First-In, First-Out (FIFO) order. The `offer()` method is used for adding orders, and the `poll()` method is used for retrieving and removing the next order to be processed.
 * 2.  **`ArrayList` (`java.util.ArrayList`)**: The `OrderProcessingSystem` uses an `ArrayList<Order>` (`processedOrders`) to store orders once they have been processed. `ArrayList` provides dynamic resizing and efficient element access, suitable for storing a growing collection of processed items.
 * 3.  **`List` interface (`java.util.List`)**: The `processedOrders` field and the return types of `getPendingOrders()` and `getProcessedOrders()` methods are declared using the `List` interface (`List<Order>`). This promotes good practice by programming to the interface rather than the concrete implementation (`ArrayList`), allowing for easier changes to the underlying list implementation in the future if needed.
 * 4.  **`Scanner` (`java.util.Scanner`)**: The `main` method in `AdvancedOrderProcessor` uses `Scanner` to read user input from the console for menu choices and order descriptions.
 * 5.  **`Switch` statement**: A `switch` statement in the `main` method is used to control the application flow based on the user's integer menu choice, directing execution to the appropriate logic for each option.
 * 6.  **`System.err`**: Error messages, such as invalid user input (non-integer or out of range choice), attempting to process an empty queue, or providing an empty order description, are printed to `System.err` to distinguish them from normal application output.
 * 7.  **`System.out`**: All standard output, including the menu, prompts for input, success messages (order added, order processed), and the display of order details, is printed to `System.out`.
 * 8.  **Class-wide `try-catch`**: The main application loop (`while(running)`) is wrapped in a `try-catch` block. Additionally, an inner `try-catch` block specifically handles potential `InputMismatchException` when reading the integer menu choice. This layered approach demonstrates handling specific anticipated errors (like bad input) and a broader catch for any unexpected runtime exceptions that might occur within the loop's execution. A `finally` block ensures the `Scanner` resource is closed.
 * 9.  **Encapsulation**: The `Order` and `OrderProcessingSystem` classes have private fields (`id`, `description`, `status`, `pendingOrders`, `processedOrders`, `nextOrderId`) and public methods (`get...`, `set...`, `addOrder`, `processNextOrder`) to control access and manage internal state, adhering to encapsulation principles.
 * 10. **Meaningful Names**: Variables (`pendingOrders`, `orderToProcess`, `description`), methods (`addOrder`, `processNextOrder`, `getPendingOrders`, `printMenu`), and classes (`Order`, `OrderProcessingSystem`, `AdvancedOrderProcessor`) are given descriptive names that reflect their purpose.
 * 11. **Input Validation**: The `addOrder` method checks if the provided description is null or empty, printing an error to `System.err` if it's invalid. The menu input handling specifically catches `InputMismatchException` and consumes the invalid input, preventing an infinite loop.
 * 12. **Error Handling**: Specific error conditions like processing an empty queue are explicitly checked for, and informative messages are printed to `System.err`. The `try-catch` blocks provide robustness against runtime issues.
 * 13. **Clean Code Structure**: The code is organized into separate classes (`Order`, `OrderStatus`, `OrderProcessingSystem`, `AdvancedOrderProcessor`) with specific responsibilities. The `main` method focuses on the user interface loop and delegates business logic to the `OrderProcessingSystem` class. Methods are kept relatively short and focused.
 * 
 * The solution effectively integrates the required Java components within a practical scenario, demonstrating understanding of data structures, object-oriented design, user input handling, and robust error management in Java.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.InputMismatchException;

/**
 * Represents the status of an order.
 */
enum OrderStatus {
    PENDING,
    PROCESSED
}

/**
 * Represents a single order in the system.
 */
class Order {
    private int id;
    private String description;
    private OrderStatus status;

    /**
     * Constructs a new Order.
     * @param id The unique ID of the order.
     * @param description A description of the order.
     */
    public Order(int id, String description) {
        this.id = id;
        this.description = description;
        this.status = OrderStatus.PENDING; // New orders are always pending
    }

    // --- Getters ---
    public int getId() {
        return id;
    }

    public String getDescription() {
        return description;
    }

    public OrderStatus getStatus() {
        return status;
    }

    // --- Setter for status ---
    public void setStatus(OrderStatus status) {
        this.status = status;
    }

    /**
     * Provides a string representation of the Order.
     */
    @Override
    public String toString() {
        return "Order [ID=" + id + ", Description='" + description + "', Status=" + status + "]";
    }
}

/**
 * Manages the collection of pending and processed orders.
 */
class OrderProcessingSystem {
    // Queue for orders waiting to be processed (FIFO)
    private Queue<Order> pendingOrders;
    // List for orders that have been processed
    private List<Order> processedOrders;
    // Counter for generating unique order IDs
    private int nextOrderId;

    /**
     * Constructs a new OrderProcessingSystem.
     */
    public OrderProcessingSystem() {
        // Use LinkedList as it implements the Queue interface
        this.pendingOrders = new LinkedList<>();
        // Use ArrayList as required, declared using the List interface
        this.processedOrders = new ArrayList<>();
        this.nextOrderId = 1; // Start order IDs from 1
    }

    /**
     * Adds a new order to the pending queue.
     * @param description The description of the order.
     */
    public void addOrder(String description) {
        if (description == null || description.trim().isEmpty()) {
            System.err.println("Error: Order description cannot be empty.");
            return; // Exit method if description is invalid
        }
        // Create new order with unique ID and PENDING status
        Order newOrder = new Order(nextOrderId++, description.trim());
        // Add the order to the end of the pending queue
        pendingOrders.offer(newOrder); // offer is generally preferred over add for queues
        System.out.println("Order " + newOrder.getId() + " added to the queue.");
    }

    /**
     * Processes the next order from the pending queue.
     * Moves the order to the processed list and updates its status.
     */
    public void processNextOrder() {
        // Check if there are any pending orders
        if (pendingOrders.isEmpty()) {
            System.err.println("Error: No pending orders to process.");
            return; // Exit method if queue is empty
        }

        // Retrieve and remove the head of the queue (FIFO)
        Order orderToProcess = pendingOrders.poll();

        // This check is technically redundant if isEmpty() is true, but good practice
        if (orderToProcess != null) {
            // Update the order's status
            orderToProcess.setStatus(OrderStatus.PROCESSED);
            // Add the processed order to the list of processed orders
            processedOrders.add(orderToProcess);
            System.out.println("Order " + orderToProcess.getId() + " processed successfully.");
        } else {
            // Should not happen if queue was not empty, indicates an unexpected state
             System.err.println("Internal error: Failed to retrieve order from queue.");
        }
    }

    /**
     * Returns a list of all pending orders.
     * Creates a new list to avoid external modification of the internal queue state.
     * @return A List of pending Orders.
     */
    public List<Order> getPendingOrders() {
        // Copy elements from the queue to a new ArrayList for display
        return new ArrayList<>(pendingOrders);
    }

    /**
     * Returns a list of all processed orders.
     * Creates a new list to avoid external modification of the internal list state.
     * @return A List of processed Orders.
     */
    public List<Order> getProcessedOrders() {
        // Copy elements from the processed list to a new ArrayList for display
        return new ArrayList<>(processedOrders);
    }
}

/**
 * Main class for the Advanced Order Processing System application.
 * Handles user interaction and menu control.
 */
public class AdvancedOrderProcessor {

    /**
     * Prints the main menu options to the console.
     */
    private static void printMenu() {
        System.out.println("--- Order Processing Menu ---");
        System.out.println("1. Add New Order");
        System.out.println("2. Process Next Order");
        System.out.println("3. View Pending Orders");
        System.out.println("4. View Processed Orders");
        System.out.println("5. Exit");
        System.out.println("---------------------------");
    }

    /**
     * The main entry point of the application.
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        // Use Scanner for reading user input
        Scanner scanner = new Scanner(System.in);
        // Instantiate the order processing system
        OrderProcessingSystem orderSystem = new OrderProcessingSystem();
        boolean running = true;

        // Class-wide exception handling for the main application loop
        // This catches any unexpected exceptions that might not be handled by specific catches inside the loop.
        try {
            while (running) {
                printMenu();
                System.out.print("Enter choice: ");

                // Inner try-catch block specifically for handling input errors
                try {
                    int choice = scanner.nextInt();
                    scanner.nextLine(); // Consume the newline character left by nextInt()

                    // Use a switch statement to handle different menu options
                    switch (choice) {
                        case 1: // Add Order
                            System.out.print("Enter order description: ");
                            String description = scanner.nextLine();
                            orderSystem.addOrder(description); // Delegate to OrderProcessingSystem
                            break;
                        case 2: // Process Next Order
                            orderSystem.processNextOrder(); // Delegate to OrderProcessingSystem
                            break;
                        case 3: // View Pending Orders
                            List<Order> pending = orderSystem.getPendingOrders(); // Get list via interface
                            if (pending.isEmpty()) {
                                System.out.println("No pending orders.");
                            } else {
                                System.out.println("\n--- Pending Orders ---");
                                // Iterate and print each pending order
                                for (Order order : pending) {
                                    System.out.println(order); // Uses Order's toString()
                                }
                                System.out.println("----------------------");
                            }
                            break;
                        case 4: // View Processed Orders
                             List<Order> processed = orderSystem.getProcessedOrders(); // Get list via interface
                             if (processed.isEmpty()) {
                                System.out.println("No processed orders.");
                            } else {
                                System.out.println("\n--- Processed Orders ---");
                                // Iterate and print each processed order
                                for (Order order : processed) {
                                    System.out.println(order); // Uses Order's toString()
                                }
                                System.out.println("----------------------");
                            }
                            break;
                        case 5: // Exit
                            running = false; // Set flag to exit loop
                            System.out.println("Exiting Order Processing System.");
                            break;
                        default:
                            // Handle invalid integer input within the valid range
                            System.err.println("Invalid choice. Please enter a number between 1 and 5.");
                    }
                } catch (InputMismatchException e) {
                    // Handle non-integer input specifically using System.err
                    System.err.println("Invalid input. Please enter a number.");
                    scanner.nextLine(); // IMPORTANT: Consume the invalid input to prevent infinite loop
                } catch (Exception e) {
                    // Catch any other unexpected runtime exceptions during an operation
                    System.err.println("An unexpected error occurred during operation: " + e.getMessage());
                    // e.printStackTrace(); // Uncomment for detailed debugging information
                }
                System.out.println(); // Print a blank line for better readability between menu cycles
            }
        } catch (Exception mainLoopException) {
            // This outer catch block catches exceptions that might occur outside the inner try-catch
            // or escape it, demonstrating the requirement for class-wide handling.
            System.err.println("A critical error occurred in the main application loop: " + mainLoopException.getMessage());
            // mainLoopException.printStackTrace(); // Uncomment for detailed debugging
        } finally {
            // Ensure the Scanner resource is closed when the application exits
            scanner.close();
            System.out.println("Scanner closed.");
        }
    }
}
