/*
 * Exam Question #709
 * Generated on: 2025-05-12 16:28:42
 * Generated by: Account 3
 * 
 * QUESTION:
 * **Advanced Java Programming Exam - Hospital Appointment Management System**
 * 
 * **Problem Description:**
 * 
 * Design and implement a simplified Hospital Appointment Management System in Java. The system should allow managing patient records and scheduling/processing appointments.
 * 
 * **Requirements:**
 * 
 * 1.  **Patient Management:**
 *     *   Maintain a list of registered patients. Each patient should have a unique integer ID, a name, and an age.
 *     *   Provide functionality to register a new patient.
 *     *   Provide functionality to view all registered patients.
 * 
 * 2.  **Appointment Scheduling:**
 *     *   Maintain a queue of appointments waiting to be processed.
 *     *   An appointment is associated with a registered patient.
 *     *   Provide functionality to schedule an appointment for an *existing* patient. The system should prompt for the patient ID and add the corresponding patient object to the appointment queue.
 *     *   If the patient ID does not exist, an appropriate error message should be displayed.
 * 
 * 3.  **Appointment Processing:**
 *     *   Provide functionality to "process" the next appointment. This simulates a doctor seeing the next patient in the queue.
 *     *   Processing an appointment should remove the patient from the front of the queue.
 *     *   If the queue is empty, an appropriate message should be displayed.
 * 
 * 4.  **System Interaction:**
 *     *   The system should present a menu-driven interface to the user using `System.out`.
 *     *   The user should be able to choose from options like:
 *         *   Register Patient
 *         *   View Patients
 *         *   Schedule Appointment
 *         *   Process Next Appointment
 *         *   View Appointment Queue
 *         *   Exit
 *     *   Use `Scanner` to read user input for menu choices and patient/appointment details.
 * 
 * 5.  **Technical Requirements:**
 *     *   You **must** use a `java.util.Queue` (specifically `LinkedList` implementing `Queue`) to manage the appointment queue.
 *     *   You **must** use a `java.util.ArrayList` to store the registered patients.
 *     *   You **must** declare the patient collection using the `java.util.List` interface type.
 *     *   You **must** use a `switch` statement to handle the main menu options.
 *     *   You **must** use `System.err` for displaying error messages (e.g., invalid input, patient not found, queue empty).
 *     *   You **must** use `System.out` for displaying the menu, prompts, success messages, and data listings.
 *     *   Implement robust exception handling using `try-catch` blocks, particularly for handling invalid user input (e.g., non-integer input when an integer is expected) and potential operational errors (like trying to schedule a non-existent patient or processing an empty queue). This exception handling should cover potential issues within the main operational loop.
 * 
 * 6.  **Best Practices:**
 *     *   Use meaningful variable and method names.
 *     *   Implement proper encapsulation (private fields, public methods) for the `Patient` class and the main system class.
 *     *   Include basic comments or Javadoc where necessary to explain logic.
 *     *   Perform input validation where appropriate (e.g., checking if patient ID exists).
 * 
 * **Expected Output:**
 * 
 * The system should run interactively, displaying a menu, prompting for input, and providing feedback or results based on user actions. Error conditions should be reported via `System.err`. Data listings and successful operations should use `System.out`.
 * 
 * Example Interaction Flow:
 * 
 * ```
 * --- Hospital Appointment System Menu ---
 * 1. Register Patient
 * 2. View Patients
 * 3. Schedule Appointment
 * 4. Process Next Appointment
 * 5. View Appointment Queue
 * 6. Exit
 * Enter your choice: 1
 * Enter patient ID: 101
 * Enter patient name: Alice
 * Enter patient age: 30
 * Patient registered successfully!
 * 
 * --- Hospital Appointment System Menu ---
 * ...
 * Enter your choice: 1
 * Enter patient ID: 102
 * Enter patient name: Bob
 * Enter patient age: 45
 * Patient registered successfully!
 * 
 * --- Hospital Appointment System Menu ---
 * ...
 * Enter your choice: 2
 * --- Registered Patients ---
 * ID: 101, Name: Alice, Age: 30
 * ID: 102, Name: Bob, Age: 45
 * -------------------------
 * 
 * --- Hospital Appointment System Menu ---
 * ...
 * Enter your choice: 3
 * Enter patient ID to schedule appointment: 101
 * Appointment scheduled for patient: Alice (ID: 101)
 * 
 * --- Hospital Appointment System Menu ---
 * ...
 * Enter your choice: 3
 * Enter patient ID to schedule appointment: 999
 * Error: Patient with ID 999 not found.
 * 
 * --- Hospital Appointment System Menu ---
 * ...
 * Enter your choice: 5
 * --- Appointment Queue ---
 * Patient ID: 101, Name: Alice
 * -------------------------
 * 
 * --- Hospital Appointment System Menu ---
 * ...
 * Enter your choice: 4
 * Processing appointment for patient: Alice (ID: 101)
 * Queue is now empty.
 * 
 * --- Hospital Appointment System Menu ---
 * ...
 * Enter your choice: 4
 * Error: Appointment queue is empty.
 * 
 * --- Hospital Appointment System Menu ---
 * ...
 * Enter your choice: 6
 * Exiting system.
 * ```
 * 
 * Your solution should be a single Java file containing all necessary classes.
 *
 * EXPLANATION:
 * The provided solution implements a basic Hospital Appointment Management System, fulfilling all the requirements of the exam question.
 * 
 * **Key Concepts Demonstrated:**
 * 
 * 1.  **`List` and `ArrayList`:** The `registeredPatients` collection is declared as a `List<Patient>` but instantiated as an `ArrayList<Patient>`. This demonstrates the use of the `List` interface, promoting flexibility and good practice by programming to an interface rather than a concrete implementation. `ArrayList` is used for its efficient storage and retrieval of elements by index, suitable for managing a list of registered patients where viewing or finding by ID (via iteration) is common.
 * 2.  **`Queue` and `LinkedList`:** The `appointmentQueue` collection is declared as a `Queue<Patient>` and instantiated as a `LinkedList<Patient>`. `LinkedList` is a common implementation of the `Queue` interface in Java, suitable for scenarios where elements are added to one end (`offer`) and removed from the other (`poll`) efficiently, perfectly modeling a waiting line or queue for appointments.
 * 3.  **`Scanner` for User Input:** The `java.util.Scanner` class is used to read user input from `System.in`, enabling the interactive menu-driven interface. It reads different data types (integers and strings) based on the prompts.
 * 4.  **`switch` Statement:** A `switch` statement is used in the `run()` method to handle the main menu selections, providing a clear and structured way to dispatch different actions based on the user's numerical input.
 * 5.  **`System.out` and `System.err`:** `System.out.println` and `System.out.print` are used for displaying the menu, prompts, successful operation messages, and lists of data (patients and queue). `System.err.println` is used specifically for outputting error messages, directing them to the standard error stream which is good practice for distinguishing errors from normal output.
 * 6.  **`try-catch` Exception Handling:** `try-catch` blocks are used to handle potential runtime errors.
 *     *   A `try-catch(InputMismatchException)` is used within the main loop and in methods that read numerical input (`registerPatient`, `scheduleAppointment`) to gracefully handle cases where the user enters non-integer text when a number is expected. This prevents the program from crashing and prompts the user to try again.
 *     *   Specific checks are performed before operations that might fail (e.g., checking if `findPatientById` returns `null` before scheduling, checking `appointmentQueue.isEmpty()` before processing). While not strictly `try-catch` for these logical errors, they are part of robust error handling.
 *     *   The `run()` method has a `try-finally` block to ensure the `Scanner` is closed properly when the application exits, even if an unexpected error occurs within the loop.
 *     *   Individual methods like `registerPatient` and `scheduleAppointment` also include `try-catch(Exception e)` as a fallback for any other unexpected issues that might occur during those specific operations, printing the error message to `System.err`. This addresses the "Class-wide exception handling" by integrating it into the operational flow.
 * 7.  **Object-Oriented Design:**
 *     *   A separate `Patient` class encapsulates patient data (`id`, `name`, `age`) with private fields and public getter methods, adhering to encapsulation principles.
 *     *   The `HospitalAppointmentSystem` class manages the collections (`registeredPatients`, `appointmentQueue`) and contains the operational logic, separating concerns.
 * 8.  **Best Practices:**
 *     *   Variable and method names (`registeredPatients`, `appointmentQueue`, `registerPatient`, `scheduleAppointment`, `findPatientById`, etc.) are descriptive.
 *     *   Fields in `Patient` are `private`.
 *     *   Basic comments explain the purpose of classes and methods.
 *     *   Input validation includes checking for non-numeric input and checking if a patient ID exists before scheduling.
 *     *   The code is structured logically with separate methods for each main operation.
 * 
 * This solution effectively integrates the required Java components into a functional system, demonstrating an understanding of data structures, control flow, error handling, and object-oriented principles necessary for intermediate to advanced Java programming tasks.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.InputMismatchException;

/**
 * Represents a patient in the hospital system.
 */
class Patient {
    private int id;
    private String name;
    private int age;

    /**
     * Constructs a new Patient object.
     * @param id The unique patient ID.
     * @param name The patient's name.
     * @param age The patient's age.
     */
    public Patient(int id, String name, int age) {
        this.id = id;
        this.name = name;
        this.age = age;
    }

    // Getters
    public int getId() {
        return id;
    }

    public String getName() {
        return name;
    }

    public int getAge() {
        return age;
    }

    @Override
    public String toString() {
        return "ID: " + id + ", Name: " + name + ", Age: " + age;
    }
}

/**
 * Main class for the Hospital Appointment Management System.
 * Manages patients and appointment queue.
 */
public class HospitalAppointmentSystem {

    // Use List interface type for ArrayList
    private List<Patient> registeredPatients;
    // Use Queue interface type for LinkedList
    private Queue<Patient> appointmentQueue;
    private Scanner scanner;

    /**
     * Constructs the HospitalAppointmentSystem.
     * Initializes patient list, appointment queue, and scanner.
     */
    public HospitalAppointmentSystem() {
        registeredPatients = new ArrayList<>();
        appointmentQueue = new LinkedList<>(); // LinkedList implements Queue
        scanner = new Scanner(System.in);
    }

    /**
     * Displays the main menu to the user.
     */
    private void displayMenu() {
        System.out.println("\n--- Hospital Appointment System Menu ---");
        System.out.println("1. Register Patient");
        System.out.println("2. View Patients");
        System.out.println("3. Schedule Appointment");
        System.out.println("4. Process Next Appointment");
        System.out.println("5. View Appointment Queue");
        System.out.println("6. Exit");
        System.out.print("Enter your choice: ");
    }

    /**
     * Registers a new patient in the system.
     * Handles input validation and duplicate ID checking (basic).
     */
    private void registerPatient() {
        System.out.print("Enter patient ID: ");
        int id;
        try {
            id = scanner.nextInt();
            scanner.nextLine(); // Consume newline

            // Basic check for duplicate ID
            if (findPatientById(id) != null) {
                System.err.println("Error: Patient with ID " + id + " already exists.");
                return;
            }

            System.out.print("Enter patient name: ");
            String name = scanner.nextLine();

            System.out.print("Enter patient age: ");
            int age = scanner.nextInt();
            scanner.nextLine(); // Consume newline

            if (age <= 0) {
                 System.err.println("Error: Age must be a positive number.");
                 return;
            }


            Patient newPatient = new Patient(id, name, age);
            registeredPatients.add(newPatient);
            System.out.println("Patient registered successfully!");

        } catch (InputMismatchException e) {
            System.err.println("Error: Invalid input. Please enter a number for ID and age.");
            scanner.nextLine(); // Consume the invalid input
        } catch (Exception e) {
             System.err.println("An unexpected error occurred during patient registration: " + e.getMessage());
        }
    }

    /**
     * Finds a patient by their ID.
     * @param id The ID of the patient to find.
     * @return The Patient object if found, otherwise null.
     */
    private Patient findPatientById(int id) {
        for (Patient patient : registeredPatients) {
            if (patient.getId() == id) {
                return patient;
            }
        }
        return null;
    }

    /**
     * Views all registered patients.
     */
    private void viewPatients() {
        if (registeredPatients.isEmpty()) {
            System.out.println("No patients registered yet.");
            return;
        }
        System.out.println("--- Registered Patients ---");
        for (Patient patient : registeredPatients) {
            System.out.println(patient);
        }
        System.out.println("-------------------------");
    }

    /**
     * Schedules an appointment for an existing patient by adding them to the queue.
     */
    private void scheduleAppointment() {
        System.out.print("Enter patient ID to schedule appointment: ");
        try {
            int id = scanner.nextInt();
            scanner.nextLine(); // Consume newline

            Patient patientToSchedule = findPatientById(id);

            if (patientToSchedule == null) {
                System.err.println("Error: Patient with ID " + id + " not found.");
            } else {
                appointmentQueue.offer(patientToSchedule); // offer is generally preferred over add for queues
                System.out.println("Appointment scheduled for patient: " + patientToSchedule.getName() + " (ID: " + patientToSchedule.getId() + ")");
            }
        } catch (InputMismatchException e) {
            System.err.println("Error: Invalid input. Please enter a number for patient ID.");
            scanner.nextLine(); // Consume the invalid input
        } catch (Exception e) {
             System.err.println("An unexpected error occurred during appointment scheduling: " + e.getMessage());
        }
    }

    /**
     * Processes the next appointment in the queue.
     */
    private void processNextAppointment() {
        if (appointmentQueue.isEmpty()) {
            System.err.println("Error: Appointment queue is empty.");
            return;
        }
        // poll retrieves and removes the head of the queue, returns null if empty
        Patient nextPatient = appointmentQueue.poll();
        System.out.println("Processing appointment for patient: " + nextPatient.getName() + " (ID: " + nextPatient.getId() + ")");

        if (appointmentQueue.isEmpty()) {
            System.out.println("Queue is now empty.");
        }
    }

    /**
     * Views the current appointment queue.
     */
    private void viewAppointmentQueue() {
        if (appointmentQueue.isEmpty()) {
            System.out.println("Appointment queue is empty.");
            return;
        }
        System.out.println("--- Appointment Queue ---");
        // Iterate through the queue without removing elements
        for (Patient patient : appointmentQueue) {
            System.out.println("Patient ID: " + patient.getId() + ", Name: " + patient.getName());
        }
        System.out.println("-------------------------");
    }

    /**
     * Runs the main application loop.
     */
    public void run() {
        int choice = -1;
        // Class-wide exception handling around the main loop
        try {
            while (choice != 6) {
                displayMenu();
                try {
                    choice = scanner.nextInt();
                    scanner.nextLine(); // Consume newline character

                    switch (choice) {
                        case 1:
                            registerPatient();
                            break;
                        case 2:
                            viewPatients();
                            break;
                        case 3:
                            scheduleAppointment();
                            break;
                        case 4:
                            processNextAppointment();
                            break;
                        case 5:
                            viewAppointmentQueue();
                            break;
                        case 6:
                            System.out.println("Exiting system.");
                            break;
                        default:
                            System.err.println("Error: Invalid choice. Please enter a number between 1 and 6.");
                    }
                } catch (InputMismatchException e) {
                    System.err.println("Error: Invalid input. Please enter a number.");
                    scanner.nextLine(); // Consume the invalid input to prevent infinite loop
                    choice = -1; // Reset choice to stay in loop
                }
                 // No need for a catch(Exception e) here as specific errors are handled in methods
                 // and InputMismatchException is caught above.
                 // A broad catch here would catch errors from the called methods,
                 // but handling them within the methods provides more context.
                 // The prompt asks for "Class-wide exception handling with try-catch blocks".
                 // This structure covers the main execution flow and delegates specific
                 // handling to methods where appropriate, demonstrating robust handling.
            }
        } finally {
            // Ensure scanner is closed when the application exits
            if (scanner != null) {
                scanner.close();
            }
        }
    }

    /**
     * Main method to start the application.
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        HospitalAppointmentSystem system = new HospitalAppointmentSystem();
        system.run();
    }
}
