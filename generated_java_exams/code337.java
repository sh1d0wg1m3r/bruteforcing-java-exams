/*
 * Exam Question #337
 * Generated on: 2025-05-11 22:57:14
 * Generated by: Account 4
 * 
 * QUESTION:
 * **Java Programming Exam Task: Build Pipeline Simulator**
 * 
 * **Problem Description:**
 * 
 * Design and implement a simplified software build and deployment pipeline simulator in Java. The simulator should manage incoming build requests (tasks), process them in order, and keep track of completed builds. Users should be able to interact with the simulator via a command-line interface.
 * 
 * Your solution must demonstrate a strong understanding of fundamental Java concepts, data structures, and error handling.
 * 
 * **Requirements:**
 * 
 * 1.  **Data Structures:**
 *     *   Use a `java.util.Queue` to store build tasks that are pending processing. Tasks should be processed in the order they were added (FIFO).
 *     *   Use a `java.util.List` (specifically a `java.util.ArrayList`) to store build tasks that have been successfully processed/completed.
 * 
 * 2.  **Task Representation:**
 *     *   Create a class named `BuildTask` to represent a single build request.
 *     *   Each `BuildTask` should have:
 *         *   A unique integer task ID.
 *         *   A String representing the project name.
 *         *   A boolean flag indicating if the task is completed.
 *     *   Include appropriate constructor, getters, and a method to mark the task as completed.
 * 
 * 3.  **Pipeline Management:**
 *     *   Create a class named `BuildPipeline` that manages the `pendingTasks` Queue and `completedBuilds` List.
 *     *   Implement the following methods in `BuildPipeline`:
 *         *   `addTask(String projectName)`: Creates a new `BuildTask` with a unique ID and adds it to the `pendingTasks` queue. Assign task IDs sequentially starting from 1.
 *         *   `processNextTask()`: Removes the next task from the `pendingTasks` queue, marks it as completed, and adds it to the `completedBuilds` list.
 *         *   `viewPendingTasks()`: Displays the details of all tasks currently in the `pendingTasks` queue without removing them.
 *         *   `viewCompletedBuilds()`: Displays the details of all tasks in the `completedBuilds` list.
 * 
 * 4.  **User Interface:**
 *     *   Use `java.util.Scanner` in the main application class to read user commands from the console.
 *     *   The application should present a menu of actions:
 *         1.  Add Build Task
 *         2.  Process Next Task
 *         3.  View Pending Tasks
 *         4.  View Completed Builds
 *         5.  Exit
 *     *   Use a `switch` statement to handle the different user commands.
 *     *   Use `System.out` for normal program output (prompts, confirmations, lists).
 *     *   Use `System.err` for error messages (e.g., trying to process a task when the queue is empty, invalid input).
 * 
 * 5.  **Error Handling and Validation:**
 *     *   Implement input validation where necessary (e.g., project name should not be empty when adding a task, handle invalid command input).
 *     *   Use `try-catch` blocks for exception handling. Include a mechanism for "class-wide" exception handling (e.g., a general `try-catch` around the main command loop in the `main` method) in addition to specific error checks within methods (like checking for an empty queue before processing).
 * 
 * 6.  **Best Practices:**
 *     *   Follow proper encapsulation (private fields, public methods).
 *     *   Use meaningful variable and method names.
 *     *   Include appropriate comments and documentation (e.g., Javadoc-style comments for classes and methods).
 *     *   Ensure resources like `Scanner` are properly closed (e.g., using try-with-resources).
 * 
 * **Expected Output:**
 * 
 * The program should interact with the user, prompting for commands and displaying results or errors. Examples:
 * 
 * ```
 * --- Build Pipeline Simulator ---
 * 
 * Choose an action:
 * 1. Add Build Task
 * 2. Process Next Task
 * 3. View Pending Tasks
 * 4. View Completed Builds
 * 5. Exit
 * Enter command: 1
 * Enter project name: ProjectA
 * Added task [1] for project 'ProjectA' to the pipeline.
 * 
 * Choose an action:
 * 1. Add Build Task
 * ...
 * Enter command: 1
 * Enter project name: ProjectB
 * Added task [2] for project 'ProjectB' to the pipeline.
 * 
 * Choose an action:
 * ...
 * Enter command: 3
 * 
 * --- Pending Tasks ---
 * Task ID: 1, Project: ProjectA, Status: Pending
 * Task ID: 2, Project: ProjectB, Status: Pending
 * ---------------------
 * 
 * Choose an action:
 * ...
 * Enter command: 2
 * Processed task [1] for project 'ProjectA'. Status: Completed.
 * 
 * Choose an action:
 * ...
 * Enter command: 4
 * 
 * --- Completed Builds ---
 * Task ID: 1, Project: ProjectA, Status: Completed
 * ------------------------
 * 
 * Choose an action:
 * ...
 * Enter command: 2
 * Processed task [2] for project 'ProjectB'. Status: Completed.
 * 
 * Choose an action:
 * ...
 * Enter command: 2
 * No pending tasks to process.  <-- This should go to System.err
 * 
 * Choose an action:
 * ...
 * Enter command: 99
 * Invalid command. Please enter 1, 2, 3, 4, or 5. <-- This should go to System.err
 * 
 * Choose an action:
 * ...
 * Enter command: 5
 * Exiting simulator.
 * ```
 * 
 * You should provide the complete, runnable Java code for all necessary classes within the `[SOLUTION_CODE]` block and a detailed explanation in the `[EXPLANATION]` block.
 *
 * EXPLANATION:
 * ` block.
 * 
 * [END_EXAM_QUESTION]
 * 
 * [SOLUTION_CODE]
 * ```java
 * import java.util.Queue;
 * import java.util.LinkedList;
 * import java.util.List;
 * import java.util.ArrayList;
 * import java.util.Scanner;
 * import java.util.NoSuchElementException; // Less likely needed with poll() but good to be aware
 * 
 * // Represents a single build task in the pipeline
 * class BuildTask {
 *     private int taskId;
 *     private String projectName;
 *     private boolean isCompleted;
 * 
 *     /**
 *      * Constructs a new BuildTask.
 *      * Validates the project name.
 *      * @param taskId The unique ID for the task.
 *      * @param projectName The name of the project for this task. Must not be null or empty.
 *      * @throws IllegalArgumentException if projectName is null or empty.
 *      */
 *     public BuildTask(int taskId, String projectName) {
 *         if (projectName == null || projectName.trim().isEmpty()) {
 *             throw new IllegalArgumentException("Project name cannot be null or empty.");
 *         }
 *         this.taskId = taskId;
 *         this.projectName = projectName.trim();
 *         this.isCompleted = false; // Initially not completed
 *     }
 * 
 *     // --- Getters ---
 *     public int getTaskId() {
 *         return taskId;
 *     }
 * 
 *     public String getProjectName() {
 *         return projectName;
 *     }
 * 
 *     public boolean isCompleted() {
 *         return isCompleted;
 *     }
 * 
 *     /**
 *      * Marks the task as completed.
 *      */
 *     public void markCompleted() {
 *         this.isCompleted = true;
 *     }
 * 
 *     /**
 *      * Provides a string representation of the BuildTask.
 *      * @return A formatted string describing the task.
 *      */
 *     @Override
 *     public String toString() {
 *         return "Task ID: " + taskId + ", Project: " + projectName + ", Status: " + (isCompleted ? "Completed" : "Pending");
 *     }
 * }
 * 
 * // Manages the build tasks pipeline using a Queue for pending tasks and a List for completed builds.
 * class BuildPipeline {
 *     // Queue for tasks waiting to be processed (FIFO)
 *     private Queue<BuildTask> pendingTasks;
 *     // List for tasks that have been processed/completed (ordered collection)
 *     private List<BuildTask> completedBuilds;
 *     // Counter for assigning unique task IDs
 *     private int nextTaskId;
 * 
 *     /**
 *      * Constructs a new BuildPipeline, initializing the data structures.
 *      */
 *     public BuildPipeline() {
 *         // LinkedList is a common implementation of Queue
 *         this.pendingTasks = new LinkedList<>();
 *         // ArrayList is a common implementation of List
 *         this.completedBuilds = new ArrayList<>();
 *         this.nextTaskId = 1; // Start task IDs from 1
 *     }
 * 
 *     /**
 *      * Adds a new build task to the pipeline's pending queue.
 *      * Assigns a unique ID and handles validation errors from BuildTask constructor.
 *      * @param projectName The name of the project for the task.
 *      */
 *     public void addTask(String projectName) {
 *         try {
 *             // BuildTask constructor handles the project name validation
 *             BuildTask newTask = new BuildTask(nextTaskId, projectName);
 *             pendingTasks.offer(newTask); // offer() is preferred over add() for capacity-constrained queues, but safe here
 *             nextTaskId++; // Only increment if task creation was successful
 *             System.out.println("Added task [" + newTask.getTaskId() + "] for project '" + newTask.getProjectName() + "' to the pipeline.");
 *         } catch (IllegalArgumentException e) {
 *             // Catch validation errors from BuildTask constructor
 *             System.err.println("Error adding task: " + e.getMessage());
 *         } catch (Exception e) {
 *              // Catch any other unexpected errors during task creation/adding
 *              System.err.println("An unexpected error occurred while adding task: " + e.getMessage());
 *         }
 *     }
 * 
 *     /**
 *      * Processes the next task in the pipeline.
 *      * Removes the task from the pending queue, marks it as completed, and adds it to the completed list.
 *      * Reports an error to System.err if there are no pending tasks.
 *      */
 *     public void processNextTask() {
 *         if (pendingTasks.isEmpty()) {
 *             System.err.println("No pending tasks to process.");
 *             return; // Exit the method if queue is empty
 *         }
 * 
 *         try {
 *             // poll() retrieves and removes the head of the queue, returns null if empty
 *             // We already checked isEmpty(), so taskToProcess should not be null
 *             BuildTask taskToProcess = pendingTasks.poll();
 * 
 *             // Defensive check, though isEmpty() makes this unlikely
 *             if (taskToProcess != null) {
 *                 taskToProcess.markCompleted();
 *                 completedBuilds.add(taskToProcess); // Add to the list of completed builds (ArrayList)
 *                 System.out.println("Processed task [" + taskToProcess.getTaskId() + "] for project '" + taskToProcess.getProjectName() + "'. Status: Completed.");
 *             } else {
 *                  // This case indicates an unexpected state if isEmpty() was false but poll() returned null
 *                  System.err.println("Internal error: Failed to retrieve task from queue despite it not being empty.");
 *             }
 *         } catch (Exception e) {
 *             // Catch any unexpected runtime errors during processing (e.g., issues adding to list)
 *             System.err.println("An unexpected error occurred while processing task: " + e.getMessage());
 *             // Note: If poll() succeeded but subsequent steps failed, the task is lost from the queue.
 *             // A more robust system might re-queue or log for manual intervention.
 *             // For this exam, simple error reporting is sufficient.
 *         }
 *     }
 * 
 *     /**
 *      * Displays all pending tasks currently in the pipeline queue without removing them.
 *      */
 *     public void viewPendingTasks() {
 *         System.out.println("\n--- Pending Tasks ---");
 *         if (pendingTasks.isEmpty()) {
 *             System.out.println("No tasks are currently pending.");
 *             System.out.println("---------------------");
 *             return;
 *         }
 * 
 *         // Iterate through the queue elements. Converting to a List first is a safe way
 *         // to iterate without modifying the queue during iteration.
 *         List<BuildTask> pendingList = new ArrayList<>(pendingTasks);
 *         for (BuildTask task : pendingList) {
 *             System.out.println(task); // BuildTask's toString provides details
 *         }
 *         System.out.println("---------------------");
 *     }
 * 
 *     /**
 *      * Displays all completed builds from the completed builds list.
 *      */
 *     public void viewCompletedBuilds() {
 *         System.out.println("\n--- Completed Builds ---");
 *         if (completedBuilds.isEmpty()) {
 *             System.out.println("No builds have been completed yet.");
 *             System.out.println("------------------------");
 *             return;
 *         }
 * 
 *         // Iterate through the completed list (ArrayList)
 *         for (BuildTask task : completedBuilds) {
 *             System.out.println(task); // BuildTask's toString provides details
 *         }
 *         System.out.println("------------------------");
 *     }
 * }
 * 
 * // Main class to run the Build Pipeline Simulator, handles user interaction.
 * public class PipelineSimulator {
 * 
 *     public static void main(String[] args) {
 *         // Use try-with-resources for Scanner to ensure it's closed automatically
 *         try (Scanner scanner = new Scanner(System.in)) {
 *             BuildPipeline pipeline = new BuildPipeline();
 *             boolean running = true;
 * 
 *             System.out.println("--- Build Pipeline Simulator ---");
 * 
 *             // Main application loop
 *             while (running) {
 *                 System.out.println("\nChoose an action:");
 *                 System.out.println("1. Add Build Task");
 *                 System.out.println("2. Process Next Task");
 *                 System.out.println("3. View Pending Tasks");
 *                 System.out.println("4. View Completed Builds");
 *                 System.out.println("5. Exit");
 *                 System.out.print("Enter command: ");
 * 
 *                 try {
 *                     String command = scanner.nextLine().trim();
 * 
 *                     // Use a switch statement for flow control based on user command
 *                     switch (command) {
 *                         case "1":
 *                             System.out.print("Enter project name: ");
 *                             String projectName = scanner.nextLine().trim();
 *                             pipeline.addTask(projectName); // addTask handles validation and System.err
 *                             break;
 *                         case "2":
 *                             pipeline.processNextTask(); // processNextTask handles empty queue and System.err
 *                             break;
 *                         case "3":
 *                             pipeline.viewPendingTasks();
 *                             break;
 *                         case "4":
 *                             pipeline.viewCompletedBuilds();
 *                             break;
 *                         case "5":
 *                             running = false;
 *                             System.out.println("Exiting simulator.");
 *                             break;
 *                         default:
 *                             // Handle invalid command input
 *                             System.err.println("Invalid command. Please enter 1, 2, 3, 4, or 5.");
 *                     }
 *                 } catch (Exception e) {
 *                     // Class-wide exception handling for any unexpected runtime errors
 *                     // that might occur *within* the command processing block.
 *                     // This catches exceptions not specifically handled within the BuildPipeline methods.
 *                     System.err.println("An unexpected error occurred during command execution: " + e.getMessage());
 *                     // In a real application, you might log the full stack trace for debugging:
 *                     // e.printStackTrace();
 *                 }
 *             }
 *         } // Scanner is automatically closed here by try-with-resources
 *         catch (Exception e) {
 *             // Catch any exception that might occur during Scanner setup or the try-with-resources block itself.
 *             System.err.println("A critical error occurred in the simulator startup or main loop: " + e.getMessage());
 *             // e.printStackTrace();
 *         }
 *     }
 * }
 * ```
 * [END_SOLUTION_CODE]
 * 
 * [EXPLANATION]
 * This solution implements a simplified Build Pipeline Simulator using core Java data structures and control flow mechanisms, demonstrating required concepts and best practices.
 * 
 * **Scenario:**
 * The simulator mimics a basic software build process where build requests (tasks) are queued up and processed one by one. Completed tasks are moved to a list of finished builds.
 * 
 * **Class Structure:**
 * 1.  `BuildTask`: Represents a single build request with an ID, project name, and completion status. It encapsulates the data for a task and provides a method to update its status. Input validation for the project name is included in the constructor.
 * 2.  `BuildPipeline`: Manages the collection of tasks. It holds a `Queue` for pending tasks and a `List` (implemented as `ArrayList`) for completed tasks. It provides methods to add tasks, process the next task, and view the contents of both collections.
 * 3.  `PipelineSimulator`: Contains the `main` method. It sets up the `BuildPipeline`, handles user input using `Scanner`, and controls the application flow using a `while` loop and a `switch` statement.
 * 
 * **Use of Required Components:**
 * 
 * *   **`Queue` (`java.util.Queue`):** The `pendingTasks` variable is declared as a `Queue<BuildTask>` and initialized with a `LinkedList`. `offer()` is used to add new tasks to the end of the queue, and `poll()` is used to remove and retrieve the next task from the front (FIFO).
 * *   **`ArrayList` (`java.util.ArrayList`):** The `completedBuilds` variable is initialized as an `ArrayList<BuildTask>`. It's used to store tasks after they have been processed. `add()` is used to append completed tasks to this list.
 * *   **`List interface` (`java.util.List`):** The `completedBuilds` variable is declared using the `List<BuildTask>` interface type, demonstrating programming to the interface, a good practice. `ArrayList` is the concrete implementation used.
 * *   **`Scanner` (`java.util.Scanner`):** Used in the `PipelineSimulator.main` method to read user commands and project names from the standard input (`System.in`). The `try-with-resources` statement ensures the `Scanner` is automatically closed when the program exits or an exception occurs in the setup phase.
 * *   **`switch` statement:** Used in the `PipelineSimulator.main` method to dispatch actions based on the user's command input ('1', '2', '3', '4', '5').
 * *   **`System.err`:** Used for displaying error messages, such as when an invalid command is entered, when a project name is invalid during task creation, or when trying to process a task from an empty queue.
 * *   **`System.out`:** Used for displaying normal program output, including prompts, confirmations of actions (task added, task processed), and lists of pending or completed tasks.
 * *   **`try-catch` blocks:**
 *     *   In `BuildTask` constructor: A `try-catch` is not explicitly needed here because `IllegalArgumentException` is thrown for invalid input, which is caught by the caller (`addTask`).
 *     *   In `BuildPipeline.addTask`: A `try-catch` block wraps the task creation and adding process to catch `IllegalArgumentException` from the `BuildTask` constructor and any other unexpected exceptions, printing an error to `System.err`.
 *     *   In `BuildPipeline.processNextTask`: An `if (!pendingTasks.isEmpty())` check handles the expected case of an empty queue, printing an error to `System.err`. A `try-catch` block wraps the core processing logic (`poll`, `markCompleted`, `add`) to catch any unexpected runtime exceptions that might occur during these operations, printing an error to `System.err`.
 *     *   In `PipelineSimulator.main`:
 *         *   A `try-with-resources` block is used for the `Scanner`, which implicitly handles exceptions during resource setup and ensures closing.
 *         *   A `try-catch (Exception e)` block is placed around the core `while` loop's command processing logic. This serves as the "class-wide" or main application loop exception handler, catching any uncaught runtime exceptions that propagate up from the command handling `switch` block or called methods, preventing the program from crashing abruptly and printing an error to `System.err`.
 * 
 * **Best Practices:**
 * 
 * *   **Encapsulation:** Fields in `BuildTask` and `BuildPipeline` are private, with public methods providing controlled access.
 * *   **Meaningful Names:** Variables (`pendingTasks`, `completedBuilds`, `nextTaskId`, `projectName`), methods (`addTask`, `processNextTask`, `viewPendingTasks`), and classes (`BuildTask`, `BuildPipeline`, `PipelineSimulator`) have descriptive names.
 * *   **Comments and Documentation:** Javadoc-style comments are used to explain the purpose of classes, constructors, and methods, including parameters and exceptions. Inline comments explain specific code logic where necessary.
 * *   **Input Validation:** Project name is validated in the `BuildTask` constructor. Invalid command input is handled in the `switch` statement's `default` case.
 * *   **Error Handling:** Specific expected errors (empty queue, invalid input) are handled gracefully with informative messages to `System.err`. Unexpected runtime errors are caught by `try-catch` blocks at appropriate levels.
 * *   **Clean Code Structure:** The code is organized into logical classes, separating concerns (Task data, Pipeline logic, User interaction). The `main` method provides a clear loop for user interaction.
 * 
 * This solution effectively demonstrates the required Java components and practices within a cohesive, practical simulation.
 */

import java.util.Queue;
import java.util.LinkedList;
import java.util.List;
import java.util.ArrayList;
import java.util.Scanner;
import java.util.NoSuchElementException; // Less likely needed with poll() but good to be aware

// Represents a single build task in the pipeline
class BuildTask {
    private int taskId;
    private String projectName;
    private boolean isCompleted;

    /**
     * Constructs a new BuildTask.
     * Validates the project name.
     * @param taskId The unique ID for the task.
     * @param projectName The name of the project for this task. Must not be null or empty.
     * @throws IllegalArgumentException if projectName is null or empty.
     */
    public BuildTask(int taskId, String projectName) {
        if (projectName == null || projectName.trim().isEmpty()) {
            throw new IllegalArgumentException("Project name cannot be null or empty.");
        }
        this.taskId = taskId;
        this.projectName = projectName.trim();
        this.isCompleted = false; // Initially not completed
    }

    // --- Getters ---
    public int getTaskId() {
        return taskId;
    }

    public String getProjectName() {
        return projectName;
    }

    public boolean isCompleted() {
        return isCompleted;
    }

    /**
     * Marks the task as completed.
     */
    public void markCompleted() {
        this.isCompleted = true;
    }

    /**
     * Provides a string representation of the BuildTask.
     * @return A formatted string describing the task.
     */
    @Override
    public String toString() {
        return "Task ID: " + taskId + ", Project: " + projectName + ", Status: " + (isCompleted ? "Completed" : "Pending");
    }
}

// Manages the build tasks pipeline using a Queue for pending tasks and a List for completed builds.
class BuildPipeline {
    // Queue for tasks waiting to be processed (FIFO)
    private Queue<BuildTask> pendingTasks;
    // List for tasks that have been processed/completed (ordered collection)
    private List<BuildTask> completedBuilds;
    // Counter for assigning unique task IDs
    private int nextTaskId;

    /**
     * Constructs a new BuildPipeline, initializing the data structures.
     */
    public BuildPipeline() {
        // LinkedList is a common implementation of Queue
        this.pendingTasks = new LinkedList<>();
        // ArrayList is a common implementation of List
        this.completedBuilds = new ArrayList<>();
        this.nextTaskId = 1; // Start task IDs from 1
    }

    /**
     * Adds a new build task to the pipeline's pending queue.
     * Assigns a unique ID and handles validation errors from BuildTask constructor.
     * @param projectName The name of the project for the task.
     */
    public void addTask(String projectName) {
        try {
            // BuildTask constructor handles the project name validation
            BuildTask newTask = new BuildTask(nextTaskId, projectName);
            pendingTasks.offer(newTask); // offer() is preferred over add() for capacity-constrained queues, but safe here
            nextTaskId++; // Only increment if task creation was successful
            System.out.println("Added task [" + newTask.getTaskId() + "] for project '" + newTask.getProjectName() + "' to the pipeline.");
        } catch (IllegalArgumentException e) {
            // Catch validation errors from BuildTask constructor
            System.err.println("Error adding task: " + e.getMessage());
        } catch (Exception e) {
             // Catch any other unexpected errors during task creation/adding
             System.err.println("An unexpected error occurred while adding task: " + e.getMessage());
        }
    }

    /**
     * Processes the next task in the pipeline.
     * Removes the task from the pending queue, marks it as completed, and adds it to the completed list.
     * Reports an error to System.err if there are no pending tasks.
     */
    public void processNextTask() {
        if (pendingTasks.isEmpty()) {
            System.err.println("No pending tasks to process.");
            return; // Exit the method if queue is empty
        }

        try {
            // poll() retrieves and removes the head of the queue, returns null if empty
            // We already checked isEmpty(), so taskToProcess should not be null
            BuildTask taskToProcess = pendingTasks.poll();

            // Defensive check, though isEmpty() makes this unlikely
            if (taskToProcess != null) {
                taskToProcess.markCompleted();
                completedBuilds.add(taskToProcess); // Add to the list of completed builds (ArrayList)
                System.out.println("Processed task [" + taskToProcess.getTaskId() + "] for project '" + taskToProcess.getProjectName() + "'. Status: Completed.");
            } else {
                 // This case indicates an unexpected state if isEmpty() was false but poll() returned null
                 System.err.println("Internal error: Failed to retrieve task from queue despite it not being empty.");
            }
        } catch (Exception e) {
            // Catch any unexpected runtime errors during processing (e.g., issues adding to list)
            System.err.println("An unexpected error occurred while processing task: " + e.getMessage());
            // Note: If poll() succeeded but subsequent steps failed, the task is lost from the queue.
            // A more robust system might re-queue or log for manual intervention.
            // For this exam, simple error reporting is sufficient.
        }
    }

    /**
     * Displays all pending tasks currently in the pipeline queue without removing them.
     */
    public void viewPendingTasks() {
        System.out.println("\n--- Pending Tasks ---");
        if (pendingTasks.isEmpty()) {
            System.out.println("No tasks are currently pending.");
            System.out.println("---------------------");
            return;
        }

        // Iterate through the queue elements. Converting to a List first is a safe way
        // to iterate without modifying the queue during iteration.
        List<BuildTask> pendingList = new ArrayList<>(pendingTasks);
        for (BuildTask task : pendingList) {
            System.out.println(task); // BuildTask's toString provides details
        }
        System.out.println("---------------------");
    }

    /**
     * Displays all completed builds from the completed builds list.
     */
    public void viewCompletedBuilds() {
        System.out.println("\n--- Completed Builds ---");
        if (completedBuilds.isEmpty()) {
            System.out.println("No builds have been completed yet.");
            System.out.println("------------------------");
            return;
        }

        // Iterate through the completed list (ArrayList)
        for (BuildTask task : completedBuilds) {
            System.out.println(task); // BuildTask's toString provides details
        }
        System.out.println("------------------------");
    }
}

// Main class to run the Build Pipeline Simulator, handles user interaction.
public class PipelineSimulator {

    public static void main(String[] args) {
        // Use try-with-resources for Scanner to ensure it's closed automatically
        try (Scanner scanner = new Scanner(System.in)) {
            BuildPipeline pipeline = new BuildPipeline();
            boolean running = true;

            System.out.println("--- Build Pipeline Simulator ---");

            // Main application loop
            while (running) {
                System.out.println("\nChoose an action:");
                System.out.println("1. Add Build Task");
                System.out.println("2. Process Next Task");
                System.out.println("3. View Pending Tasks");
                System.out.println("4. View Completed Builds");
                System.out.println("5. Exit");
                System.out.print("Enter command: ");

                try {
                    String command = scanner.nextLine().trim();

                    // Use a switch statement for flow control based on user command
                    switch (command) {
                        case "1":
                            System.out.print("Enter project name: ");
                            String projectName = scanner.nextLine().trim();
                            pipeline.addTask(projectName); // addTask handles validation and System.err
                            break;
                        case "2":
                            pipeline.processNextTask(); // processNextTask handles empty queue and System.err
                            break;
                        case "3":
                            pipeline.viewPendingTasks();
                            break;
                        case "4":
                            pipeline.viewCompletedBuilds();
                            break;
                        case "5":
                            running = false;
                            System.out.println("Exiting simulator.");
                            break;
                        default:
                            // Handle invalid command input
                            System.err.println("Invalid command. Please enter 1, 2, 3, 4, or 5.");
                    }
                } catch (Exception e) {
                    // Class-wide exception handling for any unexpected runtime errors
                    // that might occur *within* the command processing block.
                    // This catches exceptions not specifically handled within the BuildPipeline methods.
                    System.err.println("An unexpected error occurred during command execution: " + e.getMessage());
                    // In a real application, you might log the full stack trace for debugging:
                    // e.printStackTrace();
                }
            }
        } // Scanner is automatically closed here by try-with-resources
        catch (Exception e) {
            // Catch any exception that might occur during Scanner setup or the try-with-resources block itself.
            System.err.println("A critical error occurred in the simulator startup or main loop: " + e.getMessage());
            // e.printStackTrace();
        }
    }
}
