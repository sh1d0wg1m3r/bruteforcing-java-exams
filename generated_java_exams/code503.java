/*
 * Exam Question #503
 * Generated on: 2025-05-11 23:21:05
 * Generated by: Account 2
 * 
 * QUESTION:
 * **Java Programming Exam Task: Task Processing System**
 * 
 * **Problem Description:**
 * 
 * You are tasked with building a simplified command-line application that simulates a task processing system. Users can submit tasks, process the next task in a queue, and view lists of pending and completed tasks.
 * 
 * Each task should have:
 * - A unique integer ID (automatically generated).
 * - A String description.
 * - A status (e.g., PENDING, COMPLETED).
 * 
 * The system should manage tasks using a queue for pending items and a list for completed items.
 * 
 * **Requirements:**
 * 
 * 1.  **Core Functionality:** Implement the following menu-driven operations:
 *     *   `Submit New Task`: Prompt the user for a task description and add it to the end of the pending task queue.
 *     *   `Process Next Task`: Remove the task at the front of the pending queue, mark it as completed, and add it to the list of completed tasks. If the queue is empty, report a message to the user.
 *     *   `View Pending Tasks`: Display all tasks currently in the pending queue in their order.
 *     *   `View Completed Tasks`: Display all tasks that have been processed and are in the completed list.
 *     *   `Exit`: Terminate the application.
 * 
 * 2.  **Java Components:** Your solution *must* utilize the following Java components:
 *     *   `java.util.Queue` for managing pending tasks.
 *     *   `java.util.ArrayList` to store completed tasks, declared using the `java.util.List` interface (`List<Task> completedTasks = new ArrayList<>();`).
 *     *   `java.util.Scanner` for reading user input from the console.
 *     *   A `switch` statement to handle the main menu options.
 *     *   `System.err` for outputting error messages (e.g., invalid menu choice, empty task description, unexpected errors).
 *     *   `System.out` for all other normal output (menu, prompts, task details, success messages, messages for empty pending/completed lists).
 *     *   Class-wide exception handling using `try-catch` blocks to gracefully handle potential issues, particularly `InputMismatchException` from `Scanner` when reading menu choices and any other unexpected runtime errors.
 * 
 * 3.  **Best Practices:**
 *     *   Employ proper encapsulation by making class fields private and providing public methods for interaction.
 *     *   Use meaningful variable, method, and class names.
 *     *   Include appropriate comments and documentation (e.g., Javadoc for classes/methods).
 *     *   Implement input validation (e.g., ensure task description is not empty).
 *     *   Ensure proper error handling as specified in Requirement 2.
 *     *   Structure your code cleanly into logical classes (e.g., a `Task` class and a main system class).
 * 
 * **Expected Output:**
 * 
 * Your program should present a menu, accept integer input for menu choices, execute the corresponding actions, display task information clearly, and print informative messages to `System.out` or error messages to `System.err` based on the operation's outcome or validity. The system should loop until the user chooses to exit.
 * 
 * Example interaction flow:
 * - System displays menu.
 * - User enters invalid choice (non-integer) -> `System.err` shows "Invalid input...", menu redisplays.
 * - User enters invalid choice (integer outside 1-5) -> `System.err` shows "Invalid choice...", menu redisplays.
 * - User enters valid choice (e.g., 1) -> System prompts for description.
 * - User enters empty description -> `System.err` shows "Error: Task description cannot be empty.", menu redisplays.
 * - User enters valid description -> `System.out` shows task submitted, menu redisplays.
 * - User enters choice 3 (View Pending) -> `System.out` lists pending tasks or "No tasks currently pending.", menu redisplays.
 * - User enters choice 2 (Process) when queue is not empty -> `System.out` shows task being processed/completed, moves it, menu redisplays.
 * - User enters choice 2 again when queue is empty -> `System.out` shows "No pending tasks to process.", menu redisplays.
 * - User enters choice 4 (View Completed) -> `System.out` lists completed tasks or "No tasks have been completed yet.", menu redisplays.
 * - User enters choice 5 -> `System.out` shows exit message, program terminates.
 * 
 * Your solution should be a single Java file containing all necessary classes and the `main` method.
 *
 * EXPLANATION:
 * The provided solution implements a `TaskProcessingSystem` that effectively manages tasks using a queue for pending items and a list for completed items, fulfilling all the requirements of the exam question.
 * 
 * **Key Concepts Demonstrated:**
 * 
 * 1.  **`java.util.Queue`**: The `pendingTasks` field is declared as a `Queue<Task>` and instantiated using `java.util.LinkedList`. This demonstrates the use of a Queue for managing elements in a First-In, First-Out (FIFO) manner, suitable for processing tasks in the order they are submitted.
 *     *   `offer()` is used in `submitTask()` to add tasks to the end of the queue.
 *     *   `poll()` is used in `processNextTask()` to retrieve and remove the task at the front of the queue.
 *     *   `isEmpty()` is used to check if the queue is empty before attempting to process a task.
 * 
 * 2.  **`java.util.List` and `java.util.ArrayList`**: The `completedTasks` field is declared using the `java.util.List` interface and instantiated as a `java.util.ArrayList`. This shows how to use the List interface and a concrete implementation (`ArrayList`) to store an ordered collection of completed tasks, allowing easy iteration and addition.
 *     *   `add()` is used in `processNextTask()` to add completed tasks to the list.
 *     *   `isEmpty()` is used to check if the list is empty before viewing.
 *     *   Enhanced for-loops are used in `viewPendingTasks()` and `viewCompletedTasks()` to iterate through the collections.
 * 
 * 3.  **`java.util.Scanner`**: A `Scanner` object is created in the `main` method to read input from `System.in`. It is passed to the `TaskProcessingSystem` constructor and used within the `runSystemLoop` method to handle user input for menu choices and task descriptions. Proper handling of `Scanner` input, including consuming the newline character after reading an integer (`scanner.nextLine();`), is demonstrated to prevent input issues. The scanner is closed when the application exits.
 * 
 * 4.  **`switch` Statement**: A `switch` statement is used in the `runSystemLoop` method to direct program flow based on the user's integer choice from the menu. This provides a clear and efficient way to handle multiple command options.
 * 
 * 5.  **`System.err`**: `System.err.println()` is used specifically for outputting error messages, such as when the user provides invalid input (non-integer or empty task description) or when an unexpected internal error occurs. This correctly separates error output from standard application output, often displayed in a different color or stream by the console.
 * 
 * 6.  **`System.out`**: `System.out.println()` and `System.out.print()` are used for all normal application output, including displaying the menu, prompting for input, showing task details, success messages, and informative messages for empty lists/queues (like "No pending tasks to process." or "No tasks currently pending.").
 * 
 * 7.  **Exception Handling (`try-catch`)**: A `try-catch` block in `runSystemLoop` is used to handle potential exceptions during user interaction:
 *     *   `InputMismatchException` is caught specifically when `scanner.nextInt()` fails because the user entered non-integer input. This prevents the program from crashing, prints an informative error to `System.err`, and consumes the invalid input to prevent an infinite loop.
 *     *   A general `Exception` catch block is included as a fallback to catch and report any other unexpected runtime errors that might occur within the `try` block, demonstrating a robust approach to error management.
 * 
 * 8.  **Input Validation**: The `submitTask` method explicitly checks if the entered task description is empty (`description.isEmpty()`) and uses `System.err` to report the error, preventing invalid tasks from being added to the system. The `runSystemLoop` handles validation of menu input type (`InputMismatchException`) and range (the `default` case in the `switch` statement).
 * 
 * 9.  **Encapsulation**: The `Task` class fields (`id`, `description`, `status`) and `TaskProcessingSystem` fields (`pendingTasks`, `completedTasks`, `scanner`) are declared as `private`, restricting direct access from outside the class and requiring interaction through public methods (`getters`, `setStatus`, `submitTask`, etc.). This promotes data integrity and modularity.
 * 
 * 10. **Clean Code Structure**: The solution is organized into logical units: an `enum` (`TaskStatus`) for clarity on task states, a `Task` class to represent the data structure, and a `TaskProcessingSystem` class containing the main application logic and the `main` method to start the system. Methods have clear, descriptive names (`submitTask`, `processNextTask`, `viewPendingTasks`, `runSystemLoop`, `printMenu`), and basic documentation (Javadoc) is included.
 * 
 * The code effectively demonstrates a practical application of fundamental Java collections (`Queue`, `List`, `ArrayList`, `LinkedList`), control flow (`switch`, loops), user interaction (`Scanner`, `System.out`, `System.err`), and essential error handling (`try-catch`, input validation), making it a comprehensive solution for the challenging exam task.
 */

import java.util.Queue;
import java.util.LinkedList; // Concrete implementation of Queue
import java.util.List;
import java.util.ArrayList; // Concrete implementation of List
import java.util.Scanner;
import java.util.InputMismatchException;

/**
 * Enum representing the status of a task.
 */
enum TaskStatus {
    PENDING,
    COMPLETED
}

/**
 * Represents a single task in the system.
 */
class Task {
    private static int nextId = 1; // Static counter for unique task IDs
    private int id;
    private String description;
    private TaskStatus status;

    /**
     * Constructs a new Task with a given description.
     * Automatically assigns a unique ID and sets status to PENDING.
     * @param description The description of the task.
     */
    public Task(String description) {
        this.id = nextId++; // Assign unique ID and increment counter
        this.description = description;
        this.status = TaskStatus.PENDING;
    }

    // --- Getters ---
    public int getId() {
        return id;
    }

    public String getDescription() {
        return description;
    }

    public TaskStatus getStatus() {
        return status;
    }

    // --- Setter (used by TaskProcessingSystem to update status) ---
    public void setStatus(TaskStatus status) {
        this.status = status;
    }

    /**
     * Returns a string representation of the Task.
     * @return A string detailing the task's ID, description, and status.
     */
    @Override
    public String toString() {
        return "Task [ID=" + id + ", Description='" + description + "', Status=" + status + "]";
    }
}

/**
 * Manages the task processing system, including pending and completed tasks.
 */
public class TaskProcessingSystem { // Class name matching single file convention

    private Queue<Task> pendingTasks;
    private List<Task> completedTasks;
    private Scanner scanner; // Scanner for user input

    /**
     * Constructs a new TaskProcessingSystem.
     * Initializes the pending task queue and completed task list.
     * @param scanner The Scanner object to use for input.
     */
    public TaskProcessingSystem(Scanner scanner) {
        this.pendingTasks = new LinkedList<>(); // Use LinkedList as a Queue implementation
        this.completedTasks = new ArrayList<>(); // Use ArrayList as a List implementation
        this.scanner = scanner;
    }

    /**
     * Submits a new task based on user input.
     * Adds the task to the pending queue if the description is valid.
     */
    public void submitTask() {
        System.out.println("\n--- Submit New Task ---");
        System.out.print("Enter task description: ");
        // Consume the newline character left by previous nextInt()
        scanner.nextLine();
        String description = scanner.nextLine().trim(); // Read the full line and trim whitespace

        if (description.isEmpty()) {
            System.err.println("Error: Task description cannot be empty.");
            return; // Exit the method if input is invalid
        }

        Task newTask = new Task(description);
        pendingTasks.offer(newTask); // Use offer() for queue, returns false if failed (unlikely with LinkedList)
        System.out.println("Task submitted successfully: " + newTask);
    }

    /**
     * Processes the next task from the pending queue.
     * Removes the task, updates its status, and moves it to the completed list.
     * Reports a message if the pending queue is empty.
     */
    public void processNextTask() {
        System.out.println("\n--- Process Next Task ---");
        if (pendingTasks.isEmpty()) {
            // As per requirement 1, reporting message for empty queue processing
            System.out.println("No pending tasks to process.");
            return;
        }

        Task taskToProcess = pendingTasks.poll(); // Retrieves and removes the head of the queue
        if (taskToProcess != null) { // poll() returns null if queue is empty, check is defensive
            System.out.println("Processing task: " + taskToProcess.getDescription() + " (ID: " + taskToProcess.getId() + ")");
            taskToProcess.setStatus(TaskStatus.COMPLETED);
            completedTasks.add(taskToProcess); // Add to the completed list
            System.out.println("Task completed and moved: " + taskToProcess);
        } else {
             // This case should theoretically not be reached if isEmpty() is checked first,
             // but included for robustness.
             System.err.println("Internal Error: Failed to retrieve task from non-empty queue.");
        }
    }

    /**
     * Displays all tasks currently in the pending queue.
     */
    public void viewPendingTasks() {
        System.out.println("\n--- Pending Tasks ---");
        if (pendingTasks.isEmpty()) {
            System.out.println("No tasks currently pending.");
            return;
        }

        // Iterate through the queue without removing elements
        int count = 1;
        for (Task task : pendingTasks) {
            System.out.println(count++ + ". " + task);
        }
    }

    /**
     * Displays all tasks that have been completed.
     */
    public void viewCompletedTasks() {
        System.out.println("\n--- Completed Tasks ---");
        if (completedTasks.isEmpty()) {
            System.out.println("No tasks have been completed yet.");
            return;
        }

        // Iterate through the completed list
        int count = 1;
        for (Task task : completedTasks) {
            System.out.println(count++ + ". " + task);
        }
    }

    /**
     * Prints the main menu options to the console.
     */
    private void printMenu() {
        System.out.println("\n--- Task Processing System Menu ---");
        System.out.println("1. Submit New Task");
        System.out.println("2. Process Next Task");
        System.out.println("3. View Pending Tasks");
        System.out.println("4. View Completed Tasks");
        System.out.println("5. Exit");
        System.out.println("-----------------------------------");
    }

    /**
     * Runs the main application loop, handling user input and menu selection.
     * Includes robust exception handling for user input.
     */
    public void runSystemLoop() {
        int choice = -1;
        // Loop until the user chooses to exit (choice 5)
        while (choice != 5) {
            printMenu();
            try {
                System.out.print("Enter your choice: ");
                choice = scanner.nextInt(); // Read the integer choice

                // Use a switch statement for menu navigation
                switch (choice) {
                    case 1:
                        submitTask(); // Call method to submit a task
                        break;
                    case 2:
                        processNextTask(); // Call method to process the next task
                        break;
                    case 3:
                        viewPendingTasks(); // Call method to view pending tasks
                        break;
                    case 4:
                        viewCompletedTasks(); // Call method to view completed tasks
                        break;
                    case 5:
                        System.out.println("Exiting Task Processing System. Goodbye!");
                        break;
                    default:
                        // Handle invalid integer choices
                        System.err.println("Invalid choice. Please enter a number between 1 and 5.");
                }
            } catch (InputMismatchException e) {
                // Handle cases where the user enters non-integer input
                System.err.println("Invalid input. Please enter a number.");
                scanner.next(); // Consume the invalid input to prevent an infinite loop
                choice = -1; // Reset choice to ensure the loop continues and menu is shown again
            } catch (Exception e) {
                 // Catch any other unexpected runtime exceptions
                 System.err.println("An unexpected error occurred: " + e.getMessage());
                 // For debugging, you might want to print the stack trace:
                 // e.printStackTrace();
                 choice = -1; // Reset choice
            }
        }
    }

    /**
     * Main method to start the Task Processing System application.
     * Creates a Scanner and a TaskProcessingSystem instance, then runs the main loop.
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        // Create a single Scanner instance for the application
        Scanner systemScanner = new Scanner(System.in);
        // Create an instance of the Task Processing System
        TaskProcessingSystem system = new TaskProcessingSystem(systemScanner);
        // Start the main application loop
        system.runSystemLoop();
        // Close the scanner when the application exits
        systemScanner.close();
    }
}
