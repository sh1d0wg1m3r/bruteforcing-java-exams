/*
 * Exam Question #868
 * Generated on: 2025-05-12 16:52:47
 * Generated by: Account 1
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Simple Task Management System
 * 
 * **Scenario:**
 * 
 * You are tasked with developing a basic command-line application for managing tasks for a small team. The system should allow users to add new tasks, mark the next pending task as completed, view pending tasks, and view completed tasks.
 * 
 * Each task has a description and a priority (High, Medium, or Low). New tasks are added to a queue, representing the order in which they should ideally be processed. Completed tasks are moved to a separate list for historical tracking.
 * 
 * **Requirements:**
 * 
 * 1.  **Task Representation:** Create a `Task` class with private fields for `description` (String) and `priority` (String). Include a constructor and public getter methods for these fields. Override the `toString()` method for easy printing of task details.
 * 2.  **Task Management Logic:** Create a `TaskManager` class responsible for managing the collections of tasks.
 *     *   It must contain a private field `pendingTasks` declared as a `java.util.Queue<Task>`. Use a suitable concrete implementation (e.g., `java.util.LinkedList`).
 *     *   It must contain a private field `completedTasks` declared as a `java.util.List<Task>`. Use `java.util.ArrayList` as the concrete implementation.
 *     *   Implement a public method `addTask(String description, String priority)`:
 *         *   This method should create a new `Task` object.
 *         *   It must validate the `priority` string (case-insensitive "HIGH", "MEDIUM", or "LOW"). If invalid, throw an `IllegalArgumentException`.
 *         *   Add the valid task to the `pendingTasks` queue.
 *         *   Print a confirmation message to `System.out`.
 *     *   Implement a public method `completeNextTask()`:
 *         *   Remove the task from the front of the `pendingTasks` queue.
 *         *   If the queue is empty, throw an `IllegalStateException` with an appropriate message.
 *         *   Add the removed task to the `completedTasks` list.
 *         *   Print a confirmation message to `System.out`.
 *     *   Implement a public method `viewPendingTasks()`:
 *         *   Print all tasks currently in the `pendingTasks` queue to `System.out`. Indicate if the queue is empty.
 *     *   Implement a public method `viewCompletedTasks()`:
 *         *   Print all tasks currently in the `completedTasks` list to `System.out`. Indicate if the list is empty.
 * 3.  **User Interface:** Create a main application class (e.g., `TaskApp`) with a `main` method.
 *     *   Use `java.util.Scanner` to read user input from the console.
 *     *   Present a menu of options to the user:
 *         1.  Add New Task
 *         2.  Complete Next Task
 *         3.  View Pending Tasks
 *         4.  View Completed Tasks
 *         5.  Exit
 *     *   Use a `switch` statement to handle the user's menu choice.
 *     *   The main application loop must be wrapped in a `try-catch` block to handle potential exceptions thrown during user interaction or by the `TaskManager` methods.
 *     *   Print all standard output (menu, confirmations, task listings) to `System.out`.
 *     *   Print all error messages (invalid input, exceptions caught) to `System.err`.
 *     *   Ensure the `Scanner` is properly closed when the application exits.
 * 4.  **Error Handling and Validation:**
 *     *   Implement input validation for the task priority in `addTask`.
 *     *   Implement logic to handle attempting to complete a task when the queue is empty in `completeNextTask`.
 *     *   Catch specific exceptions (`IllegalArgumentException`, `IllegalStateException`, `InputMismatchException`) where appropriate, and use a general `catch` for any unexpected errors within the main loop.
 *     *   Print informative error messages to `System.err`.
 * 5.  **Best Practices:**
 *     *   Use proper encapsulation (private fields, public methods).
 *     *   Use meaningful variable and method names.
 *     *   Include appropriate comments and documentation (e.g., Javadoc for public methods).
 *     *   Structure the code into appropriate classes.
 * 
 * **Expected Output (Sample Interaction):**
 * 
 * ```
 * --- Simple Task Manager ---
 * 
 * --- Menu ---
 * 1. Add New Task
 * 2. Complete Next Task
 * 3. View Pending Tasks
 * 4. View Completed Tasks
 * 5. Exit
 * ------------
 * Enter choice: 1
 * Enter task description: Implement feature X
 * Enter task priority (HIGH, MEDIUM, LOW): HIGH
 * Task added: [HIGH] Implement feature X
 * 
 * --- Menu ---
 * 1. Add New Task
 * 2. Complete Next Task
 * 3. View Pending Tasks
 * 4. View Completed Tasks
 * 5. Exit
 * ------------
 * Enter choice: 1
 * Enter task description: Write documentation
 * Enter task priority (HIGH, MEDIUM, LOW): low
 * Task added: [LOW] Write documentation
 * 
 * --- Menu ---
 * 1. Add New Task
 * 2. Complete Next Task
 * 3. View Pending Tasks
 * 4. View Completed Tasks
 * 5. Exit
 * ------------
 * Enter choice: 3
 * 
 * --- Pending Tasks ---
 * - [HIGH] Implement feature X
 * - [LOW] Write documentation
 * ---------------------
 * 
 * 
 * --- Menu ---
 * 1. Add New Task
 * 2. Complete Next Task
 * 3. View Pending Tasks
 * 4. View Completed Tasks
 * 5. Exit
 * ------------
 * Enter choice: 1
 * Enter task description: Fix bug Y
 * Enter task priority (HIGH, MEDIUM, LOW): URGENT
 * Error adding task: Invalid priority: URGENT. Must be HIGH, MEDIUM, or LOW.
 * 
 * --- Menu ---
 * 1. Add New Task
 * 2. Complete Next Task
 * 3. View Pending Tasks
 * 4. View Completed Tasks
 * 5. Exit
 * ------------
 * Enter choice: 2
 * Task completed: [HIGH] Implement feature X
 * 
 * --- Menu ---
 * 1. Add New Task
 * 2. Complete Next Task
 * 3. View Pending Tasks
 * 4. View Completed Tasks
 * 5. Exit
 * ------------
 * Enter choice: 3
 * 
 * --- Pending Tasks ---
 * - [LOW] Write documentation
 * ---------------------
 * 
 * 
 * --- Menu ---
 * 1. Add New Task
 * 2. Complete Next Task
 * 3. View Pending Tasks
 * 4. View Completed Tasks
 * 5. Exit
 * ------------
 * Enter choice: 4
 * 
 * --- Completed Tasks ---
 * 1. [HIGH] Implement feature X
 * -----------------------
 * 
 * 
 * --- Menu ---
 * 1. Add New Task
 * 2. Complete Next Task
 * 3. View Pending Tasks
 * 4. View Completed Tasks
 * 5. Exit
 * ------------
 * Enter choice: 2
 * Task completed: [LOW] Write documentation
 * 
 * --- Menu ---
 * 1. Add New Task
 * 2. Complete Next Task
 * 3. View Pending Tasks
 * 4. View Completed Tasks
 * 5. Exit
 * ------------
 * Enter choice: 2
 * Error completing task: No pending tasks to complete.
 * 
 * --- Menu ---
 * 1. Add New Task
 * 2. Complete Next Task
 * 3. View Pending Tasks
 * 4. View Completed Tasks
 * 5. Exit
 * ------------
 * Enter choice: invalid
 * Error input. Please enter a number.
 * 
 * --- Menu ---
 * 1. Add New Task
 * 2. Complete Next Task
 * 3. View Pending Tasks
 * 4. View Completed Tasks
 * 5. Exit
 * ------------
 * Enter choice: 5
 * Exiting Task Manager. Goodbye!
 * Scanner closed.
 * ```
 * 
 * Your solution should consist of one or more Java files that compile and run to produce the described behavior.
 *
 * EXPLANATION:
 * The solution implements a simple Task Management System using several core Java concepts and collections.
 * 
 * 1.  **`Task` Class:** This class serves as a simple Plain Old Java Object (POJO) to represent a task. It encapsulates the `description` and `priority` as private fields, providing public getter methods. The `toString()` method is overridden to provide a convenient string representation for printing tasks. This demonstrates encapsulation and basic object design.
 * 
 * 2.  **`TaskManager` Class:** This class is the core logic handler.
 *     *   It uses a `Queue<Task>` named `pendingTasks`, implemented by `LinkedList`. The `Queue` interface is appropriate here because tasks are processed in a First-In, First-Out (FIFO) manner: the task added earliest is the next one to be completed. `LinkedList` is a common and suitable implementation for `Queue`.
 *     *   It uses a `List<Task>` named `completedTasks`, implemented by `ArrayList`. The `List` interface and `ArrayList` are suitable for storing completed tasks because they provide ordered storage and easy access/iteration over the completed items.
 *     *   The `addTask` method demonstrates input validation by checking if the provided priority string is one of the allowed values ("HIGH", "MEDIUM", "LOW"), ignoring case and leading/trailing whitespace. It throws an `IllegalArgumentException` for invalid input, which is a standard way to signal invalid arguments to a method. It uses `pendingTasks.offer()` to add to the queue. `offer` is generally preferred over `add` for queues as it returns `false` instead of throwing an exception if the element cannot be added (though this is rare for unbounded queues like `LinkedList`).
 *     *   The `completeNextTask` method uses `pendingTasks.poll()` to remove and return the head of the queue. `poll()` is used because it returns `null` if the queue is empty, allowing us to check for this condition and throw an `IllegalStateException` (a standard way to signal that a method was called at an inappropriate time or state) rather than `remove()`, which would throw `NoSuchElementException`. The completed task is then added to the `completedTasks` list using `add()`.
 *     *   `viewPendingTasks` and `viewCompletedTasks` iterate through the respective collections and print their contents using the `Task` class's `toString()` method. Iterating over the `Queue` uses an enhanced for loop, which traverses the elements without removing them. Iterating over the `List` uses a traditional index-based loop to show an alternative iteration method and provide numbered output.
 * 
 * 3.  **`TaskApp` Class (Main Application):**
 *     *   This class contains the `main` method, which is the application entry point.
 *     *   It uses `java.util.Scanner` to read input from `System.in`.
 *     *   A `while` loop keeps the application running until the user chooses to exit.
 *     *   Inside the loop, a menu is printed, and the user's choice is read.
 *     *   A `try-catch` block specifically handles `InputMismatchException` that `scanner.nextInt()` might throw if the user enters non-integer input. This ensures the application doesn't crash and prompts the user again. `scanner.nextLine()` is used to consume the invalid input and the leftover newline character.
 *     *   A `switch` statement directs the program flow based on the user's valid integer choice, calling the appropriate `TaskManager` methods.
 *     *   Calls to `TaskManager` methods that might throw specific exceptions (`addTask`, `completeNextTask`) are wrapped in their own `try-catch` blocks to handle those specific errors and print informative messages to `System.err`.
 *     *   All normal application output (menu, confirmations, task listings) is directed to `System.out`.
 *     *   All error messages (invalid input, exceptions caught) are directed to `System.err`. This is a standard practice to separate application output from error output.
 *     *   The entire main application loop is wrapped in a larger `try-catch` block that catches a general `Exception`. This provides a safety net for any unexpected errors that might occur, preventing the program from crashing abruptly and printing a stack trace to `System.err` for debugging.
 *     *   A `finally` block is used to ensure that the `scanner.close()` method is always called before the program exits, releasing the underlying system resource.
 * 
 * This solution effectively demonstrates the practical use of `Queue`, `List`, `ArrayList`, `Scanner`, `switch`, `System.out`, `System.err`, and `try-catch` blocks in a cohesive, object-oriented structure with adherence to best practices like encapsulation, validation, and error handling.
 */

import java.util.Queue;
import java.util.LinkedList;
import java.util.List;
import java.util.ArrayList;
import java.util.Scanner;
import java.util.InputMismatchException;

/**
 * Represents a single task with a description and priority.
 */
class Task {
    private String description;
    private String priority;

    /**
     * Constructs a new Task.
     * @param description The description of the task.
     * @param priority The priority of the task (e.g., HIGH, MEDIUM, LOW).
     */
    public Task(String description, String priority) {
        this.description = description;
        this.priority = priority;
    }

    /**
     * Gets the description of the task.
     * @return The task description.
     */
    public String getDescription() {
        return description;
    }

    /**
     * Gets the priority of the task.
     * @return The task priority.
     */
    public String getPriority() {
        return priority;
    }

    /**
     * Returns a string representation of the task.
     * @return Formatted task string.
     */
    @Override
    public String toString() {
        return "[" + priority + "] " + description;
    }
}

/**
 * Manages collections of pending and completed tasks.
 */
class TaskManager {
    private Queue<Task> pendingTasks;
    private List<Task> completedTasks;

    /**
     * Constructs a new TaskManager, initializing task collections.
     */
    public TaskManager() {
        this.pendingTasks = new LinkedList<>(); // LinkedList implements Queue
        this.completedTasks = new ArrayList<>(); // ArrayList implements List
    }

    /**
     * Adds a new task to the pending tasks queue.
     * Validates the priority string.
     * @param description The task description.
     * @param priority The task priority (HIGH, MEDIUM, LOW). Case-insensitive.
     * @throws IllegalArgumentException if priority is invalid.
     */
    public void addTask(String description, String priority) {
        // Input validation for priority
        String upperPriority = priority.trim().toUpperCase();
        if (!upperPriority.equals("HIGH") && !upperPriority.equals("MEDIUM") && !upperPriority.equals("LOW")) {
            throw new IllegalArgumentException("Invalid priority: '" + priority + "'. Must be HIGH, MEDIUM, or LOW.");
        }
        Task newTask = new Task(description, upperPriority);
        pendingTasks.offer(newTask); // offer is preferred over add for queues, returns false on failure (rare for unbounded queues)
        System.out.println("Task added: " + newTask);
    }

    /**
     * Marks the next task in the queue as completed.
     * Removes it from pending and adds to completed list.
     * @throws IllegalStateException if the pending queue is empty.
     */
    public void completeNextTask() {
        Task completedTask = pendingTasks.poll(); // poll returns null if queue is empty
        if (completedTask == null) {
            throw new IllegalStateException("No pending tasks to complete.");
        }
        completedTasks.add(completedTask);
        System.out.println("Task completed: " + completedTask);
    }

    /**
     * Prints all pending tasks currently in the queue.
     */
    public void viewPendingTasks() {
        System.out.println("\n--- Pending Tasks ---");
        if (pendingTasks.isEmpty()) {
            System.out.println("No pending tasks.");
        } else {
            // Iterate over the queue without removing elements
            for (Task task : pendingTasks) {
                System.out.println("- " + task);
            }
        }
        System.out.println("---------------------\n");
    }

    /**
     * Prints all completed tasks currently in the list.
     */
    public void viewCompletedTasks() {
        System.out.println("\n--- Completed Tasks ---");
        if (completedTasks.isEmpty()) {
            System.out.println("No completed tasks.");
        } else {
            // Iterate over the list
            for (int i = 0; i < completedTasks.size(); i++) {
                 System.out.println((i + 1) + ". " + completedTasks.get(i));
            }
        }
        System.out.println("-----------------------\n");
    }
}

/**
 * Main application class for the Simple Task Manager.
 * Handles user interaction and orchestrates TaskManager operations.
 */
public class TaskApp {

    public static void main(String[] args) {
        TaskManager taskManager = new TaskManager();
        Scanner scanner = new Scanner(System.in);
        boolean running = true;

        System.out.println("--- Simple Task Manager ---");

        // Main application loop with class-wide exception handling
        try {
            while (running) {
                printMenu();
                int choice = -1;
                try {
                    System.out.print("Enter choice: ");
                    // Read integer choice, handles non-integer input with catch
                    choice = scanner.nextInt();
                    scanner.nextLine(); // Consume the newline character left by nextInt()
                } catch (InputMismatchException e) {
                    // Handle non-integer input gracefully
                    System.err.println("Invalid input. Please enter a number.");
                    scanner.nextLine(); // Consume the invalid input to prevent infinite loop
                    continue; // Skip the rest of the loop and show menu again
                }

                // Use switch statement for menu navigation
                switch (choice) {
                    case 1: // Add Task
                        System.out.print("Enter task description: ");
                        String description = scanner.nextLine();
                        System.out.print("Enter task priority (HIGH, MEDIUM, LOW): ");
                        String priority = scanner.nextLine();
                        try {
                            taskManager.addTask(description, priority);
                        } catch (IllegalArgumentException e) {
                            // Catch specific error for invalid priority
                            System.err.println("Error adding task: " + e.getMessage());
                        }
                        break;
                    case 2: // Complete Next Task
                        try {
                            taskManager.completeNextTask();
                        } catch (IllegalStateException e) {
                            // Catch specific error for empty queue completion attempt
                            System.err.println("Error completing task: " + e.getMessage());
                        }
                        break;
                    case 3: // View Pending Tasks
                        taskManager.viewPendingTasks();
                        break;
                    case 4: // View Completed Tasks
                        taskManager.viewCompletedTasks();
                        break;
                    case 5: // Exit
                        running = false;
                        System.out.println("Exiting Task Manager. Goodbye!");
                        break;
                    default:
                        // Handle choices outside the valid range
                        System.err.println("Invalid choice. Please enter a number between 1 and 5.");
                        break;
                }
            }
        } catch (Exception e) {
            // Catch any other unexpected runtime exceptions
            System.err.println("An unexpected error occurred: " + e.getMessage());
            e.printStackTrace(System.err); // Print stack trace for debugging purposes
        } finally {
            // Ensure scanner is closed regardless of how the try block exits
            scanner.close();
            // System.out.println("Scanner closed."); // Optional confirmation
        }
    }

    /**
     * Prints the main menu options to the console.
     */
    private static void printMenu() {
        System.out.println("\n--- Menu ---");
        System.out.println("1. Add New Task");
        System.out.println("2. Complete Next Task");
        System.out.println("3. View Pending Tasks");
        System.out.println("4. View Completed Tasks");
        System.out.println("5. Exit");
        System.out.println("------------");
    }
}
