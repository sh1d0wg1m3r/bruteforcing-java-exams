/*
 * Exam Question #564
 * Generated on: 2025-05-11 23:30:01
 * Generated by: Account 1
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Hospital Patient Check-in System
 * 
 * **Scenario:**
 * 
 * You are tasked with developing a simplified patient check-in and queuing system for a small hospital clinic. Patients arrive, check in, and wait in a queue to be called by a nurse or doctor. The system needs to manage a list of registered patients and a dynamic queue of patients who have currently checked in and are waiting.
 * 
 * **Requirements:**
 * 
 * Implement a Java program that fulfills the following requirements:
 * 
 * 1.  **Patient Representation:** Create a simple `Patient` class with private fields: `patientId` (String) and `name` (String). Include a constructor and public getter methods for these fields. Implement a meaningful `toString()` method for easy printing.
 * 2.  **System Core:** Create a class (e.g., `HospitalQueueManager`) that manages the patient data and the queue.
 *     *   It must have a private `List` (specifically an `ArrayList`) to store a pre-defined list of *all* registered patients.
 *     *   It must have a private `Queue` to store patients who have checked in and are currently waiting.
 *     *   Include a constructor that initializes these collections and populates the registered patient list with at least 5 sample patients.
 *     *   Implement the following public methods:
 *         *   `checkInPatient(String patientId)`: Finds the patient in the registered list by ID. If found and *not* already in the waiting queue, add them to the waiting queue and print a success message using `System.out`. If not found, print an error message using `System.err`. If already in the queue, print a different error message using `System.err`.
 *         *   `callNextPatient()`: Removes the patient at the front of the waiting queue. If the queue is not empty, print a message indicating which patient is being called using `System.out`. If the queue is empty, print an error message using `System.err`.
 *         *   `viewWaitingQueue()`: Prints the current list of patients in the waiting queue, from front to back, using `System.out`. Indicate if the queue is empty.
 *         *   `viewRegisteredPatients()`: Prints the list of all registered patients using `System.out`.
 * 3.  **User Interface:** Implement a `main` method (in a separate class, e.g., `HospitalApp`) that provides a text-based menu interface using `System.out` for prompts and menu options.
 *     *   Use `Scanner` to read user input (menu choices and patient IDs).
 *     *   Use a `switch` statement to handle the different menu options.
 *     *   The menu options should be:
 *         1.  Check In Patient
 *         2.  Call Next Patient
 *         3.  View Waiting Queue
 *         4.  View Registered Patients
 *         5.  Exit
 * 4.  **Error Handling & Validation:**
 *     *   Use `System.err` specifically for all error messages (e.g., invalid patient ID, queue empty, patient already checked in, invalid menu choice).
 *     *   Use `System.out` for all normal output (menu, prompts, success messages, displaying lists).
 *     *   Implement input validation:
 *         *   Ensure the entered patient ID for check-in is processed correctly.
 *         *   Handle cases where the user enters non-integer input for the menu choice using a `try-catch` block.
 *     *   Implement class-wide exception handling in the `main` method's processing loop using a `try-catch` block to catch potential runtime issues like `InputMismatchException` from the `Scanner` and provide a user-friendly error message using `System.err` before the loop continues.
 * 5.  **Best Practices:**
 *     *   Use appropriate data structures (`ArrayList` for registered, `Queue` for waiting). `LinkedList` is a common `Queue` implementation you can use.
 *     *   Follow encapsulation principles (private fields, public getters/methods).
 *     *   Use meaningful variable and method names.
 *     *   Include basic comments or Javadoc for clarity.
 *     *   Ensure the program handles empty queue conditions gracefully.
 * 
 * **Expected Output:**
 * 
 * The program should present a menu, accept user input, and perform the requested actions, printing appropriate messages to `System.out` or `System.err` based on success or failure.
 * 
 * Example Interaction Snippet:
 * 
 * ```
 * --- Hospital Clinic Menu ---
 * 1. Check In Patient
 * 2. Call Next Patient
 * 3. View Waiting Queue
 * 4. View Registered Patients
 * 5. Exit
 * Enter your choice: 1
 * Enter patient ID to check in: P102
 * Patient P102 (Jane Smith) checked in successfully.
 * 
 * --- Hospital Clinic Menu ---
 * 1. Check In Patient
 * 2. Call Next Patient
 * 3. View Waiting Queue
 * 4. View Registered Patients
 * 5. Exit
 * Enter your choice: 3
 * Waiting Queue:
 * P102 (Jane Smith)
 * 
 * --- Hospital Clinic Menu ---
 * 1. Check In Patient
 * 2. Call Next Patient
 * 3. View Waiting Queue
 * 4. View Registered Patients
 * 5. Exit
 * Enter your choice: 2
 * Calling next patient: P102 (Jane Smith)
 * 
 * --- Hospital Clinic Menu ---
 * 1. Check In Patient
 * 2. Call Next Patient
 * 3. View Waiting Queue
 * 4. View Registered Patients
 * 5. Exit
 * Enter your choice: 2
 * Error: Waiting queue is empty. No patient to call.
 * 
 * --- Hospital Clinic Menu ---
 * 1. Check In Patient
 * 2. Call Next Patient
 * 3. View Waiting Queue
 * 4. View Registered Patients
 * 5. Exit
 * Enter your choice: 6
 * Error: Invalid menu choice. Please try again.
 * 
 * --- Hospital Clinic Menu ---
 * 1. Check In Patient
 * 2. Call Next Patient
 * 3. View Waiting Queue
 * 4. View Registered Patients
 * 5. Exit
 * Enter your choice: abc
 * Error: Invalid input. Please enter a number.
 * --- Hospital Clinic Menu ---
 * ... (menu repeats)
 * ```
 * 
 * **Constraint:** You must use ALL of the following: `java.util.Queue`, `java.util.ArrayList`, `java.util.List`, `java.util.Scanner`, `switch` statement, `System.err`, `System.out`, `try-catch` blocks.
 *
 * EXPLANATION:
 * This solution implements a simplified hospital patient check-in system, demonstrating the required Java concepts in a practical context.
 * 
 * 1.  **Patient Class:** The `Patient` class is a simple Plain Old Java Object (POJO) representing a patient with `patientId` and `name`. It uses private fields and public getter methods, adhering to encapsulation. The `toString()` method provides a convenient way to print patient information.
 * 
 * 2.  **HospitalQueueManager Class:** This class is the core of the system logic.
 *     *   It uses a `private List<Patient> registeredPatients` (specifically initialized as an `ArrayList`) to store a fixed set of patients known to the system. `ArrayList` is suitable here for storing a collection where elements might be accessed sequentially or iterated over.
 *     *   It uses a `private Queue<Patient> waitingQueue` (specifically initialized as a `LinkedList`, which implements the `Queue` interface) to manage patients who have checked in. The `Queue` interface provides methods like `offer()` (to add to the end) and `poll()` (to remove from the front), which naturally fit the FIFO (First-In, First-Out) nature of a waiting line. `LinkedList` is a common and efficient choice for implementing `Queue` when frequent additions and removals from the ends are needed.
 *     *   The constructor initializes these collections and populates `registeredPatients` with sample data.
 *     *   `findRegisteredPatient` and `isPatientInQueue` are helper methods demonstrating searching within the `List` and `Queue` respectively. Note that checking if a patient is *in* the queue requires iterating over it, as `Queue` doesn't provide direct element access or efficient contains checking by default like a `Set` or `List` might (though `LinkedList`'s `contains` method works by iterating).
 *     *   `checkInPatient` demonstrates adding to the `Queue` (`offer`) after validating the patient exists in the `registeredPatients` list and is not already in the `waitingQueue`. It uses `System.out` for success and `System.err` for errors.
 *     *   `callNextPatient` demonstrates removing from the `Queue` (`poll`) and handles the case of an empty queue using `System.err`.
 *     *   `viewWaitingQueue` iterates through the `Queue` to display its contents without removing elements, using `System.out`.
 *     *   `viewRegisteredPatients` iterates through the `List` to display its contents using `System.out`.
 * 
 * 3.  **HospitalApp Class (Main Method):**
 *     *   This class contains the `main` method, which serves as the application's entry point and user interface handler.
 *     *   A `Scanner` object is used to read input from `System.in`.
 *     *   A `while` loop keeps the menu running until the user chooses to exit.
 *     *   A `switch` statement is used to process the user's integer choice, directing the program flow to the appropriate method calls on the `HospitalQueueManager` object.
 *     *   `System.out` is used for printing the menu and prompts.
 * 
 * 4.  **Error Handling and Validation:**
 *     *   `System.err` is used exclusively for printing error messages, making them distinct from normal output in environments that differentiate between standard output and standard error streams.
 *     *   Input validation is handled in two ways:
 *         *   Logical validation within `HospitalQueueManager` methods (e.g., checking if a patient ID exists, checking if the queue is empty, checking if a patient is already in the queue).
 *         *   Input type validation in the `main` method using a `try-catch(InputMismatchException)` block around `scanner.nextInt()`. This catches non-integer input gracefully, prints an error message to `System.err`, consumes the invalid input from the scanner buffer (`scanner.nextLine()`), and continues the loop, preventing a crash or infinite loop.
 *     *   A broader `try-catch(Exception e)` block wraps the main `while` loop. This serves as the "class-wide exception handling" requirement, catching any other unexpected runtime exceptions that might occur within the main execution flow and printing an error to `System.err`.
 * 
 * 5.  **Best Practices:**
 *     *   Interfaces (`List`, `Queue`) are used for variable declarations where appropriate, promoting flexibility.
 *     *   Specific implementations (`ArrayList`, `LinkedList`) are used for object instantiation.
 *     *   Fields are private, methods are public (except the internal helpers), ensuring proper encapsulation.
 *     *   Variable and method names are descriptive (`waitingQueue`, `checkInPatient`, `viewWaitingQueue`).
 *     *   Basic comments explain the purpose of classes and methods.
 *     *   Empty collection conditions are checked before attempting operations that would fail (e.g., `waitingQueue.poll()` is checked for null, `isEmpty()` is used before iterating empty lists/queues).
 *     *   The `Scanner` is closed in a `finally` block to release system resources.
 * 
 * This solution effectively combines the required Java components to build a functional, albeit simplified, system that demonstrates key programming concepts like data structures, object-oriented design, user interaction, and robust error handling.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.InputMismatchException;

// Represents a patient
class Patient {
    private String patientId;
    private String name;

    public Patient(String patientId, String name) {
        this.patientId = patientId;
        this.name = name;
    }

    public String getPatientId() {
        return patientId;
    }

    public String getName() {
        return name;
    }

    @Override
    public String toString() {
        return patientId + " (" + name + ")";
    }

    // Optional: equals and hashCode based on patientId if needed for searching in lists/queues efficiently
    // For this problem, simple iteration is sufficient as per requirements implied scope.
}

// Manages registered patients and the waiting queue
class HospitalQueueManager {
    // Using List interface and ArrayList implementation for registered patients
    private List<Patient> registeredPatients;
    // Using Queue interface and LinkedList implementation for the waiting queue
    private Queue<Patient> waitingQueue;

    public HospitalQueueManager() {
        // Initialize collections
        registeredPatients = new ArrayList<>();
        waitingQueue = new LinkedList<>(); // LinkedList implements Queue

        // Populate registered patients (at least 5 samples)
        registeredPatients.add(new Patient("P101", "Alice Johnson"));
        registeredPatients.add(new Patient("P102", "Jane Smith"));
        registeredPatients.add(new Patient("P103", "Bob Williams"));
        registeredPatients.add(new Patient("P104", "Charlie Brown"));
        registeredPatients.add(new Patient("P105", "Diana Prince"));
    }

    /**
     * Finds a patient by ID in the registered list.
     * @param patientId The ID to search for.
     * @return The Patient object if found, null otherwise.
     */
    private Patient findRegisteredPatient(String patientId) {
        for (Patient patient : registeredPatients) {
            if (patient.getPatientId().equalsIgnoreCase(patientId)) {
                return patient;
            }
        }
        return null;
    }

    /**
     * Checks if a patient is already in the waiting queue.
     * @param patientId The ID to check.
     * @return true if the patient is in the queue, false otherwise.
     */
    private boolean isPatientInQueue(String patientId) {
        // Iterate through the queue without removing elements
        for (Patient patient : waitingQueue) {
            if (patient.getPatientId().equalsIgnoreCase(patientId)) {
                return true;
            }
        }
        return false;
    }


    /**
     * Checks in a patient by finding them in registered list and adding to queue.
     * Prints status messages to System.out or System.err.
     * @param patientId The ID of the patient to check in.
     */
    public void checkInPatient(String patientId) {
        Patient patient = findRegisteredPatient(patientId);

        if (patient == null) {
            System.err.println("Error: Patient with ID " + patientId + " not found in registered list.");
        } else {
            if (isPatientInQueue(patientId)) {
                 System.err.println("Error: Patient " + patient.toString() + " is already checked in and waiting.");
            } else {
                waitingQueue.offer(patient); // offer() is preferred over add() for capacity-constrained queues, but works here too
                System.out.println("Patient " + patient.toString() + " checked in successfully.");
            }
        }
    }

    /**
     * Calls the next patient from the waiting queue.
     * Prints status messages to System.out or System.err.
     */
    public void callNextPatient() {
        Patient nextPatient = waitingQueue.poll(); // poll() retrieves and removes the head, returns null if empty

        if (nextPatient == null) {
            System.err.println("Error: Waiting queue is empty. No patient to call.");
        } else {
            System.out.println("Calling next patient: " + nextPatient.toString());
        }
    }

    /**
     * Prints the current contents of the waiting queue.
     * Prints to System.out.
     */
    public void viewWaitingQueue() {
        System.out.println("--- Waiting Queue ---");
        if (waitingQueue.isEmpty()) {
            System.out.println("The waiting queue is empty.");
        } else {
            // Iterate without removing elements
            for (Patient patient : waitingQueue) {
                System.out.println(patient.toString());
            }
        }
    }

    /**
     * Prints the list of all registered patients.
     * Prints to System.out.
     */
    public void viewRegisteredPatients() {
        System.out.println("--- Registered Patients ---");
        if (registeredPatients.isEmpty()) {
            System.out.println("No registered patients found.");
        } else {
            for (Patient patient : registeredPatients) {
                System.out.println(patient.toString());
            }
        }
    }
}

// Main application class with user interface
public class HospitalApp {

    public static void main(String[] args) {
        HospitalQueueManager queueManager = new HospitalQueueManager();
        Scanner scanner = new Scanner(System.in);
        boolean running = true;

        // Class-wide exception handling for the main menu loop
        try {
            while (running) {
                printMenu();

                int choice = -1;
                try {
                    System.out.print("Enter your choice: ");
                    choice = scanner.nextInt();
                    scanner.nextLine(); // Consume newline left-over
                } catch (InputMismatchException e) {
                    System.err.println("Error: Invalid input. Please enter a number.");
                    scanner.nextLine(); // Consume the invalid input to prevent infinite loop
                    continue; // Skip the rest of the loop and show menu again
                }

                // Using switch statement for flow control
                switch (choice) {
                    case 1:
                        System.out.print("Enter patient ID to check in: ");
                        String checkInId = scanner.nextLine();
                        queueManager.checkInPatient(checkInId);
                        break;
                    case 2:
                        queueManager.callNextPatient();
                        break;
                    case 3:
                        queueManager.viewWaitingQueue();
                        break;
                    case 4:
                        queueManager.viewRegisteredPatients();
                        break;
                    case 5:
                        System.out.println("Exiting Hospital Clinic System. Goodbye!");
                        running = false;
                        break;
                    default:
                        System.err.println("Error: Invalid menu choice. Please try again.");
                        break;
                }
                System.out.println(); // Add a blank line for readability
            }
        } catch (Exception e) {
            // Catch any other unexpected exceptions during execution
            System.err.println("An unexpected error occurred: " + e.getMessage());
            e.printStackTrace(); // Print stack trace for debugging
        } finally {
            // Ensure the scanner is closed
            scanner.close();
            System.out.println("Scanner closed.");
        }
    }

    /**
     * Prints the main menu options to System.out.
     */
    private static void printMenu() {
        System.out.println("--- Hospital Clinic Menu ---");
        System.out.println("1. Check In Patient");
        System.out.println("2. Call Next Patient");
        System.out.println("3. View Waiting Queue");
        System.out.println("4. View Registered Patients");
        System.out.println("5. Exit");
    }
}
