/*
 * Exam Question #354
 * Generated on: 2025-05-11 22:59:32
 * Generated by: Account 3
 * 
 * QUESTION:
 * **Java Programming Exam Task: Simple Task Processing System**
 * 
 * **Objective:**
 * Design and implement a command-line application for a simplified Task Processing System. This system will allow users to manage tasks through adding, queuing, processing, and viewing. The task is designed to test your understanding of core Java collections, control flow, input/output, and exception handling.
 * 
 * **Scenario:**
 * Imagine a basic workflow where tasks are created, then placed in a queue to await processing, and finally marked as completed after being processed. The system needs to keep track of all tasks ever created, regardless of their current state, and manage a separate queue for tasks ready for the next step in the workflow.
 * 
 * **Requirements:**
 * 
 * 1.  **Task Representation:**
 *     *   Create a class named `Task`.
 *     *   It must have private fields: a unique integer ID, a String description, and a `TaskStatus` (an enum you must define with states like `PENDING`, `IN_QUEUE`, `COMPLETED`).
 *     *   The task ID should be automatically assigned and incremented each time a new `Task` object is created (start IDs from 1).
 *     *   Implement public getter methods for all fields.
 *     *   Implement a public setter method *only* for the `status` field to allow controlled state changes.
 *     *   Override the `toString()` method to provide a user-friendly representation of the task (e.g., "Task [ID=..., Desc='...', Status=...]").
 * 
 * 2.  **Task Management Logic:**
 *     *   Create a class named `TaskManager`.
 *     *   This class will manage the collection of tasks. It must contain:
 *         *   A private field declared as `java.util.List<Task>` (use `java.util.ArrayList` as the concrete implementation) to store *all* tasks created in the system.
 *         *   A private field declared as `java.util.Queue<Task>` (use `java.util.LinkedList` as the concrete implementation, as it implements `Queue`) to store tasks that are currently in the `IN_QUEUE` status and waiting to be processed.
 *     *   Implement the following public methods in `TaskManager`:
 *         *   `addTask(String description)`: Creates a new `Task` with `PENDING` status and adds it to the list of all tasks. Validate that the description is not null or empty; if invalid, print an error to `System.err` and do not add the task.
 *         *   `queueTask(int taskId)`: Finds the task with the given ID in the list of all tasks. If found and its current status is `PENDING`, change its status to `IN_QUEUE` and add it to the processing queue. If the task is not found or is not in `PENDING` status, print an appropriate error message to `System.err`.
 *         *   `processNextTask()`: Removes the task from the front of the processing queue. If the queue is not empty, change the removed task's status to `COMPLETED`. If the queue is empty, print an error message to `System.err`.
 *         *   `viewAllTasks()`: Prints the details (using the `toString()` method) of all tasks currently stored in the list of all tasks, regardless of their status. If the list is empty, print a message indicating no tasks exist.
 * 
 * 3.  **User Interface and Control Flow:**
 *     *   Create a main class (e.g., `TaskSystem`) with a `main` method.
 *     *   Use `java.util.Scanner` to read user input from the console.
 *     *   Implement a loop that repeatedly displays a menu with options:
 *         1.  Add New Task
 *         2.  Queue Task by ID
 *         3.  Process Next Task from Queue
 *         4.  View All Tasks
 *         5.  Exit
 *     *   Use a `switch` statement based on the user's menu choice to call the appropriate `TaskManager` method or perform the exit action.
 *     *   Use `System.out` for displaying the menu, prompts, success messages, and task lists.
 *     *   Use `System.err` for displaying all error messages generated by input validation or `TaskManager` operations.
 * 
 * 4.  **Exception Handling:**
 *     *   Implement robust exception handling using `try-catch` blocks.
 *     *   Include "class-wide" exception handling by wrapping the main application loop in a `try-catch` block to catch any unexpected runtime exceptions and print an error message and stack trace to `System.err` before the program potentially terminates.
 *     *   Include specific `try-catch` blocks around `Scanner` input operations that expect integers (`nextInt()`) to handle `InputMismatchException` gracefully, printing an error to `System.err` and preventing the program from crashing or entering an infinite input loop. Ensure the invalid input is consumed.
 * 
 * 5.  **Best Practices:**
 *     *   Follow proper encapsulation principles (private fields, public methods).
 *     *   Use meaningful names for classes, methods, variables, and constants.
 *     *   Include appropriate comments (especially Javadoc for classes and methods) to explain the code's purpose and functionality.
 *     *   Implement input validation where necessary (e.g., task description not empty, valid menu choice, valid task ID format).
 *     *   Ensure resources like the `Scanner` are properly closed (e.g., in a `finally` block or after the main loop).
 * 
 * **Expected Output:**
 * 
 * The program should interact with the user via the console, displaying the menu, prompts, and results or error messages as described in the requirements. The output should be clear and easy to follow, demonstrating the system's state changes. Refer to the example interaction provided in the problem description (or create your own based on the requirements).
 * 
 * ```
 * --- Simple Task Processing System ---
 * 
 * --- Menu ---
 * 1. Add New Task
 * 2. Queue Task by ID
 * 3. Process Next Task from Queue
 * 4. View All Tasks
 * 5. Exit
 * ------------
 * Enter your choice: <user input>
 * ... (System response based on input)
 * ```
 *
 * EXPLANATION:
 * This solution implements a Simple Task Processing System as requested, demonstrating the use of various core Java concepts and data structures.
 * 
 * **System Structure:**
 * The system is composed of three main parts:
 * 1.  `Task`: Represents a single unit of work with an ID, description, and status.
 * 2.  `TaskManager`: Manages the collection of tasks using a `List` and a `Queue`, and provides methods for task operations.
 * 3.  `TaskSystem`: Contains the `main` method, handles user interaction via the console, controls the application flow, and manages error handling.
 * 
 * **Key Concepts Demonstrated:**
 * 
 * 1.  **`java.util.Queue`:** The `taskQueue` in `TaskManager` is declared as a `Queue` and implemented using `LinkedList`. This demonstrates the use of a queue for managing tasks in a First-In, First-Out (FIFO) manner for processing. The `offer()` method is used for adding tasks, and `poll()` is used for retrieving and removing the next task, which are standard `Queue` operations.
 * 2.  **`java.util.ArrayList`:** The `allTasks` list in `TaskManager` is implemented using `ArrayList`. This is suitable for storing all tasks, allowing easy iteration (`viewAllTasks`) and lookup by ID (`findTaskById`).
 * 3.  **`java.util.List` interface:** The `allTasks` field is declared using the `List` interface (`List<Task> allTasks = new ArrayList<>();`). This adheres to the principle of programming to interfaces, making the code more flexible should a different `List` implementation be desired later.
 * 4.  **`java.util.Scanner`:** Used in the `TaskSystem.main` method to read user input from the console (`System.in`) for menu choices and task details.
 * 5.  **`switch` statement:** Used in the `TaskSystem.main` method to control the program flow based on the user's numeric menu selection, directing execution to the appropriate logic block for each option.
 * 6.  **`System.err`:** Used consistently throughout the code (in `TaskManager` and `TaskSystem`) to output error messages, distinguishing them from normal program output.
 * 7.  **`System.out`:** Used for standard output, including displaying the menu, prompts, confirmation messages for successful operations (adding, queuing, processing), and the list of all tasks.
 * 8.  **Class-wide exception handling with `try-catch`:** The main `while` loop in `TaskSystem.main` is wrapped in a `try-catch(Exception e)` block. This provides a safety net to catch any unhandled exceptions that might occur during the program's execution, printing an error message and stack trace before exiting, preventing an abrupt crash.
 * 
 * **Other Best Practices:**
 * 
 * *   **Encapsulation:** The `Task` and `TaskManager` classes use private fields and public methods to control access to their internal data and state, promoting data integrity.
 * *   **Meaningful Names:** Variables, methods, and classes have descriptive names (e.g., `taskQueue`, `allTasks`, `addTask`, `processNextTask`, `TaskStatus`).
 * *   **Comments and Documentation:** Javadoc comments are used for classes and methods to explain their purpose, parameters, and return values. Inline comments explain specific logic points.
 * *   **Input Validation:** The `addTask` method checks for empty descriptions. The `TaskSystem.main` method uses `try-catch` blocks to handle `InputMismatchException` when reading integer inputs (menu choice, task ID), preventing crashes and infinite loops caused by non-numeric input.
 * *   **Proper Error Handling:** Specific error messages are printed to `System.err` for various failure conditions (task not found, task not in correct status for queuing, queue empty for processing, invalid menu choice).
 * *   **Clean Code Structure:** The logic is separated into distinct classes (`Task`, `TaskManager`, `TaskSystem`), improving organization and maintainability.
 * *   **Resource Management:** The `Scanner` resource is closed in a `finally` block to ensure it is released regardless of how the program exits the main loop.
 * 
 * **Workflow Implementation:**
 * 
 * *   New tasks are created with `PENDING` status and stored in the `allTasks` `List`.
 * *   Users can select a `PENDING` task by ID to move it to the `IN_QUEUE` status and add it to the `taskQueue`.
 * *   The `processNextTask` operation retrieves the oldest task from the `taskQueue` (FIFO) and changes its status to `COMPLETED`.
 * *   `viewAllTasks` allows seeing all tasks and their current statuses from the `allTasks` `List`.
 * 
 * This solution effectively integrates the required components within a practical scenario, demonstrating understanding of data structures, object-oriented principles, user interaction, and robust error handling in Java.
 */

// TaskStatus enum to represent the state of a task
enum TaskStatus {
    PENDING, IN_QUEUE, COMPLETED
}

// Task class representing a single task item
class Task {
    // Static counter to generate unique IDs for each task
    private static int nextId = 1;

    private int id;
    private String description;
    private TaskStatus status;

    /**
     * Constructs a new Task.
     * Automatically assigns a unique ID and sets initial status to PENDING.
     * @param description The description of the task.
     */
    public Task(String description) {
        this.id = nextId++; // Assign unique ID and increment counter
        this.description = description;
        this.status = TaskStatus.PENDING; // New tasks are initially PENDING
    }

    // --- Getters ---
    /**
     * Gets the unique ID of the task.
     * @return The task ID.
     */
    public int getId() {
        return id;
    }

    /**
     * Gets the description of the task.
     * @return The task description.
     */
    public String getDescription() {
        return description;
    }

    /**
     * Gets the current status of the task.
     * @return The task status (PENDING, IN_QUEUE, or COMPLETED).
     */
    public TaskStatus getStatus() {
        return status;
    }

    // --- Setter for status (controlled access) ---
    /**
     * Sets the status of the task.
     * This method allows updating the task's state in the workflow.
     * @param status The new status for the task.
     */
    public void setStatus(TaskStatus status) {
        this.status = status;
    }

    /**
     * Provides a user-friendly string representation of the Task.
     * @return Formatted string including ID, Description, and Status.
     */
    @Override
    public String toString() {
        return "Task [ID=" + id + ", Desc='" + description + "', Status=" + status + "]";
    }
}

// TaskManager class to handle collections and operations on tasks
import java.util.ArrayList;
import java.util.LinkedList; // LinkedList implements Queue interface
import java.util.List;     // Use List interface for flexibility
import java.util.Queue;    // Use Queue interface for queue operations

/**
 * Manages tasks within the system, maintaining a list of all tasks and a processing queue.
 */
class TaskManager {
    // List to hold all tasks ever created in the system.
    // Declared as List interface, instantiated as ArrayList.
    private List<Task> allTasks;

    // Queue to hold tasks that are in the IN_QUEUE status, waiting for processing.
    // Declared as Queue interface, instantiated as LinkedList.
    private Queue<Task> taskQueue;

    /**
     * Constructs a new TaskManager, initializing the task list and queue.
     */
    public TaskManager() {
        // Use ArrayList for efficient random access and storage of all tasks
        allTasks = new ArrayList<>();
        // Use LinkedList as a concrete implementation for the Queue,
        // providing efficient additions/removals from the ends.
        taskQueue = new LinkedList<>();
    }

    /**
     * Adds a new task to the system.
     * The task is initially created with PENDING status and added to the list of all tasks.
     * Validates that the description is not empty.
     * @param description The task description.
     * @return The newly created Task, or null if description is invalid.
     */
    public Task addTask(String description) {
        if (description == null || description.trim().isEmpty()) {
             // Use System.err for error messages as required
             System.err.println("Error: Task description cannot be empty.");
             return null; // Indicate failure
        }
        Task newTask = new Task(description.trim());
        allTasks.add(newTask); // Add to the list of all tasks
        // Use System.out for normal operation messages
        System.out.println("Added: " + newTask);
        return newTask;
    }

    /**
     * Finds a task by its ID in the list of all tasks.
     * This is a helper method used internally by TaskManager.
     * @param taskId The ID of the task to find.
     * @return The Task object if found, null otherwise.
     */
    private Task findTaskById(int taskId) {
        // Iterate through the list to find the task by ID
        for (Task task : allTasks) {
            if (task.getId() == taskId) {
                return task;
            }
        }
        return null; // Task not found
    }

    /**
     * Moves a pending task to the processing queue.
     * Task must exist and be in PENDING status to be queued.
     * @param taskId The ID of the task to queue.
     */
    public void queueTask(int taskId) {
        Task task = findTaskById(taskId);
        if (task == null) {
            // Use System.err for error messages
            System.err.println("Error: Task with ID " + taskId + " not found.");
            return;
        }

        // Check if the task is in the correct status to be queued
        if (task.getStatus() == TaskStatus.PENDING) {
            task.setStatus(TaskStatus.IN_QUEUE); // Update status in the allTasks list
            taskQueue.offer(task); // Add to the processing queue (offer is recommended over add)
            // Use System.out for normal operation messages
            System.out.println("Queued: " + task);
        } else {
            // Use System.err for error messages
            System.err.println("Error: Task " + taskId + " is not in PENDING status (current status: " + task.getStatus() + "). Cannot queue.");
        }
    }

    /**
     * Processes the next task from the front of the processing queue.
     * The task's status is updated to COMPLETED.
     * Reports an error if the queue is empty.
     */
    public void processNextTask() {
        // Check if the queue is empty before attempting to process
        if (taskQueue.isEmpty()) {
            // Use System.err for error messages
            System.err.println("Error: Task queue is empty. Nothing to process.");
            return;
        }

        // Retrieve and remove the head of the queue.
        // poll() returns null if the queue is empty, but we checked with isEmpty().
        Task taskToProcess = taskQueue.poll();

        // Although poll() is safe, defensive check for null
        if (taskToProcess != null) {
             // Update the status of the task.
             // The Task object in taskQueue is the same instance reference as in the allTasks list,
             // so updating its status here updates it in both places logically.
             taskToProcess.setStatus(TaskStatus.COMPLETED);
             // Use System.out for normal operation messages
             System.out.println("Processed: " + taskToProcess);
        } else {
             // This case should ideally not be reached due to the isEmpty check,
             // but included for robustness.
             System.err.println("Internal Error: Failed to retrieve task from queue despite it not being empty.");
        }
    }

    /**
     * Displays details of all tasks currently in the system, regardless of status.
     * Iterates through the list of all tasks.
     */
    public void viewAllTasks() {
        if (allTasks.isEmpty()) {
            System.out.println("No tasks in the system yet.");
            return;
        }
        // Use System.out for normal output
        System.out.println("\n--- All Tasks ---");
        // Iterate through the list of all tasks
        for (Task task : allTasks) {
            System.out.println(task); // Calls Task.toString()
        }
        System.out.println("-----------------");
    }
}

// Main class for the Simple Task Processing System User Interface
import java.util.InputMismatchException; // To catch non-integer input errors
import java.util.Scanner;               // For reading user input

/**
 * Main class to run the Simple Task Processing System application.
 * Provides a command-line interface for user interaction using Scanner and a switch statement.
 * Includes exception handling using try-catch blocks and uses System.out/System.err.
 */
public class TaskSystem {

    /**
     * Main method - the entry point of the application.
     * Initializes the TaskManager and Scanner, runs the main command loop.
     * Includes class-wide and specific exception handling.
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        // Scanner for reading user input from the console (System.in)
        Scanner scanner = new Scanner(System.in);
        // TaskManager instance to handle the task data and logic
        TaskManager taskManager = new TaskManager();
        boolean running = true; // Flag to control the main application loop

        // Use System.out for initial welcome message
        System.out.println("--- Simple Task Processing System ---");

        // --- Class-wide Exception Handling ---
        // Wrap the main application loop in a try-catch block
        // to catch any unexpected exceptions that might occur
        try {
            // Main application loop
            while (running) {
                printMenu(); // Display the menu options to the user
                // Use System.out for prompts
                System.out.print("Enter your choice: ");

                int choice;
                // --- Specific Input Exception Handling ---
                // Use a try-catch block specifically for reading integer input
                // to handle cases where the user enters non-numeric text.
                try {
                    choice = scanner.nextInt();
                    // Consume the leftover newline character after reading the integer
                    scanner.nextLine();
                } catch (InputMismatchException e) {
                    // Use System.err for error messages related to invalid input
                    System.err.println("Invalid input. Please enter a number corresponding to a menu option.");
                    // Consume the invalid input from the scanner buffer to prevent an infinite loop
                    scanner.nextLine();
                    // Skip the rest of the loop body and continue to the next iteration (redisplay menu)
                    continue;
                }

                // --- Flow Control using Switch Statement ---
                // Use a switch statement to execute actions based on the user's valid numeric choice
                switch (choice) {
                    case 1: // Add New Task
                        System.out.print("Enter task description: ");
                        String description = scanner.nextLine();
                        taskManager.addTask(description); // Call the TaskManager method
                        break;
                    case 2: // Queue Task by ID
                        System.out.print("Enter Task ID to queue: ");
                        // --- Specific Input Exception Handling for Task ID ---
                        // Another try-catch for reading the task ID, similar to the menu choice
                        try {
                            int taskIdToQueue = scanner.nextInt();
                            scanner.nextLine(); // Consume newline
                            taskManager.queueTask(taskIdToQueue); // Call the TaskManager method
                        } catch (InputMismatchException e) {
                            System.err.println("Invalid input. Please enter a valid Task ID (a number).");
                            scanner.nextLine(); // Consume invalid input
                        }
                        break;
                    case 3: // Process Next Task
                        taskManager.processNextTask(); // Call the TaskManager method
                        break;
                    case 4: // View All Tasks
                        taskManager.viewAllTasks(); // Call the TaskManager method
                        break;
                    case 5: // Exit
                        System.out.println("Exiting system. Goodbye!");
                        running = false; // Set the flag to false to terminate the loop
                        break;
                    default:
                        // Handle cases where the number entered is not a valid menu option
                        System.err.println("Invalid choice. Please enter a number between 1 and 5.");
                }
                // Add a blank line for better readability between user interactions
                System.out.println();
            }
        } catch (Exception e) {
            // --- Class-wide Exception Handling Catch Block ---
            // This block catches any other unexpected runtime exceptions
            System.err.println("An unexpected error occurred during application execution: " + e.getMessage());
            e.printStackTrace(); // Print the stack trace for debugging purposes
        } finally {
            // --- Resource Cleanup ---
            // The finally block ensures that the scanner resource is closed
            // regardless of whether an exception occurred or the loop finished normally.
            if (scanner != null) {
                scanner.close();
                System.out.println("Scanner resource closed.");
            }
        }
    }

    /**
     * Prints the main menu options to the console using System.out.
     */
    private static void printMenu() {
        System.out.println("\n--- Menu ---");
        System.out.println("1. Add New Task");
        System.out.println("2. Queue Task by ID");
        System.out.println("3. Process Next Task from Queue");
        System.out.println("4. View All Tasks");
        System.out.println("5. Exit");
        System.out.println("------------");
    }
}
