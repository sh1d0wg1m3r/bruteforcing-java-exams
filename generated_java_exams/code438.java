/*
 * Exam Question #438
 * Generated on: 2025-05-11 23:11:18
 * Generated by: Account 1
 * 
 * QUESTION:
 * **Java Programming Exam Task: Advanced Service Desk Simulation**
 * 
 * **Scenario:**
 * 
 * You are tasked with building a simplified command-line application for managing support tickets in a small IT service desk. The system needs to handle incoming tickets, process them in order, and allow viewing of both pending and completed tickets.
 * 
 * **Requirements:**
 * 
 * Implement a Java application consisting of at least two classes:
 * 
 * 1.  **`Ticket` Class:**
 *     *   Represents a single support ticket.
 *     *   Must have private fields for `id` (int), `description` (String), and `status` (an enum like `TicketStatus` with states like `PENDING`, `PROCESSED`).
 *     *   Provide a constructor to initialize a ticket with an ID and description, setting the initial status to `PENDING`.
 *     *   Include public getter methods for all fields.
 *     *   Include a public method `process()` that changes the ticket's status to `PROCESSED`.
 *     *   Override the `toString()` method to provide a user-friendly string representation of the ticket (e.g., "Ticket #<id> [<status>]: <description>").
 * 
 * 2.  **`ServiceDesk` Class:**
 *     *   Manages collections of `Ticket` objects.
 *     *   Must have private fields:
 *         *   A `Queue` to store pending tickets. Use the `java.util.Queue` interface type.
 *         *   A `List` to store processed tickets. Use the `java.util.List` interface type.
 *         *   An integer counter for generating unique ticket IDs.
 *     *   Provide a constructor to initialize the collections and the ID counter.
 *     *   Implement the following public methods:
 *         *   `addTicket(String description)`: Creates a new `Ticket` object with a unique ID and the provided description, and adds it to the pending tickets queue. Print a confirmation message using `System.out`.
 *         *   `processNextTicket()`: Removes the next ticket from the pending queue, calls its `process()` method, and adds it to the processed tickets list. Print a confirmation message using `System.out`. If the pending queue is empty, print an error message using `System.err`.
 *         *   `viewPendingTickets()`: Prints all tickets currently in the pending queue using `System.out`. If the queue is empty, print a message indicating that.
 *         *   `viewProcessedTickets()`: Prints all tickets currently in the processed list using `System.out`. If the list is empty, print a message indicating that.
 * 
 * 3.  **Main Application Logic (in a separate class, e.g., `ServiceDeskApp`):**
 *     *   Create a `main` method to run the application.
 *     *   Instantiate `ServiceDesk` and `Scanner` objects.
 *     *   Implement a command-line interface that presents the user with a menu of options:
 *         1.  Add New Ticket
 *         2.  Process Next Ticket
 *         3.  View Pending Tickets
 *         4.  View Processed Tickets
 *         5.  Exit
 *     *   Use a `Scanner` to read the user's menu choice and any required input (like ticket description).
 *     *   Use a `switch` statement to handle the different menu options, calling the appropriate `ServiceDesk` methods.
 *     *   Include input validation for the menu choice (ensure it's a valid integer within the range). If input is invalid, print an error message using `System.err`.
 *     *   Implement class-wide exception handling using `try-catch` blocks to gracefully handle potential runtime errors (e.g., non-integer input for menu choice, unexpected issues). Print error details to `System.err`.
 *     *   Ensure `System.out` is used for normal application output and prompts, and `System.err` is used exclusively for error messages.
 *     *   The application should loop until the user chooses to exit.
 *     *   Ensure the `Scanner` resource is properly managed (e.g., using try-with-resources).
 * 
 * **Constraints & Specific Requirements:**
 * 
 * *   You MUST use `java.util.Queue` for pending tickets.
 * *   You MUST use `java.util.ArrayList` for processed tickets and declare the variable using the `java.util.List` interface type.
 * *   You MUST use `java.util.Scanner` for user input.
 * *   You MUST use a `switch` statement for handling menu options.
 * *   You MUST use `System.err` for all error messages.
 * *   You MUST use `System.out` for all normal output (menu, prompts, ticket details, success messages).
 * *   You MUST implement class-wide exception handling using `try-catch`.
 * *   Follow best practices: meaningful names, encapsulation (private fields, public methods), comments, basic input validation.
 * 
 * **Expected Output:**
 * 
 * The application should interact with the user via the console, displaying a menu, prompting for input, and printing status updates, ticket details, and error messages as appropriate. Example flow:
 * 
 * ```
 * Service Desk Menu:
 * 1. Add New Ticket
 * 2. Process Next Ticket
 * 3. View Pending Tickets
 * 4. View Processed Tickets
 * 5. Exit
 * Enter choice: 1
 * Enter ticket description: Printer not working
 * 
 * Ticket #1 added successfully.
 * 
 * Service Desk Menu:
 * ...
 * Enter choice: 1
 * Enter ticket description: Cannot access network drive
 * 
 * Ticket #2 added successfully.
 * 
 * Service Desk Menu:
 * ...
 * Enter choice: 3
 * 
 * --- Pending Tickets ---
 * Ticket #1 [PENDING]: Printer not working
 * Ticket #2 [PENDING]: Cannot access network drive
 * -----------------------
 * 
 * Service Desk Menu:
 * ...
 * Enter choice: 2
 * 
 * Processing ticket #1: Printer not working
 * Ticket #1 processed successfully.
 * 
 * Service Desk Menu:
 * ...
 * Enter choice: 3
 * 
 * --- Pending Tickets ---
 * Ticket #2 [PENDING]: Cannot access network drive
 * -----------------------
 * 
 * Service Desk Menu:
 * ...
 * Enter choice: 4
 * 
 * --- Processed Tickets ---
 * Ticket #1 [PROCESSED]: Printer not working
 * -------------------------
 * 
 * Service Desk Menu:
 * ...
 * Enter choice: 99
 * Invalid choice. Please enter a number between 1 and 5.
 * 
 * Service Desk Menu:
 * ...
 * Enter choice: abc
 * Invalid input. Please enter a number.
 * 
 * Service Desk Menu:
 * ...
 * Enter choice: 2
 * No pending tickets to process.
 * 
 * Service Desk Menu:
 * ...
 * Enter choice: 5
 * 
 * Exiting Service Desk application.
 * ```
 * 
 * Your code should be well-structured, readable, and correctly implement all specified requirements.
 *
 * EXPLANATION:
 * This solution implements a simple Service Desk application demonstrating the required Java concepts and best practices.
 * 
 * 1.  **`Ticket` Class:**
 *     *   Represents the core data entity.
 *     *   Uses private fields (`id`, `description`, `status`) for encapsulation.
 *     *   Provides public getters to access the data.
 *     *   Includes a `process()` method to change the internal state (`status`), encapsulating the state transition logic.
 *     *   Overrides `toString()` for easy printing of ticket details.
 *     *   An `enum` `TicketStatus` is used for status, providing type safety and readability compared to simple strings or integers.
 * 
 * 2.  **`ServiceDesk` Class:**
 *     *   Acts as the manager for the `Ticket` objects.
 *     *   Uses a `Queue<Ticket>` (`LinkedList` implementation) for `pendingTickets`. This correctly models the "process next" requirement, as `Queue` inherently provides FIFO (First-In, First-Out) behavior via `add()` and `poll()`.
 *     *   Uses a `List<Ticket>` (`ArrayList` implementation) for `processedTickets`. `ArrayList` is suitable for storing items where order is maintained and iteration is common. The variable is correctly declared using the `List` interface type, adhering to the requirement and promoting good practice (programming to interfaces).
 *     *   Includes an `nextTicketId` counter, managed internally and incremented upon adding a new ticket, ensuring unique IDs.
 *     *   Methods like `addTicket`, `processNextTicket`, `viewPendingTickets`, and `viewProcessedTickets` encapsulate the operations on the ticket collections.
 *     *   `processNextTicket()` uses `poll()` which safely returns `null` if the queue is empty, allowing for graceful handling of this scenario.
 * 
 * 3.  **`ServiceDeskApp` Class (Main Application):**
 *     *   Contains the `main` method, the entry point of the application.
 *     *   Initializes `ServiceDesk` and `Scanner`.
 *     *   Uses a `try-with-resources` block for the `Scanner` to ensure it's automatically closed when the block is exited, preventing resource leaks.
 *     *   The main application loop runs within a larger `try-catch` block. This demonstrates class-wide exception handling, catching unexpected `Exception` types that might occur during the execution of the loop, preventing the application from crashing abruptly.
 *     *   Inside the loop:
 *         *   A menu is printed using `System.out`.
 *         *   User input for the menu choice is read using `scanner.nextInt()`.
 *         *   Input validation for the menu choice is implemented using a nested `while` loop and a `try-catch(InputMismatchException)`. This specifically handles cases where the user enters non-integer input, printing an error to `System.err` and prompting again. `scanner.nextLine()` is crucial after `nextInt()` to consume the leftover newline character.
 *         *   A `switch` statement is used to direct the flow based on the validated user choice, calling the appropriate `ServiceDesk` methods.
 *         *   The `default` case in the `switch` handles invalid integer choices (outside the 1-5 range), printing an error to `System.err`.
 *         *   `System.out` is used for all normal output (menu, prompts, success messages, ticket listings).
 *         *   `System.err` is used exclusively for error messages (invalid input, no tickets to process, unexpected exceptions).
 * 
 * **Demonstrated Concepts:**
 * 
 * *   **Object-Oriented Programming:** Using classes (`Ticket`, `ServiceDesk`, `ServiceDeskApp`), encapsulation (private fields, public methods), and methods (`process`, `addTicket`, etc.).
 * *   **Data Structures:** Practical use of `Queue` (FIFO behavior for pending items) and `List` (`ArrayList` implementation for storing processed items). Using interfaces (`Queue`, `List`) for variable declarations.
 * *   **Enums:** Defining a fixed set of possible states (`TicketStatus`) for clarity and type safety.
 * *   **Input/Output:** Reading user input with `Scanner`, printing normal output with `System.out`, printing error output with `System.err`.
 * *   **Control Flow:** Using `while` loops for the main application loop and input validation, and a `switch` statement for multi-way branching based on user choice.
 * *   **Exception Handling:** Implementing `try-catch` blocks for robust error handling, including specific handling for `InputMismatchException` and a general catch for unexpected runtime errors. Using `try-with-resources` for `Scanner`.
 * *   **Best Practices:** Meaningful variable/method names, comments, basic input validation, separating concerns into different classes.
 * 
 * This solution effectively combines multiple core Java concepts to build a functional, albeit simple, application that simulates a real-world scenario while adhering strictly to all specified requirements.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.InputMismatchException;

// Enum for ticket status
enum TicketStatus {
    PENDING,
    PROCESSED
}

// Represents a support ticket
class Ticket {
    private int id;
    private String description;
    private TicketStatus status;

    /**
     * Constructs a new Ticket.
     * @param id The unique ID for the ticket.
     * @param description A brief description of the issue.
     */
    public Ticket(int id, String description) {
        this.id = id;
        this.description = description;
        this.status = TicketStatus.PENDING; // New tickets are always pending
    }

    // --- Getters ---
    public int getId() {
        return id;
    }

    public String getDescription() {
        return description;
    }

    public TicketStatus getStatus() {
        return status;
    }

    /**
     * Changes the status of the ticket to PROCESSED.
     */
    public void process() {
        this.status = TicketStatus.PROCESSED;
    }

    @Override
    public String toString() {
        return String.format("Ticket #%d [%s]: %s", id, status, description);
    }
}

// Manages the collection of tickets
class ServiceDesk {
    // Use Queue for pending tickets (FIFO processing)
    private Queue<Ticket> pendingTickets;
    // Use List for processed tickets
    private List<Ticket> processedTickets;
    // Counter for generating unique ticket IDs
    private int nextTicketId;

    /**
     * Constructs a new ServiceDesk.
     * Initializes ticket collections and ID counter.
     */
    public ServiceDesk() {
        // LinkedList implements the Queue interface
        this.pendingTickets = new LinkedList<>();
        // ArrayList implements the List interface
        this.processedTickets = new ArrayList<>();
        this.nextTicketId = 1; // Start ticket IDs from 1
    }

    /**
     * Adds a new ticket to the pending queue.
     * @param description The description of the new ticket.
     */
    public void addTicket(String description) {
        if (description == null || description.trim().isEmpty()) {
             System.err.println("Error: Ticket description cannot be empty.");
             return; // Prevent adding empty tickets
        }
        Ticket newTicket = new Ticket(nextTicketId++, description.trim());
        pendingTickets.add(newTicket);
        System.out.println("Ticket #" + newTicket.getId() + " added successfully.");
    }

    /**
     * Processes the next ticket in the pending queue.
     * Removes it from pending, marks it processed, and moves it to the processed list.
     */
    public void processNextTicket() {
        // poll() removes the head of the queue, returns null if queue is empty
        Ticket ticketToProcess = pendingTickets.poll();

        if (ticketToProcess != null) {
            System.out.println("Processing ticket #" + ticketToProcess.getId() + ": " + ticketToProcess.getDescription());
            ticketToProcess.process(); // Change status
            processedTickets.add(ticketToProcess); // Move to processed list
            System.out.println("Ticket #" + ticketToProcess.getId() + " processed successfully.");
        } else {
            // Use System.err for error message
            System.err.println("No pending tickets to process.");
        }
    }

    /**
     * Prints details of all tickets currently in the pending queue.
     */
    public void viewPendingTickets() {
        System.out.println("\n--- Pending Tickets ---");
        if (pendingTickets.isEmpty()) {
            System.out.println("No pending tickets.");
        } else {
            // Iterate through the queue without removing elements
            for (Ticket ticket : pendingTickets) {
                System.out.println(ticket); // Uses Ticket's toString()
            }
        }
        System.out.println("-----------------------");
    }

    /**
     * Prints details of all tickets currently in the processed list.
     */
    public void viewProcessedTickets() {
        System.out.println("\n--- Processed Tickets ---");
        if (processedTickets.isEmpty()) {
            System.out.println("No processed tickets.");
        } else {
            // Iterate through the list
            for (Ticket ticket : processedTickets) {
                System.out.println(ticket); // Uses Ticket's toString()
            }
        }
        System.out.println("-------------------------");
    }
}

// Main application class to run the Service Desk
public class ServiceDeskApp {

    public static void main(String[] args) {
        // Use try-with-resources to ensure the Scanner is closed
        try (Scanner scanner = new Scanner(System.in)) {
            ServiceDesk serviceDesk = new ServiceDesk();
            boolean running = true;

            // Class-wide exception handling for the main loop
            try {
                while (running) {
                    printMenu();
                    int choice = -1; // Default invalid choice

                    // Input validation loop for menu choice
                    while (true) {
                         System.out.print("Enter choice: ");
                         try {
                             choice = scanner.nextInt();
                             scanner.nextLine(); // Consume newline left-over
                             break; // Exit validation loop if input is valid integer
                         } catch (InputMismatchException e) {
                             System.err.println("Invalid input. Please enter a number.");
                             scanner.nextLine(); // Consume the invalid input
                         }
                    }


                    // Use switch statement for flow control based on user choice
                    switch (choice) {
                        case 1: // Add New Ticket
                            System.out.print("Enter ticket description: ");
                            String description = scanner.nextLine();
                            serviceDesk.addTicket(description);
                            break;
                        case 2: // Process Next Ticket
                            serviceDesk.processNextTicket();
                            break;
                        case 3: // View Pending Tickets
                            serviceDesk.viewPendingTickets();
                            break;
                        case 4: // View Processed Tickets
                            serviceDesk.viewProcessedTickets();
                            break;
                        case 5: // Exit
                            running = false;
                            System.out.println("Exiting Service Desk application.");
                            break;
                        default: // Invalid choice
                            System.err.println("Invalid choice. Please enter a number between 1 and 5.");
                            break;
                    }
                    // Optional: Add a pause or prompt before showing menu again
                    // System.out.println("\nPress Enter to continue...");
                    // scanner.nextLine(); // Wait for user to press Enter

                }
            } catch (Exception e) {
                // Catch any unexpected runtime exceptions within the main loop
                System.err.println("An unexpected error occurred: " + e.getMessage());
                // Optionally print stack trace for debugging during development/testing
                // e.printStackTrace(System.err);
            }

        } // Scanner is automatically closed here by try-with-resources
        catch (Exception e) {
             // Catch exceptions related to Scanner initialization or closing
             System.err.println("Error initializing or closing scanner: " + e.getMessage());
        }
    }

    /**
     * Prints the main menu options to the console.
     */
    private static void printMenu() {
        System.out.println("\nService Desk Menu:");
        System.out.println("1. Add New Ticket");
        System.out.println("2. Process Next Ticket");
        System.out.println("3. View Pending Tickets");
        System.out.println("4. View Processed Tickets");
        System.out.println("5. Exit");
    }
}
