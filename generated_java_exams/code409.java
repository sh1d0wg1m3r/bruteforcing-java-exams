/*
 * Exam Question #409
 * Generated on: 2025-05-11 23:07:01
 * Generated by: Account 3
 * 
 * QUESTION:
 * **Subject:** Advanced Java Programming
 * **Task Title:** Print Shop Job Management System
 * 
 * **Problem Description:**
 * 
 * You are tasked with developing a console-based application for a small print shop to manage customer print jobs. The system should handle incoming jobs, process them in the order they are received, and keep a record of completed jobs.
 * 
 * Your solution must adhere to the following requirements:
 * 
 * 1.  **Job Representation:** Create a class `PrintJob` to represent a print job. Each job should have a unique ID, a file name (String), the number of pages (int), and a status (e.g., PENDING, PROCESSING, COMPLETED). Use an enum for the status.
 * 2.  **Job Management:** Create a class `PrintShopManager` that will manage the print jobs.
 *     *   It must use a `java.util.Queue` to hold jobs waiting to be processed (pending jobs).
 *     *   It must use a `java.util.List` (specifically, an `ArrayList` implementation) to store completed jobs.
 *     *   Implement methods within `PrintShopManager`:
 *         *   `submitJob(String fileName, int pages)`: Adds a new job to the pending queue. Assign a unique ID automatically. Validate that the number of pages is positive; if not, handle this error.
 *         *   `processNextJob()`: Takes the next job from the pending queue, changes its status to PROCESSING, simulates processing (e.g., print a message), changes status to COMPLETED, and moves it to the completed jobs list. Handle the case where the pending queue is empty.
 *         *   `viewPendingJobs()`: Displays all jobs currently in the pending queue without removing them.
 *         *   `viewCompletedJobs()`: Displays all jobs in the completed list.
 * 3.  **User Interface:** Implement a simple console interface in a `main` method.
 *     *   Use `java.util.Scanner` to read user input.
 *     *   Provide a menu with options: Submit New Job, Process Next Job, View Pending Jobs, View Completed Jobs, Exit.
 *     *   Use a `switch` statement to handle the user's choice.
 * 4.  **Error Handling:**
 *     *   Implement robust input validation, especially for numerical inputs (like pages and menu choices).
 *     *   Use `System.err` to display error messages (e.g., invalid input, trying to process an empty queue, invalid pages).
 *     *   Use `System.out` for all normal output (menu, prompts, success messages, job details).
 *     *   Implement **class-wide exception handling** using a `try-catch` block that wraps the main application loop in your `main` method to catch any unexpected runtime errors. Handle specific expected errors (like invalid input or business logic errors) with more targeted `try-catch` blocks or conditional checks within the relevant methods/switch cases.
 * 5.  **Best Practices:**
 *     *   Apply proper encapsulation (private fields, public methods).
 *     *   Use meaningful variable and method names.
 *     *   Include appropriate comments and documentation (e.g., Javadoc for methods).
 *     *   Ensure resources like `Scanner` are properly closed.
 * 
 * **Expected Output:**
 * 
 * The program should display a menu, accept user input, perform the requested action, print relevant output or error messages, and continue until the user chooses to exit.
 * 
 * Example interaction flow:
 * ```
 * --- Print Shop Menu ---
 * 1. Submit New Job
 * 2. Process Next Job
 * 3. View Pending Jobs
 * 4. View Completed Jobs
 * 5. Exit
 * -----------------------
 * Enter your choice: 1
 * Enter file name: report.pdf
 * Enter number of pages: 10
 * Job submitted successfully: report.pdf (ID: 1)
 * 
 * --- Print Shop Menu ---
 * ...
 * Enter your choice: 1
 * Enter file name: presentation.pptx
 * Enter number of pages: 5
 * Job submitted successfully: presentation.pptx (ID: 2)
 * 
 * --- Print Shop Menu ---
 * ...
 * Enter your choice: 3
 * --- Pending Jobs ---
 * 1. Job ID: 1, File: report.pdf, Pages: 10, Status: PENDING
 * 2. Job ID: 2, File: presentation.pptx, Pages: 5, Status: PENDING
 * --------------------
 * 
 * --- Print Shop Menu ---
 * ...
 * Enter your choice: 2
 * Processing job: report.pdf (ID: 1)
 * Job completed: report.pdf (ID: 1)
 * 
 * --- Print Shop Menu ---
 * ...
 * Enter your choice: 3
 * --- Pending Jobs ---
 * 1. Job ID: 2, File: presentation.pptx, Pages: 5, Status: PENDING
 * --------------------
 * 
 * --- Print Shop Menu ---
 * ...
 * Enter your choice: 4
 * --- Completed Jobs ---
 * 1. Job ID: 1, File: report.pdf, Pages: 10, Status: COMPLETED
 * --------------------
 * 
 * --- Print Shop Menu ---
 * ...
 * Enter your choice: 2
 * Processing job: presentation.pptx (ID: 2)
 * Job completed: presentation.pptx (ID: 2)
 * 
 * --- Print Shop Menu ---
 * ...
 * Enter your choice: 2
 * Error processing job: No pending jobs to process. // Using System.err
 * 
 * --- Print Shop Menu ---
 * ...
 * Enter your choice: abc // Invalid input
 * Invalid input. Please enter a number. // Using System.err
 * 
 * --- Print Shop Menu ---
 * ...
 * Enter your choice: 1
 * Enter file name: invalid.txt
 * Enter number of pages: -5
 * Error submitting job: Number of pages must be positive. // Using System.err
 * 
 * --- Print Shop Menu ---
 * ...
 * Enter your choice: 5
 * Exiting Print Shop Manager. Goodbye!
 * ```
 *
 * EXPLANATION:
 * This solution implements a simple Print Shop Job Management system that effectively utilizes the required Java components and adheres to best practices.
 * 
 * 1.  **`PrintJob` Class:** Represents a print job with essential attributes (ID, file name, pages, status). An `enum` `JobStatus` is used for clarity and type safety regarding job states. A static counter ensures unique job IDs.
 * 2.  **`PrintShopManager` Class:** This is the core of the system logic.
 *     *   It uses a `java.util.Queue<PrintJob>` (`pendingJobs`) implemented by `LinkedList` to maintain the order of incoming jobs (First-In, First-Out).
 *     *   It uses a `java.util.List<PrintJob>` (`completedJobs`) referenced by the `List` interface but instantiated as an `ArrayList` to store jobs after processing. `ArrayList` is suitable here as we primarily add to and iterate over the list.
 *     *   The `submitJob` method adds new jobs to the `pendingJobs` queue using `offer()`. It includes input validation for the number of pages, throwing an `IllegalArgumentException` if invalid.
 *     *   The `processNextJob` method uses `poll()` to retrieve and remove the head of the `pendingJobs` queue. It updates the job status and moves it to the `completedJobs` list. It throws an `IllegalStateException` if the queue is empty, demonstrating handling of a specific business logic error. A small `Thread.sleep` is included to simulate work.
 *     *   `viewPendingJobs` iterates through the `pendingJobs` queue without removing elements.
 *     *   `viewCompletedJobs` iterates through the `completedJobs` list.
 * 3.  **`PrintShopApp` (Main Class):**
 *     *   Contains the `main` method, which is the application entry point.
 *     *   A `Scanner` object is used to read user input from the console (`System.in`).
 *     *   The main application logic is enclosed within a `do-while` loop that continues until the user chooses to exit (option 5).
 *     *   A `switch` statement handles the different menu options, directing execution to the appropriate `PrintShopManager` methods.
 * 4.  **Error Handling:**
 *     *   `System.err.println()` is used exclusively for displaying error messages, distinguishing them from normal output (`System.out.println()`).
 *     *   Input validation for the main menu choice is done using `scanner.hasNextInt()` and consuming invalid input with `scanner.next()`.
 *     *   Input validation for the 'pages' input in the "Submit Job" case uses a nested `try-catch` block specifically for `InputMismatchException`.
 *     *   Business logic errors (like non-positive pages or processing an empty queue) are handled by throwing specific exceptions (`IllegalArgumentException`, `IllegalStateException`) from the `PrintShopManager` methods. These exceptions are then caught in the `main` method's `switch` cases, and informative error messages are printed to `System.err`.
 *     *   A **class-wide `try-catch (Exception e)` block** wraps the entire `do-while` loop in `main`. This serves as a fallback to catch any other unexpected runtime exceptions that might occur, preventing the program from crashing abruptly and providing a generic error message.
 *     *   The `Scanner` resource is closed in a `finally` block to ensure it's released even if exceptions occur.
 * 5.  **Best Practices:**
 *     *   Fields in `PrintJob` and `PrintShopManager` are `private`, accessed via `public` methods (getters and setters), demonstrating encapsulation.
 *     *   Variable names (`pendingJobs`, `completedJobs`, `fileName`, `pages`, `jobId`) and method names (`submitJob`, `processNextJob`, `viewPendingJobs`) are descriptive.
 *     *   Javadoc comments explain the purpose of classes and methods.
 *     *   The code is structured logically into separate classes for different responsibilities.
 * 
 * This solution requires students to integrate data structures (`Queue`, `List`/`ArrayList`), user input (`Scanner`), control flow (`switch`, `do-while`), and robust error handling (`try-catch`, `System.err`, input validation, specific exceptions) in a practical, albeit simplified, application context, demonstrating an advanced understanding of core Java concepts.
 */

import java.util.Queue;
import java.util.LinkedList;
import java.util.List;
import java.util.ArrayList;
import java.util.Scanner;
import java.util.InputMismatchException;

// Enum to represent the status of a print job
enum JobStatus {
    PENDING,
    PROCESSING,
    COMPLETED
}

// Class to represent a single print job
class PrintJob {
    private static int nextJobId = 1; // Static counter for unique IDs
    private int jobId;
    private String fileName;
    private int pages;
    private JobStatus status;

    /**
     * Constructs a new PrintJob.
     * @param fileName The name of the file for the job.
     * @param pages The number of pages in the file.
     */
    public PrintJob(String fileName, int pages) {
        this.jobId = nextJobId++;
        this.fileName = fileName;
        this.pages = pages;
        this.status = JobStatus.PENDING; // New jobs start as PENDING
    }

    // --- Getters ---
    public int getJobId() {
        return jobId;
    }

    public String getFileName() {
        return fileName;
    }

    public int getPages() {
        return pages;
    }

    public JobStatus getStatus() {
        return status;
    }

    // --- Setter for status ---
    public void setStatus(JobStatus status) {
        this.status = status;
    }

    /**
     * Provides a string representation of the PrintJob.
     */
    @Override
    public String toString() {
        return "Job ID: " + jobId + ", File: " + fileName + ", Pages: " + pages + ", Status: " + status;
    }
}

// Class to manage the print shop operations
class PrintShopManager {
    // Queue for jobs waiting to be processed
    private Queue<PrintJob> pendingJobs;
    // List for jobs that have been completed
    private List<PrintJob> completedJobs;

    /**
     * Constructs a PrintShopManager, initializing the job queues and lists.
     */
    public PrintShopManager() {
        this.pendingJobs = new LinkedList<>(); // LinkedList implements Queue
        this.completedJobs = new ArrayList<>(); // ArrayList implements List
    }

    /**
     * Submits a new print job to the pending queue.
     * Validates that the number of pages is positive.
     * @param fileName The name of the file to print.
     * @param pages The number of pages.
     * @throws IllegalArgumentException if pages is less than or equal to 0.
     */
    public void submitJob(String fileName, int pages) {
        if (pages <= 0) {
            // Throw an exception for business logic validation failure
            throw new IllegalArgumentException("Number of pages must be positive.");
        }
        PrintJob newJob = new PrintJob(fileName, pages);
        pendingJobs.offer(newJob); // offer() is the preferred way to add to a queue
        System.out.println("Job submitted successfully: " + newJob.getFileName() + " (ID: " + newJob.getJobId() + ")");
    }

    /**
     * Processes the next job in the pending queue.
     * Removes the job from pending, marks it as completed, and adds it to the completed list.
     * @throws IllegalStateException if the pending queue is empty.
     */
    public void processNextJob() {
        // Check if the queue is empty before trying to poll
        if (pendingJobs.isEmpty()) {
            // Throw an exception for business logic validation failure
            throw new IllegalStateException("No pending jobs to process.");
        }

        PrintJob jobToProcess = pendingJobs.poll(); // poll() removes and returns the head of the queue

        if (jobToProcess != null) { // poll() returns null if queue is empty, though we checked above
            jobToProcess.setStatus(JobStatus.PROCESSING);
            System.out.println("Processing job: " + jobToProcess.getFileName() + " (ID: " + jobToProcess.getJobId() + ")");

            // Simulate processing time (optional, for realism)
            try {
                Thread.sleep(500); // Pause for 500 milliseconds
            } catch (InterruptedException e) {
                // Restore the interrupted status
                Thread.currentThread().interrupt();
                System.err.println("Job processing was interrupted.");
            }

            jobToProcess.setStatus(JobStatus.COMPLETED);
            completedJobs.add(jobToProcess); // Add to the completed list
            System.out.println("Job completed: " + jobToProcess.getFileName() + " (ID: " + jobToProcess.getJobId() + ")");
        }
    }

    /**
     * Displays all jobs currently in the pending queue.
     */
    public void viewPendingJobs() {
        if (pendingJobs.isEmpty()) {
            System.out.println("No pending jobs.");
            return;
        }
        System.out.println("--- Pending Jobs ---");
        // Iterate over the queue elements without removing them
        int index = 1;
        for (PrintJob job : pendingJobs) {
            System.out.println(index++ + ". " + job);
        }
        System.out.println("--------------------");
    }

    /**
     * Displays all jobs that have been completed.
     */
    public void viewCompletedJobs() {
        if (completedJobs.isEmpty()) {
            System.out.println("No completed jobs.");
            return;
        }
        System.out.println("--- Completed Jobs ---");
        // Iterate over the list elements
        for (int i = 0; i < completedJobs.size(); i++) {
            System.out.println((i + 1) + ". " + completedJobs.get(i));
        }
        System.out.println("--------------------");
    }
}

// Main class to run the application
public class PrintShopApp { // Renamed from Main to be more descriptive
    public static void main(String[] args) {
        PrintShopManager manager = new PrintShopManager();
        Scanner scanner = new Scanner(System.in);

        // Class-wide exception handling for the main application loop
        try {
            int choice;
            // Main application loop
            do {
                printMenu();
                System.out.print("Enter your choice: ");

                // Validate if the input is an integer before reading
                if (!scanner.hasNextInt()) {
                    System.err.println("Invalid input. Please enter a number.");
                    scanner.next(); // Consume the invalid input (non-integer string)
                    continue; // Skip the rest of the loop and show the menu again
                }

                choice = scanner.nextInt();
                scanner.nextLine(); // Consume the leftover newline character after reading the integer

                // Use switch for flow control based on user choice
                switch (choice) {
                    case 1: // Submit New Job
                        System.out.print("Enter file name: ");
                        String fileName = scanner.nextLine();
                        System.out.print("Enter number of pages: ");
                        try {
                            // Use hasNextInt() again or wrap in try-catch for the pages input
                            int pages = scanner.nextInt();
                            scanner.nextLine(); // Consume newline after pages integer
                            manager.submitJob(fileName, pages);
                        } catch (InputMismatchException e) {
                            System.err.println("Invalid input for pages. Please enter an integer.");
                            scanner.nextLine(); // Consume the invalid input
                        } catch (IllegalArgumentException e) {
                            // Catch validation errors from submitJob method
                            System.err.println("Error submitting job: " + e.getMessage());
                        }
                        break;

                    case 2: // Process Next Job
                        try {
                            manager.processNextJob();
                        } catch (IllegalStateException e) {
                            // Catch business logic error from processNextJob (empty queue)
                            System.err.println("Error processing job: " + e.getMessage());
                        }
                        break;

                    case 3: // View Pending Jobs
                        manager.viewPendingJobs();
                        break;

                    case 4: // View Completed Jobs
                        manager.viewCompletedJobs();
                        break;

                    case 5: // Exit
                        System.out.println("Exiting Print Shop Manager. Goodbye!");
                        break;

                    default:
                        // Handle choices outside the 1-5 range
                        System.err.println("Invalid choice. Please enter a number between 1 and 5.");
                }
            } while (choice != 5); // Loop continues until user chooses 5

        } catch (Exception e) {
            // Generic catch block for any unexpected runtime exceptions
            System.err.println("An unexpected application error occurred: " + e.getMessage());
            // e.printStackTrace(); // Uncomment for debugging purposes to see the full stack trace
        } finally {
            // Ensure the scanner resource is closed regardless of exceptions
            if (scanner != null) {
                scanner.close();
            }
        }
    }

    /**
     * Prints the main menu options to the console.
     */
    private static void printMenu() {
        System.out.println("\n--- Print Shop Menu ---");
        System.out.println("1. Submit New Job");
        System.out.println("2. Process Next Job");
        System.out.println("3. View Pending Jobs");
        System.out.println("4. View Completed Jobs");
        System.out.println("5. Exit");
        System.out.println("-----------------------");
    }
}
