/*
 * Exam Question #942
 * Generated on: 2025-05-12 17:02:56
 * Generated by: Account 1
 * 
 * QUESTION:
 * **Java Programming Exam: Advanced Task Dispatcher System**
 * 
 * **Problem Description:**
 * 
 * You are tasked with developing a simple Task Dispatcher System for a service company. The system should manage incoming tasks, process them in the order they arrive, and keep a record of completed tasks. The system must be interactive, allowing a user (or operator) to add new tasks, process the next pending task, view pending tasks, and view completed tasks via a command-line interface.
 * 
 * Your solution must demonstrate advanced understanding of Java collections, I/O, control flow, object-oriented programming, and exception handling.
 * 
 * **Requirements:**
 * 
 * 1.  **Task Representation:** Create a `Task` class with private fields for a unique integer ID and a String description. Include a constructor and public getter methods for these fields. Override the `toString()` method to provide a user-friendly representation of a task (e.g., "Task #ID: Description").
 * 2.  **Task Dispatcher Logic:** Create a `TaskDispatcher` class that manages the system's state and operations.
 *     *   It must contain a private `Queue<Task>` to hold tasks that are waiting to be processed (pending tasks). Use a `java.util.LinkedList` to implement the `Queue`.
 *     *   It must contain a private `List<Task>` to hold tasks that have been completed. Use a `java.util.ArrayList` and declare the field using the `java.util.List` interface type.
 *     *   Include a private integer counter to generate unique task IDs, starting from 1.
 *     *   Implement the following public methods:
 *         *   `addTask(String description)`: Creates a new `Task` with the next available ID and the given description, and adds it to the pending tasks queue. Print a confirmation message to `System.out`. Validate that the description is not null or empty; if invalid, print an error message to `System.err` and do not add the task.
 *         *   `processNextTask()`: Removes the task at the front of the pending tasks queue. If a task is successfully retrieved, add it to the completed tasks list and print a confirmation message to `System.out`. If the queue is empty, print a message indicating no pending tasks to `System.out`.
 *         *   `viewPendingTasks()`: Prints all tasks currently in the pending queue to `System.out`. If the queue is empty, print a message indicating no pending tasks.
 *         *   `viewCompletedTasks()`: Prints all tasks currently in the completed list to `System.out`. If the list is empty, print a message indicating no completed tasks.
 * 3.  **User Interface:** Implement a command-line interface within the `TaskDispatcher` class (e.g., in a `runSystem()` method called from `main`).
 *     *   Use `java.util.Scanner` to read user input from `System.in`.
 *     *   Present a menu of options to the user (Add Task, Process Task, View Pending, View Completed, Exit).
 *     *   Use a `switch` statement to handle the user's menu choice and call the appropriate `TaskDispatcher` methods.
 *     *   Continue prompting the user for input until they choose the "Exit" option.
 * 4.  **Error Handling:**
 *     *   Implement class-wide exception handling. The main loop processing user input within `TaskDispatcher` should be wrapped in a `try-catch` block to catch potential unexpected runtime exceptions. Print an error message and the exception details (e.g., using `e.printStackTrace()`) to `System.err` if an unexpected error occurs.
 *     *   Specifically handle `java.util.InputMismatchException` if the user enters non-integer input when a number is expected (e.g., for the menu choice). Print an informative error message to `System.err` and recover to prompt the user again.
 *     *   Use `System.err` for all error messages and `System.out` for all normal output (prompts, confirmations, task listings).
 *     *   Ensure the `Scanner` resource is properly closed when the system exits, preferably using a `finally` block or try-with-resources.
 * 5.  **Best Practices:**
 *     *   Follow standard Java coding conventions.
 *     *   Use meaningful variable and method names.
 *     *   Include appropriate comments and Javadoc where necessary.
 *     *   Ensure proper encapsulation (`private` fields, `public` methods).
 * 
 * **Expected Output:**
 * 
 * The system should display a menu, accept integer input for choices, and perform actions based on the choice. Example flow:
 * 
 * ```
 * --- Task Dispatcher System ---
 * 
 * Select an option:
 * 1. Add New Task
 * 2. Process Next Task
 * 3. View Pending Tasks
 * 4. View Completed Tasks
 * 0. Exit
 * Enter your choice: 1
 * Enter task description: Fix network issue
 * Added task: Task #1: Fix network issue
 * 
 * Press Enter to continue...
 * 
 * Select an option:
 * ... (menu repeats)
 * Enter your choice: 1
 * Enter task description: Install software update
 * Added task: Task #2: Install software update
 * 
 * Press Enter to continue...
 * 
 * Select an option:
 * ...
 * Enter your choice: 3
 * --- Pending Tasks ---
 * Task #1: Fix network issue
 * Task #2: Install software update
 * ---------------------
 * 
 * Press Enter to continue...
 * 
 * Select an option:
 * ...
 * Enter your choice: 2
 * Processed task: Task #1: Fix network issue
 * 
 * Press Enter to continue...
 * 
 * Select an option:
 * ...
 * Enter your choice: 3
 * --- Pending Tasks ---
 * Task #2: Install software update
 * ---------------------
 * 
 * Press Enter to continue...
 * 
 * Select an option:
 * ...
 * Enter your choice: 4
 * --- Completed Tasks ---
 * Task #1: Fix network issue
 * -----------------------
 * 
 * Press Enter to continue...
 * 
 * Select an option:
 * ...
 * Enter your choice: abc
 * Invalid input. Please enter a number.
 * 
 * Press Enter to continue...
 * 
 * Select an option:
 * ...
 * Enter your choice: 9
 * Invalid choice. Please enter a number between 0 and 4.
 * 
 * Press Enter to continue...
 * 
 * Select an option:
 * ...
 * Enter your choice: 0
 * Exiting system. Goodbye!
 * Scanner closed.
 * ```
 * 
 * Implement the `Task` and `TaskDispatcher` classes in a single file for submission. The entry point should be the `main` method in the `TaskDispatcher` class.
 *
 * EXPLANATION:
 * The solution implements a Task Dispatcher System as required, demonstrating the use of various Java concepts and components.
 * 
 * 1.  **Task Class:** A simple POJO (`Plain Old Java Object`) representing a task with an ID and description. Encapsulation is achieved through private fields and public getter methods. The `toString()` method provides a convenient way to print task details.
 * 
 * 2.  **TaskDispatcher Class:** This is the core class managing the system's logic and state.
 *     *   **Queue (`pendingTasks`):** A `java.util.Queue` interface is used, implemented by `java.util.LinkedList`. This is appropriate because tasks are processed in the order they arrive (FIFO - First-In, First-Out), which is the fundamental behavior of a queue. `LinkedList` provides efficient `offer()` (add to end) and `poll()` (remove from front) operations.
 *     *   **List (`completedTasks`):** A `java.util.List` interface is used, implemented by `java.util.ArrayList`. The `List` interface provides standard methods for accessing and iterating over elements. `ArrayList` is a common and efficient choice for storing a dynamic list of elements, especially when random access (though not strictly needed here) or simple iteration is required. Using the interface type (`List`) for the field promotes flexibility.
 *     *   **Encapsulation:** All collection fields (`pendingTasks`, `completedTasks`) and the ID counter (`nextTaskId`) are private, ensuring they can only be modified via the class's public methods.
 *     *   **Methods:** Methods like `addTask`, `processNextTask`, `viewPendingTasks`, and `viewCompletedTasks` provide the public interface for interacting with the system's state. `addTask` uses `offer` to add to the queue. `processNextTask` uses `poll` to retrieve and remove from the queue, gracefully handling the case where the queue is empty by checking for a `null` return value.
 * 
 * 3.  **User Interface (`runSystem` method):**
 *     *   **Scanner:** A `java.util.Scanner` is used to read input from `System.in`. It's instantiated once and reused within the loop. The `scanner.nextLine()` call after `scanner.nextInt()` is crucial to consume the leftover newline character, preventing issues with subsequent `nextLine()` calls reading an empty string.
 *     *   **Switch Statement:** A `switch` statement is used to cleanly route execution based on the integer input received from the user. This provides clear flow control for the menu options. The `default` case handles invalid integer inputs.
 *     *   **Loop:** A `while` loop keeps the system running until the user enters '0'.
 * 
 * 4.  **Error Handling:**
 *     *   **Class-wide try-catch:** The main `while` loop within `runSystem` is wrapped in a `try-catch (Exception e)` block. This demonstrates catching unexpected runtime exceptions that might occur anywhere within the loop's execution, providing a fallback mechanism to prevent the program from crashing abruptly. Error details are printed to `System.err`.
 *     *   **Specific InputMismatchException:** An inner `try-catch (InputMismatchException e)` block specifically targets errors when `scanner.nextInt()` is called but the user provides non-integer input. This is a common and expected type of error with `Scanner`, and handling it specifically allows for a more user-friendly error message printed to `System.err`, followed by consuming the invalid input (`scanner.nextLine()`) to clear the scanner's buffer and allow the loop to continue.
 *     *   **System.err vs. System.out:** As required, `System.err` is strictly used for error messages (invalid choice, invalid input, unexpected exceptions), while `System.out` is used for all normal program output (menu, prompts, confirmations, task listings).
 *     *   **Resource Management (Scanner):** The `finally` block ensures that `scanner.close()` is called when the `try` block is exited, whether normally or due to an exception. This is important for releasing system resources held by the `Scanner`.
 * 
 * 5.  **Best Practices:** The code follows standard conventions, uses descriptive names for classes, variables, and methods, includes comments explaining the purpose of different parts, and adheres to encapsulation principles. Input validation is performed for the task description.
 * 
 * This solution effectively integrates the required components and demonstrates essential Java programming concepts in a practical scenario.
 */

import java.util.Queue;
import java.util.LinkedList;
import java.util.List;
import java.util.ArrayList;
import java.util.Scanner;
import java.util.InputMismatchException;

/**
 * Represents a single task in the system.
 */
class Task {
    private int id;
    private String description;

    /**
     * Constructs a new Task.
     * @param id The unique identifier for the task.
     * @param description A brief description of the task.
     */
    public Task(int id, String description) {
        this.id = id;
        this.description = description;
    }

    /**
     * Gets the task ID.
     * @return The task ID.
     */
    public int getId() {
        return id;
    }

    /**
     * Gets the task description.
     * @return The task description.
     */
    public String getDescription() {
        return description;
    }

    /**
     * Provides a string representation of the task.
     * @return Formatted string including task ID and description.
     */
    @Override
    public String toString() {
        return "Task #" + id + ": " + description;
    }
}

/**
 * Manages pending and completed tasks using a Queue and a List.
 * Provides a command-line interface for interaction.
 */
public class TaskDispatcher {
    private Queue<Task> pendingTasks; // Queue for tasks waiting to be processed (FIFO)
    private List<Task> completedTasks; // List for tasks that have been completed
    private int nextTaskId; // Counter to generate unique task IDs
    private Scanner scanner; // Scanner for reading user input

    /**
     * Constructs a new TaskDispatcher system.
     * Initializes the task collections and the task ID counter.
     */
    public TaskDispatcher() {
        // Use LinkedList as it implements the Queue interface efficiently for this use case
        this.pendingTasks = new LinkedList<>();
        // Use ArrayList as it implements the List interface and is suitable for storing completed tasks
        this.completedTasks = new ArrayList<>();
        this.nextTaskId = 1;
        // Initialize scanner for reading from standard input
        this.scanner = new Scanner(System.in);
    }

    /**
     * Adds a new task to the pending tasks queue.
     * @param description The description of the task.
     */
    public void addTask(String description) {
        // Input validation: Check if description is null or empty/whitespace only
        if (description == null || description.trim().isEmpty()) {
            // Use System.err for error messages as required
            System.err.println("Error: Task description cannot be empty.");
            return; // Exit the method without adding a task
        }
        Task newTask = new Task(nextTaskId++, description.trim());
        pendingTasks.offer(newTask); // offer() is preferred over add() for capacity-constrained queues (though LinkedList isn't) and returns boolean
        // Use System.out for normal confirmation messages
        System.out.println("Added task: " + newTask);
    }

    /**
     * Processes the next task from the pending queue.
     * Removes the task from the queue and adds it to the completed list.
     */
    public void processNextTask() {
        // poll() retrieves and removes the head of the queue, returning null if the queue is empty
        Task taskToProcess = pendingTasks.poll();
        if (taskToProcess != null) {
            completedTasks.add(taskToProcess); // Add the processed task to the completed list
            // Use System.out for normal confirmation messages
            System.out.println("Processed task: " + taskToProcess);
        } else {
            // Use System.out for informational messages when no tasks are pending
            System.out.println("No pending tasks to process.");
        }
    }

    /**
     * Displays all tasks currently in the pending queue.
     */
    public void viewPendingTasks() {
        System.out.println("\n--- Pending Tasks ---");
        if (pendingTasks.isEmpty()) {
            System.out.println("No pending tasks.");
        } else {
            // Iterate through the queue without removing elements
            // ForEach loop is a clean way to iterate
            pendingTasks.forEach(System.out::println);
        }
        System.out.println("---------------------\n");
    }

    /**
     * Displays all tasks currently in the completed list.
     */
    public void viewCompletedTasks() {
        System.out.println("\n--- Completed Tasks ---");
        if (completedTasks.isEmpty()) {
            System.out.println("No completed tasks.");
        } else {
            // Iterate through the list
            completedTasks.forEach(System.out::println);
        }
        System.out.println("-----------------------\n");
    }

    /**
     * Prints the main menu options to the console.
     */
    private void printMenu() {
        System.out.println("\nSelect an option:");
        System.out.println("1. Add New Task");
        System.out.println("2. Process Next Task");
        System.out.println("3. View Pending Tasks");
        System.out.println("4. View Completed Tasks");
        System.out.println("0. Exit");
    }

    /**
     * Runs the main interactive system loop.
     * Handles user input and calls appropriate methods.
     * Includes class-wide and specific exception handling.
     */
    public void runSystem() {
        System.out.println("--- Task Dispatcher System ---");

        // Class-wide exception handling block wrapping the main system loop
        try {
            int choice = -1; // Initialize choice to a non-exit value
            while (choice != 0) { // Loop until the user chooses to exit (option 0)
                printMenu(); // Display the menu
                System.out.print("Enter your choice: ");

                // Inner try-catch block specifically for handling Scanner input errors
                try {
                    choice = scanner.nextInt(); // Read the integer choice
                    scanner.nextLine(); // Consume the newline character left by nextInt()

                    // Use a switch statement for control flow based on user input
                    switch (choice) {
                        case 1:
                            System.out.print("Enter task description: ");
                            String description = scanner.nextLine(); // Read the task description
                            addTask(description); // Call the method to add the task
                            break; // Exit the switch case
                        case 2:
                            processNextTask(); // Call the method to process the next task
                            break; // Exit the switch case
                        case 3:
                            viewPendingTasks(); // Call the method to view pending tasks
                            break; // Exit the switch case
                        case 4:
                            viewCompletedTasks(); // Call the method to view completed tasks
                            break; // Exit the switch case
                        case 0:
                            System.out.println("Exiting system. Goodbye!");
                            break; // Exit the switch case (and the while loop condition will become false)
                        default:
                            // Use System.err for invalid input messages as required
                            System.err.println("Invalid choice. Please enter a number between 0 and 4.");
                            break; // Exit the switch case
                    }
                } catch (InputMismatchException e) {
                    // Catch the exception if the user enters non-integer input
                    // Use System.err for error messages as required
                    System.err.println("Invalid input. Please enter a number.");
                    scanner.nextLine(); // Consume the invalid input to prevent an infinite loop
                    choice = -1; // Reset choice to ensure the loop continues after the error
                }
                // Add a small pause or prompt for better readability in console, unless exiting
                if (choice != 0) {
                    System.out.println("\nPress Enter to continue...");
                    scanner.nextLine(); // Wait for user to press Enter before showing the menu again
                }
            }
        } catch (Exception e) {
            // Catch any other unexpected runtime exceptions that might occur
            // Use System.err for error messages as required
            System.err.println("An unexpected error occurred: " + e.getMessage());
            e.printStackTrace(); // Print stack trace for debugging purposes
        } finally {
            // Ensure the scanner resource is closed regardless of how the try block exits
            if (scanner != null) {
                scanner.close();
                System.out.println("Scanner closed.");
            }
        }
    }

    /**
     * The main entry point of the Task Dispatcher application.
     * Creates and runs a TaskDispatcher instance.
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        // Create an instance of the TaskDispatcher and start the system
        TaskDispatcher dispatcher = new TaskDispatcher();
        dispatcher.runSystem();
    }
}
