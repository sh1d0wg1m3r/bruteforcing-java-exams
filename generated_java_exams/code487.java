/*
 * Exam Question #487
 * Generated on: 2025-05-11 23:18:14
 * Generated by: Account 1
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Task Management System
 * 
 * **Scenario:**
 * 
 * You are tasked with developing a simple command-line Task Management System for a small team. The system should allow users to add tasks, view all tasks, queue specific tasks for processing, process the next task in the queue, and view the current processing queue.
 * 
 * **Requirements:**
 * 
 * 1.  **Task Representation:** Create an inner static class `Task` with the following attributes:
 *     *   `id`: A unique integer identifier for the task.
 *     *   `description`: A String describing the task.
 *     *   `priority`: An enum (`Priority`) with values `HIGH`, `MEDIUM`, `LOW`.
 *     *   `status`: An enum (`Status`) with values `PENDING`, `QUEUED`, `COMPLETED`.
 *     *   Include a constructor, getters for all fields, and a method `markAsCompleted()`.
 * 
 * 2.  **Data Structures:**
 *     *   Maintain a list of *all* tasks created using `java.util.ArrayList`.
 *     *   Maintain a queue of tasks waiting for processing using `java.util.Queue`.
 * 
 * 3.  **User Interface:** Implement a command-line interface using `java.util.Scanner` that accepts the following commands:
 *     *   `add`: Prompts for task description and priority (HIGH, MEDIUM, LOW). Creates a new task with status `PENDING` and adds it to the list of all tasks. Assigns a unique ID.
 *     *   `list`: Displays all tasks in the system, including their ID, description, priority, and status.
 *     *   `queue`: Prompts for a Task ID. Finds the task in the list of all tasks. If the task exists and is currently `PENDING`, change its status to `QUEUED` and add it to the processing queue. If the task is not found, or is already `QUEUED` or `COMPLETED`, print an appropriate error message.
 *     *   `process`: Takes the next task from the front of the processing queue. Finds the corresponding task in the list of all tasks and changes its status to `COMPLETED`. Prints which task was processed. If the queue is empty, print a message indicating that.
 *     *   `view_queue`: Displays the tasks currently in the processing queue, showing their ID, description, and priority. The task at the head of the queue should be listed first.
 *     *   `exit`: Terminates the program.
 * 
 * 4.  **Required Java Components:** Your solution *must* explicitly use and demonstrate understanding of:
 *     *   `java.util.Queue`
 *     *   `java.util.ArrayList`
 *     *   `java.util.List` (e.g., for declaring variables or method parameters)
 *     *   `java.util.Scanner`
 *     *   `switch` statement for command handling
 *     *   `System.err` for printing error messages
 *     *   `System.out` for printing normal output (menu, prompts, task lists, success messages)
 *     *   Class-wide exception handling using `try-catch` blocks (e.g., around the main command loop or input reading).
 * 
 * 5.  **Best Practices:**
 *     *   Employ proper encapsulation (private fields, public methods/getters).
 *     *   Use meaningful variable and method names.
 *     *   Include appropriate comments explaining complex logic.
 *     *   Implement input validation (e.g., for task IDs, priority input).
 *     *   Provide proper error handling for invalid input or system state (e.g., task not found, empty queue, invalid command).
 *     *   Structure the code cleanly.
 * 
 * **Expected Output:**
 * 
 * The output should be clear and informative, following the descriptions above. Error messages should be printed to `System.err`. Normal interaction and results should be printed to `System.out`.
 * 
 * **Example Interaction Snippet:**
 * 
 * ```
 * Task Management Menu:
 * add - Add a new task
 * list - List all tasks
 * queue - Queue a task for processing
 * process - Process next task in queue
 * view_queue - View processing queue
 * exit - Exit program
 * Enter command: add
 * Enter task description: Write report
 * Enter priority (HIGH, MEDIUM, LOW): HIGH
 * Task added with ID: 1
 * 
 * Task Management Menu:
 * ...
 * Enter command: list
 * All Tasks:
 * Task ID: 1, Description: Write report, Priority: HIGH, Status: PENDING
 * 
 * Task Management Menu:
 * ...
 * Enter command: queue
 * Enter Task ID to queue: 1
 * Task ID 1 queued.
 * 
 * Task Management Menu:
 * ...
 * Enter command: view_queue
 * Tasks in processing queue (next to process first):
 * Task ID: 1, Description: Write report, Priority: HIGH
 * 
 * Task Management Menu:
 * ...
 * Enter command: process
 * Processing task: Task ID: 1, Description: Write report, Priority: HIGH
 * Task ID 1 marked as COMPLETED.
 * 
 * Task Management Menu:
 * ...
 * Enter command: list
 * All Tasks:
 * Task ID: 1, Description: Write report, Priority: HIGH, Status: COMPLETED
 * 
 * Task Management Menu:
 * ...
 * Enter command: exit
 * Exiting Task Management System.
 * ```
 * 
 * Implement the Java code for this Task Management System.
 *
 * EXPLANATION:
 * The provided solution implements a simple command-line Task Management System demonstrating the required Java concepts and best practices.
 * 
 * **Core Components and Usage:**
 * 
 * 1.  **`java.util.Queue`**: The `processingQueue` variable is declared as `Queue<Task>` and initialized with `new LinkedList<>()`. This queue is used to hold `Task` objects that are ready to be processed. The `offer()` method is used to add tasks to the end of the queue when they are queued by the user. The `poll()` method is used to retrieve and remove the task at the head of the queue for processing. Iteration over the queue in `viewProcessingQueue` uses an enhanced for loop, which traverses elements without removing them.
 * 2.  **`java.util.ArrayList`**: The `allTasks` variable is declared as `List<Task>` and initialized with `new ArrayList<>()`. This list serves as the central repository for all tasks created in the system. New tasks are added using `allTasks.add()`. Listing all tasks involves iterating over this list. Finding a task by ID (used in `queueTask` and `processNextTask`) also requires iterating through this list.
 * 3.  **`java.util.List`**: The `allTasks` variable is explicitly declared using the `List` interface (`List<Task> allTasks`), although the implementation is `ArrayList`. This demonstrates the use of the interface for polymorphism and good practice.
 * 4.  **`java.util.Scanner`**: A `Scanner` object is used to read user commands and input (description, priority, task ID) from `System.in`. `nextLine()` is used for reading strings, and `nextInt()` is used for reading integers, with careful handling of the newline character after reading an integer.
 * 5.  **`switch` statement**: The main command loop uses a `switch` statement to direct the program flow based on the user's input command string ("add", "list", "queue", "process", "view_queue", "exit"). A `default` case handles invalid commands.
 * 6.  **`System.err`**: Error messages resulting from invalid operations (e.g., task not found, invalid priority, trying to queue a non-pending task, invalid integer input) are printed to `System.err` using `System.err.println()`. This separates error output from normal program output.
 * 7.  **`System.out`**: All normal program output, including the menu, prompts, success messages, and task lists, is printed to `System.out` using `System.out.println()`.
 * 8.  **`try-catch` blocks**:
 *     *   A large `try-catch (Exception e)` block wraps the main command processing loop in the `main` method. This provides class-wide exception handling, catching any unexpected runtime errors that might occur during execution and preventing the program from crashing abruptly.
 *     *   A specific `try-catch (InputMismatchException e)` block is used within the `queueTask` method to handle cases where the user enters non-integer input when prompted for a task ID.
 * 
 * **Best Practices:**
 * 
 * *   **Encapsulation:** The `Task` class fields (`id`, `description`, `priority`, `status`) are `private`, with public getter methods provided to access their values. The `markAsCompleted` and `markAsQueued` methods provide controlled ways to change the task's status. The data structures (`allTasks`, `processingQueue`) and the `nextTaskId` counter are private fields within the `TaskManager` class.
 * *   **Meaningful Names:** Variables (`allTasks`, `processingQueue`, `nextTaskId`, `taskToQueue`, `command`), methods (`addTask`, `listAllTasks`, `queueTask`, `processNextTask`, `viewProcessingQueue`), and enums (`Priority`, `Status`) have names that clearly indicate their purpose.
 * *   **Comments:** Comments are used to explain the purpose of classes, enums, data structures, and specific blocks of logic, particularly in the `main` method and within the command handling cases.
 * *   **Input Validation:**
 *     *   The `addTask` method includes a loop and a `try-catch` block to validate that the entered priority string matches one of the `Priority` enum values.
 *     *   The `queueTask` method uses a `try-catch` block for `InputMismatchException` when reading the task ID. It also explicitly checks if the entered task ID exists (`findTaskById`) and if the task's current status is `PENDING` before allowing it to be queued.
 * *   **Error Handling:** As detailed above, `try-catch` blocks and checks against task status/existence are used to handle potential issues gracefully, printing informative messages to `System.err`.
 * *   **Clean Code Structure:** The code is organized into a main class `TaskManager` with an inner static `Task` class and separate methods for each command's logic (`addTask`, `listAllTasks`, etc.), making the `main` method cleaner and improving readability and maintainability. Helper methods like `displayMenu` and `findTaskById` further break down the logic.
 * 
 * This solution effectively combines the required Java components within a practical scenario, demonstrating an understanding of fundamental data structures, control flow, exception handling, and object-oriented principles.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.InputMismatchException;

public class TaskManager {

    // Enum for Task Priority
    private enum Priority {
        HIGH, MEDIUM, LOW
    }

    // Enum for Task Status
    private enum Status {
        PENDING, QUEUED, COMPLETED
    }

    // Inner static class to represent a Task
    private static class Task {
        private int id;
        private String description;
        private Priority priority;
        private Status status;

        public Task(int id, String description, Priority priority) {
            this.id = id;
            this.description = description;
            this.priority = priority;
            this.status = Status.PENDING; // New tasks start as PENDING
        }

        // Getters
        public int getId() {
            return id;
        }

        public String getDescription() {
            return description;
        }

        public Priority getPriority() {
            return priority;
        }

        public Status getStatus() {
            return status;
        }

        // Method to mark task as completed
        public void markAsCompleted() {
            this.status = Status.COMPLETED;
        }

        // Method to mark task as queued
        public void markAsQueued() {
            this.status = Status.QUEUED;
        }

        @Override
        public String toString() {
            return "Task ID: " + id + ", Description: " + description + ", Priority: " + priority + ", Status: " + status;
        }
    }

    // Data structures for Task Management
    private List<Task> allTasks; // Use List interface, implemented by ArrayList
    private Queue<Task> processingQueue; // Use Queue interface, implemented by LinkedList
    private int nextTaskId; // Counter for unique task IDs

    // Scanner for user input
    private Scanner scanner;

    public TaskManager() {
        allTasks = new ArrayList<>();
        processingQueue = new LinkedList<>(); // LinkedList is a common Queue implementation
        nextTaskId = 1; // Start task IDs from 1
        scanner = new Scanner(System.in);
    }

    // Method to display the menu
    private void displayMenu() {
        System.out.println("\nTask Management Menu:");
        System.out.println("add - Add a new task");
        System.out.println("list - List all tasks");
        System.out.println("queue - Queue a task for processing");
        System.out.println("process - Process next task in queue");
        System.out.println("view_queue - View processing queue");
        System.out.println("exit - Exit program");
        System.out.print("Enter command: ");
    }

    // Method to add a new task
    private void addTask() {
        System.out.print("Enter task description: ");
        String description = scanner.nextLine();

        Priority priority = null;
        while (priority == null) {
            System.out.print("Enter priority (HIGH, MEDIUM, LOW): ");
            String priorityInput = scanner.nextLine().trim().toUpperCase();
            try {
                priority = Priority.valueOf(priorityInput);
            } catch (IllegalArgumentException e) {
                System.err.println("Error: Invalid priority. Please enter HIGH, MEDIUM, or LOW.");
            }
        }

        Task newTask = new Task(nextTaskId++, description, priority);
        allTasks.add(newTask);
        System.out.println("Task added with ID: " + newTask.getId());
    }

    // Method to list all tasks
    private void listAllTasks() {
        if (allTasks.isEmpty()) {
            System.out.println("No tasks in the system.");
            return;
        }
        System.out.println("All Tasks:");
        for (Task task : allTasks) {
            System.out.println(task);
        }
    }

    // Method to queue a task
    private void queueTask() {
        System.out.print("Enter Task ID to queue: ");
        try {
            int taskIdToQueue = scanner.nextInt();
            scanner.nextLine(); // Consume newline left-over

            Task taskToQueue = findTaskById(taskIdToQueue);

            if (taskToQueue == null) {
                System.err.println("Error: Task with ID " + taskIdToQueue + " not found.");
            } else {
                if (taskToQueue.getStatus() == Status.PENDING) {
                    taskToQueue.markAsQueued(); // Update status in allTasks list
                    processingQueue.offer(taskToQueue); // Add to queue
                    System.out.println("Task ID " + taskIdToQueue + " queued.");
                } else {
                    System.err.println("Error: Task with ID " + taskIdToQueue + " is already " + taskToQueue.getStatus() + ".");
                }
            }
        } catch (InputMismatchException e) {
            System.err.println("Error: Invalid input. Please enter a number for Task ID.");
            scanner.nextLine(); // Consume the invalid input
        }
    }

    // Helper method to find a task by ID in the allTasks list
    private Task findTaskById(int id) {
        for (Task task : allTasks) {
            if (task.getId() == id) {
                return task;
            }
        }
        return null; // Task not found
    }

    // Method to process the next task in the queue
    private void processNextTask() {
        Task taskToProcess = processingQueue.poll(); // Get and remove the head of the queue

        if (taskToProcess == null) {
            System.out.println("Processing queue is empty. No tasks to process.");
        } else {
            // Find the task in the allTasks list to update its status
            // We already have the Task object from the queue,
            // but let's simulate finding it by ID in the master list
            // to ensure the status update persists in the main list.
            Task taskInAllTasks = findTaskById(taskToProcess.getId());

            if (taskInAllTasks != null) {
                 taskInAllTasks.markAsCompleted(); // Update status in allTasks list
                 System.out.println("Processing task: " + taskToProcess); // Use taskToProcess for printing info
                 System.out.println("Task ID " + taskToProcess.getId() + " marked as COMPLETED.");
            } else {
                 // This case should ideally not happen if queue contains tasks from allTasks,
                 // but it's good practice to handle unexpected states.
                 System.err.println("Internal Error: Processed task not found in the main task list.");
            }
        }
    }

    // Method to view tasks in the processing queue
    private void viewProcessingQueue() {
        if (processingQueue.isEmpty()) {
            System.out.println("Processing queue is empty.");
            return;
        }
        System.out.println("Tasks in processing queue (next to process first):");
        // Iterate over the queue without removing elements
        for (Task task : processingQueue) {
            System.out.println("Task ID: " + task.getId() + ", Description: " + task.getDescription() + ", Priority: " + task.getPriority());
        }
    }

    // Main method to run the Task Manager
    public static void main(String[] args) {
        TaskManager manager = new TaskManager();
        boolean running = true;

        // Class-wide exception handling around the main loop
        try {
            while (running) {
                manager.displayMenu();
                String command = manager.scanner.nextLine().trim().toLowerCase();

                // Using switch statement for command handling
                switch (command) {
                    case "add":
                        manager.addTask();
                        break;
                    case "list":
                        manager.listAllTasks();
                        break;
                    case "queue":
                        manager.queueTask();
                        break;
                    case "process":
                        manager.processNextTask();
                        break;
                    case "view_queue":
                        manager.viewProcessingQueue();
                        break;
                    case "exit":
                        System.out.println("Exiting Task Management System.");
                        running = false;
                        break;
                    default:
                        System.err.println("Error: Invalid command. Please try again.");
                        break;
                }
            }
        } catch (Exception e) {
            // Catch any unexpected exceptions during execution
            System.err.println("An unexpected error occurred: " + e.getMessage());
            e.printStackTrace(System.err); // Print stack trace to error stream
        } finally {
            // Ensure scanner is closed
            if (manager.scanner != null) {
                manager.scanner.close();
            }
        }
    }
}
