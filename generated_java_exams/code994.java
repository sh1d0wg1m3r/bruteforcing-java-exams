/*
 * Exam Question #994
 * Generated on: 2025-05-12 17:10:06
 * Generated by: Account 5
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Hospital Appointment and Waiting List System
 * 
 * **Objective:** Design and implement a simplified console-based hospital appointment and waiting list management system. The system should allow scheduling appointments with doctors, managing a waiting list for busy doctors, viewing doctor status, and simulating the completion of an appointment.
 * 
 * **Requirements:**
 * 
 * 1.  **Data Structures:**
 *     *   Use `java.util.ArrayList` to store the list of `Doctor` objects.
 *     *   Use `java.util.List` as the type declaration when referring to the list of doctors.
 *     *   Use `java.util.Queue` to manage the waiting list of patients for each doctor. A `Map<Integer, Queue<String>>` (mapping Doctor ID to a Queue of patient names) is recommended for this.
 * 
 * 2.  **User Interaction:**
 *     *   Use `java.util.Scanner` to read user commands and input data from the console.
 *     *   Implement a command-line interface with options for:
 *         *   `schedule <doctorId> <patientName>`: Attempt to schedule an appointment.
 *         *   `finish <doctorId>`: Simulate a doctor finishing their current appointment.
 *         *   `status <doctorId>`: View the current status (busy/free) and waiting list for a doctor.
 *         *   `exit`: Terminate the program.
 *     *   Use a `switch` statement to process user commands.
 * 
 * 3.  **System Logic:**
 *     *   Pre-populate the system with a few `Doctor` objects. Each doctor should have a unique ID, name, specialty, and a state indicating if they are currently busy.
 *     *   When scheduling an appointment:
 *         *   Check if the specified doctor exists.
 *         *   If the doctor is free, book the appointment (mark the doctor as busy) and print a confirmation message.
 *         *   If the doctor is busy, add the patient's name to the waiting list for that doctor and print a message indicating they have been added to the queue.
 *         *   If the doctor does not exist, print an error message.
 *     *   When a doctor finishes an appointment:
 *         *   Check if the specified doctor exists and is currently busy.
 *         *   If they were busy, mark them as free.
 *         *   Check their waiting list. If the list is not empty, remove the first patient from the queue, book their appointment (mark the doctor as busy again), and print a message indicating the next patient is now being seen.
 *         *   If the doctor was not busy or did not exist, print an appropriate message/error.
 *     *   When viewing status:
 *         *   Check if the specified doctor exists.
 *         *   If they exist, print their busy status and the current list of patients in their waiting queue.
 *         *   If the doctor does not exist, print an error message.
 * 
 * 4.  **Error Handling and Best Practices:**
 *     *   Use `System.out` for normal output messages (confirmations, status reports).
 *     *   Use `System.err` for all error messages (invalid commands, doctor not found, invalid input format, etc.).
 *     *   Implement robust input validation for doctor IDs (must be integers), command format, and non-empty patient names.
 *     *   Use `try-catch` blocks to handle potential exceptions, such as `InputMismatchException` or `NumberFormatException` when parsing input. Implement a class-wide exception handling mechanism (e.g., wrapping the main command loop in a `try-catch`) to catch unexpected errors and prevent the program from crashing abruptly.
 *     *   Adhere to Java best practices:
 *         *   Proper encapsulation (private fields, public methods).
 *         *   Meaningful variable and method names.
 *         *   Appropriate comments and documentation (basic Javadoc or inline comments).
 *         *   Clean code structure with separate classes where appropriate (e.g., a `Doctor` class).
 * 
 * **Expected Output:**
 * 
 * The program should run continuously, accepting commands. Output should be informative, clearly distinguishing between success messages (`System.out`) and error messages (`System.err`).
 * 
 * Example interactions:
 * 
 * ```
 * Enter command (schedule <id> <name>, finish <id>, status <id>, exit): schedule 101 Alice
 * Scheduling appointment for Alice with Doctor 101...
 * Doctor 101 is free. Alice is now seeing Doctor Smith.
 * 
 * Enter command (schedule <id> <name>, finish <id>, status <id>, exit): schedule 101 Bob
 * Scheduling appointment for Bob with Doctor 101...
 * Doctor 101 is busy. Bob added to the waiting list for Doctor 101.
 * 
 * Enter command (schedule <id> <name>, finish <id>, status <id>, exit): status 101
 * Status for Doctor 101:
 * Busy: true
 * Waiting List: [Bob]
 * 
 * Enter command (schedule <id> <name>, finish <id>, status <id>, exit): finish 101
 * Doctor 101 finished appointment.
 * Checking waiting list for Doctor 101...
 * Next patient Bob from queue is now seeing Doctor Smith.
 * 
 * Enter command (schedule <id> <name>, finish <id>, status <id>, exit): status 101
 * Status for Doctor 101:
 * Busy: true
 * Waiting List: []
 * 
 * Enter command (schedule <id> <name>, finish <id>, status <id>, exit): schedule 999 Carol
 * Scheduling appointment for Carol with Doctor 999...
 * Error: Doctor with ID 999 not found.
 * 
 * Enter command (schedule <id> <name>, finish <id>, status <id>, exit): exit
 * Exiting Hospital System.
 * ```
 * 
 * Your solution must be a single Java file containing all necessary classes.
 *
 * EXPLANATION:
 * The provided solution implements a simplified Hospital Appointment and Waiting List System, fulfilling all the requirements of the exam task.
 * 
 * 1.  **Class Structure:**
 *     *   `Doctor` class: A simple class representing a doctor with private fields (`id`, `name`, `specialty`, `isBusy`) and public getter/setter methods, demonstrating encapsulation.
 *     *   `HospitalSystem` class: The main class containing the core logic of the system. It holds the list of doctors and manages the waiting lists.
 * 
 * 2.  **Data Structures:**
 *     *   `List<Doctor> doctors`: Declared using the `List` interface type and initialized with an `ArrayList`. This adheres to the requirement of using both `List` and `ArrayList`. `ArrayList` is suitable here for storing and iterating through a collection of doctors.
 *     *   `Map<Integer, Queue<String>> waitingLists`: A `HashMap` is used to map each Doctor's unique ID (Integer) to their specific waiting list, which is implemented using a `Queue` (`LinkedList`). `Queue` (specifically `LinkedList` which implements `Queue`) is ideal for a waiting list because it provides FIFO (First-In, First-Out) behavior, allowing patients to be served in the order they joined the queue (`offer` to add, `poll` to remove from the front).
 * 
 * 3.  **User Interaction and Flow Control:**
 *     *   `Scanner scanner`: Used in the `HospitalSystem` constructor to read input from `System.in`.
 *     *   `start()` method: Contains the main application loop.
 *     *   `while(true)` loop: Keeps the system running until the 'exit' command is given.
 *     *   `scanner.nextLine()`: Reads the entire line of input, making it easier to parse commands with multiple arguments.
 *     *   `line.trim().split("\\s+", 3)`: Splits the input line into parts based on whitespace, limiting the split to 3 parts to handle commands like `schedule <id> <name>` correctly.
 *     *   `switch (command)`: Used to direct the program flow based on the first word of the user's input (the command). This meets the requirement for using a switch statement.
 * 
 * 4.  **System Logic Implementation:**
 *     *   `addDoctor()`: A private helper method to pre-populate doctors and initialize their corresponding waiting queues in the `waitingLists` map.
 *     *   `findDoctorById()`: A private helper method to easily locate a `Doctor` object within the `doctors` list by their ID.
 *     *   `scheduleAppointment(int doctorId, String patientName)`: Implements the logic for scheduling. It finds the doctor, validates the patient name, checks the doctor's `isBusy` status. If busy, it uses `waitingLists.get(doctorId).offer(patientName)` to add the patient to the end of the queue. If not busy, it sets the doctor's `isBusy` status to `true`.
 *     *   `finishAppointment(int doctorId)`: Implements the logic for finishing. It finds the doctor, checks if they were busy, sets `isBusy` to `false`, then uses `waitingLists.get(doctorId).poll()` to retrieve and remove the first patient from the queue. If a patient is retrieved, it immediately sets the doctor back to `isBusy=true` for the next appointment.
 *     *   `viewDoctorStatus(int doctorId)`: Finds the doctor and prints their `isBusy` status. It retrieves the queue for the doctor's ID and prints its contents. `new ArrayList<>(queue)` is used to create a temporary list from the queue for easy printing of all elements without modifying the queue itself.
 * 
 * 5.  **Error Handling and Best Practices:**
 *     *   `System.out.println()`: Used for successful operations and informative messages.
 *     *   `System.err.println()`: Used for all error messages, clearly distinguishing them from normal output as required.
 *     *   **Input Validation:**
 *         *   Command format is checked by verifying the `parts.length` after splitting the input line.
 *         *   Doctor ID is parsed using `Integer.parseInt()`.
 *         *   Patient name is checked for emptiness (`patientName.trim().isEmpty()`).
 *     *   **Exception Handling:**
 *         *   Specific `try-catch (NumberFormatException e)` blocks are placed around `Integer.parseInt()` calls within the `switch` cases to handle invalid integer input for doctor IDs, providing a user-friendly error message via `System.err`.
 *         *   A broader `try-catch (Exception e)` block is wrapped around the entire `while` loop in the `start()` method. This fulfills the "class-wide exception handling" requirement by catching any unexpected exceptions that might occur during command processing or within the loop, preventing the program from crashing and printing a general error message to `System.err`. This acts as a safety net.
 *         *   A `finally` block is used to ensure the `Scanner` is closed when the program exits, releasing system resources.
 *     *   **Best Practices:**
 *         *   Private fields and public methods in `Doctor` and `HospitalSystem` ensure proper encapsulation.
 *         *   Variable and method names are descriptive (e.g., `waitingLists`, `scheduleAppointment`, `findDoctorById`).
 *         *   Basic Javadoc comments are included for classes and methods.
 *         *   The code is structured logically with separate methods for different operations.
 * 
 * This solution effectively demonstrates the use of all required Java components (`Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.err`, `System.out`, `try-catch`) within a practical scenario, incorporating essential best practices like encapsulation, input validation, and robust error handling.
 */

import java.util.ArrayList;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Queue;
import java.util.Scanner;
import java.util.InputMismatchException;

/**
 * Represents a Doctor in the hospital system.
 */
class Doctor {
    private int id;
    private String name;
    private String specialty;
    private boolean isBusy;

    /**
     * Constructs a new Doctor.
     *
     * @param id The unique ID of the doctor.
     * @param name The name of the doctor.
     * @param specialty The specialty of the doctor.
     */
    public Doctor(int id, String name, String specialty) {
        this.id = id;
        this.name = name;
        this.specialty = specialty;
        this.isBusy = false; // Doctors are free initially
    }

    // --- Getters ---
    public int getId() {
        return id;
    }

    public String getName() {
        return name;
    }

    public String getSpecialty() {
        return specialty;
    }

    public boolean isBusy() {
        return isBusy;
    }

    // --- Setters ---
    public void setBusy(boolean busy) {
        isBusy = busy;
    }

    @Override
    public String toString() {
        return "Doctor{" +
               "id=" + id +
               ", name='" + name + '\'' +
               ", specialty='" + specialty + '\'' +
               ", isBusy=" + isBusy +
               '}';
    }
}

/**
 * Manages the hospital appointment and waiting list system.
 */
public class HospitalSystem {

    // Using List interface type for doctors
    private List<Doctor> doctors;
    // Using Map to link Doctor ID to their waiting Queue
    private Map<Integer, Queue<String>> waitingLists;
    private Scanner scanner;

    /**
     * Constructs a new HospitalSystem and pre-populates doctors.
     */
    public HospitalSystem() {
        // Use ArrayList implementation for the List of doctors
        doctors = new ArrayList<>();
        // Use HashMap implementation for the Map linking IDs to Queues
        waitingLists = new HashMap<>();
        scanner = new Scanner(System.in);

        // Pre-populate doctors
        addDoctor(101, "Dr. Smith", "Cardiology");
        addDoctor(102, "Dr. Jones", "Pediatrics");
        addDoctor(103, "Dr. Lee", "Neurology");
    }

    /**
     * Adds a new doctor to the system.
     * Initializes a waiting list for the doctor.
     *
     * @param id The doctor's unique ID.
     * @param name The doctor's name.
     * @param specialty The doctor's specialty.
     */
    private void addDoctor(int id, String name, String specialty) {
        Doctor doctor = new Doctor(id, name, specialty);
        doctors.add(doctor);
        // Use LinkedList implementation for the Queue
        waitingLists.put(id, new LinkedList<>());
        System.out.println("Added doctor: " + name + " (ID: " + id + ")");
    }

    /**
     * Finds a doctor by their ID.
     *
     * @param doctorId The ID of the doctor to find.
     * @return The Doctor object if found, null otherwise.
     */
    private Doctor findDoctorById(int doctorId) {
        for (Doctor doctor : doctors) {
            if (doctor.getId() == doctorId) {
                return doctor;
            }
        }
        return null; // Doctor not found
    }

    /**
     * Schedules an appointment for a patient with a specific doctor.
     * If the doctor is busy, adds the patient to the waiting list.
     *
     * @param doctorId The ID of the doctor.
     * @param patientName The name of the patient.
     */
    public void scheduleAppointment(int doctorId, String patientName) {
        System.out.println("Scheduling appointment for " + patientName + " with Doctor " + doctorId + "...");
        Doctor doctor = findDoctorById(doctorId);

        if (doctor == null) {
            System.err.println("Error: Doctor with ID " + doctorId + " not found.");
            return;
        }

        if (patientName == null || patientName.trim().isEmpty()) {
            System.err.println("Error: Patient name cannot be empty.");
            return;
        }

        if (!waitingLists.containsKey(doctorId)) {
             // This should not happen if addDoctor initializes correctly, but good practice
            System.err.println("Internal Error: Waiting list not initialized for doctor " + doctorId);
            return;
        }

        if (doctor.isBusy()) {
            // Doctor is busy, add patient to the waiting list
            Queue<String> queue = waitingLists.get(doctorId);
            queue.offer(patientName); // Add to the end of the queue
            System.out.println("Doctor " + doctor.getId() + " is busy. " + patientName + " added to the waiting list for Doctor " + doctor.getName() + ".");
        } else {
            // Doctor is free, book the appointment
            doctor.setBusy(true);
            System.out.println("Doctor " + doctor.getId() + " is free. " + patientName + " is now seeing " + doctor.getName() + ".");
        }
    }

    /**
     * Simulates a doctor finishing their current appointment.
     * Checks the waiting list for the next patient.
     *
     * @param doctorId The ID of the doctor.
     */
    public void finishAppointment(int doctorId) {
        System.out.println("Doctor " + doctorId + " finished appointment.");
        Doctor doctor = findDoctorById(doctorId);

        if (doctor == null) {
            System.err.println("Error: Doctor with ID " + doctorId + " not found.");
            return;
        }

        if (!doctor.isBusy()) {
            System.out.println("Doctor " + doctor.getId() + " (" + doctor.getName() + ") was not currently busy.");
            return;
        }

        // Doctor was busy, now they are free
        doctor.setBusy(false);

        // Check the waiting list for the next patient
        Queue<String> queue = waitingLists.get(doctorId);
        if (queue == null) {
             // This should not happen
             System.err.println("Internal Error: Waiting list missing for doctor " + doctorId);
             return;
        }

        System.out.println("Checking waiting list for Doctor " + doctor.getId() + "...");
        String nextPatient = queue.poll(); // Get and remove the first patient

        if (nextPatient != null) {
            // Book appointment for the next patient in queue
            doctor.setBusy(true);
            System.out.println("Next patient " + nextPatient + " from queue is now seeing " + doctor.getName() + ".");
        } else {
            System.out.println("Waiting list for Doctor " + doctor.getId() + " is empty. Doctor " + doctor.getName() + " is now free.");
        }
    }

    /**
     * Displays the current status of a doctor, including their busy status and waiting list.
     *
     * @param doctorId The ID of the doctor.
     */
    public void viewDoctorStatus(int doctorId) {
        Doctor doctor = findDoctorById(doctorId);

        if (doctor == null) {
            System.err.println("Error: Doctor with ID " + doctorId + " not found.");
            return;
        }

        System.out.println("Status for Doctor " + doctor.getId() + " (" + doctor.getName() + "):");
        System.out.println("Busy: " + doctor.isBusy());

        Queue<String> queue = waitingLists.get(doctorId);
         if (queue == null) {
             // This should not happen
             System.err.println("Internal Error: Waiting list missing for doctor " + doctorId);
             return;
         }

        System.out.println("Waiting List: " + new ArrayList<>(queue)); // Print as a List for readability
    }

    /**
     * Starts the main command processing loop.
     * Includes class-wide exception handling.
     */
    public void start() {
        System.out.println("Hospital Appointment System Started.");
        System.out.println("Enter command (schedule <id> <name>, finish <id>, status <id>, exit):");

        // Class-wide exception handling for the main loop
        try {
            while (true) {
                System.out.print("> ");
                String line = scanner.nextLine();
                String[] parts = line.trim().split("\\s+", 3); // Split into max 3 parts: command, id, name (optional)
                String command = parts[0].toLowerCase();

                try {
                    switch (command) {
                        case "schedule":
                            if (parts.length == 3) {
                                int doctorId = Integer.parseInt(parts[1]);
                                String patientName = parts[2];
                                scheduleAppointment(doctorId, patientName);
                            } else {
                                System.err.println("Invalid 'schedule' command format. Use: schedule <doctorId> <patientName>");
                            }
                            break;

                        case "finish":
                            if (parts.length == 2) {
                                int doctorId = Integer.parseInt(parts[1]);
                                finishAppointment(doctorId);
                            } else {
                                System.err.println("Invalid 'finish' command format. Use: finish <doctorId>");
                            }
                            break;

                        case "status":
                            if (parts.length == 2) {
                                int doctorId = Integer.parseInt(parts[1]);
                                viewDoctorStatus(doctorId);
                            } else {
                                System.err.println("Invalid 'status' command format. Use: status <doctorId>");
                            }
                            break;

                        case "exit":
                            System.out.println("Exiting Hospital System.");
                            return; // Exit the start method and thus the program

                        default:
                            System.err.println("Unknown command: " + command);
                            System.err.println("Available commands: schedule, finish, status, exit");
                            break;
                    }
                } catch (NumberFormatException e) {
                    System.err.println("Error: Invalid number format for Doctor ID. Please enter a valid integer.");
                } catch (InputMismatchException e) {
                     // This catch might be less frequent with nextLine() and manual parsing,
                     // but good to have if scanner.nextInt() was used elsewhere.
                     System.err.println("Error: Input format mismatch. Please check your input.");
                } catch (Exception e) {
                    // Catch any other unexpected exceptions during command processing
                    System.err.println("An unexpected error occurred during command processing: " + e.getMessage());
                    // e.printStackTrace(); // Uncomment for debugging
                }
            }
        } catch (Exception e) {
            // Class-wide catch for anything that escapes the inner try-catch or happens outside the loop logic
            System.err.println("A critical system error occurred: " + e.getMessage());
            // e.printStackTrace(); // Uncomment for debugging
        } finally {
            // Ensure the scanner is closed
            if (scanner != null) {
                scanner.close();
            }
        }
    }

    /**
     * Main method to start the application.
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        HospitalSystem system = new HospitalSystem();
        system.start();
    }
}
