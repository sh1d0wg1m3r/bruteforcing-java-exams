/*
 * Exam Question #660
 * Generated on: 2025-05-12 16:21:41
 * Generated by: Account 5
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Simple Task Management System
 * 
 * **Objective:** Design and implement a command-line application that simulates a basic task management system. This task requires you to demonstrate proficiency in using fundamental Java collections, control flow structures, user input handling, and exception management.
 * 
 * **Scenario:** You are building a simple system for a small team to manage their tasks. Tasks are added to a queue for processing, and the system tracks all tasks created and their completion status.
 * 
 * **Requirements:**
 * 
 * 1.  **Task Representation:** Create a class named `Task` to model a single task. Each `Task` object must have the following attributes:
 *     *   An auto-generated unique integer `id`.
 *     *   A `description` (String).
 *     *   A `priority` (defined by an `enum` with values like `HIGH`, `MEDIUM`, `LOW`).
 *     *   A `status` (defined by an `enum` with values like `PENDING`, `COMPLETED`).
 *     *   Implement proper encapsulation (private fields with public getter methods).
 *     *   Include a method to update the task's status (e.g., from `PENDING` to `COMPLETED`).
 *     *   Override `toString()` to provide a user-friendly representation of the task.
 * 
 * 2.  **Task Management Logic:** Create a class named `TaskManager` responsible for managing the tasks.
 *     *   It must maintain a collection of **all** tasks ever created. This collection must be declared using the `java.util.List` interface and implemented using `java.util.ArrayList`.
 *     *   It must maintain a separate collection for tasks that are currently in the **PENDING** state, waiting to be processed. This collection must be declared and used as a `java.util.Queue`. Tasks should be added to the queue when created and removed from the queue when processed.
 *     *   Implement methods for:
 *         *   `addTask(String description, Priority priority)`: Creates a new `Task`, adds it to the list of all tasks, and adds it to the pending tasks queue.
 *         *   `processNextTask()`: Retrieves and removes the next task from the pending queue, updates its status to `COMPLETED`. If the queue is empty, it should report an error.
 *         *   `listAllTasks()`: Prints details of all tasks managed by the system.
 *         *   `listPendingTasks()`: Prints details of tasks currently in the pending queue.
 *         *   `listCompletedTasks()`: Prints details of tasks from the master list that have a `COMPLETED` status.
 * 
 * 3.  **User Interface:** Create a main application class (e.g., `TaskApp`) with a `main` method.
 *     *   Use `java.util.Scanner` to interact with the user via the command line.
 *     *   Present a menu with the following options:
 *         1.  Add New Task
 *         2.  Process Next Pending Task
 *         3.  List All Tasks
 *         4.  List Pending Tasks
 *         5.  List Completed Tasks
 *         6.  Exit
 *     *   Use a `switch` statement to handle the user's menu choice.
 *     *   Implement input validation for menu choices and task details (e.g., ensuring description is not empty, handling invalid priority input).
 * 
 * 4.  **Error Handling and Output:**
 *     *   Use `System.err` to print all error messages (e.g., invalid input, attempting to process an empty queue, empty task description).
 *     *   Use `System.out` for all normal output (menu, prompts, success messages, task listings).
 *     *   Implement **class-wide exception handling** using `try-catch` blocks in the main application class to catch potential exceptions during user interaction or task processing. Include specific handling for input-related exceptions (`NumberFormatException`, etc.) and a general catch-all for unexpected errors. Ensure resources like `Scanner` are closed.
 * 
 * 5.  **Code Quality:**
 *     *   Adhere to Java coding conventions.
 *     *   Use meaningful names for classes, methods, and variables.
 *     *   Include basic comments to explain complex parts.
 * 
 * **Mandatory Component Usage Summary:**
 * 
 * Your solution **must explicitly use** and demonstrate the functionality of:
 * *   `java.util.Queue`
 * *   `java.util.ArrayList`
 * *   `java.util.List` (as a type)
 * *   `java.util.Scanner`
 * *   `switch` statement
 * *   `System.err`
 * *   `System.out`
 * *   `try-catch` blocks for exception handling
 * 
 * **Expected Output:**
 * 
 * The program should run interactively, displaying the menu, accepting user input, performing the requested operations on tasks, and printing results or errors to the console using the appropriate output streams (`System.out` or `System.err`). The system should handle invalid inputs gracefully and exit when the user chooses option 6.
 *
 * EXPLANATION:
 * This solution implements a simple task management system demonstrating the required Java concepts and best practices.
 * 
 * **Class Structure:**
 * -   `Priority` and `Status` enums: Define the possible states for task priority and completion status, improving code readability and preventing invalid values.
 * -   `Task` class: Encapsulates the data for a single task (ID, description, priority, status). It uses private fields and public getters for proper encapsulation. The `setStatus` method allows controlled modification of the task's state. `toString()` provides a convenient way to display task details.
 * -   `TaskManager` class: Acts as the central hub for managing tasks.
 *     -   It holds two main collections: `allTasks` (declared as `List<Task>` and implemented as `ArrayList<Task>`) to keep a history of all tasks, and `pendingTasksQueue` (declared as `Queue<Task>` and implemented as `LinkedList<Task>`) to manage tasks waiting for processing in a queue structure.
 *     -   It contains methods (`addTask`, `processNextTask`, `listAllTasks`, `listPendingTasks`, `listCompletedTasks`) that implement the core logic, operating on these collections. `addTask` adds to both collections, `processNextTask` removes from the queue and updates the status of the task object (which is reflected in `allTasks` because both collections hold references to the same `Task` objects).
 *     -   A helper method `getPriorityFromString` is included to parse user input for priority, including basic validation.
 * -   `TaskApp` class: Contains the `main` method, serving as the application's entry point and handling user interaction.
 * 
 * **Required Component Usage:**
 * -   `java.util.Queue`: Used for `pendingTasksQueue` (`new LinkedList<>()`), demonstrating queue operations like `offer()` (add) and `poll()` (retrieve and remove).
 * -   `java.util.ArrayList`: Used as the concrete implementation for the `allTasks` list (`new ArrayList<>()`).
 * -   `java.util.List` interface: Used as the type declaration for the `allTasks` field (`private List<Task> allTasks;`), demonstrating programming to the interface.
 * -   `java.util.Scanner`: Used in `TaskApp.main` to read user input from `System.in`.
 * -   `switch` statement: Used in `TaskApp.main` to direct the program flow based on the user's menu choice.
 * -   `System.err`: Used throughout the code (in `TaskManager` and `TaskApp`) to print error messages, such as invalid input, empty description, or attempting to process an empty queue.
 * -   `System.out`: Used for all standard output, including the menu, prompts, success messages, and task listings.
 * -   `try-catch` blocks:
 *     -   A large `try-catch(Exception e)` block wraps the main `while` loop in `TaskApp.main`, providing "class-wide" handling for unexpected exceptions that might occur during the program's execution.
 *     -   A specific `try-catch(NumberFormatException e)` is used within the loop to handle cases where the user enters non-numeric input for the menu choice.
 *     -   A `try-catch(IllegalArgumentException e)` is used in `TaskManager.getPriorityFromString` to handle invalid priority input strings.
 *     -   A `finally` block is used to ensure the `Scanner` resource is closed regardless of whether an exception occurred or the program exited normally.
 * 
 * **Best Practices:**
 * -   **Encapsulation:** Task attributes and TaskManager collections are private, accessed via public methods.
 * -   **Meaningful Names:** Class, variable, and method names are descriptive (e.g., `pendingTasksQueue`, `processNextTask`, `getPriorityFromString`).
 * -   **Comments:** Basic comments explain the purpose of classes, methods, and key logic sections.
 * -   **Input Validation:** Checks for empty task descriptions, handles non-numeric menu input, and validates priority strings.
 * -   **Error Handling:** Specific error messages are printed to `System.err` for user errors, and a general `try-catch` handles unexpected system errors.
 * -   **Clean Structure:** The code is organized into separate classes with distinct responsibilities (`Task` for data, `TaskManager` for logic, `TaskApp` for UI/main loop).
 * 
 * This solution effectively integrates the required components into a functional and understandable application, demonstrating key Java programming concepts suitable for an advanced exam.
 */

import java.util.ArrayList;
import java.util.LinkedList; // LinkedList implements Queue
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.InputMismatchException; // Specific exception for Scanner input

// Enum for Task Priority
enum Priority {
    HIGH, MEDIUM, LOW
}

// Enum for Task Status
enum Status {
    PENDING, COMPLETED
}

// Represents a single Task
class Task {
    private int id;
    private String description;
    private Priority priority;
    private Status status;

    // Constructor
    public Task(int id, String description, Priority priority) {
        this.id = id;
        this.description = description;
        this.priority = priority;
        this.status = Status.PENDING; // New tasks start as PENDING
    }

    // Getters
    public int getId() {
        return id;
    }

    public String getDescription() {
        return description;
    }

    public Priority getPriority() {
        return priority;
    }

    public Status getStatus() {
        return status;
    }

    // Setter for status (to change status upon processing)
    public void setStatus(Status status) {
        this.status = status;
    }

    // String representation of the Task
    @Override
    public String toString() {
        return String.format("ID: %d, Desc: '%s', Priority: %s, Status: %s",
                             id, description, priority, status);
    }
}

// Manages collections of Tasks
class TaskManager {
    // List to hold all tasks ever created (declared as List, implemented by ArrayList)
    private List<Task> allTasks;
    // Queue to hold tasks that are currently pending
    private Queue<Task> pendingTasksQueue;
    // Counter for generating unique task IDs
    private int nextTaskId;

    // Constructor
    public TaskManager() {
        this.allTasks = new ArrayList<>(); // Use ArrayList for the List
        this.pendingTasksQueue = new LinkedList<>(); // Use LinkedList for the Queue
        this.nextTaskId = 1; // Start ID from 1
    }

    /**
     * Adds a new task to the system.
     * Adds to the master list and the pending queue.
     * @param description The task description.
     * @param priority The task priority.
     */
    public void addTask(String description, Priority priority) {
        // Basic input validation for description
        if (description == null || description.trim().isEmpty()) {
            System.err.println("Error: Task description cannot be empty.");
            return;
        }

        Task newTask = new Task(nextTaskId++, description.trim(), priority);
        allTasks.add(newTask); // Add to the list of all tasks
        pendingTasksQueue.offer(newTask); // Add to the pending queue (offer is preferred over add for capacity-constrained queues, though LinkedList is not)
        System.out.println(System.lineSeparator() + "Task added successfully: " + newTask.toString());
    }

    /**
     * Processes the next task from the pending queue.
     * Removes the task from the queue and updates its status in the master list.
     */
    public void processNextTask() {
        // Retrieve and remove the head of the queue
        Task taskToProcess = pendingTasksQueue.poll();

        if (taskToProcess == null) {
            System.err.println(System.lineSeparator() + "Error: No pending tasks in the queue to process.");
        } else {
            // Update the status of the task object (which is referenced in allTasks)
            taskToProcess.setStatus(Status.COMPLETED);
            System.out.println(System.lineSeparator() + "Processed task: " + taskToProcess.toString());
        }
    }

    /**
     * Lists all tasks managed by the system.
     */
    public void listAllTasks() {
        System.out.println(System.lineSeparator() + "--- All Tasks ---");
        if (allTasks.isEmpty()) {
            System.out.println("No tasks created yet.");
        } else {
            for (Task task : allTasks) {
                System.out.println(task);
            }
        }
        System.out.println("-----------------");
    }

    /**
     * Lists tasks currently in the pending queue.
     */
    public void listPendingTasks() {
        System.out.println(System.lineSeparator() + "--- Pending Tasks ---");
        if (pendingTasksQueue.isEmpty()) {
            System.out.println("No tasks currently pending.");
        } else {
            // Iterating over a Queue is possible and doesn't remove elements
            for (Task task : pendingTasksQueue) {
                 System.out.println(task);
            }
        }
         System.out.println("---------------------");
    }

    /**
     * Lists tasks from the master list that have been marked as COMPLETED.
     */
    public void listCompletedTasks() {
        System.out.println(System.lineSeparator() + "--- Completed Tasks ---");
        boolean foundCompleted = false;
        // Iterate through the master list to find completed tasks
        for (Task task : allTasks) {
            if (task.getStatus() == Status.COMPLETED) {
                System.out.println(task);
                foundCompleted = true;
            }
        }
        if (!foundCompleted) {
            System.out.println("No tasks have been completed yet.");
        }
        System.out.println("-----------------------");
    }

    /**
     * Helper method to get Priority enum from user input string.
     * Handles invalid input by printing error and returning a default or null.
     * @param priorityInput The user's input string for priority.
     * @return The corresponding Priority enum, or null/default if invalid.
     */
    public Priority getPriorityFromString(String priorityInput) {
        try {
            // Convert input to uppercase and get the enum value
            return Priority.valueOf(priorityInput.trim().toUpperCase());
        } catch (IllegalArgumentException e) {
            // Handle cases where the input string doesn't match any enum constant
            System.err.println("Invalid priority entered: '" + priorityInput + "'. Please use HIGH, MEDIUM, or LOW.");
            return null; // Indicate invalid input
        }
    }
}

// Main application class
public class TaskApp {

    // Method to print the main menu
    private static void printMenu() {
        System.out.println(System.lineSeparator() + "--- Simple Task Management System ---");
        System.out.println("Select an option:");
        System.out.println("1. Add New Task");
        System.out.println("2. Process Next Pending Task");
        System.out.println("3. List All Tasks");
        System.out.println("4. List Pending Tasks");
        System.out.println("5. List Completed Tasks");
        System.out.println("6. Exit");
        System.out.println("-----------------------------------");
    }

    public static void main(String[] args) {
        // Scanner for reading user input
        Scanner scanner = new Scanner(System.in);
        // TaskManager instance to handle task operations
        TaskManager taskManager = new TaskManager();

        // Class-wide exception handling around the main application loop
        try {
            while (true) {
                printMenu();
                System.out.print("Enter choice: ");

                int choice = -1; // Default invalid choice
                String inputLine = scanner.nextLine(); // Read the entire line

                // Handle potential NumberFormatException for choice input
                try {
                    choice = Integer.parseInt(inputLine);
                } catch (NumberFormatException e) {
                    System.err.println(System.lineSeparator() + "Invalid input. Please enter a number.");
                    continue; // Skip the rest of the loop and show menu again
                }

                // Switch statement to handle different menu options
                switch (choice) {
                    case 1: // Add New Task
                        System.out.print("Enter task description: ");
                        String description = scanner.nextLine(); // Read description
                        System.out.print("Enter priority (HIGH, MEDIUM, LOW): ");
                        String priorityString = scanner.nextLine(); // Read priority as string

                        Priority priority = taskManager.getPriorityFromString(priorityString);
                        if (priority != null) { // Only add task if priority was valid
                            taskManager.addTask(description, priority);
                        } else {
                             System.err.println("Task not added due to invalid priority.");
                        }
                        break;

                    case 2: // Process Next Pending Task
                        taskManager.processNextTask();
                        break;

                    case 3: // List All Tasks
                        taskManager.listAllTasks();
                        break;

                    case 4: // List Pending Tasks
                        taskManager.listPendingTasks();
                        break;

                    case 5: // List Completed Tasks
                        taskManager.listCompletedTasks();
                        break;

                    case 6: // Exit
                        System.out.println("Exiting Task Management System. Goodbye!");
                        return; // Exit the main method, terminating the application

                    default: // Handle invalid menu numbers
                        System.err.println(System.lineSeparator() + "Invalid choice. Please enter a number between 1 and 6.");
                        break;
                }
            }
        } catch (Exception e) {
            // Catch any unexpected exceptions that might occur
            System.err.println(System.lineSeparator() + "An unexpected error occurred: " + e.getMessage());
            e.printStackTrace(); // Print stack trace for debugging purposes
        } finally {
            // Ensure the scanner resource is closed when the application exits
            if (scanner != null) {
                scanner.close();
                // System.out.println("Scanner closed."); // Optional confirmation
            }
        }
    }
}
