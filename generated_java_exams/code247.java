/*
 * Exam Question #247
 * Generated on: 2025-05-11 22:38:48
 * Generated by: Account 4
 * 
 * QUESTION:
 * ## Java Programming Exam: Advanced Task Management System
 * 
 * **Objective:** Implement a console-based Task Management System that allows users to add, list, and process software development tasks. The system should demonstrate advanced usage of Java collections, input handling, control flow, and error management.
 * 
 * **Scenario:** You are building a simplified system for managing development tasks. Tasks have a description, a unique ID, a priority (High, Medium, Low), and a completion status. Tasks are initially added to a main list. High-priority tasks can be immediately added to a processing queue, while others must be explicitly enqueued by ID before they can be processed. The system processes tasks one by one from the front of the queue.
 * 
 * **Requirements:**
 * 
 * 1.  **Task Representation:** Create a `Task` class with private fields for `id` (int), `description` (String), `priority` (String), and `isCompleted` (boolean). Include a constructor, getter methods for all fields, a method `markCompleted()`, and a meaningful `toString()` method.
 * 2.  **System Class:** Create a `TaskManager` class to manage the tasks and the processing queue.
 *     *   It must use a `java.util.ArrayList` (declared as `List<Task>`) to store all tasks.
 *     *   It must use a `java.util.Queue<Task>` (implemented using `java.util.LinkedList`) to manage tasks ready for processing.
 *     *   Implement methods for:
 *         *   `addTask(String description, String priority)`: Adds a new task to the main list. Assigns a unique ID (starting from 1). If the priority is "High", it should *also* automatically enqueue the task. Validate priority input ("High", "Medium", "Low").
 *         *   `enqueueTask(int taskId)`: Finds a task by ID in the main list and adds it to the processing queue. A task can only be enqueued if it exists, is not already completed, and is not already in the queue.
 *         *   `processNextTask()`: Removes and processes the task at the front of the queue. Processing involves marking the task as completed in the main list. Handle the case where the queue is empty.
 *         *   `listAllTasks()`: Prints details of all tasks in the main list.
 *         *   `listQueue()`: Prints details of tasks currently in the processing queue.
 * 3.  **User Interface:**
 *     *   Use `java.util.Scanner` to read user commands from the console.
 *     *   Implement a command loop that continues until the user types `exit`.
 *     *   Use a `switch` statement to handle the different commands: `add`, `enqueue`, `process`, `list`, `exit`. The `list` command will require checking a second token (`all` or `queue`).
 *     *   Provide clear prompts for user input.
 * 4.  **Error Handling:**
 *     *   Use `System.err.println()` for all error messages (e.g., invalid command format, invalid task ID, queue empty, invalid priority).
 *     *   Use `System.out.println()` for normal output (prompts, success messages, list outputs).
 *     *   Implement input validation (e.g., checking if task ID input is an integer, checking if priority is valid).
 *     *   Use `try-catch` blocks. Implement a class-wide exception handling mechanism (e.g., a `try-catch` block wrapping the main command processing loop) to catch unexpected errors and print a generic error message to `System.err`.
 * 5.  **Best Practices:**
 *     *   Use meaningful variable and method names.
 *     *   Ensure proper encapsulation (private fields, public methods).
 *     *   Include appropriate comments and documentation (Javadocs for classes/methods, inline comments for complex logic).
 *     *   Structure the code logically into classes and methods.
 * 
 * **Commands:**
 * 
 * *   `add <description> <priority>`: Adds a new task. `<priority>` must be "High", "Medium", or "Low". Description can be multiple words.
 * *   `enqueue <taskId>`: Adds the task with the given ID to the processing queue.
 * *   `process`: Processes the next task in the queue.
 * *   `list all`: Lists all tasks.
 * *   `list queue`: Lists tasks in the processing queue.
 * *   `exit`: Exits the application.
 * 
 * **Example Interaction (Illustrative):**
 * 
 * ```
 * Enter command: add Implement login feature High
 * Task 1 added (High priority). Automatically enqueued.
 * Enter command: add Design database schema Low
 * Task 2 added (Low priority).
 * Enter command: add Write unit tests Medium
 * Task 3 added (Medium priority).
 * Enter command: list all
 * Tasks:
 * ID: 1, Desc: Implement login feature, Priority: High, Completed: false
 * ID: 2, Desc: Design database schema, Priority: Low, Completed: false
 * ID: 3, Desc: Write unit tests, Priority: Medium, Completed: false
 * Enter command: list queue
 * Processing Queue:
 * ID: 1, Desc: Implement login feature, Priority: High, Completed: false
 * Enter command: enqueue 3
 * Task 3 enqueued.
 * Enter command: list queue
 * Processing Queue:
 * ID: 1, Desc: Implement login feature, Priority: High, Completed: false
 * ID: 3, Desc: Write unit tests, Priority: Medium, Completed: false
 * Enter command: process
 * Processing task: ID: 1, Desc: Implement login feature...
 * Task 1 marked as completed.
 * Enter command: process
 * Processing task: ID: 3, Desc: Write unit tests...
 * Task 3 marked as completed.
 * Enter command: process
 * Error: Processing queue is empty.
 * Enter command: list all
 * Tasks:
 * ID: 1, Desc: Implement login feature, Priority: High, Completed: true
 * ID: 2, Desc: Design database schema, Priority: Low, Completed: false
 * ID: 3, Desc: Write unit tests, Priority: Medium, Completed: true
 * Enter command: enqueue 1
 * Error: Task 1 is already completed.
 * Enter command: enqueue 5
 * Error: Task with ID 5 not found.
 * Enter command: add Fix bug Critical
 * Error: Invalid priority: Critical. Use High, Medium, or Low.
 * Enter command: exit
 * Exiting Task Manager.
 * ```
 * 
 * Implement the complete Java code for this system.
 *
 * EXPLANATION:
 * This solution implements a `TaskManager` class that simulates a basic task management system, fulfilling all the requirements of the problem.
 * 
 * 1.  **Task Class:** The `Task` class is a simple Plain Old Java Object (POJO) representing a task. It has private fields (`id`, `description`, `priority`, `isCompleted`) demonstrating encapsulation. Getters are provided for accessing the data. The `markCompleted()` method modifies the state. `toString()` provides a convenient string representation. `equals()` and `hashCode()` are overridden based on the unique ID, which is good practice for objects that might be stored in collections where uniqueness or comparison is needed (like checking if a task is already in the queue).
 * 
 * 2.  **TaskManager Class:** This is the core class managing the system's state and logic.
 *     *   `allTasks`: Declared as `List<Task>` and initialized with `new ArrayList<>()`. This demonstrates using the interface type for the variable while using a concrete implementation. `ArrayList` is suitable here for storing all tasks as it allows easy adding and iteration, and finding by ID requires a linear scan anyway.
 *     *   `processingQueue`: Declared as `Queue<Task>` and initialized with `new LinkedList<>()`. `LinkedList` implements the `Queue` interface, providing methods like `offer()` (add to end) and `poll()` (remove from front), which are essential for queue behavior (FIFO - First-In, First-Out).
 *     *   `nextTaskId`: A simple counter to generate unique IDs for tasks.
 * 
 * 3.  **Methods:**
 *     *   `addTask`: Creates a `Task` object, assigns the next ID, adds it to `allTasks`. It includes validation for the `priority` using the helper method `isValidPriority`. If the priority is "High", it automatically calls `processingQueue.offer()` to add the task to the queue. `offer()` is used as it's the standard `Queue` method for adding, returning `false` if the element cannot be added (though `LinkedList` is unbounded).
 *     *   `enqueueTask`: Finds the task by ID using the helper `findTaskById`. It performs checks to ensure the task exists, is not already completed, and is not already in the queue before adding it to the `processingQueue` using `offer()`.
 *     *   `processNextTask`: Uses `processingQueue.poll()` to retrieve and remove the task at the head of the queue. It handles the case where the queue is empty by checking if the result of `poll()` is `null`. If a task is retrieved, it finds the corresponding task in `allTasks` (to ensure the main list's state is updated) and calls `markCompleted()` on it.
 *     *   `listAllTasks`: Iterates through the `allTasks` list and prints each task's `toString()` representation.
 *     *   `listQueue`: Iterates through the `processingQueue`. Iterating over a `Queue` using a for-each loop or an iterator does *not* remove elements, correctly showing the current queue contents.
 *     *   `findTaskById`: A private helper method to search the `allTasks` list.
 *     *   `isValidPriority`: A private helper method using `Arrays.asList().contains()` for simple validation of the priority string.
 *     *   `run`: Contains the main application loop. It uses a `Scanner` to read lines of input.
 *     *   `main`: The entry point, creates a `TaskManager` instance and calls `run()`.
 * 
 * 4.  **User Interface and Control Flow:**
 *     *   The `run` method uses a `while(true)` loop for the main command processing.
 *     *   Input lines are read using `scanner.nextLine()`.
 *     *   The input line is split to get the command and arguments.
 *     *   A `switch` statement is used on the command string (`add`, `enqueue`, `process`, `list`, `exit`, `help`) to direct the program flow to the appropriate logic.
 *     *   The `list` command further checks the argument (`all` or `queue`) using `equalsIgnoreCase`.
 * 
 * 5.  **Error Handling:**
 *     *   `System.err.println()` is used for all error messages (invalid command, invalid ID, queue empty, task not found, task already completed, invalid priority).
 *     *   `System.out.println()` is used for prompts, success messages, and list outputs.
 *     *   Input validation is done for priority in `addTask` and for the task ID format in the `enqueue` case using a `try-catch(NumberFormatException)`.
 *     *   A `try-catch(Exception e)` block wraps the core logic inside the `while` loop in the `run` method. This provides a class-wide exception handling mechanism, catching any unexpected runtime exceptions that might occur during command processing and printing a generic error message to `System.err`, preventing the program from crashing abruptly. Specific, expected errors (like invalid ID format or queue empty) are handled by `if` checks and dedicated `System.err` messages *before* potentially throwing an unexpected exception.
 * 
 * This solution effectively combines the required Java components (`Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.err`, `System.out`, `try-catch`) within a practical scenario, demonstrating encapsulation, input validation, and structured error handling, making it a challenging yet solvable task for an advanced Java student.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.Arrays; // Used for quick priority validation

/**
 * Represents a single development task.
 */
class Task {
    private int id;
    private String description;
    private String priority; // High, Medium, Low
    private boolean isCompleted;

    /**
     * Constructs a new Task.
     *
     * @param id The unique ID for the task.
     * @param description The description of the task.
     * @param priority The priority of the task (High, Medium, Low).
     */
    public Task(int id, String description, String priority) {
        this.id = id;
        this.description = description;
        this.priority = priority;
        this.isCompleted = false;
    }

    // --- Getters ---
    public int getId() {
        return id;
    }

    public String getDescription() {
        return description;
    }

    public String getPriority() {
        return priority;
    }

    public boolean isCompleted() {
        return isCompleted;
    }

    /**
     * Marks the task as completed.
     */
    public void markCompleted() {
        this.isCompleted = true;
    }

    @Override
    public String toString() {
        return String.format("ID: %d, Desc: %s, Priority: %s, Completed: %b",
                             id, description, priority, isCompleted);
    }

    // Override equals and hashCode for potential queue/list checks,
    // though not strictly required by the prompt for basic functionality,
    // it's good practice if tasks might be searched/removed by object equality.
    // Based on ID being unique identifier.
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Task task = (Task) o;
        return id == task.id;
    }

    @Override
    public int hashCode() {
        return Integer.hashCode(id);
    }
}

/**
 * Manages a collection of tasks and a processing queue.
 */
public class TaskManager {
    // Using List interface for flexibility, implemented by ArrayList
    private List<Task> allTasks;
    // Using Queue interface, implemented by LinkedList
    private Queue<Task> processingQueue;
    private int nextTaskId;

    /**
     * Constructs a new TaskManager.
     */
    public TaskManager() {
        allTasks = new ArrayList<>();
        processingQueue = new LinkedList<>(); // LinkedList implements Queue
        nextTaskId = 1;
    }

    /**
     * Adds a new task to the system. Automatically enqueues High priority tasks.
     *
     * @param description The task description.
     * @param priority The task priority ("High", "Medium", "Low").
     */
    public void addTask(String description, String priority) {
        if (!isValidPriority(priority)) {
            System.err.println("Error: Invalid priority: " + priority + ". Use High, Medium, or Low.");
            return;
        }

        Task newTask = new Task(nextTaskId++, description, priority);
        allTasks.add(newTask);
        System.out.println("Task " + newTask.getId() + " added (" + newTask.getPriority() + " priority).");

        if ("High".equalsIgnoreCase(priority)) {
            // Find the task just added (using the ID) and enqueue it
            // This step is slightly redundant as we have newTask, but demonstrates finding in allTasks
            // if we only had the ID later. Here we can just use newTask directly.
             if (processingQueue.offer(newTask)) { // offer is safer than add for capacity-constrained queues, though LinkedList is not
                System.out.println("Automatically enqueued.");
             } else {
                 // Should not happen with LinkedList unless memory is exhausted
                 System.err.println("Warning: Failed to automatically enqueue High priority task " + newTask.getId());
             }
        }
    }

    /**
     * Enqueues a task by its ID for processing.
     *
     * @param taskId The ID of the task to enqueue.
     */
    public void enqueueTask(int taskId) {
        Task taskToEnqueue = findTaskById(taskId);

        if (taskToEnqueue == null) {
            System.err.println("Error: Task with ID " + taskId + " not found.");
            return;
        }

        if (taskToEnqueue.isCompleted()) {
            System.err.println("Error: Task " + taskId + " is already completed.");
            return;
        }

        if (processingQueue.contains(taskToEnqueue)) {
             System.err.println("Error: Task " + taskId + " is already in the processing queue.");
             return;
        }

        if (processingQueue.offer(taskToEnqueue)) {
            System.out.println("Task " + taskId + " enqueued.");
        } else {
            // Should not happen with LinkedList
            System.err.println("Error: Failed to enqueue task " + taskId + " due to queue constraints.");
        }
    }

    /**
     * Processes the next task from the front of the queue.
     */
    public void processNextTask() {
        Task taskToProcess = processingQueue.poll(); // Retrieves and removes the head of the queue

        if (taskToProcess == null) {
            System.err.println("Error: Processing queue is empty.");
            return;
        }

        System.out.println("Processing task: " + taskToProcess.toString() + "...");

        // Find the task in allTasks to mark it as completed
        // We could use the taskToProcess object directly if we are sure
        // it's the same object reference, but finding it by ID in the list
        // is a safer way to ensure the state in the main list is updated.
        Task taskInList = findTaskById(taskToProcess.getId());
        if (taskInList != null) {
            taskInList.markCompleted();
            System.out.println("Task " + taskInList.getId() + " marked as completed.");
        } else {
             // This case should ideally not happen if taskToProcess came from allTasks
             System.err.println("Error: Processed task " + taskToProcess.getId() + " not found in main task list!");
        }
    }

    /**
     * Lists all tasks in the system.
     */
    public void listAllTasks() {
        System.out.println("Tasks:");
        if (allTasks.isEmpty()) {
            System.out.println("No tasks added yet.");
        } else {
            for (Task task : allTasks) {
                System.out.println(task);
            }
        }
    }

    /**
     * Lists tasks currently in the processing queue.
     */
    public void listQueue() {
        System.out.println("Processing Queue:");
        if (processingQueue.isEmpty()) {
            System.out.println("Queue is empty.");
        } else {
            // Iterating over the queue does not remove elements
            for (Task task : processingQueue) {
                System.out.println(task);
            }
        }
    }

    /**
     * Finds a task in the main list by its ID.
     *
     * @param id The ID of the task to find.
     * @return The Task object if found, null otherwise.
     */
    private Task findTaskById(int id) {
        for (Task task : allTasks) {
            if (task.getId() == id) {
                return task;
            }
        }
        return null;
    }

    /**
     * Validates if the given priority string is one of the allowed values.
     *
     * @param priority The priority string to validate.
     * @return true if the priority is valid, false otherwise.
     */
    private boolean isValidPriority(String priority) {
        if (priority == null) return false;
        List<String> validPriorities = Arrays.asList("High", "Medium", "Low");
        return validPriorities.contains(priority);
    }

    /**
     * Runs the main command loop for the Task Manager.
     */
    public void run() {
        Scanner scanner = new Scanner(System.in);
        System.out.println("Task Manager started. Type 'help' or 'exit'.");

        while (true) {
            System.out.print("Enter command: ");
            String inputLine = scanner.nextLine().trim();

            // Class-wide exception handling for the main loop
            try {
                if (inputLine.isEmpty()) {
                    continue;
                }

                String[] parts = inputLine.split(" ", 2); // Split into command and arguments
                String command = parts[0].toLowerCase();
                String args = parts.length > 1 ? parts[1] : "";

                switch (command) {
                    case "add":
                        String[] addArgs = args.split(" ");
                        if (addArgs.length < 2) {
                            System.err.println("Error: add command requires description and priority. Usage: add <description> <priority>");
                        } else {
                            // The last argument is priority, the rest is description
                            String priority = addArgs[addArgs.length - 1];
                            String description = String.join(" ", Arrays.copyOfRange(addArgs, 0, addArgs.length - 1));
                            addTask(description, priority);
                        }
                        break;

                    case "enqueue":
                        try {
                            int taskId = Integer.parseInt(args.trim());
                            enqueueTask(taskId);
                        } catch (NumberFormatException e) {
                            System.err.println("Error: Invalid task ID format. Please enter a number.");
                        }
                        break;

                    case "process":
                        processNextTask();
                        break;

                    case "list":
                        if (args.equalsIgnoreCase("all")) {
                            listAllTasks();
                        } else if (args.equalsIgnoreCase("queue")) {
                            listQueue();
                        } else {
                            System.err.println("Error: list command requires 'all' or 'queue'. Usage: list <all|queue>");
                        }
                        break;

                    case "exit":
                        System.out.println("Exiting Task Manager.");
                        scanner.close(); // Close the scanner
                        return; // Exit the run method

                    case "help":
                         System.out.println("Available commands:");
                         System.out.println("  add <description> <priority> - Add a new task (priority: High, Medium, Low)");
                         System.out.println("  enqueue <taskId>           - Add a task to the processing queue");
                         System.out.println("  process                    - Process the next task in the queue");
                         System.out.println("  list all                   - List all tasks");
                         System.out.println("  list queue                 - List tasks in the processing queue");
                         System.out.println("  exit                       - Exit the application");
                         break;

                    default:
                        System.err.println("Error: Unknown command '" + command + "'. Type 'help' for available commands.");
                        break;
                }
            } catch (Exception e) {
                // Catch any unexpected runtime exceptions during command processing
                System.err.println("An unexpected error occurred: " + e.getMessage());
                // Optional: e.printStackTrace(); // For debugging during development
            }
        }
    }

    /**
     * Main method to start the Task Manager.
     *
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        TaskManager manager = new TaskManager();
        manager.run();
    }
}
