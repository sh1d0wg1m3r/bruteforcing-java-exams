/*
 * Exam Question #370
 * Generated on: 2025-05-11 23:01:33
 * Generated by: Account 2
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Customer Support Ticket System
 * 
 * **Problem Description:**
 * 
 * You are tasked with developing a simple command-line application for a customer support department. The system should manage support tickets submitted by customers. New tickets arrive and are added to a queue for processing. Support agents process tickets one by one from the front of the queue. The system should also maintain a history of all tickets ever created, regardless of their current processing status.
 * 
 * **Requirements:**
 * 
 * Implement a Java program that provides the following functionality:
 * 
 * 1.  **Add New Ticket:** Allows a user (simulating a customer or agent creating a ticket) to enter a description for a new support ticket. The system should assign a unique ID to each ticket and add it to a queue of pending tickets. It should also add the ticket to a separate list that stores all tickets ever created.
 * 2.  **View Pending Tickets:** Displays all tickets currently in the processing queue. Tickets should be displayed in the order they will be processed (FIFO).
 * 3.  **Process Next Ticket:** Removes the next ticket from the front of the processing queue and marks it as "Processed" in the historical list of all tickets. Displays the details of the processed ticket. Handles the case where the queue is empty.
 * 4.  **View All Tickets:** Displays a list of all tickets ever created, including their ID, description, and current status (Pending or Processed).
 * 5.  **Exit:** Terminates the application.
 * 
 * **Technical Constraints:**
 * 
 * Your solution must adhere to the following technical requirements:
 * 
 * *   Use `java.util.Queue` to manage the pending support tickets. You can use a class that implements `Queue`, such as `java.util.LinkedList`.
 * *   Use `java.util.ArrayList` to store the history of all tickets ever created.
 * *   Declare the historical list variable using the `java.util.List` interface type (e.g., `List<Ticket> allTickets = new ArrayList<>();`).
 * *   Use `java.util.Scanner` to get user input for menu selection and ticket details.
 * *   Use a `switch` statement to handle the main menu options.
 * *   Use `System.err.println()` to display error messages (e.g., invalid input, queue empty when trying to process).
 * *   Use `System.out.println()` for all normal output (menu, ticket details, confirmation messages).
 * *   Implement class-wide exception handling using `try-catch` blocks to gracefully handle unexpected runtime errors during the main application loop. Additionally, include specific `try-catch` blocks where necessary (e.g., for handling non-integer input for menu choices).
 * *   Follow best practices:
 *     *   Create a `Ticket` class with private fields (ticket ID, description, status) and public getter methods.
 *     *   Use meaningful variable and method names.
 *     *   Include appropriate comments and documentation (e.g., Javadoc).
 *     *   Implement input validation where applicable.
 *     *   Ensure proper resource management (e.g., closing the `Scanner`).
 *     *   Structure your code into logical classes and methods.
 * 
 * **Expected Output:**
 * 
 * The program should present a menu to the user, accept input, and perform actions based on the input. Output should be clear and informative, indicating the result of each operation. Error messages should be distinct using `System.err`.
 * 
 * Example interaction:
 * 
 * ```
 * --- Support Ticket System Menu ---
 * 1. Add New Ticket
 * 2. View Pending Tickets
 * 3. Process Next Ticket
 * 4. View All Tickets
 * 5. Exit
 * Enter your choice: 1
 * Enter ticket description: Internet connection issues
 * Ticket #1 added.
 * 
 * --- Support Ticket System Menu ---
 * 1. Add New Ticket
 * 2. View Pending Tickets
 * 3. Process Next Ticket
 * 4. View All Tickets
 * 5. Exit
 * Enter your choice: 1
 * Enter ticket description: Software installation problem
 * Ticket #2 added.
 * 
 * --- Support Ticket System Menu ---
 * 1. Add New Ticket
 * 2. View Pending Tickets
 * 3. Process Next Ticket
 * 4. View All Tickets
 * 5. Exit
 * Enter your choice: 2
 * --- Pending Tickets ---
 * Ticket #1: Internet connection issues [Pending]
 * Ticket #2: Software installation problem [Pending]
 * -------------------------
 * 
 * --- Support Ticket System Menu ---
 * 1. Add New Ticket
 * 2. View Pending Tickets
 * 3. Process Next Ticket
 * 4. View All Tickets
 * 5. Exit
 * Enter your choice: 3
 * Processing Ticket #1: Internet connection issues
 * Ticket #1 processed.
 * 
 * --- Support Ticket System Menu ---
 * 1. Add New Ticket
 * 2. View Pending Tickets
 * 3. Process Next Ticket
 * 4. View All Tickets
 * 5. Exit
 * Enter your choice: 2
 * --- Pending Tickets ---
 * Ticket #2: Software installation problem [Pending]
 * -------------------------
 * 
 * --- Support Ticket System Menu ---
 * 1. Add New Ticket
 * 2. View Pending Tickets
 * 3. Process Next Ticket
 * 4. View All Tickets
 * 5. Exit
 * Enter your choice: 4
 * --- All Tickets ---
 * Ticket #1: Internet connection issues [Processed]
 * Ticket #2: Software installation problem [Pending]
 * -------------------------
 * 
 * --- Support Ticket System Menu ---
 * 1. Add New Ticket
 * 2. View Pending Tickets
 * 3. Process Next Ticket
 * 4. View All Tickets
 * 5. Exit
 * Enter your choice: 6
 * Error: Invalid menu choice. Please enter a number between 1 and 5.
 * 
 * --- Support Ticket System Menu ---
 * 1. Add New Ticket
 * 2. View Pending Tickets
 * 3. Process Next Ticket
 * 4. View All Tickets
 * 5. Exit
 * Enter your choice: 3
 * Processing Ticket #2: Software installation problem
 * Ticket #2 processed.
 * 
 * --- Support Ticket System Menu ---
 * 1. Add New Ticket
 * 2. View Pending Tickets
 * 3. Process Next Ticket
 * 4. View All Tickets
 * 5. Exit
 * Enter your choice: 3
 * Error: No pending tickets to process. The queue is empty.
 * 
 * --- Support Ticket System Menu ---
 * 1. Add New Ticket
 * 2. View Pending Tickets
 * 3. Process Next Ticket
 * 4. View All Tickets
 * 5. Exit
 * Enter your choice: 5
 * Exiting Support Ticket System.
 * ```
 * 
 * **Evaluation:**
 * 
 * Your solution will be evaluated based on:
 * *   Correct implementation of all required functionalities.
 * *   Proper use of `Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.err`, `System.out`.
 * *   Effective use of `try-catch` for error handling, including both specific and general exceptions.
 * *   Adherence to best practices (encapsulation, naming, comments, input validation, resource management).
 * *   Code clarity and structure.
 * 
 * Good luck!
 *
 * EXPLANATION:
 * This solution implements a simple Customer Support Ticket System demonstrating the required Java concepts.
 * 
 * **Core Structure:**
 * 
 * 1.  **`Ticket` Class:** A simple Plain Old Java Object (POJO) representing a single support ticket. It encapsulates the `id`, `description`, and `status` (`Pending` or `Processed`) of a ticket. It uses a static counter (`nextId`) to ensure unique IDs for each ticket. The `toString()` method provides a convenient way to display ticket information.
 * 2.  **`SupportTicketSystem` Class:** This is the main class that manages the ticket system logic.
 *     *   It holds two data structures:
 *         *   `pendingTicketsQueue`: A `java.util.Queue` (implemented using `java.util.LinkedList`) to store tickets that are waiting to be processed. The `Queue` interface ensures FIFO (First-In, First-Out) processing order, which is typical for a support queue.
 *         *   `allTicketsList`: A `java.util.List` (implemented using `java.util.ArrayList`) to keep a historical record of *all* tickets created in the system, regardless of whether they are pending or processed. Using `List` as the type for the `ArrayList` variable demonstrates polymorphism and programming to interfaces.
 *     *   It uses a `java.util.Scanner` to handle user input from the console.
 *     *   It contains methods for each menu option (`addNewTicket`, `viewPendingTickets`, `processNextTicket`, `viewAllTickets`).
 *     *   The `run()` method contains the main application loop, menu display, input reading, and the `switch` statement for handling user choices.
 * 
 * **Usage of Required Components:**
 * 
 * *   **`Queue` (`java.util.Queue`)**: The `pendingTicketsQueue` is declared as a `Queue<Ticket>` and instantiated as a `LinkedList<Ticket>`. Tickets are added using `offer()` (or `add()`) and removed from the front for processing using `poll()`. Iteration for viewing pending tickets uses a standard enhanced for loop, which works correctly with `Queue` implementations without removing elements.
 * *   **`ArrayList` (`java.util.ArrayList`)**: The `allTicketsList` is instantiated as an `ArrayList<Ticket>`. It's used to store every ticket created. This allows viewing the full history and updating the status of tickets once they are processed from the queue.
 * *   **`List` (`java.util.List`)**: The `allTicketsList` variable is explicitly declared with the `List<Ticket>` interface type: `private List<Ticket> allTicketsList = new ArrayList<>();`. This is a best practice for flexibility and abstraction.
 * *   **`Scanner` (`java.util.Scanner`)**: An instance of `Scanner` is used in the `run()` method to read integer input for the menu choice and in `addNewTicket()` to read the ticket description. `try-with-resources` is used around the scanner in the `run` method to ensure it's automatically closed when the `run` method finishes or an exception occurs.
 * *   **`switch` Statement**: A `switch` statement in the `run()` method is used to direct the program flow based on the user's integer input for the menu choice.
 * *   **`System.err`**: Used in the `run()` method to display error messages for invalid menu input (`InputMismatchException`, out-of-range choice) and in `processNextTicket()` when attempting to process a ticket from an empty queue.
 * *   **`System.out`**: Used for all standard output, including displaying the menu, success messages (ticket added, ticket processed), and listing ticket details in `viewPendingTickets()` and `viewAllTickets()`.
 * *   **Class-wide `try-catch`**: The main `while` loop within the `run()` method is wrapped in a `try-catch(Exception e)` block. This provides a top-level catch-all for any unexpected runtime exceptions that might occur within the core application logic, preventing the program from crashing abruptly and printing an error message to `System.err`.
 * *   **Specific `try-catch`**: A specific `try-catch(InputMismatchException e)` block is used when reading the menu choice. This handles cases where the user enters non-integer input, prints an informative error message to `System.err`, and consumes the invalid input from the scanner to prevent an infinite loop.
 * 
 * **Best Practices:**
 * 
 * *   **Encapsulation:** The `Ticket` class has private fields and public getter methods, controlling access to its internal state. The `SupportTicketSystem` manages its internal data structures (`Queue`, `List`) via its methods.
 * *   **Meaningful Names:** Variables (`pendingTicketsQueue`, `allTicketsList`, `ticketDescription`), methods (`addNewTicket`, `processNextTicket`, `displayMenu`), and classes (`Ticket`, `SupportTicketSystem`) have names that clearly indicate their purpose.
 * *   **Comments and Documentation:** Javadoc comments are used for classes and methods, explaining their purpose and parameters. Inline comments explain specific logic where needed.
 * *   **Input Validation:** The code checks if the ticket description is empty. It also validates the menu choice to ensure it's an integer within the valid range (1-5).
 * *   **Error Handling:** Both specific (`InputMismatchException`) and general (`Exception`) `try-catch` blocks are used. Edge cases like processing from an empty queue are explicitly checked and handled with `System.err` messages.
 * *   **Clean Code Structure:** The code is divided into logical classes and methods, making it readable and maintainable.
 * 
 * This solution effectively demonstrates the required Java concepts in a practical scenario while adhering to good programming practices.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.InputMismatchException;

/**
 * Represents a customer support ticket.
 */
class Ticket {
    private static int nextId = 1;
    private int id;
    private String description;
    private String status; // e.g., "Pending", "Processed"

    /**
     * Constructs a new Ticket with a unique ID and description.
     * Initially set to "Pending" status.
     * @param description The description of the support issue.
     */
    public Ticket(String description) {
        this.id = nextId++;
        this.description = description;
        this.status = "Pending";
    }

    public int getId() {
        return id;
    }

    public String getDescription() {
        return description;
    }

    public String getStatus() {
        return status;
    }

    public void setStatus(String status) {
        this.status = status;
    }

    @Override
    public String toString() {
        return String.format("Ticket #%d: %s [%s]", id, description, status);
    }
}

/**
 * Manages the support ticket system.
 * Handles adding, viewing, and processing tickets.
 */
public class SupportTicketSystem {

    // Queue for tickets awaiting processing (FIFO)
    private Queue<Ticket> pendingTicketsQueue;

    // List to store all tickets ever created (for history)
    private List<Ticket> allTicketsList;

    private Scanner scanner;

    /**
     * Constructs a new SupportTicketSystem.
     * Initializes the queue, list, and scanner.
     */
    public SupportTicketSystem() {
        this.pendingTicketsQueue = new LinkedList<>(); // LinkedList implements Queue
        this.allTicketsList = new ArrayList<>(); // ArrayList implements List
        this.scanner = new Scanner(System.in);
    }

    /**
     * Displays the main menu to the user.
     */
    private void displayMenu() {
        System.out.println("\n--- Support Ticket System Menu ---");
        System.out.println("1. Add New Ticket");
        System.out.println("2. View Pending Tickets");
        System.out.println("3. Process Next Ticket");
        System.out.println("4. View All Tickets");
        System.out.println("5. Exit");
        System.out.print("Enter your choice: ");
    }

    /**
     * Adds a new ticket to the system.
     * Reads description from user, creates Ticket object, adds to queue and list.
     */
    private void addNewTicket() {
        System.out.print("Enter ticket description: ");
        // Consume the newline character left by previous nextInt() or similar
        scanner.nextLine();
        String description = scanner.nextLine();

        if (description == null || description.trim().isEmpty()) {
             System.err.println("Error: Ticket description cannot be empty.");
             return;
        }

        Ticket newTicket = new Ticket(description);
        pendingTicketsQueue.offer(newTicket); // Add to the end of the queue
        allTicketsList.add(newTicket);      // Add to the history list

        System.out.println("Ticket #" + newTicket.getId() + " added.");
    }

    /**
     * Displays all tickets currently in the pending queue.
     */
    private void viewPendingTickets() {
        System.out.println("--- Pending Tickets ---");
        if (pendingTicketsQueue.isEmpty()) {
            System.out.println("No tickets are currently pending.");
        } else {
            // Iterate through the queue without removing elements
            for (Ticket ticket : pendingTicketsQueue) {
                System.out.println(ticket);
            }
        }
        System.out.println("-------------------------");
    }

    /**
     * Processes the next ticket in the queue (removes it)
     * and updates its status in the allTicketsList.
     */
    private void processNextTicket() {
        Ticket ticketToProcess = pendingTicketsQueue.poll(); // Get and remove the head of the queue

        if (ticketToProcess == null) {
            System.err.println("Error: No pending tickets to process. The queue is empty.");
        } else {
            System.out.println("Processing " + ticketToProcess);

            // Update status in the allTicketsList
            // Find the ticket in the list by ID and update its status
            for (Ticket ticket : allTicketsList) {
                if (ticket.getId() == ticketToProcess.getId()) {
                    ticket.setStatus("Processed");
                    break; // Found and updated, no need to continue searching
                }
            }
            System.out.println("Ticket #" + ticketToProcess.getId() + " processed.");
        }
    }

    /**
     * Displays all tickets ever created, including their status.
     */
    private void viewAllTickets() {
        System.out.println("--- All Tickets ---");
        if (allTicketsList.isEmpty()) {
            System.out.println("No tickets have been created yet.");
        } else {
            for (Ticket ticket : allTicketsList) {
                System.out.println(ticket);
            }
        }
        System.out.println("-------------------------");
    }

    /**
     * Runs the main application loop.
     * Handles user input and calls appropriate methods.
     * Includes class-wide exception handling.
     */
    public void run() {
        int choice = -1;
        // Use try-with-resources for Scanner to ensure it's closed
        try (scanner) { // Scanner is initialized in the constructor
             // Class-wide exception handling for the main loop
            try {
                while (choice != 5) {
                    displayMenu();

                    try {
                        choice = scanner.nextInt(); // Read integer input
                    } catch (InputMismatchException e) {
                        System.err.println("Error: Invalid input. Please enter a number.");
                        scanner.nextLine(); // Consume the invalid input to prevent infinite loop
                        continue; // Skip to the next loop iteration
                    }

                    // Basic range validation
                    if (choice < 1 || choice > 5) {
                         System.err.println("Error: Invalid menu choice. Please enter a number between 1 and 5.");
                         continue; // Skip to the next loop iteration
                    }

                    switch (choice) {
                        case 1:
                            addNewTicket();
                            break;
                        case 2:
                            viewPendingTickets();
                            break;
                        case 3:
                            processNextTicket();
                            break;
                        case 4:
                            viewAllTickets();
                            break;
                        case 5:
                            System.out.println("Exiting Support Ticket System.");
                            break;
                        default:
                            // This case should ideally not be reached due to validation above,
                            // but included for robustness.
                            System.err.println("Error: Unexpected choice.");
                    }
                }
            } catch (Exception e) {
                // Catch any unexpected runtime exceptions during the main loop
                System.err.println("An unexpected error occurred: " + e.getMessage());
                e.printStackTrace(System.err); // Print stack trace to error stream
            }
        } // Scanner is automatically closed here by try-with-resources
    }

    /**
     * Main method to start the application.
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        SupportTicketSystem system = new SupportTicketSystem();
        system.run();
    }
}
