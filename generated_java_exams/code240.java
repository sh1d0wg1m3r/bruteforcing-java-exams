/*
 * Exam Question #240
 * Generated on: 2025-05-11 22:37:44
 * Generated by: Account 5
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Logistics and Delivery Management System
 * 
 * **Objective:** Design and implement a simple console-based Logistics and Delivery Management System. This system will manage delivery orders, process them through a queue, and allow tracking and status updates. Your solution must demonstrate proficiency in using core Java collections, control flow, and exception handling.
 * 
 * **Scenario:** You are building a simplified system for a small delivery company. Orders are received and placed into a queue for processing. A dispatcher can process the next order in the queue, and the status of any order can be updated manually as it progresses through its lifecycle (e.g., from Processing to Shipped, then to Delivered).
 * 
 * **Requirements:**
 * 
 * 1.  **`OrderStatus` Enum:** Create an enum `OrderStatus` with the following states: `PENDING`, `PROCESSING`, `SHIPPED`, `DELIVERED`, `CANCELLED`.
 * 2.  **`DeliveryOrder` Class:**
 *     *   Represent a single delivery order.
 *     *   Include private fields for `orderId` (int), `destination` (String), `items` (`List<String>`), and `status` (`OrderStatus`).
 *     *   The `orderId` should be unique and auto-generated by the system.
 *     *   Provide a constructor to initialize `destination` and `items`. The initial status should be `PENDING`.
 *     *   Include public getter methods for all fields.
 *     *   Include a public method `updateStatus(OrderStatus newStatus)` to change the order's status.
 *     *   Override the `toString()` method to provide a clear string representation of the order, including its ID, destination, items, and current status.
 * 3.  **`DeliveryManager` Class:**
 *     *   Manage all delivery orders in the system.
 *     *   Use a `Queue<DeliveryOrder>` to hold orders that are currently `PENDING` and waiting to be processed.
 *     *   Use a `List<DeliveryOrder>` to store *all* orders ever created, regardless of their current status. Declare this field using the `List` interface type.
 *     *   Maintain a counter for the next available `orderId`.
 *     *   Implement the following functionalities via public methods:
 *         *   `addOrder(String destination, List<String> items)`: Creates a new `DeliveryOrder`, assigns it a unique ID, adds it to the list of all orders, and adds it to the pending queue. Returns the new order's ID.
 *         *   `processNextPendingOrder()`: Retrieves and removes the next order from the pending queue. Updates its status to `PROCESSING`. Returns the processed order, or `null` if the queue is empty.
 *         *   `updateOrderStatus(int orderId, OrderStatus newStatus)`: Finds an order by its ID in the list of all orders and updates its status. If the order is found and its status was `PENDING`, it should be removed from the pending queue *before* updating the status. If the order was not found, indicate an error.
 *         *   `viewOrderStatus(int orderId)`: Finds an order by its ID and prints its details using its `toString()` method. If the order is not found, indicate an error.
 *         *   `listAllOrders()`: Prints details of all orders currently in the system using their `toString()` methods.
 *         *   `listPendingOrders()`: Prints details of all orders currently in the pending queue using their `toString()` methods.
 *     *   Include a method (e.g., `runSystem(Scanner scanner)`) that provides a command-line interface for the user to interact with the system. This method should:
 *         *   Display a menu of options (Add Order, Process Next, Update Status, View Status, List All, List Pending, Exit).
 *         *   Read user input using the provided `Scanner`.
 *         *   Use a `switch` statement to handle different user commands.
 *         *   Implement input validation (e.g., ensuring integer input where expected, checking if order IDs exist).
 *         *   Use `System.out` for normal output (menu, order details, confirmations).
 *         *   Use `System.err` for displaying error messages (e.g., invalid command, order not found, queue empty, invalid input format).
 *         *   Implement **class-wide exception handling** using `try-catch` blocks within the `runSystem` method to gracefully handle unexpected errors during the command processing loop (e.g., `InputMismatchException`, `NumberFormatException`, or other runtime issues).
 * 4.  **`Main` Class:**
 *     *   Create a `main` method.
 *     *   Instantiate `Scanner` and `DeliveryManager`.
 *     *   Call the `runSystem` method of the `DeliveryManager` to start the interaction loop.
 *     *   Ensure the `Scanner` is closed properly when the program exits.
 * 
 * **Required Java Components Checklist:**
 * 
 * *   `java.util.Queue`: Used in `DeliveryManager` for the pending queue.
 * *   `java.util.ArrayList`: Used in `DeliveryManager` for the list of all orders.
 * *   `java.util.List`: Used as the interface type for the list of all orders and for the `items` list in `DeliveryOrder`.
 * *   `java.util.Scanner`: Used in `main` and passed to `runSystem` for user input.
 * *   `switch` statement: Used in `runSystem` for menu navigation.
 * *   `System.err`: Used for displaying error messages.
 * *   `System.out`: Used for displaying normal output and the menu.
 * *   `try-catch` blocks: Used for class-wide exception handling in `runSystem` and potentially for specific input parsing errors.
 * 
 * **Expected Output:**
 * 
 * The program should present a menu, accept user commands, and print appropriate output or error messages based on the user's actions. Examples:
 * 
 * *   Adding an order: Prompt for destination and items, confirm creation with Order ID.
 * *   Processing next: Print details of the processed order, or an error if the queue is empty.
 * *   Updating status: Prompt for Order ID and new status, confirm update or report error if ID not found or status invalid.
 * *   Viewing status: Prompt for Order ID, print order details or report error.
 * *   Listing orders: Print details of all orders or pending orders.
 * *   Errors: Print messages to `System.err`.
 * *   General exceptions caught by the main `try-catch`: Print an error message to `System.err` and potentially continue or exit gracefully.
 * 
 * **Evaluation Criteria:**
 * 
 * *   Correct usage of all required Java components.
 * *   Proper implementation of `DeliveryOrder` and `DeliveryManager` classes with encapsulation.
 * *   Accurate implementation of all required functionalities.
 * *   Effective use of the `OrderStatus` enum.
 * *   Robust input validation and error handling using `System.err` and `try-catch`.
 * *   Clear and readable code structure.
 * *   Meaningful variable and method names.
 * *   Appropriate comments and documentation (optional but recommended for clarity).
 * 
 * **Time Limit:** 45-60 minutes
 *
 * EXPLANATION:
 * This solution implements a simple Logistics and Delivery Management System, fulfilling all the requirements of the exam task.
 * 
 * 1.  **`OrderStatus` Enum:** Defines the possible states of a delivery order, making the code more readable and preventing invalid status values. Helper methods are added for easy mapping between user input (numbers) and enum values.
 * 2.  **`DeliveryOrder` Class:** Represents an order with encapsulated data (`orderId`, `destination`, `items`, `status`). It uses `List<String>` for items, demonstrating the use of the `List` interface. Getters provide controlled access to the data. The `updateStatus` method allows changing the order's state. `toString()` provides a convenient way to display order information.
 * 3.  **`DeliveryManager` Class:** This is the core class managing the system's state.
 *     *   It uses a `Queue<DeliveryOrder>` (`pendingOrdersQueue`) to model the waiting line for orders to be processed. `LinkedList` is chosen as a common `Queue` implementation.
 *     *   It uses an `ArrayList<DeliveryOrder>` (`allOrdersList`) declared as a `List<DeliveryOrder>` to store a record of every order created. This demonstrates programming to the `List` interface while using a concrete `ArrayList` implementation.
 *     *   `addOrder`: Creates a new `DeliveryOrder`, assigns a unique ID, adds it to `allOrdersList`, and adds it to `pendingOrdersQueue` because new orders start as `PENDING`. Includes basic input validation.
 *     *   `processNextPendingOrder`: Uses `queue.poll()` to get and remove the head of the `pendingOrdersQueue`, simulating processing. It updates the order's status. Handles the case where the queue is empty by returning `null`.
 *     *   `updateOrderStatus`: Iterates through `allOrdersList` to find the order by ID. If found, it updates the status. Crucially, it includes logic to remove the order from `pendingOrdersQueue` if its status changes from `PENDING` to something else, and potentially add it back if the status changes *to* `PENDING`.
 *     *   `viewOrderStatus`: Finds an order by ID in `allOrdersList` and prints its details using its `toString()` method.
 *     *   `listAllOrders`: Iterates and prints all orders from `allOrdersList`.
 *     *   `listPendingOrders`: Iterates through the `pendingOrdersQueue` (using an enhanced for loop or iterator, which doesn't remove elements) and prints pending orders.
 *     *   `runSystem`: This method implements the user interface loop. It displays a menu, reads user input using the `Scanner`, and uses a `switch` statement to dispatch commands.
 *     *   **Error Handling (`System.err` and `try-catch`):**
 *         *   Error messages related to invalid operations (e.g., order not found, invalid status number, queue empty) are printed to `System.err`.
 *         *   A `try-catch` block is wrapped around the core logic within the `while` loop in `runSystem`. This provides "class-wide" exception handling for the main execution flow of the `DeliveryManager`. It specifically catches `InputMismatchException` which occurs if the user enters non-integer input when `scanner.nextInt()` is expected, preventing a crash and allowing the loop to continue after informing the user. A general `Exception` catch is also included as a fallback for any other unexpected runtime errors during command processing.
 * 4.  **`Main` Class:** The standard entry point. It creates the `Scanner` and `DeliveryManager` instances and starts the system by calling `manager.runSystem()`. It ensures the `Scanner` is closed upon program exit.
 * 
 * This solution effectively demonstrates the required components in a practical context, adhering to best practices like encapsulation, meaningful names, and robust error handling. The use of `Queue` for processing flow and `List` for overall storage is a common pattern in such systems.
 */

import java.util.*;

// 1. OrderStatus Enum
enum OrderStatus {
    PENDING, PROCESSING, SHIPPED, DELIVERED, CANCELLED;

    // Helper to get status by index for user input
    public static OrderStatus getStatusByIndex(int index) {
        if (index >= 0 && index < values().length) {
            return values()[index];
        }
        return null; // Or throw an IllegalArgumentException
    }

    // Helper to list statuses with indices
    public static void printStatuses() {
        for (int i = 0; i < values().length; i++) {
            System.out.println(i + ": " + values()[i]);
        }
    }
}

// 2. DeliveryOrder Class
class DeliveryOrder {
    private final int orderId;
    private final String destination;
    private final List<String> items; // Using List interface
    private OrderStatus status;

    public DeliveryOrder(int orderId, String destination, List<String> items) {
        this.orderId = orderId;
        this.destination = destination;
        this.items = new ArrayList<>(items); // Defensive copy
        this.status = OrderStatus.PENDING;
    }

    // Getters
    public int getOrderId() {
        return orderId;
    }

    public String getDestination() {
        return destination;
    }

    public List<String> getItems() {
        return Collections.unmodifiableList(items); // Return unmodifiable list
    }

    public OrderStatus getStatus() {
        return status;
    }

    // Method to update status
    public void updateStatus(OrderStatus newStatus) {
        this.status = newStatus;
    }

    // Override toString for clear representation
    @Override
    public String toString() {
        return "Order ID: " + orderId +
               ", Destination: " + destination +
               ", Items: " + items +
               ", Status: " + status;
    }
}

// 3. DeliveryManager Class
class DeliveryManager {
    // Using Queue for pending orders
    private Queue<DeliveryOrder> pendingOrdersQueue;
    // Using List interface and ArrayList implementation for all orders
    private List<DeliveryOrder> allOrdersList;
    private int nextOrderId; // Counter for unique IDs

    public DeliveryManager() {
        this.pendingOrdersQueue = new LinkedList<>(); // LinkedList is a common Queue implementation
        this.allOrdersList = new ArrayList<>(); // ArrayList for general storage
        this.nextOrderId = 1; // Start Order IDs from 1
    }

    /**
     * Adds a new delivery order to the system.
     * @param destination The destination address for the order.
     * @param items The list of items included in the order.
     * @return The ID of the newly created order.
     */
    public int addOrder(String destination, List<String> items) {
        if (destination == null || destination.trim().isEmpty() || items == null || items.isEmpty()) {
             System.err.println("Error: Destination and items list cannot be empty.");
             return -1; // Indicate failure
        }
        DeliveryOrder newOrder = new DeliveryOrder(nextOrderId++, destination, items);
        allOrdersList.add(newOrder); // Add to the list of all orders
        pendingOrdersQueue.offer(newOrder); // Add to the pending queue (if status is PENDING, which it is initially)
        return newOrder.getOrderId();
    }

    /**
     * Processes the next order from the pending queue.
     * Updates its status to PROCESSING.
     * @return The processed DeliveryOrder, or null if the queue is empty.
     */
    public DeliveryOrder processNextPendingOrder() {
        DeliveryOrder orderToProcess = pendingOrdersQueue.poll(); // Retrieve and remove from queue
        if (orderToProcess != null) {
            orderToProcess.updateStatus(OrderStatus.PROCESSING);
            // Note: The order remains in allOrdersList, only removed from queue
        }
        return orderToProcess;
    }

    /**
     * Finds an order by ID and updates its status.
     * If the order was PENDING, it's removed from the queue.
     * @param orderId The ID of the order to update.
     * @param newStatus The new status for the order.
     * @return true if the order was found and updated, false otherwise.
     */
    public boolean updateOrderStatus(int orderId, OrderStatus newStatus) {
        for (DeliveryOrder order : allOrdersList) {
            if (order.getOrderId() == orderId) {
                // If the order was pending and is being moved out of pending, remove from queue
                if (order.getStatus() == OrderStatus.PENDING && newStatus != OrderStatus.PENDING) {
                     // Removing from queue might be slow for large queues, but necessary for consistency
                    pendingOrdersQueue.remove(order);
                }
                 // If the order is being set back to PENDING, add it back to the queue
                 if (order.getStatus() != OrderStatus.PENDING && newStatus == OrderStatus.PENDING) {
                    // Check if it's already in the queue to avoid duplicates (offer returns true if added)
                    if (!pendingOrdersQueue.contains(order)) {
                         pendingOrdersQueue.offer(order);
                    }
                 }
                order.updateStatus(newStatus);
                return true;
            }
        }
        return false; // Order not found
    }

    /**
     * Finds an order by ID and prints its details.
     * @param orderId The ID of the order to view.
     * @return true if the order was found and printed, false otherwise.
     */
    public boolean viewOrderStatus(int orderId) {
         for (DeliveryOrder order : allOrdersList) {
            if (order.getOrderId() == orderId) {
                System.out.println(order); // Uses DeliveryOrder's toString()
                return true;
            }
        }
        return false; // Order not found
    }

    /**
     * Prints details of all orders in the system.
     */
    public void listAllOrders() {
        if (allOrdersList.isEmpty()) {
            System.out.println("No orders in the system.");
        } else {
            System.out.println("--- All Orders ---");
            for (DeliveryOrder order : allOrdersList) {
                System.out.println(order);
            }
            System.out.println("------------------");
        }
    }

    /**
     * Prints details of orders currently in the pending queue.
     */
    public void listPendingOrders() {
         if (pendingOrdersQueue.isEmpty()) {
            System.out.println("No pending orders in the queue.");
        } else {
            System.out.println("--- Pending Orders ---");
            // Iterate through the queue without removing elements
            for (DeliveryOrder order : pendingOrdersQueue) {
                System.out.println(order);
            }
            System.out.println("----------------------");
        }
    }

    /**
     * Runs the main command-line interface for the delivery system.
     * @param scanner The Scanner object for reading user input.
     */
    public void runSystem(Scanner scanner) {
        boolean running = true;
        while (running) {
            // Class-wide exception handling using try-catch around the main loop body
            try {
                printMenu();
                System.out.print("Enter command: ");
                int command = scanner.nextInt(); // Potential InputMismatchException
                scanner.nextLine(); // Consume newline

                // Using switch statement for flow control
                switch (command) {
                    case 1: // Add New Order
                        System.out.print("Enter destination: ");
                        String destination = scanner.nextLine();
                        System.out.print("Enter items (comma-separated): ");
                        String itemsInput = scanner.nextLine();
                        List<String> items = Arrays.asList(itemsInput.split(","));
                        int newOrderId = addOrder(destination, items);
                        if (newOrderId != -1) {
                            System.out.println("Order added with ID: " + newOrderId);
                        }
                        break;

                    case 2: // Process Next Pending Order
                        DeliveryOrder processedOrder = processNextPendingOrder();
                        if (processedOrder != null) {
                            System.out.println("Processed next order: " + processedOrder);
                        } else {
                            System.out.println("No pending orders to process.");
                        }
                        break;

                    case 3: // Update Order Status
                        System.out.print("Enter Order ID to update: ");
                        int updateId = scanner.nextInt(); // Potential InputMismatchException
                        scanner.nextLine(); // Consume newline

                        System.out.println("Select new status:");
                        OrderStatus.printStatuses(); // Helper to show options
                        System.out.print("Enter status number: ");
                        int statusIndex = scanner.nextInt(); // Potential InputMismatchException
                        scanner.nextLine(); // Consume newline

                        OrderStatus newStatus = OrderStatus.getStatusByIndex(statusIndex);

                        if (newStatus == null) {
                             System.err.println("Error: Invalid status number.");
                        } else {
                            if (updateOrderStatus(updateId, newStatus)) {
                                System.out.println("Order " + updateId + " status updated to " + newStatus);
                            } else {
                                System.err.println("Error: Order with ID " + updateId + " not found.");
                            }
                        }
                        break;

                    case 4: // View Order Status
                        System.out.print("Enter Order ID to view: ");
                        int viewId = scanner.nextInt(); // Potential InputMismatchException
                        scanner.nextLine(); // Consume newline
                        if (!viewOrderStatus(viewId)) {
                             System.err.println("Error: Order with ID " + viewId + " not found.");
                        }
                        break;

                    case 5: // List All Orders
                        listAllOrders();
                        break;

                    case 6: // List Pending Orders
                        listPendingOrders();
                        break;

                    case 7: // Exit
                        System.out.println("Exiting Delivery Management System.");
                        running = false;
                        break;

                    default:
                        System.err.println("Error: Invalid command. Please try again.");
                }
            } catch (InputMismatchException e) {
                 // Catch specific input format errors for numbers
                System.err.println("Error: Invalid input format. Please enter a number.");
                scanner.nextLine(); // Consume the invalid input to prevent infinite loop
            } catch (Exception e) {
                 // Catch any other unexpected exceptions during command processing
                System.err.println("An unexpected error occurred: " + e.getMessage());
                // e.printStackTrace(); // Uncomment for debugging if needed
            }
            System.out.println(); // Add a blank line for readability
        }
    }

    private void printMenu() {
        System.out.println("--- Delivery System Menu ---");
        System.out.println("1. Add New Order");
        System.out.println("2. Process Next Pending Order");
        System.out.println("3. Update Order Status");
        System.out.println("4. View Order Status");
        System.out.println("5. List All Orders");
        System.out.println("6. List Pending Orders");
        System.out.println("7. Exit");
        System.out.println("--------------------------");
    }
}

// Main class to run the system
public class DeliverySystem {

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        DeliveryManager manager = new DeliveryManager();

        manager.runSystem(scanner); // Start the system interface

        scanner.close(); // Close the scanner when done
        System.out.println("System shut down.");
    }
}
