/*
 * Exam Question #399
 * Generated on: 2025-05-11 23:05:26
 * Generated by: Account 1
 * 
 * QUESTION:
 * **Advanced Java Programming Exam Task: Automated Support Ticket Processing System**
 * 
 * **Scenario:**
 * 
 * You are tasked with building a simplified command-line interface for an automated support ticket processing system. Incoming support tickets arrive and are placed in a queue. A processing mechanism takes the next ticket from the queue, marks it as processed, and moves it to an archive for historical tracking. The system should allow users to add new tickets, process existing ones, and view the current queue and the archive.
 * 
 * **Requirements:**
 * 
 * Implement a Java program that simulates this system. Your solution must adhere to the following specific requirements:
 * 
 * 1.  **Ticket Representation:** Create a class named `Ticket` to represent a support ticket. It should have:
 *     *   A unique integer ID, automatically assigned when a ticket is created.
 *     *   A String description of the issue.
 *     *   A String status (e.g., "New", "Processed").
 *     *   Implement proper encapsulation (private fields, public getters, potentially a setter for status).
 *     *   Override the `toString()` method for easy printing of ticket details.
 * 
 * 2.  **System Core:** Create a class named `TicketProcessingSystem` that manages the ticket flow. This class must contain:
 *     *   A `java.util.Queue` to hold incoming tickets. Use a concrete implementation like `java.util.LinkedList`.
 *     *   A `java.util.List` to hold archived (processed) tickets. Use a concrete implementation like `java.util.ArrayList`.
 *     *   Methods to:
 *         *   `addTicket(String description)`: Creates a new `Ticket` object and adds it to the incoming queue. Validate that the description is not empty.
 *         *   `processNextTicket()`: Removes the next ticket from the incoming queue, updates its status to "Processed", and adds it to the archived list. Handle the case where the queue is empty.
 *         *   `viewQueue()`: Prints the details of all tickets currently in the incoming queue without removing them.
 *         *   `viewArchive()`: Prints the details of all tickets in the archived list.
 *         *   `run()`: Contains the main application loop for user interaction.
 * 
 * 3.  **User Interface:** The `run()` method in `TicketProcessingSystem` should:
 *     *   Use a `java.util.Scanner` to read commands from the user via the console (`System.in`).
 *     *   Support the following commands (case-insensitive for the main command):
 *         *   `add <description>`: Adds a new ticket with the provided description. The description can contain spaces.
 *         *   `process`: Processes the next ticket in the queue.
 *         *   `view queue`: Displays the contents of the incoming ticket queue.
 *         *   `view archive`: Displays the contents of the archived tickets list.
 *         *   `exit`: Terminates the program.
 *     *   Use a `switch` statement to handle the different user commands.
 *     *   Provide clear prompts for user input.
 * 
 * 4.  **Output and Error Handling:**
 *     *   Use `System.out` for all normal program output (prompts, success messages, list displays).
 *     *   Use `System.err` for all error messages (e.g., invalid command usage, empty description, empty queue when processing).
 *     *   Implement input validation for commands and descriptions.
 *     *   Include a class-wide `try-catch` block (covering the main loop in `run()`) to catch any unexpected exceptions during program execution and print an informative error message to `System.err`, including the exception details. Ensure the `Scanner` is closed properly, ideally in a `finally` block.
 * 
 * 5.  **Best Practices:**
 *     *   Employ meaningful variable and method names.
 *     *   Include appropriate comments (e.g., Javadoc for classes/methods, inline comments for complex logic).
 *     *   Structure the code cleanly.
 * 
 * **Expected Output:**
 * 
 * The program should interact with the user, accepting commands and printing results or errors.
 * *   Adding a ticket should confirm the addition and show the ticket details.
 * *   Processing a ticket should confirm the action and show the processed ticket details.
 * *   Viewing lists should clearly label the output and list tickets with their ID, description, and status.
 * *   Error messages should be printed to the error stream (`System.err`).
 * *   The program should handle invalid commands or operations gracefully.
 * 
 * Your solution should be a single Java file containing both classes for submission convenience.
 *
 * EXPLANATION:
 * This solution implements the Automated Support Ticket Processing System by leveraging several core Java concepts and data structures as required.
 * 
 * 1.  **`Ticket` Class:** This class serves as the blueprint for individual tickets. It demonstrates **encapsulation** by keeping its fields (`id`, `description`, `status`) private and providing public getter methods. The static `nextId` field ensures that each new ticket created gets a unique, automatically incrementing ID. The `toString()` method is overridden for convenient display of ticket information.
 * 
 * 2.  **`TicketProcessingSystem` Class:** This is the central class managing the system's state and logic.
 *     *   **`Queue<Ticket> incomingTickets`:** A `java.util.Queue` is used, specifically implemented by `java.util.LinkedList`. The `Queue` interface is ideal here because it naturally models a waiting line where items are processed in the order they arrive (FIFO - First-In, First-Out). Methods like `add()` (or `offer()`) for adding and `poll()` for retrieving and removing the head of the queue are used.
 *     *   **`List<Ticket> archivedTickets`:** A `java.util.List` is used, specifically implemented by `java.util.ArrayList`. The `List` interface represents an ordered collection, which is suitable for storing processed tickets in the order they were archived. `ArrayList` provides a dynamic array implementation.
 *     *   **`Scanner scanner`:** A `java.util.Scanner` is used to read user input from `System.in`, fulfilling the requirement for user interaction. It's initialized in the constructor and closed in the `finally` block of the `run` method to release the system resource.
 *     *   **`addTicket()`:** Creates a new `Ticket` object after validating the description and adds it to the `incomingTickets` queue using `queue.add()`.
 *     *   **`processNextTicket()`:** Demonstrates queue usage by calling `queue.poll()`. `poll()` is preferred over `remove()` for processing queues in scenarios where the queue might be empty, as `poll()` returns `null` gracefully, whereas `remove()` would throw a `NoSuchElementException`. The processed ticket's status is updated, and it's added to the `archivedTickets` list using `list.add()`.
 *     *   **`viewQueue()` and `viewArchive()`:** These methods iterate over the respective collections (`Queue` and `List`) to display their contents using enhanced for loops. This shows how to access elements in these data structures without modifying them (for the queue view).
 * 
 * 3.  **User Interface (`run()` method):**
 *     *   The `run()` method contains the main application loop, continuously prompting the user for commands.
 *     *   **`Scanner` Input:** `scanner.nextLine()` reads the entire line of user input.
 *     *   **Command Parsing:** `commandLine.split(" ", 2)` splits the input into the command and the rest of the line (which is treated as the description for the `add` command).
 *     *   **`switch` Statement:** A `switch` statement is used to dispatch the program's logic based on the user's command (e.g., "add", "process", "view", "exit"). A nested `switch` is used within the "view" command to handle "queue" or "archive". This fulfills the `switch` requirement.
 *     *   **`System.out` and `System.err`:** `System.out.println()` is used for standard output like prompts, confirmation messages, and list displays. `System.err.println()` is used specifically for printing error conditions, such as invalid command usage, trying to process an empty queue, or providing an empty description. This clearly separates normal output from error messages.
 * 
 * 4.  **Exception Handling:**
 *     *   **Class-wide `try-catch`:** The entire `while` loop in the `run()` method is wrapped in a `try-catch(Exception e)` block. This fulfills the requirement for class-wide exception handling, catching any unexpected runtime errors that might occur during the command processing loop. The caught exception's message and stack trace are printed to `System.err`, providing debugging information.
 *     *   **`finally` Block:** A `finally` block is used after the `try-catch` to ensure that the `scanner.close()` method is called, releasing the system resource associated with the `Scanner`, regardless of whether the loop completed normally or an exception occurred.
 *     *   **Specific Error Handling:** Within methods like `addTicket` and `processNextTicket`, specific checks are performed (e.g., `description.trim().isEmpty()`, `incomingTickets.poll() == null`) to handle anticipated error conditions gracefully using `System.err`.
 * 
 * 5.  **Best Practices:** The code uses descriptive variable and method names (`incomingTickets`, `processNextTicket`, `viewArchive`). Javadoc comments are included for classes and methods, explaining their purpose. The code structure is modular, with the `Ticket` class representing the data and `TicketProcessingSystem` handling the logic and interaction. Input validation is performed for the `add` command's description.
 * 
 * This solution effectively integrates the required Java components (`Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.err`, `System.out`, `try-catch`) into a cohesive, practical application while demonstrating best practices in Java programming.
 */

import java.util.Queue;
import java.util.LinkedList;
import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;
import java.util.NoSuchElementException; // Used by Queue.remove(), though poll() is safer here

/**
 * Represents a support ticket in the processing system.
 * Encapsulates ticket details like ID, description, and status.
 */
class Ticket {
    private int id;
    private String description;
    private String status;

    // Static counter for unique ticket IDs
    private static int nextId = 1;

    /**
     * Constructs a new Ticket.
     *
     * @param description The description of the support issue.
     */
    public Ticket(String description) {
        this.id = nextId++; // Assign unique ID and increment counter
        this.description = description;
        this.status = "New"; // Initial status
    }

    // --- Getters ---
    public int getId() {
        return id;
    }

    public String getDescription() {
        return description;
    }

    public String getStatus() {
        return status;
    }

    // --- Setter ---
    public void setStatus(String status) {
        this.status = status;
    }

    /**
     * Provides a string representation of the Ticket.
     *
     * @return Formatted string detailing the ticket.
     */
    @Override
    public String toString() {
        return String.format("Ticket ID: %d, Description: '%s', Status: %s", id, description, status);
    }
}

/**
 * Manages the flow of support tickets through a queue and archive.
 * Provides a command-line interface for interaction.
 */
public class TicketProcessingSystem { // Made public for main method access
    private Queue<Ticket> incomingTickets;
    private List<Ticket> archivedTickets;
    private Scanner scanner; // Scanner for user input

    /**
     * Constructs a new TicketProcessingSystem.
     * Initializes the incoming queue and archived list.
     */
    public TicketProcessingSystem() {
        // Requirement: Use java.util.Queue (implemented by LinkedList)
        this.incomingTickets = new LinkedList<>();
        // Requirement: Use java.util.List (implemented by ArrayList)
        this.archivedTickets = new ArrayList<>();
        // Requirement: Use Scanner for user input
        this.scanner = new Scanner(System.in);
    }

    /**
     * Adds a new ticket to the incoming queue.
     * Validates that the description is not empty.
     *
     * @param description The description for the new ticket.
     */
    public void addTicket(String description) {
        // Input validation for description
        if (description == null || description.trim().isEmpty()) {
            // Requirement: Use System.err for error messages
            System.err.println("Error: Ticket description cannot be empty.");
            return;
        }
        Ticket newTicket = new Ticket(description.trim());
        incomingTickets.add(newTicket); // Add ticket to the queue
        // Requirement: Use System.out for normal output
        System.out.println("Added new ticket: " + newTicket.toString());
    }

    /**
     * Processes the next ticket from the incoming queue.
     * Removes it from the queue, updates status, and adds to archive.
     * Handles the case where the queue is empty.
     */
    public void processNextTicket() {
        // Retrieve and remove the head of the queue. poll() returns null if queue is empty.
        Ticket ticketToProcess = incomingTickets.poll();

        if (ticketToProcess == null) {
            // Requirement: Use System.err for error messages
            System.err.println("Error: No tickets in the incoming queue to process.");
        } else {
            // Simulate processing by changing status
            ticketToProcess.setStatus("Processed");
            archivedTickets.add(ticketToProcess); // Add to the archived list
            // Requirement: Use System.out for normal output
            System.out.println("Processed ticket: " + ticketToProcess.toString());
        }
    }

    /**
     * Displays all tickets currently in the incoming queue.
     */
    public void viewQueue() {
        // Requirement: Use System.out for normal output
        System.out.println("\n--- Incoming Ticket Queue ---");
        if (incomingTickets.isEmpty()) {
            System.out.println("Queue is empty.");
        } else {
            // Iterate through the queue without removing elements
            int count = 1;
            for (Ticket ticket : incomingTickets) {
                System.out.println(count++ + ". " + ticket.toString());
            }
        }
        System.out.println("-----------------------------");
    }

    /**
     * Displays all tickets currently in the archived list.
     */
    public void viewArchive() {
        // Requirement: Use System.out for normal output
        System.out.println("\n--- Archived Tickets ---");
        if (archivedTickets.isEmpty()) {
            System.out.println("Archive is empty.");
        } else {
            // Iterate through the list
            int count = 1;
            for (Ticket ticket : archivedTickets) {
                System.out.println(count++ + ". " + ticket.toString());
            }
        }
        System.out.println("------------------------");
    }

    /**
     * Runs the main command-line interaction loop for the system.
     * Includes class-wide exception handling.
     */
    public void run() {
        System.out.println("Support Ticket Processing System Started.");
        System.out.println("Commands: add <description>, process, view queue, view archive, exit");

        boolean running = true;

        // Requirement: Class-wide exception handling with try-catch
        try {
            while (running) {
                System.out.print("\nEnter command: ");
                String commandLine = scanner.nextLine().trim();

                if (commandLine.isEmpty()) {
                    continue; // Ignore empty input lines
                }

                // Split command and potential arguments (description)
                String[] parts = commandLine.split(" ", 2);
                String command = parts[0].toLowerCase(); // Case-insensitive command

                // Requirement: Use switch statement for flow control
                switch (command) {
                    case "add":
                        if (parts.length < 2) {
                            // Requirement: Use System.err for error messages
                            System.err.println("Usage: add <description>");
                        } else {
                            addTicket(parts[1]); // Pass the rest as description
                        }
                        break; // Exit switch case
                    case "process":
                        processNextTicket();
                        break; // Exit switch case
                    case "view":
                        if (parts.length < 2) {
                            // Requirement: Use System.err for error messages
                            System.err.println("Usage: view queue or view archive");
                        } else {
                            String viewType = parts[1].toLowerCase();
                            // Nested switch for view type
                            switch (viewType) {
                                case "queue":
                                    viewQueue();
                                    break; // Exit inner switch case
                                case "archive":
                                    viewArchive();
                                    break; // Exit inner switch case
                                default:
                                    // Requirement: Use System.err for error messages
                                    System.err.println("Unknown view type. Usage: view queue or view archive");
                                    break; // Exit inner switch case
                            }
                        }
                        break; // Exit switch case
                    case "exit":
                        System.out.println("Exiting system. Goodbye!");
                        running = false; // Set flag to exit loop
                        break; // Exit switch case
                    default:
                        // Requirement: Use System.err for error messages
                        System.err.println("Unknown command: " + command);
                        System.out.println("Commands: add <description>, process, view queue, view archive, exit");
                        break; // Exit switch case
                }
            }
        } catch (Exception e) {
            // Catch any unexpected exception during the program's main loop
            // Requirement: Use System.err for error messages in catch
            System.err.println("An unexpected error occurred during system operation: " + e.getMessage());
            e.printStackTrace(System.err); // Print stack trace to error stream for debugging
        } finally {
            // Ensure the scanner resource is closed regardless of exceptions
            if (scanner != null) {
                scanner.close();
                System.out.println("Scanner resource closed.");
            }
        }
    }

    /**
     * Main method to start the Ticket Processing System.
     *
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        TicketProcessingSystem system = new TicketProcessingSystem();
        system.run(); // Start the interaction loop
    }
}
