/*
 * Exam Question #116
 * Generated on: 2025-05-11 22:16:40
 * Generated by: Account 5
 * 
 * QUESTION:
 * **Subject:** Advanced Java Programming
 * **Task Title:** Priority Task Management System
 * 
 * **Problem Description:**
 * 
 * Design and implement a command-line application for a simple Priority Task Management System. The system should allow users to add new tasks with descriptions and priorities, process the next pending task, and view lists of pending and completed tasks.
 * 
 * Your solution must demonstrate a strong understanding of core Java concepts including collections, input/output, control flow, object-oriented principles, and exception handling.
 * 
 * **Specific Requirements:**
 * 
 * 1.  **Task Representation:** Create a `Task` class with private fields for a unique task ID (integer), description (String), priority (String, e.g., "High", "Medium", "Low"), and status (String, initially "Pending", changes to "Completed" upon processing). Include a constructor, getters for all fields, and a method to mark the task as completed.
 * 2.  **System Core:** Create a `TaskProcessorSystem` class to manage the tasks.
 *     *   It must maintain two collections:
 *         *   A `java.util.Queue` to hold tasks that are pending processing. Tasks should be processed in the order they were added (FIFO).
 *         *   A `java.util.List` (specifically using `java.util.ArrayList` as the implementation) to store tasks that have been completed.
 *     *   Include methods for:
 *         *   `addTask(String description, String priority)`: Creates a new `Task` object and adds it to the pending tasks queue. Assigns a unique ID.
 *         *   `processNextTask()`: Removes the next task from the pending queue, updates its status to "Completed", and adds it to the completed tasks list. Should handle the case where the pending queue is empty.
 *         *   `getPendingTasks()`: Returns a `java.util.List` view of the tasks currently in the pending queue (order matters).
 *         *   `getCompletedTasks()`: Returns the `java.util.List` of completed tasks.
 * 3.  **User Interface:** Implement a command-line interface using `java.util.Scanner`. The system should present a menu of options to the user:
 *     *   1. Add New Task
 *     *   2. Process Next Task
 *     *   3. View Pending Tasks
 *     *   4. View Completed Tasks
 *     *   5. Exit
 *     *   Use a `switch` statement to handle the user's choice.
 * 4.  **Input Handling & Validation:**
 *     *   Use `Scanner` to read user input for menu choices and task details.
 *     *   Validate user input where necessary (e.g., ensure task description is not empty).
 *     *   Handle potential `Scanner` input issues or other runtime errors gracefully.
 * 5.  **Output & Error Messages:**
 *     *   Use `System.out` for normal program output (menu, task details, success messages).
 *     *   Use `System.err` to display error messages (e.g., invalid input, attempting to process when no tasks are pending).
 * 6.  **Exception Handling:** Implement class-wide exception handling using `try-catch` blocks within the main application loop or the `TaskProcessorSystem`'s run method to catch and report unexpected errors.
 * 7.  **Best Practices:**
 *     *   Apply proper encapsulation (private fields, public getters/methods).
 *     *   Use meaningful names for variables, methods, and classes.
 *     *   Include appropriate comments and basic documentation (e.g., Javadoc stubs or inline comments).
 *     *   Maintain a clean code structure.
 * 
 * **Expected Output:**
 * 
 * The program should run interactively, presenting a menu, accepting user input, and displaying task information or status updates based on the chosen action. Error messages should be clearly distinguishable using `System.err`. Example interactions might look like:
 * 
 * ```
 * --- Task Management System ---
 * Choose an option:
 * 1. Add New Task
 * 2. Process Next Task
 * 3. View Pending Tasks
 * 4. View Completed Tasks
 * 5. Exit
 * Enter choice: 1
 * Enter task description: Implement Scanner input
 * Enter task priority (High, Medium, Low): High
 * Task added with ID: 1
 * 
 * --- Task Management System ---
 * ...
 * Enter choice: 3
 * --- Pending Tasks ---
 * ID: 1, Description: Implement Scanner input, Priority: High, Status: Pending
 * ---------------------
 * 
 * --- Task Management System ---
 * ...
 * Enter choice: 2
 * Processing task ID: 1
 * Task "Implement Scanner input" completed.
 * 
 * --- Task Management System ---
 * ...
 * Enter choice: 3
 * --- Pending Tasks ---
 * (No pending tasks)
 * ---------------------
 * 
 * --- Task Management System ---
 * ...
 * Enter choice: 4
 * --- Completed Tasks ---
 * ID: 1, Description: Implement Scanner input, Priority: High, Status: Completed
 * ---------------------
 * 
 * --- Task Management System ---
 * ...
 * Enter choice: 5
 * Exiting Task Management System.
 * ```
 * 
 * Attempting to process with an empty queue should result in an error message on `System.err`.
 * 
 * **Evaluation Criteria:**
 * 
 * *   Correct usage of `Queue`, `ArrayList`, and `List`.
 * *   Effective use of `Scanner`, `switch`, `System.out`, and `System.err`.
 * *   Proper implementation of the `Task` and `TaskProcessorSystem` classes with encapsulation.
 * *   Robust input validation and error handling using `try-catch`.
 * *   Adherence to best coding practices (naming, comments, structure).
 * *   Correct logic for adding, processing, and viewing tasks.
 *
 * EXPLANATION:
 * This solution implements a simple command-line Task Management System as required, demonstrating the use of all specified Java components and adhering to best practices.
 * 
 * 1.  **`Task` Class:** This class represents a single task. It follows encapsulation principles with private fields (`id`, `description`, `priority`, `status`) and public getter methods. The `markAsCompleted()` method modifies the internal state, and `toString()` provides a convenient representation for printing.
 * 
 * 2.  **`TaskProcessorSystem` Class:** This is the core class managing the system's state and operations.
 *     *   **Collections:** It uses a `java.util.Queue<Task>` (`pendingTasks`) implemented by `java.util.LinkedList` to store tasks awaiting processing. The `Queue` interface ensures FIFO behavior when using methods like `offer()` (to add) and `poll()` (to remove and retrieve). It uses a `java.util.List<Task>` (`completedTasks`) implemented by `java.util.ArrayList` to store tasks once they are finished. The `List` interface is used for type hinting and flexibility.
 *     *   **Methods:**
 *         *   `addTask`: Creates a new `Task` object, assigns it a unique ID using the `nextTaskId` counter, performs basic validation on input, and adds the task to the `pendingTasks` queue using `offer()`.
 *         *   `processNextTask`: Retrieves and removes the head of the `pendingTasks` queue using `poll()`. If `poll()` returns `null`, it means the queue was empty, and an error message is printed to `System.err`. Otherwise, the task's status is updated, and it's added to the `completedTasks` list.
 *         *   `getPendingTasks`: Returns a `List` representation of the current pending tasks. It creates a *new* `ArrayList` from the queue's elements to avoid exposing the internal queue directly, preserving the queue's integrity and order.
 *         *   `getCompletedTasks`: Returns the `completedTasks` `ArrayList`.
 *         *   `run`: Contains the main application loop. It uses a `Scanner` to read user input. The loop continues until the user chooses to exit.
 * 
 * 3.  **User Interface & Control Flow:**
 *     *   The `run` method displays a menu using `System.out`.
 *     *   It reads the user's numerical choice using `scanner.nextLine()` and `Integer.parseInt()`.
 *     *   A `switch` statement is used to direct execution based on the parsed choice, calling the appropriate `TaskProcessorSystem` methods.
 *     *   The `default` case of the `switch` handles invalid numerical input, printing an error to `System.err`.
 * 
 * 4.  **Input Handling & Validation:**
 *     *   `Scanner` is used throughout the `run` method to get user input.
 *     *   Basic validation is performed in `addTask` to ensure the description is not empty.
 *     *   A `try-catch(NumberFormatException)` block is used around `Integer.parseInt()` within the loop to handle cases where the user enters non-numeric input for the menu choice.
 * 
 * 5.  **Output & Error Messages:**
 *     *   `System.out.println()` is used for displaying the menu, task details, and success messages.
 *     *   `System.err.println()` is used specifically for error conditions, such as invalid menu input, empty task description, or attempting to process tasks when none are pending.
 * 
 * 6.  **Exception Handling:**
 *     *   A broad `try-catch(Exception e)` block wraps the main `while` loop in the `run` method. This provides a class-wide safety net to catch any unexpected exceptions that might occur during the execution of the main interactive logic, preventing the program from crashing abruptly. It prints the error message and stack trace to `System.err`.
 *     *   A `finally` block is used to ensure the `Scanner` is closed, releasing system resources, regardless of whether the loop finishes normally or an exception occurs.
 * 
 * 7.  **Best Practices:**
 *     *   Encapsulation is used in both `Task` and `TaskProcessorSystem`.
 *     *   Variables and methods have descriptive names (`pendingTasks`, `processNextTask`, `addTask`, etc.).
 *     *   Basic comments explain the purpose of classes, methods, and key code sections.
 *     *   The code is structured into logical classes (`Task`, `TaskProcessorSystem`).
 *     *   Input validation and error handling are present.
 * 
 * This solution effectively integrates the required Java components within a practical, interactive application, demonstrating the ability to handle collections, user input, control flow, and exceptions in a structured manner.
 */

import java.util.Queue;
import java.util.LinkedList; // Common Queue implementation
import java.util.List;
import java.util.ArrayList;
import java.util.Scanner;

/**
 * Represents a single task in the system.
 */
class Task {
    private int id;
    private String description;
    private String priority; // e.g., "High", "Medium", "Low"
    private String status;   // e.g., "Pending", "Completed"

    /**
     * Constructs a new Task.
     * @param id The unique ID for the task.
     * @param description The description of the task.
     * @param priority The priority level of the task.
     */
    public Task(int id, String description, String priority) {
        this.id = id;
        this.description = description;
        this.priority = priority;
        this.status = "Pending"; // Tasks start as Pending
    }

    // --- Getters ---
    public int getId() {
        return id;
    }

    public String getDescription() {
        return description;
    }

    public String getPriority() {
        return priority;
    }

    public String getStatus() {
        return status;
    }

    /**
     * Marks the task as completed.
     */
    public void markAsCompleted() {
        this.status = "Completed";
    }

    @Override
    public String toString() {
        return String.format("ID: %d, Description: %s, Priority: %s, Status: %s",
                             id, description, priority, status);
    }
}

/**
 * Manages a collection of tasks, supporting adding, processing, and viewing.
 */
class TaskProcessorSystem {
    private Queue<Task> pendingTasks; // Tasks waiting to be processed (FIFO)
    private List<Task> completedTasks; // Tasks that have been processed
    private int nextTaskId;          // Counter for unique task IDs

    /**
     * Constructs a new TaskProcessorSystem.
     */
    public TaskProcessorSystem() {
        // Using LinkedList as a Queue implementation
        this.pendingTasks = new LinkedList<>();
        // Using ArrayList as a List implementation
        this.completedTasks = new ArrayList<>();
        this.nextTaskId = 1; // Start IDs from 1
    }

    /**
     * Adds a new task to the pending queue.
     * @param description The description of the task.
     * @param priority The priority level of the task.
     */
    public void addTask(String description, String priority) {
        if (description == null || description.trim().isEmpty()) {
            System.err.println("Error: Task description cannot be empty.");
            return;
        }
        // Basic validation for priority, could be more robust
        if (priority == null || priority.trim().isEmpty()) {
             System.err.println("Warning: Priority is empty, using 'Unknown'.");
             priority = "Unknown";
        }

        Task newTask = new Task(nextTaskId++, description.trim(), priority.trim());
        pendingTasks.offer(newTask); // offer() is preferred over add() for capacity-constrained queues, but works fine here
        System.out.println("Task added with ID: " + newTask.getId());
    }

    /**
     * Processes the next task in the pending queue.
     * Removes it from pending, marks as completed, and adds to completed list.
     */
    public void processNextTask() {
        Task taskToProcess = pendingTasks.poll(); // poll() returns null if queue is empty

        if (taskToProcess == null) {
            System.err.println("No pending tasks to process.");
        } else {
            taskToProcess.markAsCompleted();
            completedTasks.add(taskToProcess);
            System.out.println("Processing task ID: " + taskToProcess.getId());
            System.out.println("Task \"" + taskToProcess.getDescription() + "\" completed.");
        }
    }

    /**
     * Returns a list of tasks currently in the pending queue.
     * Note: This returns a new list to avoid external modification of the internal queue.
     * The order reflects the processing order (FIFO).
     * @return A List of pending tasks.
     */
    public List<Task> getPendingTasks() {
        // Create a new ArrayList from the elements in the queue
        // This preserves the order of the queue elements
        return new ArrayList<>(pendingTasks);
    }

    /**
     * Returns a list of tasks that have been completed.
     * @return A List of completed tasks.
     */
    public List<Task> getCompletedTasks() {
        return completedTasks; // It's acceptable to return the internal list here,
                              // as modification by external code is less likely to break the system logic
                              // compared to modifying the pending queue directly.
                              // For absolute safety, one might return a copy: new ArrayList<>(completedTasks);
    }

    /**
     * Runs the main interactive loop for the task management system.
     * Handles user input, menu display, and calls system operations.
     */
    public void run() {
        Scanner scanner = new Scanner(System.in);
        boolean running = true;

        // Class-wide exception handling for the main loop
        try {
            while (running) {
                printMenu();
                System.out.print("Enter choice: ");

                if (!scanner.hasNextLine()) {
                    System.err.println("No more input available. Exiting.");
                    break; // Exit loop if no more input (e.g., EOF)
                }

                String input = scanner.nextLine();
                int choice;

                try {
                    choice = Integer.parseInt(input);
                } catch (NumberFormatException e) {
                    System.err.println("Invalid input. Please enter a number.");
                    continue; // Skip to next iteration
                }

                // Using a switch statement for command processing
                switch (choice) {
                    case 1: // Add New Task
                        System.out.print("Enter task description: ");
                        String description = scanner.nextLine();
                        System.out.print("Enter task priority (e.g., High, Medium, Low): ");
                        String priority = scanner.nextLine();
                        addTask(description, priority);
                        break;

                    case 2: // Process Next Task
                        processNextTask();
                        break;

                    case 3: // View Pending Tasks
                        List<Task> pending = getPendingTasks();
                        System.out.println("--- Pending Tasks ---");
                        if (pending.isEmpty()) {
                            System.out.println("(No pending tasks)");
                        } else {
                            for (Task task : pending) {
                                System.out.println(task);
                            }
                        }
                        System.out.println("---------------------");
                        break;

                    case 4: // View Completed Tasks
                        List<Task> completed = getCompletedTasks();
                        System.out.println("--- Completed Tasks ---");
                        if (completed.isEmpty()) {
                            System.out.println("(No completed tasks)");
                        } else {
                            for (Task task : completed) {
                                System.out.println(task);
                            }
                        }
                        System.out.println("---------------------");
                        break;

                    case 5: // Exit
                        running = false;
                        System.out.println("Exiting Task Management System.");
                        break;

                    default: // Invalid choice
                        System.err.println("Invalid choice. Please enter a number between 1 and 5.");
                }
                System.out.println(); // Add a newline for better formatting between actions
            }
        } catch (Exception e) {
            // Catch any unexpected runtime exceptions during the main loop execution
            System.err.println("An unexpected error occurred: " + e.getMessage());
            e.printStackTrace(System.err); // Print stack trace to error stream
        } finally {
            // Ensure scanner is closed even if an exception occurs
            scanner.close();
            System.out.println("Scanner closed.");
        }
    }

    /**
     * Prints the main menu options to the console.
     */
    private void printMenu() {
        System.out.println("--- Task Management System ---");
        System.out.println("Choose an option:");
        System.out.println("1. Add New Task");
        System.out.println("2. Process Next Task");
        System.out.println("3. View Pending Tasks");
        System.out.println("4. View Completed Tasks");
        System.out.println("5. Exit");
    }

    /**
     * Main method to start the application.
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        TaskProcessorSystem system = new TaskProcessorSystem();
        system.run();
    }
}
