/*
 * Exam Question #528
 * Generated on: 2025-05-11 23:25:02
 * Generated by: Account 2
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Simplified Task Management System
 * 
 * **Objective:** Design and implement a command-line application for managing tasks using core Java data structures and control flow mechanisms.
 * 
 * **Scenario:** You are building a basic task management tool for a small team. Tasks are added to a list and then processed sequentially from a queue.
 * 
 * **Requirements:**
 * 
 * 1.  **Task Representation:** Create a class named `Task` with the following private attributes:
 *     *   `taskId` (int): A unique integer identifier for the task.
 *     *   `description` (String): A textual description of the task.
 *     *   `priority` (String): Represents the task's priority, accepting "HIGH", "MEDIUM", or "LOW". Input should be case-insensitive but stored as uppercase. Implement basic validation: if an invalid priority string is provided during construction, print a warning to `System.err` and default the priority to "MEDIUM".
 *     *   `status` (String): Represents the current status of the task, accepting "PENDING", "IN_PROGRESS", or "COMPLETED". New tasks must be initialized with the status "PENDING". Implement basic validation in the setter: if an invalid status string is provided, print a warning to `System.err` and do not change the status.
 *     *   Include a public constructor to initialize `description` and `priority` (automatically setting `status` to "PENDING"). The `taskId` should be assigned by the management system.
 *     *   Provide public getter methods for all attributes (`getTaskId`, `getDescription`, `getPriority`, `getStatus`).
 *     *   Provide a public setter method `setStatus(String status)` to update the task's status with validation.
 *     *   Override the `toString()` method to provide a user-friendly string representation of the task (e.g., "Task [ID=1, Desc='Fix bug', Priority=HIGH, Status=PENDING]").
 * 
 * 2.  **Task Management System:** Create a class named `TaskManagementSystem` responsible for managing the tasks. It must contain:
 *     *   A `private Queue<Task>` named `processingQueue` to hold tasks that are currently awaiting processing. Use `java.util.LinkedList` as the concrete implementation.
 *     *   A `private List<Task>` named `allTasks` to store a record of *all* tasks ever created in the system. Use `java.util.ArrayList` as the concrete implementation.
 *     *   A `private int` variable `nextTaskId` initialized to 1, used to generate unique IDs for new tasks.
 *     *   A `private Scanner` field to handle user input from `System.in`.
 * 
 * 3.  **Functionality (Implement as public methods in `TaskManagementSystem`):**
 *     *   `addTask()`: Prompts the user to enter the task description and priority. Creates a new `Task` object using the current `nextTaskId`, adds the task to the `allTasks` list, and adds the task to the `processingQueue`. Increment `nextTaskId` after creating the task. Use `System.out` for prompts and success messages.
 *     *   `processNextTask()`: Removes the task at the head of the `processingQueue`. If a task was successfully removed, find that task in the `allTasks` list (using its `taskId`) and update its status to "COMPLETED" using the task's `setStatus` method. Print a message to `System.out` indicating which task was completed. If the `processingQueue` was empty, print a message to `System.out` stating that no tasks were available for processing.
 *     *   `viewAllTasks()`: Iterate through the `allTasks` list and print the `toString()` representation of each task to `System.out`. If the list is empty, print a message indicating that.
 *     *   `viewProcessingQueue()`: Iterate through the `processingQueue` and print the `toString()` representation of each task to `System.out`. If the queue is empty, print a message indicating that.
 *     *   `run()`: This is the main application method. It should:
 *         *   Enter a loop that continues until the user chooses to exit.
 *         *   Inside the loop, display a menu of options (e.g., 1. Add Task, 2. Process Next, 3. View All, 4. View Queue, 5. Exit) using `System.out`.
 *         *   Prompt the user for their choice using `System.out` and read the input using the `Scanner`.
 *         *   Implement a `try-catch` block around the input reading and the subsequent `switch` statement.
 *             *   Catch `InputMismatchException` if the user enters non-integer input for the menu choice. Print an error message to `System.err` and consume the invalid input to prevent an infinite loop.
 *             *   Include a general `catch (Exception e)` block to handle any other unexpected errors, printing an error message including `e.getMessage()` to `System.err`.
 *         *   Use a `switch` statement on the user's valid integer choice to call the appropriate method (`addTask`, `processNextTask`, `viewAllTasks`, `viewProcessingQueue`).
 *         *   Include a `default` case in the `switch` for invalid integer choices (outside the menu range), printing an error message to `System.err`.
 *         *   For the "Exit" option, terminate the loop and print an exit message to `System.out`.
 *         *   Ensure the `Scanner` is closed when the application exits.
 * 
 * 4.  **Main Class:** Create a separate class (e.g., `ExamTaskManagement`) with a `main` method to create an instance of `TaskManagementSystem` and call its `run()` method to start the application.
 * 
 * 5.  **General Requirements:**
 *     *   Adhere to Java coding conventions.
 *     *   Use meaningful variable and method names.
 *     *   Include basic comments explaining the purpose of classes and key methods.
 *     *   Ensure proper encapsulation (private fields, public methods where necessary).
 *     *   Use `System.out` for all standard program output and `System.err` for all error messages or warnings.
 * 
 * **Expected Interaction (Example):**
 * 
 * ```
 * --- Task Management System ---
 * 
 * Select an option:
 * 1. Add New Task
 * 2. Process Next Task
 * 3. View All Tasks
 * 4. View Processing Queue
 * 5. Exit
 * Enter your choice: 1
 * 
 * --- Add New Task ---
 * Enter task description: Implement login feature
 * Enter priority (HIGH, MEDIUM, LOW): HIGH
 * Task added: Task [ID=1, Desc='Implement login feature', Priority=HIGH, Status=PENDING]
 * 
 * Select an option:
 * ... menu ...
 * Enter your choice: 1
 * 
 * --- Add New Task ---
 * Enter task description: Write unit tests
 * Enter priority (HIGH, MEDIUM, LOW): Low
 * Task added: Task [ID=2, Desc='Write unit tests', Priority=LOW, Status=PENDING]
 * 
 * Select an option:
 * ... menu ...
 * Enter your choice: 4
 * 
 * --- Tasks in Processing Queue ---
 * Task [ID=1, Desc='Implement login feature', Priority=HIGH, Status=PENDING]
 * Task [ID=2, Desc='Write unit tests', Priority=LOW, Status=PENDING]
 * 
 * Select an option:
 * ... menu ...
 * Enter your choice: 2
 * 
 * --- Process Next Task ---
 * Task completed: Task [ID=1, Desc='Implement login feature', Priority=HIGH, Status=COMPLETED]
 * 
 * Select an option:
 * ... menu ...
 * Enter your choice: 4
 * 
 * --- Tasks in Processing Queue ---
 * Task [ID=2, Desc='Write unit tests', Priority=LOW, Status=PENDING]
 * 
 * Select an option:
 * ... menu ...
 * Enter your choice: 3
 * 
 * --- All Tasks ---
 * Task [ID=1, Desc='Implement login feature', Priority=HIGH, Status=COMPLETED]
 * Task [ID=2, Desc='Write unit tests', Priority=LOW, Status=PENDING]
 * 
 * Select an option:
 * ... menu ...
 * Enter your choice: invalid input
 * Invalid input. Please enter a number.
 * 
 * Select an option:
 * ... menu ...
 * Enter your choice: 9
 * Invalid choice. Please enter a number between 1 and 5.
 * 
 * Select an option:
 * ... menu ...
 * Enter your choice: 5
 * Exiting Task Management System.
 * ```
 * 
 * **Evaluation Criteria:**
 * 
 * *   Correct implementation of the `Task` class with encapsulation, validation, and `toString()`.
 * *   Correct usage of `Queue` (specifically `LinkedList`) and `List` (`ArrayList`) in `TaskManagementSystem`.
 * *   Correct implementation of `addTask`, `processNextTask`, `viewAllTasks`, and `viewProcessingQueue`.
 * *   Proper implementation of the `run` method including menu display, `Scanner` usage, `switch` statement, main loop control, and `Scanner` closing.
 * *   Effective use of `try-catch` for handling `InputMismatchException` and general exceptions in the `run` method.
 * *   Correct and consistent use of `System.out` and `System.err`.
 * *   Adherence to best practices (naming, comments, encapsulation).
 *
 * EXPLANATION:
 * This solution implements a simplified Task Management System demonstrating the required Java concepts.
 * 
 * 1.  **`Task` Class:**
 *     *   Represents a single task with `taskId`, `description`, `priority`, and `status`.
 *     *   Uses private fields and public getters/setters (`setStatus`) to enforce encapsulation.
 *     *   The constructor assigns the ID and description, performs basic case-insensitive validation on the input `priority` string, defaulting to "MEDIUM" and printing a warning to `System.err` if invalid. Status is initialized to "PENDING".
 *     *   The `setStatus` method performs basic validation on the input `status` string, printing a warning to `System.err` if invalid and preventing the status change.
 *     *   The `toString()` method provides a clear string representation, useful for printing task details.
 * 
 * 2.  **`TaskManagementSystem` Class:**
 *     *   Manages the task lifecycle.
 *     *   `processingQueue`: Declared as `Queue<Task>` and instantiated as `LinkedList<Task>`. This structure is used to hold tasks waiting to be processed in a First-In, First-Out (FIFO) manner, fulfilling the `Queue` and `List` interface requirements (since `LinkedList` implements `List` as well, though it's used here primarily for its `Queue` behavior).
 *     *   `allTasks`: Declared as `List<Task>` and instantiated as `ArrayList<Task>`. This list serves as a complete historical record of all tasks created, fulfilling the `ArrayList` and `List` interface requirements.
 *     *   `nextTaskId`: A simple counter to ensure unique task IDs.
 *     *   `scanner`: A `Scanner` object for reading user input, initialized in the `run` method.
 * 
 * 3.  **Functionality Methods:**
 *     *   `addTask()`: Prompts for description and priority, creates a new `Task` object with a unique ID, adds it to both `allTasks` and `processingQueue`, and increments `nextTaskId`.
 *     *   `processNextTask()`: Uses `processingQueue.poll()` to get and remove the next task from the queue. If a task is returned (queue was not empty), it then iterates through `allTasks` to find the corresponding task by ID and updates its status to "COMPLETED" using the `Task` object's `setStatus` method. Messages are printed to `System.out`.
 *     *   `viewAllTasks()`: Iterates through the `allTasks` `ArrayList` and prints each task's details using `System.out`.
 *     *   `viewProcessingQueue()`: Iterates through the `processingQueue` `LinkedList` (which maintains insertion order) and prints each task's details using `System.out`. Note that iterating the queue does not remove elements; `poll()` is used for removal.
 * 
 * 4.  **`run()` Method:**
 *     *   Contains the main application loop (`while(running)`).
 *     *   Displays the menu using `System.out`.
 *     *   Uses `scanner.nextInt()` to read the menu choice, followed by `scanner.nextLine()` to consume the leftover newline character, which is crucial when mixing `nextInt()` and `nextLine()`.
 *     *   A `switch` statement handles the different integer menu choices, calling the appropriate methods. A `default` case catches invalid integer inputs.
 *     *   A `try-catch` block wraps the input reading and the `switch` statement.
 *         *   `catch (InputMismatchException e)` specifically handles cases where the user enters non-integer input for the menu choice, prints an error to `System.err`, and consumes the invalid input using `scanner.nextLine()` to prevent an infinite loop.
 *         *   `catch (Exception e)` acts as a general catch-all for any other unexpected runtime exceptions that might occur within the loop, printing an error message to `System.err`.
 *     *   The loop terminates when the user enters '5', setting the `running` flag to `false`.
 *     *   The `Scanner` is closed when the loop finishes.
 * 
 * 5.  **`ExamTaskManagement` Class:**
 *     *   A simple class containing the `main` method, which serves as the entry point to create and run the `TaskManagementSystem`.
 * 
 * **Advanced Concepts Demonstrated:**
 * 
 * *   **Object-Oriented Programming:** Using classes (`Task`, `TaskManagementSystem`), objects, encapsulation (private fields, public methods), and method calls.
 * *   **Data Structures:** Practical application of `Queue` (FIFO behavior for processing) and `List`/`ArrayList` (storage and retrieval).
 * *   **Control Flow:** Use of `while` loop for the main application cycle, `switch` statement for menu handling, and `for` loops for iterating through lists/queues.
 * *   **Input/Output:** Using `Scanner` for user input, `System.out` for standard output, and `System.err` for error messages, demonstrating appropriate channel usage.
 * *   **Exception Handling:** Implementing `try-catch` blocks for anticipated errors (`InputMismatchException`) and unexpected errors (`Exception`), providing robustness to the application's main loop.
 * *   **Input Validation:** Basic validation implemented in the `Task` constructor and `setStatus` method, and validation of menu input type and range in the `run` method.
 * 
 * This solution integrates multiple core Java concepts into a cohesive, albeit simplified, real-world-like application, fulfilling all specified requirements and demonstrating best practices suitable for a challenging exam question.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.InputMismatchException;

/**
 * Represents a single task in the management system.
 */
class Task {
    private int taskId;
    private String description;
    private String priority; // HIGH, MEDIUM, LOW
    private String status; // PENDING, IN_PROGRESS, COMPLETED

    /**
     * Constructs a new Task object.
     * @param taskId The unique ID for the task.
     * @param description A brief description of the task.
     * @param priority The priority level (HIGH, MEDIUM, LOW).
     */
    public Task(int taskId, String description, String priority) {
        this.taskId = taskId;
        this.description = description;
        // Basic validation for priority, default to MEDIUM if invalid
        if (priority != null && ("HIGH".equalsIgnoreCase(priority) || "MEDIUM".equalsIgnoreCase(priority) || "LOW".equalsIgnoreCase(priority))) {
            this.priority = priority.toUpperCase();
        } else {
            System.err.println("Warning: Invalid priority '" + priority + "' for Task ID " + taskId + ". Defaulting to MEDIUM.");
            this.priority = "MEDIUM";
        }
        this.status = "PENDING"; // New tasks start as PENDING
    }

    // --- Getters ---
    public int getTaskId() {
        return taskId;
    }

    public String getDescription() {
        return description;
    }

    public String getPriority() {
        return priority;
    }

    public String getStatus() {
        return status;
    }

    // --- Setter for status ---
    /**
     * Sets the status of the task.
     * @param status The new status (PENDING, IN_PROGRESS, COMPLETED).
     */
    public void setStatus(String status) {
        // Basic validation for status
        if (status != null && ("PENDING".equalsIgnoreCase(status) || "IN_PROGRESS".equalsIgnoreCase(status) || "COMPLETED".equalsIgnoreCase(status))) {
            this.status = status.toUpperCase();
        } else {
             System.err.println("Warning: Attempted to set invalid status '" + status + "' for Task ID " + taskId + ". Status remains: " + this.status);
        }
    }

    /**
     * Provides a string representation of the task.
     * @return Formatted string detailing the task.
     */
    @Override
    public String toString() {
        return "Task [ID=" + taskId + ", Desc='" + description + "', Priority=" + priority + ", Status=" + status + "]";
    }
}

/**
 * Manages a collection of tasks using a queue for processing
 * and a list for historical records.
 */
class TaskManagementSystem {
    // Queue for tasks awaiting processing (FIFO order)
    private Queue<Task> processingQueue = new LinkedList<>();
    // List to keep track of all tasks ever created
    private List<Task> allTasks = new ArrayList<>();
    // Counter for generating unique task IDs
    private int nextTaskId = 1;
    // Scanner for user input
    private Scanner scanner; // Initialized in run()

    /**
     * Adds a new task to the system based on user input.
     * The task is added to the master list and the processing queue.
     */
    public void addTask() {
        System.out.println("\n--- Add New Task ---");
        System.out.print("Enter task description: ");
        String description = scanner.nextLine();

        System.out.print("Enter priority (HIGH, MEDIUM, LOW): ");
        String priority = scanner.nextLine();

        // Create the task - validation for priority happens in Task constructor
        Task newTask = new Task(nextTaskId++, description, priority);

        // Add to the master list of all tasks
        allTasks.add(newTask);

        // Add to the queue for processing
        processingQueue.offer(newTask); // offer is generally preferred over add for queues

        System.out.println("Task added: " + newTask.toString());
    }

    /**
     * Processes the next task in the queue.
     * Removes the task from the queue and updates its status to COMPLETED in the master list.
     */
    public void processNextTask() {
        System.out.println("\n--- Process Next Task ---");
        // poll() retrieves and removes the head of the queue, returns null if queue is empty
        Task taskToProcess = processingQueue.poll();

        if (taskToProcess != null) {
            // Find the task in the allTasks list to update its status
            // A simple linear search is acceptable for this complexity level
            boolean found = false;
            for (Task task : allTasks) {
                if (task.getTaskId() == taskToProcess.getTaskId()) {
                    task.setStatus("COMPLETED"); // Update status in the master list
                    System.out.println("Task completed: " + task.toString());
                    found = true;
                    break; // Found the task, no need to continue searching
                }
            }
            // This check adds robustness, though theoretically the task should always be found
            if (!found) {
                 System.err.println("Error: Completed task ID " + taskToProcess.getTaskId() + " was polled but not found in master list!");
            }

        } else {
            System.out.println("Processing queue is empty. No tasks to process.");
        }
    }

    /**
     * Displays all tasks ever created in the system.
     */
    public void viewAllTasks() {
        System.out.println("\n--- All Tasks ---");
        if (allTasks.isEmpty()) {
            System.out.println("No tasks have been added yet.");
        } else {
            // Iterate through the ArrayList and print each task
            for (Task task : allTasks) {
                System.out.println(task.toString());
            }
        }
    }

    /**
     * Displays tasks currently present in the processing queue.
     */
    public void viewProcessingQueue() {
        System.out.println("\n--- Tasks in Processing Queue ---");
        if (processingQueue.isEmpty()) {
            System.out.println("Processing queue is empty.");
        } else {
            // Iterate through the Queue. Note that iterating a Queue typically
            // does not remove elements. LinkedList iteration is in insertion order.
            // Creating a temporary list is a way to safely iterate if needed,
            // but direct iteration is fine for just viewing.
            // List<Task> queueContents = new ArrayList<>(processingQueue); // Alternative if direct iteration was risky
            for (Task task : processingQueue) {
                System.out.println(task.toString()); // Prints task details from the object instance
            }
        }
    }

    /**
     * Runs the main interactive loop for the task management system.
     * Handles user input, menu display, and calls appropriate methods.
     * Includes class-wide exception handling for input errors.
     */
    public void run() {
        scanner = new Scanner(System.in); // Initialize scanner
        System.out.println("--- Task Management System ---");
        boolean running = true;

        while (running) {
            displayMenu();

            try {
                System.out.print("Enter your choice: ");
                int choice = scanner.nextInt();
                scanner.nextLine(); // Consume the newline character left by nextInt()

                switch (choice) {
                    case 1:
                        addTask();
                        break;
                    case 2:
                        processNextTask();
                        break;
                    case 3:
                        viewAllTasks();
                        break;
                    case 4:
                        viewProcessingQueue();
                        break;
                    case 5:
                        running = false; // Set flag to exit the loop
                        System.out.println("Exiting Task Management System.");
                        break;
                    default:
                        // Handle invalid integer choices (outside 1-5 range)
                        System.err.println("Invalid choice. Please enter a number between 1 and 5.");
                        break;
                }
            } catch (InputMismatchException e) {
                // Handle non-integer input gracefully
                System.err.println("Invalid input. Please enter a number.");
                scanner.nextLine(); // Consume the invalid input to prevent infinite loop
            } catch (Exception e) {
                // Catch any other unexpected runtime exceptions
                System.err.println("An unexpected error occurred: " + e.getMessage());
                // e.printStackTrace(); // Uncomment for detailed debugging if needed
            }
        }

        scanner.close(); // Close the scanner when the application exits
    }

    /**
     * Displays the main menu options to the console.
     */
    private void displayMenu() {
        System.out.println("\nSelect an option:");
        System.out.println("1. Add New Task");
        System.out.println("2. Process Next Task");
        System.out.println("3. View All Tasks");
        System.out.println("4. View Processing Queue");
        System.out.println("5. Exit");
    }
}

/**
 * Main class to start the Task Management System application.
 */
public class ExamTaskManagement {
    public static void main(String[] args) {
        // Create an instance of the system and run it
        TaskManagementSystem system = new TaskManagementSystem();
        system.run();
    }
}
