/*
 * Exam Question #76
 * Generated on: 2025-05-11 22:09:33
 * Generated by: Account 5
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Task Management System
 * 
 * **Objective:** Implement a simple command-line Task Management System that allows a user to add, process, list, and manage tasks. This task requires demonstrating proficiency in using core Java data structures and control flow mechanisms, including exception handling.
 * 
 * **Scenario:** You need to build a system to manage a list of tasks. New tasks are added to a queue for processing. Users can process the next task in the queue, view lists of all tasks, pending tasks (those still in the queue), or completed tasks. They can also manually mark a task as completed.
 * 
 * **Requirements:**
 * 
 * 1.  **Task Representation:** Create a `Task` class with the following private fields:
 *     *   `id` (int): Unique identifier for the task.
 *     *   `description` (String): A brief description of the task.
 *     *   `status` (enum `TaskStatus`): Represents the current status of the task (e.g., `PENDING`, `IN_PROGRESS`, `COMPLETED`).
 *     *   Provide a constructor, appropriate getters, and a setter for the status.
 *     *   Override the `toString()` method for easy printing of task details.
 * 
 * 2.  **Task Management Logic:** Create a `TaskManager` class with the following private fields:
 *     *   `pendingTasks` (java.util.Queue<Task>): A queue holding tasks that are waiting to be processed.
 *     *   `allTasks` (java.util.List<Task>): A list containing all tasks ever created, regardless of their current status. Use `java.util.ArrayList` for the concrete implementation.
 *     *   `nextTaskId` (int): A counter to generate unique task IDs starting from 1.
 * 
 * 3.  **`TaskManager` Methods:** Implement the following public methods in the `TaskManager` class:
 *     *   `addTask(String description)`: Creates a new `Task` with status `PENDING`, assigns a unique ID, adds it to both `allTasks` and `pendingTasks`.
 *     *   `processNextTask()`: Removes the next task from `pendingTasks`. If a task is successfully retrieved, find it in `allTasks` and update its status to `COMPLETED`. If the queue is empty, indicate this condition.
 *     *   `getAllTasks()`: Returns the `allTasks` list.
 *     *   `getPendingTasks()`: Returns the `pendingTasks` queue. (Note: Returning the queue directly allows viewing but not modification via the returned reference in this simple design).
 *     *   `getCompletedTasks()`: Returns a new `List` containing only tasks from `allTasks` whose status is `COMPLETED`.
 *     *   `markTaskCompleted(int taskId)`: Finds the task with the given ID in `allTasks`. If found and its status is `PENDING` or `IN_PROGRESS`, update its status to `COMPLETED`. If the task was still in `pendingTasks`, remove it from the queue as well. If the task is not found or is already completed, indicate this condition.
 * 
 * 4.  **Main Application:** Create a `Main` class with a `main` method.
 *     *   Use `java.util.Scanner` to get user input from the console.
 *     *   Implement a menu-driven interface using a `switch` statement within a loop to allow the user to perform the following actions:
 *         1.  Add New Task
 *         2.  Process Next Pending Task
 *         3.  List All Tasks
 *         4.  List Pending Tasks
 *         5.  List Completed Tasks
 *         6.  Mark Task as Completed (by ID)
 *         7.  Exit
 *     *   Use `System.out` for displaying the menu, task lists, and success messages.
 *     *   Use `System.err` for displaying error messages (e.g., invalid menu choice, queue empty, task not found, invalid input format).
 *     *   Implement class-wide exception handling using a `try-catch` block that wraps the main application loop or critical sections to catch and report unexpected errors.
 * 
 * 5.  **Input Validation:** Validate user input where necessary (e.g., menu choice, task ID). Handle invalid input gracefully using `System.err` and prompt the user again or return to the menu.
 * 
 * 6.  **Best Practices:** Adhere to Java coding best practices:
 *     *   Proper encapsulation (private fields, public methods).
 *     *   Meaningful variable and method names.
 *     *   Appropriate comments and documentation (Javadocs are a plus but not strictly required for every single method in an exam setting; clarity is key).
 *     *   Clean code structure.
 * 
 * **Expected Output:**
 * The program should present a menu, accept user input, and perform the requested actions, displaying results or errors to the console (`System.out` or `System.err`) as appropriate.
 * 
 * ```
 * --- Task Management System ---
 * 1. Add New Task
 * 2. Process Next Pending Task
 * 3. List All Tasks
 * 4. List Pending Tasks
 * 5. List Completed Tasks
 * 6. Mark Task as Completed (by ID)
 * 7. Exit
 * Enter your choice:
 * ```
 * (Example output after adding tasks and processing)
 * ```
 * Task added with ID: 1
 * Task added with ID: 2
 * Next task processed: Task{id=1, description='Task 1', status=COMPLETED}
 * --- All Tasks ---
 * Task{id=1, description='Task 1', status=COMPLETED}
 * Task{id=2, description='Task 2', status=PENDING}
 * --- Pending Tasks ---
 * Task{id=2, description='Task 2', status=PENDING}
 * --- Completed Tasks ---
 * Task{id=1, description='Task 1', status=COMPLETED}
 * ```
 * 
 * **Constraint Checklist:**
 * *   [x] Use java.util.Queue
 * *   [x] Use java.util.ArrayList
 * *   [x] Use java.util.List interface
 * *   [x] Use java.util.Scanner
 * *   [x] Use switch statement
 * *   [x] Use System.err
 * *   [x] Use System.out
 * *   [x] Use class-wide exception handling (try-catch)
 * *   [x] Practical/Creative scenario
 * *   [x] Proper encapsulation
 * *   [x] Meaningful names
 * *   [x] Comments/Documentation (basic)
 * *   [x] Input validation
 * *   [x] Proper error handling
 * *   [x] Clean code structure
 *
 * EXPLANATION:
 * This solution implements a simple command-line Task Management System demonstrating the required Java concepts.
 * 
 * 1.  **Task Class:** Represents a single task with an ID, description, and status. The `TaskStatus` enum provides clear, type-safe states. Encapsulation is achieved by making fields `private` and providing public getter/setter methods. The `toString()` method provides a convenient way to print task details.
 * 
 * 2.  **TaskManager Class:** This class encapsulates the core logic and data structures.
 *     *   `private Queue<Task> pendingTasks`: A `LinkedList` is used as the concrete implementation of the `Queue` interface. This queue holds tasks waiting to be processed in a FIFO manner (or order of addition). `LinkedList` is a good choice for a queue due to efficient additions/removals at both ends.
 *     *   `private List<Task> allTasks`: An `ArrayList` is used as the concrete implementation of the `List` interface. This list maintains a complete history of all tasks created, allowing lookup and filtering regardless of their current status. `ArrayList` is suitable for storing and iterating over a collection of elements.
 *     *   `addTask(String description)`: Creates a new `Task`, assigns a unique ID using `nextTaskId`, adds the task object reference to *both* the `allTasks` list and the `pendingTasks` queue. Input validation checks for empty descriptions.
 *     *   `processNextTask()`: Uses `pendingTasks.poll()` to get and remove the next task from the queue. If `poll()` returns `null` (queue is empty), it prints an error to `System.err`. Otherwise, it updates the status of the retrieved task object (which is the same object reference stored in `allTasks`) to `COMPLETED`.
 *     *   `getAllTasks()`, `getPendingTasks()`: Simple getters returning the internal data structures.
 *     *   `getCompletedTasks()`: Demonstrates iterating through the `allTasks` list and filtering based on status, returning a new `ArrayList` containing only completed tasks.
 *     *   `markTaskCompleted(int taskId)`: Iterates through `allTasks` to find the task by ID. If found and not already completed, it updates the status to `COMPLETED` and importantly, also attempts to remove the task from the `pendingTasks` queue using `pendingTasks.remove(taskToComplete)`. This ensures manually completed tasks are no longer in the processing queue. Error messages are printed to `System.err` if the task isn't found or is already completed.
 * 
 * 3.  **Main Class:**
 *     *   The `main` method drives the application.
 *     *   A `Scanner` is used to read user input from `System.in`.
 *     *   A `while` loop runs the main application menu until the user chooses to exit.
 *     *   A `switch` statement handles the user's menu choice, directing execution to the appropriate `TaskManager` method calls or application logic.
 *     *   `System.out` is used for printing the menu, successful operations, and task lists.
 *     *   `System.err` is used for printing validation errors (like invalid menu choice, empty description, task not found, queue empty) and `InputMismatchException` errors from the `Scanner`.
 *     *   **Class-wide exception handling:** A `try-catch (Exception e)` block wraps the main `while` loop. This provides a basic level of robustness by catching any unexpected runtime exceptions that might occur within the loop and printing an error message and stack trace to `System.err`. More specific `try-catch` blocks are also used within the loop (e.g., around `scanner.nextInt()`) to handle `InputMismatchException` specifically for numerical inputs, allowing for more graceful error recovery for common input issues.
 *     *   Input validation is performed for menu choices (within the `switch` default case) and task descriptions (`addTask` method). The `Scanner` input reading also includes handling `InputMismatchException` and consuming the invalid input to prevent infinite loops.
 *     *   The `finally` block ensures the `Scanner` is closed when the application terminates, releasing system resources.
 * 
 * This solution effectively integrates `Queue`, `ArrayList` (`List`), `Scanner`, `switch`, `System.err`, `System.out`, and `try-catch` in a practical scenario, demonstrating proper object-oriented design, data structure usage, and error handling techniques suitable for an advanced beginner or intermediate Java exam.
 */

import java.util.ArrayList;
import java.util.LinkedList; // LinkedList is a common implementation for Queue
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.InputMismatchException; // Specific exception for Scanner

// Enum for Task Status
enum TaskStatus {
    PENDING,
    IN_PROGRESS, // Could be used for a more complex system, but PENDING -> COMPLETED is simpler here
    COMPLETED
}

// Represents a single task
class Task {
    private int id;
    private String description;
    private TaskStatus status;

    public Task(int id, String description) {
        this.id = id;
        this.description = description;
        this.status = TaskStatus.PENDING; // New tasks are always pending
    }

    // Getters
    public int getId() {
        return id;
    }

    public String getDescription() {
        return description;
    }

    public TaskStatus getStatus() {
        return status;
    }

    // Setter for status (used by TaskManager)
    public void setStatus(TaskStatus status) {
        this.status = status;
    }

    @Override
    public String toString() {
        return "Task{id=" + id + ", description='" + description + "', status=" + status + '}';
    }
}

// Manages the collection of tasks
class TaskManager {
    private Queue<Task> pendingTasks;
    private List<Task> allTasks; // Storing all tasks for history and lookup
    private int nextTaskId;

    public TaskManager() {
        this.pendingTasks = new LinkedList<>(); // LinkedList implements Queue
        this.allTasks = new ArrayList<>(); // ArrayList implements List
        this.nextTaskId = 1; // Start task IDs from 1
    }

    /**
     * Adds a new task to the system.
     * @param description The description of the new task.
     */
    public void addTask(String description) {
        if (description == null || description.trim().isEmpty()) {
            System.err.println("Error: Task description cannot be empty.");
            return;
        }
        Task newTask = new Task(nextTaskId++, description.trim());
        allTasks.add(newTask);
        pendingTasks.add(newTask); // Add to the queue for processing
        System.out.println("Task added with ID: " + newTask.getId());
    }

    /**
     * Processes the next task in the pending queue.
     * Marks the task as COMPLETED.
     */
    public void processNextTask() {
        Task taskToProcess = pendingTasks.poll(); // Retrieves and removes the head of the queue

        if (taskToProcess != null) {
            // Find the task in allTasks and update its status
            // We can use the reference from the queue directly as it's the same object
            taskToProcess.setStatus(TaskStatus.COMPLETED);
            System.out.println("Next task processed: " + taskToProcess);
        } else {
            System.err.println("No pending tasks to process.");
        }
    }

    /**
     * Gets an unmodifiable view of all tasks.
     * @return A list containing all tasks.
     */
    public List<Task> getAllTasks() {
        // Returning the internal list directly is okay for this exam scenario,
        // but in a real app, you might return an unmodifiable list or a copy.
        return allTasks;
    }

    /**
     * Gets the queue of pending tasks.
     * @return The queue of pending tasks.
     */
    public Queue<Task> getPendingTasks() {
        // Returning the internal queue directly is okay for this exam scenario.
        return pendingTasks;
    }

    /**
     * Gets a list of tasks that are completed.
     * @return A list containing only completed tasks.
     */
    public List<Task> getCompletedTasks() {
        List<Task> completed = new ArrayList<>(); // Use ArrayList for the result list
        for (Task task : allTasks) { // Iterate through the main list
            if (task.getStatus() == TaskStatus.COMPLETED) {
                completed.add(task);
            }
        }
        return completed;
    }

    /**
     * Marks a specific task as completed by its ID.
     * Also removes it from the pending queue if it was there.
     * @param taskId The ID of the task to mark as completed.
     */
    public void markTaskCompleted(int taskId) {
        Task taskToComplete = null;
        // Find the task in the allTasks list
        for (Task task : allTasks) {
            if (task.getId() == taskId) {
                taskToComplete = task;
                break; // Found the task
            }
        }

        if (taskToComplete == null) {
            System.err.println("Error: Task with ID " + taskId + " not found.");
        } else if (taskToComplete.getStatus() == TaskStatus.COMPLETED) {
            System.err.println("Task with ID " + taskId + " is already completed.");
        } else {
            taskToComplete.setStatus(TaskStatus.COMPLETED);
            // If the task was pending, remove it from the queue
            // Note: removing from LinkedList (used for Queue) by object reference works
            pendingTasks.remove(taskToComplete); // remove() returns true if element was found and removed
            System.out.println("Task with ID " + taskId + " marked as completed.");
        }
    }
}

// Main application class
public class Main {

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        TaskManager taskManager = new TaskManager();
        boolean running = true;

        // Class-wide exception handling for the main loop
        try {
            while (running) {
                printMenu();
                System.out.print("Enter your choice: ");

                int choice = -1;
                try {
                    choice = scanner.nextInt(); // Read integer choice
                    scanner.nextLine(); // Consume newline left-over
                } catch (InputMismatchException e) {
                    System.err.println("Invalid input. Please enter a number.");
                    scanner.nextLine(); // Consume the invalid input to prevent infinite loop
                    continue; // Skip the rest of the loop and show menu again
                }

                switch (choice) {
                    case 1:
                        System.out.print("Enter task description: ");
                        String description = scanner.nextLine();
                        taskManager.addTask(description);
                        break;
                    case 2:
                        taskManager.processNextTask();
                        break;
                    case 3:
                        System.out.println("--- All Tasks ---");
                        List<Task> all = taskManager.getAllTasks();
                        if (all.isEmpty()) {
                            System.out.println("No tasks created yet.");
                        } else {
                            for (Task task : all) {
                                System.out.println(task);
                            }
                        }
                        break;
                    case 4:
                        System.out.println("--- Pending Tasks ---");
                        Queue<Task> pending = taskManager.getPendingTasks();
                        if (pending.isEmpty()) {
                            System.out.println("No pending tasks.");
                        } else {
                            // Iterate over the queue without removing elements
                            for (Task task : pending) {
                                System.out.println(task);
                            }
                        }
                        break;
                    case 5:
                        System.out.println("--- Completed Tasks ---");
                        List<Task> completed = taskManager.getCompletedTasks();
                        if (completed.isEmpty()) {
                            System.out.println("No completed tasks.");
                        } else {
                            for (Task task : completed) {
                                System.out.println(task);
                            }
                        }
                        break;
                    case 6:
                        System.out.print("Enter ID of task to mark as completed: ");
                        try {
                            int taskIdToComplete = scanner.nextInt();
                            scanner.nextLine(); // Consume newline
                            taskManager.markTaskCompleted(taskIdToComplete);
                        } catch (InputMismatchException e) {
                            System.err.println("Invalid input. Please enter a valid task ID (number).");
                            scanner.nextLine(); // Consume invalid input
                        }
                        break;
                    case 7:
                        System.out.println("Exiting Task Management System. Goodbye!");
                        running = false;
                        break;
                    default:
                        System.err.println("Invalid choice. Please enter a number between 1 and 7.");
                }
                System.out.println(); // Add a newline for better readability
            }
        } catch (Exception e) {
            // Catch any unexpected exceptions during the program execution
            System.err.println("An unexpected error occurred: " + e.getMessage());
            e.printStackTrace(); // Print stack trace for debugging
        } finally {
            scanner.close(); // Close the scanner when the application exits
        }
    }

    private static void printMenu() {
        System.out.println("--- Task Management System ---");
        System.out.println("1. Add New Task");
        System.out.println("2. Process Next Pending Task");
        System.out.println("3. List All Tasks");
        System.out.println("4. List Pending Tasks");
        System.out.println("5. List Completed Tasks");
        System.out.println("6. Mark Task as Completed (by ID)");
        System.out.println("7. Exit");
    }
}
