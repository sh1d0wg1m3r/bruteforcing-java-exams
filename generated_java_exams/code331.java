/*
 * Exam Question #331
 * Generated on: 2025-05-11 22:56:14
 * Generated by: Account 2
 * 
 * QUESTION:
 * ## Advanced Java Programming Exam Task: Document Processing Simulation
 * 
 * **Scenario:**
 * 
 * You are tasked with building a simplified simulation of a document processing system. Documents arrive and are placed in a queue awaiting processing. A processor takes documents from the queue one by one, attempts to process them, and then moves them to a list of processed documents, noting their final status (Completed or Failed). The system should allow users to add new documents, process the next available document, view pending documents, view processed documents, and search for a document by its ID.
 * 
 * **Requirements:**
 * 
 * 1.  **Document Representation:** Create a `Document` class with private fields for `id` (int), `name` (String), and `status` (an enum `DocumentStatus`). Include a constructor and public getter methods. The `DocumentStatus` enum should have values: `PENDING`, `PROCESSING`, `COMPLETED`, `FAILED`.
 * 2.  **Processing System:** Create a `DocumentProcessor` class that manages the document flow.
 *     *   It must use a `java.util.Queue<Document>` to hold documents awaiting processing.
 *     *   It must use a `java.util.List<Document>` (specifically implemented using `java.util.ArrayList`) to store documents after processing.
 *     *   Implement the following methods:
 *         *   `addDocument(Document doc)`: Adds a document to the pending queue.
 *         *   `processNextDocument()`:
 *             *   Takes the document from the *front* of the pending queue.
 *             *   If the queue is empty, print an error message to `System.err` and return.
 *             *   Simulate processing: For this task, assume processing succeeds if the document ID is *odd* and fails if the document ID is *even*.
 *             *   Update the document's status based on the simulation result (`COMPLETED` or `FAILED`).
 *             *   Add the processed document to the list of processed documents.
 *             *   Print the result of the processing (which document, status) to `System.out`.
 *         *   `getPendingDocuments()`: Returns a `List` view of the current documents in the pending queue (without removing them).
 *         *   `getProcessedDocuments()`: Returns the list of processed documents.
 *         *   `findDocumentById(int id)`: Searches for a document with the given ID in *both* the pending queue and the processed list. Returns the `Document` object if found, or `null` otherwise.
 * 3.  **User Interface:** Create a `Main` class with a `main` method to interact with the user via the console.
 *     *   Use `java.util.Scanner` to read user input.
 *     *   Present a menu of options to the user:
 *         1.  Add New Document
 *         2.  Process Next Document
 *         3.  View Pending Documents
 *         4.  View Processed Documents
 *         5.  Find Document by ID
 *         6.  Exit
 *     *   Use a `switch` statement to handle the user's menu choice.
 *     *   Implement input validation:
 *         *   For adding a document, prompt for ID (integer) and Name (String). Ensure ID is a positive integer.
 *         *   For finding a document, prompt for ID (integer). Ensure ID is a positive integer.
 *         *   Handle non-integer input gracefully using `try-catch` blocks around `Scanner` calls that expect integers, printing an error message to `System.err`.
 *     *   Wrap the main application loop (reading menu choices) in a `try-catch` block to demonstrate class-wide exception handling for unexpected errors. Print a generic error message to `System.err` if such an error occurs.
 * 4.  **Output:**
 *     *   Use `System.out` for menu display, successful operations, and listing documents.
 *     *   Use `System.err` for all error messages (invalid input, queue empty, processing failure messages).
 * 5.  **Best Practices:**
 *     *   Use appropriate data types.
 *     *   Follow Java naming conventions.
 *     *   Include Javadoc-style comments for classes and methods.
 *     *   Ensure proper encapsulation (private fields, public methods).
 *     *   Handle potential exceptions gracefully.
 *     *   Keep the code clean and readable.
 * 
 * **Expected Output Structure:**
 * 
 * ```
 * --- Document Processing System ---
 * 1. Add New Document
 * 2. Process Next Document
 * ...
 * Enter your choice: [user input]
 * 
 * // Example outputs based on user actions:
 * // Adding Document:
 * Enter Document ID: [user input]
 * Enter Document Name: [user input]
 * Document added: [ID] - [Name] (PENDING)
 * 
 * // Invalid Input:
 * Enter Document ID: [non-integer input]
 * Error: Invalid input. Please enter a positive integer for ID.
 * 
 * // Processing Document:
 * Processing document: [ID] - [Name]...
 * Document [ID] processed successfully (COMPLETED). // Or Failed
 * 
 * // Viewing Pending:
 * --- Pending Documents ---
 * ID: [ID], Name: [Name], Status: [Status]
 * ...
 * (Queue is empty) // If no pending documents
 * 
 * // Viewing Processed:
 * --- Processed Documents ---
 * ID: [ID], Name: [Name], Status: [Status]
 * ...
 * (No documents have been processed yet) // If no processed documents
 * 
 * // Finding Document:
 * Enter Document ID to find: [user input]
 * Document found: ID: [ID], Name: [Name], Status: [Status] // If found
 * Document with ID [ID] not found. // If not found
 * 
 * // Generic Error (from class-wide try-catch):
 * An unexpected error occurred: [error message]
 * 
 * // Exit:
 * Exiting system.
 * ```
 * 
 * Your solution should be a single Java file containing all necessary classes.
 *
 * EXPLANATION:
 * This solution implements a simplified document processing system, demonstrating the required Java concepts in a practical context.
 * 
 * 1.  **`Document` Class:** This class represents a single document with an `id`, `name`, and `status`.
 *     *   Fields are `private` for encapsulation.
 *     *   Getters provide controlled access to the data.
 *     *   An enum `DocumentStatus` is used for clarity and type safety regarding the document's state.
 *     *   The constructor includes basic validation (`id > 0`).
 * 
 * 2.  **`DocumentProcessor` Class:** This is the core of the processing logic.
 *     *   `Queue<Document> pendingDocuments`: A `LinkedList` is used as the concrete implementation of the `Queue` interface. This is suitable for adding to the rear (`offer`) and removing from the front (`poll`).
 *     *   `List<Document> processedDocuments`: An `ArrayList` is used as the concrete implementation of the `List` interface. This is suitable for storing processed items in a dynamic list.
 *     *   `addDocument(Document doc)`: Uses `queue.offer()` to add a document to the end of the pending queue.
 *     *   `processNextDocument()`:
 *         *   Checks if the queue is empty using `queue.isEmpty()`. If so, it prints an error to `System.err`.
 *         *   Uses `queue.poll()` to get and remove the document at the head of the queue. `poll()` safely returns `null` if the queue is empty (though we already checked, it's good practice).
 *         *   Simulates processing success/failure based on `document.getId() % 2 != 0`.
 *         *   Updates the document's status using the setter.
 *         *   Adds the processed document to the `processedDocuments` list using `list.add()`.
 *         *   Prints status updates to `System.out` for success and `System.err` for failure, as requested.
 *     *   `getPendingDocuments()`: Returns a *copy* of the pending documents list (`new ArrayList<>(pendingDocuments)`) to prevent external modification of the internal queue state. It returns a `List`, adhering to the requirement.
 *     *   `getProcessedDocuments()`: Returns the internal `processedDocuments` `List` (which is an `ArrayList`), satisfying the requirement to use `List` and `ArrayList`.
 *     *   `findDocumentById(int id)`: Iterates through both the `pendingDocuments` queue and the `processedDocuments` list to find a document by ID.
 * 
 * 3.  **`Main` Class:** Provides the command-line user interface.
 *     *   `Scanner scanner = new Scanner(System.in)`: Used to read input from the console.
 *     *   The main application logic is wrapped in a `try-catch (Exception e)` block. This serves as the "class-wide" exception handling, catching any unexpected runtime errors that might occur within the loop and printing a generic error message to `System.err`.
 *     *   A `while(running)` loop keeps the application running until the user chooses to exit.
 *     *   Inside the loop, a nested `try-catch (NumberFormatException e)` is used specifically for parsing the user's menu choice. If the input isn't an integer, it prints an error to `System.err` and continues the loop, prompting for input again.
 *     *   A `switch` statement handles the different menu options, directing execution to helper methods (`addDocument`, `viewDocuments`, `findDocument`) or directly calling `processor` methods.
 *     *   Helper methods (`addDocument`, `findDocument`) contain specific input validation logic using `try-catch (NumberFormatException e)` for integer inputs (ID) and checking for positive values. Error messages for invalid input are sent to `System.err`.
 *     *   `viewDocuments` helper method iterates through a given `List` and prints document details to `System.out`. It handles the case of an empty list.
 *     *   `System.out` is used for menu display, prompts, and successful operations/list views.
 *     *   `System.err` is used exclusively for error messages (invalid input, queue empty, processing failures, unexpected errors).
 *     *   `scanner.close()` is called in a `finally` block to ensure the scanner resource is released when the application exits (either normally or due to an unexpected error caught by the outer `try-catch`).
 * 
 * This solution effectively uses all the required Java components (`Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.err`, `System.out`, `try-catch`) within a structured, encapsulated, and error-handling design, simulating a realistic document processing flow.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.NoSuchElementException; // For queue.remove() on empty queue

// Enum for Document Status
enum DocumentStatus {
    PENDING, PROCESSING, COMPLETED, FAILED
}

/**
 * Represents a document in the processing system.
 */
class Document {
    private int id;
    private String name;
    private DocumentStatus status;

    /**
     * Constructs a new Document.
     * @param id The unique identifier for the document.
     * @param name The name of the document.
     */
    public Document(int id, String name) {
        if (id <= 0) {
            throw new IllegalArgumentException("Document ID must be positive.");
        }
        this.id = id;
        this.name = name;
        this.status = DocumentStatus.PENDING; // Initially pending
    }

    // Getters
    public int getId() {
        return id;
    }

    public String getName() {
        return name;
    }

    public DocumentStatus getStatus() {
        return status;
    }

    // Setter for status (package-private or protected if needed, public for simplicity here)
    public void setStatus(DocumentStatus status) {
        this.status = status;
    }

    @Override
    public String toString() {
        return "ID: " + id + ", Name: " + name + ", Status: " + status;
    }
}

/**
 * Manages the queue of pending documents and the list of processed documents.
 */
class DocumentProcessor {
    // Use LinkedList as a Queue implementation
    private Queue<Document> pendingDocuments;
    // Use ArrayList for the processed documents list
    private List<Document> processedDocuments;

    /**
     * Constructs a new DocumentProcessor.
     */
    public DocumentProcessor() {
        this.pendingDocuments = new LinkedList<>();
        this.processedDocuments = new ArrayList<>();
    }

    /**
     * Adds a document to the pending queue.
     * @param doc The document to add.
     */
    public void addDocument(Document doc) {
        pendingDocuments.offer(doc); // offer is generally preferred over add for capacity-constrained queues, but fine here
    }

    /**
     * Processes the next document from the queue.
     * Simulates processing success/failure based on ID parity.
     */
    public void processNextDocument() {
        if (pendingDocuments.isEmpty()) {
            System.err.println("Error: No documents in the pending queue to process.");
            return;
        }

        // Use poll() to retrieve and remove the head of the queue, returns null if empty
        // Alternatively, element()/peek() + remove() can be used, but requires checking
        Document docToProcess = pendingDocuments.poll();

        if (docToProcess != null) {
            System.out.println("Processing document: " + docToProcess.getId() + " - " + docToProcess.getName() + "...");

            // Simulate processing: Odd ID succeeds, Even ID fails
            if (docToProcess.getId() % 2 != 0) { // Odd ID
                docToProcess.setStatus(DocumentStatus.COMPLETED);
                System.out.println("Document " + docToProcess.getId() + " processed successfully (COMPLETED).");
            } else { // Even ID
                docToProcess.setStatus(DocumentStatus.FAILED);
                System.err.println("Document " + docToProcess.getId() + " processing failed (FAILED)."); // Use err for failure
            }

            processedDocuments.add(docToProcess);
        }
    }

    /**
     * Returns a list containing documents currently in the pending queue.
     * Note: This returns a new list, not the internal queue object itself.
     * @return A list of pending documents.
     */
    public List<Document> getPendingDocuments() {
        // Create a new list to avoid exposing the internal queue structure directly
        return new ArrayList<>(pendingDocuments);
    }

    /**
     * Returns the list of processed documents.
     * Note: Returns the internal list object. For larger systems, returning an unmodifiable list might be better.
     * @return The list of processed documents.
     */
    public List<Document> getProcessedDocuments() {
        return processedDocuments;
    }

    /**
     * Finds a document by its ID in either the pending queue or the processed list.
     * @param id The ID to search for.
     * @return The Document object if found, null otherwise.
     */
    public Document findDocumentById(int id) {
        // Search in pending queue
        for (Document doc : pendingDocuments) {
            if (doc.getId() == id) {
                return doc;
            }
        }

        // Search in processed list
        for (Document doc : processedDocuments) {
            if (doc.getId() == id) {
                return doc;
            }
        }

        return null; // Not found
    }
}

/**
 * Main class for the Document Processing System user interface.
 */
public class Main {

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        DocumentProcessor processor = new DocumentProcessor();
        boolean running = true;

        // Class-wide try-catch for unexpected errors in the main loop
        try {
            while (running) {
                printMenu();
                System.out.print("Enter your choice: ");

                int choice = -1;
                try {
                    choice = Integer.parseInt(scanner.nextLine());
                } catch (NumberFormatException e) {
                    System.err.println("Error: Invalid input. Please enter a number.");
                    continue; // Go back to menu
                }

                switch (choice) {
                    case 1: // Add New Document
                        addDocument(scanner, processor);
                        break;
                    case 2: // Process Next Document
                        processor.processNextDocument();
                        break;
                    case 3: // View Pending Documents
                        viewDocuments(processor.getPendingDocuments(), "Pending");
                        break;
                    case 4: // View Processed Documents
                        viewDocuments(processor.getProcessedDocuments(), "Processed");
                        break;
                    case 5: // Find Document by ID
                        findDocument(scanner, processor);
                        break;
                    case 6: // Exit
                        running = false;
                        System.out.println("Exiting system.");
                        break;
                    default:
                        System.err.println("Error: Invalid choice. Please enter a number between 1 and 6.");
                }
                System.out.println(); // Add a newline for better readability
            }
        } catch (Exception e) {
            // Catch any other unexpected exceptions
            System.err.println("An unexpected error occurred: " + e.getMessage());
            // e.printStackTrace(); // Uncomment for debugging
        } finally {
            scanner.close(); // Close the scanner when done
        }
    }

    /**
     * Prints the main menu options.
     */
    private static void printMenu() {
        System.out.println("--- Document Processing System ---");
        System.out.println("1. Add New Document");
        System.out.println("2. Process Next Document");
        System.out.println("3. View Pending Documents");
        System.out.println("4. View Processed Documents");
        System.out.println("5. Find Document by ID");
        System.out.println("6. Exit");
        System.out.println("----------------------------------");
    }

    /**
     * Handles adding a new document based on user input.
     * @param scanner The Scanner object for reading input.
     * @param processor The DocumentProcessor instance.
     */
    private static void addDocument(Scanner scanner, DocumentProcessor processor) {
        int id = -1;
        String name = "";

        // Input validation for ID
        try {
            System.out.print("Enter Document ID: ");
            id = Integer.parseInt(scanner.nextLine());
            if (id <= 0) {
                System.err.println("Error: Document ID must be a positive integer.");
                return; // Exit method if ID is not positive
            }
        } catch (NumberFormatException e) {
            System.err.println("Error: Invalid input for ID. Please enter a positive integer.");
            return; // Exit method if input is not a number
        }

        System.out.print("Enter Document Name: ");
        name = scanner.nextLine();

        // Basic validation for name (optional but good practice)
        if (name == null || name.trim().isEmpty()) {
             System.err.println("Error: Document name cannot be empty.");
             return;
        }

        try {
             Document newDoc = new Document(id, name);
             processor.addDocument(newDoc);
             System.out.println("Document added: " + newDoc.getId() + " - " + newDoc.getName() + " (" + newDoc.getStatus() + ")");
        } catch (IllegalArgumentException e) {
             System.err.println("Error creating document: " + e.getMessage());
             // This catch block handles the negative ID check from the Document constructor
        }
    }

    /**
     * Displays a list of documents with a given title.
     * @param documents The list of documents to display.
     * @param title The title for the list (e.g., "Pending", "Processed").
     */
    private static void viewDocuments(List<Document> documents, String title) {
        System.out.println("--- " + title + " Documents ---");
        if (documents.isEmpty()) {
            System.out.println("(" + title + " list is empty)");
        } else {
            for (int i = 0; i < documents.size(); i++) {
                System.out.println((i + 1) + ". " + documents.get(i));
            }
        }
    }

    /**
     * Handles finding a document by ID based on user input.
     * @param scanner The Scanner object for reading input.
     * @param processor The DocumentProcessor instance.
     */
    private static void findDocument(Scanner scanner, DocumentProcessor processor) {
        int idToFind = -1;
        try {
            System.out.print("Enter Document ID to find: ");
            idToFind = Integer.parseInt(scanner.nextLine());
            if (idToFind <= 0) {
                 System.err.println("Error: Document ID must be a positive integer.");
                 return; // Exit method if ID is not positive
            }
        } catch (NumberFormatException e) {
            System.err.println("Error: Invalid input for ID. Please enter a positive integer.");
            return; // Exit method if input is not a number
        }

        Document foundDoc = processor.findDocumentById(idToFind);

        if (foundDoc != null) {
            System.out.println("Document found: " + foundDoc);
        } else {
            System.out.println("Document with ID " + idToFind + " not found.");
        }
    }
}
