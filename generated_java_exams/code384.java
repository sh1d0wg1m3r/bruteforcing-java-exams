/*
 * Exam Question #384
 * Generated on: 2025-05-11 23:03:06
 * Generated by: Account 3
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Document Processing Workflow Simulation
 * 
 * **Scenario:**
 * 
 * You are tasked with building a simple document processing system. The system should manage a queue of documents waiting to be processed and a list of documents that have already been processed. Users should be able to add new documents to the queue, process the next document in the queue, view the documents currently waiting, view the documents already processed, and exit the application.
 * 
 * **Requirements:**
 * 
 * 1.  **Document Representation:** Create a class named `Document` with private fields for `id` (int), `name` (String), and `status` (String, e.g., "Pending", "Processed"). Include a constructor, public getter methods for all fields, and a public method `markAsProcessed()` that changes the status to "Processed". Implement a `toString()` method to easily print document details.
 * 2.  **Processing Logic:** Create a class named `DocumentProcessor` that manages the document workflow.
 *     *   It should have a private `Queue<Document>` to hold pending documents.
 *     *   It should have a private `List<Document>` (specifically using an `ArrayList` instance) to hold processed documents.
 *     *   It should maintain a counter for assigning unique document IDs.
 *     *   Include public methods:
 *         *   `addDocument(String name)`: Creates a new `Document` with a unique ID and "Pending" status, adds it to the pending queue.
 *         *   `processNextDocument()`: Removes the document at the front of the pending queue, calls its `markAsProcessed()` method, and adds it to the processed list. This method should handle the case where the queue is empty.
 *         *   `getPendingDocuments()`: Returns a `List` view (or copy) of the documents in the pending queue.
 *         *   `getProcessedDocuments()`: Returns the `List` of processed documents.
 * 3.  **User Interface:** Create a main application class (e.g., `DocumentProcessingApp`) with a `main` method.
 *     *   Use `java.util.Scanner` to get user input from the console.
 *     *   Present a menu with options:
 *         1.  Add New Document
 *         2.  Process Next Document
 *         3.  View Pending Documents
 *         4.  View Processed Documents
 *         5.  Exit
 *     *   Use a `switch` statement to handle the user's menu choice.
 *     *   Display appropriate messages using `System.out`.
 *     *   Use `System.err` to display error messages (e.g., invalid menu choice, attempting to process when the queue is empty).
 * 4.  **Error Handling:** Implement class-wide exception handling using `try-catch` blocks, particularly around the main loop or input reading, to gracefully handle unexpected issues. Also, handle the specific case of processing an empty queue within `processNextDocument`.
 * 5.  **Best Practices:**
 *     *   Use proper encapsulation (private fields, public methods).
 *     *   Use meaningful variable and method names.
 *     *   Include comments where necessary to explain complex logic.
 *     *   Validate user input (e.g., ensure menu choice is a valid number within the range).
 *     *   Structure the code logically into classes and methods.
 * 
 * **Expected Output:**
 * 
 * The program should run interactively, displaying a menu, prompting for input, and showing results based on the user's choices. Error messages should be clearly distinguishable using `System.err`.
 * 
 * Example interaction flow:
 * 
 * ```
 * --- Document Processing System ---
 * Choose an option:
 * 1. Add New Document
 * 2. Process Next Document
 * 3. View Pending Documents
 * 4. View Processed Documents
 * 5. Exit
 * Enter choice: 1
 * Enter document name: ReportA
 * Document 'ReportA' (ID: 1) added to pending queue.
 * 
 * --- Document Processing System ---
 * Choose an option:
 * 1. Add New Document
 * 2. Process Next Document
 * 3. View Pending Documents
 * 4. View Processed Documents
 * 5. Exit
 * Enter choice: 1
 * Enter document name: InvoiceB
 * Document 'InvoiceB' (ID: 2) added to pending queue.
 * 
 * --- Document Processing System ---
 * Choose an option:
 * 1. Add New Document
 * 2. Process Next Document
 * 3. View Pending Documents
 * 4. View Processed Documents
 * 5. Exit
 * Enter choice: 3
 * --- Pending Documents ---
 * ID: 1, Name: ReportA, Status: Pending
 * ID: 2, Name: InvoiceB, Status: Pending
 * 
 * --- Document Processing System ---
 * Choose an option:
 * 1. Add New Document
 * 2. Process Next Document
 * 3. View Pending Documents
 * 4. View Processed Documents
 * 5. Exit
 * Enter choice: 2
 * Processing document: ID: 1, Name: ReportA, Status: Pending
 * Document 'ReportA' (ID: 1) processed.
 * 
 * --- Document Processing System ---
 * Choose an option:
 * 1. Add New Document
 * 2. Process Next Document
 * 3. View Pending Documents
 * 4. View Processed Documents
 * 5. Exit
 * Enter choice: 3
 * --- Pending Documents ---
 * ID: 2, Name: InvoiceB, Status: Pending
 * 
 * --- Document Processing System ---
 * Choose an option:
 * 1. Add New Document
 * 2. Process Next Document
 * 3. View Pending Documents
 * 4. View Processed Documents
 * 5. Exit
 * Enter choice: 4
 * --- Processed Documents ---
 * ID: 1, Name: ReportA, Status: Processed
 * 
 * --- Document Processing System ---
 * Choose an option:
 * 1. Add New Document
 * 2. Process Next Document
 * 3. View Pending Documents
 * 4. View Processed Documents
 * 5. Exit
 * Enter choice: 2
 * Processing document: ID: 2, Name: InvoiceB, Status: Pending
 * Document 'InvoiceB' (ID: 2) processed.
 * 
 * --- Document Processing System ---
 * Choose an option:
 * 1. Add New Document
 * 2. Process Next Document
 * 3. View Pending Documents
 * 4. View Processed Documents
 * 5. Exit
 * Enter choice: 2
 * System.err: No documents currently in the pending queue to process.
 * 
 * --- Document Processing System ---
 * Choose an option:
 * 1. Add New Document
 * 2. Process Next Document
 * 3. View Pending Documents
 * 4. View Processed Documents
 * 5. Exit
 * Enter choice: 6
 * System.err: Invalid choice. Please enter a number between 1 and 5.
 * 
 * --- Document Processing System ---
 * Choose an option:
 * 1. Add New Document
 * 2. Process Next Document
 * 3. View Pending Documents
 * 4. View Processed Documents
 * 5. Exit
 * Enter choice: 5
 * Exiting Document Processing System.
 * ```
 * 
 * **Grading Focus:**
 * 
 * *   Correct implementation and usage of `Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.out`, `System.err`, and `try-catch`.
 * *   Proper object-oriented design (`Document`, `DocumentProcessor`).
 * *   Adherence to best practices (encapsulation, naming, comments, input validation, error handling).
 * *   Correct logic for adding, processing, and viewing documents.
 *
 * EXPLANATION:
 * This solution implements a simple document processing workflow using the required Java components and best practices.
 * 
 * **1. Document Class:**
 * *   The `Document` class is a simple Plain Old Java Object (POJO) representing a document.
 * *   It uses `private` fields (`id`, `name`, `status`) demonstrating encapsulation.
 * *   Public getter methods provide controlled access to the data.
 * *   `markAsProcessed()` is a specific method to change the status, preventing direct manipulation of the status field from outside.
 * *   `toString()` is overridden for easy printing of document details.
 * 
 * **2. DocumentProcessor Class:**
 * *   This class encapsulates the core logic of the system.
 * *   `pendingDocuments`: A `Queue<Document>` is used here, specifically implemented by `LinkedList`. The `Queue` interface is ideal for managing items in a First-In, First-Out (FIFO) manner, which is suitable for a processing queue. `add()` and `poll()` methods of the Queue are used for adding and removing elements respectively.
 * *   `processedDocuments`: A `List<Document>` is used, instantiated as an `ArrayList`. The `List` interface represents an ordered collection, suitable for keeping track of processed documents in the order they finished processing. `ArrayList` is a common and efficient implementation for this purpose. `add()` method of the List is used to add processed documents.
 * *   `nextDocumentId`: A private integer counter ensures unique IDs are assigned to each new document.
 * *   `addDocument(String name)`: Creates a new `Document` object and adds it to the `pendingDocuments` queue using `queue.add()`. Basic input validation checks for empty names.
 * *   `processNextDocument()`: Uses `queue.poll()` to get and remove the next document from the front of the queue. It checks if `poll()` returned `null` (indicating an empty queue) and prints an error message using `System.err` if so. If a document is retrieved, its status is updated, and it's added to the `processedDocuments` list using `list.add()`.
 * *   `getPendingDocuments()` and `getProcessedDocuments()`: These methods provide access to the managed lists. `getPendingDocuments()` returns a *new* `ArrayList` containing the queue's elements, preventing external code from modifying the queue itself. `getProcessedDocuments()` returns an *unmodifiable* view of the processed list using `Collections.unmodifiableList()`, preventing external code from adding, removing, or modifying elements in the processed list, demonstrating defensive programming.
 * 
 * **3. DocumentProcessingApp Class:**
 * *   This class contains the `main` method, acting as the application's entry point and user interface.
 * *   `Scanner`: An instance of `Scanner` reads input from `System.in` (the console).
 * *   Main Loop: A `while(running)` loop keeps the application active until the user chooses to exit.
 * *   Input Validation: It checks if the input is an integer using `scanner.hasNextInt()` before reading it. If not, it consumes the invalid input and prints an error using `System.err`.
 * *   `switch` Statement: The user's integer choice is handled by a `switch` statement, directing the flow to the appropriate action (adding, processing, viewing, exiting). This provides a clean and readable way to handle multiple distinct options.
 * *   `System.out`: Used for printing the menu, prompts, success messages, and the lists of documents.
 * *   `System.err`: Used specifically for printing error messages (invalid input, empty queue processing) to the standard error stream, which is good practice for distinguishing errors from normal output.
 * *   `try-catch`: A `try-catch` block wraps the main `while` loop. This provides a basic level of class-wide exception handling, catching any unexpected `Exception` that might occur during the application's execution and printing an error message and stack trace to `System.err`. A `finally` block ensures the `Scanner` is closed properly regardless of whether an exception occurred or the loop finished normally.
 * *   `printMenu()`: A separate helper method for displaying the menu, promoting code modularity.
 * 
 * **Best Practices Demonstrated:**
 * *   **Encapsulation:** Fields are private, access is via public methods.
 * *   **Meaningful Names:** Class names (`Document`, `DocumentProcessor`), method names (`addDocument`, `processNextDocument`), and variable names (`pendingDocuments`, `docName`, `choice`) are descriptive.
 * *   **Comments:** Javadoc-style comments explain the purpose of classes and methods, and inline comments clarify specific logic (like queue implementation choice, input handling).
 * *   **Input Validation:** Checks for empty document names and invalid menu input type/range.
 * *   **Error Handling:** Specific check for empty queue processing (`System.err`), general `try-catch` for unexpected exceptions (`System.err`, `printStackTrace`), and proper `Scanner` handling (consuming newline, closing).
 * *   **Clean Code Structure:** Logic is separated into distinct classes (`Document`, `DocumentProcessor`) and methods (`addDocument`, `processNextDocument`, `printMenu`).
 * 
 * This solution effectively integrates all the required Java components into a functional, well-structured application that simulates a real-world workflow and demonstrates key programming concepts.
 */

import java.util.Queue;
import java.util.LinkedList; // LinkedList is a common Queue implementation
import java.util.List;
import java.util.ArrayList;
import java.util.Scanner;
import java.util.Collections; // For returning unmodifiable list

// Represents a document in the system
class Document {
    private int id;
    private String name;
    private String status; // e.g., "Pending", "Processed"

    /**
     * Constructs a new Document.
     * @param id The unique ID of the document.
     * @param name The name of the document.
     */
    public Document(int id, String name) {
        this.id = id;
        this.name = name;
        this.status = "Pending"; // Default status
    }

    // --- Getters ---
    public int getId() {
        return id;
    }

    public String getName() {
        return name;
    }

    public String getStatus() {
        return status;
    }

    /**
     * Marks the document status as "Processed".
     */
    public void markAsProcessed() {
        this.status = "Processed";
    }

    @Override
    public String toString() {
        return "ID: " + id + ", Name: " + name + ", Status: " + status;
    }
}

// Manages the document processing workflow
class DocumentProcessor {
    // Queue for documents waiting to be processed
    private Queue<Document> pendingDocuments;
    // List for documents that have been processed
    private List<Document> processedDocuments;
    // Counter for assigning unique document IDs
    private int nextDocumentId;

    /**
     * Constructs a new DocumentProcessor.
     * Initializes the pending queue and processed list.
     */
    public DocumentProcessor() {
        // Using LinkedList as a Queue implementation
        this.pendingDocuments = new LinkedList<>();
        // Using ArrayList as a List implementation
        this.processedDocuments = new ArrayList<>();
        this.nextDocumentId = 1; // Start IDs from 1
    }

    /**
     * Adds a new document to the pending queue.
     * @param name The name of the document.
     */
    public void addDocument(String name) {
        if (name == null || name.trim().isEmpty()) {
            System.err.println("Error: Document name cannot be empty.");
            return;
        }
        Document newDocument = new Document(nextDocumentId++, name);
        pendingDocuments.add(newDocument);
        System.out.println("Document '" + name + "' (ID: " + newDocument.getId() + ") added to pending queue.");
    }

    /**
     * Processes the next document in the pending queue.
     * Removes it from the queue, marks it as processed, and adds it to the processed list.
     * Handles the case where the queue is empty.
     */
    public void processNextDocument() {
        Document docToProcess = pendingDocuments.poll(); // Retrieves and removes the head of the queue

        if (docToProcess == null) {
            System.err.println("No documents currently in the pending queue to process.");
        } else {
            System.out.println("Processing document: " + docToProcess);
            docToProcess.markAsProcessed();
            processedDocuments.add(docToProcess);
            System.out.println("Document '" + docToProcess.getName() + "' (ID: " + docToProcess.getId() + ") processed.");
        }
    }

    /**
     * Returns a list of documents currently in the pending queue.
     * Note: Returns a new ArrayList containing elements from the queue to avoid external modification of the queue.
     * @return A List of pending documents.
     */
    public List<Document> getPendingDocuments() {
        // Return a new ArrayList to avoid exposing the internal queue structure directly
        return new ArrayList<>(pendingDocuments);
    }

    /**
     * Returns the list of documents that have been processed.
     * Note: Returns an unmodifiable view to prevent external modification of the processed list.
     * @return A List of processed documents.
     */
    public List<Document> getProcessedDocuments() {
        // Return an unmodifiable list to protect the internal list
        return Collections.unmodifiableList(processedDocuments);
    }
}

// Main application class for the Document Processing System
public class DocumentProcessingApp {

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        DocumentProcessor processor = new DocumentProcessor();
        boolean running = true;

        System.out.println("--- Document Processing System ---");

        // Main application loop with exception handling
        try {
            while (running) {
                printMenu();
                int choice = -1; // Default invalid choice

                // Input validation for menu choice
                if (scanner.hasNextInt()) {
                    choice = scanner.nextInt();
                } else {
                    // Consume the invalid input to prevent infinite loop
                    String invalidInput = scanner.next();
                    System.err.println("Invalid input: '" + invalidInput + "'. Please enter a number.");
                    continue; // Skip to next iteration
                }
                scanner.nextLine(); // Consume the newline character left by nextInt()

                // Process user choice using a switch statement
                switch (choice) {
                    case 1:
                        System.out.print("Enter document name: ");
                        String docName = scanner.nextLine();
                        processor.addDocument(docName);
                        break;
                    case 2:
                        processor.processNextDocument();
                        break;
                    case 3:
                        System.out.println("--- Pending Documents ---");
                        List<Document> pending = processor.getPendingDocuments();
                        if (pending.isEmpty()) {
                            System.out.println("No documents in the pending queue.");
                        } else {
                            for (Document doc : pending) {
                                System.out.println(doc);
                            }
                        }
                        break;
                    case 4:
                        System.out.println("--- Processed Documents ---");
                        List<Document> processed = processor.getProcessedDocuments();
                        if (processed.isEmpty()) {
                            System.out.println("No documents have been processed yet.");
                        } else {
                            for (Document doc : processed) {
                                System.out.println(doc);
                            }
                        }
                        break;
                    case 5:
                        running = false; // Set flag to exit loop
                        System.out.println("Exiting Document Processing System.");
                        break;
                    default:
                        // Handle invalid integer choices
                        System.err.println("Invalid choice. Please enter a number between 1 and 5.");
                }
                System.out.println(); // Add a blank line for better readability
            }
        } catch (Exception e) {
            // Catch any unexpected exceptions during execution
            System.err.println("An unexpected error occurred: " + e.getMessage());
            e.printStackTrace(); // Print stack trace for debugging
        } finally {
            // Ensure the scanner is closed
            scanner.close();
            System.out.println("Scanner closed.");
        }
    }

    /**
     * Prints the main menu options to the console.
     */
    private static void printMenu() {
        System.out.println("Choose an option:");
        System.out.println("1. Add New Document");
        System.out.println("2. Process Next Document");
        System.out.println("3. View Pending Documents");
        System.out.println("4. View Processed Documents");
        System.out.println("5. Exit");
        System.out.print("Enter choice: ");
    }
}
