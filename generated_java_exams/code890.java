/*
 * Exam Question #890
 * Generated on: 2025-05-12 16:55:30
 * Generated by: Account 3
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Customer Service Request Management System
 * 
 * **Scenario:**
 * 
 * A small IT support company needs a simple command-line application to manage incoming customer service requests. Requests arrive sequentially and need to be processed in the order they are received. The system should allow users (support agents) to add new requests, process the next pending request, view the history of completed requests, and view the queue of pending requests.
 * 
 * **Requirements:**
 * 
 * Implement a Java program that fulfills the following requirements:
 * 
 * 1.  **Data Structures:**
 *     *   Use a `java.util.Queue` to store pending service requests. Requests should be processed in First-In, First-Out (FIFO) order.
 *     *   Use a `java.util.ArrayList` to store a history of completed service requests.
 *     *   Declare the history collection variable using the `java.util.List` interface type.
 * 
 * 2.  **Service Request Representation:**
 *     *   Create a class `ServiceRequest` with appropriate fields to represent a single request (e.g., a unique ID, a description of the problem, and a status like "Pending" or "Completed").
 *     *   Implement proper encapsulation for the `ServiceRequest` class (private fields, public getter methods).
 * 
 * 3.  **Request Management Logic:**
 *     *   Create a class `RequestManager` that encapsulates the `Queue` of pending requests and the `List` of completed requests.
 *     *   Implement methods in `RequestManager` for:
 *         *   `addRequest(String description)`: Creates a new `ServiceRequest` with status "Pending", assigns a unique ID (a simple counter starting from 1 is sufficient), and adds it to the pending queue.
 *         *   `processNextRequest()`: Removes the next request from the pending queue, updates its status to "Completed", and adds it to the completed history list. This method should handle the case where the queue is empty.
 *         *   `getPendingRequests()`: Returns a `List` (or similar collection view) of pending requests.
 *         *   `getCompletedRequests()`: Returns a `List` of completed requests.
 * 
 * 4.  **User Interface:**
 *     *   Use `java.util.Scanner` to get user input from the console.
 *     *   Implement a main application loop that presents the following menu to the user:
 *         ```
 *         Customer Service Request System
 *         1. Add New Request
 *         2. Process Next Pending Request
 *         3. View Pending Requests
 *         4. View Completed Requests
 *         5. Exit
 *         Enter your choice:
 *         ```
 *     *   Use a `switch` statement to handle the user's menu choice.
 * 
 * 5.  **Input Handling and Validation:**
 *     *   Validate user input for the menu choice. If the input is not a valid integer or is outside the range of menu options, display an error message.
 *     *   For adding a request, prompt the user for the request description. Ensure the description is not empty.
 * 
 * 6.  **Output:**
 *     *   Use `System.out.println()` for displaying the menu, prompts, request details, and successful operations.
 *     *   Use `System.err.println()` for displaying error messages (e.g., invalid input, processing an empty queue, empty lists).
 * 
 * 7.  **Error Handling:**
 *     *   Implement **class-wide exception handling** using a `try-catch` block that wraps the main application logic (the menu loop and interaction with the `RequestManager`). This block should catch general exceptions and print an error message using `System.err`.
 *     *   Implement specific checks within methods (e.g., checking if the queue is empty before processing) and use `System.err` for reporting these specific operational issues, even if they don't throw exceptions.
 * 
 * 8.  **Best Practices:**
 *     *   Use meaningful variable and method names.
 *     *   Add comments to explain complex parts of the code.
 *     *   Ensure proper indentation and code formatting.
 * 
 * **Expected Output:**
 * 
 * The program should interact with the user via the console, displaying the menu, accepting input, and printing relevant information or error messages based on the user's actions. Examples:
 * 
 * *   Adding a request: Prompt for description, confirm addition with ID.
 * *   Processing request: Confirm which request was processed or indicate an empty queue.
 * *   Viewing lists: Print details of requests in the respective list/queue, or indicate if the list/queue is empty.
 * *   Invalid input: Print an error message to `System.err`.
 * *   General error: Print a general error message to `System.err` if an unexpected exception occurs.
 * 
 * **Deliverable:**
 * 
 * Provide the complete Java code for the solution.
 *
 * EXPLANATION:
 * This solution implements a simple Customer Service Request Management System as described in the problem statement, demonstrating the required Java concepts and best practices.
 * 
 * 1.  **`ServiceRequest` Class:**
 *     *   Represents a single request with `id`, `description`, and `status`.
 *     *   Uses `private` fields and `public` getters for encapsulation.
 *     *   Includes a `setStatus` method for controlled modification of the status.
 *     *   `toString()` method provides a convenient string representation for printing.
 * 
 * 2.  **`RequestManager` Class:**
 *     *   Holds the core data structures:
 *         *   `pendingRequests`: A `Queue<ServiceRequest>` implemented using `LinkedList`. `Queue` is used because requests are processed in FIFO order (first come, first served). The `offer()` method is used to add elements, and `poll()` is used to remove and retrieve the head.
 *         *   `completedRequests`: A `List<ServiceRequest>` implemented using `ArrayList`. `ArrayList` is suitable for storing a history where elements are added at the end and retrieved by iterating. The variable is declared using the `List` interface type, demonstrating programming to the interface.
 *     *   `nextRequestId`: A simple counter to generate unique IDs for requests.
 *     *   `addRequest()`: Creates a new `ServiceRequest`, increments the ID counter, and adds the request to the `pendingRequests` queue using `offer()`. Includes basic validation for the description.
 *     *   `processNextRequest()`: Uses `poll()` to get the next request from the queue. If `poll()` returns `null`, it means the queue is empty, and an error message is printed to `System.err`. Otherwise, the request's status is updated, and it's added to the `completedRequests` list using `add()`.
 *     *   `getPendingRequests()` and `getCompletedRequests()`: Provide access to the request lists. `getPendingRequests()` returns a *copy* (new `ArrayList`) of the elements currently in the queue to avoid external code directly modifying the internal queue structure. `getCompletedRequests()` returns a reference to the internal `ArrayList` (for simplicity in this example, though returning an unmodifiable list would be safer in a larger application). Both return types are declared as `List`, fulfilling that requirement.
 * 
 * 3.  **`ServiceSystem` Class (Main Application):**
 *     *   Contains the `main` method where execution begins.
 *     *   **Class-wide Exception Handling:** The core `while` loop and `Scanner` initialization are wrapped in a `try-catch(Exception e)` block. This catches any unexpected runtime errors that might occur within the main application flow and prints a general error message to `System.err`, fulfilling the requirement for class-wide handling.
 *     *   **Scanner Input:** A `Scanner` is used to read user input from `System.in`.
 *     *   **Menu and Switch:** The `printMenu()` method displays options. The main loop reads the user's integer choice. A `try-catch(InputMismatchException e)` is specifically used around `scanner.nextInt()` to handle cases where the user enters non-integer input, printing an error to `System.err` and consuming the invalid input to prevent an infinite loop. A `switch` statement is then used to direct the program flow based on the valid integer choice.
 *     *   **Menu Options:** Each `case` in the `switch` calls the appropriate method in the `RequestManager` and handles the output, including checking if lists/queues are empty before attempting to print contents.
 *     *   **System.out and System.err:** `System.out` is used for menu, prompts, and normal operation messages. `System.err` is used for invalid input, operational errors (like processing an empty queue), and the general exception catch.
 *     *   **Input Validation:** Basic validation is done for the menu choice (within the `switch` `default` case) and for the request description (in `RequestManager.addRequest`).
 *     *   **Resource Management:** The `Scanner` is closed before the program exits.
 * 
 * This solution effectively integrates all the required Java components (`Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.err`, `System.out`, `try-catch`) into a cohesive, practical application while adhering to good programming practices like encapsulation, meaningful names, and basic error handling.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.InputMismatchException;

// Represents a single customer service request
class ServiceRequest {
    private int id;
    private String description;
    private String status; // e.g., "Pending", "Completed"

    public ServiceRequest(int id, String description) {
        this.id = id;
        this.description = description;
        this.status = "Pending"; // Default status
    }

    // Getters
    public int getId() {
        return id;
    }

    public String getDescription() {
        return description;
    }

    public String getStatus() {
        return status;
    }

    // Method to update status (controlled update)
    public void setStatus(String status) {
        this.status = status;
    }

    @Override
    public String toString() {
        return "Request [ID=" + id + ", Status=" + status + ", Description='" + description + "']";
    }
}

// Manages the queue of pending requests and list of completed requests
class RequestManager {
    private Queue<ServiceRequest> pendingRequests;
    private List<ServiceRequest> completedRequests;
    private int nextRequestId; // Counter for unique IDs

    public RequestManager() {
        // LinkedList is a common implementation for Queue
        this.pendingRequests = new LinkedList<>();
        // ArrayList for completed requests history
        this.completedRequests = new ArrayList<>();
        this.nextRequestId = 1; // Start ID from 1
    }

    /**
     * Adds a new service request to the pending queue.
     * @param description The description of the service request.
     */
    public void addRequest(String description) {
        if (description == null || description.trim().isEmpty()) {
            System.err.println("Error: Request description cannot be empty.");
            return;
        }
        ServiceRequest newRequest = new ServiceRequest(nextRequestId++, description.trim());
        pendingRequests.offer(newRequest); // offer is preferred over add for capacity-constrained queues, though LinkedList is not capacity-constrained
        System.out.println("Added request: " + newRequest);
    }

    /**
     * Processes the next request in the pending queue.
     * Moves the request from pending to completed list.
     */
    public void processNextRequest() {
        ServiceRequest requestToProcess = pendingRequests.poll(); // Retrieves and removes the head of the queue
        if (requestToProcess == null) {
            System.err.println("No pending requests to process.");
        } else {
            requestToProcess.setStatus("Completed");
            completedRequests.add(requestToProcess);
            System.out.println("Processed request: " + requestToProcess);
        }
    }

    /**
     * Gets an unmodifiable view of the pending requests.
     * @return A List of pending requests.
     */
    public List<ServiceRequest> getPendingRequests() {
        // Returning a new ArrayList prevents external modification of the internal queue state
        // For a queue, iterating might be better, but returning a List fulfills the List requirement
        // A better approach might be returning Collections.unmodifiableList(new ArrayList<>(pendingRequests));
        // But for simplicity and demonstrating List usage:
         return new ArrayList<>(pendingRequests); // Copies elements to a new list
    }

     /**
     * Gets an unmodifiable view of the completed requests.
     * @return A List of completed requests.
     */
    public List<ServiceRequest> getCompletedRequests() {
        // Returning the internal list directly is okay if it's only for reading.
        // To prevent external modification: return Collections.unmodifiableList(completedRequests);
        // For this problem's scope, returning the list reference is acceptable.
        return completedRequests;
    }

    /**
     * Checks if there are any pending requests.
     * @return true if the pending queue is empty, false otherwise.
     */
    public boolean isPendingQueueEmpty() {
        return pendingRequests.isEmpty();
    }

    /**
     * Checks if there are any completed requests.
     * @return true if the completed list is empty, false otherwise.
     */
     public boolean isCompletedListEmpty() {
        return completedRequests.isEmpty();
    }
}

// Main application class
public class ServiceSystem {

    public static void main(String[] args) {
        // Class-wide exception handling
        try {
            RequestManager manager = new RequestManager();
            Scanner scanner = new Scanner(System.in);
            boolean running = true;

            while (running) {
                printMenu();
                int choice = -1;
                try {
                    System.out.print("Enter your choice: ");
                    choice = scanner.nextInt();
                    scanner.nextLine(); // Consume newline left-over

                    // Use switch statement for menu navigation
                    switch (choice) {
                        case 1: // Add New Request
                            System.out.print("Enter request description: ");
                            String description = scanner.nextLine();
                            manager.addRequest(description);
                            break;
                        case 2: // Process Next Pending Request
                            manager.processNextRequest();
                            break;
                        case 3: // View Pending Requests
                            List<ServiceRequest> pending = manager.getPendingRequests(); // Using List interface
                            if (pending.isEmpty()) {
                                System.out.println("No pending requests.");
                            } else {
                                System.out.println("\n--- Pending Requests ---");
                                for (ServiceRequest req : pending) {
                                    System.out.println(req);
                                }
                                System.out.println("------------------------\n");
                            }
                            break;
                        case 4: // View Completed Requests
                            List<ServiceRequest> completed = manager.getCompletedRequests(); // Using List interface
                            if (completed.isEmpty()) {
                                System.out.println("No completed requests.");
                            } else {
                                System.out.println("\n--- Completed Requests ---");
                                for (ServiceRequest req : completed) {
                                    System.out.println(req);
                                }
                                System.out.println("------------------------\n");
                            }
                            break;
                        case 5: // Exit
                            running = false;
                            System.out.println("Exiting system. Goodbye!");
                            break;
                        default: // Invalid choice
                            System.err.println("Invalid choice. Please enter a number between 1 and 5.");
                            break;
                    }
                } catch (InputMismatchException e) {
                    // Handle non-integer input specifically
                    System.err.println("Invalid input. Please enter a number.");
                    scanner.nextLine(); // Consume the invalid input to prevent infinite loop
                }
                // Other potential specific exceptions could be caught here if needed
            }
            scanner.close(); // Close the scanner when done

        } catch (Exception e) {
            // Catch any other unexpected exceptions as class-wide handling
            System.err.println("An unexpected error occurred: " + e.getMessage());
            e.printStackTrace(); // Print stack trace for debugging
        }
    }

    /**
     * Prints the main menu options to the console.
     */
    private static void printMenu() {
        System.out.println("\nCustomer Service Request System");
        System.out.println("1. Add New Request");
        System.out.println("2. Process Next Pending Request");
        System.out.println("3. View Pending Requests");
        System.out.println("4. View Completed Requests");
        System.out.println("5. Exit");
    }
}
