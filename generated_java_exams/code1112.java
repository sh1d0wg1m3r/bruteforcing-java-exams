/*
 * Exam Question #1112
 * Generated on: 2025-05-12 17:26:38
 * Generated by: Account 1
 * 
 * QUESTION:
 * **Java Programming Exam Task: Advanced Task Scheduler**
 * 
 * **Problem Description:**
 * 
 * Design and implement a command-line based Task Scheduler system. This system will manage tasks that are initially placed in a waiting queue and can be processed one by one, moving them to a completed list. The system should be interactive, allowing the user to perform various operations via a menu.
 * 
 * **Requirements:**
 * 
 * 1.  **Task Representation:** Create a `Task` class to represent a single task. Each task must have:
 *     *   A unique integer ID (auto-generated by the scheduler).
 *     *   A String description.
 *     *   Implement proper encapsulation (private fields with public getters).
 *     *   Override the `toString()` method for easy printing of task details.
 * 
 * 2.  **Scheduler Class:** Create a `TaskScheduler` class that manages the tasks. It must contain:
 *     *   A `Queue` to hold tasks that are waiting to be processed. Use a suitable implementation from `java.util`.
 *     *   A `List` to hold tasks that have been completed. Use `java.util.List` as the interface type and a suitable implementation like `ArrayList`.
 *     *   A `Scanner` object to read user input from the console.
 *     *   A mechanism to generate unique task IDs.
 * 
 * 3.  **Functionality:** The `TaskScheduler` must provide the following operations via a main interactive loop:
 *     *   **Add New Task:** Prompt the user for a task description, create a new `Task` object with the next available ID, and add it to the waiting queue.
 *     *   **Process Next Task:** Remove the task at the front of the waiting queue and add it to the completed tasks list. Handle the case where the waiting queue is empty.
 *     *   **View Waiting Tasks:** Display all tasks currently in the waiting queue without removing them. Handle the case where the waiting queue is empty.
 *     *   **View Completed Tasks:** Display all tasks currently in the completed tasks list. Handle the case where the completed list is empty.
 *     *   **Exit:** Terminate the program.
 * 
 * 4.  **User Interface:**
 *     *   Present a clear menu of options to the user using `System.out`.
 *     *   Read the user's choice using the `Scanner`.
 *     *   Use a `switch` statement to direct program flow based on the user's choice.
 * 
 * 5.  **Error Handling & Input Validation:**
 *     *   Implement class-wide exception handling using `try-catch` blocks within the main interactive loop to gracefully handle unexpected errors.
 *     *   Specifically handle `InputMismatchException` if the user enters non-integer input for the menu choice. Use `System.err` to report this error.
 *     *   Handle cases where the user attempts to process a task from an empty queue or view empty lists/queues. Use `System.out` for informative messages in these cases.
 *     *   Validate user input for the task description (e.g., ensure it's not empty). Use `System.err` for validation errors.
 *     *   Use `System.err` for any other critical errors or invalid user actions (like an invalid menu choice).
 * 
 * 6.  **Best Practices:**
 *     *   Adhere to proper encapsulation.
 *     *   Use meaningful variable and method names.
 *     *   Include appropriate comments and documentation (e.g., Javadoc for classes/methods).
 *     *   Ensure the `Scanner` is properly closed upon program exit.
 *     *   Structure the code cleanly.
 * 
 * **Expected Output:**
 * 
 * The program should display a menu, accept user input, and print status messages or task lists based on the chosen action. Error messages (like invalid input) should be printed to `System.err`, while normal output (menu, task lists, success messages) should go to `System.out`.
 * 
 * Example Interaction Flow:
 * ```
 * --- Task Scheduler Menu ---
 * 1. Add New Task
 * 2. Process Next Task
 * 3. View Waiting Tasks
 * 4. View Completed Tasks
 * 5. Exit
 * ---------------------------
 * Enter your choice: 1
 * Enter task description: Finish exam question
 * Task added: Task ID: 1, Description: Finish exam question
 * 
 * --- Task Scheduler Menu ---
 * ...
 * Enter your choice: 1
 * Enter task description: Review solution
 * Task added: Task ID: 2, Description: Review solution
 * 
 * --- Task Scheduler Menu ---
 * ...
 * Enter your choice: 3
 * --- Waiting Tasks ---
 * 1. Task ID: 1, Description: Finish exam question
 * 2. Task ID: 2, Description: Review solution
 * ---------------------
 * 
 * --- Task Scheduler Menu ---
 * ...
 * Enter your choice: 2
 * Task processed: Task ID: 1, Description: Finish exam question
 * 
 * --- Task Scheduler Menu ---
 * ...
 * Enter your choice: 3
 * --- Waiting Tasks ---
 * 1. Task ID: 2, Description: Review solution
 * ---------------------
 * 
 * --- Task Scheduler Menu ---
 * ...
 * Enter your choice: 4
 * --- Completed Tasks ---
 * 1. Task ID: 1, Description: Finish exam question
 * -----------------------
 * 
 * --- Task Scheduler Menu ---
 * ...
 * Enter your choice: 6
 * Invalid choice. Please enter a number between 1 and 5.
 * 
 * --- Task Scheduler Menu ---
 * ...
 * Enter your choice: abc
 * Invalid input. Please enter a number.
 * 
 * --- Task Scheduler Menu ---
 * ...
 * Enter your choice: 5
 * Exiting Task Scheduler. Goodbye!
 * ```
 * 
 * **Note:** You can implement the `Task` class as a static inner class within `TaskScheduler` for simplicity in a single file solution.
 *
 * EXPLANATION:
 * This solution implements a `TaskScheduler` class that manages tasks using a `Queue` for waiting tasks and a `List` (specifically an `ArrayList`) for completed tasks.
 * 
 * 1.  **`Task` Class:** A private static inner class `Task` is defined to encapsulate task data (`taskId` and `description`). It includes a constructor, public getter methods for its private fields, and an overridden `toString()` method for convenient printing. This demonstrates encapsulation and basic object design.
 * 
 * 2.  **`TaskScheduler` Fields:**
 *     *   `waitingQueue`: Declared as `Queue<Task>` and initialized with `new LinkedList<>()`. `LinkedList` is a common implementation of `Queue` that supports efficient additions and removals from the ends.
 *     *   `completedTasks`: Declared as `List<Task>` and initialized with `new ArrayList<>()`. `ArrayList` is a common implementation of `List` suitable for storing completed items where indexed access or iteration is needed. Using the `List` interface demonstrates polymorphism and good practice.
 *     *   `scanner`: An instance of `Scanner` for reading user input from `System.in`.
 *     *   `nextTaskId`: An integer counter to ensure unique IDs for new tasks.
 * 
 * 3.  **Methods:**
 *     *   `addTask()`: Reads the task description from the user (handling the newline character issue after reading numbers), validates that the description is not empty, creates a new `Task` object with the auto-incremented `nextTaskId`, and adds it to the `waitingQueue` using the `offer()` method.
 *     *   `processNextTask()`: Checks if the `waitingQueue` is empty. If not, it uses `poll()` to retrieve and remove the task at the head of the queue and adds it to the `completedTasks` list using `add()`.
 *     *   `viewWaitingTasks()`: Checks if the `waitingQueue` is empty. If not, it iterates through the queue using an enhanced for loop (which doesn't remove elements) and prints each task.
 *     *   `viewCompletedTasks()`: Checks if the `completedTasks` list is empty. If not, it iterates through the list using an enhanced for loop and prints each task.
 *     *   `displayMenu()`: A helper method to print the menu options to `System.out`.
 *     *   `run()`: This is the main method controlling the application flow. It contains a `while` loop that continues until the user chooses to exit (option 5).
 * 
 * 4.  **Control Flow and Input:**
 *     *   The `run()` method reads the user's integer choice using `scanner.nextInt()`.
 *     *   A `switch` statement is used to execute the corresponding method based on the integer `choice`.
 *     *   The `default` case in the `switch` handles invalid menu numbers.
 * 
 * 5.  **Exception Handling:**
 *     *   A `try-catch (InputMismatchException e)` block is placed around `scanner.nextInt()` to catch non-integer input specifically. It prints an error to `System.err` and consumes the invalid input using `scanner.next()` to prevent an infinite loop.
 *     *   An inner `try-catch (Exception e)` block is placed around the `switch` statement's body. This serves as a "class-wide" handler for any unexpected exceptions that might occur during the execution of the chosen operation (e.g., potential null pointers or other runtime errors, though less likely in this simple scenario). It prints a generic error message to `System.err`.
 *     *   A final `catch (Exception e)` is outside the inner block but inside the main loop's `try`. This catches any other general exceptions that might occur *before* or *after* the inner operation block within a single loop iteration (e.g., if an issue occurred immediately after reading input but before the switch).
 *     *   Specific checks (`waitingQueue.isEmpty()`, `completedTasks.isEmpty()`, `description.isEmpty()`) are used for validation *before* attempting operations, providing user-friendly messages via `System.out` or `System.err` as appropriate, rather than relying solely on exceptions.
 * 
 * 6.  **Best Practices:**
 *     *   Private fields and public methods demonstrate encapsulation.
 *     *   Method and variable names (`addTask`, `waitingQueue`, `nextTaskId`) are descriptive.
 *     *   Javadoc comments explain the purpose of classes and methods.
 *     *   Input validation for description and choice type is included.
 *     *   Error messages are directed to `System.err`.
 *     *   The `Scanner` is closed when the `run()` method exits.
 *     *   The code is structured logically with helper methods.
 * 
 * This solution effectively integrates all required Java components and demonstrates key programming concepts like data structures (`Queue`, `List`, `ArrayList`, `LinkedList`), control flow (`switch`, `while`), object-oriented principles (encapsulation, `toString`), input/output (`Scanner`, `System.out`, `System.err`), and robust error handling (`try-catch`, specific exception handling, input validation).
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.InputMismatchException;

/**
 * A simple command-line based Task Scheduler system.
 * Manages tasks using a waiting queue and a completed list.
 */
public class TaskScheduler {

    /**
     * Represents a single task with an ID and description.
     */
    private static class Task {
        private int taskId;
        private String description;

        /**
         * Constructs a new Task.
         * @param taskId The unique identifier for the task.
         * @param description A brief description of the task.
         */
        public Task(int taskId, String description) {
            this.taskId = taskId;
            this.description = description;
        }

        /**
         * Gets the task ID.
         * @return The task ID.
         */
        public int getTaskId() {
            return taskId;
        }

        /**
         * Gets the task description.
         * @return The task description.
         */
        public String getDescription() {
            return description;
        }

        /**
         * Returns a string representation of the Task.
         * @return A formatted string including task ID and description.
         */
        @Override
        public String toString() {
            return "Task ID: " + taskId + ", Description: " + description;
        }
    }

    // Scheduler fields
    private Queue<Task> waitingQueue; // Using LinkedList which implements Queue
    private List<Task> completedTasks; // Using ArrayList implementing List
    private Scanner scanner;
    private int nextTaskId; // To generate unique IDs

    /**
     * Constructs a new TaskScheduler, initializing data structures and scanner.
     */
    public TaskScheduler() {
        this.waitingQueue = new LinkedList<>(); // Initialize Queue
        this.completedTasks = new ArrayList<>(); // Initialize ArrayList implementing List
        this.scanner = new Scanner(System.in);
        this.nextTaskId = 1; // Start Task IDs from 1
    }

    /**
     * Adds a new task to the waiting queue based on user input.
     * Handles input validation for the description.
     */
    private void addTask() {
        System.out.print("Enter task description: ");
        // Consume the newline character left by previous nextInt() or similar
        scanner.nextLine();
        String description = scanner.nextLine().trim();

        if (description.isEmpty()) {
            System.err.println("Error: Task description cannot be empty.");
            return;
        }

        Task newTask = new Task(nextTaskId++, description);
        waitingQueue.offer(newTask); // offer is generally preferred over add for capacity-constrained queues
        System.out.println("Task added: " + newTask);
    }

    /**
     * Processes the next task from the waiting queue, moving it to the completed list.
     * Handles the case where the queue is empty.
     */
    private void processNextTask() {
        if (waitingQueue.isEmpty()) {
            System.out.println("No tasks in the waiting queue to process.");
            return;
        }

        Task processedTask = waitingQueue.poll(); // Retrieves and removes the head of the queue
        if (processedTask != null) { // poll returns null if queue is empty, but we checked isEmpty()
            completedTasks.add(processedTask);
            System.out.println("Task processed: " + processedTask);
        } else {
             // This case should ideally not be reached due to isEmpty() check, but included for robustness.
             System.err.println("An unexpected error occurred: Queue unexpectedly returned null.");
        }
    }

    /**
     * Displays all tasks currently in the waiting queue without removing them.
     * Handles the case where the queue is empty.
     */
    private void viewWaitingTasks() {
        if (waitingQueue.isEmpty()) {
            System.out.println("No tasks currently in the waiting queue.");
            return;
        }

        System.out.println("--- Waiting Tasks ---");
        // Iterate over the Queue using enhanced for loop
        int index = 1;
        for (Task task : waitingQueue) {
            System.out.println(index++ + ". " + task);
        }
        System.out.println("---------------------");
    }

    /**
     * Displays all tasks currently in the completed list.
     * Handles the case where the list is empty.
     */
    private void viewCompletedTasks() {
        if (completedTasks.isEmpty()) {
            System.out.println("No tasks currently in the completed list.");
            return;
        }

        System.out.println("--- Completed Tasks ---");
        // Iterate over the List (ArrayList) using enhanced for loop
        int index = 1;
        for (Task task : completedTasks) {
            System.out.println(index++ + ". " + task);
        }
        System.out.println("-----------------------");
    }

    /**
     * Runs the main interactive task scheduler loop.
     * Includes menu display, user input handling, switch statement for operations,
     * and class-wide exception handling.
     */
    public void run() {
        int choice = -1;
        while (choice != 5) {
            displayMenu();
            try {
                System.out.print("Enter your choice: ");
                // Attempt to read integer input
                choice = scanner.nextInt();

                // Class-wide exception handling for the core operation execution
                try {
                    switch (choice) {
                        case 1:
                            addTask();
                            break;
                        case 2:
                            processNextTask();
                            break;
                        case 3:
                            viewWaitingTasks();
                            break;
                        case 4:
                            viewCompletedTasks();
                            break;
                        case 5:
                            System.out.println("Exiting Task Scheduler. Goodbye!");
                            break;
                        default:
                            System.err.println("Invalid choice. Please enter a number between 1 and 5.");
                            break;
                    }
                } catch (Exception e) {
                    // Catch any unexpected errors that might occur within the called methods
                    System.err.println("An unexpected error occurred during operation: " + e.getMessage());
                    // Optionally, log the full stack trace during development/debugging
                    // e.printStackTrace();
                }

            } catch (InputMismatchException e) {
                // Handle non-integer input specifically
                System.err.println("Invalid input. Please enter a number.");
                scanner.next(); // Consume the invalid input to prevent infinite loop
                choice = -1; // Reset choice to ensure the loop continues
            } catch (Exception e) {
                 // Catch any other unexpected exceptions during the input reading or menu handling phase
                 System.err.println("An unexpected error occurred: " + e.getMessage());
                 // e.printStackTrace();
                 choice = -1; // Reset choice to ensure the loop continues
            }
            System.out.println(); // Add a newline for better readability between operations
        }

        scanner.close(); // Close the scanner when exiting the loop
    }

    /**
     * Displays the main menu options to the user.
     */
    private void displayMenu() {
        System.out.println("--- Task Scheduler Menu ---");
        System.out.println("1. Add New Task");
        System.out.println("2. Process Next Task");
        System.out.println("3. View Waiting Tasks");
        System.out.println("4. View Completed Tasks");
        System.out.println("5. Exit");
        System.out.println("---------------------------");
    }

    /**
     * Main method to start the Task Scheduler application.
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        TaskScheduler scheduler = new TaskScheduler();
        scheduler.run();
    }
}
