/*
 * Exam Question #504
 * Generated on: 2025-05-11 23:21:31
 * Generated by: Account 5
 * 
 * QUESTION:
 * ## Advanced Java Programming Exam Task: Resource Allocation Simulation
 * 
 * **Scenario:**
 * 
 * You are tasked with building a simplified simulation of a computing resource allocation system. The system manages a pool of available computing units and a queue of job requests waiting for these units. Jobs are processed from the queue on a First-Come, First-Served (FCFS) basis when enough resources are available.
 * 
 * **Entities:**
 * 
 * 1.  **`ComputingUnit`**: Represents a single, identical computing resource. It needs a unique ID.
 * 2.  **`JobRequest`**: Represents a request for computing resources. It needs a unique ID and specifies the number of computing units it requires.
 * 
 * **System Functionality:**
 * 
 * The system should provide a menu-driven interface allowing the user to perform the following operations:
 * 
 * 1.  **Add New Job Request**: Allows the user to submit a new job, specifying the number of units required. This job is added to a waiting queue.
 * 2.  **View Job Queue**: Displays the list of jobs currently waiting in the queue, in the order they will be processed.
 * 3.  **View Available Computing Units**: Displays the total count and IDs of computing units that are currently available for allocation.
 * 4.  **Allocate Units to Next Job**: Attempts to allocate units to the job at the front of the queue. If the number of available units is greater than or equal to the job's requirement, the job is removed from the queue, the required units are marked as allocated (by removing them from the available pool), and the job is moved to a list of "running" jobs. If not enough units are available, the job remains in the queue. If the queue is empty, an appropriate message is displayed.
 * 5.  **Release Units from Completed Job**: Allows the user to specify a Job ID from the list of "running" jobs. If the job is found, its required units are returned to the available pool (by adding new units to the available list representing the released capacity), and the job is removed from the "running" list. If the job ID is not found, an error message is displayed.
 * 6.  **View Running Jobs**: Displays the list of jobs that have been allocated units and are currently running.
 * 7.  **Exit**: Terminates the application.
 * 
 * **Implementation Requirements:**
 * 
 * Your solution must be a single Java application that demonstrates advanced understanding by incorporating **ALL** of the following Java components and best practices:
 * 
 * *   Use `java.util.Queue` (specifically, implement it using `java.util.LinkedList`) to manage the waiting job requests.
 * *   Use `java.util.ArrayList` to manage the pool of available computing units and the list of running jobs.
 * *   Declare variables and method return types that represent collections using the `java.util.List` interface where appropriate (e.g., `List<ComputingUnit> availableUnits`).
 * *   Use `java.util.Scanner` to read user input from the console.
 * *   Use a `switch` statement to control the flow of the main application loop based on user menu choices.
 * *   Use `System.err` to display error messages (e.g., invalid input, job not found, queue empty, not enough units).
 * *   Use `System.out` for all normal output (menu, prompts, status messages, viewing lists/queue).
 * *   Implement class-wide exception handling using `try-catch` blocks, specifically for handling potential input errors (like non-numeric input when expecting a number) and any other runtime issues that might occur during operations.
 * *   Apply best practices including:
 *     *   Proper encapsulation (private fields, public/private methods).
 *     *   Meaningful variable and method names.
 *     *   Appropriate comments and documentation (Javadoc where applicable).
 *     *   Input validation (e.g., ensuring required units are positive, handling non-numeric input).
 *     *   Proper error handling as described above.
 *     *   Clean code structure (e.g., separate methods for distinct functionalities).
 * 
 * **Simplified Unit Management Note:** For this simulation, when units are allocated, simply remove the required number of units from the `availableUnits` list. When units are released, add *new* `ComputingUnit` objects (with new unique IDs) representing the returned capacity back to the `availableUnits` list. You do not need to track which *specific* unit IDs were allocated to which job.
 * 
 * **Initial State:** The system should start with a predefined number of available computing units (e.g., 10).
 * 
 * **Expected Output:** The application should run interactively, displaying the menu, processing user commands, and printing appropriate output or error messages for each operation.
 * 
 * **Example Interaction Flow (Illustrative):**
 * 
 * ```
 * Resource Allocator initialized with 10 computing units.
 * 
 * --- Resource Allocator Menu ---
 * 1. Add New Job Request
 * ...
 * 7. Exit
 * Enter your choice: 1
 * Enter required computing units for the new job: 5
 * Job#1 added to the queue.
 * 
 * --- Resource Allocator Menu ---
 * ...
 * Enter your choice: 1
 * Enter required computing units for the new job: 8
 * Job#2 added to the queue.
 * 
 * --- Resource Allocator Menu ---
 * ...
 * Enter your choice: 2
 * --- Job Queue ---
 * 1. Job#1 (Units: 5)
 * 2. Job#2 (Units: 8)
 * 
 * --- Resource Allocator Menu ---
 * ...
 * Enter your choice: 3
 * --- Available Computing Units ---
 * Total available units: 10
 * Unit IDs: 1, 2, 3, 4, 5, 6, 7, 8, 9, 10
 * 
 * --- Resource Allocator Menu ---
 * ...
 * Enter your choice: 4
 * --- Attempting Allocation ---
 * Successfully allocated 5 units to Job#1 (Units: 5).
 * 5 units remaining available.
 * 
 * --- Resource Allocator Menu ---
 * ...
 * Enter your choice: 6
 * --- Running Jobs ---
 * - Job#1 (Units: 5)
 * 
 * --- Resource Allocator Menu ---
 * ...
 * Enter your choice: 2
 * --- Job Queue ---
 * 1. Job#2 (Units: 8)
 * 
 * --- Resource Allocator Menu ---
 * ...
 * Enter your choice: 3
 * --- Available Computing Units ---
 * Total available units: 5
 * Unit IDs: 6, 7, 8, 9, 10
 * 
 * --- Resource Allocator Menu ---
 * ...
 * Enter your choice: 4
 * --- Attempting Allocation ---
 * Not enough units available (5) for Job#2 (Units: 8) which requires 8.
 * Job remains in the queue.
 * 
 * --- Resource Allocator Menu ---
 * ...
 * Enter your choice: 5
 * Enter Job ID to release units from: 1
 * Successfully released 5 units from Job#1.
 * 10 units now available.
 * 
 * --- Resource Allocator Menu ---
 * ...
 * Enter your choice: 6
 * --- Running Jobs ---
 * No jobs are currently running.
 * 
 * --- Resource Allocator Menu ---
 * ...
 * Enter your choice: 3
 * --- Available Computing Units ---
 * Total available units: 10
 * Unit IDs: 6, 7, 8, 9, 10, 11, 12, 13, 14, 15
 * 
 * --- Resource Allocator Menu ---
 * ...
 * Enter your choice: 4
 * --- Attempting Allocation ---
 * Successfully allocated 8 units to Job#2 (Units: 8).
 * 2 units remaining available.
 * 
 * --- Resource Allocator Menu ---
 * ...
 * Enter your choice: 7
 * Exiting Resource Allocator. Goodbye!
 * ```
 * 
 * Your solution should be provided as a single `.java` file containing all necessary classes.
 *
 * EXPLANATION:
 * The provided solution implements a simplified Resource Allocation Simulation system, demonstrating the use of various core Java concepts as required by the exam task.
 * 
 * 1.  **Scenario and Entities:**
 *     *   `ComputingUnit` and `JobRequest` classes are simple Plain Old Java Objects (POJOs) representing the core entities, each with an ID and relevant data (`requiredUnits` for `JobRequest`). They use private fields and public getters, adhering to encapsulation.
 * 
 * 2.  **Data Structures:**
 *     *   `jobQueue`: Declared as `Queue<JobRequest>` and implemented using `LinkedList`. This correctly models the First-Come, First-Served nature of waiting jobs. Methods like `offer()`, `peek()`, and `poll()` are used for queue operations.
 *     *   `availableUnits`: Declared as `List<ComputingUnit>` and implemented using `ArrayList`. This list holds the units ready for allocation. `size()` is used to check availability, `remove(0)` simulates allocating a unit (removing from the list), and `addAll()` is used to add released units back.
 *     *   `runningJobs`: Declared as `List<JobRequest>` and implemented using `ArrayList`. This list tracks jobs that have successfully been allocated units. `add()` is used when a job starts running, and `remove()` is used when units are released.
 * 
 * 3.  **Control Flow and User Interaction:**
 *     *   `Scanner`: An instance is created and used throughout the `ResourceAllocator` class (`run`, `addJob`, `releaseUnits`) to read input from `System.in`.
 *     *   `switch` statement: Located in the `run()` method, it directs the program flow to the appropriate method based on the user's menu choice.
 *     *   `System.out` and `System.err`: `System.out.println()` and `System.out.print()` are used for displaying the menu, prompts, successful operation messages, and viewing the contents of the queue and lists. `System.err.println()` is used specifically for displaying error conditions, such as invalid input, attempting to allocate from an empty queue, not finding a job to release, or insufficient units.
 * 
 * 4.  **Exception Handling:**
 *     *   `try-catch` blocks are used to handle potential runtime exceptions.
 *     *   In `run()`, a `try-catch(InputMismatchException)` block handles cases where the user enters non-integer input for the menu choice, preventing the program from crashing and prompting the user to try again. A general `catch(Exception)` is also included for unexpected errors.
 *     *   In `addJob()` and `releaseUnits()`, `try-catch(NumberFormatException)` blocks are used around `Integer.parseInt()` to handle cases where the user enters non-numeric input when prompted for required units or a job ID.
 *     *   The `allocateUnitsToNextJob()` method includes a `try-catch(IndexOutOfBoundsException)` as a defensive measure around the `availableUnits.remove(0)` calls, although the logic is designed to prevent this exception under normal operation.
 *     *   A top-level `try-catch(Exception)` block is placed in the `main()` method to catch any unhandled exceptions that might occur during the application's initialization or main execution loop, providing a robust exit mechanism.
 * 
 * 5.  **Best Practices:**
 *     *   **Encapsulation:** Fields in all classes (`id`, `requiredUnits`, collections, scanner, counters) are `private`. Access is provided via public or private methods as needed.
 *     *   **Naming:** Variable names (`jobQueue`, `availableUnits`, `runningJobs`, `nextJobId`, `requiredUnits`, `allocatedJob`, etc.) and method names (`addJob`, `viewQueue`, `allocateUnitsToNextJob`, `releaseUnits`, `findRunningJobById`) are descriptive and follow Java conventions.
 *     *   **Comments and Documentation:** Javadoc comments explain the purpose of classes and methods, while inline comments clarify specific logic steps, especially around data structure operations and error handling.
 *     *   **Input Validation:** Input for required units is checked to be positive. Input parsing (`Integer.parseInt`) is enclosed in `try-catch` to handle non-numeric strings.
 *     *   **Error Handling:** A combination of `if` checks (`isEmpty`, `size >= required`, `jobToRelease == null`), `System.err` messages, and `try-catch` blocks ensures various error conditions are detected and reported gracefully without crashing the application.
 *     *   **Clean Code Structure:** The logic is divided into small, focused methods (`addJob`, `viewQueue`, `allocateUnitsToNextJob`, etc.), making the code modular and easier to understand. The `main` method is kept clean, primarily responsible for setting up the application and starting the main loop.
 * 
 * The simplified unit management (removing from the list and adding new units back) is handled as specified, using `availableUnits.remove(0)` and `availableUnits.addAll(released)`. The `findRunningJobById` helper method demonstrates iterating through a `List` to find a specific element.
 * 
 * Overall, the solution effectively integrates the required Java components within a practical simulation, demonstrating competence in data structures, control flow, input/output, and robust error handling.
 */

package com.example.resourceallocator;

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.InputMismatchException;

/**
 * Represents a single computing unit resource with a unique ID.
 */
class ComputingUnit {
    private int id;

    /**
     * Constructs a ComputingUnit with the given ID.
     * @param id The unique ID for the unit.
     */
    public ComputingUnit(int id) {
        this.id = id;
    }

    /**
     * Gets the ID of the computing unit.
     * @return The unit's ID.
     */
    public int getId() {
        return id;
    }

    /**
     * Returns a string representation of the ComputingUnit.
     * @return A string like "Unit#X".
     */
    @Override
    public String toString() {
        return "Unit#" + id;
    }
}

/**
 * Represents a job request requiring a specific number of computing units.
 */
class JobRequest {
    private int id;
    private int requiredUnits;

    /**
     * Constructs a JobRequest with the given ID and required units.
     * @param id The unique ID for the job.
     * @param requiredUnits The number of units required by the job.
     */
    public JobRequest(int id, int requiredUnits) {
        this.id = id;
        this.requiredUnits = requiredUnits;
    }

    /**
     * Gets the ID of the job request.
     * @return The job's ID.
     */
    public int getId() {
        return id;
    }

    /**
     * Gets the number of units required by the job.
     * @return The required unit count.
     */
    public int getRequiredUnits() {
        return requiredUnits;
    }

    /**
     * Returns a string representation of the JobRequest.
     * @return A string like "Job#X (Units: Y)".
     */
    @Override
    public String toString() {
        return "Job#" + id + " (Units: " + requiredUnits + ")";
    }
}

/**
 * Manages job requests and computing unit allocation in a simulated environment.
 * Uses Queue for waiting jobs, List for available units and running jobs.
 * Provides a menu-driven interface.
 */
public class ResourceAllocator {

    // Queue to hold jobs waiting for resources (FIFO)
    private Queue<JobRequest> jobQueue = new LinkedList<>();

    // List to hold computing units that are currently available
    private List<ComputingUnit> availableUnits = new ArrayList<>();

    // List to hold jobs that have been allocated units and are currently running
    private List<JobRequest> runningJobs = new ArrayList<>();

    // Counters for assigning unique IDs to jobs and units
    private int nextJobId = 1;
    private int nextUnitId = 1; // For assigning IDs to new units created upon release

    // Scanner for reading user input
    private Scanner scanner;

    /**
     * Constructs a ResourceAllocator with a given number of initial computing units.
     * Initializes the available units list with unique IDs.
     * @param totalUnits The initial number of computing units available. Must be non-negative.
     */
    public ResourceAllocator(int totalUnits) {
        if (totalUnits < 0) {
             System.err.println("Warning: Initial total units cannot be negative. Setting to 0.");
             totalUnits = 0;
        }
        // Populate the availableUnits list with initial units
        for (int i = 0; i < totalUnits; i++) {
            availableUnits.add(new ComputingUnit(nextUnitId++));
        }
        scanner = new Scanner(System.in); // Initialize scanner
        System.out.println("Resource Allocator initialized with " + totalUnits + " computing units.");
    }

    /**
     * Displays the main menu options to the user using System.out.
     */
    private void displayMenu() {
        System.out.println("\n--- Resource Allocator Menu ---");
        System.out.println("1. Add New Job Request");
        System.out.println("2. View Job Queue");
        System.out.println("3. View Available Computing Units");
        System.out.println("4. Allocate Units to Next Job");
        System.out.println("5. Release Units from Completed Job");
        System.out.println("6. View Running Jobs");
        System.out.println("7. Exit");
        System.out.print("Enter your choice: ");
    }

    /**
     * Runs the main application loop. Displays the menu, reads user input,
     * processes menu choices using a switch statement, and handles input-related exceptions
     * using try-catch blocks. Continues until the user chooses to exit.
     */
    public void run() {
        int choice = -1;
        // Main application loop continues until user chooses to exit (option 7)
        while (choice != 7) {
            displayMenu();
            try {
                // Read user choice as an integer
                choice = scanner.nextInt();
                // Consume the newline character left by nextInt() to prevent issues with subsequent nextLine() calls
                scanner.nextLine();

                // Use a switch statement to handle different menu options
                switch (choice) {
                    case 1:
                        addJob(); // Add a new job request
                        break;
                    case 2:
                        viewQueue(); // View the waiting job queue
                        break;
                    case 3:
                        viewAvailableUnits(); // View currently available units
                        break;
                    case 4:
                        allocateUnitsToNextJob(); // Attempt to allocate units to the next job in queue
                        break;
                    case 5:
                        releaseUnits(); // Release units from a completed job
                        break;
                     case 6:
                        viewRunningJobs(); // View jobs currently using resources
                        break;
                    case 7:
                        System.out.println("Exiting Resource Allocator. Goodbye!");
                        break;
                    default:
                        // Handle invalid menu choices using System.err
                        System.err.println("Invalid choice. Please enter a number between 1 and 7.");
                }
            } catch (InputMismatchException e) {
                // Handle cases where the user enters non-integer input for the menu choice
                System.err.println("Invalid input. Please enter a number.");
                // Consume the invalid input to prevent an infinite loop
                scanner.nextLine();
                choice = -1; // Reset choice to ensure the loop continues
            } catch (Exception e) {
                 // Catch any other unexpected exceptions during the loop execution
                 System.err.println("An unexpected error occurred: " + e.getMessage());
                 e.printStackTrace(); // Print stack trace for debugging purposes
            }
        }
        // Close the scanner when the application exits to release system resources
        scanner.close();
    }

    /**
     * Prompts the user for job details (required units) and adds a new JobRequest
     * to the waiting queue. Handles potential input errors using try-catch and
     * validates the input using System.err.
     */
    private void addJob() {
        System.out.print("Enter required computing units for the new job: ");
        try {
            // Read the required units as a string first for robust parsing
            String unitsStr = scanner.nextLine();
            // Attempt to parse the string into an integer
            int requiredUnits = Integer.parseInt(unitsStr);

            // Validate that the required units is a positive number
            if (requiredUnits <= 0) {
                System.err.println("Required units must be a positive number.");
                return; // Exit the method if validation fails
            }

            // Create a new JobRequest object with a unique ID
            JobRequest newJob = new JobRequest(nextJobId++, requiredUnits);
            // Add the new job to the end of the queue using offer()
            jobQueue.offer(newJob);
            System.out.println("Job#" + newJob.getId() + " added to the queue.");

        } catch (NumberFormatException e) {
            // Handle cases where the input string cannot be parsed into an integer
            System.err.println("Invalid input. Please enter a valid number for units.");
        } catch (Exception e) {
             // Catch any other unexpected exceptions during job addition
             System.err.println("An error occurred while adding job: " + e.getMessage());
        }
    }

    /**
     * Displays the current job queue contents using System.out.
     * If the queue is empty, prints a message.
     */
    private void viewQueue() {
        System.out.println("\n--- Job Queue ---");
        // Check if the queue is empty
        if (jobQueue.isEmpty()) {
            System.out.println("Queue is empty.");
        } else {
            // Iterate through the queue elements and print them using the Queue's iterator (doesn't remove)
            int index = 1;
            for (JobRequest job : jobQueue) {
                System.out.println(index++ + ". " + job);
            }
        }
    }

     /**
     * Displays the jobs that are currently running (have been allocated units)
     * using System.out. If no jobs are running, prints a message.
     */
    private void viewRunningJobs() {
        System.out.println("\n--- Running Jobs ---");
        // Check if there are any running jobs
        if (runningJobs.isEmpty()) {
            System.out.println("No jobs are currently running.");
        } else {
            // Iterate through the list of running jobs and print them
            for (JobRequest job : runningJobs) {
                System.out.println("- " + job);
            }
        }
    }

    /**
     * Displays the number of currently available computing units and their IDs
     * using System.out.
     */
    private void viewAvailableUnits() {
        System.out.println("\n--- Available Computing Units ---");
        // Print the total count of available units using the List's size() method
        System.out.println("Total available units: " + availableUnits.size());
        // If there are units, print their IDs
        if (!availableUnits.isEmpty()) {
            System.out.print("Unit IDs: ");
            // Iterate through the List and print IDs, formatting with commas
            for (int i = 0; i < availableUnits.size(); i++) {
                System.out.print(availableUnits.get(i).getId() + (i < availableUnits.size() - 1 ? ", " : ""));
            }
            System.out.println(); // Newline after printing IDs
        }
    }

    /**
     * Attempts to allocate units to the next job at the front of the queue.
     * Checks if enough units are available using the availableUnits List size.
     * If successful, the job is moved from the jobQueue to the runningJobs List,
     * and units are removed from the availableUnits List. Prints status messages
     * using System.out and error/failure messages using System.err where appropriate.
     */
    private void allocateUnitsToNextJob() {
        System.out.println("\n--- Attempting Allocation ---");
        // Check if the job queue is empty using Queue's isEmpty()
        if (jobQueue.isEmpty()) {
            System.err.println("Job queue is empty. No jobs to allocate."); // Use System.err for this failure state
            return; // Exit if no jobs are waiting
        }

        // Peek at the next job in the queue without removing it using Queue's peek()
        JobRequest nextJob = jobQueue.peek();
        if (nextJob == null) {
             // This case should ideally not be reached if jobQueue.isEmpty() is false, but defensive coding
             System.err.println("Error: Could not retrieve next job from queue.");
             return;
        }

        int required = nextJob.getRequiredUnits(); // Units required by the next job
        int available = availableUnits.size(); // Units currently available using List's size()

        // Check if there are enough units available for the job
        if (available >= required) {
            // Enough units available, proceed with allocation

            // Remove the job from the front of the queue using Queue's poll()
            JobRequest allocatedJob = jobQueue.poll();
             if (allocatedJob == null) {
                 // Should not happen given the peek() and isEmpty() checks, but defensive
                 System.err.println("Error: Could not remove job from queue during allocation.");
                 return;
            }

            // Simulate allocating units by removing the required number from the available list.
            // This simplified model removes units from the list but doesn't track which specific units
            // are assigned to which job. Remove from index 0 for simplicity.
            try {
                for(int i = 0; i < required; i++) {
                    // Remove units from the beginning of the availableUnits list using List's remove(index)
                    availableUnits.remove(0);
                }
            } catch (IndexOutOfBoundsException e) {
                 // This catch block is a safeguard; the 'available >= required' check
                 // should prevent this in normal operation.
                 System.err.println("Internal Error: Index out of bounds while removing units.");
                 // Basic recovery: attempt to put the job back in the queue
                 jobQueue.offer(allocatedJob);
                 // Note: Recovering specific units removed before error is complex in this model.
                 return;
            }


            // Move the allocated job to the list of running jobs using List's add()
            runningJobs.add(allocatedJob);
            System.out.println("Successfully allocated " + required + " units to " + allocatedJob + ".");
            System.out.println(availableUnits.size() + " units remaining available.");

        } else {
            // Not enough units available, print message using System.out
            System.out.println("Not enough units available (" + available + ") for " + nextJob + " which requires " + required + ".");
            System.out.println("Job remains in the queue.");
        }
    }

    /**
     * Releases units from a job that has completed, based on its Job ID.
     * Units are returned to the available pool. Finds the job in the runningJobs
     * list using a helper method. Handles potential input errors using try-catch
     * and job not found cases using System.err.
     */
    private void releaseUnits() {
        System.out.print("Enter Job ID to release units from: ");
        try {
            // Read the Job ID as a string first for robust parsing
            String jobIdStr = scanner.nextLine();
            // Attempt to parse the string into an integer
            int jobId = Integer.parseInt(jobIdStr);

            // Find the job in the list of running jobs by its ID using a helper method
            JobRequest jobToRelease = findRunningJobById(jobId);

            // Check if the job was found in the running jobs list
            if (jobToRelease == null) {
                System.err.println("Job with ID " + jobId + " not found in the list of running jobs.");
                return; // Exit if job not found
            }

            int releasedUnitsCount = jobToRelease.getRequiredUnits(); // Get the number of units to release

            // Simulate releasing units by adding new unit objects to the available list.
            // This represents the computing capacity being freed up.
            List<ComputingUnit> released = new ArrayList<>(); // Use ArrayList for temporarily holding released units
             for (int i = 0; i < releasedUnitsCount; i++) {
                 released.add(new ComputingUnit(nextUnitId++)); // Create new unit objects with unique IDs
             }
             availableUnits.addAll(released); // Add the released units to the available pool using List's addAll()

            // Remove the job from the list of running jobs using List's remove()
            runningJobs.remove(jobToRelease);

            System.out.println("Successfully released " + releasedUnitsCount + " units from Job#" + jobId + ".");
            System.out.println(availableUnits.size() + " units now available.");

        } catch (NumberFormatException e) {
            // Handle cases where the input string for Job ID cannot be parsed
            System.err.println("Invalid input. Please enter a valid Job ID number.");
        } catch (Exception e) {
             // Catch any other unexpected exceptions during unit release
             System.err.println("An error occurred while releasing units: " + e.getMessage());
        }
    }

    /**
     * Helper method to search for a JobRequest in the runningJobs list by its ID.
     * Iterates through the List to find the matching job.
     * @param jobId The ID of the job to find.
     * @return The JobRequest object if found, otherwise null.
     */
    private JobRequest findRunningJobById(int jobId) {
        // Iterate through the runningJobs list to find the job with the matching ID
        for (JobRequest job : runningJobs) { // Uses List iteration
            if (job.getId() == jobId) {
                return job; // Return the job if found
            }
        }
        return null; // Return null if no job with the given ID is found
    }

    /**
     * Main method to start the Resource Allocator application.
     * Initializes the allocator with a predefined number of units and runs the main loop.
     * Includes a top-level try-catch for critical application errors during setup or execution.
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        // Define the initial number of computing units available
        final int INITIAL_UNITS = 10;

        // Use a try-catch block to handle potential exceptions during application startup or execution
        try {
             // Create an instance of the ResourceAllocator with initial units
             ResourceAllocator allocator = new ResourceAllocator(INITIAL_UNITS);
             // Start the main application loop
             allocator.run();
        } catch (Exception e) {
             // Catch any critical exceptions that weren't handled elsewhere and print to System.err
             System.err.println("Application encountered a critical error: " + e.getMessage());
             e.printStackTrace(); // Print the stack trace for debugging
        }
    }
}
