/*
 * Exam Question #1002
 * Generated on: 2025-05-12 17:11:19
 * Generated by: Account 5
 * 
 * QUESTION:
 * **Exam Task: Hospital Appointment Queue Management System**
 * 
 * You are tasked with creating a simplified hospital system to manage patient waiting queues for appointments. The system should allow registering new patients, adding registered patients to a waiting queue, simulating a doctor seeing the next patient, and displaying the current waiting list.
 * 
 * Your solution must demonstrate advanced understanding of Java collections, input handling, control flow, and error management.
 * 
 * **Requirements:**
 * 
 * 1.  **Data Structures:**
 *     *   Use a `java.util.Queue` to manage the patient waiting list. Patients should be processed in a First-In, First-Out (FIFO) manner.
 *     *   Use a `java.util.ArrayList` to maintain a list of all registered patients in the system.
 *     *   Use the `java.util.List` interface when declaring variables that hold the `ArrayList` instances, adhering to good practice (programming to interfaces).
 * 2.  **User Interaction:**
 *     *   Use `java.util.Scanner` to get user input for menu choices and patient names.
 * 3.  **Control Flow:**
 *     *   Implement a main menu loop that continuously prompts the user for actions until they choose to exit.
 *     *   Use a `switch` statement to handle the different menu options.
 * 4.  **Output:**
 *     *   Use `System.out` for displaying the menu, successful operation messages, and list/queue contents.
 *     *   Use `System.err` for displaying error messages (e.g., invalid input, patient not found, queue empty).
 * 5.  **Error Handling:**
 *     *   Implement robust input validation. Handle cases where the user enters non-numeric input for menu choices.
 *     *   Handle cases where a user tries to add a patient to the queue who is not registered.
 *     *   Handle cases where a doctor tries to see a patient when the queue is empty.
 *     *   Implement class-wide exception handling using `try-catch` blocks to gracefully handle unexpected issues, particularly around user input.
 * 6.  **Best Practices:**
 *     *   Employ proper encapsulation: Declare collection fields as `private`.
 *     *   Use meaningful variable and method names (e.g., `waitingQueue`, `registeredPatients`, `registerPatient`, `addToWaitingList`, `seeNextPatient`).
 *     *   Include appropriate comments and basic documentation (like Javadoc comments for methods).
 *     *   Structure the code logically with separate methods for different functionalities (e.g., displaying menu, handling each option).
 * 
 * **Functionality Details:**
 * 
 * *   **Register Patient:** Prompt for a patient name and add them to the list of registered patients. Prevent duplicate registrations (optional, but good practice - for this exam, simple addition is sufficient).
 * *   **Add to Waiting List:** Prompt for a patient name. Check if the patient is registered. If yes, add them to the waiting queue. If not, display an error using `System.err`.
 * *   **See Next Patient:** Simulate a doctor taking the next patient from the front of the waiting queue. If the queue is empty, display an error using `System.err`. Otherwise, display the name of the patient being seen.
 * *   **Display Waiting List:** Show the current patients in the waiting queue, in order. If the queue is empty, indicate that.
 * *   **List All Registered Patients:** Display the list of all patients who have been registered.
 * *   **Exit:** Terminate the program.
 * 
 * **Expected Output Structure:**
 * 
 * ```
 * --- Hospital Scheduler Menu ---
 * 1. Register Patient
 * 2. Add Patient to Waiting List
 * 3. See Next Patient
 * 4. Display Waiting List
 * 5. List All Registered Patients
 * 6. Exit
 * Enter your choice: [user input]
 * 
 * [Output based on choice - success messages or errors]
 * 
 * Enter your choice: ...
 * ```
 * 
 * Your solution should be a single Java file containing the main class and all necessary logic.
 * 
 * **Constraints:**
 * 
 * *   You *must* use all the components listed in Requirement 1-5.
 * *   The solution should be contained within a single class for simplicity in an exam setting.
 * 
 * **Grading:**
 * 
 * Your solution will be evaluated based on:
 * *   Correctness of implementation for each function.
 * *   Proper usage of all required Java components.
 * *   Adherence to best practices (encapsulation, naming, comments, structure).
 * *   Robustness of error handling and input validation.
 * 
 * ```java
 * // Your solution code goes here
 * ```
 * 
 * **Good luck!**
 *
 * EXPLANATION:
 * This solution implements a basic hospital appointment scheduler demonstrating the required Java concepts.
 * 
 * 1.  **Data Structures (`Queue`, `ArrayList`, `List`):**
 *     *   `private List<String> registeredPatients = new ArrayList<>();`: An `ArrayList` is used to store the names of all registered patients. It's declared using the `List` interface, demonstrating programming to the interface principle. This allows flexibility if we wanted to switch to a different `List` implementation later.
 *     *   `private Queue<String> waitingQueue = new LinkedList<>();`: A `Queue` is used for the waiting list. `LinkedList` is chosen as a common implementation for `Queue` because it provides efficient additions to the tail (`offer`) and removals from the head (`poll`), which are the core operations for a FIFO queue. It's declared using the `Queue` interface.
 * 
 * 2.  **User Interaction (`Scanner`):**
 *     *   `private Scanner scanner = new Scanner(System.in);`: A `Scanner` object is created to read input from the console (`System.in`). It's initialized in the constructor and closed in the `finally` block of the `run` method to release system resources.
 *     *   `scanner.nextLine()` and `scanner.nextInt()` are used to read string and integer inputs respectively. Care is taken to consume the newline character left by `nextInt()` using an extra `scanner.nextLine()` call to prevent issues in subsequent `nextLine()` calls.
 * 
 * 3.  **Control Flow (`Switch`, Main Loop):**
 *     *   The `run()` method contains a `while(running)` loop that keeps the application active until the user chooses to exit.
 *     *   Inside the loop, `getUserChoice()` reads the user's input.
 *     *   A `switch` statement is used to direct the program execution based on the `choice` variable, calling the appropriate method for each menu option. The `default` case handles invalid numeric input within the expected range.
 * 
 * 4.  **Output (`System.out`, `System.err`):**
 *     *   `System.out.println()` and `System.out.print()` are used for displaying the menu, success messages, and the contents of the lists and queue.
 *     *   `System.err.println()` is used specifically for error conditions, such as invalid menu choices, patients not found, or trying to operate on an empty queue. This directs error output to the standard error stream, which is good practice for separating normal output from errors.
 * 
 * 5.  **Error Handling (`try-catch`):**
 *     *   **Input Validation:** The `getUserChoice()` method includes a `try-catch(InputMismatchException e)` block to handle cases where the user enters non-integer input for the menu choice. An error message is printed to `System.err`, and the invalid input is consumed using `scanner.next()`.
 *     *   **Application-wide Handling:** The main `run()` method is wrapped in a `try-catch(Exception e)` block. This serves as a class-wide catch-all for any unexpected runtime errors that might occur during the execution of the main loop. It prints an error message and the stack trace to `System.err`.
 *     *   **Logical Error Handling:** Methods like `addToWaitingList()` check if a patient exists in `registeredPatients` before adding them to the queue. `seeNextPatient()` checks if the `waitingQueue` is empty before attempting to remove an element. These checks prevent runtime errors (like `NoSuchElementException` if `remove()` was used on an empty queue) and provide user-friendly error messages via `System.err`.
 * 
 * 6.  **Best Practices:**
 *     *   **Encapsulation:** `registeredPatients`, `waitingQueue`, and `scanner` are declared as `private` fields, restricting direct external access. Public methods (`run`, `main`) and private helper methods (`displayMenu`, `getUserChoice`, etc.) control interaction with these fields.
 *     *   **Meaningful Names:** Variables (`waitingQueue`, `registeredPatients`, `choice`, `name`) and methods (`registerPatient`, `addToWaitingList`, `seeNextPatient`) have descriptive names indicating their purpose.
 *     *   **Comments and Documentation:** Basic Javadoc comments are included for the class and key methods, explaining their function. Inline comments clarify specific logic points.
 *     *   **Clean Structure:** The code is organized into a single class with separate methods for distinct tasks (menu display, input handling, each menu option). The main logic resides in the `run` method, called from `main`.
 * 
 * This solution effectively integrates all required components into a functional, albeit simplified, real-world scenario, demonstrating practical application of core Java concepts and best practices for building robust command-line applications.
 */

import java.util.Queue;
import java.util.LinkedList;
import java.util.List;
import java.util.ArrayList;
import java.util.Scanner;
import java.util.InputMismatchException;

/**
 * A simple Hospital Appointment Queue Management System.
 * Manages patient registration and a waiting queue.
 */
public class HospitalScheduler {

    // Private fields for data storage
    private List<String> registeredPatients;
    private Queue<String> waitingQueue;
    private Scanner scanner;

    /**
     * Constructor to initialize the data structures and scanner.
     */
    public HospitalScheduler() {
        // Use List interface for declaration, ArrayList for implementation
        registeredPatients = new ArrayList<>();
        // Use Queue interface for declaration, LinkedList for implementation (good for queues)
        waitingQueue = new LinkedList<>();
        scanner = new Scanner(System.in);

        // Optional: Pre-register a few patients for testing
        registeredPatients.add("Alice");
        registeredPatients.add("Bob");
        registeredPatients.add("Charlie");
    }

    /**
     * Main method to start the application.
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        HospitalScheduler scheduler = new HospitalScheduler();
        scheduler.run();
    }

    /**
     * Runs the main application loop, handling user input and menu options.
     * Includes class-wide exception handling.
     */
    public void run() {
        boolean running = true;
        // Class-wide try-catch block for the main application loop
        try {
            while (running) {
                displayMenu();
                int choice = getUserChoice();

                // Use switch statement for flow control
                switch (choice) {
                    case 1:
                        registerPatient();
                        break;
                    case 2:
                        addToWaitingList();
                        break;
                    case 3:
                        seeNextPatient();
                        break;
                    case 4:
                        displayWaitingList();
                        break;
                    case 5:
                        listAllRegisteredPatients();
                        break;
                    case 6:
                        System.out.println("Exiting Hospital Scheduler. Goodbye!");
                        running = false;
                        break;
                    default:
                        // Use System.err for invalid menu choices
                        System.err.println("Invalid choice. Please enter a number between 1 and 6.");
                }
                System.out.println(); // Add a blank line for readability
            }
        } catch (Exception e) {
            // Catch any unexpected exceptions during the main loop
            System.err.println("An unexpected error occurred: " + e.getMessage());
            e.printStackTrace(System.err); // Print stack trace to error stream
        } finally {
            // Ensure the scanner is closed when the application exits
            if (scanner != null) {
                scanner.close();
            }
        }
    }

    /**
     * Displays the main menu options to the console.
     * Uses System.out for normal output.
     */
    private void displayMenu() {
        System.out.println("--- Hospital Scheduler Menu ---");
        System.out.println("1. Register Patient");
        System.out.println("2. Add Patient to Waiting List");
        System.out.println("3. See Next Patient");
        System.out.println("4. Display Waiting List");
        System.out.println("5. List All Registered Patients");
        System.out.println("6. Exit");
        System.out.print("Enter your choice: ");
    }

    /**
     * Gets the user's menu choice from the console input.
     * Handles non-integer input using try-catch.
     * @return The integer choice entered by the user.
     */
    private int getUserChoice() {
        int choice = -1;
        try {
            // Use Scanner to read integer input
            choice = scanner.nextInt();
        } catch (InputMismatchException e) {
            // Use System.err for input validation errors
            System.err.println("Invalid input. Please enter a number.");
            // Consume the invalid input to prevent an infinite loop
            scanner.next();
        } finally {
             // Consume the newline character left by nextInt() or next()
             // This is crucial before subsequent calls to nextLine()
             // A simple nextLine() call after nextInt() or next() usually works.
             // However, calling it here in finally ensures it runs regardless of success/failure
             // But it might consume an extra line if input was fine.
             // A better pattern is to consume the rest of the line immediately after the specific input method.
             // Let's refine this pattern outside the finally block for clarity and correctness.
        }
         // Correct pattern: Consume the rest of the line *after* reading the number
         scanner.nextLine(); // Consume the newline character

        return choice;
    }


    /**
     * Registers a new patient in the system.
     * Prompts the user for the patient's name.
     * Adds the patient to the registeredPatients list.
     * Uses System.out for success messages.
     */
    private void registerPatient() {
        System.out.print("Enter patient name to register: ");
        // Use Scanner to read line input (allows spaces in names)
        String name = scanner.nextLine().trim();

        if (name.isEmpty()) {
            System.err.println("Patient name cannot be empty.");
            return;
        }

        // Optional: Prevent duplicates (simple check)
        if (registeredPatients.contains(name)) {
             System.out.println("Patient '" + name + "' is already registered.");
        } else {
            registeredPatients.add(name); // Add to ArrayList
            System.out.println("Patient '" + name + "' registered successfully.");
        }
    }

    /**
     * Adds a registered patient to the waiting queue.
     * Prompts the user for the patient's name.
     * Validates if the patient is registered before adding to the queue.
     * Uses System.err for validation errors, System.out for success.
     */
    private void addToWaitingList() {
        System.out.print("Enter name of patient to add to waiting list: ");
        String name = scanner.nextLine().trim();

        if (name.isEmpty()) {
            System.err.println("Patient name cannot be empty.");
            return;
        }

        // Check if the patient is registered (validation)
        if (registeredPatients.contains(name)) {
            waitingQueue.offer(name); // Add to Queue (offer is preferred over add as it doesn't throw exception on capacity limits)
            System.out.println("Patient '" + name + "' added to waiting list.");
        } else {
            // Use System.err for validation errors
            System.err.println("Error: Patient '" + name + "' is not registered.");
        }
    }

    /**
     * Simulates a doctor seeing the next patient from the waiting queue.
     * Removes the patient from the front of the queue.
     * Handles the case where the queue is empty.
     * Uses System.err for queue empty error, System.out for success.
     */
    private void seeNextPatient() {
        // Check if the queue is empty before trying to remove
        if (waitingQueue.isEmpty()) {
            // Use System.err for error when queue is empty
            System.err.println("No patients in the waiting list.");
        } else {
            // Remove and retrieve the head of the queue (FIFO)
            String patient = waitingQueue.poll(); // poll is preferred over remove as it returns null if empty
            System.out.println("Doctor is now seeing patient: " + patient);
        }
    }

    /**
     * Displays the current patients in the waiting queue.
     * Shows the order in which patients will be seen.
     * Uses System.out for output.
     */
    private void displayWaitingList() {
        System.out.println("--- Current Waiting List ---");
        // Check if the queue is empty
        if (waitingQueue.isEmpty()) {
            System.out.println("The waiting list is empty.");
        } else {
            // Iterate through the queue without removing elements
            int count = 1;
            for (String patient : waitingQueue) {
                System.out.println(count++ + ". " + patient);
            }
        }
    }

    /**
     * Displays all registered patients in the system.
     * Uses System.out for output.
     */
    private void listAllRegisteredPatients() {
        System.out.println("--- All Registered Patients ---");
        // Check if the list is empty
        if (registeredPatients.isEmpty()) {
            System.out.println("No patients are currently registered.");
        } else {
            // Iterate through the ArrayList (declared as List)
            for (int i = 0; i < registeredPatients.size(); i++) {
                System.out.println((i + 1) + ". " + registeredPatients.get(i));
            }
        }
    }
}
