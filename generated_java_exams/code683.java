/*
 * Exam Question #683
 * Generated on: 2025-05-12 16:25:20
 * Generated by: Account 2
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Conference Workshop Registration System
 * 
 * **Objective:** Design and implement a command-line application to manage attendee registration for workshops at a conference. The system must handle workshop capacity and maintain a waiting list for full workshops.
 * 
 * **Requirements:**
 * 
 * 1.  **Core Functionality:**
 *     *   Simulate a conference with pre-defined workshops, each having a maximum capacity.
 *     *   Allow users to perform the following actions via a command-line menu:
 *         1.  View all workshops with their current status (registered attendees count, waiting list size, available spots).
 *         2.  Register a new attendee for a specific workshop.
 *         3.  View detailed information for a specific workshop (list registered attendees, list waiting list attendees).
 *         4.  Exit the application.
 * 2.  **Data Structures:**
 *     *   Use `java.util.ArrayList` or `java.util.LinkedList` (implementing `java.util.List`) to store the collection of workshops in the conference manager.
 *     *   Use `java.util.ArrayList` or `java.util.LinkedList` (implementing `java.util.List`) within the `Workshop` class to store registered attendees.
 *     *   Use `java.util.Queue` (specifically `java.util.LinkedList` which implements `Queue`) within the `Workshop` class to manage the waiting list for attendees who couldn't register due to capacity limits.
 * 3.  **User Interaction:**
 *     *   Use `java.util.Scanner` to read user input from the console (menu choices, attendee details, workshop names).
 *     *   Use a `switch` statement to handle the main menu options.
 * 4.  **Output and Error Handling:**
 *     *   Use `System.out` for displaying the menu, prompts, workshop information, success messages, registered lists, and waiting lists.
 *     *   Use `System.err` for displaying all error messages (e.g., invalid menu choice, workshop not found, invalid input format).
 *     *   Implement exception handling using `try-catch` blocks. Specifically, handle potential `NumberFormatException` when reading numeric input (like menu choices). Also, consider a general `try-catch` around the main application loop for robustness. Handle logical errors (like workshop not found) by checking conditions and printing to `System.err`.
 * 5.  **Object-Oriented Design:**
 *     *   Create an `Attendee` class to represent conference attendees (e.g., with name and ID).
 *     *   Create a `Workshop` class to represent a single workshop, managing its capacity, registered attendees, and waiting list.
 *     *   Create a `ConferenceManager` class to manage the collection of workshops and handle the main application logic (menu, user input processing, coordinating operations between workshops).
 *     *   Apply principles of encapsulation (private fields, public getters/setters/methods as needed).
 *     *   Use meaningful variable and method names.
 *     *   Include basic comments to explain complex logic or class purpose.
 * 
 * **Pre-defined Workshops (Use these in your `ConferenceManager` initialization):**
 * 
 * *   "Advanced Java": Capacity 5
 * *   "Frontend Basics": Capacity 10
 * *   "Database Design": Capacity 7
 * 
 * **Expected Output Structure:**
 * 
 * The application should present a menu, process user input, and display information or errors accordingly.
 * 
 * ```
 * --- Conference Workshop Registration ---
 * 1. View Workshops
 * 2. Register Attendee
 * 3. View Workshop Details
 * 4. Exit
 * Enter choice: [user input]
 * 
 * // Example View Workshops Output
 * Workshops:
 * - Advanced Java (Capacity: 5, Registered: 3, Waiting: 1, Available: 2)
 * - Frontend Basics (Capacity: 10, Registered: 10, Waiting: 2, Available: 0)
 * - Database Design (Capacity: 7, Registered: 5, Waiting: 0, Available: 2)
 * 
 * // Example Register Attendee Flow
 * Enter choice: 2
 * Enter Attendee Name: Alice
 * Enter Attendee ID: A101
 * Enter Workshop Name: Advanced Java
 * Alice (A101) registered successfully for Advanced Java.
 * 
 * // Example Registration to Waiting List
 * Enter choice: 2
 * Enter Attendee Name: Bob
 * Enter Attendee ID: B202
 * Enter Workshop Name: Advanced Java
 * Advanced Java is full. Bob (B202) added to the waiting list.
 * 
 * // Example View Workshop Details Flow
 * Enter choice: 3
 * Enter Workshop Name: Frontend Basics
 * Workshop: Frontend Basics (Capacity: 10)
 * Registered Attendees:
 * - Attendee [Name=..., ID=...]
 * - Attendee [Name=..., ID=...]
 * ... (list all registered)
 * Waiting List:
 * - Attendee [Name=..., ID=...]
 * - Attendee [Name=..., ID=...]
 * ... (list all on waiting list)
 * 
 * // Example Error Output
 * Enter choice: 5
 * Invalid menu choice. Please enter a number between 1 and 4.
 * 
 * Enter choice: 2
 * Enter Attendee Name: Charlie
 * Enter Attendee ID: C303
 * Enter Workshop Name: NonExistent Workshop
 * Error: Workshop 'NonExistent Workshop' not found.
 * 
 * Enter choice: invalid_input
 * Error: Invalid input. Please enter a number.
 * 
 * ```
 * 
 * **Evaluation Criteria:**
 * 
 * *   Correct implementation of all required Java components (`Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.err`, `System.out`, `try-catch`).
 * *   Correct implementation of the registration logic, including capacity checks and waiting list management.
 * *   Proper handling of user input and errors as specified.
 * *   Adherence to object-oriented principles (encapsulation, class design).
 * *   Code clarity, readability, and basic documentation.
 * 
 * **Time Estimate:** 45-60 minutes.
 *
 * EXPLANATION:
 * This solution implements the Conference Workshop Registration System as described in the exam question, utilizing all required Java components and following best practices.
 * 
 * 1.  **`Attendee` Class:** A simple class representing an attendee with `name` and `id`. It includes a `toString()` method for easy printing and `equals()`/`hashCode()` based on ID for basic comparison (useful if we were to implement checks for duplicate registrations). Encapsulation is used with private fields and public getters.
 * 
 * 2.  **`Workshop` Class:**
 *     *   Manages a single workshop's state.
 *     *   `name` and `maxCapacity` are private fields.
 *     *   `registeredAttendees`: A `List<Attendee>` (specifically an `ArrayList`) stores attendees who successfully registered within the capacity limit.
 *     *   `waitingList`: A `Queue<Attendee>` (specifically a `LinkedList` which implements `Queue`) stores attendees waiting for a spot to open up. `LinkedList` is a common choice for implementing `Queue` in `java.util`.
 *     *   `registerAttendee(Attendee attendee)`: This core method checks if `registeredAttendees.size()` is less than `maxCapacity`. If true, the attendee is added to the `registeredAttendees` list using `add()`. If false, the attendee is added to the `waitingList` queue using `offer()`. It returns `true` if registered directly, `false` if added to the waiting list.
 *     *   Getter methods (`getName`, `getMaxCapacity`, `getRegisteredCount`, etc.) provide controlled access to the workshop's state. `getRegisteredAttendees` and `getWaitingList` return *copies* to prevent external code from modifying the internal lists directly, adhering to encapsulation.
 * 
 * 3.  **`ConferenceManager` Class:**
 *     *   Acts as the main orchestrator.
 *     *   `workshops`: A `List<Workshop>` (specifically an `ArrayList`) holds all the workshops managed by the conference.
 *     *   `scanner`: A `Scanner` object is used throughout the `run()` method to read user input. It's initialized once and closed when the application exits.
 *     *   The constructor initializes the `workshops` list with the pre-defined workshops.
 *     *   `findWorkshop(String name)`: A helper method to locate a workshop by its name, returning the `Workshop` object or `null` if not found.
 *     *   `displayMenu()`, `handleViewWorkshops()`, `handleRegisterAttendee()`, `handleViewWorkshopDetails()`: These methods encapsulate the logic for each menu option, improving code organization. They use `System.out` for normal output and prompts.
 *     *   `run()`: This method contains the main application loop (`while(running)`).
 *         *   It repeatedly displays the menu.
 *         *   It reads the user's input line using `scanner.nextLine()`.
 *         *   A `try-catch` block is used around the input parsing (`Integer.parseInt`). If the user enters non-numeric input, a `NumberFormatException` is caught, and an error message is printed to `System.err`.
 *         *   Inside the `try` block, a `switch` statement directs the flow based on the valid integer input.
 *         *   Each case calls the corresponding `handle...` method.
 *         *   The `handle...` methods perform input validation (e.g., checking if a workshop exists using `findWorkshop`). If a logical error occurs (like workshop not found), they print an error message to `System.err`.
 *         *   A general `catch(Exception e)` is included as a fallback to catch any other unexpected runtime exceptions and print an error message to `System.err`.
 *         *   Case 4 sets `running` to `false` to exit the loop.
 *         *   The `scanner` is closed after the loop finishes.
 * 
 * 4.  **`main` Method:** The entry point of the application. It creates a `ConferenceManager` instance and calls its `run()` method to start the system.
 * 
 * **Demonstrated Concepts:**
 * 
 * *   **Object-Oriented Programming:** Use of classes (`Attendee`, `Workshop`, `ConferenceManager`), encapsulation (private fields, public methods), and object interaction.
 * *   **Data Structures:** Practical application of `List` (`ArrayList`) for collections where order and indexed access are useful (registered attendees, list of workshops) and `Queue` (`LinkedList`) for managing a FIFO (First-In, First-Out) waiting list.
 * *   **User Input:** Using `Scanner` to read different types of input from the console.
 * *   **Control Flow:** Using `switch` for multi-way branching based on menu choices and `while` for the main application loop. Using `if-else` for conditional logic (capacity check, workshop found).
 * *   **Input/Output:** Differentiating between standard output (`System.out`) for normal information and standard error (`System.err`) for error messages.
 * *   **Exception Handling:** Using `try-catch` to gracefully handle potential runtime errors (`NumberFormatException`) and a general catch for unexpected issues, preventing the program from crashing. Logical errors are handled with conditional checks and `System.err`.
 * *   **Code Structure and Best Practices:** Meaningful names, basic comments, separation of concerns into different methods and classes, returning copies of collections to protect internal state.
 * 
 * This solution effectively combines the required components to build a functional, albeit simplified, real-world simulation, demonstrating a solid understanding of fundamental and intermediate Java concepts.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;

/**
 * Represents an attendee at the conference.
 */
class Attendee {
    private String name;
    private String id;

    public Attendee(String name, String id) {
        this.name = name;
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public String getId() {
        return id;
    }

    @Override
    public String toString() {
        return "Attendee [Name=" + name + ", ID=" + id + "]";
    }

    // Basic equality check based on ID for simplicity in this problem
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Attendee attendee = (Attendee) o;
        return id.equals(attendee.id);
    }

    @Override
    public int hashCode() {
        return id.hashCode();
    }
}

/**
 * Represents a single workshop with capacity, registered attendees, and a waiting list.
 */
class Workshop {
    private String name;
    private int maxCapacity;
    private List<Attendee> registeredAttendees;
    private Queue<Attendee> waitingList;

    public Workshop(String name, int maxCapacity) {
        this.name = name;
        this.maxCapacity = maxCapacity;
        this.registeredAttendees = new ArrayList<>(); // Using ArrayList for registered attendees
        this.waitingList = new LinkedList<>(); // Using LinkedList as a Queue for the waiting list
    }

    public String getName() {
        return name;
    }

    public int getMaxCapacity() {
        return maxCapacity;
    }

    public int getRegisteredCount() {
        return registeredAttendees.size();
    }

    public int getWaitingCount() {
        return waitingList.size();
    }

    public int getAvailableSpots() {
        return maxCapacity - registeredAttendees.size();
    }

    public List<Attendee> getRegisteredAttendees() {
        return new ArrayList<>(registeredAttendees); // Return a copy to prevent external modification
    }

    public Queue<Attendee> getWaitingList() {
        return new LinkedList<>(waitingList); // Return a copy
    }

    /**
     * Attempts to register an attendee for the workshop.
     * Adds to registered list if capacity allows, otherwise adds to waiting list.
     *
     * @param attendee The attendee to register.
     * @return true if registered directly, false if added to waiting list.
     *         Note: This simplified version doesn't check if attendee is already registered/on waiting list.
     */
    public boolean registerAttendee(Attendee attendee) {
        // In a real system, we'd check if the attendee is already registered or on the waiting list
        // For this exam, we simplify and assume attempts are for new registrations/waiting list spots.

        if (registeredAttendees.size() < maxCapacity) {
            registeredAttendees.add(attendee);
            return true; // Successfully registered
        } else {
            waitingList.offer(attendee); // Add to the end of the waiting queue
            return false; // Added to waiting list
        }
    }

    // Note: A real system would need methods to move attendees from waiting list
    // to registered list when spots open up (e.g., attendee cancels).
    // This is omitted for complexity management within the exam time frame.
}

/**
 * Manages the collection of workshops and handles user interaction.
 */
public class ConferenceManager {
    private List<Workshop> workshops;
    private Scanner scanner;

    public ConferenceManager() {
        this.workshops = new ArrayList<>(); // Using ArrayList for the list of workshops
        // Initialize with predefined workshops
        workshops.add(new Workshop("Advanced Java", 5));
        workshops.add(new Workshop("Frontend Basics", 10));
        workshops.add(new Workshop("Database Design", 7));

        this.scanner = new Scanner(System.in);
    }

    /**
     * Finds a workshop by name (case-insensitive).
     * @param name The name of the workshop to find.
     * @return The Workshop object if found, otherwise null.
     */
    private Workshop findWorkshop(String name) {
        for (Workshop workshop : workshops) {
            if (workshop.getName().equalsIgnoreCase(name)) {
                return workshop;
            }
        }
        return null; // Workshop not found
    }

    /**
     * Displays the main menu options.
     */
    private void displayMenu() {
        System.out.println("\n--- Conference Workshop Registration ---");
        System.out.println("1. View Workshops");
        System.out.println("2. Register Attendee");
        System.out.println("3. View Workshop Details");
        System.out.println("4. Exit");
        System.out.print("Enter choice: ");
    }

    /**
     * Handles the "View Workshops" action.
     */
    private void handleViewWorkshops() {
        System.out.println("\nWorkshops:");
        if (workshops.isEmpty()) {
            System.out.println("No workshops available.");
            return;
        }
        for (Workshop workshop : workshops) {
            System.out.printf("- %s (Capacity: %d, Registered: %d, Waiting: %d, Available: %d)%n",
                    workshop.getName(),
                    workshop.getMaxCapacity(),
                    workshop.getRegisteredCount(),
                    workshop.getWaitingCount(),
                    workshop.getAvailableSpots());
        }
    }

    /**
     * Handles the "Register Attendee" action.
     */
    private void handleRegisterAttendee() {
        System.out.print("Enter Attendee Name: ");
        String name = scanner.nextLine();
        System.out.print("Enter Attendee ID: ");
        String id = scanner.nextLine();
        System.out.print("Enter Workshop Name: ");
        String workshopName = scanner.nextLine();

        Attendee newAttendee = new Attendee(name, id);
        Workshop workshop = findWorkshop(workshopName);

        if (workshop == null) {
            System.err.println("Error: Workshop '" + workshopName + "' not found.");
            return;
        }

        // Simplified check: prevent duplicate registration attempts in this run
        // A real system would need persistent storage and more robust checks
        if (workshop.getRegisteredAttendees().contains(newAttendee) || workshop.getWaitingList().contains(newAttendee)) {
             System.err.println("Error: Attendee '" + name + "' (" + id + ") is already registered or on the waiting list for '" + workshopName + "'.");
             return;
        }


        boolean registeredDirectly = workshop.registerAttendee(newAttendee);

        if (registeredDirectly) {
            System.out.println(newAttendee.getName() + " (" + newAttendee.getId() + ") registered successfully for " + workshop.getName() + ".");
        } else {
            System.out.println(workshop.getName() + " is full. " + newAttendee.getName() + " (" + newAttendee.getId() + ") added to the waiting list.");
        }
    }

    /**
     * Handles the "View Workshop Details" action.
     */
    private void handleViewWorkshopDetails() {
        System.out.print("Enter Workshop Name: ");
        String workshopName = scanner.nextLine();

        Workshop workshop = findWorkshop(workshopName);

        if (workshop == null) {
            System.err.println("Error: Workshop '" + workshopName + "' not found.");
            return;
        }

        System.out.println("\nWorkshop: " + workshop.getName() + " (Capacity: " + workshop.getMaxCapacity() + ")");

        System.out.println("Registered Attendees:");
        List<Attendee> registered = workshop.getRegisteredAttendees();
        if (registered.isEmpty()) {
            System.out.println("  None.");
        } else {
            for (Attendee attendee : registered) {
                System.out.println("  - " + attendee);
            }
        }

        System.out.println("Waiting List:");
        Queue<Attendee> waiting = workshop.getWaitingList();
         if (waiting.isEmpty()) {
            System.out.println("  None.");
        } else {
             // Iterate through the queue without removing elements for viewing
            for (Attendee attendee : waiting) {
                System.out.println("  - " + attendee);
            }
        }
    }

    /**
     * Runs the main application loop.
     */
    public void run() {
        boolean running = true;
        while (running) {
            displayMenu();
            String inputLine = scanner.nextLine(); // Read the entire line

            try {
                int choice = Integer.parseInt(inputLine); // Attempt to parse as integer

                switch (choice) {
                    case 1:
                        handleViewWorkshops();
                        break;
                    case 2:
                        handleRegisterAttendee();
                        break;
                    case 3:
                        handleViewWorkshopDetails();
                        break;
                    case 4:
                        System.out.println("Exiting application. Goodbye!");
                        running = false;
                        break;
                    default:
                        System.err.println("Invalid menu choice. Please enter a number between 1 and 4.");
                        break;
                }
            } catch (NumberFormatException e) {
                // Handle cases where input is not a valid integer
                System.err.println("Error: Invalid input. Please enter a number.");
            } catch (Exception e) {
                // Catch any other unexpected errors
                System.err.println("An unexpected error occurred: " + e.getMessage());
                // e.printStackTrace(System.err); // Optional: for debugging
            }
        }
        scanner.close(); // Close the scanner when done
    }

    public static void main(String[] args) {
        ConferenceManager manager = new ConferenceManager();
        manager.run();
    }
}
