/*
 * Exam Question #1141
 * Generated on: 2025-05-12 17:30:29
 * Generated by: Account 3
 * 
 * QUESTION:
 * **Advanced Java Programming Exam: Manufacturing Task Dispatch System**
 * 
 * **Scenario:**
 * You are tasked with developing a simplified system for a small manufacturing plant. The system needs to manage a queue of production tasks that need to be processed and a list of available machines that can perform these tasks. Tasks must be dispatched to an available machine of the correct type.
 * 
 * **Requirements:**
 * 
 * 1.  **Core Functionality:**
 *     *   Maintain a queue of pending tasks.
 *     *   Maintain a list of manufacturing machines.
 *     *   Allow adding new tasks to the queue.
 *     *   Allow dispatching the next task from the queue to an *available* machine of the *required type*.
 *     *   Allow marking a machine as available again after a task is completed on it.
 *     *   Allow listing all pending tasks in the queue.
 *     *   Allow listing all available machines.
 *     *   Implement a command-line interface using `Scanner` for user interaction.
 * 
 * 2.  **Java Components:** Your solution *must* utilize *all* of the following Java components:
 *     *   `java.util.Queue` (e.g., `java.util.LinkedList` implementing `Queue`)
 *     *   `java.util.ArrayList`
 *     *   `java.util.List` interface (used for declaring variables/collections)
 *     *   `java.util.Scanner`
 *     *   `switch` statement
 *     *   `System.err` (for error messages)
 *     *   `System.out` (for normal output)
 *     *   Class-wide or method-level `try-catch` blocks for exception handling.
 * 
 * 3.  **Best Practices:**
 *     *   Use proper encapsulation (private fields, public methods).
 *     *   Use meaningful variable and method names.
 *     *   Include appropriate comments and documentation (e.g., Javadoc style).
 *     *   Implement input validation (e.g., for numeric inputs).
 *     *   Implement proper error handling (e.g., handling empty queue, no available machines, invalid input).
 *     *   Structure the code cleanly with separate classes where appropriate (`Task`, `Machine`, `TaskDispatcherSystem`).
 * 
 * **System Details:**
 * 
 * *   **Task:** Each task has an `id` (int), a `description` (String), and a `requiredMachineType` (String, e.g., "CNC", "Assembly", "Packaging").
 * *   **Machine:** Each machine has an `id` (int), a `type` (String), and a status (`isAvailable`, boolean).
 * *   The system should start with a predefined set of machines.
 * *   The user interface should present a menu of options:
 *     1.  Add New Task
 *     2.  Dispatch Task
 *     3.  Complete Task on Machine
 *     4.  List Pending Tasks
 *     5.  List Available Machines
 *     6.  Exit
 * 
 * **Error Conditions to Handle:**
 * 
 * *   Invalid menu choice.
 * *   Non-integer input where an integer is expected (e.g., for IDs, menu choice).
 * *   Attempting to dispatch when the task queue is empty.
 * *   Attempting to dispatch when no available machine matches the required type for the next task.
 * *   Attempting to complete a task on a non-existent machine ID.
 * *   Attempting to complete a task on a machine that is already available.
 * 
 * **Expected Output:**
 * 
 * *   Menu displayed clearly.
 * *   Prompts for user input.
 * *   Confirmation messages for successful operations (task added, task dispatched, machine completed).
 * *   Lists of tasks and machines formatted clearly.
 * *   Error messages printed to `System.err` for failed operations or invalid input.
 * 
 * **Time Limit:** Approximately 45-60 minutes.
 * 
 * **Task:** Implement the `TaskDispatcherSystem` class and necessary helper classes (`Task`, `Machine`) according to the requirements.
 *
 * EXPLANATION:
 * The provided solution implements a `TaskDispatcherSystem` that simulates a basic manufacturing task management process, incorporating all the required Java components and best practices.
 * 
 * 1.  **Class Structure:**
 *     *   `Task` class: A simple class to represent a task with private fields (`id`, `description`, `requiredMachineType`) and public getter methods, demonstrating encapsulation. `toString()` is overridden for easy printing.
 *     *   `Machine` class: Represents a machine with private fields (`id`, `type`, `isAvailable`) and public getters/setters (`setAvailable`), also demonstrating encapsulation. `toString()` is overridden.
 *     *   `TaskDispatcherSystem` class: The main class containing the system logic.
 * 
 * 2.  **Data Structures:**
 *     *   `taskQueue`: Declared as `Queue<Task>` and instantiated as `new LinkedList<>()`. This correctly uses the `Queue` interface and a concrete implementation (`LinkedList` which is suitable for queue operations like `offer`, `peek`, `poll`). It stores tasks in a FIFO (First-In, First-Out) manner.
 *     *   `machines`: Declared as `List<Machine>` and instantiated as `new ArrayList<>()`. This uses the `List` interface for flexibility and `ArrayList` for dynamic storage and easy iteration over the collection of machines.
 * 
 * 3.  **User Interface (`run` method):**
 *     *   A `Scanner` object is used to read user input from the console (`System.in`).
 *     *   A `while` loop keeps the system running until the user chooses to exit.
 *     *   Inside the loop, a menu is printed (`printMenu`).
 *     *   The user's choice is read using `scanner.nextLine()` and parsed into an integer.
 *     *   A `switch` statement is used to direct the program flow based on the user's integer choice, fulfilling the `switch` requirement.
 *     *   Each case in the `switch` calls the appropriate method (`addTask`, `dispatchTask`, etc.).
 * 
 * 4.  **Core Logic Methods:**
 *     *   `initializeMachines()`: Populates the `machines` list with some initial `Machine` objects.
 *     *   `addTask(Task task)`: Uses `taskQueue.offer(task)` to add a task to the end of the queue.
 *     *   `dispatchTask()`:
 *         *   Uses `taskQueue.peek()` to look at the next task without removing it.
 *         *   Iterates through the `machines` list to find an `isAvailable` machine matching the task's `requiredMachineType`.
 *         *   If a suitable machine is found, `taskQueue.poll()` removes the task from the queue, and the machine's `isAvailable` status is set to `false`.
 *         *   If no suitable machine is found, an error message is printed to `System.err`, and the task remains in the queue.
 *     *   `completeTask(int machineId)`: Iterates through the `machines` list to find the machine by ID and sets its `isAvailable` status to `true` if it exists and is currently busy.
 *     *   `listPendingTasks()`: Iterates through the `taskQueue` (using an enhanced for loop, which internally uses an iterator without removing elements) and prints each task.
 *     *   `listAvailableMachines()`: Iterates through the `machines` list and prints each machine's status.
 * 
 * 5.  **Error Handling and Input Validation:**
 *     *   A `try-catch(Exception e)` block wraps the main `while` loop in the `run` method, providing a general exception handler for unexpected errors (demonstrating class-wide or method-level handling).
 *     *   A specific `try-catch(NumberFormatException e)` block is used *inside* the loop to catch errors when parsing user input (like menu choice or IDs) into integers. This demonstrates handling specific anticipated exceptions.
 *     *   Input validation is done implicitly by catching `NumberFormatException`.
 *     *   Specific error conditions (empty queue, no suitable machine, machine not found/already available) are checked within the respective methods (`dispatchTask`, `completeTask`), and descriptive error messages are printed to `System.err`.
 *     *   Normal output (menu, prompts, success messages, lists) is printed to `System.out`.
 * 
 * 6.  **Best Practices Implementation:**
 *     *   Private fields and public methods ensure proper encapsulation.
 *     *   Variable and method names are descriptive (e.g., `taskQueue`, `dispatchTask`, `requiredMachineType`).
 *     *   Basic comments explain the purpose of classes and methods.
 *     *   Error handling using `try-catch` and `System.err` is implemented.
 *     *   The code is structured into logical classes and methods.
 *     *   The `Scanner` is closed in a `finally` block to release system resources.
 * 
 * This solution effectively demonstrates the required Java components within a practical scenario, includes robust error handling, input validation, and follows good programming practices, making it a suitable challenging exam task.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;

// Represents a manufacturing task
class Task {
    private int id;
    private String description;
    private String requiredMachineType;

    public Task(int id, String description, String requiredMachineType) {
        this.id = id;
        this.description = description;
        this.requiredMachineType = requiredMachineType;
    }

    public int getId() {
        return id;
    }

    public String getDescription() {
        return description;
    }

    public String getRequiredMachineType() {
        return requiredMachineType;
    }

    @Override
    public String toString() {
        return "Task [ID=" + id + ", Desc='" + description + "', Requires='" + requiredMachineType + "']";
    }
}

// Represents a manufacturing machine
class Machine {
    private int id;
    private String type;
    private boolean isAvailable;
    // Could potentially store the task it's currently working on, but not required by prompt

    public Machine(int id, String type) {
        this.id = id;
        this.type = type;
        this.isAvailable = true; // Machines start as available
    }

    public int getId() {
        return id;
    }

    public String getType() {
        return type;
    }

    public boolean isAvailable() {
        return isAvailable;
    }

    public void setAvailable(boolean available) {
        isAvailable = available;
    }

    @Override
    public String toString() {
        return "Machine [ID=" + id + ", Type='" + type + "', Available=" + isAvailable + "]";
    }
}

// The main system managing tasks and machines
public class TaskDispatcherSystem {

    // Use Queue for tasks (FIFO)
    private Queue<Task> taskQueue;
    // Use List for machines (ArrayList for dynamic size and easy iteration)
    private List<Machine> machines;
    private Scanner scanner;

    public TaskDispatcherSystem() {
        this.taskQueue = new LinkedList<>(); // LinkedList implements Queue
        this.machines = new ArrayList<>(); // ArrayList implements List
        this.scanner = new Scanner(System.in);

        // Initialize with some machines
        initializeMachines();
    }

    private void initializeMachines() {
        machines.add(new Machine(101, "CNC"));
        machines.add(new Machine(102, "Assembly"));
        machines.add(new Machine(103, "Packaging"));
        machines.add(new Machine(104, "CNC"));
        machines.add(new Machine(105, "Assembly"));
        System.out.println("System initialized with " + machines.size() + " machines.");
    }

    /**
     * Adds a new task to the pending queue.
     * @param task The task to add.
     */
    public void addTask(Task task) {
        taskQueue.offer(task); // offer is preferred over add for queues (returns false if failed, doesn't throw exception)
        System.out.println("Task added to queue: " + task.getDescription());
    }

    /**
     * Attempts to dispatch the next task in the queue to an available machine.
     */
    public void dispatchTask() {
        // Use peek() first to check without removing
        Task nextTask = taskQueue.peek();

        if (nextTask == null) {
            System.err.println("Error: No pending tasks in the queue to dispatch.");
            return;
        }

        System.out.println("Attempting to dispatch task: " + nextTask.getDescription() + " (Requires: " + nextTask.getRequiredMachineType() + ")");

        Machine suitableMachine = null;
        for (Machine machine : machines) {
            if (machine.isAvailable() && machine.getType().equalsIgnoreCase(nextTask.getRequiredMachineType())) {
                suitableMachine = machine;
                break; // Found a suitable machine
            }
        }

        if (suitableMachine != null) {
            // Found a machine, poll the task from the queue
            taskQueue.poll();
            suitableMachine.setAvailable(false); // Mark machine as busy
            System.out.println("Task '" + nextTask.getDescription() + "' dispatched to Machine ID " + suitableMachine.getId());
        } else {
            System.err.println("Error: No available machine of type '" + nextTask.getRequiredMachineType() + "' found for task '" + nextTask.getDescription() + "'. Task remains in queue.");
            // Task remains in queue because we used peek() first and only poll() if a machine is found
        }
    }

    /**
     * Marks a machine as available after a task is completed.
     * @param machineId The ID of the machine to mark as available.
     */
    public void completeTask(int machineId) {
        Machine targetMachine = null;
        for (Machine machine : machines) {
            if (machine.getId() == machineId) {
                targetMachine = machine;
                break;
            }
        }

        if (targetMachine == null) {
            System.err.println("Error: Machine with ID " + machineId + " not found.");
        } else {
            if (targetMachine.isAvailable()) {
                System.err.println("Error: Machine with ID " + machineId + " is already available.");
            } else {
                targetMachine.setAvailable(true);
                System.out.println("Machine ID " + machineId + " marked as available.");
            }
        }
    }

    /**
     * Lists all tasks currently in the pending queue.
     */
    public void listPendingTasks() {
        System.out.println("\n--- Pending Tasks ---");
        if (taskQueue.isEmpty()) {
            System.out.println("No tasks in the queue.");
        } else {
            // Iterate through the queue without removing elements
            int index = 1;
            for (Task task : taskQueue) {
                System.out.println(index++ + ". " + task);
            }
        }
        System.out.println("---------------------");
    }

    /**
     * Lists all manufacturing machines and their availability status.
     */
    public void listAvailableMachines() {
        System.out.println("\n--- Machines Status ---");
        if (machines.isEmpty()) {
            System.out.println("No machines configured.");
        } else {
            for (Machine machine : machines) {
                System.out.println(machine);
            }
        }
        System.out.println("---------------------");
    }

    /**
     * Runs the main command-line interface loop.
     */
    public void run() {
        int choice = -1;

        // Class-wide exception handling example wrapping the main loop
        try {
            while (choice != 6) {
                printMenu();

                System.out.print("Enter your choice: ");
                try {
                    choice = Integer.parseInt(scanner.nextLine());

                    // Switch statement for flow control based on user choice
                    switch (choice) {
                        case 1: // Add New Task
                            System.out.print("Enter Task ID (int): ");
                            int taskId = Integer.parseInt(scanner.nextLine());
                            System.out.print("Enter Task Description: ");
                            String taskDesc = scanner.nextLine();
                            System.out.print("Enter Required Machine Type (e.g., CNC, Assembly, Packaging): ");
                            String requiredType = scanner.nextLine();
                            addTask(new Task(taskId, taskDesc, requiredType));
                            break;

                        case 2: // Dispatch Task
                            dispatchTask();
                            break;

                        case 3: // Complete Task on Machine
                            System.out.print("Enter Machine ID to mark as available: ");
                            int machineId = Integer.parseInt(scanner.nextLine());
                            completeTask(machineId);
                            break;

                        case 4: // List Pending Tasks
                            listPendingTasks();
                            break;

                        case 5: // List Available Machines
                            listAvailableMachines();
                            break;

                        case 6: // Exit
                            System.out.println("Exiting Task Dispatcher System. Goodbye!");
                            break;

                        default:
                            System.err.println("Error: Invalid choice. Please enter a number between 1 and 6.");
                            break;
                    }
                } catch (NumberFormatException e) {
                    // Specific exception handling for invalid number input
                    System.err.println("Error: Invalid input. Please enter a valid number for the choice or ID.");
                } catch (Exception e) {
                    // Catch any other unexpected exceptions during operation
                    System.err.println("An unexpected error occurred: " + e.getMessage());
                    // e.printStackTrace(); // Uncomment for debugging
                }
                System.out.println(); // Add a newline for better readability between operations
            }
        } finally {
            // Ensure scanner is closed when the system exits or an unhandled exception occurs
            scanner.close();
            System.out.println("Scanner closed.");
        }
    }

    private void printMenu() {
        System.out.println("--- Manufacturing Task Dispatch System ---");
        System.out.println("1. Add New Task");
        System.out.println("2. Dispatch Task");
        System.out.println("3. Complete Task on Machine");
        System.out.println("4. List Pending Tasks");
        System.out.println("5. List Available Machines");
        System.out.println("6. Exit");
        System.out.println("------------------------------------------");
    }

    // Main method to start the system
    public static void main(String[] args) {
        TaskDispatcherSystem system = new TaskDispatcherSystem();
        system.run();
    }
}
