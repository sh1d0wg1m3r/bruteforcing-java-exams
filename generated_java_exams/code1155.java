/*
 * Exam Question #1155
 * Generated on: 2025-05-12 17:32:24
 * Generated by: Account 1
 * 
 * QUESTION:
 * ## Advanced Java Programming Exam Task: Software Build & Deployment Queue
 * 
 * **Scenario:**
 * 
 * You are tasked with building a simple command-line application that simulates a software build and deployment queue. Build requests are submitted and processed in a First-In, First-Out (FIFO) manner. The system should allow users to submit new build requests, process the next available request in the queue, view pending requests, and view completed requests.
 * 
 * **Requirements:**
 * 
 * 1.  **Classes:**
 *     *   Create a class `BuildRequest` to represent a single build request. It should have private fields for `requestId` (an integer, automatically generated), `projectName` (String), `version` (String), and `status` (an enum `RequestStatus` with values: `PENDING`, `PROCESSING`, `COMPLETED`). Include a constructor, getters for all fields, and a method to update the status.
 *     *   Create a class `BuildQueueManager` to manage the collection of build requests. It should contain:
 *         *   A private `Queue<BuildRequest>` to hold pending requests.
 *         *   A private `List<BuildRequest>` to hold completed requests.
 *         *   Methods to `submitRequest(String projectName, String version)`, `processNextRequest()`, `getPendingRequests()`, and `getCompletedRequests()`.
 *         *   Ensure proper encapsulation (private fields, public methods).
 *     *   Create a main application class (e.g., `BuildQueueApp`) with a `main` method to handle user interaction via a command-line interface.
 * 
 * 2.  **Core Logic:**
 *     *   The `BuildQueueManager`'s `submitRequest` method should create a new `BuildRequest` with status `PENDING` and add it to the pending queue. Assign a unique `requestId` (e.g., using a static counter).
 *     *   The `processNextRequest` method should take the next request from the *pending queue*. If a request exists, update its status to `PROCESSING` (simulate work), then update its status to `COMPLETED`, and move it to the *completed list*. If the queue is empty, indicate that there are no requests to process.
 *     *   The `getPendingRequests` and `getCompletedRequests` methods should return the respective collections. To maintain encapsulation and prevent external modification, consider returning a *copy* of the internal list/queue contents, ideally as a `List`.
 * 
 * 3.  **User Interface (BuildQueueApp):**
 *     *   Display a menu of options:
 *         1.  Submit New Build Request
 *         2.  Process Next Request
 *         3.  View Pending Requests
 *         4.  View Completed Requests
 *         5.  Exit
 *     *   Use `Scanner` to read user input for menu choices and request details.
 *     *   Use a `switch` statement to handle the different menu options.
 *     *   Use `System.out` for displaying the menu, prompts, successful operations, and request details.
 *     *   Use `System.err` for displaying error messages (e.g., invalid menu choice, invalid input for request details, attempting to process an empty queue).
 * 
 * 4.  **Error Handling and Validation:**
 *     *   Implement input validation for submitting a new request (e.g., project name and version should not be empty). Use `System.err` for validation errors.
 *     *   Implement robust exception handling using `try-catch` blocks. At a minimum, wrap the main user interaction loop or critical input reading sections in `try-catch` to handle potential runtime exceptions (like `NumberFormatException` if you were reading numbers, though less critical here, a general `Exception` catch around the main loop is good practice as requested). Use `System.err` to report caught exceptions.
 *     *   Gracefully handle the case where the user attempts to process a request when the pending queue is empty.
 * 
 * 5.  **Java Concepts:**
 *     *   You *must* use `java.util.Queue`, `java.util.ArrayList`, `java.util.List` interface, `java.util.Scanner`, `switch` statement, `System.err`, `System.out`, and class-wide `try-catch` blocks.
 * 
 * 6.  **Best Practices:**
 *     *   Apply proper encapsulation (private fields, public methods).
 *     *   Use meaningful variable and method names.
 *     *   Include appropriate comments and documentation (Javadoc where appropriate).
 *     *   Ensure clean code structure.
 * 
 * **Expected Output:**
 * 
 * The application should present a menu, accept user input, perform actions, and display results or errors clearly on the console, using `System.out` for normal output and `System.err` for errors.
 * 
 * ```
 * --- Build Queue Menu ---
 * 1. Submit New Build Request
 * 2. Process Next Request
 * 3. View Pending Requests
 * 4. View Completed Requests
 * 5. Exit
 * Enter your choice:
 * ```
 * 
 * (Example interaction)
 * ```
 * Enter your choice: 1
 * Enter project name: MyProject
 * Enter version: 1.0
 * Build request submitted: [ID: 1, Project: MyProject, Version: 1.0, Status: PENDING]
 * 
 * --- Build Queue Menu ---
 * ...
 * Enter your choice: 3
 * --- Pending Requests ---
 * [ID: 1, Project: MyProject, Version: 1.0, Status: PENDING]
 * 
 * --- Build Queue Menu ---
 * ...
 * Enter your choice: 2
 * Processing request: [ID: 1, Project: MyProject, Version: 1.0, Status: PENDING]
 * Request ID 1 processed successfully.
 * 
 * --- Build Queue Menu ---
 * ...
 * Enter your choice: 4
 * --- Completed Requests ---
 * [ID: 1, Project: MyProject, Version: 1.0, Status: COMPLETED]
 * 
 * --- Build Queue Menu ---
 * ...
 * Enter your choice: 2
 * Error: No pending requests to process.
 * ```
 * (Error example)
 * ```
 * Enter your choice: 1
 * Enter project name:
 * Error: Project name and version cannot be empty. Build request not submitted.
 * ```
 * 
 * Your solution should provide the complete Java code for all necessary classes (`BuildRequest`, `BuildQueueManager`, `BuildQueueApp`, and the `RequestStatus` enum).
 *
 * EXPLANATION:
 * This solution implements a software build and deployment queue simulation, demonstrating the required Java concepts and best practices.
 * 
 * 1.  **`RequestStatus` Enum:** Defines the possible states of a build request (`PENDING`, `PROCESSING`, `COMPLETED`), improving code readability and maintainability compared to using raw strings or integers.
 * 
 * 2.  **`BuildRequest` Class:**
 *     *   Models a single request with `requestId`, `projectName`, `version`, and `status`.
 *     *   `requestId` is automatically assigned using a `static` counter (`nextRequestId`), ensuring uniqueness across all requests.
 *     *   The constructor initializes the request with `PENDING` status.
 *     *   Provides standard getter methods.
 *     *   Includes a `setStatus` method to change the request's state.
 *     *   Overrides `toString()` for easy printing of request details.
 *     *   Fields are `private` adhering to encapsulation.
 * 
 * 3.  **`BuildQueueManager` Class:**
 *     *   Manages the core logic of the queue system.
 *     *   Uses a `Queue<BuildRequest>` (`LinkedList` implementation) for `buildQueue` to maintain the FIFO order of pending requests.
 *     *   Uses an `List<BuildRequest>` (`ArrayList` implementation) for `processedRequests` to store completed requests.
 *     *   **`submitRequest(String projectName, String version)`:**
 *         *   Performs basic input validation (checks for empty strings). If validation fails, prints an error to `System.err` and returns `false`.
 *         *   Creates a new `BuildRequest` instance.
 *         *   Uses `buildQueue.offer()` to add the new request to the tail of the queue. `offer()` is preferred over `add()` for queues as it returns `false` if the element cannot be added (though with `LinkedList`, it typically doesn't fail unless memory is exhausted).
 *         *   Prints a success message to `System.out`.
 *     *   **`processNextRequest()`:**
 *         *   Uses `buildQueue.poll()` to retrieve and remove the element at the head of the queue. `poll()` returns `null` if the queue is empty.
 *         *   Checks if the result of `poll()` is `null`. If so, it prints an error message to `System.err` indicating no pending requests and returns `false`.
 *         *   If a request is retrieved, it simulates processing by updating the status to `PROCESSING` and then `COMPLETED`.
 *         *   Adds the completed request to the `processedRequests` `List`.
 *         *   Prints a success message to `System.out`.
 *         *   Returns `true` indicating a request was processed.
 *     *   **`getPendingRequests()` and `getCompletedRequests()`:**
 *         *   These methods return a `List<BuildRequest>`.
 *         *   Crucially, they return a *new `ArrayList`* constructed from the elements of the internal `Queue` or `List`. This provides a *copy* of the data, preventing external code from directly modifying the internal state of the `BuildQueueManager`'s collections, thus upholding encapsulation.
 * 
 * 4.  **`BuildQueueApp` Class:**
 *     *   Contains the `main` method, serving as the entry point.
 *     *   Initializes a `BuildQueueManager` instance and a `Scanner` for user input.
 *     *   **Class-wide Exception Handling:** The `main` method wraps the call to `runMenuLoop()` in a `try-catch(Exception e)` block. This provides a top-level safety net for any unexpected exceptions that might propagate up, printing the error to `System.err` and ensuring the application can attempt a graceful exit (`finally` block closes the scanner).
 *     *   **`runMenuLoop()`:**
 *         *   Implements the main application loop using `do-while`.
 *         *   Calls `printMenu()` to display options.
 *         *   Reads user input using the `Scanner`.
 *         *   Includes specific input validation for the menu choice: it checks `scanner.hasNextInt()` *before* calling `scanner.nextInt()` to prevent `InputMismatchException`. If input is not an integer, it prints an error to `System.err`, consumes the invalid input, and sets the choice to 0 (which the `switch` handles as default).
 *         *   Calls `scanner.nextLine()` after `nextInt()` to consume the leftover newline character, preventing issues in subsequent `nextLine()` calls.
 *         *   Uses a `switch` statement to direct control flow based on the user's validated choice.
 *         *   Calls helper methods (`submitRequestOption`, `processNextRequestOption`, etc.) for each menu action.
 *         *   Includes a nested `try-catch` within the loop iteration to catch potential exceptions during the processing of a specific menu choice, allowing the loop to potentially continue after an error.
 *     *   **Helper Methods (`submitRequestOption`, `processNextRequestOption`, etc.):** These methods encapsulate the logic for each menu option, prompting the user for necessary input (using `System.out`) and calling the appropriate methods on the `BuildQueueManager`. Validation for submit request is delegated to the manager class.
 *     *   **`System.out` and `System.err`:** Used appropriately throughout the code: `System.out` for menus, prompts, successful operations, and displaying request lists; `System.err` for all error conditions (invalid input, empty queue, exceptions).
 * 
 * This structure effectively uses all required components in a practical scenario, demonstrates good object-oriented design principles (encapsulation, separation of concerns), and includes necessary error handling and input validation.
 */

import java.util.Queue;
import java.util.LinkedList;
import java.util.List;
import java.util.ArrayList;
import java.util.Scanner;
import java.util.Collections; // For unmodifiable lists

// Enum for request status
enum RequestStatus {
    PENDING,
    PROCESSING,
    COMPLETED
}

/**
 * Represents a single software build request.
 */
class BuildRequest {
    private static int nextRequestId = 1; // Static counter for unique IDs

    private int requestId;
    private String projectName;
    private String version;
    private RequestStatus status;

    /**
     * Constructs a new BuildRequest.
     * Automatically assigns a unique ID and sets initial status to PENDING.
     * @param projectName The name of the project.
     * @param version The version of the project.
     */
    public BuildRequest(String projectName, String version) {
        this.requestId = nextRequestId++; // Assign unique ID and increment counter
        this.projectName = projectName;
        this.version = version;
        this.status = RequestStatus.PENDING; // Initial status
    }

    // --- Getters ---
    public int getRequestId() {
        return requestId;
    }

    public String getProjectName() {
        return projectName;
    }

    public String getVersion() {
        return version;
    }

    public RequestStatus getStatus() {
        return status;
    }

    /**
     * Updates the status of the build request.
     * @param status The new status.
     */
    public void setStatus(RequestStatus status) {
        this.status = status;
    }

    @Override
    public String toString() {
        return "[ID: " + requestId + ", Project: " + projectName + ", Version: " + version + ", Status: " + status + "]";
    }
}

/**
 * Manages the queue of pending build requests and a list of completed requests.
 */
class BuildQueueManager {
    private Queue<BuildRequest> buildQueue; // Queue for pending requests (FIFO)
    private List<BuildRequest> processedRequests; // List for completed requests

    /**
     * Constructs a new BuildQueueManager.
     * Initializes the queue and list.
     */
    public BuildQueueManager() {
        // Use LinkedList as a Queue implementation
        this.buildQueue = new LinkedList<>();
        // Use ArrayList for the list of processed requests
        this.processedRequests = new ArrayList<>();
    }

    /**
     * Submits a new build request to the queue.
     * Performs basic validation on project name and version.
     * @param projectName The name of the project.
     * @param version The version of the project.
     * @return true if the request was submitted successfully, false otherwise.
     */
    public boolean submitRequest(String projectName, String version) {
        // Input validation
        if (projectName == null || projectName.trim().isEmpty() || version == null || version.trim().isEmpty()) {
            System.err.println("Error: Project name and version cannot be empty.");
            return false;
        }

        BuildRequest newRequest = new BuildRequest(projectName.trim(), version.trim());
        buildQueue.offer(newRequest); // Add to the end of the queue
        System.out.println("Build request submitted: " + newRequest);
        return true;
    }

    /**
     * Processes the next request from the pending queue.
     * Moves the request from pending to completed list.
     * @return true if a request was processed, false if the queue was empty.
     */
    public boolean processNextRequest() {
        BuildRequest requestToProcess = buildQueue.poll(); // Get and remove the head of the queue

        if (requestToProcess == null) {
            // Queue is empty
            System.err.println("Error: No pending requests to process.");
            return false;
        }

        // Simulate processing
        System.out.println("Processing request: " + requestToProcess);
        requestToProcess.setStatus(RequestStatus.PROCESSING);

        // Simulate completion
        requestToProcess.setStatus(RequestStatus.COMPLETED);
        processedRequests.add(requestToProcess); // Add to the completed list

        System.out.println("Request ID " + requestToProcess.getRequestId() + " processed successfully.");
        return true;
    }

    /**
     * Gets a list of all pending build requests.
     * Returns a copy to prevent external modification of the internal queue.
     * @return A List of pending BuildRequest objects.
     */
    public List<BuildRequest> getPendingRequests() {
        // Return a new ArrayList containing elements from the queue
        // This converts the Queue elements into a List and provides a copy
        return new ArrayList<>(buildQueue);
    }

    /**
     * Gets a list of all completed build requests.
     * Returns a copy to prevent external modification of the internal list.
     * @return A List of completed BuildRequest objects.
     */
    public List<BuildRequest> getCompletedRequests() {
        // Return a new ArrayList containing elements from the processedRequests list
        // This provides a copy of the internal list
        return new ArrayList<>(processedRequests);
        // Alternative: return Collections.unmodifiableList(processedRequests);
        // This returns a view that cannot be modified, but still points to the original list.
        // Returning a new ArrayList is safer if the exam requires strict copy.
    }
}

/**
 * Main application class for the Build Queue simulation.
 * Handles user interaction and menu display.
 */
public class BuildQueueApp {

    private static final BuildQueueManager queueManager = new BuildQueueManager();
    private static final Scanner scanner = new Scanner(System.in);

    public static void main(String[] args) {
        System.out.println("--- Software Build & Deployment Queue Simulation ---");

        // Use a try-catch block to handle potential exceptions during execution
        // Catches general exceptions for robustness, though specific catches
        // for input errors are handled within methods.
        try {
            runMenuLoop();
        } catch (Exception e) {
            System.err.println("An unexpected error occurred: " + e.getMessage());
            e.printStackTrace(System.err); // Print stack trace to stderr
        } finally {
            // Ensure the scanner is closed
            if (scanner != null) {
                scanner.close();
            }
            System.out.println("Application exiting. Goodbye!");
        }
    }

    /**
     * Runs the main menu loop for user interaction.
     */
    private static void runMenuLoop() {
        int choice;
        do {
            printMenu();
            System.out.print("Enter your choice: ");

            // Use a nested try-catch for reading the choice specifically
            try {
                // Check if there is an integer to read to prevent InputMismatchException
                if (scanner.hasNextInt()) {
                    choice = scanner.nextInt();
                } else {
                    // Consume the invalid input line and set choice to 0 (invalid)
                    System.err.println("Error: Invalid input. Please enter a number.");
                    scanner.next(); // Consume the non-integer input
                    choice = 0; // Set to an invalid choice to trigger default case
                }
                scanner.nextLine(); // Consume the newline character left by nextInt()

                // Process the valid or invalid choice using switch
                switch (choice) {
                    case 1:
                        submitRequestOption();
                        break;
                    case 2:
                        processNextRequestOption();
                        break;
                    case 3:
                        viewPendingRequestsOption();
                        break;
                    case 4:
                        viewCompletedRequestsOption();
                        break;
                    case 5:
                        System.out.println("Exiting application...");
                        break;
                    default:
                        if (choice != 0) { // Avoid printing error again if it was already handled by hasNextInt() check
                             System.err.println("Error: Invalid choice. Please enter a number between 1 and 5.");
                        }
                        break;
                }
            } catch (Exception e) {
                // Catch any other unexpected exceptions during the loop iteration
                System.err.println("An error occurred during menu processing: " + e.getMessage());
                e.printStackTrace(System.err);
                choice = 0; // Continue loop after error
            }

        } while (choice != 5);
    }

    /**
     * Displays the main menu options.
     */
    private static void printMenu() {
        System.out.println("\n--- Build Queue Menu ---");
        System.out.println("1. Submit New Build Request");
        System.out.println("2. Process Next Request");
        System.out.println("3. View Pending Requests");
        System.out.println("4. View Completed Requests");
        System.out.println("5. Exit");
    }

    /**
     * Handles the "Submit New Build Request" option.
     * Prompts user for project name and version.
     */
    private static void submitRequestOption() {
        System.out.print("Enter project name: ");
        String projectName = scanner.nextLine();
        System.out.print("Enter version: ");
        String version = scanner.nextLine();

        // Validation is handled within BuildQueueManager.submitRequest
        queueManager.submitRequest(projectName, version);
    }

    /**
     * Handles the "Process Next Request" option.
     */
    private static void processNextRequestOption() {
        queueManager.processNextRequest();
    }

    /**
     * Handles the "View Pending Requests" option.
     * Displays all requests currently in the queue.
     */
    private static void viewPendingRequestsOption() {
        List<BuildRequest> pending = queueManager.getPendingRequests();
        System.out.println("\n--- Pending Requests ---");
        if (pending.isEmpty()) {
            System.out.println("No pending requests.");
        } else {
            for (BuildRequest req : pending) {
                System.out.println(req);
            }
        }
    }

    /**
     * Handles the "View Completed Requests" option.
     * Displays all requests that have been processed.
     */
    private static void viewCompletedRequestsOption() {
        List<BuildRequest> completed = queueManager.getCompletedRequests();
        System.out.println("\n--- Completed Requests ---");
        if (completed.isEmpty()) {
            System.out.println("No completed requests.");
        } else {
            for (BuildRequest req : completed) {
                System.out.println(req);
            }
        }
    }
}
