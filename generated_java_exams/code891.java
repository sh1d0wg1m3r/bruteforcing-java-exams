/*
 * Exam Question #891
 * Generated on: 2025-05-12 16:55:54
 * Generated by: Account 1
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Office Task Automation System
 * 
 * **Objective:** Design and implement a simple system to manage office tasks. Tasks are added to a queue for processing, and after processing, they are moved to an archive list. The system should be interactive, handling user input and demonstrating robust error handling.
 * 
 * **Scenario:** Imagine a small office with shared resources (printers, scanners, filing systems). Tasks (printing, scanning, filing) are submitted by users and processed one by one in the order they are received.
 * 
 * **Requirements:**
 * 
 * 1.  **Task Representation:** Create a class named `Task` with the following private fields:
 *     *   `id` (an integer, unique identifier)
 *     *   `description` (a String describing the task)
 *     *   `type` (a String representing the task type, e.g., "PRINT", "SCAN", "FILE").
 *     *   Include a constructor, appropriate getters, and a `toString()` method to display task details.
 * 
 * 2.  **System Management:** Create a class named `OfficeTaskSystem` that manages the tasks. It must contain:
 *     *   A private field `pendingTasks` of type `java.util.Queue<Task>`.
 *     *   A private field `processedTasks` of type `java.util.List<Task>`, instantiated as a `java.util.ArrayList`.
 *     *   A private field `scanner` of type `java.util.Scanner` for reading user input.
 *     *   A private field `nextTaskId` (an integer) to generate unique task IDs, initialized to 1.
 * 
 * 3.  **Functionality:** Implement the following operations within `OfficeTaskSystem`, accessible via a menu:
 *     *   **Add New Task:** Prompt the user for task description and type. Validate the task type (only "PRINT", "SCAN", "FILE" are allowed, case-insensitive). If valid, create a `Task` object with a unique ID and add it to the `pendingTasks` queue. If invalid, print an error to `System.err`.
 *     *   **View Pending Tasks:** Display all tasks currently in the `pendingTasks` queue, showing their ID, description, and type.
 *     *   **Process Next Task:** Remove the task at the front of the `pendingTasks` queue and add it to the `processedTasks` list. If the queue is empty, print an error message to `System.err` and do nothing. Print a success message to `System.out` indicating which task was processed.
 *     *   **View Processed Tasks:** Display all tasks currently in the `processedTasks` list, showing their ID, description, and type.
 *     *   **Exit:** Terminate the program.
 * 
 * 4.  **User Interface:** Implement a simple menu-driven interface using a `switch` statement within a loop in the `OfficeTaskSystem` class. The menu should display the available options (1-5).
 * 
 * 5.  **Error Handling:**
 *     *   Use `System.err` for all error messages (invalid input, invalid operations like processing an empty queue).
 *     *   Use `System.out` for all normal output (menu, prompts, success messages, task lists).
 *     *   Implement class-wide exception handling using `try-catch` blocks. This should ideally wrap the main operational loop to catch unexpected runtime exceptions or input errors (like non-integer input for menu choice) and prevent the program from crashing. The system should report the error and continue running if possible.
 * 
 * 6.  **Best Practices:**
 *     *   Adhere to encapsulation principles (private fields, public methods).
 *     *   Use meaningful variable and method names.
 *     *   Include appropriate comments and basic documentation (e.g., Javadoc for classes/methods).
 *     *   Perform input validation (task type, menu choice).
 * 
 * **Expected Output:**
 * 
 * The program should present a clear menu, respond to user choices, print task details and status messages to `System.out`, and print specific error messages to `System.err` when invalid actions or inputs occur. The system should be resilient to invalid user input and operational errors, continuing execution after reporting the error.
 * 
 * Example Interaction Snippet:
 * 
 * ```
 * --- Office Task System Menu ---
 * 1. Add New Task
 * 2. View Pending Tasks
 * 3. Process Next Task
 * 4. View Processed Tasks
 * 5. Exit
 * Enter your choice: 1
 * Enter task description: Print quarterly report
 * Enter task type (PRINT, SCAN, FILE): PRINT
 * Task 1 (PRINT) added to queue.
 * 
 * --- Office Task System Menu ---
 * 1. Add New Task
 * 2. View Pending Tasks
 * 3. Process Next Task
 * 4. View Processed Tasks
 * 5. Exit
 * Enter your choice: 2
 * Pending Tasks:
 * [Task ID: 1, Type: PRINT, Description: Print quarterly report]
 * 
 * --- Office Task System Menu ---
 * 1. Add New Task
 * 2. View Pending Tasks
 * 3. Process Next Task
 * 4. View Processed Tasks
 * 5. Exit
 * Enter your choice: 3
 * Processed task: Task ID: 1, Type: PRINT, Description: Print quarterly report
 * 
 * --- Office Task System Menu ---
 * 1. Add New Task
 * 2. View Pending Tasks
 * 3. Process Next Task
 * 4. View Processed Tasks
 * 5. Exit
 * Enter your choice: 4
 * Processed Tasks:
 * [Task ID: 1, Type: PRINT, Description: Print quarterly report]
 * 
 * --- Office Task System Menu ---
 * 1. Add New Task
 * 2. View Pending Tasks
 * 3. Process Next Task
 * 4. View Processed Tasks
 * 5. Exit
 * Enter your choice: 3
 * Error: No pending tasks to process.
 * 
 * --- Office Task System Menu ---
 * ...
 * Enter your choice: invalid
 * Error: Invalid input. Please enter a number.
 * 
 * --- Office Task System Menu ---
 * ...
 * Enter your choice: 6
 * Error: Invalid menu choice. Please enter a number between 1 and 5.
 * ```
 * 
 * **Constraint Checklist:**
 * *   [x] Queue (`java.util.Queue`)
 * *   [x] ArrayList (`java.util.ArrayList`)
 * *   [x] List interface (`java.util.List`)
 * *   [x] Scanner (`java.util.Scanner`)
 * *   [x] Switch statement
 * *   [x] System.err
 * *   [x] System.out
 * *   [x] Class-wide exception handling (`try-catch`)
 * *   [x] Encapsulation
 * *   [x] Meaningful names
 * *   [x] Comments/Documentation
 * *   [x] Input validation
 * *   [x] Proper error handling
 * *   [x] Clean code structure
 * *   [x] Real-world scenario simulation
 * *   [x] Challenging but solvable
 * 
 * This task requires you to integrate several core Java concepts and standard library components into a functional, well-structured, and robust application.
 *
 * EXPLANATION:
 * The provided solution implements the `OfficeTaskSystem` as required, demonstrating the use of various core Java concepts and collections.
 * 
 * 1.  **`Task` Class:** This simple class encapsulates the data for a single task (`id`, `description`, `type`) following encapsulation principles with private fields and public getters. The `toString()` method provides a convenient way to display task information.
 * 
 * 2.  **`OfficeTaskSystem` Class:** This is the main class managing the system's state and logic.
 *     *   `pendingTasks`: A `Queue<Task>` is used here, specifically implemented by `LinkedList`. `Queue` is appropriate because tasks are processed in a First-In, First-Out (FIFO) manner. The `add()` method is used to enqueue tasks, and `poll()` is used to dequeue the next task for processing.
 *     *   `processedTasks`: A `List<Task>` is used, implemented by `ArrayList`. `List` is suitable for storing processed tasks where order might be relevant (chronological processing order) and allows easy iteration and viewing. Using `List` as the declared type adheres to the requirement and promotes good practice by programming to the interface.
 *     *   `scanner`: An instance of `java.util.Scanner` reads input from `System.in`.
 *     *   `nextTaskId`: A simple counter to ensure each task gets a unique ID.
 * 
 * 3.  **Functionality Methods:**
 *     *   `displayMenu()`: A helper method to show the user options.
 *     *   `addTask()`: Reads description and type from the user. It includes input validation to check if the entered task type is one of the allowed values ("PRINT", "SCAN", "FILE"), ignoring case. If invalid, it prints an error to `System.err` and returns. Otherwise, it creates a new `Task` object, increments `nextTaskId`, and adds the task to the `pendingTasks` queue using `add()`.
 *     *   `viewPendingTasks()`: Iterates through the `pendingTasks` queue (using `forEach`) and prints each task's `toString()` representation to `System.out`. It checks if the queue is empty first.
 *     *   `processNextTask()`: Uses `pendingTasks.poll()` to get and remove the head of the queue. `poll()` is used because it returns `null` if the queue is empty, which is handled by printing an error message to `System.err`. If a task is retrieved, it's added to the `processedTasks` list using `add()`, and a success message is printed to `System.out`.
 *     *   `viewProcessedTasks()`: Iterates through the `processedTasks` list (using `forEach`) and prints each task's `toString()` representation to `System.out`. It checks if the list is empty first.
 * 
 * 4.  **User Interface and Control Flow:**
 *     *   The `run()` method contains the main application loop (`while(running)`).
 *     *   Inside the loop, the menu is displayed, and user input is read using `scanner.nextInt()` for the menu choice.
 *     *   A `switch` statement is used to direct execution based on the user's `choice`. Each case calls the corresponding method.
 *     *   A `default` case handles invalid integer choices (outside 1-5), printing an error to `System.err`.
 *     *   `scanner.nextLine()` is called after `scanner.nextInt()` to consume the newline character left in the input buffer, preventing issues in subsequent `scanner.nextLine()` calls within `addTask`.
 * 
 * 5.  **Error Handling and Exception Handling:**
 *     *   Specific error conditions (invalid task type, empty queue during processing, invalid menu number) are checked explicitly, and messages are printed to `System.err`.
 *     *   **Class-wide exception handling:** A `try-catch(Exception e)` block wraps the main `while(running)` loop in the `run()` method. This serves as a broad handler for any unexpected runtime exceptions that might occur within the loop's execution.
 *     *   **Input Mismatch Handling:** A more specific `try-catch(InputMismatchException e)` is nested inside the loop to specifically catch cases where the user enters non-integer input for the menu choice. This prevents the program from crashing due to invalid input type. After catching `InputMismatchException`, an error is printed to `System.err`, `scanner.next()` consumes the invalid token, and `continue` restarts the loop, prompting the menu again.
 *     *   A `finally` block ensures the `scanner` is closed when the `run` method finishes (either by exiting the loop normally or due to an exception).
 * 
 * 6.  **Best Practices:**
 *     *   Encapsulation is used in the `Task` and `OfficeTaskSystem` classes.
 *     *   Variable and method names are descriptive (e.g., `pendingTasks`, `processNextTask`).
 *     *   Basic Javadoc comments are included for classes and methods.
 *     *   Input validation for task type and menu choice is implemented.
 *     *   Error messages are directed to `System.err`, while normal output goes to `System.out`.
 *     *   The code is structured logically into separate methods for different functionalities.
 * 
 * This solution effectively integrates all required components (`Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.err`, `System.out`, `try-catch`) in a practical scenario, demonstrating good programming practices and robust error handling.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.InputMismatchException;

/**
 * Represents a single task in the office automation system.
 */
class Task {
    private int id;
    private String description;
    private String type; // e.g., PRINT, SCAN, FILE

    /**
     * Constructs a new Task.
     * @param id The unique identifier for the task.
     * @param description A brief description of the task.
     * @param type The type of the task (e.g., "PRINT", "SCAN", "FILE").
     */
    public Task(int id, String description, String type) {
        this.id = id;
        this.description = description;
        this.type = type;
    }

    // Getters
    public int getId() {
        return id;
    }

    public String getDescription() {
        return description;
    }

    public String getType() {
        return type;
    }

    /**
     * Returns a string representation of the Task.
     * @return A formatted string including task ID, type, and description.
     */
    @Override
    public String toString() {
        return String.format("[Task ID: %d, Type: %s, Description: %s]", id, type, description);
    }
}

/**
 * Manages the queue of pending tasks and the list of processed tasks.
 * Provides a menu-driven interface for user interaction.
 */
public class OfficeTaskSystem {
    private Queue<Task> pendingTasks;
    private List<Task> processedTasks; // Declared as List, implemented by ArrayList
    private Scanner scanner;
    private int nextTaskId;

    /**
     * Constructs an OfficeTaskSystem, initializing collections and scanner.
     */
    public OfficeTaskSystem() {
        // Using LinkedList as a Queue implementation
        this.pendingTasks = new LinkedList<>();
        // Using ArrayList as a List implementation
        this.processedTasks = new ArrayList<>();
        this.scanner = new Scanner(System.in);
        this.nextTaskId = 1;
    }

    /**
     * Displays the main menu to the user.
     */
    private void displayMenu() {
        System.out.println("\n--- Office Task System Menu ---");
        System.out.println("1. Add New Task");
        System.out.println("2. View Pending Tasks");
        System.out.println("3. Process Next Task");
        System.out.println("4. View Processed Tasks");
        System.out.println("5. Exit");
        System.out.print("Enter your choice: ");
    }

    /**
     * Adds a new task based on user input.
     * Validates task type.
     */
    private void addTask() {
        System.out.print("Enter task description: ");
        String description = scanner.nextLine();

        System.out.print("Enter task type (PRINT, SCAN, FILE): ");
        String type = scanner.nextLine().trim().toUpperCase();

        // Input validation for task type
        if (!type.equals("PRINT") && !type.equals("SCAN") && !type.equals("FILE")) {
            System.err.println("Error: Invalid task type. Allowed types are PRINT, SCAN, FILE.");
            return; // Exit method if type is invalid
        }

        Task newTask = new Task(nextTaskId++, description, type);
        pendingTasks.add(newTask); // Add task to the queue
        System.out.println("Task " + newTask.getId() + " (" + newTask.getType() + ") added to queue.");
    }

    /**
     * Displays all tasks currently in the pending tasks queue.
     */
    private void viewPendingTasks() {
        System.out.println("\nPending Tasks:");
        if (pendingTasks.isEmpty()) {
            System.out.println("No tasks in the pending queue.");
        } else {
            // Iterate through the queue without removing elements
            pendingTasks.forEach(System.out::println);
        }
    }

    /**
     * Processes the next task from the queue.
     * Removes the task from pendingTasks and adds it to processedTasks.
     * Handles empty queue condition.
     */
    private void processNextTask() {
        Task taskToProcess = pendingTasks.poll(); // Retrieve and remove the head of the queue

        if (taskToProcess == null) {
            System.err.println("Error: No pending tasks to process.");
        } else {
            processedTasks.add(taskToProcess); // Add processed task to the list
            System.out.println("Processed task: " + taskToProcess);
        }
    }

    /**
     * Displays all tasks that have been processed.
     */
    private void viewProcessedTasks() {
        System.out.println("\nProcessed Tasks:");
        if (processedTasks.isEmpty()) {
            System.out.println("No tasks have been processed yet.");
        } else {
            // Iterate through the list
            processedTasks.forEach(System.out::println);
        }
    }

    /**
     * Runs the main loop of the task system, handling user interaction.
     * Includes class-wide exception handling.
     */
    public void run() {
        boolean running = true;

        // Class-wide exception handling wrapping the main operational loop
        try {
            while (running) {
                displayMenu();
                int choice = -1; // Default invalid choice

                try {
                    choice = scanner.nextInt();
                } catch (InputMismatchException e) {
                    // Catch non-integer input specifically
                    System.err.println("Error: Invalid input. Please enter a number.");
                    scanner.next(); // Consume the invalid input to prevent infinite loop
                    continue; // Skip the switch and show menu again
                } finally {
                     // Consume the rest of the line after reading the integer choice
                     // This is necessary to prevent issues with nextLine() after nextInt()
                     scanner.nextLine();
                }


                switch (choice) {
                    case 1:
                        addTask();
                        break;
                    case 2:
                        viewPendingTasks();
                        break;
                    case 3:
                        processNextTask();
                        break;
                    case 4:
                        viewProcessedTasks();
                        break;
                    case 5:
                        System.out.println("Exiting Office Task System. Goodbye!");
                        running = false;
                        break;
                    default:
                        System.err.println("Error: Invalid menu choice. Please enter a number between 1 and 5.");
                }
            }
        } catch (Exception e) {
            // Catch any other unexpected exceptions during execution
            System.err.println("An unexpected error occurred: " + e.getMessage());
            // e.printStackTrace(System.err); // Uncomment for debugging
        } finally {
            // Ensure scanner is closed when the program exits
            scanner.close();
            System.out.println("Scanner closed.");
        }
    }

    /**
     * Main method to start the Office Task System.
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        OfficeTaskSystem system = new OfficeTaskSystem();
        system.run();
    }
}
