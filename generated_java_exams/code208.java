/*
 * Exam Question #208
 * Generated on: 2025-05-11 22:32:12
 * Generated by: Account 5
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Software Build Pipeline Simulator
 * 
 * **Objective:**
 * 
 * Design and implement a simple command-line application that simulates a software build and deployment pipeline. The pipeline processes tasks sequentially. Tasks are added to a queue, processed one by one, and then moved to a history list.
 * 
 * **Requirements:**
 * 
 * 1.  **Pipeline:** Use a `java.util.Queue` to represent the tasks waiting to be processed in the pipeline.
 * 2.  **History:** Use a `java.util.ArrayList` to store tasks that have been processed. Declare the variable using the `java.util.List` interface (`List<Task> history = new ArrayList<>();`).
 * 3.  **Task Representation:** Create a simple class `PipelineTask` with the following attributes:
 *     *   `name` (String): The name of the task (e.g., "Build Module A", "Run Unit Tests", "Deploy to Staging").
 *     *   `status` (String): The current status of the task (e.g., "PENDING", "PROCESSING", "COMPLETED", "FAILED").
 * 4.  **User Interaction:**
 *     *   Use `java.util.Scanner` to read user commands from the console.
 *     *   Present a menu of options to the user:
 *         1.  Add Task to Pipeline
 *         2.  Process Next Task
 *         3.  View Current Pipeline
 *         4.  View Task History
 *         5.  Exit
 *     *   Implement a loop that continues until the user chooses to exit.
 *     *   Use a `switch` statement to handle the different user commands.
 * 5.  **Task Processing:**
 *     *   When "Process Next Task" is selected, take the task from the front of the `Queue`.
 *     *   Simulate processing: Change the task's status from "PENDING" to "PROCESSING". Then, simulate a random outcome (e.g., 80% chance of "COMPLETED", 20% chance of "FAILED"). Update the status accordingly.
 *     *   Move the processed task from the queue (it was already removed by `poll` or similar) to the `List` of historical tasks.
 *     *   If the pipeline is empty when processing is attempted, print an error message.
 * 6.  **Output:**
 *     *   Use `System.out` for all normal output (menu, prompts, task details, simulation results).
 *     *   Use `System.err` for all error messages (e.g., invalid input, attempting to process from an empty pipeline).
 * 7.  **Error Handling:**
 *     *   Implement robust exception handling using `try-catch` blocks.
 *     *   Handle potential `InputMismatchException` if the user enters non-numeric input for menu selection.
 *     *   Handle attempting to process from an empty queue (this might throw `NoSuchElementException` depending on the method used, or you can check `isEmpty()` explicitly).
 *     *   Wrap the main user interaction loop within a `try-catch` to demonstrate class-wide exception handling for unexpected issues.
 * 8.  **Best Practices:**
 *     *   Implement proper encapsulation for the `PipelineTask` class (private fields, public getters).
 *     *   Use meaningful names for variables, methods, and classes.
 *     *   Include appropriate comments and documentation (e.g., Javadoc for classes and methods).
 *     *   Validate user input where necessary (e.g., checking menu option range).
 *     *   Structure the code clearly with separate methods for different functionalities (adding task, processing, viewing, etc.).
 *     *   Ensure the `Scanner` resource is closed properly.
 * 
 * **Expected Output:**
 * 
 * The program should present a menu, accept user input, perform the requested action, and display relevant information or error messages. Examples:
 * 
 * *   Adding a task: Prompt for name, confirm addition.
 * *   Processing: Indicate which task is being processed, its final status, and confirmation it was moved to history. Handle empty queue.
 * *   Viewing Pipeline: List tasks currently in the queue with their status.
 * *   Viewing History: List tasks in the history list with their final status.
 * *   Invalid input: Print an error message using `System.err`.
 * 
 * Your solution should be a single Java file containing all necessary classes.
 * 
 * **Example Interaction Flow:**
 * 
 * ```
 * Pipeline Simulator Menu:
 * 1. Add Task to Pipeline
 * 2. Process Next Task
 * 3. View Current Pipeline
 * 4. View Task History
 * 5. Exit
 * Enter your choice: 1
 * Enter task name: Build Frontend
 * Task 'Build Frontend' added to the pipeline.
 * 
 * Pipeline Simulator Menu:
 * ...
 * Enter your choice: 1
 * Enter task name: Run Tests
 * Task 'Run Tests' added to the pipeline.
 * 
 * Pipeline Simulator Menu:
 * ...
 * Enter your choice: 3
 * Current Pipeline:
 * [PENDING] Build Frontend
 * [PENDING] Run Tests
 * 
 * Pipeline Simulator Menu:
 * ...
 * Enter your choice: 2
 * Processing task: Build Frontend...
 * Task 'Build Frontend' COMPLETED. Moved to history.
 * 
 * Pipeline Simulator Menu:
 * ...
 * Enter your choice: 3
 * Current Pipeline:
 * [PENDING] Run Tests
 * 
 * Pipeline Simulator Menu:
 * ...
 * Enter your choice: 4
 * Task History:
 * [COMPLETED] Build Frontend
 * 
 * Pipeline Simulator Menu:
 * ...
 * Enter your choice: 2
 * Processing task: Run Tests...
 * Task 'Run Tests' FAILED. Moved to history.
 * 
 * Pipeline Simulator Menu:
 * ...
 * Enter your choice: 4
 * Task History:
 * [COMPLETED] Build Frontend
 * [FAILED] Run Tests
 * 
 * Pipeline Simulator Menu:
 * ...
 * Enter your choice: 5
 * Exiting simulator.
 * ```
 * 
 * *(Note: The exact output format for lists can vary, but should clearly show task name and status.)*
 *
 * EXPLANATION:
 * 
 */

import java.util.Queue;
import java.util.LinkedList; // Common Queue implementation
import java.util.List;
import java.util.ArrayList;
import java.util.Scanner;
import java.util.InputMismatchException;
import java.util.NoSuchElementException;
import java.util.Random;

/**
 * Represents a single task in the build pipeline.
 */
class PipelineTask {
    private String name;
    private String status; // e.g., PENDING, PROCESSING, COMPLETED, FAILED

    /**
     * Constructs a new PipelineTask with a name and initial status PENDING.
     * @param name The name of the task.
     */
    public PipelineTask(String name) {
        this.name = name;
        this.status = "PENDING";
    }

    /**
     * Gets the name of the task.
     * @return The task name.
     */
    public String getName() {
        return name;
    }

    /**
     * Gets the current status of the task.
     * @return The task status.
     */
    public String getStatus() {
        return status;
    }

    /**
     * Sets the status of the task.
     * @param status The new status.
     */
    public void setStatus(String status) {
        this.status = status;
    }

    /**
     * Returns a string representation of the task.
     * @return String format: [STATUS] TaskName
     */
    @Override
    public String toString() {
        return "[" + status + "] " + name;
    }
}

/**
 * Simulates a software build and deployment pipeline.
 * Manages tasks in a queue and keeps a history of processed tasks.
 */
public class PipelineSimulator {

    private Queue<PipelineTask> pipelineQueue;
    private List<PipelineTask> taskHistory;
    private Scanner scanner;
    private Random random; // For simulating processing outcome

    /**
     * Constructs a new PipelineSimulator.
     * Initializes the queue, history list, scanner, and random generator.
     */
    public PipelineSimulator() {
        // Use LinkedList as a common Queue implementation
        this.pipelineQueue = new LinkedList<>();
        // Use ArrayList for the history list, programming to the List interface
        this.taskHistory = new ArrayList<>();
        this.scanner = new Scanner(System.in);
        this.random = new Random();
    }

    /**
     * Runs the main simulation loop, handling user interaction.
     */
    public void runSimulation() {
        System.out.println("Welcome to the Pipeline Simulator!");

        // Class-wide exception handling for the main simulation loop
        try {
            boolean running = true;
            while (running) {
                printMenu();
                int choice = getUserChoice();

                // Use switch statement for flow control based on user choice
                switch (choice) {
                    case 1:
                        addTask();
                        break;
                    case 2:
                        processNextTask();
                        break;
                    case 3:
                        viewPipeline();
                        break;
                    case 4:
                        viewHistory();
                        break;
                    case 5:
                        running = false;
                        System.out.println("Exiting simulator.");
                        break;
                    default:
                        // Handle invalid integer choices
                        System.err.println("Invalid choice. Please enter a number between 1 and 5.");
                }
                System.out.println(); // Add a blank line for readability
            }
        } catch (Exception e) {
            // Catch any unexpected exceptions during the simulation run
            System.err.println("An unexpected error occurred during simulation: " + e.getMessage());
            e.printStackTrace(System.err); // Print stack trace to System.err
        } finally {
            // Ensure scanner is closed when the simulation ends
            if (scanner != null) {
                scanner.close();
            }
        }
    }

    /**
     * Prints the main menu options to System.out.
     */
    private void printMenu() {
        System.out.println("Pipeline Simulator Menu:");
        System.out.println("1. Add Task to Pipeline");
        System.out.println("2. Process Next Task");
        System.out.println("3. View Current Pipeline");
        System.out.println("4. View Task History");
        System.out.println("5. Exit");
        System.out.print("Enter your choice: ");
    }

    /**
     * Reads and validates the user's menu choice.
     * Handles InputMismatchException if non-integer input is provided.
     * @return The valid menu choice.
     */
    private int getUserChoice() {
        int choice = -1;
        try {
            choice = scanner.nextInt();
        } catch (InputMismatchException e) {
            // Handle case where input is not an integer
            System.err.println("Invalid input. Please enter a number.");
            scanner.next(); // Consume the invalid input to prevent infinite loop
        }
        // Note: Validation for the range 1-5 is done in the switch statement's default case
        return choice;
    }

    /**
     * Prompts user for task name, creates a task, and adds it to the pipeline queue.
     */
    private void addTask() {
        System.out.print("Enter task name: ");
        // Consume the newline character left by nextInt()
        scanner.nextLine();
        String taskName = scanner.nextLine().trim();

        if (taskName.isEmpty()) {
            System.err.println("Task name cannot be empty.");
            return;
        }

        PipelineTask newTask = new PipelineTask(taskName);
        pipelineQueue.offer(newTask); // offer is preferred over add in queues as it returns false on failure
        System.out.println("Task '" + taskName + "' added to the pipeline.");
    }

    /**
     * Processes the next task in the pipeline queue.
     * Simulates processing, updates status, and moves the task to history.
     */
    private void processNextTask() {
        // Check if the queue is empty before attempting to poll
        if (pipelineQueue.isEmpty()) {
            System.err.println("The pipeline is empty. No tasks to process.");
            return;
        }

        // poll() retrieves and removes the head of the queue, returns null if empty
        // We already checked for empty, so poll() is safe or we could use remove() which throws NoSuchElementException
        PipelineTask taskToProcess = pipelineQueue.poll();

        System.out.println("Processing task: " + taskToProcess.getName() + "...");
        taskToProcess.setStatus("PROCESSING"); // Update status to processing

        // Simulate processing time (optional, can add Thread.sleep)
        // Simulate outcome (80% success, 20% failure)
        if (random.nextDouble() < 0.8) { // 80% chance
            taskToProcess.setStatus("COMPLETED");
            System.out.println("Task '" + taskToProcess.getName() + "' COMPLETED.");
        } else { // 20% chance
            taskToProcess.setStatus("FAILED");
            System.err.println("Task '" + taskToProcess.getName() + "' FAILED.");
        }

        // Move the processed task to the history list
        taskHistory.add(taskToProcess);
        System.out.println("Task '" + taskToProcess.getName() + "' moved to history.");
    }

    /**
     * Displays the tasks currently in the pipeline queue.
     */
    private void viewPipeline() {
        System.out.println("Current Pipeline:");
        if (pipelineQueue.isEmpty()) {
            System.out.println("The pipeline is empty.");
        } else {
            // Iterate through the queue without removing elements
            for (PipelineTask task : pipelineQueue) {
                System.out.println(task); // Uses PipelineTask's toString()
            }
        }
    }

    /**
     * Displays the tasks in the history list.
     */
    private void viewHistory() {
        System.out.println("Task History:");
        if (taskHistory.isEmpty()) {
            System.out.println("The task history is empty.");
        } else {
            // Iterate through the list
            for (PipelineTask task : taskHistory) {
                System.out.println(task); // Uses PipelineTask's toString()
            }
        }
    }

    /**
     * Main method to start the Pipeline Simulator.
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        PipelineSimulator simulator = new PipelineSimulator();
        simulator.runSimulation();
    }
}
