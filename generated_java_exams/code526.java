/*
 * Exam Question #526
 * Generated on: 2025-05-11 23:24:45
 * Generated by: Account 4
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Event Registration System
 * 
 * **Scenario:** You are building a simplified system to manage registrations for an event with limited capacity. People who try to register after the event is full are placed on a waiting list. When a spot becomes available (simulated by processing the waitlist), the next person on the waiting list is automatically registered.
 * 
 * **Task:** Implement a Java program that simulates this event registration process.
 * 
 * **Requirements:**
 * 
 * 1.  **Core Functionality:**
 *     *   Initialize an event with a fixed maximum capacity (e.g., 10).
 *     *   Allow users to perform the following actions via a command-line menu:
 *         *   **Add Person:** Register a new person. If the event is not full, add them to the list of registered attendees. If the event is full, add them to the waiting list.
 *         *   **Process Waitlist:** Simulate a spot becoming available. Take the next person from the waiting list and move them to the registered attendees list (if the event is not full).
 *         *   **View Registered Attendees:** Display the list of all currently registered people.
 *         *   **View Waiting List:** Display the list of people currently on the waiting list.
 *         *   **Check Person Status:** Given a name, report if the person is registered, on the waiting list, or not found in the system.
 *         *   **Exit:** Terminate the program.
 * 
 * 2.  **Data Structures:**
 *     *   Use a `java.util.Queue` to manage the waiting list (people waiting in order).
 *     *   Use a `java.util.ArrayList` to store the registered attendees.
 *     *   Use the `java.util.List` interface type when declaring the registered attendees list variable.
 * 
 * 3.  **Input/Output:**
 *     *   Use `java.util.Scanner` to read user input (menu choices, names).
 *     *   Use `System.out.println()` for normal program output (menu, prompts, success messages, lists).
 *     *   Use `System.err.println()` for displaying error messages (e.g., invalid input, trying to process an empty waitlist when event is full, person already exists).
 * 
 * 4.  **Control Flow:**
 *     *   Use a `switch` statement to handle the main menu choices.
 * 
 * 5.  **Error Handling:**
 *     *   Implement robust input validation (e.g., ensure names are not empty, handle non-integer input for menu choice).
 *     *   Use `try-catch` blocks for specific potential errors (e.g., `InputMismatchException` from Scanner).
 *     *   Include a **class-wide** `try-catch` block (e.g., around the main operational loop) to catch any unexpected runtime exceptions and print a generic error message using `System.err`.
 * 
 * 6.  **Object-Oriented Design & Best Practices:**
 *     *   Create a simple `Person` class with appropriate fields (e.g., name) and methods (getters, possibly `equals()` and `hashCode()` if needed for checking duplicates easily).
 *     *   Implement proper encapsulation (private fields, public methods).
 *     *   Use meaningful variable and method names.
 *     *   Include appropriate comments and documentation (e.g., Javadocs for methods).
 *     *   Ensure resources like `Scanner` are handled appropriately (though for a simple exam task, not strictly required to close if it's a class-level resource used throughout).
 * 
 * **Expected Output:**
 * 
 * The program should present a menu, prompt for input based on the choice, and print results or error messages.
 * 
 * ```
 * --- Event Registration Menu ---
 * 1. Add Person
 * 2. Process Waitlist
 * 3. View Registered Attendees
 * 4. View Waiting List
 * 5. Check Person Status
 * 6. Exit
 * -----------------------------
 * Enter your choice: [User Input]
 * 
 * [Based on choice, show prompts and output, e.g.]
 * 
 * Enter person's name: [User Input]
 * [System.out] Person [Name] registered successfully. (If space available)
 * [System.out] Event full. Person [Name] added to the waiting list. (If event full)
 * [System.err] Error: Person [Name] is already registered or on the waiting list. (If duplicate)
 * [System.err] Error: Name cannot be empty. (If invalid input)
 * 
 * [For Process Waitlist]
 * [System.out] Processed waitlist. Person [Name] is now registered. (If successful)
 * [System.out] Waitlist is empty. No one to process. (If waitlist empty)
 * [System.out] Event is still full. Cannot process waitlist. (If event full)
 * 
 * [For View Registered/Waiting List]
 * [System.out] Registered Attendees:
 * [List of names]
 * [System.out] (No registered attendees yet.)
 * 
 * [System.out] Waiting List:
 * [List of names]
 * [System.out] (Waiting list is empty.)
 * 
 * [For Check Status]
 * Enter person's name: [User Input]
 * [System.out] Person [Name] is registered.
 * [System.out] Person [Name] is on the waiting list.
 * [System.out] Person [Name] not found in the system.
 * 
 * [For Invalid Menu Choice]
 * [System.err] Error: Invalid choice. Please enter a number between 1 and 6.
 * [System.err] Error: Invalid input. Please enter a number. (If non-integer)
 * 
 * [For unexpected errors]
 * [System.err] An unexpected error occurred: [Error details]
 * 
 * [On Exit]
 * [System.out] Exiting Event Registration System.
 * 
 * ```
 * 
 * **Evaluation:** Your solution will be evaluated based on correctness, adherence to all requirements (especially the use of specified components), code quality, error handling, and clarity.
 *
 * EXPLANATION:
 * The provided solution implements the `EventRegistrationSystem` as required, simulating event registration with limited capacity and a waiting list.
 * 
 * 1.  **`Person` Class:**
 *     *   A simple class `Person` is created to encapsulate the data for an individual, holding their `name`.
 *     *   It includes a constructor, a getter for the name, and overrides `equals()`, `hashCode()`, and `toString()`.
 *     *   Overriding `equals()` and `hashCode()` is crucial because we store `Person` objects in collections (`ArrayList` and `Queue`) and need to correctly check for the existence of a person based on their name (e.g., using `contains()`). The implementation uses case-insensitive name comparison for robustness.
 * 
 * 2.  **`EventRegistrationSystem` Class:**
 *     *   This is the main class managing the system logic.
 *     *   **Fields:**
 *         *   `EVENT_CAPACITY`: A constant defining the maximum number of registered attendees.
 *         *   `registeredAttendees`: Declared as `List<Person>` but initialized as `new ArrayList<>()`. This demonstrates using the interface type for flexibility while using a concrete implementation (`ArrayList`) which is suitable for fast random access and iteration needed for viewing and checking status.
 *         *   `waitingList`: Declared and initialized as `new LinkedList<>()`. `LinkedList` implements the `Queue` interface, providing the necessary FIFO (First-In, First-Out) behavior required for a waiting list (`add()` for adding to the end, `poll()` for removing from the front).
 *         *   `scanner`: A `Scanner` object for reading user input from the console.
 *     *   **Constructor:** Initializes the `ArrayList`, `LinkedList`, and `Scanner`.
 *     *   **`runSystem()` Method:**
 *         *   This is the main operational loop of the system.
 *         *   It contains the **class-wide `try-catch (Exception e)` block** which wraps the entire `while` loop. This block catches any uncaught exceptions that might occur during the system's operation and prints a generic error message using `System.err`, fulfilling a key requirement.
 *         *   Inside the loop, it repeatedly calls `printMenu()`, reads the user's choice, and uses a `switch` statement to dispatch the call to the appropriate method (`addPerson`, `processWaitlist`, etc.).
 *         *   An inner `try-catch (InputMismatchException e)` block specifically handles cases where the user enters non-integer input for the menu choice, printing an error to `System.err` and consuming the invalid input to prevent an infinite loop.
 *         *   A `finally` block is used to ensure the `scanner` resource is closed when the `runSystem` method exits, regardless of whether it's a normal exit or due to an exception caught by the outer `try-catch`.
 *     *   **`printMenu()`:** A simple helper method to display the menu options using `System.out`.
 *     *   **`addPerson()`:**
 *         *   Prompts for the person's name using `System.out`.
 *         *   Reads input using `scanner.nextLine()`.
 *         *   Includes input validation (`trim().isEmpty()`) and uses `System.err` for the error message.
 *         *   Creates a `Person` object.
 *         *   Checks for duplicates in *both* `registeredAttendees` and `waitingList` using the `contains()` method, which relies on the overridden `equals()` method in the `Person` class. Prints an error to `System.err` if a duplicate is found.
 *         *   Checks if `registeredAttendees.size()` is less than `EVENT_CAPACITY`.
 *         *   If space is available, adds the person to `registeredAttendees` (an `ArrayList`). Prints success to `System.out`.
 *         *   If full, adds the person to `waitingList` (a `Queue` using `add()`). Prints success (with waitlist info) to `System.out`.
 *     *   **`processWaitlist()`:**
 *         *   Checks if the `waitingList` is empty or if the event is still full, printing informational messages to `System.out` and returning early if so.
 *         *   If the waitlist is not empty and there's space (`registeredAttendees.size() < EVENT_CAPACITY`), it uses `waitingList.poll()` to retrieve and remove the person at the front of the queue.
 *         *   The polled person is then added to the `registeredAttendees` list.
 *         *   Prints success message to `System.out`. Includes a robustness check for duplicates, although unlikely in this flow.
 *     *   **`viewRegistered()`:**
 *         *   Prints a header using `System.out`.
 *         *   Iterates through the `registeredAttendees` `List` using a standard `for` loop and `get(i)`, printing each person's name using `System.out`.
 *         *   Handles the case where the list is empty.
 *     *   **`viewWaitlist()`:**
 *         *   Prints a header using `System.out`.
 *         *   Iterates through the `waitingList` `Queue` using an enhanced `for` loop. Iterating over a `Queue` allows viewing elements without removing them.
 *         *   Prints each person's name using `System.out`.
 *         *   Handles the case where the queue is empty.
 *     *   **`checkPersonStatus()`:**
 *         *   Prompts for the name using `System.out`.
 *         *   Reads input and performs validation using `System.err`.
 *         *   Creates a temporary `Person` object for searching (again relying on `equals()`).
 *         *   Checks if the person is in `registeredAttendees` using `contains()`. Prints status to `System.out`.
 *         *   If not registered, checks if the person is in `waitingList` using `contains()`. Prints status to `System.out`.
 *         *   If not found in either, prints "not found" status to `System.out`.
 *     *   **`main()`:** Creates an instance of `EventRegistrationSystem` and calls `runSystem()` to start the application.
 * 
 * This solution effectively integrates all the required Java components (`Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.err`, `System.out`, `try-catch`) within a practical, object-oriented structure that demonstrates input validation, error handling, and the distinct roles of a list (for collection/iteration) and a queue (for ordered processing).
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.InputMismatchException;

/**
 * Represents a person for event registration.
 */
class Person {
    private String name;

    /**
     * Constructs a new Person.
     * @param name The name of the person.
     */
    public Person(String name) {
        this.name = name;
    }

    /**
     * Gets the name of the person.
     * @return The person's name.
     */
    public String getName() {
        return name;
    }

    /**
     * Checks if two Person objects are equal based on their name.
     * @param o The object to compare with.
     * @return true if the objects are equal, false otherwise.
     */
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Person person = (Person) o;
        return name.equalsIgnoreCase(person.name); // Case-insensitive comparison for names
    }

    /**
     * Returns a hash code value for the object.
     * @return A hash code value for this object.
     */
    @Override
    public int hashCode() {
        return name.toLowerCase().hashCode(); // Use lowercase for consistent hashing
    }

    /**
     * Returns a string representation of the Person object.
     * @return The person's name.
     */
    @Override
    public String toString() {
        return name;
    }
}

/**
 * Manages event registration with a limited capacity and a waiting list.
 */
public class EventRegistrationSystem {

    private static final int EVENT_CAPACITY = 10; // Fixed capacity
    private List<Person> registeredAttendees; // Use List interface type
    private Queue<Person> waitingList;
    private Scanner scanner;

    /**
     * Constructs a new EventRegistrationSystem.
     * Initializes the registered attendees list, waiting list, and scanner.
     */
    public EventRegistrationSystem() {
        registeredAttendees = new ArrayList<>(); // Implementation is ArrayList
        waitingList = new LinkedList<>(); // LinkedList is a common Queue implementation
        scanner = new Scanner(System.in);
    }

    /**
     * Runs the main loop of the registration system, displaying the menu
     * and processing user input. Includes class-wide exception handling.
     */
    public void runSystem() {
        int choice = -1;
        System.out.println("--- Event Registration System ---");

        // Class-wide exception handling block
        try {
            while (choice != 6) {
                printMenu();
                try {
                    System.out.print("Enter your choice: ");
                    choice = scanner.nextInt();
                    scanner.nextLine(); // Consume newline character

                    switch (choice) {
                        case 1:
                            addPerson();
                            break;
                        case 2:
                            processWaitlist();
                            break;
                        case 3:
                            viewRegistered();
                            break;
                        case 4:
                            viewWaitlist();
                            break;
                        case 5:
                            checkPersonStatus();
                            break;
                        case 6:
                            System.out.println("Exiting Event Registration System.");
                            break;
                        default:
                            System.err.println("Error: Invalid choice. Please enter a number between 1 and 6.");
                    }
                } catch (InputMismatchException e) {
                    System.err.println("Error: Invalid input. Please enter a number.");
                    scanner.nextLine(); // Consume the invalid input
                    choice = -1; // Reset choice to prevent infinite loop
                }
                System.out.println(); // Add a newline for better readability between actions
            }
        } catch (Exception e) {
            // Catch any other unexpected exceptions
            System.err.println("An unexpected error occurred: " + e.getMessage());
            // e.printStackTrace(); // Optional: for debugging
        } finally {
            // Ensure scanner is closed when the system exits (either normally or via exception)
            if (scanner != null) {
                scanner.close();
            }
        }
    }

    /**
     * Displays the main menu options to the user.
     */
    private void printMenu() {
        System.out.println("--- Event Registration Menu ---");
        System.out.println("1. Add Person");
        System.out.println("2. Process Waitlist");
        System.out.println("3. View Registered Attendees");
        System.out.println("4. View Waiting List");
        System.out.println("5. Check Person Status");
        System.out.println("6. Exit");
        System.out.println("-----------------------------");
    }

    /**
     * Adds a new person to the system. Registers them if space is available,
     * otherwise adds them to the waiting list. Handles duplicates and input validation.
     */
    private void addPerson() {
        System.out.print("Enter person's name: ");
        String name = scanner.nextLine().trim();

        if (name.isEmpty()) {
            System.err.println("Error: Name cannot be empty.");
            return;
        }

        Person newPerson = new Person(name);

        // Check if person is already registered or on waiting list
        if (registeredAttendees.contains(newPerson) || waitingList.contains(newPerson)) {
            System.err.println("Error: Person '" + name + "' is already registered or on the waiting list.");
            return;
        }

        if (registeredAttendees.size() < EVENT_CAPACITY) {
            registeredAttendees.add(newPerson);
            System.out.println("Person '" + name + "' registered successfully.");
        } else {
            waitingList.add(newPerson);
            System.out.println("Event full. Person '" + name + "' added to the waiting list.");
        }
    }

    /**
     * Processes the next person from the waiting list, moving them to the
     * registered attendees list if there is capacity.
     */
    private void processWaitlist() {
        if (waitingList.isEmpty()) {
            System.out.println("Waitlist is empty. No one to process.");
            return;
        }

        if (registeredAttendees.size() >= EVENT_CAPACITY) {
            System.out.println("Event is still full. Cannot process waitlist until a spot opens.");
            return;
        }

        Person nextPerson = waitingList.poll(); // Get and remove the head of the queue
        if (nextPerson != null) { // Should not be null if waitlist wasn't empty, but good practice
             // Re-check if they somehow got registered already (unlikely in this simple model, but robust)
             if (registeredAttendees.contains(nextPerson)) {
                 System.err.println("Warning: Person '" + nextPerson.getName() + "' from waitlist was already registered. Skipping.");
             } else {
                registeredAttendees.add(nextPerson);
                System.out.println("Processed waitlist. Person '" + nextPerson.getName() + "' is now registered.");
             }
        }
    }

    /**
     * Displays all currently registered attendees.
     */
    private void viewRegistered() {
        System.out.println("Registered Attendees:");
        if (registeredAttendees.isEmpty()) {
            System.out.println("(No registered attendees yet.)");
        } else {
            for (int i = 0; i < registeredAttendees.size(); i++) {
                System.out.println("- " + registeredAttendees.get(i).getName());
            }
        }
    }

    /**
     * Displays all people currently on the waiting list.
     */
    private void viewWaitlist() {
        System.out.println("Waiting List:");
        if (waitingList.isEmpty()) {
            System.out.println("(Waiting list is empty.)");
        } else {
            // Iterating over a Queue doesn't remove elements
            int i = 1;
            for (Person p : waitingList) {
                System.out.println(i + ". " + p.getName());
                i++;
            }
        }
    }

    /**
     * Checks and reports the status of a person (registered, on waitlist, or not found).
     */
    private void checkPersonStatus() {
        System.out.print("Enter person's name to check: ");
        String name = scanner.nextLine().trim();

        if (name.isEmpty()) {
            System.err.println("Error: Name cannot be empty.");
            return;
        }

        Person searchPerson = new Person(name); // Create a temporary Person object for searching

        if (registeredAttendees.contains(searchPerson)) {
            System.out.println("Person '" + name + "' is registered.");
        } else if (waitingList.contains(searchPerson)) {
            System.out.println("Person '" + name + "' is on the waiting list.");
        } else {
            System.out.println("Person '" + name + "' not found in the system.");
        }
    }

    /**
     * Main method to start the Event Registration System.
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        EventRegistrationSystem system = new EventRegistrationSystem();
        system.runSystem();
    }
}
