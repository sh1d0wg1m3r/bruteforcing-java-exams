/*
 * Exam Question #1090
 * Generated on: 2025-05-12 17:23:19
 * Generated by: Account 5
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Network Packet Processor Simulation
 * 
 * **Scenario:**
 * 
 * You are tasked with building a simplified simulation of a network device that processes incoming data packets. Packets arrive and are placed in a queue to await processing. The device can process the next packet, view the queue of waiting packets, view the list of packets that have been successfully processed, or shut down.
 * 
 * **Task:**
 * 
 * Implement a Java program that simulates this packet processing device. Your program should be interactive, allowing a user to control the device's actions via a command-line interface.
 * 
 * **Requirements:**
 * 
 * 1.  **`Packet` Class:** Create a simple class named `Packet` to represent a data packet. It should have:
 *     *   A private integer field `id` to uniquely identify the packet.
 *     *   A private string field `status` (e.g., "Waiting", "Processed").
 *     *   A constructor `Packet(int id)` that initializes the `id` and sets the initial status to "Waiting".
 *     *   A public getter method `getId()`.
 *     *   A public setter method `setStatus(String status)`.
 *     *   A public getter method `getStatus()`.
 *     *   Override the `toString()` method to provide a user-friendly representation (e.g., "Packet [ID: X, Status: Y]").
 * 
 * 2.  **`PacketProcessor` Class:** Create a class named `PacketProcessor` to manage the packet processing logic. It should have:
 *     *   A private field `incomingQueue` of type `java.util.Queue<Packet>` to hold packets awaiting processing. Use a `LinkedList` implementation for the `Queue`.
 *     *   A private field `processedPackets` of type `java.util.List<Packet>` to store packets after they are processed. Use an `ArrayList` implementation for the `List`.
 *     *   A private integer field `nextPacketId` initialized to 1, used to assign unique IDs to new packets.
 *     *   A constructor to initialize the `incomingQueue` and `processedPackets`.
 *     *   A public method `addIncomingPacket()` that creates a new `Packet` with the next available ID, adds it to the `incomingQueue`, and increments `nextPacketId`.
 *     *   A public method `processNextPacket()` that:
 *         *   Attempts to retrieve and remove the head of the `incomingQueue`.
 *         *   If the queue is empty, it should indicate this failure (e.g., return a boolean or throw a specific exception, though for this exam, printing an error and returning is acceptable).
 *         *   If a packet is retrieved, it should update its status to "Processed" and add it to the `processedPackets` list.
 *         *   It should return `true` if a packet was processed, `false` otherwise.
 *     *   A public method `getIncomingQueue()` that returns the `incomingQueue` (or a view of it, returning the queue itself is fine for this exam).
 *     *   A public method `getProcessedPackets()` that returns the `processedPackets` list (or a view of it).
 * 
 * 3.  **Main Program (`Main` class):** Create a class with a `main` method to run the simulation.
 *     *   Create a `Scanner` object to read user input from `System.in`.
 *     *   Create a `PacketProcessor` object.
 *     *   Implement a menu-driven loop that presents the following options to the user:
 *         1.  Simulate Incoming Packet
 *         2.  Process Next Packet
 *         3.  View Incoming Queue
 *         4.  View Processed Packets
 *         5.  Exit
 *     *   Use a `switch` statement to handle the user's choice.
 *     *   For option 1, call `packetProcessor.addIncomingPacket()`.
 *     *   For option 2, call `packetProcessor.processNextPacket()`. Print a success message if true is returned, or an error message if false.
 *     *   For option 3, retrieve the incoming queue using `packetProcessor.getIncomingQueue()` and print its contents. Indicate if the queue is empty.
 *     *   For option 4, retrieve the processed packets list using `packetProcessor.getProcessedPackets()` and print its contents. Indicate if the list is empty.
 *     *   For invalid menu choices, print an error message.
 *     *   Handle potential exceptions during the execution of the program using a `try-catch` block that wraps the main user interaction loop. This demonstrates class-wide exception handling. Catch `Exception` or a more specific relevant exception if identified.
 *     *   Use `System.out` for menu display, prompts, and successful output.
 *     *   Use `System.err` for error messages (invalid input, processing failure due to empty queue, general exceptions).
 *     *   Ensure the program exits gracefully when the user chooses option 5.
 * 
 * **General Requirements & Best Practices:**
 * 
 * *   Use meaningful variable and method names.
 * *   Apply proper encapsulation (private fields, public methods where necessary).
 * *   Include comments to explain complex parts of the code.
 * *   Add basic input validation (e.g., checking if the input is an integer and within the valid range).
 * *   Ensure all required Java components (`Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.err`, `System.out`, `try-catch`) are used correctly and demonstrably.
 * 
 * **Expected Output:**
 * 
 * The program should display a menu, accept integer input, and perform actions based on the input, printing status updates, queue contents, or error messages as appropriate. Example interaction:
 * 
 * ```
 * Packet Processor Menu:
 * 1. Simulate Incoming Packet
 * 2. Process Next Packet
 * 3. View Incoming Queue
 * 4. View Processed Packets
 * 5. Exit
 * Enter choice: 1
 * Simulating new incoming packet: Packet [ID: 1, Status: Waiting]
 * 
 * Packet Processor Menu:
 * 1. Simulate Incoming Packet
 * 2. Process Next Packet
 * 3. View Incoming Queue
 * 4. View Processed Packets
 * 5. Exit
 * Enter choice: 1
 * Simulating new incoming packet: Packet [ID: 2, Status: Waiting]
 * 
 * Packet Processor Menu:
 * 1. Simulate Incoming Packet
 * ...
 * Enter choice: 3
 * Incoming Queue (2 packets):
 * Packet [ID: 1, Status: Waiting]
 * Packet [ID: 2, Status: Waiting]
 * 
 * Packet Processor Menu:
 * ...
 * Enter choice: 2
 * Processing packet Packet [ID: 1, Status: Waiting]... Processed successfully.
 * 
 * Packet Processor Menu:
 * ...
 * Enter choice: 3
 * Incoming Queue (1 packet):
 * Packet [ID: 2, Status: Waiting]
 * 
 * Packet Processor Menu:
 * ...
 * Enter choice: 4
 * Processed Packets (1 packet):
 * Packet [ID: 1, Status: Processed]
 * 
 * Packet Processor Menu:
 * ...
 * Enter choice: 2
 * Processing packet Packet [ID: 2, Status: Waiting]... Processed successfully.
 * 
 * Packet Processor Menu:
 * ...
 * Enter choice: 2
 * Error: No packets in the incoming queue to process.
 * 
 * Packet Processor Menu:
 * ...
 * Enter choice: 6
 * Error: Invalid choice. Please enter a number between 1 and 5.
 * 
 * Packet Processor Menu:
 * ...
 * Enter choice: abc
 * Error: Invalid input. Please enter an integer.
 * 
 * Packet Processor Menu:
 * ...
 * Enter choice: 5
 * Shutting down.
 * ```
 * 
 * **Evaluation Criteria:**
 * 
 * *   Correct usage of all specified Java components (`Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.err`, `System.out`, `try-catch`).
 * *   Proper implementation of the `Packet` and `PacketProcessor` classes with encapsulation.
 * *   Correct simulation logic (adding, processing, viewing packets).
 * *   Effective use of `switch` for menu navigation.
 * *   Appropriate use of `System.out` and `System.err`.
 * *   Implementation of basic input validation and error handling (empty queue, invalid input).
 * *   Correct placement and usage of the `try-catch` block for general error handling.
 * *   Code clarity, comments, and adherence to best practices.
 *
 * EXPLANATION:
 * This solution implements a simple network packet processor simulation using the required Java components and following best practices.
 * 
 * 1.  **`Packet` Class:**
 *     *   Represents a packet with an `id` and `status`.
 *     *   Uses private fields and public getters/setters, demonstrating encapsulation.
 *     *   The `toString()` method provides a clear representation for printing.
 * 
 * 2.  **`PacketProcessor` Class:**
 *     *   Manages the core logic.
 *     *   `incomingQueue`: A `Queue<Packet>` (implemented using `LinkedList`) stores packets waiting to be processed. `Queue` is suitable because packets are processed in the order they arrive (FIFO - First-In, First-Out).
 *     *   `processedPackets`: A `List<Packet>` (implemented using `ArrayList`) stores packets after they have been processed. `List` is suitable for maintaining an ordered collection of processed items.
 *     *   `nextPacketId`: A simple counter to ensure unique IDs for new packets.
 *     *   `addIncomingPacket()`: Creates a new packet and adds it to the `incomingQueue` using `offer()`.
 *     *   `processNextPacket()`: Attempts to remove the next packet from the `incomingQueue` using `poll()`. `poll()` is used because it returns `null` if the queue is empty, which is handled gracefully, avoiding an exception. If a packet is found, its status is updated, and it's added to the `processedPackets` list. It returns a boolean indicating success or failure.
 *     *   `getIncomingQueue()` and `getProcessedPackets()`: Public methods to allow the `Main` class to access the collections for viewing. Returning the collections directly is acceptable for this exam's complexity.
 * 
 * 3.  **`Main` Class:**
 *     *   Contains the `main` method, the entry point of the program.
 *     *   `Scanner`: Used to read integer input from the user via `System.in`.
 *     *   `PacketProcessor`: An instance of the processor is created.
 *     *   **`try-catch` Block:** A large `try-catch(Exception e)` block wraps the main `while` loop. This demonstrates class-wide exception handling, catching any unexpected exceptions that might occur during the program's execution (though specific handling is also done within the loop). The `finally` block ensures the `Scanner` is closed.
 *     *   **User Interaction Loop:** The `while(running)` loop keeps the program active until the user chooses to exit.
 *     *   **Input Validation:** Inside the loop, `scanner.hasNextInt()` checks if the next input is an integer. If not, an error is printed to `System.err`, the invalid input is consumed using `scanner.next()`, and the loop continues. This prevents `InputMismatchException` when `scanner.nextInt()` is called on non-integer input.
 *     *   **`switch` Statement:** The user's valid integer choice is handled by a `switch` statement, directing the program flow to the appropriate action (add packet, process, view queue, view list, exit).
 *     *   **`System.out` vs. `System.err`:**
 *         *   `System.out.println()` is used for the menu, prompts, successful actions (packet added, processed successfully), and printing the contents of the queue/list.
 *         *   `System.err.println()` is used specifically for error conditions: invalid user input (non-integer or out of range) and attempting to process from an empty queue.
 *     *   **Viewing Collections:** When viewing the queue or list, the code checks if they are empty before attempting to iterate and print their contents. Iterating through the `Queue` is done using an enhanced for loop (`for (Packet p : queue)`), which does not remove elements.
 * 
 * This solution effectively demonstrates the use of all required components (`Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.err`, `System.out`, `try-catch`) within a practical, interactive program structure, incorporating encapsulation, input validation, and error handling as requested.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.InputMismatchException; // Specific exception for non-integer input

/**
 * Represents a data packet in the simulation.
 */
class Packet {
    private int id;
    private String status;

    /**
     * Constructs a new Packet with a given ID.
     *
     * @param id The unique identifier for the packet.
     */
    public Packet(int id) {
        this.id = id;
        this.status = "Waiting"; // Initial status
    }

    /**
     * Gets the packet's ID.
     *
     * @return The packet ID.
     */
    public int getId() {
        return id;
    }

    /**
     * Sets the packet's status.
     *
     * @param status The new status for the packet.
     */
    public void setStatus(String status) {
        this.status = status;
    }

    /**
     * Gets the packet's status.
     *
     * @return The packet status.
     */
    public String getStatus() {
        return status;
    }

    /**
     * Provides a string representation of the packet.
     *
     * @return A formatted string representing the packet.
     */
    @Override
    public String toString() {
        return "Packet [ID: " + id + ", Status: " + status + "]";
    }
}

/**
 * Manages the processing of packets, including incoming queue and processed list.
 */
class PacketProcessor {
    // Queue to hold packets waiting to be processed
    private Queue<Packet> incomingQueue;
    // List to hold packets that have been processed
    private List<Packet> processedPackets;
    // Counter for assigning unique packet IDs
    private int nextPacketId;

    /**
     * Constructs a new PacketProcessor, initializing the queue and list.
     */
    public PacketProcessor() {
        // Use LinkedList as an implementation of Queue
        this.incomingQueue = new LinkedList<>();
        // Use ArrayList as an implementation of List
        this.processedPackets = new ArrayList<>();
        this.nextPacketId = 1; // Start ID from 1
    }

    /**
     * Creates a new packet and adds it to the incoming queue.
     */
    public void addIncomingPacket() {
        Packet newPacket = new Packet(nextPacketId++);
        incomingQueue.offer(newPacket); // offer() is preferred over add() for capacity-constrained queues, though LinkedList is not capacity-constrained. It's good practice.
        System.out.println("Simulating new incoming packet: " + newPacket);
    }

    /**
     * Processes the next packet from the incoming queue.
     *
     * @return true if a packet was processed successfully, false if the queue was empty.
     */
    public boolean processNextPacket() {
        // poll() retrieves and removes the head of the queue, returns null if empty
        Packet packetToProcess = incomingQueue.poll();

        if (packetToProcess == null) {
            // Use System.err for error conditions
            System.err.println("Error: No packets in the incoming queue to process.");
            return false;
        } else {
            System.out.println("Processing packet " + packetToProcess + "...");
            packetToProcess.setStatus("Processed"); // Update status
            processedPackets.add(packetToProcess); // Add to processed list
            System.out.println("Processed successfully.");
            return true;
        }
    }

    /**
     * Gets the current incoming queue.
     *
     * @return The Queue of incoming packets.
     */
    public Queue<Packet> getIncomingQueue() {
        return incomingQueue;
    }

    /**
     * Gets the list of processed packets.
     *
     * @return The List of processed packets.
     */
    public List<Packet> getProcessedPackets() {
        return processedPackets;
    }
}

/**
 * Main class to run the Packet Processor simulation.
 */
public class Main {

    /**
     * Displays the main menu options.
     */
    private static void displayMenu() {
        System.out.println("\nPacket Processor Menu:");
        System.out.println("1. Simulate Incoming Packet");
        System.out.println("2. Process Next Packet");
        System.out.println("3. View Incoming Queue");
        System.out.println("4. View Processed Packets");
        System.out.println("5. Exit");
        System.out.print("Enter choice: ");
    }

    /**
     * Main method to start the simulation.
     *
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        // Use Scanner for user input
        Scanner scanner = new Scanner(System.in);
        PacketProcessor processor = new PacketProcessor();
        boolean running = true;

        // Class-wide exception handling using try-catch around the main loop
        try {
            while (running) {
                displayMenu();
                int choice = -1; // Default invalid choice

                // Input validation for integer
                if (scanner.hasNextInt()) {
                    choice = scanner.nextInt();
                } else {
                    // Use System.err for invalid input error
                    System.err.println("Error: Invalid input. Please enter an integer.");
                    scanner.next(); // Consume the invalid input to prevent infinite loop
                    continue; // Skip to next iteration
                }

                // Use switch statement for flow control based on user choice
                switch (choice) {
                    case 1:
                        processor.addIncomingPacket();
                        break;
                    case 2:
                        processor.processNextPacket(); // Method handles its own error message
                        break;
                    case 3:
                        Queue<Packet> queue = processor.getIncomingQueue();
                        System.out.println("\nIncoming Queue (" + queue.size() + " packets):");
                        if (queue.isEmpty()) {
                            System.out.println("Queue is empty.");
                        } else {
                            // Iterate through the queue without removing elements
                            for (Packet p : queue) {
                                System.out.println(p);
                            }
                        }
                        break;
                    case 4:
                        List<Packet> processed = processor.getProcessedPackets();
                        System.out.println("\nProcessed Packets (" + processed.size() + " packets):");
                        if (processed.isEmpty()) {
                            System.out.println("No packets have been processed yet.");
                        } else {
                            // Iterate through the list
                            for (Packet p : processed) {
                                System.out.println(p);
                            }
                        }
                        break;
                    case 5:
                        System.out.println("Shutting down.");
                        running = false; // Exit the loop
                        break;
                    default:
                        // Use System.err for invalid choice error
                        System.err.println("Error: Invalid choice. Please enter a number between 1 and 5.");
                        break;
                }
            }
        } catch (Exception e) {
            // Catch any unexpected exceptions during the main loop
            System.err.println("\nAn unexpected error occurred: " + e.getMessage());
            // e.printStackTrace(); // Uncomment for detailed debugging
        } finally {
            // Ensure the scanner is closed
            scanner.close();
            System.out.println("Scanner closed.");
        }
    }
}
