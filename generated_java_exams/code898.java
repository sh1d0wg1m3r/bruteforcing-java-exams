/*
 * Exam Question #898
 * Generated on: 2025-05-12 16:56:37
 * Generated by: Account 2
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Advanced Print Queue Management System
 * 
 * **Scenario:**
 * 
 * You are tasked with developing a simplified Print Queue Management System for a busy office. The system needs to handle print job requests, manage a waiting queue, simulate processing, and keep a history of all jobs.
 * 
 * **Requirements:**
 * 
 * 1.  **`PrintJob` Class:**
 *     *   Represent a single print request.
 *     *   Private fields: `jobId` (int, unique identifier), `fileName` (String), `numberOfPages` (int), `status` (String - e.g., "Pending", "Processing", "Completed", "Failed").
 *     *   Constructor to initialize `fileName` and `numberOfPages`. Assign a unique `jobId` automatically (e.g., using a static counter). Initial status should be "Pending".
 *     *   Public getter methods for all fields.
 *     *   A method `updateStatus(String newStatus)` to change the job's status.
 *     *   A `toString()` method to provide a readable representation of the job.
 * 
 * 2.  **`PrintQueueManager` Class:**
 *     *   Manage the collection of print jobs.
 *     *   Private fields:
 *         *   A `Queue<PrintJob>` to hold jobs waiting to be processed.
 *         *   A `List<PrintJob>` to store a history of all jobs (including those in the queue, completed, or failed).
 *     *   Public methods:
 *         *   `addJob(String fileName, int numberOfPages)`: Creates a new `PrintJob`, adds it to both the waiting queue and the history list. Returns the assigned `jobId`. Should validate input (non-empty file name, positive number of pages).
 *         *   `processNextJob()`: Takes the next job from the waiting queue (if available). Simulates processing (e.g., print a message). Updates the job's status in the history list (e.g., to "Completed" or potentially "Failed" to demonstrate error handling). If the queue is empty, report an error.
 *         *   `viewQueue()`: Prints the details of all jobs currently in the waiting queue. If the queue is empty, report that.
 *         *   `viewJobHistory()`: Prints the details of all jobs ever processed or waiting in the system (from the history list). If the history is empty, report that.
 *         *   `findJobById(int jobId)`: Finds and prints the details of a specific job from the history list using its ID. If not found, report an error.
 * 
 * 3.  **Main Application (`PrintQueueApp` class):**
 *     *   Contain the `main` method to run the application.
 *     *   Create a `PrintQueueManager` instance.
 *     *   Implement a text-based menu interface using `Scanner` for user interaction.
 *     *   The menu should offer the following options using a `switch` statement:
 *         *   1. Add New Print Job
 *         *   2. Process Next Job
 *         *   3. View Current Queue
 *         *   4. View Job History
 *         *   5. Find Job by ID
 *         *   6. Exit
 *     *   Use a loop to keep the menu running until the user chooses to exit.
 *     *   Implement input validation for user choices and job details (file name, pages, job ID).
 *     *   Use `System.out` for normal output (menu, job details, success messages).
 *     *   Use `System.err` for error messages (invalid input, queue empty, job not found, processing failure).
 *     *   Implement class-wide exception handling using `try-catch` blocks to gracefully handle potential runtime errors (e.g., incorrect input format).
 * 
 * **Required Java Components to Use:**
 * 
 * *   `java.util.Queue`
 * *   `java.util.ArrayList`
 * *   `java.util.List`
 * *   `java.util.Scanner`
 * *   `switch` statement
 * *   `System.err`
 * *   `System.out`
 * *   Class-wide `try-catch` blocks
 * 
 * **Best Practices:**
 * 
 * *   Proper encapsulation (private fields, public methods).
 * *   Meaningful variable and method names.
 * *   Appropriate comments and documentation (e.g., Javadoc).
 * *   Input validation.
 * *   Proper error handling (using `System.err`, checking for empty queue/list, invalid IDs).
 * *   Clean code structure.
 * 
 * **Expected Output:**
 * 
 * The application should present a menu, accept user input, and display information or error messages based on the chosen action. Examples:
 * 
 * ```
 * --- Print Queue Menu ---
 * 1. Add New Print Job
 * 2. Process Next Job
 * 3. View Current Queue
 * 4. View Job History
 * 5. Find Job by ID
 * 6. Exit
 * Enter your choice: 1
 * Enter file name: document.pdf
 * Enter number of pages: 15
 * Job added with ID: 1
 * 
 * --- Print Queue Menu ---
 * ...
 * Enter your choice: 3
 * Current Queue:
 * Job ID: 1, File: document.pdf, Pages: 15, Status: Pending
 * 
 * --- Print Queue Menu ---
 * ...
 * Enter your choice: 2
 * Processing job ID: 1 (document.pdf, 15 pages)...
 * Job ID 1 completed successfully.
 * 
 * --- Print Queue Menu ---
 * ...
 * Enter your choice: 3
 * Current Queue is empty.
 * 
 * --- Print Queue Menu ---
 * ...
 * Enter your choice: 4
 * Job History:
 * Job ID: 1, File: document.pdf, Pages: 15, Status: Completed
 * 
 * --- Print Queue Menu ---
 * ...
 * Enter your choice: 5
 * Enter Job ID to find: 1
 * Job Found: Job ID: 1, File: document.pdf, Pages: 15, Status: Completed
 * 
 * --- Print Queue Menu ---
 * ...
 * Enter your choice: 5
 * Enter Job ID to find: 99
 * Error: Job with ID 99 not found.
 * 
 * --- Print Queue Menu ---
 * ...
 * Enter your choice: 2
 * Error: Print queue is empty. No jobs to process.
 * 
 * --- Print Queue Menu ---
 * ...
 * Enter your choice: 1
 * Enter file name: report.docx
 * Enter number of pages: -5
 * Error: Number of pages must be positive. Job not added.
 * 
 * --- Print Queue Menu ---
 * ...
 * Enter your choice: invalid
 * Error: Invalid input. Please enter a number between 1 and 6.
 * 
 * --- Print Queue Menu ---
 * ...
 * Enter your choice: 6
 * Exiting Print Queue System.
 * ```
 * 
 * Implement the Java code for this system.
 *
 * EXPLANATION:
 * This solution implements a Print Queue Management System demonstrating the required Java concepts and best practices.
 * 
 * 1.  **`PrintJob` Class:**
 *     *   Represents a single print request with `jobId`, `fileName`, `numberOfPages`, and `status`.
 *     *   Uses a `static int nextJobId` to ensure each job gets a unique, auto-incrementing ID upon creation.
 *     *   Fields are `private` with `public` getters, enforcing encapsulation.
 *     *   Includes an `updateStatus` method and overrides `toString` for easy printing.
 * 
 * 2.  **`PrintQueueManager` Class:**
 *     *   Manages the collection of jobs.
 *     *   Uses a `Queue<PrintJob>` named `waitingQueue`. A `LinkedList` is used as the concrete implementation, as it efficiently supports queue operations (`offer` for adding, `poll` for removing).
 *     *   Uses a `List<PrintJob>` named `jobHistory`. An `ArrayList` is used as the concrete implementation to store all jobs ever added, allowing easy iteration and searching by ID.
 *     *   `addJob`: Creates a new `PrintJob`, adds it to *both* the `waitingQueue` and the `jobHistory`. Includes basic input validation for `fileName` and `numberOfPages`, returning -1 on failure.
 *     *   `processNextJob`: Uses `waitingQueue.poll()` to retrieve and remove the head element (the next job to be processed). It checks if the queue is empty before polling. It simulates processing and updates the job's status in the `jobHistory`. Because the `PrintJob` objects in the queue and history are the *same references*, updating the status on the object retrieved from the queue automatically updates it in the history list. Includes a simulated random failure.
 *     *   `viewQueue`: Iterates through the `waitingQueue` (without removing elements) to print current jobs.
 *     *   `viewJobHistory`: Iterates through the `jobHistory` `List` to print all jobs, regardless of status.
 *     *   `findJobById`: Iterates through the `jobHistory` `List` to find a job by its unique ID.
 * 
 * 3.  **`PrintQueueApp` Class (`main` method):**
 *     *   Acts as the application entry point and user interface.
 *     *   Uses `Scanner` to read user input from the console.
 *     *   Presents a menu using `System.out`.
 *     *   Uses a `while` loop to keep the application running until the user chooses to exit.
 *     *   A `switch` statement is used to handle the different menu options, directing control to the appropriate methods in `PrintQueueManager`.
 *     *   Input validation is performed:
 *         *   Checking for `InputMismatchException` when reading integers (choice, pages, job ID) using nested `try-catch` blocks within the `main` `try-catch`. This is crucial for robust `Scanner` usage.
 *         *   Calling `scanner.nextLine()` after `nextInt()` to consume the leftover newline character.
 *         *   Delegating validation of file name and page count to the `addJob` method.
 *     *   `System.err` is used specifically for printing error messages (invalid input, empty queue, job not found, processing failure).
 *     *   `System.out` is used for all other standard output (menu, prompts, job details, success messages).
 *     *   A large `try-catch(Exception e)` block wraps the main application loop (`while(running)`). This serves as the "class-wide exception handling", catching any unhandled exceptions that might occur during execution and preventing the program from crashing abruptly. A `finally` block ensures the `Scanner` is closed.
 * 
 * **Key Concepts Demonstrated:**
 * 
 * *   **Data Structures:** Practical use of `Queue` for managing a waiting list (FIFO - First-In, First-Out) and `List` (`ArrayList`) for maintaining a collection/history of objects.
 * *   **Object-Oriented Programming:** Encapsulation within `PrintJob` and `PrintQueueManager`, creating objects to model real-world entities.
 * *   **Input/Output:** Using `Scanner` for user input, `System.out` for normal output, and `System.err` for error reporting.
 * *   **Control Flow:** Using `switch` for clear menu selection and a `while` loop for continuous execution.
 * *   **Exception Handling:** Using `try-catch` blocks at different levels – specific catches for expected input errors (`InputMismatchException`) and a broader catch for unexpected issues, fulfilling the "class-wide" requirement.
 * *   **Input Validation:** Checking user inputs for correctness before processing.
 * *   **Best Practices:** Adherence to naming conventions, commenting, and structured code.
 * 
 * This solution effectively integrates the required Java components into a cohesive, practical application while adhering to good programming principles.
 */

import java.util.Queue;
import java.util.LinkedList;
import java.util.List;
import java.util.ArrayList;
import java.util.Scanner;
import java.util.InputMismatchException;
import java.util.Iterator; // To iterate and update in history list

/**
 * Represents a single print job request.
 */
class PrintJob {
    private static int nextJobId = 1; // Static counter for unique IDs

    private int jobId;
    private String fileName;
    private int numberOfPages;
    private String status; // e.g., "Pending", "Processing", "Completed", "Failed"

    /**
     * Constructs a new PrintJob.
     *
     * @param fileName The name of the file to print.
     * @param numberOfPages The number of pages in the file.
     */
    public PrintJob(String fileName, int numberOfPages) {
        this.jobId = nextJobId++; // Assign unique ID and increment counter
        this.fileName = fileName;
        this.numberOfPages = numberOfPages;
        this.status = "Pending"; // Initial status
    }

    // --- Getters ---
    public int getJobId() {
        return jobId;
    }

    public String getFileName() {
        return fileName;
    }

    public int getNumberOfPages() {
        return numberOfPages;
    }

    public String getStatus() {
        return status;
    }

    /**
     * Updates the status of the print job.
     *
     * @param newStatus The new status to set.
     */
    public void updateStatus(String newStatus) {
        this.status = newStatus;
    }

    /**
     * Provides a string representation of the PrintJob.
     *
     * @return A formatted string describing the job.
     */
    @Override
    public String toString() {
        return String.format("Job ID: %d, File: %s, Pages: %d, Status: %s",
                             jobId, fileName, numberOfPages, status);
    }
}

/**
 * Manages a queue of print jobs and maintains a history.
 */
class PrintQueueManager {
    private Queue<PrintJob> waitingQueue;
    private List<PrintJob> jobHistory; // Stores all jobs ever created

    /**
     * Constructs a new PrintQueueManager.
     */
    public PrintQueueManager() {
        this.waitingQueue = new LinkedList<>(); // LinkedList implements Queue
        this.jobHistory = new ArrayList<>();    // ArrayList implements List
    }

    /**
     * Adds a new print job to the queue and history.
     *
     * @param fileName The name of the file.
     * @param numberOfPages The number of pages.
     * @return The ID of the added job, or -1 if validation fails.
     */
    public int addJob(String fileName, int numberOfPages) {
        if (fileName == null || fileName.trim().isEmpty()) {
            System.err.println("Error: File name cannot be empty.");
            return -1; // Indicate failure
        }
        if (numberOfPages <= 0) {
            System.err.println("Error: Number of pages must be positive.");
            return -1; // Indicate failure
        }

        PrintJob newJob = new PrintJob(fileName.trim(), numberOfPages);
        waitingQueue.offer(newJob); // Add to the end of the queue
        jobHistory.add(newJob);     // Add to the history list
        return newJob.getJobId();
    }

    /**
     * Processes the next job in the waiting queue.
     * Removes the job from the queue and updates its status in history.
     */
    public void processNextJob() {
        PrintJob jobToProcess = waitingQueue.poll(); // Get and remove head of queue

        if (jobToProcess == null) {
            System.err.println("Error: Print queue is empty. No jobs to process.");
            return;
        }

        System.out.println("Processing job ID: " + jobToProcess.getJobId() +
                           " (" + jobToProcess.getFileName() + ", " +
                           jobToProcess.getNumberOfPages() + " pages)...");

        // Simulate processing - In a real system, this would do actual work.
        // For this example, we'll just update the status.
        // Let's add a small chance of failure for demonstration.
        boolean success = Math.random() > 0.1; // 90% chance of success

        String newStatus = success ? "Completed" : "Failed";
        jobToProcess.updateStatus(newStatus); // Update status on the job object

        // Since the same PrintJob object reference is in both the queue (before polling)
        // and the history list, updating the status on the polled object
        // automatically updates it in the history list as well.

        if (success) {
            System.out.println("Job ID " + jobToProcess.getJobId() + " completed successfully.");
        } else {
            System.err.println("Error: Job ID " + jobToProcess.getJobId() + " failed during processing.");
        }
    }

    /**
     * Prints the details of all jobs currently in the waiting queue.
     */
    public void viewQueue() {
        if (waitingQueue.isEmpty()) {
            System.out.println("Current Queue is empty.");
            return;
        }

        System.out.println("Current Queue:");
        // Iterate through the queue without removing elements
        for (PrintJob job : waitingQueue) {
            System.out.println(job);
        }
    }

    /**
     * Prints the details of all jobs in the history list.
     */
    public void viewJobHistory() {
        if (jobHistory.isEmpty()) {
            System.out.println("Job History is empty.");
            return;
        }

        System.out.println("Job History:");
        for (PrintJob job : jobHistory) {
            System.out.println(job);
        }
    }

    /**
     * Finds and prints the details of a specific job by its ID from the history.
     *
     * @param jobId The ID of the job to find.
     */
    public void findJobById(int jobId) {
        boolean found = false;
        // Search the history list as it contains all jobs
        for (PrintJob job : jobHistory) {
            if (job.getJobId() == jobId) {
                System.out.println("Job Found: " + job);
                found = true;
                break; // Found the job, no need to continue searching
            }
        }

        if (!found) {
            System.err.println("Error: Job with ID " + jobId + " not found.");
        }
    }
}

/**
 * Main application class for the Print Queue Management System.
 */
public class PrintQueueApp {

    /**
     * Displays the main menu options.
     */
    private static void displayMenu() {
        System.out.println("\n--- Print Queue Menu ---");
        System.out.println("1. Add New Print Job");
        System.out.println("2. Process Next Job");
        System.out.println("3. View Current Queue");
        System.out.println("4. View Job History");
        System.out.println("5. Find Job by ID");
        System.out.println("6. Exit");
        System.out.print("Enter your choice: ");
    }

    /**
     * Main method to run the Print Queue Application.
     *
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        PrintQueueManager queueManager = new PrintQueueManager();
        boolean running = true;

        // Class-wide try-catch block to handle unexpected exceptions
        try {
            while (running) {
                displayMenu();

                int choice = -1;
                try {
                    choice = scanner.nextInt(); // Read user choice
                    scanner.nextLine(); // Consume the newline character
                } catch (InputMismatchException e) {
                    System.err.println("Error: Invalid input. Please enter a number between 1 and 6.");
                    scanner.nextLine(); // Consume the invalid input to prevent infinite loop
                    continue; // Skip to the next iteration of the loop
                }

                // Use switch statement for menu navigation
                switch (choice) {
                    case 1:
                        System.out.print("Enter file name: ");
                        String fileName = scanner.nextLine();
                        System.out.print("Enter number of pages: ");
                        int numberOfPages = -1;
                        try {
                            numberOfPages = scanner.nextInt();
                            scanner.nextLine(); // Consume newline
                        } catch (InputMismatchException e) {
                            System.err.println("Error: Invalid input for number of pages. Please enter an integer.");
                            scanner.nextLine(); // Consume invalid input
                            break; // Exit case 1, return to menu
                        }

                        int jobId = queueManager.addJob(fileName, numberOfPages);
                        if (jobId != -1) { // Check if addJob was successful (validation passed)
                            System.out.println("Job added with ID: " + jobId);
                        }
                        break;

                    case 2:
                        queueManager.processNextJob();
                        break;

                    case 3:
                        queueManager.viewQueue();
                        break;

                    case 4:
                        queueManager.viewJobHistory();
                        break;

                    case 5:
                        System.out.print("Enter Job ID to find: ");
                        int findJobId = -1;
                         try {
                            findJobId = scanner.nextInt();
                            scanner.nextLine(); // Consume newline
                        } catch (InputMismatchException e) {
                            System.err.println("Error: Invalid input for Job ID. Please enter an integer.");
                            scanner.nextLine(); // Consume invalid input
                            break; // Exit case 5, return to menu
                        }
                        queueManager.findJobById(findJobId);
                        break;

                    case 6:
                        running = false;
                        System.out.println("Exiting Print Queue System.");
                        break;

                    default:
                        System.err.println("Error: Invalid choice. Please enter a number between 1 and 6.");
                }
            }
        } catch (Exception e) {
            // Catch any unexpected exceptions that weren't handled elsewhere
            System.err.println("An unexpected error occurred: " + e.getMessage());
            e.printStackTrace(); // Print stack trace for debugging
        } finally {
            // Ensure the scanner is closed
            if (scanner != null) {
                scanner.close();
            }
        }
    }
}
