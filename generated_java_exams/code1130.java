/*
 * Exam Question #1130
 * Generated on: 2025-05-12 17:28:56
 * Generated by: Account 5
 * 
 * QUESTION:
 * **Java Programming Exam: Advanced Task Scheduler Simulation**
 * 
 * **Problem Description:**
 * 
 * You are tasked with building a simple simulation of a task scheduling system. The system should allow users to add tasks to a queue, process tasks one by one from the queue, view the current queue of pending tasks, and view a history of completed tasks. The system needs to handle user input, manage task states, and report errors appropriately.
 * 
 * **System Requirements:**
 * 
 * 1.  **Task Representation:** Create a `Task` class to represent individual tasks. Each task should have:
 *     *   A unique integer ID.
 *     *   A String description of the task.
 *     *   A `TaskType` (use an enum: `HIGH_PRIORITY`, `STANDARD`).
 *     *   A `TaskStatus` (use an enum: `PENDING`, `COMPLETED`).
 *     *   Appropriate constructors, getters, and a meaningful `toString()` method.
 * 
 * 2.  **Scheduler Class:** Create a `TaskScheduler` class that manages the tasks. It should contain:
 *     *   A `Queue` to hold tasks that are pending execution.
 *     *   A `List` (specifically, an `ArrayList`) to store tasks that have been completed.
 *     *   A counter for generating unique task IDs.
 *     *   Methods for:
 *         *   Adding a new task to the pending queue.
 *         *   Processing the next task from the queue (moving it to the completed list and updating its status).
 *         *   Viewing the contents of the pending queue.
 *         *   Viewing the contents of the completed tasks list.
 *         *   A main method or a `run()` method to handle user interaction.
 * 
 * 3.  **User Interface:** The `TaskScheduler` should provide a command-line interface using `Scanner`. It should display a menu with the following options:
 *     *   1. Add New Task
 *     *   2. Process Next Task
 *     *   3. View Pending Tasks
 *     *   4. View Completed Tasks
 *     *   5. Exit
 * 
 * 4.  **Flow Control:** Use a `switch` statement to handle the user's menu selection within a loop that continues until the user chooses to exit.
 * 
 * 5.  **Input Handling & Validation:**
 *     *   Use `Scanner` to read user input for menu choices, task descriptions, and task types.
 *     *   Validate user input, especially for menu choices and task types. Inform the user using `System.err` if input is invalid.
 *     *   Handle cases where the user tries to process a task when the pending queue is empty, reporting this condition using `System.err`.
 * 
 * 6.  **Output:**
 *     *   Use `System.out` for displaying the menu, successful operation messages, the contents of the queue, and the contents of the completed list.
 *     *   Use `System.err` for all error messages and warnings (e.g., invalid input, empty queue).
 * 
 * 7.  **Exception Handling:** Implement class-wide exception handling using a `try-catch` block within the main execution loop (`run` method or `main`) to catch potential unexpected errors (e.g., `InputMismatchException` if reading integers, although careful `Scanner` usage can mitigate this, a general catch is required). Report caught exceptions using `System.err`.
 * 
 * 8.  **Best Practices:**
 *     *   Use private fields and public methods for encapsulation.
 *     *   Use meaningful variable and method names.
 *     *   Include appropriate comments and Javadoc where necessary.
 *     *   Ensure clean code structure with separate methods for different functionalities.
 * 
 * **Required Java Components (MUST use ALL):**
 * 
 * *   `java.util.Queue`
 * *   `java.util.ArrayList`
 * *   `java.util.List`
 * *   `java.util.Scanner`
 * *   `switch` statement
 * *   `System.err`
 * *   `System.out`
 * *   `try-catch` block (class-wide)
 * 
 * **Expected Output:**
 * 
 * The system should display a menu, accept user input, perform the requested action, and display relevant output or error messages.
 * 
 * *   Adding a task should prompt for description and type, then confirm addition.
 * *   Processing a task should remove the head of the queue and confirm completion, or report if the queue is empty.
 * *   Viewing queues/lists should print their current contents using the `Task` object's `toString()` method.
 * *   Invalid input should result in an error message on `System.err`.
 * *   Unexpected exceptions should be caught and reported on `System.err`.
 * 
 * **Example Interaction Snippet:**
 * 
 * ```
 * Task Scheduler Menu:
 * 1. Add New Task
 * 2. Process Next Task
 * 3. View Pending Tasks
 * 4. View Completed Tasks
 * 5. Exit
 * Enter your choice: 1
 * Enter task description: Clean room
 * Enter task type (HIGH_PRIORITY, STANDARD): STANDARD
 * Task added: Task{id=1, description='Clean room', type=STANDARD, status=PENDING}
 * 
 * Task Scheduler Menu:
 * ...
 * Enter your choice: 3
 * Pending Tasks:
 * [Task{id=1, description='Clean room', type=STANDARD, status=PENDING}]
 * 
 * Task Scheduler Menu:
 * ...
 * Enter your choice: 2
 * Processing task: Task{id=1, description='Clean room', type=STANDARD, status=PENDING}
 * Task completed: Task{id=1, description='Clean room', type=STANDARD, status=COMPLETED}
 * 
 * Task Scheduler Menu:
 * ...
 * Enter your choice: 3
 * Pending Tasks:
 * []
 * 
 * Task Scheduler Menu:
 * ...
 * Enter your choice: 4
 * Completed Tasks:
 * [Task{id=1, description='Clean room', type=STANDARD, status=COMPLETED}]
 * 
 * Task Scheduler Menu:
 * ...
 * Enter your choice: 99
 * Error: Invalid choice. Please enter a number between 1 and 5.
 * 
 * Task Scheduler Menu:
 * ...
 * Enter your choice: 2
 * Error: No tasks in the pending queue to process.
 * 
 * Task Scheduler Menu:
 * ...
 * Enter your choice: 5
 * Exiting Task Scheduler.
 * ```
 * 
 * Implement the complete Java code for this Task Scheduler simulation.
 *
 * EXPLANATION:
 * This solution implements a simple Task Scheduler simulation demonstrating the required Java concepts.
 * 
 * 1.  **`Task` Class:** Represents a single unit of work with an ID, description, type (`HIGH_PRIORITY` or `STANDARD`), and status (`PENDING` or `COMPLETED`). It uses an enum for `TaskType` and `TaskStatus` for clarity and type safety. The `markAsCompleted()` method encapsulates the state change. The `toString()` method provides a convenient way to display task information.
 * 
 * 2.  **`TaskScheduler` Class:** This is the core class managing the simulation.
 *     *   **`Queue<Task> taskQueue`**: A `LinkedList` is used here as it's a common implementation of the `Queue` interface, providing efficient FIFO operations (`offer` to add, `poll` to remove and retrieve). It stores tasks waiting to be processed.
 *     *   **`List<Task> completedTasks`**: An `ArrayList` is used and declared using the `List` interface. This stores tasks that have been successfully processed.
 *     *   **`nextTaskId`**: A simple counter to assign unique IDs to new tasks.
 *     *   **`scanner`**: An instance of `Scanner` to read input from the console (`System.in`).
 *     *   **`addTask()`**: Creates a new `Task` object, assigns it the `nextTaskId`, and adds it to the `taskQueue` using `offer()`.
 *     *   **`processNextTask()`**: Uses `poll()` to retrieve and remove the head of the `taskQueue`. If `poll()` returns `null` (meaning the queue is empty), an error is printed to `System.err`. Otherwise, the task's status is updated, and it's added to the `completedTasks` list.
 *     *   **`viewPendingTasks()`**: Iterates through the `taskQueue` (using a for-each loop, which doesn't remove elements) and prints each task using `System.out`.
 *     *   **`viewCompletedTasks()`**: Iterates through the `completedTasks` list and prints each task using `System.out`.
 *     *   **`displayMenu()`**: A helper method to print the menu options to `System.out`.
 *     *   **`getUserChoice()`**: Reads an integer from the scanner. It includes a `try-catch` specifically for `InputMismatchException` to handle non-integer input gracefully, printing an error to `System.err` and consuming the invalid token to prevent an infinite loop.
 *     *   **`getTaskTypeInput()`**: Reads the task type string from the user, converts it to uppercase, and attempts to convert it into a `TaskType` enum value using `TaskType.valueOf()`. A `try-catch` handles `IllegalArgumentException` if the input string doesn't match any enum constant, printing an error to `System.err`.
 *     *   **`run()`**: This method contains the main simulation loop.
 *         *   It uses a `boolean running` flag to control the loop.
 *         *   It displays the menu, gets user input using `getUserChoice()`.
 *         *   A `switch` statement handles the user's choice, calling the appropriate `TaskScheduler` methods.
 *         *   A `scanner.nextLine()` call after reading the integer choice is crucial to consume the leftover newline character, preventing issues when subsequently reading a full line for the task description.
 *         *   The `default` case in the `switch` handles invalid menu numbers (including the -1 returned by `getUserChoice` on input errors), printing an error to `System.err`.
 *         *   **Class-wide `try-catch`**: The entire `while` loop within the `run()` method is wrapped in a `try-catch(Exception e)` block. This fulfills the requirement for class-wide exception handling, catching any unexpected `Exception` that might occur during the execution of the scheduler's main logic. It prints the error message and stack trace to `System.err`.
 *         *   **`finally` block**: Ensures the `Scanner` is closed when the `run` method finishes (either by exiting the loop or catching an exception), releasing system resources.
 *     *   **`main()`**: The entry point of the application, which simply creates a `TaskScheduler` instance and calls its `run()` method.
 * 
 * **Demonstrated Concepts:**
 * 
 * *   **Object-Oriented Programming:** Use of classes (`Task`, `TaskScheduler`) and enums (`TaskType`, `TaskStatus`) to model the problem domain.
 * *   **Encapsulation:** Private fields and public methods in both classes.
 * *   **Data Structures:** Effective use of `Queue` (specifically `LinkedList`) for FIFO task processing and `List` (specifically `ArrayList`) for storing completed tasks.
 * *   **Interfaces:** Using the `List` interface type for the `completedTasks` variable demonstrates programming to interfaces.
 * *   **User Input:** Using `Scanner` to interact with the user.
 * *   **Control Flow:** Using a `while` loop for the main application loop and a `switch` statement for menu navigation.
 * *   **Error Handling:**
 *     *   Specific `try-catch` for `InputMismatchException` in `getUserChoice`.
 *     *   Specific `try-catch` for `IllegalArgumentException` in `getTaskTypeInput`.
 *     *   Checking for empty queue before processing.
 *     *   Using `System.err` for all error messages.
 *     *   Using a broad `try-catch(Exception e)` around the main `run` loop for class-wide unexpected error handling, printing to `System.err`.
 * *   **Output:** Using `System.out` for normal program output.
 * *   **Code Structure:** Separating logic into distinct methods (`addTask`, `processNextTask`, `viewQueue`, etc.) for readability and maintainability.
 * *   **Enums:** Using enums for clear, type-safe representation of task types and statuses.
 * 
 * This solution effectively integrates all the required components into a functional simulation, demonstrating a solid understanding of core and intermediate Java programming concepts.
 */

import java.util.ArrayList;
import java.util.LinkedList; // LinkedList is a common implementation of Queue
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.InputMismatchException;

// Enum for Task Type
enum TaskType {
    HIGH_PRIORITY, STANDARD
}

// Enum for Task Status
enum TaskStatus {
    PENDING, COMPLETED
}

// Task class
class Task {
    private int id;
    private String description;
    private TaskType type;
    private TaskStatus status;

    /**
     * Constructs a new Task.
     * @param id The unique ID of the task.
     * @param description A brief description of the task.
     * @param type The priority type of the task.
     */
    public Task(int id, String description, TaskType type) {
        this.id = id;
        this.description = description;
        this.type = type;
        this.status = TaskStatus.PENDING; // Tasks start as PENDING
    }

    // Getters
    public int getId() {
        return id;
    }

    public String getDescription() {
        return description;
    }

    public TaskType getType() {
        return type;
    }

    public TaskStatus getStatus() {
        return status;
    }

    /**
     * Sets the status of the task to COMPLETED.
     */
    public void markAsCompleted() {
        this.status = TaskStatus.COMPLETED;
    }

    @Override
    public String toString() {
        return "Task{" +
               "id=" + id +
               ", description='" + description + '\'' +
               ", type=" + type +
               ", status=" + status +
               '}';
    }
}

// TaskScheduler class
public class TaskScheduler {
    private Queue<Task> taskQueue;
    private List<Task> completedTasks; // Declared as List interface
    private int nextTaskId;
    private Scanner scanner;

    /**
     * Constructs a new TaskScheduler.
     */
    public TaskScheduler() {
        // Use LinkedList as an implementation of Queue
        this.taskQueue = new LinkedList<>();
        // Use ArrayList as an implementation of List
        this.completedTasks = new ArrayList<>();
        this.nextTaskId = 1; // Start task IDs from 1
        this.scanner = new Scanner(System.in);
    }

    /**
     * Adds a new task to the pending queue.
     * @param description The description of the task.
     * @param type The type (priority) of the task.
     */
    public void addTask(String description, TaskType type) {
        Task newTask = new Task(nextTaskId++, description, type);
        taskQueue.offer(newTask); // offer is preferred over add for queues (returns false instead of throwing exception on capacity issues)
        System.out.println("Task added: " + newTask);
    }

    /**
     * Processes the next task from the queue (FIFO).
     * Removes the task, marks it as completed, and adds it to the completed list.
     */
    public void processNextTask() {
        Task taskToProcess = taskQueue.poll(); // poll removes and returns the head, or null if queue is empty
        if (taskToProcess != null) {
            System.out.println("Processing task: " + taskToProcess);
            taskToProcess.markAsCompleted();
            completedTasks.add(taskToProcess);
            System.out.println("Task completed: " + taskToProcess);
        } else {
            System.err.println("Error: No tasks in the pending queue to process.");
        }
    }

    /**
     * Displays the current tasks in the pending queue.
     */
    public void viewPendingTasks() {
        System.out.println("--- Pending Tasks ---");
        if (taskQueue.isEmpty()) {
            System.out.println("No tasks in the pending queue.");
        } else {
            // Iterate through the queue without removing elements
            for (Task task : taskQueue) {
                System.out.println(task);
            }
        }
        System.out.println("---------------------");
    }

    /**
     * Displays the history of completed tasks.
     */
    public void viewCompletedTasks() {
        System.out.println("--- Completed Tasks ---");
        if (completedTasks.isEmpty()) {
            System.out.println("No completed tasks yet.");
        } else {
            for (Task task : completedTasks) {
                System.out.println(task);
            }
        }
        System.out.println("-----------------------");
    }

    /**
     * Displays the main menu to the user.
     */
    private void displayMenu() {
        System.out.println("\nTask Scheduler Menu:");
        System.out.println("1. Add New Task");
        System.out.println("2. Process Next Task");
        System.out.println("3. View Pending Tasks");
        System.out.println("4. View Completed Tasks");
        System.out.println("5. Exit");
        System.out.print("Enter your choice: ");
    }

    /**
     * Reads the user's menu choice, handling potential input errors.
     * @return The user's choice, or -1 if input is invalid.
     */
    private int getUserChoice() {
        int choice = -1;
        try {
            choice = scanner.nextInt();
        } catch (InputMismatchException e) {
            System.err.println("Error: Invalid input. Please enter a number.");
            scanner.next(); // Consume the invalid input to prevent infinite loop
        }
        return choice;
    }

    /**
     * Reads and validates the task type from the user.
     * @return The valid TaskType, or null if input is invalid.
     */
    private TaskType getTaskTypeInput() {
        System.out.print("Enter task type (HIGH_PRIORITY, STANDARD): ");
        String typeInput = scanner.next().trim().toUpperCase();
        try {
            return TaskType.valueOf(typeInput);
        } catch (IllegalArgumentException e) {
            System.err.println("Error: Invalid task type. Please enter HIGH_PRIORITY or STANDARD.");
            return null;
        }
    }

    /**
     * The main loop for the Task Scheduler simulation.
     * Handles user interaction and calls appropriate methods.
     */
    public void run() {
        boolean running = true;

        // Class-wide exception handling for the main simulation loop
        try {
            while (running) {
                displayMenu();
                int choice = getUserChoice();

                // Consume the rest of the line after reading the integer choice
                // This is important if the next input is a String (like task description)
                // to prevent the scanner from reading the newline character left by nextInt().
                scanner.nextLine();

                switch (choice) {
                    case 1:
                        System.out.print("Enter task description: ");
                        String description = scanner.nextLine();
                        TaskType type = getTaskTypeInput();
                        if (type != null) {
                            addTask(description, type);
                        }
                        break;
                    case 2:
                        processNextTask();
                        break;
                    case 3:
                        viewPendingTasks();
                        break;
                    case 4:
                        viewCompletedTasks();
                        break;
                    case 5:
                        System.out.println("Exiting Task Scheduler.");
                        running = false;
                        break;
                    default:
                        // Handles both invalid integers and the -1 from getUserChoice
                        System.err.println("Error: Invalid choice. Please enter a number between 1 and 5.");
                        break;
                }
            }
        } catch (Exception e) {
            // Catch any unexpected exceptions during the run loop
            System.err.println("An unexpected error occurred: " + e.getMessage());
            e.printStackTrace(System.err); // Print stack trace to System.err
        } finally {
            // Ensure the scanner is closed when the application exits
            if (scanner != null) {
                scanner.close();
            }
        }
    }

    /**
     * Main method to start the Task Scheduler.
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        TaskScheduler scheduler = new TaskScheduler();
        scheduler.run();
    }
}
