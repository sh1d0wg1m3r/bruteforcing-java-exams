/*
 * Exam Question #821
 * Generated on: 2025-05-12 16:46:13
 * Generated by: Account 5
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Customer Support Ticket System
 * 
 * **Problem Description:**
 * 
 * You are tasked with developing a simple console-based application for managing customer support tickets. The system should allow users (simulating support staff) to add new tickets, process the next waiting ticket, view the current queue of waiting tickets, and view a history of processed tickets.
 * 
 * **Requirements:**
 * 
 * Implement a Java application that fulfills the following functional requirements:
 * 
 * 1.  **Add New Ticket:** Prompt the user for a ticket description and add it to a queue of waiting tickets. Each ticket should have a unique auto-generated ID and an initial status of "Waiting".
 * 2.  **Process Next Ticket:** Take the oldest ticket from the waiting queue, change its status to "Completed", and move it to a list of processed tickets. If the queue is empty, display an appropriate error message.
 * 3.  **View Queue Status:** Display the current number of tickets waiting in the queue and the details (ID and description) of the next ticket to be processed (without removing it). If the queue is empty, indicate that.
 * 4.  **View Processed History:** Display a list of all tickets that have been processed, including their ID, description, and "Completed" status. If no tickets have been processed, indicate that.
 * 5.  **Exit:** Terminate the application.
 * 
 * **Technical Constraints:**
 * 
 * Your solution **must** use **ALL** of the following Java components and concepts:
 * 
 * *   `java.util.Queue` interface
 * *   `java.util.ArrayList` class
 * *   `java.util.List` interface (declare a variable using this interface type)
 * *   `java.util.Scanner` for user input
 * *   `switch` statement for controlling the main menu flow
 * *   `System.err` for printing error messages
 * *   `System.out` for printing normal output (menu, prompts, status, history)
 * *   Class-wide exception handling using `try-catch` blocks (specifically, a general `try-catch` block wrapping the main application logic loop to catch unexpected errors, in addition to specific error handling for expected issues like invalid input).
 * 
 * **Implementation Details:**
 * 
 * *   Create a `Ticket` class to represent a support ticket. It should have private fields for ID, description, and status, a constructor, and appropriate getter methods. Include a `toString()` method for easy printing.
 * *   Create a main class (e.g., `SupportSystem`) that contains the `main` method and the core application logic.
 * *   Use a `Queue<Ticket>` to store tickets that are waiting to be processed. Choose an appropriate implementation of the `Queue` interface (e.g., `LinkedList`).
 * *   Use a `List<Ticket>` (declared as `List`, instantiated as `ArrayList`) to store tickets that have been processed.
 * *   Implement the functional requirements as methods within the main class or helper methods called from the main loop.
 * *   Handle invalid user input gracefully (e.g., entering text when a number is expected for the menu choice) using `try-catch` and `System.err`.
 * 
 * **Expected Output:**
 * 
 * The application should present a menu to the user. Based on the user's numeric choice, it should perform the corresponding action and provide feedback using `System.out` for normal operations and `System.err` for errors. The output format for tickets should be clear and readable (e.g., using the `Ticket` class's `toString()` method).
 * 
 * **Example Interaction Snippet (Illustrative):**
 * 
 * ```
 * --- Support System Menu ---
 * 1. Add New Ticket
 * 2. Process Next Ticket
 * 3. View Queue Status
 * 4. View Processed History
 * 5. Exit
 * Enter your choice: 1
 * 
 * Enter ticket description: My printer is not working.
 * Ticket #1 added to the queue.
 * 
 * --- Support System Menu ---
 * ...
 * Enter your choice: 3
 * 
 * --- Queue Status ---
 * Tickets waiting: 1
 * Next ticket to be processed: ID=1, Description='My printer is not working.'
 * --------------------
 * 
 * --- Support System Menu ---
 * ...
 * Enter your choice: 2
 * 
 * Attempting to process next ticket...
 * Processed ticket: Ticket [ID=1, Description='My printer is not working.', Status=Completed]
 * 
 * --- Support System Menu ---
 * ...
 * Enter your choice: 2
 * 
 * Attempting to process next ticket...
 * Error: No tickets in the queue to process.
 * 
 * --- Support System Menu ---
 * ...
 * Enter your choice: 4
 * 
 * --- Processed Tickets History ---
 * 1. Ticket [ID=1, Description='My printer is not working.', Status=Completed]
 * ---------------------------------
 * 
 * --- Support System Menu ---
 * ...
 * Enter your choice: invalid_input
 * Invalid input. Please enter a number.
 * 
 * --- Support System Menu ---
 * ...
 * Enter your choice: 5
 * Exiting Support System. Goodbye!
 * Application terminated.
 * ```
 * 
 * Your code should be well-structured, use meaningful names, and include basic comments where necessary.
 *
 * EXPLANATION:
 * This solution implements a simple Customer Support Ticket System demonstrating the required Java concepts.
 * 
 * 1.  **Class Structure:**
 *     *   The `Ticket` class encapsulates the data for a single ticket (ID, description, status) and provides a constructor and getters. It includes basic validation for the description.
 *     *   The `SupportSystem` class contains the main logic, managing the collections of tickets and handling user interaction.
 * 
 * 2.  **Data Structures:**
 *     *   `java.util.Queue<Ticket> waitingTickets`: A `Queue` is used to store tickets awaiting processing. The `LinkedList` class is a common implementation of the `Queue` interface that supports FIFO (First-In, First-Out) order, which is suitable for processing tickets in the order they were received. `offer()` is used for adding and `poll()` for removing, as they are safer methods that handle capacity constraints (though not strictly necessary for `LinkedList`) and empty queues gracefully (returning `null`). `peek()` is used to view the next element without removing it.
 *     *   `java.util.List<Ticket> processedTickets`: A `List` is used to store tickets after they have been processed. `ArrayList` is chosen as the implementation, providing dynamic array capabilities suitable for storing a history where order and indexed access (`get(i)`) might be useful (though iteration is used here). The variable is declared using the `List` interface type (`List<Ticket> processedTickets`), fulfilling that requirement.
 * 
 * 3.  **User Interaction and Flow Control:**
 *     *   `java.util.Scanner scanner`: An instance of `Scanner` reads input from `System.in`. It's managed within the `SupportSystem` class.
 *     *   `displayMenu()`: A helper method prints the menu options to `System.out`.
 *     *   `run()`: This method contains the main application loop (`while(running)`).
 *     *   `switch (choice)`: A `switch` statement is used to direct the program flow based on the user's numeric menu selection, calling the appropriate methods (`addTicket`, `processNextTicket`, etc.).
 * 
 * 4.  **Input/Output Streams:**
 *     *   `System.out`: Used for all standard output, including the menu, prompts, success messages (ticket added, ticket processed), queue status, and processed history.
 *     *   `System.err`: Used specifically for printing error messages, such as invalid menu input, attempting to process from an empty queue, and messages from the general exception handler. This clearly distinguishes errors from normal program output.
 * 
 * 5.  **Exception Handling:**
 *     *   **Specific Handling:**
 *         *   A `try-catch(InputMismatchException e)` block is used around `scanner.nextInt()` within the main loop. If the user enters non-numeric input, this block catches the exception, prints an error message to `System.err`, consumes the invalid input using `scanner.nextLine()`, and uses `continue` to restart the loop, prompting the user again.
 *         *   A `try-catch(IllegalArgumentException e)` block is used in the `addTicket` method to catch the exception thrown by the `Ticket` constructor if the description is empty. The error message is printed to `System.err`.
 *     *   **Class-Wide Handling:** A `try-catch(Exception e)` block wraps the entire `while(running)` loop in the `run()` method. This serves as a general safety net to catch any unexpected runtime exceptions that might occur within the application's core logic. If such an exception occurs, a generic error message and the stack trace are printed to `System.err`, and the `finally` block ensures resources are cleaned up before the application terminates.
 *     *   **Empty Queue:** The `processNextTicket` and `viewQueueStatus` methods use `poll()` and `peek()`, respectively. These methods return `null` if the queue is empty, allowing for a graceful check (`if (ticketToProcess != null)`) rather than throwing an exception (`NoSuchElementException` if `remove()` or `element()` were used). An error message is printed to `System.err` when the queue is empty and processing is attempted.
 *     *   **Resource Management:** A `finally` block is used in the `run()` method to ensure that the `Scanner` object's `close()` method is called, releasing the underlying system resource, regardless of whether the loop finishes normally or an exception is caught.
 * 
 * 6.  **Best Practices:**
 *     *   **Encapsulation:** Data fields in `Ticket` and `SupportSystem` are private, accessed/modified via public methods.
 *     *   **Meaningful Names:** Variables, methods, and classes have names that clearly indicate their purpose (`waitingTickets`, `processNextTicket`, `viewHistory`, `Ticket`, `SupportSystem`).
 *     *   **Code Structure:** The code is separated into logical units (`Ticket` class, `SupportSystem` class with distinct methods for each function).
 *     *   **Comments:** Basic comments explain the purpose of classes, methods, and key code sections.
 *     *   **Input Validation:** Basic validation is performed for ticket descriptions and menu input types.
 * 
 * This solution effectively demonstrates the required components and concepts in a practical, structured, and error-resistant manner suitable for a challenging exam task.
 */

import java.util.Queue;
import java.util.LinkedList; // A common Queue implementation
import java.util.List;
import java.util.ArrayList;
import java.util.Scanner;
import java.util.InputMismatchException;

// Class to represent a support ticket
class Ticket {
    private int id;
    private String description;
    private String status; // e.g., "Waiting", "Completed"

    /**
     * Constructs a new Ticket.
     * @param id The unique identifier for the ticket.
     * @param description A brief description of the issue.
     * @throws IllegalArgumentException if the description is null or empty.
     */
    public Ticket(int id, String description) {
        if (description == null || description.trim().isEmpty()) {
            throw new IllegalArgumentException("Ticket description cannot be empty.");
        }
        this.id = id;
        this.description = description.trim();
        this.status = "Waiting"; // Initial status
    }

    // --- Getters ---
    public int getId() {
        return id;
    }

    public String getDescription() {
        return description;
    }

    public String getStatus() {
        return status;
    }

    /**
     * Sets the status of the ticket.
     * Note: Basic validation included, more robust validation possible.
     * @param status The new status (e.g., "Waiting", "Completed").
     */
    public void setStatus(String status) {
        // Basic validation for status
        if (status != null && (status.equals("Waiting") || status.equals("Completed"))) {
            this.status = status;
        } else {
            // Using System.err for potential logic errors within the code itself
            System.err.println("Warning: Attempted to set invalid ticket status: " + status + " for Ticket ID " + this.id);
        }
    }

    /**
     * Provides a string representation of the Ticket.
     * @return A formatted string detailing the ticket.
     */
    @Override
    public String toString() {
        return "Ticket [ID=" + id + ", Description='" + description + "', Status=" + status + "]";
    }
}

// Main class for the support system application
public class SupportSystem {
    private Queue<Ticket> waitingTickets; // Queue for tickets waiting processing
    private List<Ticket> processedTickets; // List for tickets already processed
    private int nextTicketId; // Counter for assigning unique ticket IDs
    private Scanner scanner; // Scanner for reading user input

    /**
     * Constructs a new SupportSystem, initializing collections and scanner.
     */
    public SupportSystem() {
        // Use LinkedList as a concrete implementation of Queue
        this.waitingTickets = new LinkedList<>();
        // Use ArrayList as a concrete implementation of List
        this.processedTickets = new ArrayList<>();
        this.nextTicketId = 1; // Start ticket IDs from 1
        this.scanner = new Scanner(System.in); // Initialize scanner
    }

    /**
     * Adds a new ticket to the waiting queue based on user input.
     */
    public void addTicket() {
        System.out.println("\nEnter ticket description:");
        String description = scanner.nextLine(); // Read the whole line for description

        try {
            // Create a new Ticket object
            Ticket newTicket = new Ticket(nextTicketId, description);
            // Add the new ticket to the waiting queue. offer() is safer than add()
            // as it returns false instead of throwing an exception if the queue is full (unlikely for LinkedList).
            if (waitingTickets.offer(newTicket)) {
                System.out.println("Ticket #" + nextTicketId + " added to the queue.");
                nextTicketId++; // Increment for the next ticket
            } else {
                 // Should not happen with LinkedList, but good practice for Queue interface
                System.err.println("Error: Failed to add ticket to the queue.");
            }
        } catch (IllegalArgumentException e) {
            // Catch specific exception from Ticket constructor for invalid description
            System.err.println("Error adding ticket: " + e.getMessage());
        }
    }

    /**
     * Processes the next ticket in the waiting queue (FIFO).
     */
    public void processNextTicket() {
        System.out.println("\nAttempting to process next ticket...");
        // Retrieve and remove the head of the queue. poll() returns null if queue is empty.
        Ticket ticketToProcess = waitingTickets.poll();

        if (ticketToProcess != null) {
            ticketToProcess.setStatus("Completed"); // Update status
            processedTickets.add(ticketToProcess); // Add to history list
            System.out.println("Processed ticket: " + ticketToProcess); // Use System.out for success
        } else {
            // Use System.err for the error condition (queue empty)
            System.err.println("Error: No tickets in the queue to process.");
        }
    }

    /**
     * Displays the current status of the waiting queue.
     */
    public void viewQueueStatus() {
        System.out.println("\n--- Queue Status ---");
        System.out.println("Tickets waiting: " + waitingTickets.size()); // Get size using List/Collection method

        // Peek at the next ticket without removing it. peek() returns null if queue is empty.
        Ticket nextTicket = waitingTickets.peek();
        if (nextTicket != null) {
            System.out.println("Next ticket to be processed: ID=" + nextTicket.getId() + ", Description='" + nextTicket.getDescription() + "'");
        } else {
            System.out.println("The queue is empty.");
        }
        System.out.println("--------------------");
    }

    /**
     * Displays the history of all processed tickets.
     */
    public void viewHistory() {
        System.out.println("\n--- Processed Tickets History ---");
        if (processedTickets.isEmpty()) {
            System.out.println("No tickets have been processed yet.");
        } else {
            // Iterate through the List of processed tickets
            for (int i = 0; i < processedTickets.size(); i++) {
                Ticket ticket = processedTickets.get(i); // Access elements by index using List method
                System.out.println((i + 1) + ". " + ticket); // Use System.out for history display
            }
        }
        System.out.println("---------------------------------");
    }

    /**
     * Displays the main menu options to the user.
     */
    private void displayMenu() {
        System.out.println("\n--- Support System Menu ---");
        System.out.println("1. Add New Ticket");
        System.out.println("2. Process Next Ticket");
        System.out.println("3. View Queue Status");
        System.out.println("4. View Processed History");
        System.out.println("5. Exit");
        System.out.print("Enter your choice: ");
    }

    /**
     * Runs the main application loop, handling user input and dispatching actions.
     * Includes class-wide exception handling.
     */
    public void run() {
        boolean running = true;
        // Class-wide exception handling: Wrap the entire main application loop
        // to catch any unexpected runtime errors that might occur.
        try {
            while (running) {
                displayMenu();
                int choice = -1; // Default invalid choice

                try {
                    // Attempt to read integer input for menu choice
                    choice = scanner.nextInt();
                    scanner.nextLine(); // Consume the newline character left by nextInt()
                } catch (InputMismatchException e) {
                    // Specific error handling for non-integer input
                    System.err.println("Invalid input. Please enter a number.");
                    scanner.nextLine(); // Consume the invalid input (e.g., text) to prevent infinite loop
                    continue; // Skip the rest of the loop iteration and show the menu again
                }

                // Switch statement for flow control based on user choice
                switch (choice) {
                    case 1:
                        addTicket(); // Call method to add ticket
                        break;
                    case 2:
                        processNextTicket(); // Call method to process ticket
                        break;
                    case 3:
                        viewQueueStatus(); // Call method to view queue
                        break;
                    case 4:
                        viewHistory(); // Call method to view history
                        break;
                    case 5:
                        running = false; // Set flag to exit loop
                        System.out.println("Exiting Support System. Goodbye!");
                        break;
                    default:
                        // Handle choices outside the valid range (1-5)
                        System.err.println("Invalid choice. Please enter a number between 1 and 5.");
                }
            }
        } catch (Exception e) {
            // General catch block for any other unexpected exceptions during runtime
            System.err.println("\nA critical error occurred: " + e.getMessage());
            // Print stack trace to System.err for debugging unexpected errors
            e.printStackTrace(System.err);
        } finally {
            // Ensure the scanner resource is closed regardless of how the application exits
            if (scanner != null) {
                scanner.close();
            }
            System.out.println("Application terminated.");
        }
    }

    /**
     * The entry point of the application.
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        // Create an instance of the SupportSystem and run it
        SupportSystem system = new SupportSystem();
        system.run();
    }
}
