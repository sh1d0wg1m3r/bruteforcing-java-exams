/*
 * Exam Question #75
 * Generated on: 2025-05-11 22:09:19
 * Generated by: Account 4
 * 
 * QUESTION:
 * **Java Programming Exam Task: Advanced Print Job Scheduler**
 * 
 * **Scenario:**
 * You are tasked with developing a simple, command-line based Print Job Scheduler simulation. The scheduler manages a queue of print jobs waiting to be processed and keeps a history of jobs that have been successfully completed. Users can interact with the scheduler to add new jobs, process the next job in the queue, view the waiting queue, or view the history of completed jobs.
 * 
 * **Requirements:**
 * 
 * Implement a Java program consisting of at least two classes:
 * 1.  `PrintJob`: Represents a single print job. It should have a unique integer ID and a String representing the file name to be printed.
 * 2.  `PrintJobScheduler`: Manages the collection of `PrintJob` objects.
 * 
 * The `PrintJobScheduler` class must implement the following functionality:
 * *   **Add Job:** Allows the user to add a new print job by providing a file name. Each new job should be assigned a unique, sequential ID starting from 1. New jobs are added to the waiting queue.
 * *   **Process Next Job:** Takes the next job from the front of the waiting queue and moves it to the history of completed jobs. If the queue is empty, an appropriate error message should be displayed.
 * *   **List Waiting Queue:** Displays all jobs currently in the waiting queue, in the order they will be processed.
 * *   **List Completed History:** Displays all jobs that have been processed and moved to the history.
 * *   **Exit:** Terminates the program.
 * 
 * Your solution must use ALL of the following Java components:
 * *   `java.util.Queue` (specifically, an implementation like `LinkedList`) for the waiting queue.
 * *   `java.util.ArrayList` for the completed jobs history.
 * *   `java.util.List` interface: The completed jobs history field must be declared using the `List` interface type.
 * *   `java.util.Scanner` for reading user input from the console.
 * *   `switch` statement for handling user commands.
 * *   `System.err` for printing error messages (e.g., invalid command, queue empty).
 * *   `System.out` for printing normal output (prompts, job lists, success messages).
 * *   Class-wide exception handling using `try-catch` blocks to gracefully handle potential runtime issues during command processing (e.g., unexpected input).
 * 
 * **Best Practices:**
 * *   Use proper encapsulation: Declare fields as private and provide public methods for interaction.
 * *   Use meaningful variable and method names.
 * *   Include appropriate comments and documentation (e.g., Javadoc for classes/public methods).
 * *   Implement input validation where necessary (e.g., handling non-integer input for menu choices).
 * *   Ensure resources like `Scanner` are properly closed.
 * *   Structure the code cleanly.
 * 
 * **Input Format:**
 * The program should present a menu of options (1-5) to the user.
 * ```
 * Print Job Scheduler Menu:
 * 1. Add New Job
 * 2. Process Next Job
 * 3. List Waiting Queue
 * 4. List Completed History
 * 5. Exit
 * Enter your choice:
 * ```
 * Based on the choice, the program may prompt for additional input (e.g., file name for adding a job).
 * 
 * **Output Format:**
 * *   Prompts and menu should use `System.out`.
 * *   Job listings should clearly show the job ID and file name using `System.out`.
 * *   Error messages (e.g., "Invalid choice.", "Queue is empty.") must use `System.err`.
 * *   Confirmation messages (e.g., "Job added.", "Job processed.") should use `System.out`.
 * 
 * **Example Interaction:**
 * 
 * ```
 * Print Job Scheduler Menu:
 * 1. Add New Job
 * 2. Process Next Job
 * 3. List Waiting Queue
 * 4. List Completed History
 * 5. Exit
 * Enter your choice: 1
 * Enter file name: document.pdf
 * Job added: [ID: 1, File: document.pdf]
 * 
 * Print Job Scheduler Menu:
 * 1. Add New Job
 * 2. Process Next Job
 * 3. List Waiting Queue
 * 4. List Completed History
 * 5. Exit
 * Enter your choice: 1
 * Enter file name: image.png
 * Job added: [ID: 2, File: image.png]
 * 
 * Print Job Scheduler Menu:
 * 1. Add New Job
 * 2. Process Next Job
 * 3. List Waiting Queue
 * 4. List Completed History
 * 5. Exit
 * Enter your choice: 3
 * --- Waiting Queue ---
 * [ID: 1, File: document.pdf]
 * [ID: 2, File: image.png]
 * ---------------------
 * 
 * Print Job Scheduler Menu:
 * 1. Add New Job
 * 2. Process Next Job
 * 3. List Waiting Queue
 * 4. List Completed History
 * 5. Exit
 * Enter your choice: 2
 * Processing job: [ID: 1, File: document.pdf]
 * Job processed.
 * 
 * Print Job Scheduler Menu:
 * 1. Add New Job
 * 2. Process Next Job
 * 3. List Waiting Queue
 * 4. List Completed History
 * 5. Exit
 * Enter your choice: 3
 * --- Waiting Queue ---
 * [ID: 2, File: image.png]
 * ---------------------
 * 
 * Print Job Scheduler Menu:
 * 1. Add New Job
 * 2. Process Next Job
 * 3. List Waiting Queue
 * 4. List Completed History
 * 5. Exit
 * Enter your choice: 4
 * --- Completed History ---
 * [ID: 1, File: document.pdf]
 * -------------------------
 * 
 * Print Job Scheduler Menu:
 * 1. Add New Job
 * 2. Process Next Job
 * 3. List Waiting Queue
 * 4. List Completed History
 * 5. Exit
 * Enter your choice: 2
 * Processing job: [ID: 2, File: image.png]
 * Job processed.
 * 
 * Print Job Scheduler Menu:
 * 1. Add New Job
 * 2. Process Next Job
 * 3. List Waiting Queue
 * 4. List Completed History
 * 5. Exit
 * Enter your choice: 2
 * Error: Queue is empty. No jobs to process.
 * 
 * Print Job Scheduler Menu:
 * 1. Add New Job
 * 2. Process Next Job
 * 3. List Waiting Queue
 * 4. List Completed History
 * 5. Exit
 * Enter your choice: 5
 * Exiting scheduler.
 * ```
 * 
 * Implement the complete Java code for this Print Job Scheduler.
 *
 * EXPLANATION:
 * This solution implements the `PrintJobScheduler` as required, demonstrating the use of all specified Java components and adhering to best practices.
 * 
 * 1.  **`PrintJob` Class:** A simple class encapsulating the data for a print job (ID and file name). It uses private fields and public getter methods, demonstrating encapsulation. The `toString()` method provides a convenient way to represent a job for printing.
 * 
 * 2.  **`PrintJobScheduler` Class:**
 *     *   **Fields:**
 *         *   `printQueue`: Declared as `Queue<PrintJob>`, initialized with `new LinkedList<>()`. This correctly uses the `Queue` interface for FIFO behavior and `LinkedList` as a concrete implementation.
 *         *   `completedJobs`: Declared as `List<PrintJob>`, initialized with `new ArrayList<>()`. This demonstrates using the `List` interface and `ArrayList` as its implementation for the history.
 *         *   `nextJobId`: A private integer to ensure unique sequential IDs for new jobs.
 *     *   **`addJob(String fileName)`:** Creates a `PrintJob` with the next available ID and adds it to the `printQueue` using the `add()` method of the Queue. It increments `nextJobId` for the next job. Includes basic validation for the file name.
 *     *   **`processNextJob()`:** Uses `printQueue.poll()` to retrieve and remove the head of the queue. `poll()` is suitable as it returns `null` if the queue is empty, which is handled to print an error message using `System.err`. If a job is retrieved, it's added to the `completedJobs` list.
 *     *   **`listWaitingQueue()`:** Iterates through the `printQueue` using an enhanced for loop. This iterates over the elements without removing them, suitable for listing. Output is directed to `System.out`.
 *     *   **`listCompletedHistory()`:** Iterates through the `completedJobs` list using an enhanced for loop. Output is directed to `System.out`.
 *     *   **`displayMenu()`:** A private helper method to print the menu options to `System.out`.
 *     *   **`runScheduler()`:** This is the core method containing the main application loop.
 *         *   It uses a `try-with-resources` block for the `Scanner` to ensure it is automatically closed, preventing resource leaks.
 *         *   The `while(running)` loop continues until the user chooses to exit.
 *         *   Inside the loop, a `try-catch` block is used for class-wide exception handling. This block surrounds the code that reads user input and processes the choice.
 *         *   **`Scanner`:** Reads the user's integer choice using `scanner.nextInt()` and the file name using `scanner.nextLine()`. It's crucial to consume the newline character after `nextInt()` to prevent issues with subsequent `nextLine()`.
 *         *   **`switch` statement:** Handles the user's integer choice, directing execution to the appropriate method (`addJob`, `processNextJob`, `listWaitingQueue`, `listCompletedHistory`) or setting the `running` flag to `false` for exit. The `default` case handles invalid integer choices.
 *         *   **`System.err`:** Used specifically for error messages within `processNextJob` (queue empty), `addJob` (empty file name), the `default` case of the switch (invalid choice), and within the `catch` blocks.
 *         *   **`System.out`:** Used for all normal output: menu, prompts, success messages, and listing jobs.
 *         *   **`try-catch` (Exception Handling):**
 *             *   A specific `catch (InputMismatchException e)` is included to handle cases where the user enters non-integer input when an integer choice is expected. It prints an error to `System.err` and consumes the invalid input using `scanner.nextLine()` to clear the buffer and prevent an infinite loop.
 *             *   A general `catch (Exception e)` is included as a fallback to catch any other unexpected runtime exceptions that might occur within the command processing logic, printing an error to `System.err`.
 *     *   **`main` Method:** Creates an instance of `PrintJobScheduler` and calls `runScheduler()` to start the application.
 * 
 * The solution effectively integrates the required components (`Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.err`, `System.out`, `try-catch`) into a functional program that simulates a practical scenario, while following good programming practices like encapsulation, meaningful names, and basic error handling.
 */

import java.util.LinkedList;
import java.util.Queue;
import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;
import java.util.InputMismatchException;

/**
 * Represents a single print job with an ID and file name.
 */
class PrintJob {
    private int id;
    private String fileName;

    /**
     * Constructs a new PrintJob.
     * @param id The unique identifier for the job.
     * @param fileName The name of the file to print.
     */
    public PrintJob(int id, String fileName) {
        this.id = id;
        this.fileName = fileName;
    }

    /**
     * Gets the job ID.
     * @return The job ID.
     */
    public int getId() {
        return id;
    }

    /**
     * Gets the file name.
     * @return The file name.
     */
    public String getFileName() {
        return fileName;
    }

    /**
     * Returns a string representation of the PrintJob.
     * @return A string in the format "[ID: id, File: fileName]".
     */
    @Override
    public String toString() {
        return "[ID: " + id + ", File: " + fileName + "]";
    }
}

/**
 * Manages a queue of print jobs and a history of completed jobs.
 */
public class PrintJobScheduler {
    // Queue to hold jobs waiting to be processed (FIFO)
    private Queue<PrintJob> printQueue;
    // List to hold jobs that have been completed
    private List<PrintJob> completedJobs;
    // Counter for assigning unique job IDs
    private int nextJobId;

    /**
     * Constructs a new PrintJobScheduler.
     * Initializes the waiting queue and completed jobs list.
     */
    public PrintJobScheduler() {
        this.printQueue = new LinkedList<>(); // Using LinkedList as a Queue implementation
        this.completedJobs = new ArrayList<>(); // Using ArrayList for the history list
        this.nextJobId = 1; // Start job IDs from 1
    }

    /**
     * Adds a new print job to the waiting queue.
     * @param fileName The name of the file for the new job.
     */
    public void addJob(String fileName) {
        PrintJob newJob = new PrintJob(nextJobId++, fileName);
        printQueue.add(newJob);
        System.out.println("Job added: " + newJob);
    }

    /**
     * Processes the next job in the waiting queue.
     * Removes the job from the queue and adds it to the completed history.
     * Handles the case where the queue is empty.
     */
    public void processNextJob() {
        PrintJob jobToProcess = printQueue.poll(); // Retrieves and removes the head of the queue

        if (jobToProcess != null) {
            System.out.println("Processing job: " + jobToProcess);
            completedJobs.add(jobToProcess); // Add to completed history
            System.out.println("Job processed.");
        } else {
            System.err.println("Error: Queue is empty. No jobs to process.");
        }
    }

    /**
     * Lists all jobs currently in the waiting queue.
     */
    public void listWaitingQueue() {
        System.out.println("--- Waiting Queue ---");
        if (printQueue.isEmpty()) {
            System.out.println("(Queue is empty)");
        } else {
            // Iterate through the queue without removing elements
            for (PrintJob job : printQueue) {
                System.out.println(job);
            }
        }
        System.out.println("---------------------");
    }

    /**
     * Lists all jobs in the completed history.
     */
    public void listCompletedHistory() {
        System.out.println("--- Completed History ---");
        if (completedJobs.isEmpty()) {
            System.out.println("(History is empty)");
        } else {
            // Iterate through the list
            for (PrintJob job : completedJobs) {
                System.out.println(job);
            }
        }
        System.out.println("-------------------------");
    }

    /**
     * Displays the main menu to the user.
     */
    private void displayMenu() {
        System.out.println("\nPrint Job Scheduler Menu:");
        System.out.println("1. Add New Job");
        System.out.println("2. Process Next Job");
        System.out.println("3. List Waiting Queue");
        System.out.println("4. List Completed History");
        System.out.println("5. Exit");
        System.out.print("Enter your choice: ");
    }

    /**
     * Runs the main scheduler loop, handling user input.
     * Includes class-wide exception handling.
     */
    public void runScheduler() {
        // Use try-with-resources to ensure the Scanner is closed
        try (Scanner scanner = new Scanner(System.in)) {
            boolean running = true;

            // Main application loop
            while (running) {
                displayMenu();

                try {
                    int choice = scanner.nextInt();
                    scanner.nextLine(); // Consume the newline character after reading the integer

                    // Use a switch statement to handle different menu choices
                    switch (choice) {
                        case 1:
                            System.out.print("Enter file name: ");
                            String fileName = scanner.nextLine();
                            if (fileName != null && !fileName.trim().isEmpty()) {
                                addJob(fileName.trim());
                            } else {
                                System.err.println("Error: File name cannot be empty.");
                            }
                            break;
                        case 2:
                            processNextJob();
                            break;
                        case 3:
                            listWaitingQueue();
                            break;
                        case 4:
                            listCompletedHistory();
                            break;
                        case 5:
                            System.out.println("Exiting scheduler.");
                            running = false; // Set flag to exit the loop
                            break;
                        default:
                            // Handle invalid menu choices
                            System.err.println("Error: Invalid choice. Please enter a number between 1 and 5.");
                            break;
                    }
                } catch (InputMismatchException e) {
                    // Handle cases where the user enters non-integer input for the choice
                    System.err.println("Error: Invalid input. Please enter a number.");
                    scanner.nextLine(); // Consume the invalid input to prevent infinite loop
                } catch (Exception e) {
                    // Catch any other unexpected exceptions during the loop iteration
                    System.err.println("An unexpected error occurred: " + e.getMessage());
                    // Optionally print stack trace for debugging during development
                    // e.printStackTrace();
                }
            }
        } // Scanner is automatically closed here by try-with-resources
    }

    /**
     * Main method to start the Print Job Scheduler application.
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        PrintJobScheduler scheduler = new PrintJobScheduler();
        scheduler.runScheduler(); // Start the scheduler loop
    }
}
