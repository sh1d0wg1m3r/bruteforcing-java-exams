/*
 * Exam Question #417
 * Generated on: 2025-05-11 23:08:02
 * Generated by: Account 4
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Advanced Task Management System
 * 
 * **Scenario:**
 * 
 * You are tasked with developing a simple command-line application to manage tasks. Tasks are added to a queue of pending work, processed one by one, and then moved to a list of completed tasks. The system should handle user input, display task status, and manage potential errors during processing.
 * 
 * **Requirements:**
 * 
 * Implement a Java program that fulfills the following requirements:
 * 
 * 1.  **Task Representation:** Create a class named `Task` with the following characteristics:
 *     *   Private fields: `int id`, `String description`, `String status`.
 *     *   The `status` field should indicate the current state (e.g., "Pending", "Processing", "Completed", "Failed").
 *     *   A constructor to initialize `id` and `description`. The initial status should be "Pending".
 *     *   Public getter methods for all fields.
 *     *   A method to update the status (e.g., `setStatus(String status)`), intended for use by the manager class.
 *     *   Override `toString()` to provide a useful string representation of the task.
 * 
 * 2.  **Task Management Logic:** Create a class named `TaskManager` with the following characteristics:
 *     *   Private fields: A `Queue` to hold pending tasks and a `List` to hold completed tasks. Use `java.util.LinkedList` as the implementation for the `Queue` and `java.util.ArrayList` as the implementation for the `List`.
 *     *   A private field `nextTaskId` to generate unique IDs for new tasks, starting from 1.
 *     *   A constructor to initialize the collections and `nextTaskId`.
 *     *   A public method `addTask(String description)`:
 *         *   Takes a task description as input.
 *         *   Validates that the description is not null or empty. Throw an `IllegalArgumentException` if invalid.
 *         *   Creates a new `Task` object with the next available ID and the provided description.
 *         *   Adds the new task to the pending tasks `Queue`.
 *         *   Increments `nextTaskId`.
 *         *   Prints a success message to `System.out`.
 *     *   A public method `processNextTask()`:
 *         *   Attempts to retrieve and remove the next task from the pending tasks `Queue`.
 *         *   If the queue is empty, throw a custom exception (see requirement 3).
 *         *   Simulate task processing: If the task's description (case-insensitive) contains the word "FAIL", mark the task's status as "Failed". Otherwise, mark the status as "Completed".
 *         *   Add the processed task (regardless of success or failure) to the completed tasks `List`.
 *         *   Print a message to `System.out` indicating the task being processed and its final status (Completed or Failed). If failed, also print an error message to `System.err`.
 *     *   Public methods `getPendingTasks()` and `getCompletedTasks()` to return the respective collections (you may return the direct collections for simplicity in this exam).
 * 
 * 3.  **Exception Handling:**
 *     *   Create a custom exception class `TaskProcessingException` that extends `Exception` to signal errors specific to task processing (e.g., trying to process when the queue is empty, or a simulated processing failure).
 *     *   Implement class-wide exception handling using `try-catch` blocks in the main application logic (see requirement 4). This should catch potential exceptions like `IllegalArgumentException` from `addTask`, `TaskProcessingException` from `processNextTask`, and potentially other unexpected runtime exceptions. Error messages from caught exceptions should be printed to `System.err`.
 * 
 * 4.  **Main Application:** Create a class (e.g., `TaskManagementApp`) with a `main` method that provides a menu-driven interface:
 *     *   Use `java.util.Scanner` to read user input from the console.
 *     *   Use a `switch` statement to handle user menu choices.
 *     *   The menu should offer the following options:
 *         1.  Add New Task
 *         2.  Process Next Task
 *         3.  View Pending Tasks
 *         4.  View Completed Tasks
 *         5.  Exit
 *     *   Use `System.out` for printing the menu, prompts, and successful operation results.
 *     *   Use `System.err` for printing invalid menu choices and error messages caught by the `try-catch` blocks.
 *     *   Implement a loop that continues until the user chooses to exit.
 *     *   Wrap the core interaction loop (or the switch statement logic) within `try-catch` block(s) to demonstrate class-wide exception handling. Handle specific exceptions where appropriate (e.g., your custom exception, `IllegalArgumentException`) and a general `Exception` as a fallback.
 *     *   Ensure the `Scanner` is closed when the application exits.
 * 
 * 5.  **Best Practices:**
 *     *   Use proper encapsulation (private fields, public methods).
 *     *   Use meaningful variable and method names.
 *     *   Include basic comments or Javadoc to explain classes and methods.
 *     *   Implement input validation where specified.
 *     *   Ensure clean code structure with separate classes for different responsibilities.
 * 
 * **Expected Output:**
 * 
 * Your program should interact with the user via the console. Example interactions might look like this:
 * 
 * ```
 * --- Task Management Menu ---
 * 1. Add New Task
 * 2. Process Next Task
 * 3. View Pending Tasks
 * 4. View Completed Tasks
 * 5. Exit
 * ----------------------------
 * Enter your choice: 1
 * Enter task description: Write report
 * 
 * Task added: Task [ID=1, Desc='Write report', Status=Pending]
 * 
 * --- Task Management Menu ---
 * ...
 * Enter your choice: 1
 * Enter task description: Fix bug (FAIL simulation)
 * 
 * Task added: Task [ID=2, Desc='Fix bug (FAIL simulation)', Status=Pending]
 * 
 * --- Task Management Menu ---
 * ...
 * Enter your choice: 3
 * --- Pending Tasks ---
 * 1. Task [ID=1, Desc='Write report', Status=Pending]
 * 2. Task [ID=2, Desc='Fix bug (FAIL simulation)', Status=Pending]
 * ---------------------
 * 
 * --- Task Management Menu ---
 * ...
 * Enter your choice: 2
 * Processing task: Write report (ID: 1)
 * Task completed successfully: Write report (ID: 1)
 * 
 * --- Task Management Menu ---
 * ...
 * Enter your choice: 2
 * Processing task: Fix bug (FAIL simulation) (ID: 2)
 * Task processing failed for ID 2: Simulated failure.
 * Processing Error: Processing failed for task ID 2
 * 
 * --- Task Management Menu ---
 * ...
 * Enter your choice: 4
 * --- Completed Tasks ---
 * 1. Task [ID=1, Desc='Write report', Status=Completed]
 * 2. Task [ID=2, Desc='Fix bug (FAIL simulation)', Status=Failed]
 * -----------------------
 * 
 * --- Task Management Menu ---
 * ...
 * Enter your choice: 2
 * Processing Error: No pending tasks to process.
 * 
 * --- Task Management Menu ---
 * ...
 * Enter your choice: invalid
 * Invalid choice. Please enter a number between 1 and 5.
 * 
 * --- Task Management Menu ---
 * ...
 * Enter your choice: 1
 * Enter task description:
 * 
 * Input Error: Task description cannot be empty.
 * 
 * --- Task Management Menu ---
 * ...
 * Enter your choice: 5
 * Exiting Task Management System.
 * Scanner closed.
 * ```
 * 
 * Your solution should be provided as a single Java file containing all necessary classes.
 *
 * EXPLANATION:
 * This solution implements a simple Task Management System demonstrating the required Java concepts.
 * 
 * 1.  **`Task` Class:** A basic POJO (Plain Old Java Object) representing a task with an ID, description, and status. It includes a constructor, getters, a setter for status (used by `TaskManager`), and overrides `toString()` for easy printing. This demonstrates encapsulation and basic object modeling.
 * 
 * 2.  **`TaskProcessingException`:** A custom checked exception is defined to specifically signal errors that occur during task processing, such as attempting to process an empty queue or a simulated processing failure. Using custom exceptions improves code readability and allows for more specific error handling.
 * 
 * 3.  **`TaskManager` Class:** This class encapsulates the core logic and data structures.
 *     *   It uses a `java.util.Queue<Task>` named `pendingTasks`, implemented by `java.util.LinkedList`, to maintain the order of tasks waiting to be processed (FIFO - First-In, First-Out).
 *     *   It uses a `java.util.List<Task>` named `completedTasks`, implemented by `java.util.ArrayList`, to store tasks after they have been processed. Declaring it as `List` and instantiating as `ArrayList` demonstrates coding to the interface.
 *     *   `addTask` validates the input description using `if` and throws an `IllegalArgumentException` for invalid input. It uses `queue.offer()` to add the task.
 *     *   `processNextTask` uses `queue.peek()` to check if a task exists before attempting to `queue.poll()` (remove) it. This prevents `NoSuchElementException` if using `remove()`. If the queue is empty, it throws the custom `TaskProcessingException`. It simulates a processing failure based on the task description and updates the task's status accordingly, adding the task to the `completedTasks` list. It uses `System.out` for success and `System.err` for the simulated failure message before throwing the exception.
 *     *   `getPendingTasks` and `getCompletedTasks` provide access to the underlying collections.
 * 
 * 4.  **`TaskManagementApp` Class (Main Application):**
 *     *   The `main` method sets up the `Scanner` for input and an instance of `TaskManager`.
 *     *   A `do-while` (or `while`) loop drives the application, continuing until the user chooses to exit.
 *     *   The core interaction loop is wrapped in a `try-catch` block (`try { while(...) } catch { ... } finally { ... }`). This fulfills the requirement for "class-wide exception handling" by covering the main execution flow.
 *     *   An *inner* `try-catch` block is placed inside the loop, around the `switch` statement. This demonstrates more granular error handling, allowing the application to catch exceptions from specific operations (`addTask`, `processNextTask`) and print an error message using `System.err` without crashing the entire application loop. This allows the user to continue interacting after an error.
 *     *   The `switch` statement handles the user's menu choice, calling the appropriate `TaskManager` methods or program logic.
 *     *   Invalid menu choices fall into the `default` case of the `switch`, printing an error to `System.err`.
 *     *   The `catch` blocks specifically handle `IllegalArgumentException` (from input validation), `TaskProcessingException` (from task processing), and a general `Exception` as a fallback for any other unexpected runtime errors. All caught exception messages are printed to `System.err`.
 *     *   A `finally` block ensures the `Scanner` resource is closed, preventing resource leaks.
 *     *   Helper methods `printMenu`, `viewPendingTasks`, and `viewCompletedTasks` are used to keep the `main` method cleaner. `viewPendingTasks` iterates the `Queue` using a for-each loop, which does not remove elements.
 * 
 * This solution effectively integrates all required components (`Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.err`, `System.out`, `try-catch`) in a practical scenario, demonstrates object-oriented design, input validation, custom exceptions, and layered error handling, making it a challenging but fair exam question for evaluating advanced Java skills.
 */

import java.util.Queue;
import java.util.LinkedList;
import java.util.List;
import java.util.ArrayList;
import java.util.Scanner;
import java.util.Locale; // To handle case-insensitive comparison

/**
 * Represents a single task in the management system.
 */
class Task {
    private int id;
    private String description;
    private String status; // e.g., "Pending", "Processing", "Completed", "Failed"

    /**
     * Constructs a new Task.
     * @param id The unique identifier for the task.
     * @param description The description of the task.
     */
    public Task(int id, String description) {
        this.id = id;
        this.description = description;
        this.status = "Pending"; // Initial status
    }

    // --- Getters ---
    public int getId() {
        return id;
    }

    public String getDescription() {
        return description;
    }

    public String getStatus() {
        return status;
    }

    /**
     * Updates the status of the task.
     * @param status The new status.
     */
    public void setStatus(String status) {
        this.status = status;
    }

    /**
     * Provides a string representation of the Task.
     * @return String representation.
     */
    @Override
    public String toString() {
        return "Task [ID=" + id + ", Desc='" + description + "', Status=" + status + "]";
    }
}

/**
 * Custom exception for task processing errors.
 */
class TaskProcessingException extends Exception {
    /**
     * Constructs a new TaskProcessingException with the specified detail message.
     * @param message The detail message.
     */
    public TaskProcessingException(String message) {
        super(message);
    }
}

/**
 * Manages the collection of pending and completed tasks.
 */
class TaskManager {
    // Queue for tasks waiting to be processed
    private Queue<Task> pendingTasks;
    // List for tasks that have been processed
    private List<Task> completedTasks;
    // Counter for generating unique task IDs
    private int nextTaskId;

    /**
     * Constructs a new TaskManager.
     */
    public TaskManager() {
        // Use LinkedList as a Queue implementation
        this.pendingTasks = new LinkedList<>();
        // Use ArrayList as a List implementation
        this.completedTasks = new ArrayList<>();
        this.nextTaskId = 1; // Start task IDs from 1
    }

    /**
     * Adds a new task to the pending queue.
     *
     * @param description The description of the task.
     * @throws IllegalArgumentException if the description is null or empty.
     */
    public void addTask(String description) throws IllegalArgumentException {
        if (description == null || description.trim().isEmpty()) {
            throw new IllegalArgumentException("Task description cannot be empty.");
        }
        // Create new task and add to the pending queue
        Task newTask = new Task(nextTaskId++, description.trim());
        pendingTasks.offer(newTask); // offer is preferred over add for queues as it handles capacity limits
        System.out.println("Task added: " + newTask); // Use System.out for success
    }

    /**
     * Processes the next task from the pending queue.
     * Simulates processing and potential failure based on description.
     *
     * @throws TaskProcessingException if there are no tasks to process or processing fails.
     */
    public void processNextTask() throws TaskProcessingException {
        // Retrieve the next task from the queue without removing it yet
        Task taskToProcess = pendingTasks.peek();

        if (taskToProcess == null) {
            // If peek() returns null, the queue is empty
            throw new TaskProcessingException("No pending tasks to process.");
        }

        // Remove the task from the queue now that we know it exists
        taskToProcess = pendingTasks.poll();

        System.out.println("Processing task: " + taskToProcess.getDescription() + " (ID: " + taskToProcess.getId() + ")"); // Use System.out for processing start

        // Simulate processing logic and potential failure
        // Optional: taskToProcess.setStatus("Processing"); // Could set status temporarily

        // Simulate failure if description contains "FAIL" (case-insensitive)
        boolean simulationFailed = taskToProcess.getDescription().toUpperCase(Locale.ROOT).contains("FAIL");

        if (simulationFailed) {
            taskToProcess.setStatus("Failed");
            completedTasks.add(taskToProcess); // Move to completed list even if failed
            System.err.println("Task processing failed for ID " + taskToProcess.getId() + ": Simulated failure."); // Use System.err for failure
            // Throw exception to signal failure to the calling code (Main application)
            throw new TaskProcessingException("Processing failed for task ID " + taskToProcess.getId());
        } else {
            taskToProcess.setStatus("Completed");
            completedTasks.add(taskToProcess); // Move to completed list
            System.out.println("Task completed successfully: " + taskToProcess.getDescription() + " (ID: " + taskToProcess.getId() + ")"); // Use System.out for success
        }
    }

    /**
     * Returns the queue of pending tasks.
     * @return The queue of pending tasks.
     */
    public Queue<Task> getPendingTasks() {
        return pendingTasks;
    }

    /**
     * Returns the list of completed tasks.
     * @return The list of completed tasks.
     */
    public List<Task> getCompletedTasks() {
        return completedTasks;
    }
}

/**
 * Main application class for the Task Management System.
 * Provides a menu-driven interface.
 */
public class TaskManagementApp {

    public static void main(String[] args) {
        // Scanner for reading user input
        Scanner scanner = new Scanner(System.in);
        // TaskManager instance to handle task operations
        TaskManager taskManager = new TaskManager();
        boolean running = true;

        // --- Class-wide exception handling for the main application loop ---
        try {
            // Main application loop
            while (running) {
                printMenu();
                System.out.print("Enter your choice: ");
                String choice = scanner.nextLine();

                // --- Inner try-catch for handling specific operation errors ---
                try {
                    // Use switch statement for menu options
                    switch (choice) {
                        case "1":
                            // Add New Task
                            System.out.print("Enter task description: ");
                            String description = scanner.nextLine();
                            taskManager.addTask(description); // addTask might throw IllegalArgumentException
                            break;
                        case "2":
                            // Process Next Task
                            taskManager.processNextTask(); // processNextTask might throw TaskProcessingException
                            break;
                        case "3":
                            // View Pending Tasks
                            viewPendingTasks(taskManager.getPendingTasks());
                            break;
                        case "4":
                            // View Completed Tasks
                            viewCompletedTasks(taskManager.getCompletedTasks());
                            break;
                        case "5":
                            // Exit
                            System.out.println("Exiting Task Management System.");
                            running = false; // Set flag to exit loop
                            break;
                        default:
                            // Invalid choice
                            System.err.println("Invalid choice. Please enter a number between 1 and 5."); // Use System.err for invalid input
                            break;
                    }
                } catch (IllegalArgumentException e) {
                    // Catch errors from input validation (e.g., empty description)
                    System.err.println("Input Error: " + e.getMessage()); // Use System.err
                } catch (TaskProcessingException e) {
                    // Catch errors specific to task processing (e.g., empty queue, simulated failure)
                    System.err.println("Processing Error: " + e.getMessage()); // Use System.err
                } catch (Exception e) {
                    // Catch any other unexpected runtime exceptions during an operation
                    System.err.println("An unexpected error occurred during operation: " + e.getMessage()); // Use System.err
                    // Optional: e.printStackTrace(System.err); // Print stack trace for debugging
                }
                System.out.println(); // Add a newline for better readability between operations
            }
        } catch (Exception mainException) {
            // This outer catch block handles exceptions that might escape the inner block
            // or occur outside the switch logic (e.g., errors during scanner operations,
            // or unhandled exceptions from TaskManager that weren't caught inside).
            System.err.println("A critical error occurred in the main application loop: " + mainException.getMessage());
            // Optional: mainException.printStackTrace(System.err);
        } finally {
            // Ensure resources like Scanner are closed
            if (scanner != null) {
                scanner.close();
                System.out.println("Scanner closed."); // Confirmation message
            }
        }
    }

    /**
     * Prints the main menu options to System.out.
     */
    private static void printMenu() {
        System.out.println("--- Task Management Menu ---");
        System.out.println("1. Add New Task");
        System.out.println("2. Process Next Task");
        System.out.println("3. View Pending Tasks");
        System.out.println("4. View Completed Tasks");
        System.out.println("5. Exit");
        System.out.println("----------------------------");
    }

    /**
     * Displays the tasks currently in the pending queue.
     * @param tasks The queue of pending tasks.
     */
    private static void viewPendingTasks(Queue<Task> tasks) {
        System.out.println("--- Pending Tasks ---");
        if (tasks.isEmpty()) {
            System.out.println("No pending tasks.");
        } else {
            // Iterate through the queue without removing elements
            int index = 1;
            for (Task task : tasks) {
                System.out.println(index++ + ". " + task); // Uses Task.toString()
            }
        }
        System.out.println("---------------------");
    }

    /**
     * Displays the tasks that have been completed (or failed).
     * @param tasks The list of completed tasks.
     */
    private static void viewCompletedTasks(List<Task> tasks) {
        System.out.println("--- Completed Tasks ---");
        if (tasks.isEmpty()) {
            System.out.println("No completed tasks.");
        } else {
            int index = 1;
            for (Task task : tasks) {
                System.out.println(index++ + ". " + task); // Uses Task.toString()
            }
        }
        System.out.println("-----------------------");
    }
}
