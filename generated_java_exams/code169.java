/*
 * Exam Question #169
 * Generated on: 2025-05-11 22:25:22
 * Generated by: Account 2
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Production Line Task Manager
 * 
 * **Objective:** Design and implement a simple command-line application simulating a production line task manager. The application should allow users to add new tasks to a queue, process the next task in the queue, and view both pending and completed tasks.
 * 
 * **Requirements:**
 * 
 * 1.  **Task Representation:** Create a `Task` class with the following private fields:
 *     *   `id` (int): A unique identifier for the task.
 *     *   `description` (String): A brief description of the task.
 *     *   `status` (String): The current status of the task (e.g., "PENDING", "COMPLETED").
 *     *   Implement appropriate constructor(s), getters, and a method to update the status.
 * 
 * 2.  **Task Management:** Create a `TaskManager` class responsible for managing tasks. It must contain:
 *     *   A `java.util.Queue<Task>` to hold tasks that are waiting to be processed.
 *     *   A `java.util.List<Task>` (specifically, an `ArrayList`) to hold tasks that have been completed.
 *     *   Methods for:
 *         *   `addTask(String description)`: Creates a new `Task` with a unique ID, sets its status to "PENDING", and adds it to the pending tasks queue.
 *         *   `processNextTask()`: Removes the next task from the pending queue, changes its status to "COMPLETED", and adds it to the completed tasks list. This method should handle the case where the queue is empty.
 *         *   `getPendingTasks()`: Returns a `List` view of the tasks currently in the pending queue (without removing them).
 *         *   `getCompletedTasks()`: Returns the `List` of completed tasks.
 * 
 * 3.  **User Interface:** Implement a command-line interface in a main class (e.g., `ProductionLineApp`) using `java.util.Scanner`. The application should present a menu with the following options:
 *     *   1. Add New Task
 *     *   2. Process Next Task
 *     *   3. View Pending Tasks
 *     *   4. View Completed Tasks
 *     *   5. Exit
 * 
 * 4.  **Control Flow:** Use a `switch` statement to handle the user's menu selection.
 * 
 * 5.  **Input Handling:**
 *     *   Read user input using `java.util.Scanner`.
 *     *   Validate menu input to ensure it's a valid integer corresponding to a menu option.
 *     *   Handle potential `InputMismatchException` if the user enters non-integer input for the menu choice.
 *     *   Handle potential `NoSuchElementException` or `IllegalStateException` related to `Scanner` usage gracefully.
 * 
 * 6.  **Error Handling:**
 *     *   Use `System.err` to print error messages (e.g., invalid menu input, attempting to process a task when the queue is empty).
 *     *   Use `System.out` for all normal output (menu, task details, confirmations).
 *     *   Implement class-wide or main loop level exception handling using `try-catch` blocks to prevent the application from crashing due to unexpected errors, especially related to input.
 * 
 * 7.  **Best Practices:**
 *     *   Ensure proper encapsulation in the `Task` and `TaskManager` classes (private fields, public methods).
 *     *   Use meaningful variable and method names.
 *     *   Include appropriate comments and basic documentation (e.g., Javadoc for classes/methods).
 *     *   Implement input validation where necessary (e.g., task description not empty - optional but good practice).
 * 
 * **Expected Output/Interaction:**
 * 
 * The application should loop, presenting the menu until the user chooses to exit.
 * *   Adding a task should prompt for a description and confirm addition.
 * *   Processing a task should indicate which task was processed or report if the queue is empty.
 * *   Viewing tasks should list the tasks in the respective queues/lists.
 * *   Invalid input should print an error message to `System.err` and re-display the menu.
 * 
 * **Example Interaction Snippet:**
 * 
 * ```
 * --- Production Line Task Manager ---
 * 1. Add New Task
 * 2. Process Next Task
 * 3. View Pending Tasks
 * 4. View Completed Tasks
 * 5. Exit
 * Enter your choice: 1
 * Enter task description: Build component A
 * Task added with ID: 1.
 * 
 * --- Production Line Task Manager ---
 * ...
 * Enter your choice: 1
 * Enter task description: Test component A
 * Task added with ID: 2.
 * 
 * --- Production Line Task Manager ---
 * ...
 * Enter your choice: 3
 * --- Pending Tasks ---
 * ID: 1, Description: Build component A, Status: PENDING
 * ID: 2, Description: Test component A, Status: PENDING
 * 
 * --- Production Line Task Manager ---
 * ...
 * Enter your choice: 2
 * Processing task: ID: 1, Description: Build component A, Status: PENDING
 * Task ID 1 processed and completed.
 * 
 * --- Production Line Task Manager ---
 * ...
 * Enter your choice: 3
 * --- Pending Tasks ---
 * ID: 2, Description: Test component A, Status: PENDING
 * 
 * --- Production Line Task Manager ---
 * ...
 * Enter your choice: 4
 * --- Completed Tasks ---
 * ID: 1, Description: Build component A, Status: COMPLETED
 * 
 * --- Production Line Task Manager ---
 * ...
 * Enter your choice: abc
 * Error: Invalid input. Please enter a number between 1 and 5.
 * 
 * --- Production Line Task Manager ---
 * ...
 * Enter your choice: 2
 * Processing task: ID: 2, Description: Test component A, Status: PENDING
 * Task ID 2 processed and completed.
 * 
 * --- Production Line Task Manager ---
 * ...
 * Enter your choice: 2
 * Error: No tasks in the pending queue to process.
 * 
 * --- Production Line Task Manager ---
 * ...
 * Enter your choice: 5
 * Exiting Task Manager.
 * ```
 * 
 * Implement the complete Java code for this application.
 *
 * EXPLANATION:
 * This solution implements a basic production line task manager, demonstrating the required Java concepts and best practices.
 * 
 * **Key Components and Concepts Demonstrated:**
 * 
 * 1.  **`Task` Class:** A simple POJO (Plain Old Java Object) representing a task. It encapsulates task data (`id`, `description`, `status`) with private fields and public getters. The `setStatus` method allows changing the task's state, and `toString` provides a convenient way to print task details. This shows basic object-oriented design and encapsulation.
 * 
 * 2.  **`TaskManager` Class:** This class manages the core logic.
 *     *   **`Queue<Task> pendingTasks`**: A `LinkedList` is used to implement the `Queue` interface. This is suitable for managing tasks in a First-In, First-Out (FIFO) manner, simulating tasks arriving and being processed in order. `addTask` uses `add()` to enqueue, and `processNextTask` uses `poll()` to dequeue.
 *     *   **`List<Task> completedTasks`**: An `ArrayList` is used to store completed tasks. `ArrayList` is a common and efficient choice for storing elements when random access isn't strictly necessary but dynamic resizing is. The variable is declared using the `List` interface type (`List<Task> completedTasks = new ArrayList<>();`), which is good practice as it allows flexibility to change the underlying implementation (e.g., to `LinkedList`) later if needed, without changing the code that interacts with the list via the `List` interface methods.
 *     *   **`addTask(String description)`**: Creates a new `Task` with an auto-incrementing ID and adds it to the `pendingTasks` queue.
 *     *   **`processNextTask()`**: Uses `pendingTasks.poll()` to get and remove the head of the queue. It checks if the result is `null` to handle the empty queue case, demonstrating safe interaction with the queue. If a task is retrieved, its status is updated, and it's added to the `completedTasks` `List`.
 *     *   **`getPendingTasks()` and `getCompletedTasks()`**: Provide access to the task lists. `getPendingTasks()` returns a new `ArrayList` created from the queue's contents to avoid exposing the internal `LinkedList` directly and prevent external code from modifying the queue structure unexpectedly. `getCompletedTasks()` returns the reference to the internal `ArrayList`.
 * 
 * 3.  **`ProductionLineApp` Class (Main Application):**
 *     *   **`Scanner`**: Used to read user input from `System.in`. The code correctly handles the newline character after reading an integer using `scanner.nextLine()`.
 *     *   **`Switch statement`**: Controls the main application loop based on the user's menu choice, providing a clear and structured way to handle different commands.
 *     *   **`System.out`**: Used for displaying the menu, task details, confirmations, and other normal application output.
 *     *   **`System.err`**: Used specifically for printing error messages, such as invalid input or attempting an action (like processing) when the state is not valid (e.g., empty queue). This distinguishes error output from normal output.
 *     *   **`try-catch` blocks**:
 *         *   A `try-catch(InputMismatchException e)` block specifically handles cases where the user enters non-integer input when a number is expected (the menu choice). It prints an error to `System.err` and consumes the invalid input using `scanner.nextLine()` to prevent an infinite loop.
 *         *   A general `try-catch(Exception e)` block wraps the core logic inside the `while` loop. This acts as a class-wide or main-loop-level exception handler, catching any other unexpected runtime exceptions that might occur during the execution of a menu option, preventing the program from crashing and allowing it to continue running the loop.
 * 
 * 4.  **Best Practices:**
 *     *   **Encapsulation:** Fields in `Task` and `TaskManager` are private, accessed via public methods.
 *     *   **Meaningful Names:** Class, method, and variable names (`Task`, `TaskManager`, `pendingTasks`, `processNextTask`, `description`, `id`) are descriptive.
 *     *   **Comments/Documentation:** Javadoc-style comments are included for classes and methods, explaining their purpose.
 *     *   **Input Validation:** Basic validation is done for the menu choice (via `switch` default and `InputMismatchException` handling) and a check for empty task description is included.
 *     *   **Error Handling:** `System.err` is used for errors, specific exception types (`InputMismatchException`) are caught, and a general `Exception` catch provides robustness.
 * 
 * This solution effectively integrates all the required components (`Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.err`, `System.out`, `try-catch`) into a functional application that simulates a real-world scenario, while adhering to good programming practices.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.InputMismatchException;

/**
 * Represents a single task in the production line.
 */
class Task {
    private int id;
    private String description;
    private String status; // e.g., "PENDING", "COMPLETED"

    /**
     * Constructs a new Task.
     * @param id The unique ID of the task.
     * @param description The description of the task.
     */
    public Task(int id, String description) {
        this.id = id;
        this.description = description;
        this.status = "PENDING"; // Default status
    }

    // Getters
    public int getId() {
        return id;
    }

    public String getDescription() {
        return description;
    }

    public String getStatus() {
        return status;
    }

    /**
     * Sets the status of the task.
     * @param status The new status (e.g., "COMPLETED").
     */
    public void setStatus(String status) {
        this.status = status;
    }

    @Override
    public String toString() {
        return "ID: " + id + ", Description: " + description + ", Status: " + status;
    }
}

/**
 * Manages the queue of pending tasks and the list of completed tasks.
 */
class TaskManager {
    private Queue<Task> pendingTasks;
    private List<Task> completedTasks;
    private int nextTaskId; // Simple counter for unique IDs

    /**
     * Constructs a TaskManager.
     */
    public TaskManager() {
        // Using LinkedList as a Queue implementation
        this.pendingTasks = new LinkedList<>();
        // Using ArrayList as a List implementation
        this.completedTasks = new ArrayList<>();
        this.nextTaskId = 1; // Start task IDs from 1
    }

    /**
     * Adds a new task to the pending queue.
     * @param description The description of the task.
     */
    public void addTask(String description) {
        Task newTask = new Task(nextTaskId++, description);
        pendingTasks.add(newTask);
        System.out.println("Task added with ID: " + newTask.getId() + ".");
    }

    /**
     * Processes the next task in the pending queue.
     * Removes it from the queue, marks it as completed, and adds it to the completed list.
     * @return The task that was processed, or null if the queue was empty.
     */
    public Task processNextTask() {
        // poll() retrieves and removes the head of this queue, or returns null if this queue is empty.
        Task taskToProcess = pendingTasks.poll();
        if (taskToProcess != null) {
            System.out.println("Processing task: " + taskToProcess);
            taskToProcess.setStatus("COMPLETED");
            completedTasks.add(taskToProcess);
            System.out.println("Task ID " + taskToProcess.getId() + " processed and completed.");
            return taskToProcess;
        } else {
            System.err.println("Error: No tasks in the pending queue to process.");
            return null;
        }
    }

    /**
     * Returns a list of tasks currently in the pending queue.
     * Note: This creates a new list containing elements from the queue for display purposes.
     * It does not remove elements from the queue.
     * @return A List of pending tasks.
     */
    public List<Task> getPendingTasks() {
        // Convert queue to list for easy iteration and display
        return new ArrayList<>(pendingTasks);
    }

    /**
     * Returns the list of completed tasks.
     * @return A List of completed tasks.
     */
    public List<Task> getCompletedTasks() {
        return completedTasks;
    }
}

/**
 * Main application class for the Production Line Task Manager.
 * Handles user interaction and integrates with the TaskManager.
 */
public class ProductionLineApp {

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        TaskManager taskManager = new TaskManager();
        boolean running = true;

        System.out.println("--- Production Line Task Manager ---");

        // Class-wide exception handling loop
        while (running) {
            printMenu();
            int choice = -1; // Default invalid choice

            try {
                System.out.print("Enter your choice: ");
                choice = scanner.nextInt();
                // Consume the newline character left by nextInt()
                scanner.nextLine();

                // Switch statement for menu options
                switch (choice) {
                    case 1:
                        System.out.print("Enter task description: ");
                        String description = scanner.nextLine();
                        if (description == null || description.trim().isEmpty()) {
                             System.err.println("Error: Task description cannot be empty.");
                        } else {
                            taskManager.addTask(description.trim());
                        }
                        break;
                    case 2:
                        taskManager.processNextTask();
                        break;
                    case 3:
                        List<Task> pending = taskManager.getPendingTasks();
                        System.out.println("--- Pending Tasks ---");
                        if (pending.isEmpty()) {
                            System.out.println("No tasks pending.");
                        } else {
                            for (Task task : pending) {
                                System.out.println(task);
                            }
                        }
                        break;
                    case 4:
                        List<Task> completed = taskManager.getCompletedTasks();
                        System.out.println("--- Completed Tasks ---");
                        if (completed.isEmpty()) {
                             System.out.println("No tasks completed yet.");
                        } else {
                            for (Task task : completed) {
                                System.out.println(task);
                            }
                        }
                        break;
                    case 5:
                        running = false;
                        System.out.println("Exiting Task Manager.");
                        break;
                    default:
                        // Invalid number entered
                        System.err.println("Error: Invalid input. Please enter a number between 1 and 5.");
                        break;
                }
            } catch (InputMismatchException e) {
                // Handles non-integer input for menu choice
                System.err.println("Error: Invalid input. Please enter a number.");
                scanner.nextLine(); // Consume the invalid input to prevent infinite loop
            } catch (Exception e) {
                // Catch any other unexpected exceptions
                System.err.println("An unexpected error occurred: " + e.getMessage());
                // Optionally print stack trace for debugging during development/exam
                // e.printStackTrace();
            }
             System.out.println(); // Add a blank line for better readability between loops
        }

        scanner.close(); // Close the scanner when done
    }

    /**
     * Prints the main menu options to the console.
     */
    private static void printMenu() {
        System.out.println("--- Production Line Task Manager ---");
        System.out.println("1. Add New Task");
        System.out.println("2. Process Next Task");
        System.out.println("3. View Pending Tasks");
        System.out.println("4. View Completed Tasks");
        System.out.println("5. Exit");
    }
}
