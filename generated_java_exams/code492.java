/*
 * Exam Question #492
 * Generated on: 2025-05-11 23:19:12
 * Generated by: Account 5
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Advanced Task Management System
 * 
 * **Problem Description:**
 * 
 * Design and implement a command-line based Task Management System that allows users to add, process, and view tasks. Tasks have a description and a priority level. The system should manage pending tasks in a queue, processing them in the order they were added (First-In, First-Out). Completed tasks should be stored separately in a list for historical viewing.
 * 
 * Your solution must demonstrate a strong understanding of core Java collections, control flow, input/output, and exception handling.
 * 
 * **Requirements:**
 * 
 * 1.  **Task Representation:** Create a class `Task` with private fields for `id` (an integer, automatically assigned), `description` (String), and `priority` (an integer). Include a constructor, getters for all fields, and a meaningful `toString()` method.
 * 2.  **Task Management Logic:** Create a class `TaskScheduler` that encapsulates the task management logic.
 *     *   It must use a `java.util.Queue` (specifically, implement it using `java.util.LinkedList`) to hold tasks that are pending.
 *     *   It must use a `java.util.List` (specifically, implement it using `java.util.ArrayList`) to store tasks that have been completed.
 *     *   Include a counter to assign unique IDs to tasks.
 *     *   Implement methods for:
 *         *   `addTask(String description, int priority)`: Adds a new task to the pending queue. Validate that priority is a non-negative integer.
 *         *   `processNextTask()`: Removes the task at the head of the pending queue and adds it to the completed tasks list. Handle the case where the queue is empty.
 *         *   `listPendingTasks()`: Prints all tasks currently in the pending queue.
 *         *   `listCompletedTasks()`: Prints all tasks in the completed tasks list.
 *         *   `run()`: Contains the main application loop, handling user interaction.
 * 3.  **User Interface:**
 *     *   Use `java.util.Scanner` to read user commands from standard input.
 *     *   The application should continuously prompt the user for a command until they enter "exit".
 *     *   Support the following commands:
 *         *   `add <description> <priority>`: Adds a new task. `<description>` can be a single word or multiple words (read the rest of the line after "add"). `<priority>` must be an integer.
 *         *   `process`: Processes the next task in the queue.
 *         *   `pending`: Lists all pending tasks.
 *         *   `completed`: Lists all completed tasks.
 *         *   `exit`: Terminates the application.
 *     *   Use a `switch` statement to dispatch based on the user's command.
 * 4.  **Output:**
 *     *   Use `System.out` for prompts, successful operation messages, and listing tasks.
 *     *   Use `System.err` for error messages (e.g., invalid command, invalid priority input, attempting to process an empty queue).
 * 5.  **Error Handling:**
 *     *   Implement class-wide exception handling using `try-catch` blocks within the `run()` method to gracefully handle potential issues, particularly related to parsing user input (like the priority).
 *     *   Validate user input where necessary (e.g., priority must be a valid integer).
 * 6.  **Best Practices:**
 *     *   Ensure proper encapsulation (`private` fields, `public` methods).
 *     *   Use meaningful variable and method names.
 *     *   Include appropriate comments and documentation (at least basic Javadoc for classes/methods).
 *     *   Maintain a clean code structure.
 * 
 * **Expected Interaction Examples:**
 * 
 * ```
 * Enter command (add <desc> <prio>, process, pending, completed, exit): add Buy groceries 2
 * Task added: Task{id=1, description='Buy groceries', priority=2}
 * Enter command (add <desc> <prio>, process, pending, completed, exit): add Finish report 1
 * Task added: Task{id=2, description='Finish report', priority=1}
 * Enter command (add <desc> <prio>, process, pending, completed, exit): pending
 * --- Pending Tasks ---
 * Task{id=1, description='Buy groceries', priority=2}
 * Task{id=2, description='Finish report', priority=1}
 * ---------------------
 * Enter command (add <desc> <prio>, process, pending, completed, exit): process
 * Processing task: Task{id=1, description='Buy groceries', priority=2}
 * Enter command (add <desc> <prio>, process, pending, completed, exit): pending
 * --- Pending Tasks ---
 * Task{id=2, description='Finish report', priority=1}
 * ---------------------
 * Enter command (add <desc> <prio>, process, pending, completed, exit): completed
 * --- Completed Tasks ---
 * Task{id=1, description='Buy groceries', priority=2}
 * -----------------------
 * Enter command (add <desc> <prio>, process, pending, completed, exit): add Invalid priority
 * Error: Invalid command format or priority. Use: add <description> <priority>
 * Enter command (add <desc> <prio>, process, pending, completed, exit): add Another task xyz
 * Error: Invalid priority 'xyz'. Priority must be a non-negative integer.
 * Enter command (add <desc> <prio>, process, pending, completed, exit): process
 * Processing task: Task{id=2, description='Finish report', priority=1}
 * Enter command (add <desc> <prio>, process, pending, completed, exit): process
 * Error: No pending tasks to process.
 * Enter command (add <desc> <prio>, process, pending, completed, exit): exit
 * Exiting Task Scheduler.
 * ```
 * 
 * Your solution should be a single Java file containing the `Task` and `TaskScheduler` classes, and a `main` method to start the `TaskScheduler`.
 *
 * EXPLANATION:
 * This solution implements the Task Management System as required, demonstrating the use of all specified Java components and adhering to best practices.
 * 
 * 1.  **`Task` Class:** This simple class encapsulates the data for a task (`id`, `description`, `priority`). It follows encapsulation principles with private fields and public getters. The `toString()` method provides a convenient way to print task details.
 * 
 * 2.  **`TaskScheduler` Class:** This is the core class managing the tasks.
 *     *   `taskQueue`: Declared as `Queue<Task>` and initialized with `new LinkedList<>()`. This correctly uses the `Queue` interface and its `LinkedList` implementation to manage pending tasks in FIFO order. Methods like `offer()` (for adding) and `poll()` (for removing) are used, which are standard `Queue` operations.
 *     *   `completedTasks`: Declared as `List<Task>` and initialized with `new ArrayList<>()`. This fulfills the requirement to use the `List` interface and `ArrayList` implementation for storing completed tasks. Tasks are added using the `add()` method.
 *     *   `taskIdCounter`: A simple integer counter to assign unique IDs to tasks as they are created.
 *     *   `scanner`: An instance of `Scanner` is used to read input from `System.in`. It is a class-level field to be accessible throughout the `run()` method and closed properly at the end.
 *     *   `addTask()`: Creates a new `Task` object, increments the ID counter, and adds the task to the `taskQueue`. It includes basic validation for the priority being non-negative.
 *     *   `processNextTask()`: Uses `taskQueue.poll()` to get the next task. `poll()` returns `null` if the queue is empty, which is handled by printing an error message to `System.err`. If a task is retrieved, it's added to the `completedTasks` list.
 *     *   `listPendingTasks()` and `listCompletedTasks()`: These methods iterate through the respective collections (`taskQueue` and `completedTasks`) and print the `toString()` representation of each task. They check for emptiness and print a message if the list is empty. Iterating directly over the `Queue` (using enhanced for loop) does not remove elements, which is appropriate for listing.
 *     *   `run()`: This method contains the main application loop (`while(running)`).
 *         *   It prompts the user for input using `System.out`.
 *         *   It reads the entire line of input using `scanner.nextLine()`.
 *         *   The input line is split to extract the command and arguments.
 *         *   A `switch` statement is used to determine which command was entered. This fulfills the requirement for using a `switch` statement for flow control based on user input.
 *         *   Inside the `add` case, the arguments are further parsed to separate the description and priority. This involves string manipulation (`substring`, `lastIndexOf`, `trim`) and parsing the priority string to an integer using `Integer.parseInt()`.
 *         *   `try-catch` blocks are used within the `run()` method. A specific `catch (NumberFormatException e)` handles errors when parsing the priority string. A general `catch (Exception e)` is included as a fallback for any other unexpected runtime errors within the command processing logic, printing the error message to `System.err`. This demonstrates class-wide exception handling for the main operational loop.
 *         *   Error messages for invalid commands, incorrect command format, or processing an empty queue are printed to `System.err`.
 *         *   Successful actions and lists are printed to `System.out`.
 *         *   The loop continues until the "exit" command is entered.
 *         *   The `scanner.close()` call ensures resources are released when the application exits.
 * 
 * 3.  **`main` Method:** A standard `main` method creates an instance of `TaskScheduler` and calls its `run()` method to start the application.
 * 
 * This solution effectively integrates the required Java components into a functional command-line application, demonstrating understanding of collections, control flow, I/O, and robust error handling.
 */

import java.util.Queue;
import java.util.LinkedList;
import java.util.List;
import java.util.ArrayList;
import java.util.Scanner;

/**
 * Represents a single task with an ID, description, and priority.
 */
class Task {
    private int id;
    private String description;
    private int priority;

    /**
     * Constructs a new Task.
     * @param id The unique ID for the task.
     * @param description The description of the task.
     * @param priority The priority level of the task.
     */
    public Task(int id, String description, int priority) {
        this.id = id;
        this.description = description;
        this.priority = priority;
    }

    // Getters
    public int getId() {
        return id;
    }

    public String getDescription() {
        return description;
    }

    public int getPriority() {
        return priority;
    }

    /**
     * Returns a string representation of the Task.
     * @return String representation.
     */
    @Override
    public String toString() {
        return "Task{id=" + id + ", description='" + description + "', priority=" + priority + '}';
    }
}

/**
 * Manages a queue of pending tasks and a list of completed tasks.
 */
public class TaskScheduler {
    private Queue<Task> taskQueue;
    private List<Task> completedTasks;
    private int taskIdCounter;
    private Scanner scanner;

    /**
     * Constructs a new TaskScheduler.
     */
    public TaskScheduler() {
        this.taskQueue = new LinkedList<>(); // Implements Queue
        this.completedTasks = new ArrayList<>(); // Implements List
        this.taskIdCounter = 0;
        this.scanner = new Scanner(System.in);
    }

    /**
     * Adds a new task to the pending queue.
     * @param description The task description.
     * @param priority The task priority.
     */
    public void addTask(String description, int priority) {
        if (priority < 0) {
            System.err.println("Error: Priority must be a non-negative integer.");
            return;
        }
        taskIdCounter++;
        Task newTask = new Task(taskIdCounter, description, priority);
        taskQueue.offer(newTask); // offer is preferred over add for queues as it doesn't throw exception on capacity issues
        System.out.println("Task added: " + newTask);
    }

    /**
     * Processes the next task from the pending queue.
     * Moves the task from the pending queue to the completed list.
     */
    public void processNextTask() {
        Task taskToProcess = taskQueue.poll(); // Retrieves and removes the head of the queue
        if (taskToProcess != null) {
            System.out.println("Processing task: " + taskToProcess);
            completedTasks.add(taskToProcess);
        } else {
            System.err.println("Error: No pending tasks to process.");
        }
    }

    /**
     * Lists all tasks currently in the pending queue.
     */
    public void listPendingTasks() {
        System.out.println("--- Pending Tasks ---");
        if (taskQueue.isEmpty()) {
            System.out.println("No pending tasks.");
        } else {
            // Iterating over the queue without removing elements
            for (Task task : taskQueue) {
                System.out.println(task);
            }
        }
        System.out.println("---------------------");
    }

    /**
     * Lists all tasks that have been completed.
     */
    public void listCompletedTasks() {
        System.out.println("--- Completed Tasks ---");
        if (completedTasks.isEmpty()) {
            System.out.println("No completed tasks.");
        } else {
            for (Task task : completedTasks) {
                System.out.println(task);
            }
        }
        System.out.println("-----------------------");
    }

    /**
     * Runs the main application loop, handling user input and commands.
     */
    public void run() {
        System.out.println("Task Scheduler started.");

        boolean running = true;
        while (running) {
            System.out.print("Enter command (add <desc> <prio>, process, pending, completed, exit): ");
            String commandLine = scanner.nextLine().trim();

            // Use try-catch to handle potential exceptions during input parsing or command execution
            try {
                if (commandLine.isEmpty()) {
                    continue; // Skip empty input
                }

                String[] parts = commandLine.split(" ", 2); // Split into command and arguments
                String command = parts[0].toLowerCase(); // Get the command part

                switch (command) {
                    case "add":
                        if (parts.length < 2) {
                            System.err.println("Error: Invalid command format. Use: add <description> <priority>");
                            break; // Exit switch, continue while loop
                        }
                        String args = parts[1]; // Get the rest of the line
                        int lastSpaceIndex = args.lastIndexOf(" ");
                        if (lastSpaceIndex == -1) {
                             System.err.println("Error: Invalid command format. Use: add <description> <priority>");
                             break;
                        }

                        String description = args.substring(0, lastSpaceIndex).trim();
                        String priorityStr = args.substring(lastSpaceIndex + 1).trim();

                        if (description.isEmpty() || priorityStr.isEmpty()) {
                             System.err.println("Error: Invalid command format. Use: add <description> <priority>");
                             break;
                        }

                        int priority = Integer.parseInt(priorityStr); // Potential NumberFormatException
                        addTask(description, priority);
                        break;

                    case "process":
                        processNextTask();
                        break;

                    case "pending":
                        listPendingTasks();
                        break;

                    case "completed":
                        listCompletedTasks();
                        break;

                    case "exit":
                        running = false;
                        System.out.println("Exiting Task Scheduler.");
                        break;

                    default:
                        System.err.println("Error: Unknown command '" + command + "'.");
                        break;
                }
            } catch (NumberFormatException e) {
                // Catch exception specifically for priority parsing
                System.err.println("Error: Invalid priority format. Priority must be a non-negative integer.");
            } catch (Exception e) {
                // Catch any other unexpected exceptions
                System.err.println("An unexpected error occurred: " + e.getMessage());
                // e.printStackTrace(); // Uncomment for debugging
            }
        }

        scanner.close(); // Close the scanner when done
    }

    /**
     * Main method to start the Task Scheduler application.
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        TaskScheduler scheduler = new TaskScheduler();
        scheduler.run();
    }
}
