/*
 * Exam Question #54
 * Generated on: 2025-05-11 22:06:08
 * Generated by: Account 4
 * 
 * QUESTION:
 * ## Advanced Task Management System
 * 
 * **Scenario:**
 * You are tasked with developing a simple command-line application to manage a queue of tasks for a small team. New tasks are added to the end of a pending list and processed one by one from the front. Once processed, tasks are moved to a separate list of completed tasks.
 * 
 * **Requirements:**
 * Implement a Java program that simulates this task management system. Your solution must adhere to the following:
 * 
 * 1.  **Data Structures:**
 *     *   Use `java.util.Queue` to manage the **pending tasks**. Tasks should be processed in a First-In, First-Out (FIFO) manner.
 *     *   Use `java.util.List` (specifically instantiated as `java.util.ArrayList`) to store the **completed tasks**.
 * 
 * 2.  **Classes:**
 *     *   Create a `Task` class representing a single task. It should have a description and a status (pending/completed). Use private fields and public getter methods (encapsulation). Include input validation for the task description (cannot be empty or null).
 *     *   Create a `TaskManager` class that encapsulates the `Queue` and `List` and provides methods for task operations (add, process, list pending, list completed).
 *     *   Create a main application class (e.g., `TaskManagerApp`) that handles user interaction.
 * 
 * 3.  **User Interaction:**
 *     *   Use `java.util.Scanner` to read user commands from the console (`System.in`).
 *     *   Implement a command-line interface with the following commands:
 *         *   `add`: Prompts the user for a task description and adds a new task to the pending queue.
 *         *   `process`: Takes the next task from the pending queue, marks it as completed, and moves it to the completed list. If the pending queue is empty, inform the user.
 *         *   `list_pending`: Displays all tasks currently in the pending queue, in order.
 *         *   `list_completed`: Displays all tasks in the completed list.
 *         *   `exit`: Terminates the application.
 *     *   Use a `switch` statement to handle the different user commands.
 * 
 * 4.  **Output and Error Handling:**
 *     *   Use `System.out` for normal program output (welcome messages, confirmations, task lists).
 *     *   Use `System.err` to display error messages (e.g., invalid command, error adding task due to empty description).
 *     *   Implement class-wide exception handling using `try-catch` blocks. Wrap the main application loop or critical sections to catch potential unexpected errors and display an informative message using `System.err` before potentially exiting or continuing. Handle specific errors like invalid input where appropriate (e.g., in `Task` constructor).
 * 
 * 5.  **Best Practices:**
 *     *   Use meaningful variable and method names.
 *     *   Add comments and basic documentation explaining the purpose of classes and methods.
 *     *   Ensure proper resource management (e.g., closing the `Scanner`).
 * 
 * **Expected Output Structure:**
 * 
 * ```
 * Task Management System
 * Enter command: add, process, list_pending, list_completed, exit
 * > add
 * Enter task description: Write exam question
 * Task added: "Write exam question"
 * > add
 * Enter task description: Grade exams
 * Task added: "Grade exams"
 * > list_pending
 * 
 * --- Pending Tasks ---
 * 1. [ ] Write exam question
 * 2. [ ] Grade exams
 * ---------------------
 * > process
 * Task processed: "Write exam question"
 * > list_completed
 * 
 * --- Completed Tasks ---
 * 1. [X] Write exam question
 * -----------------------
 * > process
 * Task processed: "Grade exams"
 * > process
 * No pending tasks to process.
 * > invalid_command
 * Invalid command. Please use add, process, list_pending, list_completed, or exit.
 * > add
 * Enter task description:
 * Error adding task: Task description cannot be empty.
 * > exit
 * Exiting Task Management System. Goodbye!
 * Scanner closed.
 * ```
 * 
 * Your solution should be a single Java file containing the `Task`, `TaskManager`, and `TaskManagerApp` (or similar) classes.
 * 
 * ```java
 * // Your code goes here
 * ```
 * 
 * **Evaluation Criteria:**
 * *   Correct usage of `Queue`, `List`, `ArrayList`, `Scanner`, `switch`.
 * *   Effective use of `System.out` and `System.err`.
 * *   Implementation of `try-catch` for exception handling as specified.
 * *   Adherence to best practices (encapsulation, naming, comments, input validation, resource management).
 * *   Correct implementation of task management logic (add, process, list).
 * *   Robustness in handling invalid input and empty states.
 *
 * EXPLANATION:
 * The solution implements a simple task management system using several core Java concepts as required.
 * 
 * 1.  **Class Structure:** The problem is broken down into three classes:
 *     *   `Task`: Represents a single task object. It encapsulates the `description` and `isCompleted` status using private fields and provides public getter methods. The constructor includes input validation to ensure the description is not null or empty, throwing an `IllegalArgumentException` if validation fails. The `markCompleted` method changes the task's status. The `toString` method provides a user-friendly representation.
 *     *   `TaskManager`: Manages the collections of tasks. It holds a `Queue<Task>` named `pendingTasks` (implemented using `LinkedList` for FIFO behavior) and a `List<Task>` named `completedTasks` (implemented using `ArrayList`). It provides methods (`addTask`, `processNextTask`, `listPendingTasks`, `listCompletedTasks`) that operate on these collections, abstracting the underlying data structures from the main application logic.
 *     *   `TaskManagerApp`: Contains the `main` method and the primary application loop. It initializes the `TaskManager` and `Scanner`, reads user commands, and delegates the actual task operations to the `TaskManager`.
 * 
 * 2.  **Data Structure Usage:**
 *     *   `Queue`: `pendingTasks` is declared as `Queue<Task>` and instantiated as `LinkedList<Task>`. This correctly models the requirement for tasks to be processed in the order they are added (FIFO). Methods like `offer()` (for adding) and `poll()` (for retrieving and removing the head) are used, which are standard Queue operations designed to handle potential capacity constraints gracefully (though `LinkedList` is unbounded).
 *     *   `List` and `ArrayList`: `completedTasks` is declared as `List<Task>` and instantiated as `ArrayList<Task>`. `ArrayList` is a suitable choice for storing completed tasks as it provides dynamic resizing and efficient element access/addition, which is appropriate for a historical list where order of completion might matter, but not strict FIFO removal. The `add()` method is used to add completed tasks. Iteration is used to list the elements in both the Queue and the List.
 * 
 * 3.  **User Interaction:**
 *     *   `Scanner`: An instance of `Scanner` is used in the `TaskManagerApp`'s `run` method to read input from `System.in`. It reads entire lines (`nextLine()`) to capture commands and task descriptions, including potential spaces in descriptions.
 *     *   `switch`: A `switch` statement in the `run` method efficiently handles the different command strings entered by the user (`add`, `process`, `list_pending`, `list_completed`, `exit`, and the `default` case for invalid commands). Command input is trimmed and converted to lowercase for case-insensitive matching.
 * 
 * 4.  **Output and Error Handling:**
 *     *   `System.out`: Used for standard output like the welcome message, confirmations when tasks are added or processed, and formatted lists of tasks.
 *     *   `System.err`: Used specifically for error messages, such as reporting an invalid command entered by the user or displaying the error message when a task cannot be created due to an empty description (caught from the `Task` constructor).
 *     *   `try-catch`:
 *         *   A specific `try-catch(IllegalArgumentException e)` block is used within `TaskManager.addTask` to catch the validation error from the `Task` constructor and report it gracefully using `System.err`.
 *         *   A broader `try-catch(Exception e)` block wraps the main `while` loop in `TaskManagerApp.run`. This demonstrates class-wide exception handling by catching any unexpected runtime exception that might occur during the command processing loop, printing a generic error message to `System.err`, and allowing the program to potentially terminate or continue in a more controlled manner than crashing.
 *         *   A `finally` block is used after the main `try-catch` in `run` to ensure that the `Scanner` resource is closed properly, preventing resource leaks, regardless of whether the loop finishes normally or an exception is caught.
 * 
 * 5.  **Best Practices:**
 *     *   **Encapsulation:** Private fields and public methods are used in `Task` and `TaskManager` to control access to data.
 *     *   **Meaningful Names:** Variables (`pendingTasks`, `completedTasks`, `taskToProcess`), methods (`addTask`, `processNextTask`, `listPendingTasks`), and classes (`Task`, `TaskManager`, `TaskManagerApp`) have names that clearly indicate their purpose.
 *     *   **Comments:** Basic comments are included to explain the purpose of classes, methods, and key sections of code (like the `try-catch` blocks, `switch` cases, and data structure choices).
 *     *   **Input Validation:** The `Task` constructor explicitly validates the input description.
 *     *   **Resource Management:** The `Scanner` is closed in a `finally` block to release the underlying system resource.
 * 
 * This solution effectively integrates all required components and demonstrates key object-oriented and error-handling principles in Java within a practical, albeit simplified, application context.
 */

import java.util.Queue;
import java.util.LinkedList; // A common implementation of Queue
import java.util.List;
import java.util.ArrayList; // A common implementation of List
import java.util.Scanner;
import java.util.InputMismatchException; // Example of a specific exception type

// Task class: Represents a single task with description and status.
class Task {
    private String description;
    private boolean isCompleted;

    /**
     * Constructs a new Task.
     * @param description The description of the task.
     * @throws IllegalArgumentException if the description is null or empty.
     */
    public Task(String description) {
        // Input validation: description must not be null or empty/whitespace
        if (description == null || description.trim().isEmpty()) {
            throw new IllegalArgumentException("Task description cannot be empty.");
        }
        this.description = description.trim(); // Trim whitespace
        this.isCompleted = false; // New tasks are initially pending
    }

    // Getter for description
    public String getDescription() {
        return description;
    }

    // Getter for completion status
    public boolean isCompleted() {
        return isCompleted;
    }

    /**
     * Marks the task as completed.
     */
    public void markCompleted() {
        this.isCompleted = true;
    }

    /**
     * Provides a string representation of the task, indicating its status.
     * @return String formatted as "[X] description" if completed, "[ ] description" if pending.
     */
    @Override
    public String toString() {
        return "[" + (isCompleted ? "X" : " ") + "] " + description;
    }
}

// TaskManager class: Manages the collection of pending and completed tasks using Queue and List.
class TaskManager {
    // Use Queue for pending tasks to ensure FIFO processing order
    private Queue<Task> pendingTasks;
    // Use List (instantiated as ArrayList) for completed tasks
    private List<Task> completedTasks;

    /**
     * Constructs a new TaskManager, initializing the task collections.
     */
    public TaskManager() {
        // LinkedList is a common implementation for Queue interface, providing FIFO behavior
        this.pendingTasks = new LinkedList<>();
        // ArrayList is a common implementation for List interface, good for storing completed items
        this.completedTasks = new ArrayList<>();
    }

    /**
     * Adds a new task to the pending queue.
     * It handles validation errors thrown by the Task constructor.
     * @param description The description of the task.
     */
    public void addTask(String description) {
        try {
            Task newTask = new Task(description);
            // offer() is the preferred method for adding to a queue; it returns false on failure
            // (though LinkedList doesn't have capacity limits like some other queues, offer is good practice)
            pendingTasks.offer(newTask);
            System.out.println("Task added: \"" + description + "\"");
        } catch (IllegalArgumentException e) {
            // Use System.err to report validation errors from Task constructor
            System.err.println("Error adding task: " + e.getMessage());
        }
    }

    /**
     * Processes the next task in the pending queue.
     * Removes the task from the queue, marks it as completed, and adds it to the completed list.
     * Handles the scenario where there are no pending tasks.
     */
    public void processNextTask() {
        // poll() retrieves and removes the head of the queue, returning null if the queue is empty
        Task taskToProcess = pendingTasks.poll();

        if (taskToProcess != null) {
            taskToProcess.markCompleted();
            completedTasks.add(taskToProcess); // Add to the list of completed tasks
            System.out.println("Task processed: \"" + taskToProcess.getDescription() + "\"");
        } else {
            // Use System.out for informational messages when no tasks are available
            System.out.println("No pending tasks to process.");
        }
    }

    /**
     * Lists all tasks currently in the pending queue, in processing order.
     */
    public void listPendingTasks() {
        System.out.println("\n--- Pending Tasks ---");
        if (pendingTasks.isEmpty()) {
            System.out.println("No pending tasks.");
        } else {
            // Iterate through the queue elements without removing them
            int index = 1;
            for (Task task : pendingTasks) {
                System.out.println(index++ + ". " + task);
            }
        }
        System.out.println("---------------------");
    }

    /**
     * Lists all tasks that have been marked as completed.
     */
    public void listCompletedTasks() {
        System.out.println("\n--- Completed Tasks ---");
        if (completedTasks.isEmpty()) {
            System.out.println("No completed tasks.");
        } else {
            int index = 1;
            // Iterate through the completed tasks list
            for (Task task : completedTasks) {
                System.out.println(index++ + ". " + task);
            }
        }
        System.out.println("-----------------------");
    }
}

// Main application class: Handles user input and application flow.
public class TaskManagerApp { // This class contains the main method and application loop

    private TaskManager taskManager;
    private Scanner scanner;

    /**
     * Constructs the TaskManagerApp, initializing the TaskManager and Scanner for input.
     */
    public TaskManagerApp() {
        taskManager = new TaskManager();
        scanner = new Scanner(System.in);
    }

    /**
     * Runs the main application loop, continuously reading and processing user commands.
     * Includes a class-wide try-catch block to handle unexpected exceptions during execution.
     */
    public void run() {
        System.out.println("Task Management System");
        System.out.println("Enter command: add, process, list_pending, list_completed, exit");

        boolean running = true;
        // Class-wide exception handling: Wrap the core application loop
        try {
            while (running) {
                System.out.print("> ");
                // Read the user's command, trim whitespace, and convert to lowercase for case-insensitive matching
                String command = scanner.nextLine().trim().toLowerCase();

                // Use a switch statement to execute actions based on the command
                switch (command) {
                    case "add":
                        System.out.print("Enter task description: ");
                        String description = scanner.nextLine();
                        // Delegate adding task to TaskManager, which handles validation errors with System.err
                        taskManager.addTask(description);
                        break;
                    case "process":
                        taskManager.processNextTask();
                        break;
                    case "list_pending":
                        taskManager.listPendingTasks();
                        break;
                    case "list_completed":
                        taskManager.listCompletedTasks();
                        break;
                    case "exit":
                        running = false; // Set flag to exit the loop
                        System.out.println("Exiting Task Management System. Goodbye!");
                        break;
                    default:
                        // Use System.err for invalid or unrecognized commands
                        System.err.println("Invalid command. Please use add, process, list_pending, list_completed, or exit.");
                }
            }
        } catch (Exception e) {
            // Catch any unexpected exceptions that occur within the try block
            System.err.println("An unexpected error occurred during application execution: " + e.getMessage());
            // In a real application, you might log the exception or print a stack trace for debugging:
            // e.printStackTrace();
        } finally {
            // The finally block ensures this code runs regardless of whether an exception occurred or not
            // It's crucial for resource cleanup, like closing the Scanner
            if (scanner != null) {
                scanner.close();
            }
            System.out.println("Scanner closed."); // Confirm resource cleanup
        }
    }

    /**
     * The entry point of the application.
     * @param args Command line arguments (not used in this application).
     */
    public static void main(String[] args) {
        // Create an instance of the application and run it
        TaskManagerApp app = new TaskManagerApp();
        app.run();
    }
}
