/*
 * Exam Question #869
 * Generated on: 2025-05-12 16:52:53
 * Generated by: Account 4
 * 
 * QUESTION:
 * **Java Programming Exam Task: Print Queue Manager**
 * 
 * You are tasked with developing a simplified Print Queue Manager system in Java. This system should allow users to add print jobs to a queue, process the next job in the queue, and view the status of all jobs.
 * 
 * Your solution must demonstrate a strong understanding of fundamental and intermediate Java concepts, including data structures, object-oriented programming, user input handling, control flow, and exception handling.
 * 
 * **Requirements:**
 * 
 * 1.  **PrintJob Class:**
 *     *   Create a class named `PrintJob` to represent a single print request.
 *     *   It should have private fields for `jobId` (an integer, uniquely assigned), `documentName` (String), `pages` (integer), and `status` (String, e.g., "QUEUED", "PROCESSING", "COMPLETED").
 *     *   Implement a constructor to initialize `jobId`, `documentName`, and `pages`. The initial `status` should be "QUEUED".
 *     *   Provide public getter methods for all fields.
 *     *   Provide a public setter method `setStatus(String status)` to update the job's status.
 *     *   Override the `toString()` method to provide a concise string representation of the job (including ID, name, pages, and status).
 * 
 * 2.  **PrintQueueManager Class:**
 *     *   Create a class named `PrintQueueManager` that will manage the print jobs.
 *     *   It should have a private field `printQueue` of type `java.util.Queue<PrintJob>` to hold jobs waiting to be processed.
 *     *   It should have a private field `allJobs` of type `java.util.List<PrintJob>` (using `java.util.ArrayList` as the concrete implementation) to keep a record of all submitted jobs, regardless of their current status.
 *     *   Include a private integer field `nextJobId` initialized to 1, used to assign unique IDs to new jobs.
 *     *   Include a private field `scanner` of type `java.util.Scanner` for reading user input.
 *     *   Implement a public method `start()` which contains the main application loop.
 *     *   Inside `start()`, display a menu of options to the user:
 *         *   1. Add New Print Job
 *         *   2. Process Next Job
 *         *   3. View Print Queue
 *         *   4. View All Jobs
 *         *   5. Exit
 *     *   Use a `switch` statement within the main loop to handle the user's choice.
 *     *   Implement private methods for each menu option (`addNewJob`, `processNextJob`, `viewPrintQueue`, `viewAllJobs`).
 *     *   The `main` method should create an instance of `PrintQueueManager` and call its `start()` method.
 * 
 * 3.  **Functionality Implementation:**
 *     *   `addNewJob`:
 *         *   Prompt the user for the document name and number of pages.
 *         *   Validate that the number of pages is a positive integer. Handle non-integer input or non-positive values using `try-catch` and `System.err`.
 *         *   Create a new `PrintJob` object using the `nextJobId`, provided details, and "QUEUED" status.
 *         *   Add the new job to both the `printQueue` and the `allJobs` list.
 *         *   Increment `nextJobId`.
 *         *   Print a confirmation message using `System.out`.
 *     *   `processNextJob`:
 *         *   Attempt to retrieve and remove the next job from the `printQueue`.
 *         *   If the queue is empty, print an error message using `System.err`.
 *         *   If a job is retrieved:
 *             *   Simulate processing by printing a message using `System.out` indicating which job is being processed.
 *             *   Update the status of this job to "COMPLETED". You must find this specific job object within the `allJobs` list and update its status there.
 *             *   Print a confirmation message using `System.out`.
 *     *   `viewPrintQueue`:
 *         *   Print the current contents of the `printQueue`. If the queue is empty, print a message indicating so using `System.out`.
 *         *   Iterate through the queue and print each job's `toString()` representation. *Hint: Be careful not to remove elements while viewing.*
 *     *   `viewAllJobs`:
 *         *   Print the current contents of the `allJobs` list. If the list is empty, print a message indicating so using `System.out`.
 *         *   Iterate through the list and print each job's `toString()` representation.
 * 
 * 4.  **Exception Handling:**
 *     *   Implement `try-catch` blocks for potential exceptions, particularly around user input parsing (`Scanner`) and operations that might fail (e.g., attempting to process an empty queue, although `poll()` is safe, other operations might not be).
 *     *   Include a general `try-catch(Exception e)` block around the main application loop in the `start()` method to catch any unhandled exceptions during execution, printing an error message using `System.err` and potentially continuing the loop or exiting gracefully.
 * 
 * 5.  **Best Practices:**
 *     *   Use meaningful variable and method names.
 *     *   Apply proper encapsulation (private fields, public methods).
 *     *   Include comments where necessary to explain complex logic.
 *     *   Ensure proper input validation.
 *     *   Use `System.out` for normal output and `System.err` for error messages.
 *     *   Close the `Scanner` when the application exits.
 * 
 * **Expected Output:**
 * 
 * The program should present a menu, accept user input, perform the requested actions, and display appropriate output or error messages based on the operations.
 * 
 * Example interaction flow:
 * 
 * ```
 * Print Queue Manager Menu:
 * 1. Add New Print Job
 * 2. Process Next Job
 * 3. View Print Queue
 * 4. View All Jobs
 * 5. Exit
 * Enter choice: 1
 * Enter document name: documentA
 * Enter number of pages: 10
 * Job 1 (documentA, 10 pages) added to queue.
 * 
 * Print Queue Manager Menu:
 * 1. Add New Print Job
 * 2. Process Next Job
 * 3. View Print Queue
 * 4. View All Jobs
 * 5. Exit
 * Enter choice: 1
 * Enter document name: reportB
 * Enter number of pages: 5
 * Job 2 (reportB, 5 pages) added to queue.
 * 
 * Print Queue Manager Menu:
 * 1. Add New Print Job
 * 2. Process Next Job
 * 3. View Print Queue
 * 4. View All Jobs
 * 5. Exit
 * Enter choice: 3
 * --- Print Queue ---
 * [Job #1, documentA, 10 pages, Status: QUEUED]
 * [Job #2, reportB, 5 pages, Status: QUEUED]
 * -------------------
 * 
 * Print Queue Manager Menu:
 * 1. Add New Print Job
 * 2. Process Next Job
 * 3. View Print Queue
 * 4. View All Jobs
 * 5. Exit
 * Enter choice: 2
 * Processing job: [Job #1, documentA, 10 pages, Status: QUEUED]
 * Job 1 processed and status updated.
 * 
 * Print Queue Manager Menu:
 * 1. Add New Print Job
 * 2. Process Next Job
 * 3. View Print Queue
 * 4. View All Jobs
 * 5. Exit
 * Enter choice: 3
 * --- Print Queue ---
 * [Job #2, reportB, 5 pages, Status: QUEUED]
 * -------------------
 * 
 * Print Queue Manager Menu:
 * 1. Add New Print Job
 * 2. Process Next Job
 * 3. View Print Queue
 * 4. View All Jobs
 * 5. Exit
 * Enter choice: 4
 * --- All Jobs ---
 * [Job #1, documentA, 10 pages, Status: COMPLETED]
 * [Job #2, reportB, 5 pages, Status: QUEUED]
 * ----------------
 * 
 * Print Queue Manager Menu:
 * 1. Add New Print Job
 * 2. Process Next Job
 * 3. View Print Queue
 * 4. View All Jobs
 * 5. Exit
 * Enter choice: invalid
 * Invalid choice. Please enter a number between 1 and 5.
 * 
 * Print Queue Manager Menu:
 * ... (user continues)
 * Enter choice: 5
 * Exiting Print Queue Manager.
 * ```
 * 
 * Your solution should be a single Java file containing both classes.
 *
 * EXPLANATION:
 * This solution implements a `PrintQueueManager` system demonstrating the required Java concepts.
 * 
 * 1.  **`PrintJob` Class:** This class serves as a simple Plain Old Java Object (POJO) representing a print request. It encapsulates the data related to a job (`jobId`, `documentName`, `pages`, `status`) with private fields and public getters/setters, adhering to encapsulation principles. The `toString()` method provides a convenient way to display job information.
 * 
 * 2.  **`PrintQueueManager` Class:** This is the core class that orchestrates the system.
 *     *   It uses a `java.util.Queue<PrintJob>` (`printQueue`) implemented by `java.util.LinkedList`. The `Queue` is ideal for managing jobs in a First-In, First-Out (FIFO) order, which is typical for a print queue.
 *     *   It uses a `java.util.List<PrintJob>` (`allJobs`) implemented by `java.util.ArrayList`. This list maintains a complete history of all submitted jobs, allowing viewing regardless of their current status in the queue. Using the `List` interface type promotes good practice, even though `ArrayList` is the concrete implementation.
 *     *   A `Scanner` (`scanner`) is used to get input from `System.in`.
 *     *   The `start()` method contains the main application loop, presenting a menu and processing user choices.
 *     *   The `displayMenu()`, `addNewJob()`, `processNextJob()`, `viewPrintQueue()`, and `viewAllJobs()` methods break down the functionality into logical units, improving code organization.
 * 
 * 3.  **Functionality:**
 *     *   **`addNewJob()`:** Reads document name and pages, validates pages using a `try-catch` for `InputMismatchException` and a check for positive value. It creates a new `PrintJob`, adds it to both the `printQueue` (using `offer()`) and the `allJobs` list (using `add()`), and increments the job ID counter.
 *     *   **`processNextJob()`:** Uses `printQueue.poll()` to safely retrieve and remove the next job. `poll()` returns `null` if the queue is empty, which is handled with a `System.err` message. If a job is retrieved, it simulates processing and then iterates through the `allJobs` list to find the corresponding job by ID and update its status to "COMPLETED".
 *     *   **`viewPrintQueue()`:** Iterates through the `printQueue` using a for-each loop. This allows viewing the queue's contents without removing elements. It prints each job's `toString()` representation.
 *     *   **`viewAllJobs()`:** Iterates through the `allJobs` list using a for-each loop, printing the details and status of every job ever submitted.
 * 
 * 4.  **Required Components Usage:**
 *     *   `Queue` (`printQueue`)
 *     *   `ArrayList` (`allJobs` is an `ArrayList`)
 *     *   `List` (`allJobs` is declared as `List`)
 *     *   `Scanner` (`scanner` initialized with `System.in`)
 *     *   `switch` statement (in `start()` for menu handling)
 *     *   `System.err` (for error messages like invalid input, empty queue/list, unexpected errors)
 *     *   `System.out` (for menu, prompts, success messages, list/queue output)
 *     *   `try-catch` (around `Scanner` input reading in `start()` and `addNewJob()`, and a general `try-catch(Exception)` around the `switch` block in `start()` to demonstrate class-wide handling of potential operational errors).
 * 
 * 5.  **Best Practices:**
 *     *   **Encapsulation:** `PrintJob` fields are private, accessed via public methods.
 *     *   **Naming:** Variable and method names are descriptive (e.g., `printQueue`, `addNewJob`, `documentName`).
 *     *   **Comments:** Javadoc comments explain the purpose of classes and methods. Inline comments clarify specific logic.
 *     *   **Input Validation:** Checks for positive pages and handles non-integer input for pages and menu choice.
 *     *   **Error Handling:** Specific `InputMismatchException` is caught for input errors. A general `Exception` is caught around the main operation logic. Error messages are directed to `System.err`.
 *     *   **Clean Code:** Functionality is divided into small, focused methods. The main loop is kept relatively clean.
 * 
 * This solution effectively integrates all required components within a practical scenario, demonstrating key Java programming skills expected at an intermediate to advanced level.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.InputMismatchException;

/**
 * Represents a print job with ID, document name, pages, and status.
 */
class PrintJob {
    private int jobId;
    private String documentName;
    private int pages;
    private String status; // e.g., "QUEUED", "PROCESSING", "COMPLETED"

    /**
     * Constructs a new PrintJob.
     *
     * @param jobId The unique ID for the job.
     * @param documentName The name of the document.
     * @param pages The number of pages to print.
     */
    public PrintJob(int jobId, String documentName, int pages) {
        this.jobId = jobId;
        this.documentName = documentName;
        this.pages = pages;
        this.status = "QUEUED"; // Initial status
    }

    // Getters
    public int getJobId() {
        return jobId;
    }

    public String getDocumentName() {
        return documentName;
    }

    public int getPages() {
        return pages;
    }

    public String getStatus() {
        return status;
    }

    /**
     * Sets the status of the print job.
     *
     * @param status The new status (e.g., "QUEUED", "PROCESSING", "COMPLETED").
     */
    public void setStatus(String status) {
        this.status = status;
    }

    /**
     * Provides a string representation of the PrintJob.
     *
     * @return A formatted string describing the job.
     */
    @Override
    public String toString() {
        return "[Job #" + jobId + ", " + documentName + ", " + pages + " pages, Status: " + status + "]";
    }
}

/**
 * Manages the print queue and a list of all submitted print jobs.
 */
public class PrintQueueManager {
    private Queue<PrintJob> printQueue = new LinkedList<>(); // Use LinkedList as a Queue implementation
    private List<PrintJob> allJobs = new ArrayList<>(); // Use ArrayList as a List implementation
    private int nextJobId = 1;
    private Scanner scanner; // Declare scanner here, initialize in start()

    /**
     * Starts the Print Queue Manager application loop.
     */
    public void start() {
        scanner = new Scanner(System.in); // Initialize scanner
        System.out.println("Welcome to the Print Queue Manager!");

        while (true) {
            displayMenu();
            int choice = -1; // Default invalid choice

            try {
                System.out.print("Enter choice: ");
                choice = scanner.nextInt();
                // Consume the newline character left by nextInt()
                scanner.nextLine();

                // Class-wide exception handling for operations within the switch
                try {
                    switch (choice) {
                        case 1:
                            addNewJob();
                            break;
                        case 2:
                            processNextJob();
                            break;
                        case 3:
                            viewPrintQueue();
                            break;
                        case 4:
                            viewAllJobs();
                            break;
                        case 5:
                            System.out.println("Exiting Print Queue Manager.");
                            return; // Exit the start method, ending the program
                        default:
                            System.err.println("Invalid choice. Please enter a number between 1 and 5.");
                    }
                } catch (Exception e) {
                    // Catch any unexpected exceptions during an operation
                    System.err.println("An unexpected error occurred during the operation: " + e.getMessage());
                    // e.printStackTrace(); // Uncomment for detailed debugging
                }

            } catch (InputMismatchException e) {
                System.err.println("Invalid input. Please enter a number for the menu choice.");
                scanner.nextLine(); // Consume the invalid input
            } catch (Exception e) {
                // General catch for exceptions not handled elsewhere in the loop
                System.err.println("An unexpected error occurred in the main loop: " + e.getMessage());
                // e.printStackTrace(); // Uncomment for detailed debugging
            }
            System.out.println(); // Add a newline for better readability between iterations
        }
        // scanner.close(); // Closing scanner here is unreachable if exiting via return
        // It's better to close in a finally block or after the loop if it could be reached
        // For this simple example exiting with return is acceptable, but in larger apps, manage resources carefully.
    }

    /**
     * Displays the main menu options.
     */
    private void displayMenu() {
        System.out.println("Print Queue Manager Menu:");
        System.out.println("1. Add New Print Job");
        System.out.println("2. Process Next Job");
        System.out.println("3. View Print Queue");
        System.out.println("4. View All Jobs");
        System.out.println("5. Exit");
    }

    /**
     * Adds a new print job based on user input.
     */
    private void addNewJob() {
        System.out.print("Enter document name: ");
        String documentName = scanner.nextLine();

        int pages = -1; // Default invalid pages
        boolean validInput = false;
        while (!validInput) {
            System.out.print("Enter number of pages: ");
            try {
                pages = scanner.nextInt();
                // Consume the newline character
                scanner.nextLine();
                if (pages > 0) {
                    validInput = true;
                } else {
                    System.err.println("Number of pages must be positive.");
                }
            } catch (InputMismatchException e) {
                System.err.println("Invalid input. Please enter a valid number for pages.");
                scanner.nextLine(); // Consume the invalid input
            }
        }

        PrintJob newJob = new PrintJob(nextJobId, documentName, pages);
        printQueue.offer(newJob); // Add to the end of the queue
        allJobs.add(newJob); // Add to the list of all jobs
        System.out.println("Job " + nextJobId + " (" + documentName + ", " + pages + " pages) added to queue.");
        nextJobId++; // Increment for the next job
    }

    /**
     * Processes the next job in the print queue.
     */
    private void processNextJob() {
        // poll() retrieves and removes the head of the queue, returns null if queue is empty
        PrintJob jobToProcess = printQueue.poll();

        if (jobToProcess == null) {
            System.err.println("Print queue is empty. No jobs to process.");
        } else {
            System.out.println("Processing job: " + jobToProcess);

            // Find the job in the allJobs list and update its status
            // We can find it by its unique jobId
            for (PrintJob job : allJobs) {
                if (job.getJobId() == jobToProcess.getJobId()) {
                    job.setStatus("COMPLETED");
                    break; // Found the job, no need to continue searching
                }
            }
            System.out.println("Job " + jobToProcess.getJobId() + " processed and status updated.");
        }
    }

    /**
     * Displays the jobs currently in the print queue.
     */
    private void viewPrintQueue() {
        System.out.println("--- Print Queue ---");
        if (printQueue.isEmpty()) {
            System.out.println("The print queue is empty.");
        } else {
            // Iterate through the queue without removing elements
            // The iterator() method or a for-each loop on the Queue works correctly.
            for (PrintJob job : printQueue) {
                System.out.println(job);
            }
        }
        System.out.println("-------------------");
    }

    /**
     * Displays all jobs ever submitted, including their status.
     */
    private void viewAllJobs() {
        System.out.println("--- All Jobs ---");
        if (allJobs.isEmpty()) {
            System.out.println("No jobs have been submitted yet.");
        } else {
            for (PrintJob job : allJobs) {
                System.out.println(job);
            }
        }
        System.out.println("----------------");
    }

    /**
     * Main method to start the application.
     *
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        PrintQueueManager manager = new PrintQueueManager();
        manager.start();
        // It's good practice to close the scanner when the program finishes.
        // Since start() exits with return, we can't reliably close it after start().
        // For this exam, we'll assume System.in will be closed when the process terminates.
        // In a more complex app, resources like Scanner should be managed carefully, perhaps in a try-with-resources if scope allows,
        // or explicitly closed in a shutdown hook or finally block if exiting differently.
        if (manager.scanner != null) {
             manager.scanner.close(); // Attempt to close if initialized
        }
    }
}
