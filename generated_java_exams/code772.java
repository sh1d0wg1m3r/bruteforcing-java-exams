/*
 * Exam Question #772
 * Generated on: 2025-05-12 16:38:36
 * Generated by: Account 3
 * 
 * QUESTION:
 * ## Advanced Java Programming Exam: Deployment Task Manager
 * 
 * **Problem Description:**
 * 
 * You are tasked with developing a simple command-line application to manage a queue of software deployment tasks. The system should allow users to add new tasks, view tasks waiting for deployment, process the next task in the queue, view completed tasks, and exit.
 * 
 * This problem requires you to demonstrate your understanding of core Java collections, input handling, control flow, and exception handling.
 * 
 * **Requirements:**
 * 
 * 1.  **Task Representation:** Create a class `DeploymentTask` to represent a single task. It should have:
 *     *   A unique integer `id`.
 *     *   A `String` `description`.
 *     *   Appropriate private fields, a constructor, and public getter methods.
 *     *   Override the `toString()` method for easy printing (e.g., "Task ID: [id], Description: [description]").
 * 
 * 2.  **Task Management System:** Create a class `DeploymentManager` that handles the task lifecycle. It must contain:
 *     *   A `java.util.Queue<DeploymentTask>` to hold tasks waiting for deployment (pending tasks). Use a suitable implementation like `java.util.LinkedList`.
 *     *   A `java.util.List<DeploymentTask>` to hold tasks that have been successfully processed (completed tasks). Use `java.util.ArrayList` as the implementation. Declare the variable using the `List` interface type.
 *     *   A `java.util.Scanner` for reading user input from the console.
 *     *   A method `addTask()`: Prompts the user for task ID and description, creates a `DeploymentTask`, and adds it to the pending queue. Include input validation (e.g., check for positive ID, non-empty description).
 *     *   A method `viewPendingTasks()`: Displays all tasks currently in the pending queue without removing them. If the queue is empty, print an appropriate message.
 *     *   A method `processNextTask()`: Removes the next task from the pending queue (FIFO order), adds it to the completed tasks list, and prints a confirmation message. If the pending queue is empty, print an error message to `System.err`.
 *     *   A method `viewCompletedTasks()`: Displays all tasks in the completed tasks list. If the list is empty, print an appropriate message.
 *     *   A method `runMenu()`: Implements the main application loop. It should repeatedly display a menu of options (Add Task, View Pending, Process Next, View Completed, Exit), read the user's choice, and use a `switch` statement to call the appropriate method. The loop should continue until the user chooses to exit.
 * 
 * 3.  **Input/Output and Control Flow:**
 *     *   Use `System.out.println()` for displaying the menu, task details, success messages, and informational messages.
 *     *   Use `System.err.println()` for displaying error messages (e.g., invalid menu choice, attempting to process from an empty queue, input validation errors).
 *     *   Use a `switch` statement in `runMenu()` to handle the different menu options.
 *     *   Use `java.util.Scanner` for all user input.
 * 
 * 4.  **Exception Handling:**
 *     *   Implement class-wide or method-level `try-catch` blocks to handle potential exceptions, particularly `java.util.InputMismatchException` when reading integer input and any other unexpected runtime errors. Print error details to `System.err`.
 * 
 * 5.  **Best Practices:**
 *     *   Follow proper encapsulation (private fields, public methods).
 *     *   Use meaningful variable and method names.
 *     *   Include comments where necessary to explain complex logic.
 *     *   Perform input validation as specified.
 *     *   Ensure proper error handling and reporting using `System.err`.
 * 
 * **Menu Options:**
 * 
 * 1.  Add New Task
 * 2.  View Pending Tasks
 * 3.  Process Next Task
 * 4.  View Completed Tasks
 * 5.  Exit
 * 
 * **Expected Interaction Example:**
 * 
 * ```
 * --- Deployment Task Manager ---
 * 1. Add New Task
 * 2. View Pending Tasks
 * 3. Process Next Task
 * 4. View Completed Tasks
 * 5. Exit
 * Enter your choice: 1
 * Enter Task ID: 101
 * Enter Task Description: Deploy frontend v1.0
 * Task 101 added to the pending queue.
 * 
 * --- Deployment Task Manager ---
 * 1. Add New Task
 * 2. View Pending Tasks
 * 3. Process Next Task
 * 4. View Completed Tasks
 * 5. Exit
 * Enter your choice: 1
 * Enter Task ID: 102
 * Enter Task Description: Deploy backend API fix
 * Task 102 added to the pending queue.
 * 
 * --- Deployment Task Manager ---
 * 1. Add New Task
 * 2. View Pending Tasks
 * 3. Process Next Task
 * 4. View Completed Tasks
 * 5. Exit
 * Enter your choice: 2
 * --- Pending Tasks ---
 * Task ID: 101, Description: Deploy frontend v1.0
 * Task ID: 102, Description: Deploy backend API fix
 * 
 * --- Deployment Task Manager ---
 * 1. Add New Task
 * 2. View Pending Tasks
 * 3. Process Next Task
 * 4. View Completed Tasks
 * 5. Exit
 * Enter your choice: 3
 * Processing Task ID: 101, Description: Deploy frontend v1.0
 * Task processed successfully.
 * 
 * --- Deployment Task Manager ---
 * 1. Add New Task
 * 2. View Pending Tasks
 * 3. Process Next Task
 * 4. View Completed Tasks
 * 5. Exit
 * Enter your choice: 3
 * Processing Task ID: 102, Description: Deploy backend API fix
 * Task processed successfully.
 * 
 * --- Deployment Task Manager ---
 * 1. Add New Task
 * 2. View Pending Tasks
 * 3. Process Next Task
 * 4. View Completed Tasks
 * 5. Exit
 * Enter your choice: 2
 * --- Pending Tasks ---
 * No pending tasks.
 * 
 * --- Deployment Task Manager ---
 * 1. Add New Task
 * 2. View Pending Tasks
 * 3. Process Next Task
 * 4. View Completed Tasks
 * 5. Exit
 * Enter your choice: 3
 * Error: No tasks in the pending queue to process.
 * 
 * --- Deployment Task Manager ---
 * 1. Add New Task
 * 2. View Pending Tasks
 * 3. Process Next Task
 * 4. View Completed Tasks
 * 5. Exit
 * Enter your choice: 4
 * --- Completed Tasks ---
 * Task ID: 101, Description: Deploy frontend v1.0
 * Task ID: 102, Description: Deploy backend API fix
 * 
 * --- Deployment Task Manager ---
 * 1. Add New Task
 * 2. View Pending Tasks
 * 3. Process Next Task
 * 4. View Completed Tasks
 * 5. Exit
 * Enter your choice: 99
 * Error: Invalid choice. Please enter a number between 1 and 5.
 * 
 * --- Deployment Task Manager ---
 * 1. Add New Task
 * 2. View Pending Tasks
 * 3. Process Next Task
 * 4. View Completed Tasks
 * 5. Exit
 * Enter your choice: exit
 * Error: Invalid input. Please enter a number.
 * 
 * --- Deployment Task Manager ---
 * 1. Add New Task
 * 2. View Pending Tasks
 * 3. Process Next Task
 * 4. View Completed Tasks
 * 5. Exit
 * Enter your choice: 5
 * Exiting Deployment Task Manager.
 * ```
 * 
 * **Note:** Your solution should be provided as a single file containing the `DeploymentTask` and `DeploymentManager` classes. The `DeploymentManager` class should contain the `main` method to start the application.
 *
 * EXPLANATION:
 * The provided solution implements the `Deployment Task Manager` application as required, demonstrating the use of all specified Java components and adhering to best practices.
 * 
 * 1.  **`DeploymentTask` Class:** This simple class encapsulates the data for a task (`id` and `description`) with private fields and public getters, following encapsulation principles. The `toString()` method provides a convenient way to display task information.
 * 
 * 2.  **`DeploymentManager` Class:** This is the core class managing the application logic.
 *     *   **Data Structures:**
 *         *   `private Queue<DeploymentTask> pendingTasks = new LinkedList<>();`: A `Queue` is used for pending tasks because it naturally supports FIFO (First-In, First-Out) processing, which is typical for task queues. `LinkedList` is a common implementation of the `Queue` interface. Tasks are added using `offer()` and removed using `poll()`.
 *         *   `private List<DeploymentTask> completedTasks = new ArrayList<>();`: A `List` (specifically `ArrayList`) is used to store completed tasks. An `ArrayList` is suitable here because we need an ordered collection to keep track of tasks in the order they were completed, and we might need to iterate through them multiple times. Declaring it as `List` demonstrates polymorphism. Tasks are added using `add()`.
 *     *   **`Scanner`:** `private Scanner scanner = new Scanner(System.in);` is used to read input from the standard input stream (`System.in`). It's created once and reused.
 *     *   **Methods:**
 *         *   `addTask()`: Handles getting task details from the user. It includes basic input validation (positive ID, non-empty description) and uses `scanner.nextInt()` and `scanner.nextLine()`. A `try-catch(InputMismatchException)` is used around `scanner.nextInt()` to handle cases where the user enters non-numeric input for the ID, printing the error to `System.err`. `scanner.nextLine()` is called after `nextInt()` to consume the leftover newline character.
 *         *   `viewPendingTasks()`: Iterates through the `pendingTasks` queue to display its contents without removing elements. It checks if the queue is empty first. Output goes to `System.out`.
 *         *   `processNextTask()`: Implements the core queue processing logic. It checks if `pendingTasks` is empty. If not, it uses `pendingTasks.poll()` to get and remove the next task, then adds it to the `completedTasks` list using `completedTasks.add()`. Success messages go to `System.out`. **Crucially, if the queue is empty, it prints an error message to `System.err` as required.**
 *         *   `viewCompletedTasks()`: Iterates through the `completedTasks` list to display its contents. It checks if the list is empty first. Output goes to `System.out`.
 *         *   `displayMenu()`: A helper method to print the menu options to `System.out`.
 *         *   `runMenu()`: Contains the main application loop (`while (choice != 5)`). Inside the loop:
 *             *   It calls `displayMenu()`.
 *             *   It uses a `try-catch` block to wrap the input reading (`scanner.nextInt()`) and the `switch` statement.
 *             *   The `try-catch(InputMismatchException)` handles cases where the user enters non-integer input for the menu choice, printing the error to `System.err` and consuming the invalid input.
 *             *   A general `catch(Exception e)` is included as a class-wide handler for any other unexpected runtime errors, printing details to `System.err`.
 *             *   The `switch` statement directs execution based on the valid integer input, calling the appropriate method (`addTask`, `viewPendingTasks`, etc.). The `default` case in the `switch` handles valid integer input that doesn't match any menu option, printing an error to `System.err`.
 *     *   **`main` Method:** The entry point of the application. It creates an instance of `DeploymentManager` and calls `runMenu()` to start the interaction. The `scanner` is closed when the `runMenu` loop finishes (when the user chooses to exit).
 * 
 * **Demonstrated Concepts:**
 * 
 * *   **Collections:** Effective use of `Queue` (specifically `LinkedList`) for managing a waiting list with FIFO behavior and `List` (`ArrayList`) for maintaining a history of processed items.
 * *   **Interfaces vs. Implementations:** Using `List` as the type for `completedTasks` while instantiating `ArrayList`.
 * *   **Input Handling:** Using `Scanner` to read different data types (`int`, `String`) and handling the newline character after reading an integer.
 * *   **Control Flow:** Using a `while` loop for the main application flow and a `switch` statement for handling multiple menu options.
 * *   **Exception Handling:** Implementing `try-catch` blocks to handle specific input errors (`InputMismatchException`) and a general `Exception` catch for robustness. Error messages are directed to `System.err`.
 * *   **Object-Oriented Programming:** Basic class design (`DeploymentTask`, `DeploymentManager`), encapsulation (private fields, public methods), and method calls.
 * *   **Standard I/O:** Correctly using `System.out` for normal output and `System.err` for error output.
 * *   **Best Practices:** Meaningful names, basic input validation, comments, and a structured approach.
 * 
 * This solution effectively combines the required Java features into a functional, albeit simple, application that simulates a real-world task management scenario, providing a good test of an advanced student's understanding.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.InputMismatchException;

// Represents a single deployment task
class DeploymentTask {
    private int id;
    private String description;

    // Constructor
    public DeploymentTask(int id, String description) {
        this.id = id;
        this.description = description;
    }

    // Getter for ID
    public int getId() {
        return id;
    }

    // Getter for description
    public String getDescription() {
        return description;
    }

    // Override toString for easy printing
    @Override
    public String toString() {
        return "Task ID: " + id + ", Description: " + description;
    }
}

// Manages the queue of pending tasks and list of completed tasks
public class DeploymentManager {
    // Queue for tasks waiting to be processed (FIFO)
    private Queue<DeploymentTask> pendingTasks;
    // List for tasks that have been completed
    private List<DeploymentTask> completedTasks;
    // Scanner for user input
    private Scanner scanner;

    // Constructor
    public DeploymentManager() {
        // Use LinkedList as an implementation of Queue
        this.pendingTasks = new LinkedList<>();
        // Use ArrayList as an implementation of List
        this.completedTasks = new ArrayList<>();
        this.scanner = new Scanner(System.in);
    }

    // Adds a new task to the pending queue with input validation
    public void addTask() {
        System.out.print("Enter Task ID: ");
        int id = -1;
        try {
            id = scanner.nextInt();
            // Consume the newline character left by nextInt()
            scanner.nextLine();
        } catch (InputMismatchException e) {
            System.err.println("Error: Invalid input for Task ID. Please enter a number.");
            // Consume the invalid input
            scanner.nextLine();
            return; // Exit method on invalid input
        }

        if (id <= 0) {
            System.err.println("Error: Task ID must be a positive number.");
            return;
        }

        System.out.print("Enter Task Description: ");
        String description = scanner.nextLine().trim();

        if (description.isEmpty()) {
            System.err.println("Error: Task description cannot be empty.");
            return;
        }

        // Optional: Check for duplicate ID (not strictly required by prompt but good practice)
        // For simplicity, we skip duplicate ID check here as it's not a core requirement.

        DeploymentTask newTask = new DeploymentTask(id, description);
        pendingTasks.offer(newTask); // Use offer() for adding to queue
        System.out.println("Task " + id + " added to the pending queue.");
    }

    // Displays all tasks currently in the pending queue
    public void viewPendingTasks() {
        System.out.println("--- Pending Tasks ---");
        if (pendingTasks.isEmpty()) {
            System.out.println("No pending tasks.");
        } else {
            // Iterate through the queue without removing elements
            for (DeploymentTask task : pendingTasks) {
                System.out.println(task);
            }
        }
    }

    // Processes the next task in the pending queue (FIFO)
    public void processNextTask() {
        if (pendingTasks.isEmpty()) {
            // Use System.err for error message as required
            System.err.println("Error: No tasks in the pending queue to process.");
        } else {
            // Remove the next task from the queue
            DeploymentTask processedTask = pendingTasks.poll(); // Use poll() to remove and get
            // Add the processed task to the completed list
            completedTasks.add(processedTask);
            System.out.println("Processing " + processedTask);
            System.out.println("Task processed successfully.");
        }
    }

    // Displays all tasks in the completed tasks list
    public void viewCompletedTasks() {
        System.out.println("--- Completed Tasks ---");
        if (completedTasks.isEmpty()) {
            System.out.println("No completed tasks.");
        } else {
            // Iterate through the completed tasks list
            for (DeploymentTask task : completedTasks) {
                System.out.println(task);
            }
        }
    }

    // Displays the main menu
    private void displayMenu() {
        System.out.println("\n--- Deployment Task Manager ---");
        System.out.println("1. Add New Task");
        System.out.println("2. View Pending Tasks");
        System.out.println("3. Process Next Task");
        System.out.println("4. View Completed Tasks");
        System.out.println("5. Exit");
        System.out.print("Enter your choice: ");
    }

    // Runs the main application menu loop
    public void runMenu() {
        int choice = -1;
        while (choice != 5) {
            displayMenu();
            try {
                // Read user choice
                choice = scanner.nextInt();
                // Consume the newline
                scanner.nextLine();

                // Use switch statement for flow control
                switch (choice) {
                    case 1:
                        addTask();
                        break;
                    case 2:
                        viewPendingTasks();
                        break;
                    case 3:
                        processNextTask();
                        break;
                    case 4:
                        viewCompletedTasks();
                        break;
                    case 5:
                        System.out.println("Exiting Deployment Task Manager.");
                        break;
                    default:
                        // Use System.err for invalid input error
                        System.err.println("Error: Invalid choice. Please enter a number between 1 and 5.");
                }
            } catch (InputMismatchException e) {
                // Handle non-integer input using System.err
                System.err.println("Error: Invalid input. Please enter a number.");
                scanner.nextLine(); // Consume the invalid input to prevent infinite loop
                choice = -1; // Reset choice to stay in loop
            } catch (Exception e) {
                // Catch any other unexpected exceptions
                System.err.println("An unexpected error occurred: " + e.getMessage());
                e.printStackTrace(System.err); // Print stack trace to System.err
            }
        }
        // Close the scanner when exiting
        scanner.close();
    }

    // Main method to start the application
    public static void main(String[] args) {
        // Instantiate the manager and run the menu
        DeploymentManager manager = new DeploymentManager();
        manager.runMenu();
    }
}
