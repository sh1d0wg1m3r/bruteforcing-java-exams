/*
 * Exam Question #209
 * Generated on: 2025-05-11 22:32:16
 * Generated by: Account 2
 * 
 * QUESTION:
 * ## Advanced Java Programming Exam Task: Task Management System
 * 
 * **Objective:** Design and implement a simple command-line task management system. This system will allow users to add new tasks, process the next pending task, and view lists of pending and completed tasks. The implementation must demonstrate a strong understanding of core Java concepts, including collections, object-oriented principles, user input handling, and exception management.
 * 
 * **Scenario:** You are building the backend logic for a basic task tracker used by a small team. Tasks are received and placed in a queue to be processed in the order they were added. Once a task is processed, it is moved to a separate list of completed tasks.
 * 
 * **Requirements:**
 * 
 * 1.  **Task Representation:** Create a class `Task` to represent a single task. It should have:
 *     *   A private `String` field for the task description.
 *     *   A private `boolean` field to indicate if the task is completed.
 *     *   A constructor that takes the description and initializes the task as not completed.
 *     *   Public getter methods for the description and completion status.
 *     *   A public method `markCompleted()` to change the status to completed.
 *     *   Override the `toString()` method to provide a user-friendly representation (e.g., "[PENDING] Do laundry" or "[COMPLETED] Buy groceries").
 *     *   The constructor must validate that the description is not null or empty, throwing an `IllegalArgumentException` if it is.
 * 
 * 2.  **Task Management Logic:** Create a class `TaskManager` to manage the tasks. It should have:
 *     *   A private field to hold pending tasks using `java.util.Queue<Task>`. Choose an appropriate concrete implementation (e.g., `LinkedList`).
 *     *   A private field to hold completed tasks using `java.util.List<Task>`. Use `java.util.ArrayList` as the concrete implementation.
 *     *   A constructor to initialize these collections.
 *     *   A public method `addTask(String description)`: Creates a new `Task` object and adds it to the pending queue. Handle potential `IllegalArgumentException` from the `Task` constructor.
 *     *   A public method `processNextTask()`: Removes the task at the front of the pending queue, calls its `markCompleted()` method, and adds it to the completed list. If the pending queue is empty, it should not cause an error but instead indicate that there are no tasks to process.
 *     *   A public method `viewPendingTasks()`: Iterates through and prints all tasks currently in the pending queue. Indicate if the queue is empty.
 *     *   A public method `viewCompletedTasks()`: Iterates through and prints all tasks currently in the completed list. Indicate if the list is empty.
 * 
 * 3.  **User Interface and System Execution:** Create a main class (e.g., `AdvancedTaskSystem`) with a `main` method to run the system.
 *     *   Use `java.util.Scanner` to read user commands from the console (`System.in`).
 *     *   Implement a command loop that repeatedly:
 *         *   Displays a menu of available commands (`add`, `process`, `view pending`, `view completed`, `exit`).
 *         *   Reads the user's command.
 *         *   Uses a `switch` statement to determine the action based on the command.
 *         *   Calls the appropriate method(s) in the `TaskManager`.
 *         *   Handles the "exit" command to terminate the program.
 *     *   Use `System.out` for displaying the menu, prompts, success messages, and task lists.
 *     *   Use `System.err` for displaying error messages (e.g., invalid command, input validation errors, no tasks to process).
 *     *   Implement **class-wide exception handling** using `try-catch` blocks within the main command loop to catch potential exceptions during input reading or task operations and display informative error messages using `System.err` before continuing the loop (or exiting if the error is critical, like Scanner issues). Handle the `IllegalArgumentException` specifically.
 * 
 * 4.  **Best Practices:**
 *     *   Ensure proper encapsulation (private fields, public methods).
 *     *   Use meaningful variable and method names.
 *     *   Include appropriate comments and documentation (e.g., Javadoc for classes and methods).
 *     *   Implement input validation (as specified for task description).
 *     *   Ensure robust error handling (using `System.err` and `try-catch`).
 *     *   Maintain a clean and readable code structure.
 * 
 * **Expected Output:**
 * 
 * The system should interact with the user via the console. Examples of expected output include:
 * 
 * *   Displaying the command menu.
 * *   Prompts for task descriptions.
 * *   Success messages like "Task added: '...'" or "Task processed: '...'".
 * *   Lists of pending or completed tasks, clearly labeled.
 * *   Messages indicating empty lists/queues.
 * *   Error messages printed to `System.err` for invalid commands, empty descriptions, or attempts to process tasks when the queue is empty.
 * *   A message upon exiting.
 * 
 * **Evaluation Criteria:**
 * 
 * *   Correct usage of `Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.err`, `System.out`, and `try-catch`.
 * *   Correct implementation of task management logic (adding, processing, viewing).
 * *   Adherence to object-oriented principles (encapsulation, class design).
 * *   Effective input validation and error handling.
 * *   Code readability, structure, comments, and naming conventions.
 * 
 * **Time Limit:** 45-60 minutes
 * 
 * ---
 *
 * EXPLANATION:
 * The provided solution implements a simple task management system using the required Java components and following best practices.
 * 
 * 1.  **`Task` Class:** This class encapsulates the data for a single task (`description` and `isCompleted`). It provides a constructor that validates the input description, throwing an `IllegalArgumentException` if it's invalid. Methods for getting the state and marking the task completed are included. The `toString()` method provides a clear representation of the task's status and description, which is useful for printing.
 * 
 * 2.  **`TaskManager` Class:** This class manages the collections of tasks.
 *     *   It uses a `java.util.Queue<Task>` (`pendingTasks`) implemented by `java.util.LinkedList` to store tasks waiting for processing. The `Queue` ensures tasks are processed in a First-In, First-Out (FIFO) manner, suitable for a processing queue.
 *     *   It uses a `java.util.List<Task>` (`completedTasks`) implemented by `java.util.ArrayList` to store tasks once they are finished. The `List` provides an ordered collection suitable for viewing completed items.
 *     *   The `addTask` method creates a new `Task` object and adds it to the `pendingTasks` queue using `offer()`.
 *     *   The `processNextTask` method uses `poll()` to safely retrieve and remove the next task from the queue. If `poll()` returns `null` (indicating an empty queue), an error message is printed to `System.err`. Otherwise, the task is marked completed and added to the `completedTasks` list.
 *     *   `viewPendingTasks` and `viewCompletedTasks` methods iterate through their respective collections and print the tasks using their `toString()` representation. They also check if the collections are empty and print appropriate messages.
 * 
 * 3.  **`AdvancedTaskSystem` Class:** This is the main class that provides the user interface and controls the application flow.
 *     *   It initializes a `TaskManager` and a `java.util.Scanner` to read console input.
 *     *   The `run` method contains the main application loop.
 *     *   Inside the loop, a menu is displayed using `System.out`.
 *     *   User input is read using `scanner.nextLine()`.
 *     *   A `switch` statement is used to dispatch actions based on the user's command (`add`, `process`, `view pending`, `view completed`, `exit`). The `default` case handles invalid commands, printing an error to `System.err`.
 *     *   **Class-wide exception handling** is implemented with a `try-catch` block around the core command processing logic within the loop. This block catches `IllegalArgumentException` (specifically thrown by the `Task` constructor if the description is empty), `NoSuchElementException` (which can occur if the Scanner's input stream is closed unexpectedly), and a general `Exception` catch-all for any other unexpected runtime errors. All caught exceptions result in an error message printed to `System.err`, and the loop typically continues, allowing the user to try another command (except for critical errors like `NoSuchElementException` related to the Scanner).
 *     *   The `exit` command sets the `running` flag to false, terminating the loop.
 *     *   Finally, the `Scanner` resource is closed outside the loop to prevent resource leaks.
 *     *   The `main` method simply creates an instance of `AdvancedTaskSystem` and calls its `run` method.
 * 
 * **Demonstrated Concepts:**
 * 
 * *   **Collections:** Practical use of `Queue` for FIFO processing and `List`/`ArrayList` for storing records.
 * *   **Object-Oriented Programming:** Encapsulation in `Task` and `TaskManager`, separation of concerns between task data, task management logic, and the user interface.
 * *   **User Input:** Using `Scanner` to read different types of input (commands, descriptions).
 * *   **Control Flow:** Effective use of `while` loop for the main application flow and `switch` statement for command handling.
 * *   **Exception Handling:** Implementing specific `try-catch` blocks for expected errors (`IllegalArgumentException`) and a general catch for unexpected runtime errors, demonstrating robust error management using `System.err` for error output.
 * *   **Best Practices:** Adherence to naming conventions, adding comments, basic input validation, and resource management (closing Scanner).
 * 
 * This solution effectively integrates the required Java components into a functional and well-structured program, demonstrating key programming skills expected in advanced Java development.
 */

import java.util.Queue;
import java.util.LinkedList;
import java.util.List;
import java.util.ArrayList;
import java.util.Scanner;
import java.util.NoSuchElementException; // For potential Scanner issues

/**
 * Represents a single task with a description and completion status.
 */
class Task {
    private String description;
    private boolean isCompleted;

    /**
     * Constructs a new Task.
     * @param description The description of the task. Must not be null or empty.
     * @throws IllegalArgumentException if the description is null or empty.
     */
    public Task(String description) {
        if (description == null || description.trim().isEmpty()) {
            throw new IllegalArgumentException("Task description cannot be empty.");
        }
        this.description = description.trim();
        this.isCompleted = false;
    }

    /**
     * Gets the description of the task.
     * @return The task description.
     */
    public String getDescription() {
        return description;
    }

    /**
     * Checks if the task is completed.
     * @return true if the task is completed, false otherwise.
     */
    public boolean isCompleted() {
        return isCompleted;
    }

    /**
     * Marks the task as completed.
     */
    public void markCompleted() {
        this.isCompleted = true;
    }

    /**
     * Provides a string representation of the task including its status.
     * @return A formatted string representing the task.
     */
    @Override
    public String toString() {
        return "[" + (isCompleted ? "COMPLETED" : "PENDING") + "] " + description;
    }
}

/**
 * Manages a collection of pending and completed tasks.
 */
class TaskManager {
    // Queue for tasks waiting to be processed (FIFO)
    private Queue<Task> pendingTasks;
    // List for tasks that have been completed
    private List<Task> completedTasks; // Using List interface with ArrayList implementation

    /**
     * Constructs a new TaskManager, initializing the task collections.
     */
    public TaskManager() {
        // LinkedList is a common implementation for Queue
        this.pendingTasks = new LinkedList<>();
        // ArrayList is a common implementation for List
        this.completedTasks = new ArrayList<>();
    }

    /**
     * Adds a new task to the pending queue.
     * Delegates validation to the Task constructor.
     * @param description The description of the task.
     * @throws IllegalArgumentException if the description is invalid (handled by Task constructor).
     */
    public void addTask(String description) {
        // Task constructor throws IllegalArgumentException if description is invalid
        Task newTask = new Task(description);
        // offer() is generally preferred over add() for queues as it returns false
        // if the element cannot be added, while add() throws an exception.
        // For LinkedList, they behave similarly, but offer() is idiomatic.
        pendingTasks.offer(newTask);
        System.out.println("Task added: \"" + description + "\"");
    }

    /**
     * Processes the next task in the pending queue.
     * Removes the task, marks it completed, and moves it to the completed list.
     * Prints an error to System.err if the pending queue is empty.
     */
    public void processNextTask() {
        // poll() retrieves and removes the head of the queue, or returns null if the queue is empty.
        Task nextTask = pendingTasks.poll();

        if (nextTask == null) {
            // Requirement: Use System.err for error messages
            System.err.println("Error: No pending tasks to process.");
            return; // Exit the method gracefully
        }

        nextTask.markCompleted();
        completedTasks.add(nextTask);
        System.out.println("Task processed: \"" + nextTask.getDescription() + "\"");
    }

    /**
     * Displays all tasks currently in the pending queue.
     * Prints a message if the queue is empty.
     */
    public void viewPendingTasks() {
        System.out.println("\n--- Pending Tasks ---");
        if (pendingTasks.isEmpty()) {
            System.out.println("No pending tasks.");
        } else {
            // Iterate through the queue elements without removing them
            int index = 1;
            for (Task task : pendingTasks) {
                System.out.println(index++ + ". " + task);
            }
        }
        System.out.println("---------------------");
    }

    /**
     * Displays all tasks that have been completed.
     * Prints a message if the completed list is empty.
     */
    public void viewCompletedTasks() {
        System.out.println("\n--- Completed Tasks ---");
        if (completedTasks.isEmpty()) {
            System.out.println("No completed tasks.");
        } else {
            // Iterate through the list elements
            int index = 1;
            for (Task task : completedTasks) {
                System.out.println(index++ + ". " + task);
            }
        }
        System.out.println("-----------------------");
    }
}

/**
 * Main class to run the Advanced Task Management System.
 * Handles user interaction via console and manages exceptions.
 */
public class AdvancedTaskSystem {

    private TaskManager taskManager;
    private Scanner scanner;

    /**
     * Constructs the AdvancedTaskSystem, initializing TaskManager and Scanner.
     */
    public AdvancedTaskSystem() {
        this.taskManager = new TaskManager();
        this.scanner = new Scanner(System.in);
    }

    /**
     * Displays the main command menu to the user.
     * Uses System.out as required for normal output.
     */
    private void displayMenu() {
        System.out.println("\n--- Task Management System Menu ---");
        System.out.println("add           - Add a new task");
        System.out.println("process       - Process the next pending task");
        System.out.println("view pending  - View all pending tasks");
        System.out.println("view completed- View all completed tasks");
        System.out.println("exit          - Exit the system");
        System.out.print("Enter command: ");
    }

    /**
     * Runs the main command loop for the task management system.
     * Includes class-wide exception handling.
     */
    public void run() {
        boolean running = true;
        while (running) {
            displayMenu();
            String command = null;
            try {
                // Read the entire line of input
                command = scanner.nextLine().trim().toLowerCase();

                // Use switch statement for command processing as required
                switch (command) {
                    case "add":
                        System.out.print("Enter task description: ");
                        String description = scanner.nextLine();
                        // addTask method handles calling Task constructor which validates
                        taskManager.addTask(description);
                        break;
                    case "process":
                        taskManager.processNextTask(); // This method prints error to System.err if queue is empty
                        break;
                    case "view pending":
                        taskManager.viewPendingTasks();
                        break;
                    case "view completed":
                        taskManager.viewCompletedTasks();
                        break;
                    case "exit":
                        System.out.println("Exiting Task Management System.");
                        running = false; // Set flag to exit the loop
                        break;
                    default:
                        // Use System.err for invalid command error
                        System.err.println("Error: Invalid command. Please try again.");
                        break;
                }
            } catch (IllegalArgumentException e) {
                // Catch specific validation error from Task constructor via addTask method
                System.err.println("Input Error: " + e.getMessage());
            } catch (NoSuchElementException e) {
                 // Catch potential error if scanner's input stream is unexpectedly closed or empty
                 System.err.println("System Error: Input stream exhausted or closed. Exiting.");
                 running = false; // Critical error, force exit
            } catch (Exception e) {
                // Class-wide catch for any other unexpected runtime exceptions
                // Use System.err for error message
                System.err.println("An unexpected error occurred: " + e.getMessage());
                // e.printStackTrace(); // Optional: Uncomment for detailed debugging stack trace
            }
        }
        // Close the scanner resource when the loop finishes
        scanner.close();
        System.out.println("Scanner closed.");
    }

    /**
     * The entry point of the program.
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        AdvancedTaskSystem system = new AdvancedTaskSystem();
        system.run();
    }
}
