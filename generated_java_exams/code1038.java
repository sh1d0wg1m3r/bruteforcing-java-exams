/*
 * Exam Question #1038
 * Generated on: 2025-05-12 17:16:11
 * Generated by: Account 2
 * 
 * QUESTION:
 * **Advanced Java Programming Exam Task: Print Spooler Simulation**
 * 
 * **Scenario:**
 * 
 * You are tasked with developing a simplified simulation of a print spooler system. This system manages print jobs submitted by users, holds them in a queue, processes them one by one, and keeps a record of completed jobs.
 * 
 * **Requirements:**
 * 
 * Implement a Java program that simulates this print spooler with the following features:
 * 
 * 1.  **Print Job Representation:** Create a class `PrintJob` to represent a print job. Each `PrintJob` should have:
 *     *   A unique integer ID.
 *     *   A String representing the file name to be printed.
 *     *   A String representing the current status (e.g., "Pending", "Completed").
 *     *   Implement appropriate encapsulation (private fields, public getters).
 *     *   Include a `toString()` method for easy printing of job details.
 * 
 * 2.  **Print Spooler Management:** Create a class `PrintSpooler` that manages the print jobs. This class must:
 *     *   Use a `java.util.Queue<PrintJob>` to hold pending print jobs.
 *     *   Use a `java.util.List<PrintJob>` (specifically, an `ArrayList<PrintJob>`) to store completed print jobs.
 *     *   Maintain a counter for generating unique job IDs.
 *     *   Implement the following public methods:
 *         *   `addJob(String fileName)`: Creates a new `PrintJob` with a unique ID and "Pending" status, and adds it to the pending job queue. It should perform input validation to ensure the file name is not empty.
 *         *   `processNextJob()`: Removes the next job from the front of the queue, changes its status to "Completed", and adds it to the list of completed jobs. If the queue is empty, it should report an error.
 *         *   `viewPendingJobs()`: Displays the details of all jobs currently in the pending queue.
 *         *   `viewCompletedJobs()`: Displays the details of all completed jobs.
 * 
 * 3.  **User Interface:** Provide a console-based user interface in your `main` method (can be in a separate class or within `PrintSpooler`). This interface should:
 *     *   Display a menu of options:
 *         1.  Add Print Job
 *         2.  Process Next Job
 *         3.  View Pending Jobs
 *         4.  View Completed Jobs
 *         5.  Exit
 *     *   Use `java.util.Scanner` to read the user's menu choice and any required input (like the file name).
 *     *   Use a `switch` statement to handle the user's choice and call the appropriate `PrintSpooler` methods.
 *     *   Use `System.out` for displaying the menu, prompts, job details, and confirmations.
 *     *   Use `System.err` to display error messages (e.g., invalid menu choice, invalid input for file name, attempting to process job when queue is empty).
 * 
 * 4.  **Error Handling:**
 *     *   Implement input validation for the file name in `addJob`.
 *     *   Handle the case where `processNextJob` is called on an empty queue.
 *     *   Implement class-wide exception handling using `try-catch` blocks in your `main` method to gracefully handle potential runtime errors, such as the user entering non-numeric input for the menu choice.
 * 
 * 5.  **Best Practices:**
 *     *   Follow proper encapsulation.
 *     *   Use meaningful variable and method names.
 *     *   Include appropriate comments to explain complex logic.
 *     *   Ensure the code structure is clean and readable.
 * 
 * **Expected Output:**
 * 
 * Your program should interact with the user via the console, displaying menus, prompts, and job lists. Error messages should be clearly distinguishable using `System.err`.
 * 
 * Example Interaction:
 * 
 * ```
 * --- Print Spooler Menu ---
 * 1. Add Print Job
 * 2. Process Next Job
 * 3. View Pending Jobs
 * 4. View Completed Jobs
 * 5. Exit
 * Enter your choice: 1
 * Enter file name: document1.txt
 * Job added: [ID: 1, File: document1.txt, Status: Pending]
 * 
 * --- Print Spooler Menu ---
 * 1. Add Print Job
 * 2. Process Next Job
 * 3. View Pending Jobs
 * 4. View Completed Jobs
 * 5. Exit
 * Enter your choice: 1
 * Enter file name: report.pdf
 * Job added: [ID: 2, File: report.pdf, Status: Pending]
 * 
 * --- Print Spooler Menu ---
 * 1. Add Print Job
 * 2. Process Next Job
 * 3. View Pending Jobs
 * 4. View Completed Jobs
 * 5. Exit
 * Enter your choice: 3
 * --- Pending Jobs ---
 * [ID: 1, File: document1.txt, Status: Pending]
 * [ID: 2, File: report.pdf, Status: Pending]
 * 
 * --- Print Spooler Menu ---
 * 1. Add Print Job
 * 2. Process Next Job
 * 3. View Pending Jobs
 * 4. View Completed Jobs
 * 5. Exit
 * Enter your choice: 2
 * Processing job: [ID: 1, File: document1.txt, Status: Pending]
 * Job 1 completed.
 * 
 * --- Print Spooler Menu ---
 * 1. Add Print Job
 * 2. Process Next Job
 * 3. View Pending Jobs
 * 4. View Completed Jobs
 * 5. Exit
 * Enter your choice: 3
 * --- Pending Jobs ---
 * [ID: 2, File: report.pdf, Status: Pending]
 * 
 * --- Print Spooler Menu ---
 * 1. Add Print Job
 * 2. Process Next Job
 * 3. View Pending Jobs
 * 4. View Completed Jobs
 * 5. Exit
 * Enter your choice: 4
 * --- Completed Jobs ---
 * [ID: 1, File: document1.txt, Status: Completed]
 * 
 * --- Print Spooler Menu ---
 * 1. Add Print Job
 * 2. Process Next Job
 * 3. View Pending Jobs
 * 4. View Completed Jobs
 * 5. Exit
 * Enter your choice: 6
 * Error: Invalid menu choice. Please enter a number between 1 and 5.
 * 
 * --- Print Spooler Menu ---
 * 1. Add Print Job
 * 2. Process Next Job
 * 3. View Pending Jobs
 * 4. View Completed Jobs
 * 5. Exit
 * Enter your choice: exit
 * Error: Invalid input. Please enter a number.
 * 
 * --- Print Spooler Menu ---
 * 1. Add Print Job
 * 2. Process Next Job
 * 3. View Pending Jobs
 * 4. View Completed Jobs
 * 5. Exit
 * Enter your choice: 5
 * Exiting Print Spooler.
 * ```
 * 
 * Your solution should be a single Java file containing all necessary classes.
 *
 * EXPLANATION:
 * The solution implements a basic print spooler simulation as requested, demonstrating the use of all specified Java components and adhering to best practices.
 * 
 * 1.  **`PrintJob` Class:** This class serves as a simple Plain Old Java Object (POJO) to hold the data for a single print job (ID, file name, status). It follows encapsulation principles with private fields and public getter methods. The `setStatus` method is provided to allow the `PrintSpooler` to update the job's state. The `toString()` method provides a convenient way to display job information.
 * 
 * 2.  **`PrintSpooler` Class:** This is the core class managing the print jobs.
 *     *   It declares a `Queue<PrintJob>` named `jobQueue` using `LinkedList` as the implementation. `LinkedList` implements the `Queue` interface and is suitable for this purpose as it provides efficient additions to the tail and removals from the head.
 *     *   It declares a `List<PrintJob>` named `completedJobs` using `ArrayList` as the implementation. `ArrayList` is suitable for storing completed jobs as we primarily need to add to the end and iterate through the list.
 *     *   A `nextJobId` counter ensures each job gets a unique ID.
 *     *   The `addJob` method creates a new `PrintJob` and adds it to the `jobQueue` using `offer()`. It includes basic input validation for the file name, printing an error to `System.err` if invalid input is provided.
 *     *   The `processNextJob` method uses `poll()` to retrieve and remove the head of the `jobQueue`. It first checks if the queue is empty and prints an error message to `System.err` if it is, fulfilling the requirement for operational error reporting using `System.err`. If a job is retrieved, its status is updated, and it's added to the `completedJobs` list.
 *     *   `viewPendingJobs` and `viewCompletedJobs` iterate through the respective collections and print the details of each job using `System.out`. They also handle the case where the collections are empty.
 * 
 * 3.  **User Interface (`run` method in `PrintSpooler`):**
 *     *   The `run` method contains the main application loop.
 *     *   A `Scanner` object is used to read user input from the console (`System.in`).
 *     *   The `displayMenu` helper method prints the options using `System.out`.
 *     *   Inside the `while` loop, the program reads the user's input line using `scanner.nextLine()`.
 *     *   A `try-catch` block is used to wrap the core logic of reading input and handling the menu choice. This fulfills the requirement for class-wide exception handling by catching potential `NumberFormatException` if the user enters non-numeric input, as well as a general `Exception` for any other unforeseen issues. Error messages from the catch blocks are printed to `System.err`.
 *     *   `Integer.parseInt()` attempts to convert the input string to an integer. If this fails, the `NumberFormatException` is caught.
 *     *   A `switch` statement is used to direct the program flow based on the valid integer choice, calling the appropriate methods of the `PrintSpooler` instance.
 *     *   The `default` case in the `switch` handles valid integer inputs that are outside the expected menu range (1-5), printing an error to `System.err`.
 *     *   The loop continues until the user chooses option 5.
 *     *   The `scanner.close()` call ensures the scanner resource is released upon exiting the loop.
 * 
 * 4.  **Error Handling:**
 *     *   Input validation for the file name is done within `addJob`.
 *     *   Attempting to process an empty queue is checked and reported via `System.err` in `processNextJob`.
 *     *   The `try-catch` block in `run` handles invalid menu input (non-numeric) and other potential runtime exceptions, printing errors to `System.err`.
 * 
 * 5.  **Best Practices:** The code uses meaningful names (`jobQueue`, `completedJobs`, `addJob`, `processNextJob`), follows encapsulation, includes comments explaining the purpose of classes and methods, and structures the logic into separate classes and methods for clarity.
 * 
 * This solution effectively integrates `Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.err`, `System.out`, and `try-catch` blocks within a practical simulation, demonstrating a solid understanding of these core Java concepts and best practices.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.InputMismatchException;

// Represents a single print job
class PrintJob {
    private int id;
    private String fileName;
    private String status;

    // Constructor
    public PrintJob(int id, String fileName) {
        this.id = id;
        this.fileName = fileName;
        this.status = "Pending"; // Initial status
    }

    // Getters
    public int getId() {
        return id;
    }

    public String getFileName() {
        return fileName;
    }

    public String getStatus() {
        return status;
    }

    // Setter for status (used when processing)
    public void setStatus(String status) {
        this.status = status;
    }

    // String representation of a print job
    @Override
    public String toString() {
        return "[ID: " + id + ", File: " + fileName + ", Status: " + status + "]";
    }
}

// Manages the queue of print jobs and history of completed jobs
class PrintSpooler {
    // Queue for jobs waiting to be printed
    private Queue<PrintJob> jobQueue;
    // List for jobs that have been printed
    private List<PrintJob> completedJobs;
    // Counter for generating unique job IDs
    private int nextJobId;

    // Constructor
    public PrintSpooler() {
        // Use LinkedList for the Queue implementation
        jobQueue = new LinkedList<>();
        // Use ArrayList for the List implementation
        completedJobs = new ArrayList<>();
        nextJobId = 1; // Start job IDs from 1
    }

    /**
     * Adds a new print job to the queue.
     * @param fileName The name of the file to print.
     */
    public void addJob(String fileName) {
        // Input validation: file name cannot be empty or null
        if (fileName == null || fileName.trim().isEmpty()) {
            System.err.println("Error: File name cannot be empty.");
            return; // Do not add the job
        }

        PrintJob newJob = new PrintJob(nextJobId++, fileName.trim());
        jobQueue.offer(newJob); // offer() is preferred over add() for queues as it doesn't throw exception on capacity issues (though LinkedList doesn't have capacity limit)
        System.out.println("Job added: " + newJob);
    }

    /**
     * Processes the next job in the queue.
     */
    public void processNextJob() {
        // Check if the queue is empty before trying to poll
        if (jobQueue.isEmpty()) {
            System.err.println("Error: No pending jobs to process.");
            return; // Cannot process
        }

        // poll() retrieves and removes the head of the queue, returns null if empty (already checked)
        PrintJob jobToProcess = jobQueue.poll();

        System.out.println("Processing job: " + jobToProcess);

        // Update status and move to completed list
        jobToProcess.setStatus("Completed");
        completedJobs.add(jobToProcess);

        System.out.println("Job " + jobToProcess.getId() + " completed.");
    }

    /**
     * Displays all jobs currently in the pending queue.
     */
    public void viewPendingJobs() {
        System.out.println("--- Pending Jobs ---");
        if (jobQueue.isEmpty()) {
            System.out.println("No jobs in the pending queue.");
        } else {
            // Iterate through the queue without removing elements
            for (PrintJob job : jobQueue) {
                System.out.println(job);
            }
        }
    }

    /**
     * Displays all jobs that have been completed.
     */
    public void viewCompletedJobs() {
        System.out.println("--- Completed Jobs ---");
        if (completedJobs.isEmpty()) {
            System.out.println("No jobs have been completed yet.");
        } else {
            // Iterate through the list of completed jobs
            for (PrintJob job : completedJobs) {
                System.out.println(job);
            }
        }
    }

    /**
     * Displays the main menu options to the user.
     */
    private void displayMenu() {
        System.out.println("\n--- Print Spooler Menu ---");
        System.out.println("1. Add Print Job");
        System.out.println("2. Process Next Job");
        System.out.println("3. View Pending Jobs");
        System.out.println("4. View Completed Jobs");
        System.out.println("5. Exit");
        System.out.print("Enter your choice: ");
    }

    /**
     * Runs the main application loop.
     */
    public void run() {
        // Use Scanner for reading user input from the console
        Scanner scanner = new Scanner(System.in);
        int choice = -1; // Initialize choice to a non-menu value

        // Main application loop
        while (choice != 5) {
            displayMenu();

            try {
                // Read the entire line first to avoid issues with nextInt() and line breaks
                String input = scanner.nextLine();
                // Attempt to parse the input as an integer
                choice = Integer.parseInt(input);

                // Switch statement to handle menu options
                switch (choice) {
                    case 1:
                        System.out.print("Enter file name: ");
                        String fileName = scanner.nextLine();
                        addJob(fileName); // Call method to add job with validation
                        break;
                    case 2:
                        processNextJob(); // Call method to process job
                        break;
                    case 3:
                        viewPendingJobs(); // Call method to view pending jobs
                        break;
                    case 4:
                        viewCompletedJobs(); // Call method to view completed jobs
                        break;
                    case 5:
                        System.out.println("Exiting Print Spooler.");
                        break;
                    default:
                        // Handle invalid numeric input outside the 1-5 range
                        System.err.println("Error: Invalid menu choice. Please enter a number between 1 and 5.");
                        break;
                }
            } catch (NumberFormatException e) {
                // Class-wide exception handling for non-numeric input
                System.err.println("Error: Invalid input. Please enter a number.");
                // choice remains -1, loop continues
            } catch (Exception e) {
                // Catch any other unexpected exceptions
                System.err.println("An unexpected error occurred: " + e.getMessage());
                // You might want to log the full stack trace in a real application
                // e.printStackTrace(System.err);
            }
        }

        // Close the scanner when exiting the loop
        scanner.close();
    }

    // Main method to start the application
    public static void main(String[] args) {
        PrintSpooler spooler = new PrintSpooler();
        spooler.run(); // Start the application loop
    }
}
