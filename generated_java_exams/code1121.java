/*
 * Exam Question #1121
 * Generated on: 2025-05-12 17:27:43
 * Generated by: Account 5
 * 
 * QUESTION:
 * **Task Management System with Prioritization and Dependencies**
 * 
 * You are tasked with developing a simple console-based Task Management System in Java. This system should allow users to add tasks, view existing tasks, and process tasks based on their priority and dependencies.
 * 
 * **Problem Description:**
 * 
 * A task in this system has:
 * 1.  A unique integer ID (automatically assigned).
 * 2.  A description (String).
 * 3.  A priority (High, Medium, or Low).
 * 4.  A list of integer IDs representing tasks that must be completed *before* this task can be processed (dependencies).
 * 5.  A status (Completed or Pending).
 * 
 * The system should maintain a list of all tasks created. When the user chooses to "Process Next Task", the system should identify the highest priority task that is currently Pending and whose dependencies have all been Completed. If multiple tasks meet this criteria, the one with the lowest ID should be chosen. This task is then marked as Completed.
 * 
 * **Functionality Requirements:**
 * 
 * 1.  **Add Task:**
 *     *   Prompt the user for task description.
 *     *   Prompt the user for priority (allow input as 1 for High, 2 for Medium, 3 for Low).
 *     *   Prompt the user for dependency IDs (comma-separated integers, or leave blank for no dependencies).
 *     *   Create a new `Task` object with a unique ID, the provided details, and initial status Pending.
 *     *   Validate priority input.
 *     *   Validate dependency IDs (ensure they refer to existing tasks).
 *     *   Add the new task to the system's list of all tasks.
 * 2.  **View Tasks:**
 *     *   Display all tasks with their ID, description, priority, dependencies, and status.
 * 3.  **Process Next Task:**
 *     *   Identify all Pending tasks whose dependencies are met.
 *     *   From this subset, find the task with the highest priority (High > Medium > Low).
 *     *   If there's a tie in priority, select the task with the lowest ID.
 *     *   If a task is found, mark it as Completed and display a confirmation message.
 *     *   If no task can be processed (either all are completed, or no pending tasks have met dependencies), display an appropriate message.
 * 4.  **Exit:**
 *     *   Terminate the program.
 * 
 * **Technical Requirements:**
 * 
 * Your solution must use ALL of the following Java components:
 * 
 * *   `java.util.Queue` (specifically, use a concrete implementation like `LinkedList` which also implements `Queue`) to manage tasks ready for processing in the "Process Next Task" step.
 * *   `java.util.ArrayList` to store the main list of all tasks.
 * *   `java.util.List` interface when declaring variables that hold lists.
 * *   `java.util.Scanner` for reading user input from the console.
 * *   `switch` statement for handling the main menu options.
 * *   `System.err` for printing error messages (e.g., invalid input, dependency not found).
 * *   `System.out` for printing normal output (menus, prompts, task details, success messages).
 * *   Class-wide exception handling using `try-catch` blocks where appropriate, particularly around input processing and potential issues during task operations.
 * 
 * **Best Practices:**
 * 
 * *   Implement proper encapsulation (private fields, public getters/setters where necessary).
 * *   Use meaningful variable and method names.
 * *   Include appropriate comments and documentation (e.g., Javadoc).
 * *   Perform input validation.
 * *   Implement robust error handling.
 * *   Structure your code into appropriate classes (`Task`, `TaskManager`, etc.).
 * 
 * **Input Format Examples:**
 * 
 * *   Priority: Enter 1 for High, 2 for Medium, 3 for Low.
 * *   Dependencies: Enter comma-separated task IDs (e.g., `1,3,5`) or just press Enter for no dependencies.
 * 
 * **Expected Output Examples:**
 * 
 * ```
 * --- Task Management System ---
 * 1. Add Task
 * 2. View Tasks
 * 3. Process Next Task
 * 4. Exit
 * Enter choice: 1
 * Enter task description: Design database schema
 * Enter priority (1=High, 2=Medium, 3=Low): 1
 * Enter dependency IDs (comma-separated, or blank):
 * Task added with ID: 1
 * 
 * --- Task Management System ---
 * ...
 * Enter choice: 1
 * Enter task description: Implement user interface
 * Enter priority (1=High, 2=Medium, 3=Low): 2
 * Enter dependency IDs (comma-separated, or blank): 1
 * Task added with ID: 2
 * 
 * --- Task Management System ---
 * ...
 * Enter choice: 2
 * --- All Tasks ---
 * ID: 1, Description: Design database schema, Priority: HIGH, Dependencies: [], Status: PENDING
 * ID: 2, Description: Implement user interface, Priority: MEDIUM, Dependencies: [1], Status: PENDING
 * -------------------
 * 
 * --- Task Management System ---
 * ...
 * Enter choice: 3
 * Processing task: ID: 1, Description: Design database schema, Priority: HIGH
 * Task 1 marked as Completed.
 * 
 * --- Task Management System ---
 * ...
 * Enter choice: 3
 * Processing task: ID: 2, Description: Implement user interface, Priority: MEDIUM
 * Task 2 marked as Completed.
 * 
 * --- Task Management System ---
 * ...
 * Enter choice: 3
 * No tasks are ready to be processed.
 * 
 * --- Task Management System ---
 * ...
 * Enter choice: 5
 * Invalid choice. Please try again.
 * ```
 * 
 * Your solution should be a single Java file containing all necessary classes and the main method.
 *
 * EXPLANATION:
 * This solution implements a Task Management System demonstrating the required Java concepts and best practices.
 * 
 * **Overall Design:**
 * 
 * *   The `TaskPriority` enum defines the possible priority levels.
 * *   The `Task` class encapsulates the data for a single task (ID, description, priority, dependencies, status).
 * *   The `TaskManager` class manages the collection of all tasks (`allTasks`) and handles the logic for adding, viewing, and processing tasks.
 * *   The `TaskManagementApp` class contains the `main` method, the main application loop, user interaction via `Scanner`, and orchestrates calls to the `TaskManager`.
 * 
 * **Usage of Required Components:**
 * 
 * 1.  **`java.util.Queue`**: A `Queue` (`LinkedList` implementation) is used within the `TaskManager.buildProcessingQueue()` method. This queue temporarily holds the tasks that are currently ready to be processed, ordered correctly by priority and ID. The `processNextTask()` method then uses `processingQueue.poll()` to retrieve and remove the next task according to the defined processing logic (highest priority, lowest ID).
 * 2.  **`java.util.ArrayList`**: An `ArrayList` is used in the `TaskManager` class (`allTasks`) to store the complete list of all `Task` objects created in the system. `ArrayList` is also used within the `Task` class to store the `dependencies` list and temporarily in `TaskManagementApp` when parsing dependency input.
 * 3.  **`java.util.List` interface**: The `allTasks` field in `TaskManager` is declared using the `List` interface (`List<Task> allTasks`), while being instantiated as an `ArrayList` (`new ArrayList<>()`). Similarly, the `dependencies` field in the `Task` class is declared as `List<Integer>`. This demonstrates programming to interfaces, which promotes flexibility.
 * 4.  **`java.util.Scanner`**: A `Scanner` object is created in the `main` method to read user input from `System.in` for menu choices, task details, and dependencies. `scanner.nextLine()` is used consistently to avoid common `Scanner` pitfalls with mixed input types.
 * 5.  **`switch` statement**: A `switch` statement in the `main` method is used to handle the user's menu selection, directing the program flow to the appropriate task management operation (Add, View, Process, Exit).
 * 6.  **`System.err`**: `System.err.println()` is used to print error messages, such as invalid menu choices, `NumberFormatException` during input parsing, and `IllegalArgumentException` when validating dependency IDs or priority values. This visually distinguishes error output from normal program output.
 * 7.  **`System.out`**: `System.out.println()` is used for all normal output: printing the menu, prompting the user for input, displaying task details, and confirming successful operations like task addition or completion.
 * 8.  **Class-wide exception handling with `try-catch`**:
 *     *   A broad `try-catch (Exception e)` block wraps the main `while` loop in the `main` method. This provides a form of "class-wide" or application-level handling for any unexpected exceptions that might propagate up from called methods, preventing the program from crashing abruptly.
 *     *   More specific `try-catch` blocks are used around input parsing (`Integer.parseInt`) and within the "Add Task" logic to catch expected exceptions like `NumberFormatException` (for non-integer input) and `IllegalArgumentException` (thrown by `TaskPriority.fromValue` or `TaskManager.addTask` for invalid data like non-existent dependency IDs). These specific catches allow for targeted error messages using `System.err`.
 * 
 * **Best Practices Implementation:**
 * 
 * *   **Encapsulation:** Fields in `Task` and `TaskManager` are `private`. Public getter methods are provided where external access is needed. The dependencies list is returned as an unmodifiable list to prevent external modification.
 * *   **Meaningful Names:** Class names (`Task`, `TaskManager`, `TaskManagementApp`), enum names (`TaskPriority`), variables (`allTasks`, `processingQueue`, `nextTaskId`, `description`, `priority`), and methods (`addTask`, `viewTasks`, `processNextTask`, `buildProcessingQueue`, `areDependenciesMet`, `findTaskById`) are clearly named to reflect their purpose.
 * *   **Comments and Documentation:** Javadoc comments are included for classes and key methods explaining their purpose, parameters, and return values. Inline comments are used for specific logic points.
 * *   **Input Validation:**
 *     *   Priority input is validated by the `TaskPriority.fromValue` method, which throws an `IllegalArgumentException` for invalid numbers.
 *     *   Dependency IDs entered by the user are validated in `TaskManager.addTask` to ensure they correspond to existing tasks, throwing an `IllegalArgumentException` if not found.
 *     *   `NumberFormatException` is caught when parsing integer inputs (menu choice, priority value, dependency IDs).
 * *   **Error Handling:** As detailed above, `try-catch` blocks are used to handle potential errors gracefully, providing informative messages to the user via `System.err`.
 * *   **Clean Code Structure:** The code is organized into logical classes, each responsible for a specific part of the system. Methods are kept relatively focused.
 * 
 * **Handling Dependencies and Priority in Queueing:**
 * 
 * The `buildProcessingQueue()` method is crucial. It iterates through all tasks, filters for those that are not completed and have all their dependencies met (`areDependenciesMet()`). It then sorts this filtered list using a `Comparator` that prioritizes `HIGH`, then `MEDIUM`, then `LOW`, and finally uses the task ID as a tie-breaker (lower ID first). The sorted tasks are then added to a `LinkedList` (used as a `Queue`). The `processNextTask()` method simply polls the first task from this queue, ensuring the highest priority, lowest ID task that is ready is processed next. This approach rebuilds the queue state on demand for each processing request, simplifying the logic compared to dynamic queue updates upon task completion, while still utilizing the `Queue` interface effectively for ordered processing.
 * 
 * This solution effectively integrates all required components to build a functional, albeit simple, task management system, demonstrating understanding of fundamental and intermediate Java concepts, along with good programming practices.
 */

import java.util.*;
import java.util.stream.Collectors;

// Enum for Task Priority
enum TaskPriority {
    HIGH(1), MEDIUM(2), LOW(3);

    private final int value;

    TaskPriority(int value) {
        this.value = value;
    }

    public int getValue() {
        return value;
    }

    public static TaskPriority fromValue(int value) {
        for (TaskPriority priority : values()) {
            if (priority.value == value) {
                return priority;
            }
        }
        throw new IllegalArgumentException("Invalid priority value: " + value);
    }
}

// Class representing a Task
class Task {
    private int id;
    private String description;
    private TaskPriority priority;
    private List<Integer> dependencies;
    private boolean completed;

    // Constructor
    public Task(int id, String description, TaskPriority priority, List<Integer> dependencies) {
        this.id = id;
        this.description = description;
        this.priority = priority;
        this.dependencies = new ArrayList<>(dependencies); // Use ArrayList for dependencies
        this.completed = false; // Initially pending
    }

    // Getters
    public int getId() {
        return id;
    }

    public String getDescription() {
        return description;
    }

    public TaskPriority getPriority() {
        return priority;
    }

    public List<Integer> getDependencies() {
        return Collections.unmodifiableList(dependencies); // Return unmodifiable list
    }

    public boolean isCompleted() {
        return completed;
    }

    // Setter for completion status
    public void setCompleted(boolean completed) {
        this.completed = completed;
    }

    @Override
    public String toString() {
        return String.format("ID: %d, Description: %s, Priority: %s, Dependencies: %s, Status: %s",
                             id, description, priority, dependencies, completed ? "COMPLETED" : "PENDING");
    }
}

// Class managing the collection of tasks
class TaskManager {
    private List<Task> allTasks; // Use List interface, backed by ArrayList
    private int nextTaskId;

    public TaskManager() {
        this.allTasks = new ArrayList<>(); // Use ArrayList implementation
        this.nextTaskId = 1;
    }

    /**
     * Adds a new task to the system.
     * Validates dependencies.
     * @param description Task description.
     * @param priority Task priority.
     * @param dependencyIds List of dependency task IDs.
     * @throws IllegalArgumentException if any dependency ID is invalid.
     */
    public void addTask(String description, TaskPriority priority, List<Integer> dependencyIds) {
        // Validate dependencies exist
        for (int depId : dependencyIds) {
            if (findTaskById(depId) == null) {
                throw new IllegalArgumentException("Dependency task ID " + depId + " not found.");
            }
        }

        Task newTask = new Task(nextTaskId++, description, priority, dependencyIds);
        allTasks.add(newTask);
        System.out.println("Task added with ID: " + newTask.getId());
    }

    /**
     * Finds a task by its ID.
     * @param id The task ID.
     * @return The Task object or null if not found.
     */
    public Task findTaskById(int id) {
        for (Task task : allTasks) {
            if (task.getId() == id) {
                return task;
            }
        }
        return null;
    }

    /**
     * Checks if all dependencies for a task are completed.
     * @param task The task to check.
     * @return true if all dependencies are completed or if there are no dependencies, false otherwise.
     */
    private boolean areDependenciesMet(Task task) {
        for (int depId : task.getDependencies()) {
            Task dependencyTask = findTaskById(depId);
            // If dependency task not found or not completed, dependencies are not met
            // Note: findTaskById already throws if dependency is added but not found later.
            // This check is more for runtime state.
             if (dependencyTask == null || !dependencyTask.isCompleted()) {
                return false;
            }
        }
        return true;
    }

    /**
     * Builds a queue of tasks ready for processing based on priority and dependencies.
     * @return A Queue of tasks ready to be processed, ordered by priority and ID.
     */
    private Queue<Task> buildProcessingQueue() {
        Queue<Task> processingQueue = new LinkedList<>(); // LinkedList implements Queue

        // Filter pending tasks with met dependencies
        List<Task> readyTasks = allTasks.stream()
                .filter(task -> !task.isCompleted())
                .filter(this::areDependenciesMet)
                .collect(Collectors.toList());

        // Sort ready tasks: High > Medium > Low, then by ID
        readyTasks.sort(Comparator.comparing(Task::getPriority)
                                  .reversed() // Reverse for HIGH first (enum order is LOW, MEDIUM, HIGH)
                                  .thenComparing(Task::getId)); // Then by ID

        // Add sorted tasks to the queue
        processingQueue.addAll(readyTasks);

        return processingQueue;
    }


    /**
     * Processes the next available task from the queue.
     */
    public void processNextTask() {
        // Rebuild the queue based on current state before processing
        Queue<Task> processingQueue = buildProcessingQueue(); // Use Queue interface

        if (processingQueue.isEmpty()) {
            System.out.println("No tasks are ready to be processed.");
            return;
        }

        // Get the next task from the queue (highest priority, lowest ID)
        Task taskToProcess = processingQueue.poll(); // Use poll() from Queue interface

        System.out.println("Processing task: " + taskToProcess);
        taskToProcess.setCompleted(true); // Mark as completed in the main list
        System.out.println("Task " + taskToProcess.getId() + " marked as Completed.");
    }

    /**
     * Displays all tasks in the system.
     */
    public void viewTasks() {
        System.out.println("--- All Tasks ---");
        if (allTasks.isEmpty()) {
            System.out.println("No tasks in the system.");
        } else {
            for (Task task : allTasks) { // Iterate through the List
                System.out.println(task);
            }
        }
        System.out.println("-------------------");
    }
}

// Main application class
public class TaskManagementApp {

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in); // Use Scanner for input
        TaskManager taskManager = new TaskManager();

        System.out.println("--- Task Management System ---");

        // Class-wide exception handling for the main loop
        try {
            while (true) {
                printMenu();
                System.out.print("Enter choice: ");

                int choice = -1;
                try {
                    choice = Integer.parseInt(scanner.nextLine()); // Read full line to avoid issues
                } catch (NumberFormatException e) {
                    System.err.println("Invalid input. Please enter a number."); // Use System.err
                    continue; // Restart loop
                }

                // Use switch statement for menu control
                switch (choice) {
                    case 1: // Add Task
                        try {
                            System.out.print("Enter task description: ");
                            String description = scanner.nextLine();

                            System.out.print("Enter priority (1=High, 2=Medium, 3=Low): ");
                            int priorityValue = Integer.parseInt(scanner.nextLine());
                            TaskPriority priority = TaskPriority.fromValue(priorityValue); // Handles invalid value

                            System.out.print("Enter dependency IDs (comma-separated, or blank): ");
                            String dependencyInput = scanner.nextLine().trim();
                            List<Integer> dependencyIds = new ArrayList<>(); // Use ArrayList
                            if (!dependencyInput.isEmpty()) {
                                String[] idStrings = dependencyInput.split(",");
                                for (String idStr : idStrings) {
                                    dependencyIds.add(Integer.parseInt(idStr.trim())); // Handles NumberFormatException
                                }
                            }

                            taskManager.addTask(description, priority, dependencyIds);

                        } catch (IllegalArgumentException | NumberFormatException e) {
                            System.err.println("Error adding task: " + e.getMessage()); // Use System.err
                        }
                        break;

                    case 2: // View Tasks
                        taskManager.viewTasks();
                        break;

                    case 3: // Process Next Task
                        taskManager.processNextTask();
                        break;

                    case 4: // Exit
                        System.out.println("Exiting Task Management System. Goodbye!");
                        return; // Exit the program

                    default: // Invalid choice
                        System.err.println("Invalid choice. Please try again."); // Use System.err
                        break;
                }
                System.out.println(); // Add a blank line for readability
            }
        } catch (Exception e) {
            // Catch any unexpected errors in the main loop
            System.err.println("An unexpected error occurred: " + e.getMessage()); // Use System.err
            e.printStackTrace(); // Print stack trace for debugging unexpected errors
        } finally {
            scanner.close(); // Ensure scanner is closed
        }
    }

    private static void printMenu() {
        System.out.println("--- Task Management System ---");
        System.out.println("1. Add Task");
        System.out.println("2. View Tasks");
        System.out.println("3. Process Next Task");
        System.out.println("4. Exit");
    }
}
