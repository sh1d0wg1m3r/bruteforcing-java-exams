/*
 * Exam Question #1128
 * Generated on: 2025-05-12 17:28:51
 * Generated by: Account 2
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Restaurant Order Management System
 * 
 * **Scenario:**
 * 
 * You are tasked with developing a simplified backend system for managing orders in a small restaurant. The system should handle incoming orders, allow processing of orders by the kitchen, and provide views of both pending and completed orders.
 * 
 * **Requirements:**
 * 
 * 1.  **Classes:**
 *     *   Create a class `Order` to represent a customer order. It should contain:
 *         *   A unique integer `orderId`.
 *         *   A `List` of `String` representing the items in the order.
 *     *   Create a class `RestaurantSystem` that manages the orders. It should contain:
 *         *   A `Queue` to hold orders that are pending processing by the kitchen.
 *         *   A `List` to hold orders that have been completed.
 *         *   A mechanism to generate unique order IDs.
 * 
 * 2.  **Functionality:**
 *     *   The `RestaurantSystem` should provide the following operations via a simple command-line interface:
 *         *   **Add New Order:** Prompt the user for order items (e.g., as a comma-separated string). Create an `Order` object with a new unique ID and add it to the pending orders queue.
 *         *   **Process Next Order:** Take the oldest order from the pending queue and move it to the completed orders list.
 *         *   **View Pending Orders:** Display all orders currently in the pending queue without removing them.
 *         *   **View Completed Orders:** Display all orders currently in the completed list.
 *         *   **Exit:** Terminate the program.
 * 
 * 3.  **Implementation Details:**
 *     *   Use `java.util.Queue` for the pending orders queue.
 *     *   Use `java.util.ArrayList` for the completed orders list.
 *     *   Declare variables for the completed orders list using the `java.util.List` interface type.
 *     *   Use `java.util.Scanner` to read user input from the console.
 *     *   Implement a main menu loop using a `switch` statement to handle user choices (Add Order, Process Order, View Pending, View Completed, Exit, and a default for invalid input).
 *     *   Use `System.out` for normal program output (menu, confirmations, list displays).
 *     *   Use `System.err` to display error messages (e.g., attempting to process an order when the pending queue is empty, invalid menu choice, invalid input format).
 *     *   Implement class-wide exception handling using `try-catch` blocks to gracefully handle potential runtime errors, particularly related to user input (e.g., non-integer input when expecting an integer choice).
 * 
 * 4.  **Best Practices:**
 *     *   Apply proper encapsulation by making class fields private and providing public methods for access/modification where necessary.
 *     *   Use meaningful names for classes, variables, and methods.
 *     *   Include appropriate comments and documentation (e.g., Javadoc for classes and public methods).
 *     *   Implement basic input validation (e.g., check if the pending queue is empty before processing).
 *     *   Ensure proper error handling as specified.
 *     *   Maintain a clean and readable code structure.
 * 
 * **Expected Input/Output:**
 * 
 * The program should present a menu like this:
 * 
 * ```
 * Restaurant Order Management Menu:
 * 1. Add New Order
 * 2. Process Next Order
 * 3. View Pending Orders
 * 4. View Completed Orders
 * 5. Exit
 * Enter your choice:
 * ```
 * 
 * *   **Add New Order:** Prompts for items (e.g., "Enter comma-separated items:"). Prints confirmation like "Order X added to pending queue."
 * *   **Process Next Order:** If queue is not empty, prints confirmation like "Processed order X." If empty, prints error to `System.err`.
 * *   **View Pending Orders:** Lists pending orders or prints "No pending orders."
 * *   **View Completed Orders:** Lists completed orders or prints "No completed orders."
 * *   **Exit:** Prints "Exiting system." and terminates.
 * *   **Invalid Choice:** Prints error to `System.err` and shows the menu again.
 * *   **Input Errors:** If non-integer input is given for the choice, catches the exception, prints an error to `System.err`, and shows the menu again.
 * 
 * **Time Estimate:** This task is designed to be completed within approximately 45-60 minutes by a student with advanced Java knowledge.
 * 
 * **Submission:** Provide the complete Java code for the `Order` and `RestaurantSystem` classes, including the `main` method to run the system.
 *
 * EXPLANATION:
 * This solution implements a simple Restaurant Order Management System as requested, demonstrating the required Java concepts and best practices.
 * 
 * 1.  **`Order` Class:**
 *     *   Represents an individual order with `orderId` (an `int`) and `items` (a `List<String>`).
 *     *   Fields are `private` for encapsulation.
 *     *   A constructor initializes these fields.
 *     *   Getter methods (`getOrderId`, `getItems`) are provided. Note that `getItems` returns a *copy* of the list to prevent external modification of the internal state, which is a good practice.
 *     *   `toString()` is overridden for easy printing of order details.
 * 
 * 2.  **`RestaurantSystem` Class:**
 *     *   **Collections:**
 *         *   `pendingOrders`: Declared as `Queue<Order>` and initialized with `LinkedList<Order>`. `LinkedList` is a common implementation of the `Queue` interface and provides the required FIFO (First-In, First-Out) behavior for processing orders in the order they were received.
 *         *   `completedOrders`: Declared as `List<Order>` and initialized with `ArrayList<Order>`. `ArrayList` is a flexible, resizable array implementation of the `List` interface, suitable for storing completed orders where ordered access or iteration is needed. Using the `List` interface for the variable type (`List<Order> completedOrders`) promotes polymorphism.
 *     *   **State:** `nextOrderId` is a private field to keep track of the next available ID, ensuring unique IDs for each new order.
 *     *   **Input:** `scanner` is a `Scanner` object initialized to read from `System.in`.
 *     *   **Constructor:** Initializes the collections and the ID counter.
 *     *   **`displayMenu()`:** A helper method to print the menu options to `System.out`.
 *     *   **`addNewOrder()`:**
 *         *   Prompts the user for items using `System.out`.
 *         *   Reads the entire line using `scanner.nextLine()`.
 *         *   Performs basic input validation: checks if the input string is empty or results in an empty list after splitting, printing an error to `System.err` if invalid.
 *         *   Splits the comma-separated string into a `List<String>` using `Arrays.asList` and `split()`.
 *         *   Creates a new `Order` object using `nextOrderId++`.
 *         *   Adds the new order to the `pendingOrders` queue using `offer()`.
 *         *   Prints a confirmation message to `System.out`.
 *     *   **`processNextOrder()`:**
 *         *   Checks if `pendingOrders` is empty using `isEmpty()`. If so, prints an error to `System.err`.
 *         *   If not empty, it retrieves and removes the head of the queue using `poll()`.
 *         *   Adds the processed order to the `completedOrders` list using `add()`.
 *         *   Prints a confirmation message to `System.out`.
 *     *   **`viewPendingOrders()`:**
 *         *   Checks if the `pendingOrders` queue is empty and prints an appropriate message to `System.out`.
 *         *   If not empty, it iterates through the queue using a `for-each` loop and prints each order using `System.out`. Iterating a `Queue` typically uses its iterator and does *not* remove elements, which is the desired behavior here.
 *     *   **`viewCompletedOrders()`:**
 *         *   Checks if the `completedOrders` list is empty and prints an appropriate message to `System.out`.
 *         *   If not empty, it iterates through the list using a `for-each` loop and prints each order using `System.out`.
 *     *   **`run()`:**
 *         *   This is the main method controlling the application flow.
 *         *   It uses a `boolean isRunning` flag and a `while` loop to keep the program running until the user chooses to exit.
 *         *   **Class-wide Exception Handling:** The main `while` loop is wrapped in a `try-catch(Exception e)` block. This demonstrates catching unexpected runtime exceptions that might occur anywhere within the loop's execution, printing the error details to `System.err`.
 *         *   **Input Handling & Validation:** Inside the loop, it displays the menu and attempts to read the user's choice. A nested `try-catch(InputMismatchException e)` specifically handles cases where the user enters non-integer input, printing an error to `System.err` and consuming the invalid input using `scanner.next()` to prevent an infinite loop. The `finally` block after the inner `try-catch` ensures `scanner.nextLine()` is called to consume the newline character left by `scanner.nextInt()`, which is crucial for subsequent calls to `scanner.nextLine()` (like in `addNewOrder`) to work correctly.
 *         *   **`switch` Statement:** A `switch` statement is used to direct the flow based on the validated user choice, calling the appropriate methods.
 *         *   The `default` case in the `switch` handles invalid integer choices, printing an error message to `System.err`.
 *         *   The `finally` block outside the main loop ensures the `scanner` is closed when the `run` method finishes (either by exiting or due to an uncaught exception).
 *     *   **`main()`:** The entry point of the application, which creates a `RestaurantSystem` object and calls its `run()` method.
 * 
 * 3.  **Best Practices:**
 *     *   **Encapsulation:** Fields in `Order` and `RestaurantSystem` are `private`.
 *     *   **Naming:** Class names (`Order`, `RestaurantSystem`), variable names (`pendingOrders`, `completedOrders`, `nextOrderId`), and method names (`addNewOrder`, `processNextOrder`, `viewPendingOrders`, `run`) are descriptive.
 *     *   **Documentation:** Javadoc comments are provided for classes and public methods.
 *     *   **Input Validation:** Checks for empty order items and invalid menu input are included.
 *     *   **Error Handling:** `try-catch` blocks handle input format errors, `System.err` is used for error output, and `System.out` for normal output. Empty collection checks prevent runtime errors when processing/viewing.
 *     *   **Clean Structure:** The code is divided into logical classes and methods, making it readable and maintainable.
 * 
 * This solution effectively utilizes all the required Java components within a practical scenario, demonstrates standard practices for handling collections, input, and errors, and is structured in a way suitable for an exam setting.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.Arrays;
import java.util.InputMismatchException;

/**
 * Represents a single customer order with a unique ID and a list of items.
 */
class Order {
    private int orderId;
    private List<String> items;

    /**
     * Constructs a new Order.
     * @param orderId The unique identifier for the order.
     * @param items The list of items included in the order.
     */
    public Order(int orderId, List<String> items) {
        this.orderId = orderId;
        this.items = new ArrayList<>(items); // Create a defensive copy
    }

    /**
     * Gets the unique identifier of the order.
     * @return The order ID.
     */
    public int getOrderId() {
        return orderId;
    }

    /**
     * Gets the list of items in the order.
     * @return The list of items.
     */
    public List<String> getItems() {
        return new ArrayList<>(items); // Return a defensive copy
    }

    /**
     * Returns a string representation of the order.
     * @return A string detailing the order ID and its items.
     */
    @Override
    public String toString() {
        return "Order [ID=" + orderId + ", Items=" + items + "]";
    }
}

/**
 * Manages the restaurant's order processing system.
 * Handles adding new orders, processing pending orders, and viewing orders.
 */
public class RestaurantSystem {

    // Use Queue for pending orders (FIFO)
    private Queue<Order> pendingOrders;

    // Use List (specifically ArrayList) for completed orders
    private List<Order> completedOrders;

    // Counter for generating unique order IDs
    private int nextOrderId;

    private Scanner scanner;

    /**
     * Constructs a new RestaurantSystem.
     * Initializes the order queues and the order ID counter.
     */
    public RestaurantSystem() {
        this.pendingOrders = new LinkedList<>(); // LinkedList implements Queue
        this.completedOrders = new ArrayList<>(); // ArrayList implements List
        this.nextOrderId = 1;
        this.scanner = new Scanner(System.in);
    }

    /**
     * Displays the main menu options to the user.
     */
    private void displayMenu() {
        System.out.println("\nRestaurant Order Management Menu:");
        System.out.println("1. Add New Order");
        System.out.println("2. Process Next Order");
        System.out.println("3. View Pending Orders");
        System.out.println("4. View Completed Orders");
        System.out.println("5. Exit");
        System.out.print("Enter your choice: ");
    }

    /**
     * Adds a new order based on user input.
     */
    private void addNewOrder() {
        System.out.print("Enter comma-separated items for the order: ");
        String itemsInput = scanner.nextLine().trim();

        if (itemsInput.isEmpty()) {
            System.err.println("Error: Order items cannot be empty.");
            return;
        }

        List<String> items = Arrays.asList(itemsInput.split("\\s*,\\s*")); // Split by comma, handle spaces
        if (items.isEmpty() || (items.size() == 1 && items.get(0).isEmpty())) {
             System.err.println("Error: Order items cannot be empty after splitting.");
             return;
        }


        Order newOrder = new Order(nextOrderId++, items);
        pendingOrders.offer(newOrder); // offer() is preferred over add() for capacity-constrained queues, but works fine here

        System.out.println("Order " + newOrder.getOrderId() + " added to pending queue.");
    }

    /**
     * Processes the oldest pending order, moving it to the completed list.
     */
    private void processNextOrder() {
        if (pendingOrders.isEmpty()) {
            System.err.println("Error: No pending orders to process.");
            return;
        }

        Order processedOrder = pendingOrders.poll(); // poll() retrieves and removes the head
        completedOrders.add(processedOrder); // Add to the completed list

        System.out.println("Processed order " + processedOrder.getOrderId() + ".");
    }

    /**
     * Displays all orders currently in the pending queue.
     */
    private void viewPendingOrders() {
        System.out.println("\n--- Pending Orders ---");
        if (pendingOrders.isEmpty()) {
            System.out.println("No pending orders.");
        } else {
            // Iterating over the queue does not remove elements
            for (Order order : pendingOrders) {
                System.out.println(order);
            }
        }
        System.out.println("----------------------");
    }

    /**
     * Displays all orders currently in the completed list.
     */
    private void viewCompletedOrders() {
        System.out.println("\n--- Completed Orders ---");
        if (completedOrders.isEmpty()) {
            System.out.println("No completed orders.");
        } else {
            for (Order order : completedOrders) {
                System.out.println(order);
            }
        }
        System.out.println("------------------------");
    }

    /**
     * Runs the main application loop, handling user input and menu choices.
     * Includes class-wide exception handling for input errors.
     */
    public void run() {
        boolean isRunning = true;

        // Class-wide try-catch block for the main operational loop
        try {
            while (isRunning) {
                displayMenu();
                int choice = -1;
                try {
                    choice = scanner.nextInt();
                } catch (InputMismatchException e) {
                    System.err.println("Invalid input. Please enter a number.");
                    // Consume the invalid input to prevent infinite loop
                    scanner.next();
                    continue; // Skip the rest of the loop and show menu again
                } finally {
                     // Consume the rest of the line after reading the integer choice
                     // This is crucial if nextLine() is called later
                     scanner.nextLine();
                }


                // Use switch statement for menu navigation
                switch (choice) {
                    case 1:
                        addNewOrder();
                        break;
                    case 2:
                        processNextOrder();
                        break;
                    case 3:
                        viewPendingOrders();
                        break;
                    case 4:
                        viewCompletedOrders();
                        break;
                    case 5:
                        isRunning = false;
                        System.out.println("Exiting system.");
                        break;
                    default:
                        System.err.println("Invalid choice. Please enter a number between 1 and 5.");
                }
            }
        } catch (Exception e) {
            // Catch any unexpected exceptions during runtime
            System.err.println("An unexpected error occurred: " + e.getMessage());
            e.printStackTrace(System.err); // Print stack trace to error stream
        } finally {
            // Close the scanner when the application exits
            if (scanner != null) {
                scanner.close();
            }
        }
    }

    /**
     * Main method to start the Restaurant Order Management System.
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        RestaurantSystem system = new RestaurantSystem();
        system.run();
    }
}
