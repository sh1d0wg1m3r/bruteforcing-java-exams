/*
 * Exam Question #780
 * Generated on: 2025-05-12 16:39:38
 * Generated by: Account 4
 * 
 * QUESTION:
 * **Java Programming Exam Task: Print Queue Management System**
 * 
 * **Problem Description:**
 * 
 * You are tasked with developing a simple console-based Print Queue Management System. This system should allow users to submit print jobs, view the pending jobs, process the next job in the queue, and view a history of completed jobs.
 * 
 * The system should simulate a real-world scenario where print jobs are processed in a First-In, First-Out (FIFO) manner.
 * 
 * **Requirements:**
 * 
 * 1.  **`PrintJob` Class:**
 *     *   Create a class named `PrintJob`.
 *     *   It must have private fields for `jobId` (an integer, uniquely assigned), `user` (a String), and `pages` (an integer).
 *     *   Implement a constructor to initialize these fields. The `jobId` should be automatically generated (e.g., using a static counter).
 *     *   Provide public getter methods for all fields.
 *     *   Override the `toString()` method to provide a user-friendly representation of a print job (e.g., "Job ID: X, User: Y, Pages: Z").
 * 
 * 2.  **`PrintQueueManager` Class:**
 *     *   Create a class named `PrintQueueManager`.
 *     *   It must have a private field to store pending print jobs using a `java.util.Queue`.
 *     *   It must have a private field to store completed print jobs using a `java.util.List`. Declare the field using the `List` interface type, but instantiate it with `java.util.ArrayList`.
 *     *   Implement the following public methods:
 *         *   `submitJob(String user, int pages)`: Adds a new `PrintJob` to the pending queue. It should validate that `pages` is greater than 0. If not, print an error message and do not add the job. Print a success message upon successful submission.
 *         *   `viewQueue()`: Displays the list of pending jobs in the queue without removing them. Indicate if the queue is empty.
 *         *   `processNextJob()`: Removes the next job from the head of the pending queue and adds it to the completed jobs list. Print a confirmation message showing the processed job. If the queue is empty, print an error message.
 *         *   `viewCompletedJobs()`: Displays the list of completed jobs. Indicate if the completed list is empty.
 * 
 * 3.  **Main Application (`main` method):**
 *     *   Create a class (e.g., `PrintQueueSystem`) containing the `main` method.
 *     *   Inside `main`, instantiate a `PrintQueueManager` object.
 *     *   Use `java.util.Scanner` to get user input from the console.
 *     *   Implement a menu-driven interface with options:
 *         1.  Submit Print Job
 *         2.  View Pending Queue
 *         3.  Process Next Job
 *         4.  View Completed Jobs
 *         5.  Exit
 *     *   Use a `switch` statement to handle the user's menu choice.
 *     *   Implement a loop so the menu is repeatedly shown until the user chooses to exit.
 *     *   **Class-wide exception handling:** Use `try-catch` blocks to handle potential input errors (e.g., non-integer input when an integer is expected) and other runtime exceptions that might occur during operations.
 *     *   Use `System.out` for displaying the menu, prompts, success messages, and job lists.
 *     *   Use `System.err` for displaying all error messages (invalid input, invalid page count, empty queue errors).
 * 
 * 4.  **Required Components:** Your solution *must* explicitly use *all* of the following Java components:
 *     *   `java.util.Queue`
 *     *   `java.util.ArrayList`
 *     *   `java.util.List`
 *     *   `java.util.Scanner`
 *     *   `switch` statement
 *     *   `System.err`
 *     *   `System.out`
 *     *   `try-catch` blocks
 * 
 * 5.  **Best Practices:**
 *     *   Employ proper encapsulation (private fields, public methods).
 *     *   Use meaningful variable and method names.
 *     *   Include appropriate comments and documentation (basic Javadoc style is sufficient).
 *     *   Implement input validation (e.g., pages > 0).
 *     *   Implement proper error handling (using `try-catch` and checking for empty collections).
 *     *   Maintain a clean code structure.
 * 
 * **Expected Output:**
 * 
 * The program should interact with the user via the console, displaying a menu, prompting for input, and showing the results of operations or error messages as appropriate. Example interactions:
 * 
 * *   Submitting a job: Prompts for user and pages, then prints confirmation or error.
 * *   Viewing queue: Lists jobs in FIFO order or states queue is empty.
 * *   Processing job: Removes head, adds to completed, prints confirmation or error if queue empty.
 * *   Viewing completed: Lists completed jobs or states list is empty.
 * *   Invalid input: Prints error to `System.err`.
 * *   Invalid page count: Prints error to `System.err`.
 * *   Processing empty queue: Prints error to `System.err`.
 * 
 * Your code should be complete and runnable as a single file for submission purposes in an exam setting.
 *
 * EXPLANATION:
 * This solution implements a simple Print Queue Management System demonstrating the required Java concepts.
 * 
 * **Architecture:**
 * The system is structured into three classes:
 * 1.  `PrintJob`: Represents the data structure for a single print job, holding its unique ID, user, and page count. It follows encapsulation principles with private fields and public getters. A static counter ensures unique job IDs.
 * 2.  `PrintQueueManager`: Manages the collections of print jobs. It contains a `Queue` for jobs waiting to be processed (FIFO) and a `List` for jobs that have been completed. Its methods encapsulate the core logic: adding jobs, viewing jobs, and processing jobs.
 * 3.  `PrintQueueSystem`: Contains the `main` method, which acts as the application's entry point and user interface controller. It handles user input, drives the main loop, and interacts with the `PrintQueueManager`.
 * 
 * **Required Component Usage:**
 * 
 * *   **`java.util.Queue`**: The `pendingJobs` field in `PrintQueueManager` is declared as a `Queue`. This collection is used to store print jobs in a First-In, First-Out manner, perfectly simulating a print queue. Methods like `offer()` (to add) and `poll()` (to remove from the head) are used. `LinkedList` is used as the concrete implementation of the `Queue` interface.
 * *   **`java.util.ArrayList`**: The `completedJobs` field in `PrintQueueManager` is instantiated using `ArrayList`. This provides a dynamic array implementation to store the history of processed jobs.
 * *   **`java.util.List`**: The `completedJobs` field is declared using the `List` interface type. This promotes good practice by programming to the interface rather than the concrete implementation, making the code more flexible if a different `List` implementation were needed later.
 * *   **`java.util.Scanner`**: An instance of `Scanner` is used in the `main` method to read user input from `System.in` (the console). It's used to get the user's menu choice, user name, and number of pages.
 * *   **`switch` statement**: A `switch` statement in the `main` method is used to control the program flow based on the user's integer choice from the menu, directing execution to the corresponding action (submit, view queue, process, view completed, exit).
 * *   **`System.err`**: Used specifically for printing error messages, such as invalid user input, invalid page counts during job submission, or attempting to process a job when the queue is empty. This directs error output to the standard error stream, which is good practice for separating normal output from errors.
 * *   **`System.out`**: Used for all standard output, including displaying the menu, prompts for input, confirmation messages for successful operations (job submission, processing), and listing the contents of the pending queue and completed jobs list.
 * *   **`try-catch` blocks**: Used in the `main` method to provide robust exception handling. A `try` block encloses the code that might throw exceptions, specifically `scanner.nextInt()` which can throw `InputMismatchException` if the user enters non-integer text. A `catch (InputMismatchException e)` block handles this specific error, prints a message to `System.err`, and consumes the invalid input using `scanner.nextLine()` to prevent an infinite loop. A general `catch (Exception e)` is also included to catch any other unexpected runtime errors, printing a message to `System.err`.
 * 
 * **Best Practices and Error Handling:**
 * 
 * *   **Encapsulation:** `PrintJob` and `PrintQueueManager` classes hide their internal state (private fields) and expose functionality through public methods.
 * *   **Meaningful Names:** Classes, variables, and methods have names that clearly indicate their purpose (e.g., `pendingJobs`, `submitJob`, `processNextJob`).
 * *   **Comments and Documentation:** Basic Javadoc-style comments explain the purpose of classes and methods, and inline comments clarify specific code logic.
 * *   **Input Validation:** The `submitJob` method explicitly checks if the number of pages is greater than 0, rejecting invalid jobs and reporting the error via `System.err`. The `try-catch` block in `main` handles validation of the *type* of input (ensuring numbers are entered where expected).
 * *   **Error Handling:**
 *     *   Checking `pendingJobs.isEmpty()` before attempting to process a job prevents `NoSuchElementException` (which `remove()` would throw) and allows printing a user-friendly error message via `System.err`.
 *     *   The `try-catch` block in `main` catches input errors (`InputMismatchException`) and general exceptions, preventing the program from crashing due to invalid user input or unexpected issues. Error messages are directed to `System.err`.
 * *   **Clean Code Structure:** The code is organized into logical classes, and the `main` method provides a clear loop and `switch` structure for the user interface. A separate `printMenu` method keeps the `main` method cleaner. The `Scanner` resource is closed when the program exits.
 * 
 * This solution effectively integrates the required Java components within a practical scenario, demonstrating understanding of collection types, control flow, basic I/O, object-oriented principles, and robust error handling.
 */

import java.util.Queue;
import java.util.LinkedList; // A common implementation for Queue
import java.util.List;
import java.util.ArrayList; // Required implementation for List
import java.util.Scanner;
import java.util.InputMismatchException; // For handling non-integer input

// Represents a single print job
class PrintJob {
    private static int nextJobId = 1; // Static counter for unique job IDs
    private final int jobId;
    private final String user;
    private final int pages;

    /**
     * Constructs a new PrintJob.
     * @param user The user submitting the job.
     * @param pages The number of pages in the job.
     */
    public PrintJob(String user, int pages) {
        this.jobId = nextJobId++; // Assign unique ID and increment counter
        this.user = user;
        this.pages = pages;
    }

    // --- Getters ---
    public int getJobId() {
        return jobId;
    }

    public String getUser() {
        return user;
    }

    public int getPages() {
        return pages;
    }

    /**
     * Provides a string representation of the PrintJob.
     * @return String representation of the job.
     */
    @Override
    public String toString() {
        return "Job ID: " + jobId + ", User: " + user + ", Pages: " + pages;
    }
}

// Manages the print queue and completed jobs
class PrintQueueManager {
    // Use Queue for pending jobs (FIFO)
    private Queue<PrintJob> pendingJobs = new LinkedList<>();
    // Use List (ArrayList) for completed jobs
    private List<PrintJob> completedJobs = new ArrayList<>();

    /**
     * Submits a new print job to the pending queue.
     * Validates that the number of pages is positive.
     * @param user The user submitting the job.
     * @param pages The number of pages in the job.
     */
    public void submitJob(String user, int pages) {
        if (pages <= 0) {
            System.err.println("Error: Number of pages must be greater than 0.");
            return; // Do not submit the job if validation fails
        }

        PrintJob newJob = new PrintJob(user, pages);
        // offer() is preferred for queues as it handles capacity constraints gracefully
        if (pendingJobs.offer(newJob)) {
            System.out.println("Job submitted successfully: " + newJob);
        } else {
            // This case is unlikely with LinkedList but good practice for bounded queues
            System.err.println("Error: Failed to submit job. Queue might be full.");
        }
    }

    /**
     * Displays the current pending print queue without removing elements.
     */
    public void viewQueue() {
        System.out.println("\n--- Pending Print Queue ---");
        if (pendingJobs.isEmpty()) {
            System.out.println("Queue is empty.");
        } else {
            int index = 1;
            // Iterate through the queue elements
            for (PrintJob job : pendingJobs) {
                System.out.println(index++ + ". " + job);
            }
        }
        System.out.println("---------------------------\n");
    }

    /**
     * Processes the next job from the head of the pending queue.
     * Removes the job from pending and adds it to the completed list.
     */
    public void processNextJob() {
        System.out.println("\n--- Processing Next Job ---");
        if (pendingJobs.isEmpty()) {
            System.err.println("Error: No jobs in the queue to process.");
        } else {
            // poll() retrieves and removes the head of the queue, returns null if empty
            PrintJob processedJob = pendingJobs.poll();
            if (processedJob != null) {
                completedJobs.add(processedJob); // Add to the completed list
                System.out.println("Successfully processed job: " + processedJob);
            } else {
                 // This else block should theoretically not be reached because of the isEmpty() check,
                 // but included for robustness.
                 System.err.println("Internal Error: poll() returned null unexpectedly.");
            }
        }
        System.out.println("---------------------------\n");
    }

    /**
     * Displays the list of completed print jobs.
     */
    public void viewCompletedJobs() {
        System.out.println("\n--- Completed Print Jobs ---");
        if (completedJobs.isEmpty()) {
            System.out.println("No jobs completed yet.");
        } else {
            int index = 1;
            // Iterate through the completed jobs list
            for (PrintJob job : completedJobs) {
                System.out.println(index++ + ". " + job);
            }
        }
        System.out.println("---------------------------\n");
    }
}

// Main class to run the Print Queue Management System
public class PrintQueueSystem {

    /**
     * Prints the main menu options to the console.
     */
    private static void printMenu() {
        System.out.println("\n--- Print Queue Menu ---");
        System.out.println("1. Submit Print Job");
        System.out.println("2. View Pending Queue");
        System.out.println("3. Process Next Job");
        System.out.println("4. View Completed Jobs");
        System.out.println("5. Exit");
        System.out.println("------------------------");
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        PrintQueueManager manager = new PrintQueueManager();
        boolean running = true;

        System.out.println("Welcome to the Print Queue Management System!");

        while (running) {
            printMenu();
            System.out.print("Enter your choice: ");

            try {
                int choice = scanner.nextInt();
                scanner.nextLine(); // Consume the newline character left by nextInt()

                switch (choice) {
                    case 1: // Submit Job
                        System.out.print("Enter user name: ");
                        String user = scanner.nextLine();
                        System.out.print("Enter number of pages: ");
                        int pages = scanner.nextInt();
                        scanner.nextLine(); // Consume the newline character
                        manager.submitJob(user, pages); // Validation happens inside manager method
                        break;
                    case 2: // View Queue
                        manager.viewQueue();
                        break;
                    case 3: // Process Next Job
                        manager.processNextJob();
                        break;
                    case 4: // View Completed Jobs
                        manager.viewCompletedJobs();
                        break;
                    case 5: // Exit
                        running = false;
                        System.out.println("Exiting Print Queue Manager. Goodbye!");
                        break;
                    default:
                        // Handle choices outside the valid range
                        System.err.println("Invalid choice. Please enter a number between 1 and 5.");
                }
            } catch (InputMismatchException e) {
                // Handle cases where non-integer input is provided for choice or pages
                System.err.println("Invalid input. Please enter a number for your choice or page count.");
                scanner.nextLine(); // Consume the invalid input to prevent an infinite loop
            } catch (Exception e) {
                // Catch any other unexpected runtime exceptions
                System.err.println("An unexpected error occurred: " + e.getMessage());
                // e.printStackTrace(System.err); // Uncomment for detailed debugging output
            }
        }

        scanner.close(); // Close the scanner when the application exits
    }
}
