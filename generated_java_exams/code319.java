/*
 * Exam Question #319
 * Generated on: 2025-05-11 22:54:36
 * Generated by: Account 1
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Team Task Management System
 * 
 * **Scenario:**
 * 
 * You are tasked with building a simplified console-based application to manage tasks for a small team. Tasks are added to a queue and processed in a First-In, First-Out (FIFO) manner. When a task is processed, it is assigned to the next available team member. Once a team member completes their assigned task, they become available again.
 * 
 * **Requirements:**
 * 
 * Implement a Java program that provides the following functionality:
 * 
 * 1.  **Task Representation:** Create a `Task` class with fields for `name` (String) and `priority` (String - e.g., "High", "Medium", "Low").
 * 2.  **Team Member Representation:** Create a `TeamMember` class with fields for `name` (String) and `isBusy` (boolean).
 * 3.  **Core System Class:** Create a main class (e.g., `TaskManagementSystem`) that manages the task queue and the list of team members.
 * 4.  **Data Structures:**
 *     *   Use a `java.util.Queue<Task>` to hold tasks waiting to be processed.
 *     *   Use a `java.util.List<TeamMember>` (implemented by `java.util.ArrayList`) to manage the team members.
 * 5.  **User Interface:** Implement a simple text-based menu with the following options:
 *     *   `1. Add New Task`: Prompt the user for task name and priority, create a `Task` object, and add it to the task queue.
 *     *   `2. View Task Queue`: Display all tasks currently waiting in the queue, in their current order. Do not remove tasks from the queue.
 *     *   `3. Process Next Task`:
 *         *   Check if the task queue is empty. If so, display an error.
 *         *   Check if any team member is available (`isBusy` is false). If not, display an error.
 *         *   If both are available, take the next task from the front of the queue, find the first available team member, mark that member as busy, and display which task was assigned to which member.
 *     *   `4. View Team Status`: Display the name and status (Busy/Available) of all team members.
 *     *   `5. Mark Task Completed`: Prompt the user for the name of a team member. Find the member and mark them as available (`isBusy` is false). Display a confirmation message. Handle cases where the member is not found or is not currently busy.
 *     *   `6. Exit`: Terminate the program.
 * 6.  **Input Handling:** Use `java.util.Scanner` to read user input for menu choices and task/member details.
 * 7.  **Flow Control:** Use a `switch` statement to handle the different menu options.
 * 8.  **Error Handling:**
 *     *   Use `System.err.println()` to display error messages (e.g., invalid menu choice, empty queue, no available members, member not found/not busy).
 *     *   Implement input validation where appropriate (e.g., basic check for empty task name, valid priority, valid member name for completion).
 *     *   Implement class-wide exception handling by wrapping the main application loop within a `try-catch` block in the `main` method or a dedicated `run` method. Catch potential unexpected exceptions.
 * 9.  **Output:** Use `System.out.println()` for normal output (menu, prompts, confirmations, status).
 * 10. **Best Practices:**
 *     *   Employ proper encapsulation (private fields, public methods) in your classes.
 *     *   Use meaningful variable and method names.
 *     *   Include appropriate comments (including Javadoc-style comments for classes and methods).
 *     *   Structure your code cleanly with separate methods for different functionalities.
 * 
 * **Expected Output:**
 * 
 * The program should display a menu, accept user input, and perform the requested actions, printing output to `System.out` and errors to `System.err` as described above. The menu should loop until the 'Exit' option is chosen.
 * 
 * ```
 * --- Task Management Menu ---
 * 1. Add New Task
 * 2. View Task Queue
 * 3. Process Next Task
 * 4. View Team Status
 * 5. Mark Task Completed
 * 6. Exit
 * Enter your choice: 1
 * --- Add New Task ---
 * Enter task name: Design Database
 * Enter task priority (High, Medium, Low): High
 * Task added to queue: Task [Name=Design Database, Priority=High]
 * 
 * --- Task Management Menu ---
 * ... (user selects 3)
 * --- Process Next Task ---
 * Processing task: 'Design Database' (Priority: High)
 * Assigned to: Alice
 * 
 * --- Task Management Menu ---
 * ... (user selects 4)
 * --- Team Status ---
 * Member [Name=Alice, Status=Busy]
 * Member [Name=Bob, Status=Available]
 * Member [Name=Charlie, Status=Available]
 * 
 * --- Task Management Menu ---
 * ... (user selects 5)
 * --- Mark Task Completed ---
 * Enter the name of the team member who completed the task: Alice
 * Task marked completed for 'Alice'. They are now available.
 * 
 * --- Task Management Menu ---
 * ... (user selects 6)
 * Exiting Task Management System. Goodbye!
 * ```
 * 
 * *(Note: The exact output may vary based on the order of operations and initial team members, but the structure and messages should be similar)*
 *
 * EXPLANATION:
 * This solution implements a simple Task Management System demonstrating the required Java concepts and best practices.
 * 
 * 1.  **`Task` and `TeamMember` Classes:** These are simple Plain Old Java Objects (POJOs) representing the core entities. They use private fields (`name`, `priority`, `isBusy`) and public getter/setter methods (`getName`, `getPriority`, `isBusy`, `setBusy`) to enforce encapsulation. The `toString()` method is overridden for easy printing of object details.
 * 
 * 2.  **`TaskManagementSystem` Class:** This is the main class containing the application logic.
 *     *   **Collections:**
 *         *   `taskQueue`: Declared as `Queue<Task>` and initialized with `new LinkedList<>()`. `LinkedList` is a common implementation of the `Queue` interface, providing FIFO behavior suitable for a waiting list of tasks. Tasks are added using `offer()` and removed from the front using `poll()`. Iteration is used in `viewTaskQueue` to display elements without removing them.
 *         *   `teamMembers`: Declared as `List<TeamMember>` and initialized with `new ArrayList<>()`. `ArrayList` is a dynamic array implementation of the `List` interface, suitable for storing and accessing team members by index or iterating through them to find availability or search by name.
 *     *   **`Scanner`:** An instance of `java.util.Scanner` is used to read user input from the console (`System.in`). It's initialized once in the constructor and closed in the `finally` block.
 *     *   **Methods:** The class is structured with private methods (`displayMenu`, `addNewTask`, `viewTaskQueue`, `processNextTask`, `findAvailableMember`, `viewTeamStatus`, `markTaskCompleted`, `findMemberByName`) to break down the functionality, promoting modularity and readability.
 *     *   **`run()` Method:** This method contains the main application loop (`while(running)`). It repeatedly displays the menu, reads user input, and processes the choice.
 *     *   **`main()` Method:** The standard entry point, which simply creates an instance of `TaskManagementSystem` and calls its `run()` method.
 * 
 * 3.  **Flow Control (`switch`):** The `run()` method uses a `switch` statement based on the user's integer choice to direct execution to the appropriate private method (`addNewTask`, `viewTaskQueue`, etc.).
 * 
 * 4.  **Input Handling and Validation:**
 *     *   `scanner.nextLine()` is used to read entire lines of input, which is safer than `nextInt()` or `nextDouble()` when mixing with `nextLine()`. `trim()` is used to remove leading/trailing whitespace.
 *     *   Basic validation is performed: checking for empty strings for task/member names and checking if the priority string matches expected values (case-insensitive). Error messages for invalid input are printed to `System.err`.
 *     *   A `try-catch` block specifically handles `NumberFormatException` when parsing the menu choice input, guiding the user to enter a valid number.
 * 
 * 5.  **Error Handling (`System.err` and `try-catch`):**
 *     *   `System.err.println()` is used for all error messages (e.g., "Error: Queue is empty.", "Error: Invalid choice."). This separates error output from normal application output, which is a good practice.
 *     *   The `run()` method wraps the entire `while` loop in a `try-catch(Exception e)`. This serves as a "class-wide" or application-level exception handler as required. While in a production system you might catch more specific exceptions or handle them differently, this demonstrates the ability to contain potential errors that might propagate up from the operational methods. The `finally` block ensures the `Scanner` resource is closed regardless of whether the loop finishes normally or an exception occurs. Specific operational methods (`processNextTask`, `markTaskCompleted`) also perform pre-condition checks (e.g., queue empty, member available/found) and use `System.err` for those specific, expected error conditions.
 * 
 * 6.  **Best Practices:**
 *     *   Encapsulation is used in `Task` and `TeamMember`.
 *     *   Method and variable names are descriptive (e.g., `findAvailableMember`, `taskQueue`).
 *     *   Javadoc-style comments explain the purpose of classes and methods.
 *     *   Code is organized into logical methods.
 *     *   Input validation and error handling are implemented using `try-catch` and conditional checks with `System.err`.
 * 
 * This solution effectively combines the required Java components within a practical scenario, demonstrating understanding of data structures, control flow, object-oriented principles, and error handling techniques suitable for an advanced Java exam.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;

/**
 * Represents a task with a name and priority.
 */
class Task {
    private String name;
    private String priority; // Could be an enum for stronger type safety, but String meets basic requirements

    /**
     * Constructs a new Task.
     * @param name The name of the task.
     * @param priority The priority of the task (e.g., High, Medium, Low).
     */
    public Task(String name, String priority) {
        this.name = name;
        this.priority = priority;
    }

    /**
     * Gets the name of the task.
     * @return The task name.
     */
    public String getName() {
        return name;
    }

    /**
     * Gets the priority of the task.
     * @return The task priority.
     */
    public String getPriority() {
        return priority;
    }

    /**
     * Returns a string representation of the task.
     * @return A string describing the task.
     */
    @Override
    public String toString() {
        return "Task [Name=" + name + ", Priority=" + priority + "]";
    }
}

/**
 * Represents a team member with a name and busy status.
 */
class TeamMember {
    private String name;
    private boolean isBusy;

    /**
     * Constructs a new TeamMember.
     * @param name The name of the team member.
     */
    public TeamMember(String name) {
        this.name = name;
        this.isBusy = false; // Initially not busy
    }

    /**
     * Gets the name of the team member.
     * @return The member's name.
     */
    public String getName() {
        return name;
    }

    /**
     * Checks if the team member is busy.
     * @return true if the member is busy, false otherwise.
     */
    public boolean isBusy() {
        return isBusy;
    }

    /**
     * Sets the busy status of the team member.
     * @param busy The new busy status (true for busy, false for available).
     */
    public void setBusy(boolean busy) {
        this.isBusy = busy;
    }

    /**
     * Returns a string representation of the team member and their status.
     * @return A string describing the team member.
     */
    @Override
    public String toString() {
        return "Member [Name=" + name + ", Status=" + (isBusy ? "Busy" : "Available") + "]";
    }
}

/**
 * Main class for the Task Management System. Manages tasks in a queue and team members in a list.
 */
public class TaskManagementSystem {

    private Queue<Task> taskQueue;
    private List<TeamMember> teamMembers;
    private Scanner scanner;

    /**
     * Constructs a new TaskManagementSystem, initializing collections and default team members.
     */
    public TaskManagementSystem() {
        // Use LinkedList as an implementation of Queue for FIFO behavior
        this.taskQueue = new LinkedList<>();
        // Use ArrayList as an implementation of List for managing team members
        this.teamMembers = new ArrayList<>();
        this.scanner = new Scanner(System.in);

        // Initialize some default team members
        teamMembers.add(new TeamMember("Alice"));
        teamMembers.add(new TeamMember("Bob"));
        teamMembers.add(new TeamMember("Charlie"));
        teamMembers.add(new TeamMember("David"));
    }

    /**
     * Displays the main menu options to the user.
     */
    private void displayMenu() {
        System.out.println("\n--- Task Management Menu ---");
        System.out.println("1. Add New Task");
        System.out.println("2. View Task Queue");
        System.out.println("3. Process Next Task");
        System.out.println("4. View Team Status");
        System.out.println("5. Mark Task Completed");
        System.out.println("6. Exit");
        System.out.print("Enter your choice: ");
    }

    /**
     * Handles adding a new task based on user input.
     * Prompts for task name and priority and adds it to the queue.
     * Includes basic input validation.
     */
    private void addNewTask() {
        System.out.println("\n--- Add New Task ---");
        System.out.print("Enter task name: ");
        // Read the entire line for task name
        String name = scanner.nextLine().trim();

        if (name.isEmpty()) {
            System.err.println("Error: Task name cannot be empty.");
            return; // Exit method if input is invalid
        }

        System.out.print("Enter task priority (High, Medium, Low): ");
        String priority = scanner.nextLine().trim();

        // Basic validation for priority (case-insensitive)
        if (!priority.equalsIgnoreCase("High") && !priority.equalsIgnoreCase("Medium") && !priority.equalsIgnoreCase("Low")) {
             System.err.println("Error: Invalid priority. Please use High, Medium, or Low.");
             return; // Exit method if input is invalid
        }

        Task newTask = new Task(name, priority);
        // Use offer() to add the task to the end of the queue
        taskQueue.offer(newTask);
        System.out.println("Task added to queue: " + newTask);
    }

    /**
     * Displays all tasks currently waiting in the queue without removing them.
     */
    private void viewTaskQueue() {
        System.out.println("\n--- Task Queue ---");
        if (taskQueue.isEmpty()) {
            System.out.println("Queue is empty. No tasks waiting.");
        } else {
            // Iterate through the queue elements. The Queue interface allows iteration.
            int index = 1;
            for (Task task : taskQueue) {
                System.out.println(index++ + ". " + task);
            }
        }
    }

    /**
     * Processes the next task from the queue by assigning it to the first available team member.
     * Handles cases where the queue is empty or no members are available.
     */
    private void processNextTask() {
        System.out.println("\n--- Process Next Task ---");

        // Check if there are tasks to process
        if (taskQueue.isEmpty()) {
            System.err.println("Error: No tasks in the queue to process.");
            return; // Exit method
        }

        // Find an available team member
        TeamMember availableMember = findAvailableMember();
        if (availableMember == null) {
            System.err.println("Error: No team members available to process tasks.");
            return; // Exit method
        }

        // Get the next task from the front of the queue using poll()
        Task taskToProcess = taskQueue.poll();

        // Assign the task to the found available member
        availableMember.setBusy(true);

        System.out.println("Processing task: '" + taskToProcess.getName() + "' (Priority: " + taskToProcess.getPriority() + ")");
        System.out.println("Assigned to: " + availableMember.getName());
    }

    /**
     * Searches the list of team members for the first one who is not busy.
     * @return The first available TeamMember object, or null if all members are busy.
     */
    private TeamMember findAvailableMember() {
        // Iterate through the List of team members
        for (TeamMember member : teamMembers) {
            if (!member.isBusy()) {
                return member; // Return the first available member found
            }
        }
        return null; // Return null if no available member is found after checking all
    }

     /**
     * Displays the current status (Busy/Available) of all team members.
     */
    private void viewTeamStatus() {
        System.out.println("\n--- Team Status ---");
        if (teamMembers.isEmpty()) {
             System.out.println("No team members registered.");
             return;
        }
        // Iterate through the List of team members and print their status
        for (TeamMember member : teamMembers) {
            System.out.println(member);
        }
    }

    /**
     * Marks a task as completed for a specific team member, making them available again.
     * Prompts the user for the member's name and updates their status.
     * Handles cases where the member is not found or is not busy.
     */
    private void markTaskCompleted() {
        System.out.println("\n--- Mark Task Completed ---");
        System.out.print("Enter the name of the team member who completed the task: ");
        String memberName = scanner.nextLine().trim();

        if (memberName.isEmpty()) {
             System.err.println("Error: Member name cannot be empty.");
             return; // Exit method if input is invalid
        }

        // Find the team member by name
        TeamMember member = findMemberByName(memberName);

        // Handle different scenarios based on the search result and member status
        if (member == null) {
            System.err.println("Error: Team member '" + memberName + "' not found.");
        } else if (!member.isBusy()) {
            System.err.println("Error: Team member '" + memberName + "' is not currently busy.");
        } else {
            // Mark the member as not busy
            member.setBusy(false);
            System.out.println("Task marked completed for '" + memberName + "'. They are now available.");
        }
    }

     /**
     * Searches the list of team members for a member with the given name (case-insensitive).
     * @param name The name of the member to find.
     * @return The TeamMember object if found, otherwise null.
     */
    private TeamMember findMemberByName(String name) {
        // Iterate through the List of team members
        for (TeamMember member : teamMembers) {
            if (member.getName().equalsIgnoreCase(name)) {
                return member; // Return the member if name matches (case-insensitive)
            }
        }
        return null; // Return null if no member with the given name is found
    }

    /**
     * Runs the main application loop, displaying the menu and handling user input.
     * Includes class-wide exception handling for the main loop.
     */
    public void run() {
        boolean running = true;

        // Class-wide exception handling for the main application loop
        try {
            while (running) {
                displayMenu();
                String choiceInput = scanner.nextLine().trim();
                int choice = -1; // Default invalid choice

                // Handle potential NumberFormatException for menu input
                try {
                    choice = Integer.parseInt(choiceInput);
                } catch (NumberFormatException e) {
                    System.err.println("Invalid input. Please enter a number.");
                    continue; // Skip the rest of the loop iteration and show menu again
                }

                // Use switch statement to handle menu choices
                switch (choice) {
                    case 1:
                        addNewTask();
                        break;
                    case 2:
                        viewTaskQueue();
                        break;
                    case 3:
                        processNextTask();
                        break;
                    case 4:
                        viewTeamStatus();
                        break;
                    case 5:
                        markTaskCompleted();
                        break;
                    case 6:
                        System.out.println("Exiting Task Management System. Goodbye!");
                        running = false; // Set flag to exit the loop
                        break;
                    default:
                        // Handle invalid number input outside the valid range
                        System.err.println("Invalid choice. Please enter a number between 1 and 6.");
                }
            }
        } catch (Exception e) {
            // Catch any unexpected exceptions that might occur during the main loop execution
            System.err.println("An unexpected error occurred during application execution: " + e.getMessage());
            // Print stack trace for debugging purposes in an exam/development setting
            e.printStackTrace();
        } finally {
            // Ensure the scanner resource is closed when the application exits (either normally or due to exception)
            if (scanner != null) {
                scanner.close();
                System.out.println("Scanner closed."); // Optional: confirmation
            }
        }
    }

    /**
     * The main entry point of the application.
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        TaskManagementSystem system = new TaskManagementSystem();
        system.run(); // Start the application loop
    }
}
