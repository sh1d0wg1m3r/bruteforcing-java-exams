/*
 * Exam Question #513
 * Generated on: 2025-05-11 23:22:35
 * Generated by: Account 2
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Document Processing System
 * 
 * **Problem Description:**
 * 
 * You are tasked with building a simple text-based Document Processing System. This system should manage a queue of documents waiting to be processed and maintain a history of documents that have been processed. Users will interact with the system via a menu to add documents, process the next document in the queue, view pending documents, view processed documents, or exit.
 * 
 * Each document has a name and a specific type. The system should only accept documents of predefined types. Processing a document involves removing it from the queue and adding it to the processed list, simulating the action based on its type.
 * 
 * **Requirements:**
 * 
 * 1.  **Implement a `Document` class:**
 *     *   It should have private fields for `name` (String) and `type` (String).
 *     *   Provide a constructor to initialize these fields.
 *     *   Include public getter methods for `name` and `type`.
 *     *   Override the `toString()` method for easy printing of document details.
 * 
 * 2.  **Implement a `DocumentProcessor` class:**
 *     *   It should manage the system's state using:
 *         *   A `Queue<Document>` to hold documents waiting for processing (pending documents).
 *         *   A `List<Document>` (implemented using `ArrayList`) to store documents that have been processed.
 *     *   Include a `Scanner` object to read user input from the console.
 *     *   Define a list of valid document types (e.g., "Scan", "Print", "Archive").
 *     *   Implement the following public methods:
 *         *   `addDocument()`: Prompts the user for document name and type, validates the type against the list of valid types, creates a `Document` object, and adds it to the pending documents queue. If the type is invalid, print an error message using `System.err` and do not add the document.
 *         *   `processNextDocument()`: Removes the document at the front of the pending documents queue, simulates processing (e.g., prints a message based on type using a `switch` statement), and adds it to the processed documents list. If the queue is empty, print a message to `System.out` indicating that there are no documents to process.
 *         *   `viewPendingDocuments()`: Prints the details of all documents currently in the pending documents queue. Print a message to `System.out` if the queue is empty.
 *         *   `viewProcessedDocuments()`: Prints the details of all documents in the processed documents list. Print a message to `System.out` if the list is empty.
 *         *   `run()`: Contains the main application loop. It should repeatedly display a menu, read the user's choice using the `Scanner`, and use a `switch` statement to call the appropriate method (`addDocument`, `processNextDocument`, `viewPendingDocuments`, `viewProcessedDocuments`) or exit. Handle invalid menu choices (non-integer input or out-of-range numbers) with informative error messages using `System.err`.
 *     *   Implement **class-wide exception handling** using `try-catch` blocks within the `run()` method to catch potential unexpected runtime errors during the main application loop. Print an error message to `System.err` if an unexpected exception occurs. Ensure the `Scanner` is closed when the application exits or an error occurs.
 * 
 * 3.  **Main method:** Create a `main` method in the `DocumentProcessor` class (or a separate main class) to instantiate `DocumentProcessor` and call its `run()` method to start the application.
 * 
 * 4.  **Best Practices:**
 *     *   Use meaningful variable and method names.
 *     *   Apply proper encapsulation (private fields, public methods).
 *     *   Include appropriate comments to explain complex logic.
 *     *   Ensure clean code structure.
 * 
 * **Menu Options:**
 * 
 * 1.  Add Document
 * 2.  Process Next Document
 * 3.  View Pending Documents
 * 4.  View Processed Documents
 * 5.  Exit
 * 
 * **Valid Document Types:**
 * 
 * "Scan", "Print", "Archive"
 * 
 * **Expected Output:**
 * 
 * The system should provide clear prompts for input and informative output for operations, including messages for empty queues/lists and error messages for invalid input or unexpected issues using `System.err`. The interaction should follow the menu structure.
 * 
 * Example Interaction Snippet:
 * 
 * ```
 * --- Document Processing System Menu ---
 * 1. Add Document
 * ...
 * Enter your choice: 1
 * Enter document name: Report.pdf
 * Enter document type (Scan, Print, Archive): Print
 * Document added to the queue: Document [Name: Report.pdf, Type: Print]
 * 
 * --- Document Processing System Menu ---
 * ...
 * Enter your choice: 2
 * Processing document: Document [Name: Report.pdf, Type: Print]
 * Simulating printing...
 * Document processing complete.
 * 
 * --- Document Processing System Menu ---
 * ...
 * Enter your choice: 3
 * No pending documents.
 * 
 * --- Document Processing System Menu ---
 * ...
 * Enter your choice: 4
 * --- Processed Documents ---
 * 1. Document [Name: Report.pdf, Type: Print]
 * ---------------------------
 * 
 * --- Document Processing System Menu ---
 * ...
 * Enter your choice: invalid
 * Invalid input. Please enter a number.
 * 
 * --- Document Processing System Menu ---
 * ...
 * Enter your choice: 6
 * Invalid choice. Please enter a number between 1 and 5.
 * 
 * --- Document Processing System Menu ---
 * ...
 * Enter your choice: 5
 * Exiting Document Processing System. Goodbye!
 * ```
 *
 * EXPLANATION:
 * This solution implements a `Document Processing System` as described, demonstrating the required Java concepts and best practices.
 * 
 * 1.  **`Document` Class:** This simple class encapsulates the data for a document (`name` and `type`). It follows encapsulation principles with private fields and public getters. The `toString()` method is overridden for convenient printing.
 * 
 * 2.  **`DocumentProcessor` Class:** This is the core class managing the system logic.
 *     *   **`Queue<Document> pendingDocuments`:** A `Queue` is used here because documents are processed in the order they are added (First-In, First-Out - FIFO). `LinkedList` is a common and suitable implementation for the `Queue` interface. The `offer()` method is used for adding, and `poll()` for removing, which are standard `Queue` operations.
 *     *   **`List<Document> processedDocuments`:** A `List` (specifically `ArrayList`) is used to store processed documents. A `List` is suitable because we need to maintain the order of processing and potentially iterate through the history of processed documents. `ArrayList` provides dynamic resizing and efficient element access.
 *     *   **`Scanner scanner`:** Used to read input from `System.in` for menu choices and document details.
 *     *   **`VALID_DOCUMENT_TYPES`:** A `List` (created using `Arrays.asList()`) stores the allowed document types, enabling easy validation using the `contains()` method.
 *     *   **`addDocument()`:** Handles user input for document details. It includes input validation to ensure the entered type is one of the `VALID_DOCUMENT_TYPES`. An error message is printed to `System.err` for invalid types, and the method returns without adding the document.
 *     *   **`processNextDocument()`:** Demonstrates queue operations. It checks if the queue is empty using `isEmpty()` before calling `poll()` to avoid errors. A `switch` statement is used to simulate different processing actions based on the document's type, fulfilling the requirement to use a `switch`. The processed document is then added to the `processedDocuments` list.
 *     *   **`viewPendingDocuments()` and `viewProcessedDocuments()`:** These methods iterate through the respective collections (`Queue` and `List`) to display their contents. They check for emptiness and print appropriate messages using `System.out`.
 *     *   **`printMenu()`:** A helper method to display the user menu.
 *     *   **`run()`:** This method contains the main application loop (`while (choice != 5)`).
 *         *   It displays the menu and prompts for input.
 *         *   Input validation using `scanner.hasNextInt()` checks if the input is an integer. If not, an error is printed to `System.err`, the invalid input is consumed, and the loop continues.
 *         *   A `switch` statement directs the program flow based on the valid integer choice, calling the appropriate processing method. Invalid integer choices (outside 1-5) result in an error message on `System.err`.
 *         *   **Class-wide Exception Handling:** The entire `while` loop within `run()` is wrapped in a `try-catch(Exception e)` block. This demonstrates a top-level safety net for catching any unexpected runtime exceptions that might occur during the execution of the menu loop or the methods called within it. An error message is printed to `System.err` if such an exception is caught.
 *         *   **`finally` block:** A `finally` block is used to ensure that the `scanner` resource is closed, releasing system resources, even if an exception occurs or the loop terminates normally.
 * 
 * 3.  **`main` Method:** The standard entry point of the application, it creates an instance of `DocumentProcessor` and starts the system by calling the `run()` method.
 * 
 * This solution effectively integrates all required Java components (`Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.err`, `System.out`, `try-catch`) into a practical scenario, demonstrating input validation, error handling, and adherence to object-oriented programming best practices like encapsulation. The use of `System.err` is specifically for error conditions, while `System.out` is used for normal program output like prompts, menus, and success messages.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.Arrays; // To easily create the list of valid types

/**
 * Represents a document with a name and type.
 */
class Document {
    private String name;
    private String type; // e.g., "Scan", "Print", "Archive"

    /**
     * Constructs a new Document object.
     * @param name The name of the document.
     * @param type The type of the document.
     */
    public Document(String name, String type) {
        this.name = name;
        this.type = type;
    }

    /**
     * Gets the name of the document.
     * @return The document name.
     */
    public String getName() {
        return name;
    }

    /**
     * Gets the type of the document.
     * @return The document type.
     */
    public String getType() {
        return type;
    }

    /**
     * Returns a string representation of the document.
     * @return A formatted string including document name and type.
     */
    @Override
    public String toString() {
        return "Document [Name: " + name + ", Type: " + type + "]";
    }
}

/**
 * Manages pending and processed documents using a queue and a list.
 * Provides a text-based interface for interaction.
 */
public class DocumentProcessor { // Changed to public class for main method

    // Queue to hold documents waiting for processing
    private Queue<Document> pendingDocuments;
    // List to hold documents that have been processed
    private List<Document> processedDocuments;
    // Scanner for reading user input
    private Scanner scanner;

    // Define valid document types using a List
    private static final List<String> VALID_DOCUMENT_TYPES = Arrays.asList("Scan", "Print", "Archive");

    /**
     * Constructs a new DocumentProcessor system.
     * Initializes the queue, list, and scanner.
     */
    public DocumentProcessor() {
        // Use LinkedList as the implementation for the Queue interface
        this.pendingDocuments = new LinkedList<>();
        // Use ArrayList as the implementation for the List interface
        this.processedDocuments = new ArrayList<>();
        this.scanner = new Scanner(System.in);
    }

    /**
     * Prompts the user for document details and adds it to the pending queue
     * if the type is valid.
     */
    public void addDocument() {
        System.out.print("Enter document name: ");
        String name = scanner.nextLine();
        System.out.print("Enter document type (Scan, Print, Archive): ");
        String type = scanner.nextLine();

        // Validate document type
        if (!VALID_DOCUMENT_TYPES.contains(type)) {
            System.err.println("Error: Invalid document type '" + type + "'. Please use Scan, Print, or Archive.");
            return; // Exit the method without adding the document
        }

        Document newDoc = new Document(name, type);
        pendingDocuments.offer(newDoc); // offer() is safe for capacity-constrained queues, generally preferred
        System.out.println("Document added to the queue: " + newDoc);
    }

    /**
     * Processes the next document from the pending queue.
     * Removes it from the queue, simulates processing, and adds it to the processed list.
     */
    public void processNextDocument() {
        // Check if the queue is empty before attempting to poll
        if (pendingDocuments.isEmpty()) {
            System.out.println("No pending documents to process.");
            return;
        }

        // Get and remove the document from the front of the queue
        Document docToProcess = pendingDocuments.poll();
        System.out.println("Processing document: " + docToProcess);

        // Simulate processing based on document type using a switch statement
        switch (docToProcess.getType()) {
            case "Scan":
                System.out.println("Simulating scanning...");
                break;
            case "Print":
                System.out.println("Simulating printing...");
                break;
            case "Archive":
                System.out.println("Simulating archiving...");
                break;
            default:
                // This case should ideally not be reached due to type validation in addDocument()
                System.err.println("Warning: Encountered document with unknown type '" + docToProcess.getType() + "' during processing.");
                break;
        }

        // Add the processed document to the list of processed documents
        processedDocuments.add(docToProcess);
        System.out.println("Document processing complete.");
    }

    /**
     * Displays all documents currently in the pending queue.
     */
    public void viewPendingDocuments() {
        if (pendingDocuments.isEmpty()) {
            System.out.println("No pending documents.");
            return;
        }
        System.out.println("--- Pending Documents ---");
        // Iterate through the queue elements without removing them
        int i = 1;
        for (Document doc : pendingDocuments) {
            System.out.println(i++ + ". " + doc);
        }
        System.out.println("-------------------------");
    }

    /**
     * Displays all documents that have been processed.
     */
    public void viewProcessedDocuments() {
        if (processedDocuments.isEmpty()) {
            System.out.println("No documents have been processed yet.");
            return;
        }
        System.out.println("--- Processed Documents ---");
        // Iterate through the list elements
        int i = 1;
        for (Document doc : processedDocuments) {
            System.out.println(i++ + ". " + doc);
        }
        System.out.println("---------------------------");
    }

    /**
     * Displays the main menu options to the user.
     */
    private void printMenu() {
        System.out.println("--- Document Processing System Menu ---");
        System.out.println("1. Add Document");
        System.out.println("2. Process Next Document");
        System.out.println("3. View Pending Documents");
        System.out.println("4. View Processed Documents");
        System.out.println("5. Exit");
        System.out.println("---------------------------------------");
    }

    /**
     * Runs the main application loop, handling user input and menu navigation.
     * Includes class-wide exception handling.
     */
    public void run() {
        int choice = -1;

        // Class-wide exception handling wrapping the main application loop
        try {
            while (choice != 5) {
                printMenu();
                System.out.print("Enter your choice: ");

                // Validate if the next input is an integer
                if (scanner.hasNextInt()) {
                    choice = scanner.nextInt();
                    scanner.nextLine(); // Consume the newline character left by nextInt()
                } else {
                    // Handle non-integer input
                    System.err.println("Invalid input. Please enter a number.");
                    scanner.nextLine(); // Consume the invalid input to prevent infinite loop
                    continue; // Skip the rest of the loop and show the menu again
                }

                // Use switch statement to handle user's menu choice
                switch (choice) {
                    case 1:
                        addDocument();
                        break;
                    case 2:
                        processNextDocument();
                        break;
                    case 3:
                        viewPendingDocuments();
                        break;
                    case 4:
                        viewProcessedDocuments();
                        break;
                    case 5:
                        System.out.println("Exiting Document Processing System. Goodbye!");
                        break;
                    default:
                        // Handle choices outside the valid range (1-5)
                        System.err.println("Invalid choice. Please enter a number between 1 and 5.");
                }
                System.out.println(); // Add a blank line for better readability between interactions

            } // End of while loop

        } catch (Exception e) {
            // Catch any unexpected runtime exceptions that occur within the try block
            System.err.println("An unexpected error occurred during system operation: " + e.getMessage());
            // Optional: e.printStackTrace(); // Uncomment for detailed debugging information
        } finally {
            // Ensure the scanner resource is closed regardless of how the try block exits
            if (scanner != null) {
                scanner.close();
                System.out.println("Scanner closed."); // Optional confirmation
            }
        }
    }

    /**
     * The main method to start the Document Processing System application.
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        DocumentProcessor system = new DocumentProcessor();
        system.run(); // Start the main application loop
    }
}
