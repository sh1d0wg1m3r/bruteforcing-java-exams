/*
 * Exam Question #1016
 * Generated on: 2025-05-12 17:13:09
 * Generated by: Account 4
 * 
 * QUESTION:
 * **Java Programming Exam Task: Manufacturing Process Simulator**
 * 
 * **Problem Description:**
 * 
 * You are tasked with developing a simplified simulation of a manufacturing process using Java. The system should manage a queue of tasks waiting to be processed and maintain a history of completed tasks. Users should be able to add new tasks, process the next task in the queue, view pending tasks, view completed tasks, and exit the simulator.
 * 
 * **Requirements:**
 * 
 * 1.  **Task Representation:** Create a `Task` class to represent a manufacturing task. Each task should have:
 *     *   An integer `id` (automatically generated).
 *     *   A String `description`.
 *     *   A String `status` (e.g., "PENDING", "COMPLETED").
 *     *   Appropriate constructors, getters, and a `toString()` method for display.
 *     *   All fields must be `private`.
 * 
 * 2.  **Simulator Class:** Create a `ManufacturingSimulator` class that manages the process. This class must contain:
 *     *   A `java.util.Queue` to hold tasks that are waiting to be processed. Use a concrete implementation like `LinkedList` for the Queue.
 *     *   A `java.util.List` variable to hold completed tasks. Initialize it with a `java.util.ArrayList`.
 *     *   A `java.util.Scanner` for reading user input from the console.
 *     *   Private fields for the queue, list, and scanner, and any other necessary state (like a task ID counter).
 * 
 * 3.  **Functionality:** The `ManufacturingSimulator` must provide the following operations via a command-line interface:
 *     *   **Add Task (command '1'):** Prompt the user for a task description and add a new `Task` object with status "PENDING" to the pending tasks queue. Assign a unique ID.
 *     *   **Process Next Task (command '2'):** Take the next task from the front of the pending tasks queue. If the queue is not empty, change its status to "COMPLETED" and add it to the completed tasks list. If the queue is empty, print an error message to `System.err`.
 *     *   **View Pending Tasks (command '3'):** Display all tasks currently in the pending tasks queue. If the queue is empty, indicate that. Print output to `System.out`.
 *     *   **View Completed Tasks (command '4'):** Display all tasks in the completed tasks list. If the list is empty, indicate that. Print output to `System.out`.
 *     *   **Exit (command '5'):** Terminate the program.
 * 
 * 4.  **Control Flow:**
 *     *   Use a main loop that repeatedly displays options and accepts user input.
 *     *   Use a `switch` statement based on the user's input command to execute the corresponding functionality.
 * 
 * 5.  **Error Handling:**
 *     *   Implement class-wide exception handling using `try-catch` blocks within the main simulation loop to gracefully handle unexpected errors (e.g., non-integer input for menu options, though `Scanner` can handle this, a general catch demonstrates the requirement).
 *     *   Use `System.err` specifically for printing error messages (e.g., invalid command, queue empty error).
 *     *   Use `System.out` for all normal output (prompts, menu, task lists, success messages).
 * 
 * 6.  **Best Practices:**
 *     *   Apply proper encapsulation (`private` fields, `public` methods).
 *     *   Use meaningful variable and method names.
 *     *   Include comments and basic documentation (e.g., Javadoc-style comments for classes/methods).
 *     *   Perform basic input validation (e.g., handle non-numeric input for the menu choice, though the `try-catch` requirement can cover this).
 *     *   Ensure the `Scanner` resource is closed properly.
 * 
 * **Expected Output:**
 * 
 * The program should provide a command-line interface. Example interaction:
 * 
 * ```
 * Manufacturing Process Simulator
 * Please choose an option:
 * 1. Add New Task
 * 2. Process Next Task
 * 3. View Pending Tasks
 * 4. View Completed Tasks
 * 5. Exit
 * Enter command: 1
 * Enter task description: Assemble Widget A
 * Task added: Task{id=1, description='Assemble Widget A', status='PENDING'}
 * 
 * Please choose an option:
 * ... (menu repeats)
 * Enter command: 1
 * Enter task description: Test Widget B
 * Task added: Task{id=2, description='Test Widget B', status='PENDING'}
 * 
 * Please choose an option:
 * ... (menu repeats)
 * Enter command: 3
 * --- Pending Tasks ---
 * Task{id=1, description='Assemble Widget A', status='PENDING'}
 * Task{id=2, description='Test Widget B', status='PENDING'}
 * 
 * Please choose an option:
 * ... (menu repeats)
 * Enter command: 2
 * Processing task: Task{id=1, description='Assemble Widget A', status='PENDING'}
 * Task completed.
 * 
 * Please choose an option:
 * ... (menu repeats)
 * Enter command: 3
 * --- Pending Tasks ---
 * Task{id=2, description='Test Widget B', status='PENDING'}
 * 
 * Please choose an option:
 * ... (menu repeats)
 * Enter command: 4
 * --- Completed Tasks ---
 * Task{id=1, description='Assemble Widget A', status='COMPLETED'}
 * 
 * Please choose an option:
 * ... (menu repeats)
 * Enter command: 2
 * Processing task: Task{id=2, description='Test Widget B', status='PENDING'}
 * Task completed.
 * 
 * Please choose an option:
 * ... (menu repeats)
 * Enter command: 2
 * Error: No tasks in the queue to process. (This should go to System.err)
 * 
 * Please choose an option:
 * ... (menu repeats)
 * Enter command: 4
 * --- Completed Tasks ---
 * Task{id=1, description='Assemble Widget A', status='COMPLETED'}
 * Task{id=2, description='Test Widget B', status='COMPLETED'}
 * 
 * Please choose an option:
 * ... (menu repeats)
 * Enter command: invalid
 * Error: Invalid command. Please enter a number between 1 and 5. (This should go to System.err)
 * 
 * Please choose an option:
 * ... (menu repeats)
 * Enter command: 5
 * Exiting simulator.
 * ```
 * 
 * Your solution should provide the complete Java code for the `Task` and `ManufacturingSimulator` classes, including a `main` method to start the simulation.
 *
 * EXPLANATION:
 * The solution implements a `ManufacturingSimulator` class that manages tasks through different stages, demonstrating the required Java concepts.
 * 
 * 1.  **`Task` Class:** This class encapsulates the data for a single task (`id`, `description`, `status`). Fields are `private` and accessed via `public` getters and a `setStatus` setter, adhering to encapsulation principles. The `toString()` method provides a convenient way to display task information.
 * 
 * 2.  **`ManufacturingSimulator` Class:**
 *     *   **Data Structures:**
 *         *   `pendingTasks`: A `Queue<Task>` is used here, specifically implemented by `LinkedList`. The `Queue` interface is ideal for managing tasks waiting to be processed in a FIFO (First-In, First-Out) order, which naturally fits a processing queue scenario. `offer()` is used for adding tasks and `poll()` for removing the next task.
 *         *   `completedTasks`: A `List<Task>` variable is declared, and an `ArrayList` instance is assigned to it. This demonstrates using the `List` interface for type flexibility while utilizing the concrete `ArrayList` implementation for dynamic resizing and efficient storage of completed tasks.
 *     *   **Scanner:** A `Scanner` is used as a class member to read user input throughout the simulation loop. It's initialized once in the constructor.
 *     *   **`runSimulationLoop()`:** This method contains the main program loop.
 *         *   It repeatedly calls `displayMenu()` and reads the user's command.
 *         *   **`try-catch` Block:** A `try-catch` block wraps the command reading and processing logic.
 *             *   It specifically catches `InputMismatchException` which `scanner.nextInt()` can throw if the user enters non-integer input. This demonstrates targeted exception handling.
 *             *   A general `catch (Exception e)` is included as a fallback to catch any other unexpected runtime errors, fulfilling the requirement for class-wide exception handling. Error messages are printed to `System.err`.
 *         *   **`switch` Statement:** The `switch` statement handles the different integer commands entered by the user, directing the flow to the appropriate method (`addTask`, `processNextTask`, etc.). The `default` case handles invalid numeric commands.
 *     *   **Methods (`addTask`, `processNextTask`, `viewPendingTasks`, `viewCompletedTasks`):** These methods contain the core logic for each operation, interacting with the `pendingTasks` queue and `completedTasks` list.
 *         *   `addTask`: Creates a new `Task` and adds it to the `pendingTasks` queue using `offer()`.
 *         *   `processNextTask`: Uses `poll()` to get and remove the next task from the queue. It checks if the result is `null` (indicating an empty queue) and prints an error to `System.err` if so. Otherwise, it updates the task status and adds it to the `completedTasks` list.
 *         *   `viewPendingTasks`: Iterates through the `pendingTasks` queue (using a for-each loop, which doesn't remove elements) and prints each task to `System.out`.
 *         *   `viewCompletedTasks`: Iterates through the `completedTasks` list and prints each task to `System.out`.
 *     *   **Input Handling:** Basic validation for the task description is included. The `scanner.nextLine()` call after `scanner.nextInt()` is crucial to consume the leftover newline character, preventing issues in the next `scanner.nextLine()` call within `addTask`.
 *     *   **Output:** `System.out` is used for all normal user interactions, prompts, menus, and successful operation messages. `System.err` is strictly used for printing error messages as required.
 *     *   **Resource Management:** A `closeScanner()` method is provided and called after the main loop finishes (when the user enters '5'), ensuring the `Scanner` resource is released.
 * 
 * 3.  **`main` Method:** The standard entry point creates an instance of the `ManufacturingSimulator` and calls its `runSimulationLoop()` method to start the simulation.
 * 
 * This solution effectively integrates all required components (`Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.err`, `System.out`, `try-catch`) into a practical, albeit simplified, application demonstrating core Java concepts and best practices like encapsulation, meaningful names, and basic error handling.
 */

import java.util.Queue;
import java.util.LinkedList;
import java.util.List;
import java.util.ArrayList;
import java.util.Scanner;
import java.util.InputMismatchException;

/**
 * Represents a manufacturing task.
 */
class Task {
    private int id;
    private String description;
    private String status; // e.g., "PENDING", "COMPLETED"

    /**
     * Constructs a new Task.
     *
     * @param id The unique identifier for the task.
     * @param description A brief description of the task.
     * @param status The initial status of the task.
     */
    public Task(int id, String description, String status) {
        this.id = id;
        this.description = description;
        this.status = status;
    }

    // Getters
    public int getId() {
        return id;
    }

    public String getDescription() {
        return description;
    }

    public String getStatus() {
        return status;
    }

    // Setter for status (needed for processing)
    public void setStatus(String status) {
        this.status = status;
    }

    @Override
    public String toString() {
        return "Task{id=" + id + ", description='" + description + "', status='" + status + "'}";
    }
}

/**
 * Simulates a manufacturing process managing tasks.
 */
public class ManufacturingSimulator {
    private Queue<Task> pendingTasks;
    private List<Task> completedTasks; // Declared as List, initialized with ArrayList
    private Scanner scanner;
    private int nextTaskId;

    /**
     * Constructs a new ManufacturingSimulator.
     */
    public ManufacturingSimulator() {
        // Requirement: Use Queue and ArrayList
        this.pendingTasks = new LinkedList<>(); // LinkedList implements Queue
        this.completedTasks = new ArrayList<>(); // Requirement: Use List variable with ArrayList instance
        this.scanner = new Scanner(System.in);
        this.nextTaskId = 1; // Start task IDs from 1
    }

    /**
     * Displays the main menu options to the user.
     */
    private void displayMenu() {
        System.out.println("\nManufacturing Process Simulator");
        System.out.println("Please choose an option:");
        System.out.println("1. Add New Task");
        System.out.println("2. Process Next Task");
        System.out.println("3. View Pending Tasks");
        System.out.println("4. View Completed Tasks");
        System.out.println("5. Exit");
        System.out.print("Enter command: ");
    }

    /**
     * Adds a new task to the pending tasks queue.
     */
    private void addTask() {
        System.out.print("Enter task description: ");
        // Consume the newline left by previous nextInt() or similar
        if (scanner.hasNextLine()) {
             scanner.nextLine(); // Consume remaining newline if any
        }
        String description = scanner.nextLine();
        if (description == null || description.trim().isEmpty()) {
            System.err.println("Error: Task description cannot be empty.");
            return;
        }
        Task newTask = new Task(nextTaskId++, description, "PENDING");
        pendingTasks.offer(newTask); // offer is generally preferred over add for queues
        System.out.println("Task added: " + newTask);
    }

    /**
     * Processes the next task from the queue.
     */
    private void processNextTask() {
        Task taskToProcess = pendingTasks.poll(); // Retrieves and removes the head of the queue
        if (taskToProcess == null) {
            System.err.println("Error: No tasks in the queue to process."); // Requirement: Use System.err
        } else {
            System.out.println("Processing task: " + taskToProcess); // Requirement: Use System.out
            taskToProcess.setStatus("COMPLETED");
            completedTasks.add(taskToProcess); // Add to the list of completed tasks
            System.out.println("Task completed."); // Requirement: Use System.out
        }
    }

    /**
     * Displays all tasks currently in the pending queue.
     */
    private void viewPendingTasks() {
        System.out.println("\n--- Pending Tasks ---"); // Requirement: Use System.out
        if (pendingTasks.isEmpty()) {
            System.out.println("No tasks pending."); // Requirement: Use System.out
        } else {
            // Iterate over the queue without removing elements
            for (Task task : pendingTasks) {
                System.out.println(task); // Requirement: Use System.out
            }
        }
    }

    /**
     * Displays all tasks in the completed tasks list.
     */
    private void viewCompletedTasks() {
        System.out.println("\n--- Completed Tasks ---"); // Requirement: Use System.out
        if (completedTasks.isEmpty()) {
            System.out.println("No tasks completed yet."); // Requirement: Use System.out
        } else {
            // Iterate over the list
            for (Task task : completedTasks) {
                System.out.println(task); // Requirement: Use System.out
            }
        }
    }

    /**
     * Runs the main simulation loop.
     */
    public void runSimulationLoop() {
        int command = 0;
        while (command != 5) {
            displayMenu();
            try {
                // Requirement: Class-wide exception handling with try-catch
                // Catch InputMismatchException specifically for Scanner nextInt()
                command = scanner.nextInt();

                // Requirement: Use switch statement
                switch (command) {
                    case 1:
                        addTask();
                        break;
                    case 2:
                        processNextTask();
                        break;
                    case 3:
                        viewPendingTasks();
                        break;
                    case 4:
                        viewCompletedTasks();
                        break;
                    case 5:
                        System.out.println("Exiting simulator."); // Requirement: Use System.out
                        break;
                    default:
                        System.err.println("Error: Invalid command. Please enter a number between 1 and 5."); // Requirement: Use System.err
                }
            } catch (InputMismatchException e) {
                System.err.println("Error: Invalid input. Please enter a number."); // Requirement: Use System.err
                scanner.next(); // Consume the invalid input to prevent infinite loop
                command = 0; // Reset command to stay in loop
            } catch (Exception e) {
                // Catch any other unexpected exceptions
                System.err.println("An unexpected error occurred: " + e.getMessage()); // Requirement: Use System.err
                e.printStackTrace(); // Print stack trace for debugging
                command = 0; // Reset command to stay in loop
            }
        }
        closeScanner(); // Ensure scanner is closed on exit
    }

    /**
     * Closes the scanner resource.
     */
    private void closeScanner() {
        if (scanner != null) {
            scanner.close();
        }
    }

    /**
     * Main method to start the simulation.
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        ManufacturingSimulator simulator = new ManufacturingSimulator();
        simulator.runSimulationLoop();
    }
}
