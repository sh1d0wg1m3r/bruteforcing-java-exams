/*
 * Exam Question #852
 * Generated on: 2025-05-12 16:50:32
 * Generated by: Account 2
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Team Task Management System
 * 
 * **Scenario:**
 * 
 * You are tasked with developing a simple command-line Task Management System for a small team. The system should allow users to manage tasks, tracking which ones are pending and which have been completed.
 * 
 * **Requirements:**
 * 
 * 1.  **Task Representation:** Create a `Task` class with the following attributes:
 *     *   `id` (int): A unique identifier for the task, auto-generated by the system.
 *     *   `description` (String): A brief description of the task.
 *     *   `priority` (int): A numerical priority (e.g., 1 for highest, 5 for lowest).
 *     *   `status` (String): The current status, either "Pending" or "Completed".
 *     *   Implement appropriate constructors, getters, and a method to set the status. Override `toString()` for easy printing.
 * 
 * 2.  **System State:** The main system class (`TaskManagementSystem`) must maintain the following:
 *     *   A collection of tasks that are currently waiting to be processed. This collection *must* be managed using a `java.util.Queue`.
 *     *   A collection of tasks that have been marked as completed. This collection *must* be managed using a `java.util.List`, specifically implemented using `java.util.ArrayList`.
 *     *   A predefined list of valid task descriptions (e.g., "Code Feature", "Write Documentation", "Run Tests", "Fix Bug"). This list *must* be a `java.util.List`, specifically implemented using `java.util.ArrayList`.
 * 
 * 3.  **User Interface:** Implement a command-line interface using `java.util.Scanner` to interact with the user. The system should present a menu with the following options:
 *     *   1. Add New Task
 *     *   2. Complete Task
 *     *   3. View Pending Tasks
 *     *   4. View Completed Tasks
 *     *   5. View Available Task Types
 *     *   6. Exit
 * 
 * 4.  **Functionality:** Implement the logic for each menu option:
 *     *   **Add New Task:** Prompt the user for a task description and priority. The description *must* match one from the predefined list of available types. Create a new `Task` object with status "Pending" and add it to the pending tasks `Queue`.
 *     *   **Complete Task:** Prompt the user for the ID of the task to complete. Find the task with the given ID in the pending tasks `Queue`. If found, remove it from the queue, update its status to "Completed", and add it to the completed tasks `List`. If not found, inform the user.
 *     *   **View Pending Tasks:** Display all tasks currently in the pending tasks `Queue`.
 *     *   **View Completed Tasks:** Display all tasks currently in the completed tasks `List`.
 *     *   **View Available Task Types:** Display the predefined list of valid task descriptions.
 *     *   **Exit:** Terminate the program.
 * 
 * 5.  **Required Java Components:** Your solution *must* explicitly use and demonstrate the usage of ALL of the following:
 *     *   `java.util.Queue`
 *     *   `java.util.ArrayList`
 *     *   `java.util.List` interface
 *     *   `java.util.Scanner`
 *     *   `switch` statement
 *     *   `System.err` for error messages (e.g., invalid input, task not found)
 *     *   `System.out` for normal output (menus, task lists, success messages)
 *     *   Class-wide exception handling using `try-catch` blocks (e.g., handling `NumberFormatException` for input, general exceptions).
 * 
 * 6.  **Best Practices:** Adhere to good programming practices:
 *     *   Proper encapsulation (private fields, public methods).
 *     *   Meaningful variable and method names.
 *     *   Appropriate comments and documentation (basic comments explaining key parts are sufficient for an exam).
 *     *   Input validation (check if input is valid number, if task type exists, if task ID exists).
 *     *   Proper error handling (inform the user clearly when an error occurs).
 *     *   Clean code structure (break down logic into methods).
 * 
 * **Expected Output:**
 * 
 * The program should start by printing the menu. Based on user input, it should perform the requested action, printing relevant information (task lists, success messages) to `System.out` or error messages to `System.err`. The menu should be displayed repeatedly until the user chooses to exit.
 * 
 * **Example Interaction Snippet:**
 * 
 * ```
 * --- Task Management Menu ---
 * 1. Add New Task
 * 2. Complete Task
 * 3. View Pending Tasks
 * 4. View Completed Tasks
 * 5. View Available Task Types
 * 6. Exit
 * ----------------------------
 * Enter your choice: 5
 * 
 * --- Available Task Types ---
 * 1. Code Feature
 * 2. Write Documentation
 * 3. Run Tests
 * 4. Fix Bug
 * 5. Review Code
 * 
 * --- Task Management Menu ---
 * ...
 * Enter your choice: 1
 * 
 * --- Add New Task ---
 * --- Available Task Types ---
 * ... (list again)
 * Enter task description (choose from above): Code Feature
 * Enter priority (1-5, 1 is highest): 2
 * Task added successfully: ID: 1, Description: Code Feature, Priority: 2, Status: Pending
 * 
 * --- Task Management Menu ---
 * ...
 * Enter your choice: 3
 * 
 * --- Pending Tasks ---
 * 1. ID: 1, Description: Code Feature, Priority: 2, Status: Pending
 * 
 * --- Task Management Menu ---
 * ...
 * Enter your choice: 2
 * 
 * --- Complete Task ---
 * --- Pending Tasks ---
 * 1. ID: 1, Description: Code Feature, Priority: 2, Status: Pending
 * Enter the ID of the task to complete: 1
 * Task marked as completed: ID: 1, Description: Code Feature, Priority: 2, Status: Completed
 * 
 * --- Task Management Menu ---
 * ...
 * Enter your choice: 4
 * 
 * --- Completed Tasks ---
 * 1. ID: 1, Description: Code Feature, Priority: 2, Status: Completed
 * 
 * --- Task Management Menu ---
 * ...
 * Enter your choice: 7
 * Invalid choice. Please enter a number between 1 and 6.
 * 
 * --- Task Management Menu ---
 * ...
 * Enter your choice: abc
 * Invalid input. Please enter a number for the menu choice.
 * 
 * --- Task Management Menu ---
 * ...
 * Enter your choice: 6
 * Exiting Task Management System. Goodbye!
 * ```
 * 
 * Your task is to write the complete Java code for this system.
 *
 * EXPLANATION:
 * This solution implements a command-line Task Management System, designed to meet all the specified requirements and demonstrate the practical use of the required Java components and best practices.
 * 
 * 1.  **Task Class:** The `Task` class is a simple Plain Old Java Object (POJO) that encapsulates the attributes of a task (`id`, `description`, `priority`, `status`). It uses a static counter (`nextId`) to ensure each task gets a unique ID upon creation, mimicking a database auto-incrementing primary key. Getters provide read access to attributes, and a specific setter (`setStatus`) is provided for updating the status. The `toString()` method provides a convenient way to display task details. This class adheres to encapsulation principles by keeping fields private.
 * 
 * 2.  **TaskManagementSystem Class:** This is the main class that orchestrates the application.
 *     *   It uses a `Queue<Task>` named `pendingTasks` to hold tasks awaiting completion. `LinkedList` is chosen as a common implementation of the `Queue` interface. Tasks are added to the queue using `offer()`.
 *     *   It uses a `List<Task>` named `completedTasks`, specifically instantiated as an `ArrayList`, to store tasks once they are finished.
 *     *   It uses a `List<String>` named `availableTaskTypes`, also instantiated as an `ArrayList`, to hold the valid descriptions for new tasks. This demonstrates using `List` for static, predefined data.
 *     *   A `Scanner` object is used throughout the class to read user input from `System.in`.
 * 
 * 3.  **Menu and Control Flow:**
 *     *   The `run()` method contains the main application loop, repeatedly displaying the menu and processing user input until the user chooses to exit.
 *     *   A `switch` statement is used to direct execution based on the user's integer choice, fulfilling the requirement for using a `switch`.
 *     *   `System.out` is used for displaying the menu, success messages, and lists of tasks or types.
 *     *   `System.err` is specifically used for printing error messages, such as invalid menu choices, invalid input formats, or when a task ID is not found.
 * 
 * 4.  **Functionality Implementation:**
 *     *   `addTask()`: Prompts for description and priority. It validates that the entered description is present in the `availableTaskTypes` list and that the priority is within the valid range (1-5). It uses `try-catch` to handle potential `NumberFormatException` if the priority input is not a number. A new `Task` is created and added to the `pendingTasks` queue using `offer()`.
 *     *   `completeTask()`: Prompts for a Task ID. It uses a `try-catch` block to handle `NumberFormatException` if the ID input is not a number. It then iterates through the `pendingTasks` queue using an `Iterator`. When the task with the matching ID is found, `iterator.remove()` is used to safely remove the element from the queue while iterating. This is a necessary technique when removing an arbitrary element from a collection like a `Queue` where direct indexed removal isn't standard or efficient. The task's status is updated, and it's added to the `completedTasks` list. If the ID is not found after iterating through the queue, an error message is printed to `System.err`.
 *     *   `viewPendingTasks()` and `viewCompletedTasks()`: These methods iterate through the respective collections (`Queue` and `List`) and print the details of each task using the `Task` class's `toString()` method.
 *     *   `viewAvailableTaskTypes()`: Iterates through the `availableTaskTypes` list and prints each valid type.
 * 
 * 5.  **Exception Handling:**
 *     *   `try-catch` blocks are strategically placed around input parsing operations (`Integer.parseInt`) in `run()`, `addTask()`, and `completeTask()` to catch `NumberFormatException` and provide user-friendly error messages via `System.err`.
 *     *   The main loop in `run()` includes a general `catch (Exception e)` block. While specific exceptions are handled first, this ensures that any other unexpected runtime errors that might occur within the loop are caught, preventing the program from crashing and printing an error message to `System.err`. This fulfills the requirement for class-wide exception handling using `try-catch`.
 * 
 * 6.  **Best Practices:**
 *     *   Encapsulation is used in both `Task` and `TaskManagementSystem` classes.
 *     *   Method and variable names are descriptive (`pendingTasks`, `completeTask`, `taskIdToComplete`, etc.).
 *     *   Basic comments explain the purpose of classes, methods, and key logic sections.
 *     *   Input validation is performed before attempting operations that depend on valid data.
 *     *   Error handling uses `System.err` and provides informative messages to the user.
 *     *   The code is structured into logical methods, making it more readable and maintainable.
 * 
 * This solution effectively integrates all the required Java components into a functional, albeit simple, real-world simulation, demonstrating advanced understanding of collection types, control flow, input/output, and error handling in Java.
 */

import java.util.*; // Import necessary classes

// Task class representing a single task
class Task {
    private int id;
    private String description;
    private int priority; // 1 (High) to 5 (Low)
    private String status; // "Pending" or "Completed"

    private static int nextId = 1; // Static counter for unique IDs

    /**
     * Constructs a new Task with initial status "Pending".
     * @param description The task description.
     * @param priority The task priority (1-5).
     */
    public Task(String description, int priority) {
        this.id = nextId++; // Assign unique ID and increment counter
        this.description = description;
        this.priority = priority;
        this.status = "Pending";
    }

    // --- Getters ---
    public int getId() {
        return id;
    }

    public String getDescription() {
        return description;
    }

    public int getPriority() {
        return priority;
    }

    public String getStatus() {
        return status;
    }

    // --- Setter for status ---
    public void setStatus(String status) {
        this.status = status;
    }

    /**
     * Returns a string representation of the Task.
     * @return String representation of the Task.
     */
    @Override
    public String toString() {
        return "ID: " + id + ", Description: " + description + ", Priority: " + priority + ", Status: " + status;
    }
}

// Main class for the Task Management System
public class TaskManagementSystem {

    // Required: Queue for pending tasks
    private Queue<Task> pendingTasks;
    // Required: List (implemented by ArrayList) for completed tasks
    private List<Task> completedTasks;
    // Required: List (implemented by ArrayList) for available task types
    private List<String> availableTaskTypes;
    // Required: Scanner for user input
    private Scanner scanner;

    /**
     * Constructor to initialize the Task Management System.
     */
    public TaskManagementSystem() {
        // Use LinkedList as a concrete implementation of Queue
        this.pendingTasks = new LinkedList<>();
        // Use ArrayList as a concrete implementation of List for completed tasks
        this.completedTasks = new ArrayList<>();
        // Use ArrayList as a concrete implementation of List for available types
        this.availableTaskTypes = new ArrayList<>(Arrays.asList(
            "Code Feature", "Write Documentation", "Run Tests", "Fix Bug", "Review Code"
        )); // Populate with initial types
        this.scanner = new Scanner(System.in);
    }

    /**
     * Runs the main application loop, displaying the menu and processing user input.
     */
    public void run() {
        boolean running = true;
        while (running) {
            printMenu();
            try {
                // Required: Scanner for input
                System.out.print("Enter your choice: ");
                String choiceStr = scanner.nextLine();
                // Potential NumberFormatException handled below
                int choice = Integer.parseInt(choiceStr);

                // Required: switch statement for menu control
                switch (choice) {
                    case 1:
                        addTask();
                        break;
                    case 2:
                        completeTask();
                        break;
                    case 3:
                        viewPendingTasks();
                        break;
                    case 4:
                        viewCompletedTasks();
                        break;
                    case 5:
                        viewAvailableTaskTypes();
                        break;
                    case 6:
                        running = false;
                        // Required: System.out for normal output
                        System.out.println("Exiting Task Management System. Goodbye!");
                        break;
                    default:
                        // Required: System.err for error messages
                        System.err.println("Invalid choice. Please enter a number between 1 and 6.");
                }
            } catch (NumberFormatException e) {
                // Required: try-catch for exception handling
                System.err.println("Invalid input. Please enter a number for the menu choice.");
            } catch (Exception e) {
                // Catch any other unexpected exceptions during the loop iteration
                System.err.println("An unexpected error occurred: " + e.getMessage());
                // Optionally, print stack trace for debugging: e.printStackTrace();
            }
            // Add a blank line for better readability between menu iterations
            System.out.println();
        }
        // Close the scanner when the application exits
        scanner.close();
    }

    /**
     * Prints the main menu options to System.out.
     */
    private void printMenu() {
        System.out.println("--- Task Management Menu ---");
        System.out.println("1. Add New Task");
        System.out.println("2. Complete Task");
        System.out.println("3. View Pending Tasks");
        System.out.println("4. View Completed Tasks");
        System.out.println("5. View Available Task Types");
        System.out.println("6. Exit");
        System.out.println("----------------------------");
    }

    /**
     * Handles the process of adding a new task based on user input.
     */
    private void addTask() {
        System.out.println("\n--- Add New Task ---");
        viewAvailableTaskTypes(); // Show available types to help user

        System.out.print("Enter task description (choose from above): ");
        String description = scanner.nextLine().trim();

        // Input validation: Check if description is valid
        if (!availableTaskTypes.contains(description)) {
            System.err.println("Invalid task description. Please choose from the available types.");
            return; // Exit method if validation fails
        }

        int priority = -1;
        try {
            System.out.print("Enter priority (1-5, 1 is highest): ");
            // Potential NumberFormatException handled here
            priority = Integer.parseInt(scanner.nextLine());

            // Input validation: Check if priority is within valid range
            if (priority < 1 || priority > 5) {
                System.err.println("Invalid priority. Please enter a number between 1 and 5.");
                return; // Exit method if validation fails
            }
        } catch (NumberFormatException e) {
            System.err.println("Invalid input for priority. Please enter a number.");
            return; // Exit method if parsing fails
        }

        // Create new task and add to the pending queue
        Task newTask = new Task(description, priority);
        // Required: Using Queue (offer adds to the end)
        pendingTasks.offer(newTask);
        System.out.println("Task added successfully: " + newTask.toString());
    }

    /**
     * Handles marking a pending task as completed based on user-provided ID.
     */
    private void completeTask() {
        System.out.println("\n--- Complete Task ---");
        if (pendingTasks.isEmpty()) {
            System.out.println("No pending tasks to complete.");
            return;
        }

        viewPendingTasks(); // Show pending tasks with IDs

        int taskIdToComplete = -1;
        try {
            System.out.print("Enter the ID of the task to complete: ");
            // Potential NumberFormatException handled here
            taskIdToComplete = Integer.parseInt(scanner.nextLine());
        } catch (NumberFormatException e) {
            System.err.println("Invalid input for Task ID. Please enter a number.");
            return; // Exit method if parsing fails
        }

        // Find and remove the task from the Queue.
        // We need to iterate to find by ID, and use iterator.remove()
        // as Queue doesn't have an efficient remove(id) method standardly.
        Iterator<Task> iterator = pendingTasks.iterator();
        Task taskToComplete = null;
        while (iterator.hasNext()) {
            Task task = iterator.next();
            if (task.getId() == taskIdToComplete) {
                taskToComplete = task;
                // Remove the task from the Queue using the iterator
                iterator.remove();
                break; // Found and removed, exit loop
            }
        }

        // Process the task if found
        if (taskToComplete != null) {
            taskToComplete.setStatus("Completed");
            // Required: Add to the completed List (ArrayList)
            completedTasks.add(taskToComplete);
            System.out.println("Task marked as completed: " + taskToComplete.toString());
        } else {
            // Required: System.err for error message
            System.err.println("Task with ID " + taskIdToComplete + " not found in pending tasks.");
        }
    }

    /**
     * Displays all tasks currently in the pending tasks queue.
     */
    private void viewPendingTasks() {
        System.out.println("\n--- Pending Tasks ---");
        if (pendingTasks.isEmpty()) {
            System.out.println("No pending tasks.");
        } else {
            // Iterate through the Queue to display tasks
            int count = 1;
            for (Task task : pendingTasks) {
                System.out.println(count++ + ". " + task.toString());
            }
        }
    }

    /**
     * Displays all tasks currently in the completed tasks list.
     */
    private void viewCompletedTasks() {
        System.out.println("\n--- Completed Tasks ---");
        if (completedTasks.isEmpty()) {
            System.out.println("No completed tasks.");
        } else {
            // Iterate through the List to display tasks
            int count = 1;
            for (Task task : completedTasks) {
                System.out.println(count++ + ". " + task.toString());
            }
        }
    }

    /**
     * Displays the predefined list of available task types.
     */
    private void viewAvailableTaskTypes() {
         System.out.println("\n--- Available Task Types ---");
         if (availableTaskTypes.isEmpty()) {
             System.out.println("No available task types defined.");
         } else {
             // Iterate through the List to display types
             int count = 1;
             for (String type : availableTaskTypes) {
                 System.out.println(count++ + ". " + type);
             }
         }
    }

    /**
     * Main method to start the application.
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        TaskManagementSystem system = new TaskManagementSystem();
        system.run();
    }
}
