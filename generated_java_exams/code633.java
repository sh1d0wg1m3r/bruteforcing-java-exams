/*
 * Exam Question #633
 * Generated on: 2025-05-12 16:17:41
 * Generated by: Account 4
 * 
 * QUESTION:
 * **Advanced Java Programming Exam Task: Print Job Management System**
 * 
 * **Scenario:**
 * 
 * You are tasked with developing a simple command-line application to simulate a print job management system. The system should allow users to add new print jobs, process the next job in the queue, and view lists of pending and completed jobs. This task requires you to demonstrate your understanding of fundamental Java data structures, control flow, input/output, and exception handling in an object-oriented design.
 * 
 * **Requirements:**
 * 
 * 1.  **Object-Oriented Design:** Create at least two classes:
 *     *   `PrintJob`: Represents a single print job with properties like a unique ID, file name, number of pages, and status (e.g., "Pending", "Completed").
 *     *   `PrintManager`: Manages the collection of print jobs, holding pending jobs in a queue and completed jobs in a list.
 *     *   A main application class (`PrintApp`) to handle user interaction.
 * 
 * 2.  **Data Structures:**
 *     *   Use a `java.util.Queue` to store pending print jobs (First-In, First-Out processing).
 *     *   Use a `java.util.List` (specifically implemented by `java.util.ArrayList`) to store completed print jobs.
 * 
 * 3.  **User Interaction:**
 *     *   Use `java.util.Scanner` to read user input from the console.
 *     *   Implement a menu-driven interface with options to:
 *         *   Add a new print job (requires file name and number of pages).
 *         *   Process the next job from the pending queue.
 *         *   View all pending jobs.
 *         *   View all completed jobs.
 *         *   Exit the application.
 * 
 * 4.  **Control Flow:**
 *     *   Use a `switch` statement to handle the different menu options selected by the user.
 *     *   Use a loop to keep the application running until the user chooses to exit.
 * 
 * 5.  **Input/Output:**
 *     *   Use `System.out` for displaying the menu, prompts, success messages, and lists of jobs.
 *     *   Use `System.err` for displaying error messages (e.g., invalid menu choice, invalid job details, attempting to process an empty queue).
 * 
 * 6.  **Exception Handling:**
 *     *   Implement exception handling using `try-catch` blocks. Specifically, handle potential `NumberFormatException` when parsing user input for menu choices or job details (like pages).
 *     *   Handle cases like attempting to process a job when the pending queue is empty gracefully, reporting an error to `System.err`.
 * 
 * 7.  **Best Practices:**
 *     *   Apply proper encapsulation (private fields, public getters/methods).
 *     *   Use meaningful variable and method names.
 *     *   Include basic comments to explain key parts of the code.
 *     *   Implement basic input validation (e.g., number of pages must be positive, file name not empty).
 *     *   Ensure resources like `Scanner` are closed properly.
 * 
 * **Expected Output:**
 * 
 * Your program should run interactively, presenting a menu, accepting input, and providing feedback. Example interaction could look like this:
 * 
 * ```
 * --- Print Job Management Menu ---
 * 1. Add New Print Job
 * 2. Process Next Job
 * 3. View Pending Jobs
 * 4. View Completed Jobs
 * 0. Exit
 * -------------------------------
 * Enter your choice: 1
 * Enter file name: document1.pdf
 * Enter number of pages: 10
 * Job added: document1.pdf (ID: 1)
 * 
 * --- Print Job Management Menu ---
 * 1. Add New Print Job
 * 2. Process Next Job
 * 3. View Pending Jobs
 * 4. View Completed Jobs
 * 0. Exit
 * -------------------------------
 * Enter your choice: 1
 * Enter file name: image.png
 * Enter number of pages: 5
 * Job added: image.png (ID: 2)
 * 
 * --- Print Job Management Menu ---
 * 1. Add New Print Job
 * 2. Process Next Job
 * 3. View Pending Jobs
 * 4. View Completed Jobs
 * 0. Exit
 * -------------------------------
 * Enter your choice: 3
 * --- Pending Jobs ---
 * Job ID: 1, File: document1.pdf, Pages: 10, Status: Pending
 * Job ID: 2, File: image.png, Pages: 5, Status: Pending
 * --------------------
 * 
 * --- Print Job Management Menu ---
 * 1. Add New Print Job
 * 2. Process Next Job
 * 3. View Pending Jobs
 * 4. View Completed Jobs
 * 0. Exit
 * -------------------------------
 * Enter your choice: 2
 * Job processed: document1.pdf (ID: 1)
 * 
 * --- Print Job Management Menu ---
 * 1. Add New Print Job
 * 2. Process Next Job
 * 3. View Pending Jobs
 * 4. View Completed Jobs
 * 0. Exit
 * -------------------------------
 * Enter your choice: 3
 * --- Pending Jobs ---
 * Job ID: 2, File: image.png, Pages: 5, Status: Pending
 * --------------------
 * 
 * --- Print Job Management Menu ---
 * 1. Add New Print Job
 * 2. Process Next Job
 * 3. View Pending Jobs
 * 4. View Completed Jobs
 * 0. Exit
 * -------------------------------
 * Enter your choice: 4
 * --- Completed Jobs ---
 * Job ID: 1, File: document1.pdf, Pages: 10, Status: Completed
 * ----------------------
 * 
 * --- Print Job Management Menu ---
 * 1. Add New Print Job
 * 2. Process Next Job
 * 3. View Pending Jobs
 * 4. View Completed Jobs
 * 0. Exit
 * -------------------------------
 * Enter your choice: invalid
 * Invalid input. Please enter a number.
 * 
 * --- Print Job Management Menu ---
 * 1. Add New Print Job
 * 2. Process Next Job
 * 3. View Pending Jobs
 * 4. View Completed Jobs
 * 0. Exit
 * -------------------------------
 * Enter your choice: 5
 * Invalid choice. Please enter a number between 0 and 4.
 * 
 * --- Print Job Management Menu ---
 * 1. Add New Print Job
 * 2. Process Next Job
 * 3. View Pending Jobs
 * 4. View Completed Jobs
 * 0. Exit
 * -------------------------------
 * Enter your choice: 0
 * Exiting Print Job Management System. Goodbye!
 * ```
 * 
 * Implement the Java code for this system.
 *
 * EXPLANATION:
 * The solution implements a simple Print Job Management System using the required Java components and best practices.
 * 
 * 1.  **Object-Oriented Design:**
 *     *   `PrintJob`: Encapsulates the data for a single print job (`jobId`, `fileName`, `pages`, `status`). It includes a static `AtomicInteger` for generating unique IDs and input validation in the constructor.
 *     *   `PrintManager`: Manages the two collections of jobs (`pendingJobs` and `completedJobs`). It provides methods (`addJob`, `processNextJob`, `getPendingJobs`, `getCompletedJobs`) to interact with these collections in a controlled manner.
 *     *   `PrintApp`: Contains the `main` method and the `run` loop that drives the application. It handles user input and output, and orchestrates calls to the `PrintManager`.
 * 
 * 2.  **Data Structures:**
 *     *   `java.util.Queue`: The `pendingJobs` field in `PrintManager` is declared as a `Queue<PrintJob>` and instantiated using `java.util.LinkedList`. This ensures that jobs are processed in the order they are added (FIFO), which is typical for a print queue. The `offer()` method is used for adding and `poll()` for retrieving and removing the head of the queue.
 *     *   `java.util.List` and `java.util.ArrayList`: The `completedJobs` field in `PrintManager` is declared as a `List<PrintJob>` and instantiated using `java.util.ArrayList`. `ArrayList` is suitable here as completed jobs are simply stored and iterated over, and random access isn't a primary requirement, but `ArrayList` is a common and efficient `List` implementation. The `add()` method is used to add processed jobs. The `getPendingJobs` and `getCompletedJobs` methods return new `ArrayList` instances containing the jobs from the internal collections, demonstrating good encapsulation by preventing direct external modification of the internal data structures.
 * 
 * 3.  **User Interaction (`Scanner`):**
 *     *   A `java.util.Scanner` is used in the `PrintApp` class to read input from `System.in`. Reading entire lines (`scanner.nextLine()`) is preferred, especially when mixing string and number inputs, to avoid issues with newline characters left in the buffer.
 * 
 * 4.  **Control Flow (`switch`, Loop):**
 *     *   The `run()` method in `PrintApp` contains a `while` loop that continues as long as the user's choice is not 0 (Exit).
 *     *   Inside the loop, a `switch` statement is used to direct the program flow based on the integer value of the user's menu choice, calling the appropriate private method (`addJob`, `processNextJob`, etc.).
 * 
 * 5.  **Input/Output (`System.out`, `System.err`):**
 *     *   `System.out.println()` and `System.out.print()` are used for displaying the menu, prompts, successful job additions/processing messages, and the contents of the job lists.
 *     *   `System.err.println()` is used specifically for error messages, such as invalid menu input, invalid job details (pages <= 0 or empty file name), or attempting to process a job when the pending queue is empty. This separates normal program output from error reporting, which is a standard practice.
 * 
 * 6.  **Exception Handling (`try-catch`):**
 *     *   `try-catch` blocks are used in the `run()` method to handle `NumberFormatException` that occurs if the user enters non-integer input for the menu choice.
 *     *   A `try-catch` block is also used in the `addJob()` method to handle `NumberFormatException` when parsing the pages input and `IllegalArgumentException` which is thrown by the `PrintJob` constructor if the provided file name or pages are invalid.
 *     *   The `processNextJob()` method in `PrintManager` handles the empty queue scenario by checking if `poll()` returns `null`. The `PrintApp` method `processNextJob()` checks for this `null` return value and prints an error message to `System.err` if the queue was empty. This demonstrates handling potential issues gracefully without necessarily throwing exceptions for expected conditions like an empty queue.
 * 
 * 7.  **Best Practices:**
 *     *   **Encapsulation:** Fields in `PrintJob` and `PrintManager` are `private`. Access and modification are controlled through `public` methods (getters, `markAsCompleted`, `addJob`, `processNextJob`). Returning copies of collections (`new ArrayList<>(...)`) from `getPendingJobs` and `getCompletedJobs` prevents external code from directly modifying the internal queue or list.
 *     *   **Meaningful Names:** Classes (`PrintJob`, `PrintManager`, `PrintApp`), variables (`pendingJobs`, `completedJobs`, `fileName`, `pages`, `choice`), and methods (`addJob`, `processNextJob`, `viewPendingJobs`, `printMenu`) have names that clearly indicate their purpose.
 *     *   **Comments:** Basic Javadoc-style comments explain the purpose of classes, constructors, and public methods.
 *     *   **Input Validation:** Validation for file name (not empty) and pages (positive) is performed both in the `PrintJob` constructor and checked in the `PrintManager.addJob` method.
 *     *   **Resource Management:** The `Scanner` object is closed using `scanner.close()` when the main application loop finishes, releasing the underlying system resource.
 *     *   **Clean Structure:** The code is divided into logical classes, each with a single responsibility, making it easier to understand and maintain.
 * 
 * This solution effectively integrates the required Java components within a practical simulation, demonstrating key programming concepts and best practices expected at an advanced level.
 */

import java.util.Queue;
import java.util.LinkedList;
import java.util.List;
import java.util.ArrayList;
import java.util.Scanner;
import java.util.concurrent.atomic.AtomicInteger; // For generating unique job IDs

/**
 * Represents a single print job in the system.
 */
class PrintJob {
    // Static counter to generate unique IDs for each job
    private static final AtomicInteger idCounter = new AtomicInteger(0);

    private int jobId;
    private String fileName;
    private int pages;
    private String status; // e.g., "Pending", "Completed"

    /**
     * Constructs a new PrintJob.
     *
     * @param fileName The name of the file to print.
     * @param pages    The number of pages in the file.
     * @throws IllegalArgumentException if file name is empty or pages is not positive.
     */
    public PrintJob(String fileName, int pages) {
        // Basic input validation
        if (fileName == null || fileName.trim().isEmpty()) {
            throw new IllegalArgumentException("File name cannot be empty.");
        }
        if (pages <= 0) {
            throw new IllegalArgumentException("Number of pages must be positive.");
        }

        this.jobId = idCounter.incrementAndGet(); // Assign unique ID
        this.fileName = fileName.trim();
        this.pages = pages;
        this.status = "Pending"; // Initial status
    }

    // --- Getters ---
    public int getJobId() {
        return jobId;
    }

    public String getFileName() {
        return fileName;
    }

    public int getPages() {
        return pages;
    }

    public String getStatus() {
        return status;
    }

    /**
     * Marks the job's status as "Completed".
     */
    public void markAsCompleted() {
        this.status = "Completed";
    }

    /**
     * Provides a string representation of the PrintJob.
     */
    @Override
    public String toString() {
        return String.format("Job ID: %d, File: %s, Pages: %d, Status: %s",
                             jobId, fileName, pages, status);
    }
}

/**
 * Manages the collection of print jobs, including pending and completed lists.
 */
class PrintManager {
    // Queue for jobs waiting to be processed (FIFO)
    private Queue<PrintJob> pendingJobs;
    // List for jobs that have been processed
    private List<PrintJob> completedJobs;

    /**
     * Constructs a new PrintManager, initializing the job collections.
     */
    public PrintManager() {
        // LinkedList is a common implementation of Queue
        this.pendingJobs = new LinkedList<>();
        // ArrayList is used as the implementation for the List of completed jobs
        this.completedJobs = new ArrayList<>();
    }

    /**
     * Adds a new print job to the pending queue.
     * Performs basic validation before creating the job.
     *
     * @param fileName The name of the file.
     * @param pages    The number of pages.
     * @return true if the job was added successfully, false otherwise (due to validation).
     */
    public boolean addJob(String fileName, int pages) {
        try {
            // Create PrintJob - constructor handles detailed validation and throws IllegalArgumentException
            PrintJob newJob = new PrintJob(fileName, pages);
            // Offer adds to the tail of the queue, preferred over add as it returns boolean on failure (though LinkedList doesn't typically fail)
            pendingJobs.offer(newJob);
            System.out.println("Job added: " + newJob.getFileName() + " (ID: " + newJob.getJobId() + ")");
            return true;
        } catch (IllegalArgumentException e) {
            // Catch validation errors from PrintJob constructor
            // Error message is handled by the caller (PrintApp) based on the false return
            return false;
        }
    }

    /**
     * Processes the next job in the pending queue.
     * Removes the job from pending, marks it as completed, and adds it to the completed list.
     *
     * @return The processed PrintJob, or null if the pending queue was empty.
     */
    public PrintJob processNextJob() {
        // poll() retrieves and removes the head of the queue, returns null if queue is empty
        PrintJob jobToProcess = pendingJobs.poll();

        if (jobToProcess != null) {
            jobToProcess.markAsCompleted();
            completedJobs.add(jobToProcess);
            System.out.println("Job processed: " + jobToProcess.getFileName() + " (ID: " + jobToProcess.getJobId() + ")");
            return jobToProcess;
        } else {
            // Queue was empty, return null to indicate no job was processed
            return null;
        }
    }

    /**
     * Gets a list of all pending print jobs.
     * Returns a new ArrayList containing the current pending jobs for encapsulation.
     *
     * @return An ArrayList containing the pending jobs.
     */
    public List<PrintJob> getPendingJobs() {
        // Return a copy to prevent external modification of the internal queue structure
        return new ArrayList<>(pendingJobs);
    }

    /**
     * Gets a list of all completed print jobs.
     * Returns a new ArrayList containing the current completed jobs for encapsulation.
     *
     * @return An ArrayList containing the completed jobs.
     */
    public List<PrintJob> getCompletedJobs() {
        // Return a copy to prevent external modification of the internal list
        return new ArrayList<>(completedJobs);
    }

    /**
     * Checks if the pending job queue is empty.
     *
     * @return true if the queue is empty, false otherwise.
     */
    public boolean isEmptyPending() {
        return pendingJobs.isEmpty();
    }
}

/**
 * Main application class to run the Print Job Management System.
 * Handles user interaction via a command-line menu.
 */
public class PrintApp {

    private PrintManager printManager;
    private Scanner scanner;

    /**
     * Constructs the PrintApp, initializing the manager and scanner.
     */
    public PrintApp() {
        this.printManager = new PrintManager();
        this.scanner = new Scanner(System.in);
    }

    /**
     * Runs the main application loop, displaying the menu and processing user input.
     */
    public void run() {
        int choice = -1; // Initialize choice to a non-exit value

        // Main application loop
        while (choice != 0) {
            printMenu();
            System.out.print("Enter your choice: ");

            String inputLine = scanner.nextLine(); // Read the entire line of input

            try {
                // Attempt to parse the input line as an integer
                choice = Integer.parseInt(inputLine);

                // Use a switch statement to handle different menu options
                switch (choice) {
                    case 1:
                        addJob(); // Call method to add a new job
                        break;
                    case 2:
                        processNextJob(); // Call method to process the next job
                        break;
                    case 3:
                        viewPendingJobs(); // Call method to view pending jobs
                        break;
                    case 4:
                        viewCompletedJobs(); // Call method to view completed jobs
                        break;
                    case 0:
                        System.out.println("Exiting Print Job Management System. Goodbye!");
                        break;
                    default:
                        // Handle invalid integer choices
                        System.err.println("Invalid choice. Please enter a number between 0 and 4.");
                }
            } catch (NumberFormatException e) {
                // Handle input that is not a valid integer using try-catch
                System.err.println("Invalid input. Please enter a number.");
                choice = -1; // Reset choice so the loop continues
            } catch (Exception e) {
                 // Catch any other unexpected exceptions during menu processing
                 System.err.println("An unexpected error occurred: " + e.getMessage());
                 // e.printStackTrace(System.err); // Optionally print stack trace for debugging
                 choice = -1; // Reset choice
            }
            System.out.println(); // Add a blank line for better readability between interactions
        }

        // Close the scanner resource when the application exits
        scanner.close();
    }

    /**
     * Displays the main menu options to the user.
     */
    private void printMenu() {
        System.out.println("--- Print Job Management Menu ---");
        System.out.println("1. Add New Print Job");
        System.out.println("2. Process Next Job");
        System.out.println("3. View Pending Jobs");
        System.out.println("4. View Completed Jobs");
        System.out.println("0. Exit");
        System.out.println("-------------------------------");
    }

    /**
     * Handles the process of adding a new print job based on user input.
     */
    private void addJob() {
        System.out.print("Enter file name: ");
        String fileName = scanner.nextLine(); // Read file name

        System.out.print("Enter number of pages: ");
        String pagesInput = scanner.nextLine(); // Read pages input as a string first

        try {
            // Attempt to parse pages input as an integer
            int pages = Integer.parseInt(pagesInput);

            // Call the PrintManager to add the job and check the result
            boolean success = printManager.addJob(fileName, pages);

            if (!success) {
                // Print specific error message if addJob failed due to validation
                System.err.println("Error adding job: File name cannot be empty or pages must be positive.");
            }
        } catch (NumberFormatException e) {
            // Handle non-integer input specifically for the pages field
            System.err.println("Invalid input for pages. Please enter a valid number.");
        } catch (Exception e) {
             // Catch any other unexpected exceptions during adding job process
             System.err.println("An unexpected error occurred while adding job: " + e.getMessage());
             // e.printStackTrace(System.err);
        }
    }

    /**
     * Handles the process of processing the next job in the queue.
     */
    private void processNextJob() {
        // Call the PrintManager to process the next job
        PrintJob processedJob = printManager.processNextJob();

        if (processedJob == null) {
            // If PrintManager returned null, the queue was empty. Use System.err for the error.
            System.err.println("No pending jobs to process.");
        }
        // Success message is printed by PrintManager itself
    }

    /**
     * Retrieves and displays the list of pending print jobs.
     */
    private void viewPendingJobs() {
        List<PrintJob> pending = printManager.getPendingJobs(); // Get the list of pending jobs

        if (pending.isEmpty()) {
            System.out.println("No pending jobs.");
        } else {
            System.out.println("--- Pending Jobs ---");
            // Iterate through the list and print each job's details
            for (PrintJob job : pending) {
                System.out.println(job); // PrintJob's toString() is used here
            }
            System.out.println("--------------------");
        }
    }

    /**
     * Retrieves and displays the list of completed print jobs.
     */
    private void viewCompletedJobs() {
        List<PrintJob> completed = printManager.getCompletedJobs(); // Get the list of completed jobs

        if (completed.isEmpty()) {
            System.out.println("No completed jobs.");
        } else {
            System.out.println("--- Completed Jobs ---");
            // Iterate through the list and print each job's details
            for (PrintJob job : completed) {
                System.out.println(job); // PrintJob's toString() is used here
            }
            System.out.println("----------------------");
        }
    }

    /**
     * Main method to start the application.
     *
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        PrintApp app = new PrintApp();
        app.run(); // Start the application loop
    }
}
