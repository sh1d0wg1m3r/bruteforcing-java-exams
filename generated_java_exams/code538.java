/*
 * Exam Question #538
 * Generated on: 2025-05-11 23:26:20
 * Generated by: Account 3
 * 
 * QUESTION:
 * ## Java Programming Exam Task: IT Support Task Dispatcher
 * 
 * **Scenario:**
 * 
 * You are tasked with building a simple command-line application to simulate a basic IT support task management system. The system should manage support tickets as they arrive, are processed, and completed.
 * 
 * **Requirements:**
 * 
 * 1.  **`SupportTicket` Class:**
 *     *   Create a class named `SupportTicket` to represent a single support request.
 *     *   It must have private fields: `id` (int), `description` (String), and `status` (String).
 *     *   The status should initially be "Pending".
 *     *   Provide a constructor to initialize the `id` and `description`.
 *     *   Provide public getter methods for all fields.
 *     *   Include a method `markAsCompleted()` to change the status to "Completed".
 *     *   Override the `toString()` method to provide a user-friendly representation of the ticket (e.g., "[ID] Description (Status)").
 * 
 * 2.  **`TaskDispatcher` Class:**
 *     *   Create a class named `TaskDispatcher` to manage the system's operations.
 *     *   It must use a `java.util.Queue<SupportTicket>` to store incoming (pending) tickets.
 *     *   It must use a `java.util.List<SupportTicket>` (implemented using `java.util.ArrayList`) to store completed tickets.
 *     *   Use a `java.util.Scanner` to read user input from the console.
 *     *   Implement a main application loop that presents a menu to the user.
 *     *   Use a `switch` statement to handle the user's menu choice.
 *     *   The menu options should be:
 *         *   `1. Add New Ticket`: Prompts the user for a ticket description, creates a new `SupportTicket` with a unique ID (starting from 1), and adds it to the incoming queue.
 *         *   `2. Dispatch Next Ticket`: Takes the ticket from the front of the incoming queue, marks it as "Completed", and moves it to the completed tickets list. If the queue is empty, display an error message.
 *         *   `3. View Pending Tickets`: Displays all tickets currently in the incoming queue in their current order.
 *         *   `4. List Completed Tickets`: Displays all tickets in the completed tickets list.
 *         *   `5. Exit`: Terminates the application.
 * 
 * 3.  **Input Handling and Validation:**
 *     *   Use `System.out` for displaying the menu, prompts, and normal output (ticket lists).
 *     *   Use `System.err` to display error messages (e.g., invalid menu choice, attempting to dispatch from an empty queue).
 *     *   Implement class-wide exception handling using `try-catch` blocks, particularly to handle potential issues with user input (e.g., non-integer input for menu choice). The loop should continue after an input error.
 *     *   Ensure input validation where necessary (e.g., checking if the queue is empty before dispatching).
 * 
 * 4.  **Best Practices:**
 *     *   Apply proper encapsulation (private fields, public methods).
 *     *   Use meaningful variable and method names.
 *     *   Include appropriate comments and documentation (e.g., Javadoc for classes/methods).
 *     *   Structure the code clearly into separate classes and methods.
 *     *   Ensure the `Scanner` resource is closed properly when the application exits.
 * 
 * **Expected Output:**
 * 
 * The program should run interactively. Upon starting, it displays the menu. The user can enter numbers corresponding to the options. The output should reflect the actions taken (tickets added, dispatched, lists displayed). Error messages should appear on `System.err`.
 * 
 * Example interaction flow:
 * ```
 * --- IT Support Task Dispatcher ---
 * 1. Add New Ticket
 * 2. Dispatch Next Ticket
 * 3. View Pending Tickets
 * 4. List Completed Tickets
 * 5. Exit
 * Enter your choice: 1
 * Enter ticket description: Printer not working
 * Ticket #1 added.
 * --- IT Support Task Dispatcher ---
 * ...
 * Enter your choice: 1
 * Enter ticket description: Software installation issue
 * Ticket #2 added.
 * --- IT Support Task Dispatcher ---
 * ...
 * Enter your choice: 3
 * --- Pending Tickets ---
 * [1] Printer not working (Pending)
 * [2] Software installation issue (Pending)
 * -----------------------
 * --- IT Support Task Dispatcher ---
 * ...
 * Enter your choice: 2
 * Dispatching ticket: [1] Printer not working (Pending)
 * Ticket #1 completed.
 * --- IT Support Task Dispatcher ---
 * ...
 * Enter your choice: 3
 * --- Pending Tickets ---
 * [2] Software installation issue (Pending)
 * -----------------------
 * --- IT Support Task Dispatcher ---
 * ...
 * Enter your choice: 4
 * --- Completed Tickets ---
 * [1] Printer not working (Completed)
 * -----------------------
 * --- IT Support Task Dispatcher ---
 * ...
 * Enter your choice: 2
 * Dispatching ticket: [2] Software installation issue (Pending)
 * Ticket #2 completed.
 * --- IT Support Task Dispatcher ---
 * ...
 * Enter your choice: 2
 * Error: No pending tickets to dispatch.
 * --- IT Support Task Dispatcher ---
 * ...
 * Enter your choice: invalid
 * Error: Invalid input. Please enter a number between 1 and 5.
 * --- IT Support Task Dispatcher ---
 * ...
 * Enter your choice: 5
 * Exiting Task Dispatcher.
 * ```
 *
 * EXPLANATION:
 * The provided solution implements a basic IT Support Task Dispatcher system, demonstrating the required Java concepts and best practices.
 * 
 * 1.  **`SupportTicket` Class:** This class serves as a well-encapsulated data structure representing a single ticket. It holds the ticket's ID, description, and status as private fields, accessible only through public getter methods. The `markAsCompleted()` method provides controlled modification of the status. The `toString()` method is overridden for convenient printing of ticket details.
 * 
 * 2.  **`TaskDispatcher` Class:** This is the core class managing the application logic.
 *     *   **`Queue<SupportTicket> incomingTicketsQueue`**: A `java.util.Queue` (implemented using `java.util.LinkedList`) is used to store tickets that are waiting to be processed. The Queue's First-In, First-Out (FIFO) nature is ideal for modeling a waiting line where the oldest ticket is handled first. Methods like `offer()` (to add) and `poll()` (to remove and retrieve) are used.
 *     *   **`List<SupportTicket> completedTicketsList`**: A `java.util.List` (implemented using `java.util.ArrayList`) is used to store tickets once they are marked as completed. A List is suitable here as there's no specific order required for processing; it simply serves as a collection of finished items.
 *     *   **`Scanner scanner`**: Used to read user input from the console (`System.in`).
 *     *   **`nextTicketId`**: An integer counter to ensure each new ticket receives a unique, sequential ID.
 *     *   **`run()` Method**: This method contains the main application loop. It repeatedly displays a menu, reads user input, and processes the request.
 *     *   **`switch` Statement**: Inside the `run()` method, a `switch` statement is used to efficiently route the user's integer choice to the corresponding method (`addTicket`, `dispatchNextTicket`, `viewPendingTickets`, `listCompletedTickets`, or exit).
 *     *   **Helper Methods (`addTicket`, `dispatchNextTicket`, etc.)**: Each menu option is handled by a dedicated private method within `TaskDispatcher`, promoting modularity and code organization.
 *         *   `addTicket()` prompts for input, creates a `SupportTicket`, and uses `incomingTicketsQueue.offer()` to add it to the queue.
 *         *   `dispatchNextTicket()` uses `incomingTicketsQueue.poll()` to retrieve and remove the next ticket from the front of the queue. It then calls `markAsCompleted()` on the retrieved ticket and adds it to the `completedTicketsList`. It includes validation to check if the queue is empty before attempting to poll.
 *         *   `viewPendingTickets()` iterates through the `incomingTicketsQueue` (using an enhanced for loop, which doesn't remove elements) and prints each ticket.
 *         *   `listCompletedTickets()` iterates through the `completedTicketsList` and prints each completed ticket.
 * 
 * 3.  **Input Handling and Error Handling:**
 *     *   **`Scanner`**: Used for reading input. `scanner.nextInt()` reads the integer choice, and `scanner.nextLine()` is used after reading the integer to consume the leftover newline character, preventing issues with subsequent `nextLine()` calls.
 *     *   **`try-catch` Blocks**: A `try-catch` block is wrapped around the input reading and processing within the main loop.
 *         *   `InputMismatchException` is specifically caught to handle cases where the user enters non-integer input when prompted for a menu choice. An error message is printed to `System.err`, and `scanner.nextLine()` is called within the catch block to clear the invalid input from the scanner buffer, preventing an infinite loop.
 *         *   A general `Exception` catch block is included as a fallback for any other unexpected runtime errors, printing the error message to `System.err`.
 *     *   **`System.err`**: Used specifically for displaying error messages, such as invalid menu choices, non-integer input, or attempting an operation on an empty queue. This separates error output from normal application output (`System.out`).
 *     *   **Input Validation**: The `dispatchNextTicket` method explicitly checks if `incomingTicketsQueue.isEmpty()` before attempting to poll. This prevents errors and provides a user-friendly message.
 * 
 * 4.  **Best Practices:**
 *     *   **Encapsulation**: Both `SupportTicket` and `TaskDispatcher` use private fields and public methods to control access and manage internal state.
 *     *   **Meaningful Names**: Class names (`SupportTicket`, `TaskDispatcher`), variable names (`incomingTicketsQueue`, `completedTicketsList`, `nextTicketId`), and method names (`addTicket`, `dispatchNextTicket`, `viewPendingTickets`) clearly indicate their purpose.
 *     *   **Comments and Documentation**: Javadoc comments are used for classes and methods to explain their function, parameters, and return values. Inline comments clarify specific logic where needed.
 *     *   **Clean Structure**: The code is divided into two logical classes. The `TaskDispatcher` class has a clear `run()` method orchestrating the application flow and separate methods for each distinct operation.
 *     *   **Resource Management**: The `closeScanner()` method ensures that the `Scanner` resource, which is tied to the system input stream, is properly closed when the application exits, preventing resource leaks.
 * 
 * This solution effectively demonstrates the required Java components and practices within a practical, interactive application.
 */

import java.util.Queue;
import java.util.LinkedList; // Common Queue implementation
import java.util.List;
import java.util.ArrayList;
import java.util.Scanner;
import java.util.InputMismatchException;

/**
 * Represents a single IT support ticket.
 */
class SupportTicket {
    private int id;
    private String description;
    private String status; // e.g., "Pending", "Completed"

    /**
     * Constructs a new SupportTicket.
     *
     * @param id          The unique identifier for the ticket.
     * @param description A brief description of the issue.
     */
    public SupportTicket(int id, String description) {
        this.id = id;
        this.description = description;
        this.status = "Pending"; // Initial status
    }

    // --- Getters ---
    public int getId() {
        return id;
    }

    public String getDescription() {
        return description;
    }

    public String getStatus() {
        return status;
    }

    /**
     * Marks the ticket status as "Completed".
     */
    public void markAsCompleted() {
        this.status = "Completed";
    }

    /**
     * Provides a string representation of the ticket.
     *
     * @return Formatted string representing the ticket.
     */
    @Override
    public String toString() {
        return "[" + id + "] " + description + " (" + status + ")";
    }
}

/**
 * Manages the IT support task dispatching system.
 */
public class TaskDispatcher {
    // Queue for tickets waiting to be processed (FIFO)
    private Queue<SupportTicket> incomingTicketsQueue;
    // List for tickets that have been completed
    private List<SupportTicket> completedTicketsList;
    private Scanner scanner;
    private int nextTicketId; // Counter for generating unique ticket IDs

    /**
     * Constructs a new TaskDispatcher.
     * Initializes the queue, list, scanner, and ticket ID counter.
     */
    public TaskDispatcher() {
        // LinkedList is a common implementation for Queue
        this.incomingTicketsQueue = new LinkedList<>();
        this.completedTicketsList = new ArrayList<>();
        this.scanner = new Scanner(System.in);
        this.nextTicketId = 1; // Start ticket IDs from 1
    }

    /**
     * Runs the main application loop, displaying the menu and processing user input.
     */
    public void run() {
        System.out.println("--- IT Support Task Dispatcher ---");
        boolean running = true;

        while (running) {
            printMenu();
            int choice = -1; // Default invalid choice

            try {
                System.out.print("Enter your choice: ");
                choice = scanner.nextInt();
                scanner.nextLine(); // Consume newline left-over

                // Using switch for menu control
                switch (choice) {
                    case 1:
                        addTicket();
                        break;
                    case 2:
                        dispatchNextTicket();
                        break;
                    case 3:
                        viewPendingTickets();
                        break;
                    case 4:
                        listCompletedTickets();
                        break;
                    case 5:
                        running = false; // Exit the loop
                        break;
                    default:
                        // Use System.err for invalid menu choices
                        System.err.println("Error: Invalid choice. Please enter a number between 1 and 5.");
                }
            } catch (InputMismatchException e) {
                // Handle non-integer input using try-catch
                System.err.println("Error: Invalid input. Please enter a number.");
                scanner.nextLine(); // Consume the invalid input to prevent infinite loop
            } catch (Exception e) {
                // General exception handling for unexpected errors
                System.err.println("An unexpected error occurred: " + e.getMessage());
                // Optionally log the exception details for debugging
                // e.printStackTrace(System.err);
            }
            System.out.println(); // Add a newline for better readability between interactions
        }

        System.out.println("Exiting Task Dispatcher.");
        closeScanner(); // Ensure scanner is closed
    }

    /**
     * Displays the main menu options to the user.
     */
    private void printMenu() {
        System.out.println("1. Add New Ticket");
        System.out.println("2. Dispatch Next Ticket");
        System.out.println("3. View Pending Tickets");
        System.out.println("4. List Completed Tickets");
        System.out.println("5. Exit");
    }

    /**
     * Adds a new support ticket to the incoming queue.
     * Prompts user for description and generates a unique ID.
     */
    private void addTicket() {
        System.out.print("Enter ticket description: ");
        String description = scanner.nextLine();

        if (description == null || description.trim().isEmpty()) {
             System.err.println("Error: Ticket description cannot be empty.");
             return;
        }

        SupportTicket newTicket = new SupportTicket(nextTicketId++, description);
        incomingTicketsQueue.offer(newTicket); // Use offer() for queue insertion
        System.out.println("Ticket #" + newTicket.getId() + " added.");
    }

    /**
     * Dispatches the next ticket from the queue.
     * Removes from queue, marks as completed, and adds to completed list.
     */
    private void dispatchNextTicket() {
        // Input validation: Check if the queue is empty
        if (incomingTicketsQueue.isEmpty()) {
            System.err.println("Error: No pending tickets to dispatch."); // Use System.err for this error
            return;
        }

        SupportTicket ticketToDispatch = incomingTicketsQueue.poll(); // Use poll() to remove from queue
        System.out.println("Dispatching ticket: " + ticketToDispatch); // Show ticket before status change
        ticketToDispatch.markAsCompleted();
        completedTicketsList.add(ticketToDispatch); // Add to the list of completed tickets
        System.out.println("Ticket #" + ticketToDispatch.getId() + " completed.");
    }

    /**
     * Displays all tickets currently in the incoming queue.
     */
    private void viewPendingTickets() {
        System.out.println("--- Pending Tickets ---");
        if (incomingTicketsQueue.isEmpty()) {
            System.out.println("No pending tickets.");
        } else {
            // Iterate through the queue without removing elements
            for (SupportTicket ticket : incomingTicketsQueue) {
                System.out.println(ticket); // Uses SupportTicket's toString()
            }
        }
        System.out.println("-----------------------");
    }

    /**
     * Displays all tickets that have been completed.
     */
    private void listCompletedTickets() {
        System.out.println("--- Completed Tickets ---");
        if (completedTicketsList.isEmpty()) {
            System.out.println("No completed tickets yet.");
        } else {
            // Iterate through the list
            for (SupportTicket ticket : completedTicketsList) {
                System.out.println(ticket); // Uses SupportTicket's toString()
            }
        }
        System.out.println("-----------------------");
    }

    /**
     * Closes the scanner resource.
     */
    private void closeScanner() {
        if (scanner != null) {
            scanner.close();
        }
    }

    /**
     * Main method to start the Task Dispatcher application.
     *
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        TaskDispatcher dispatcher = new TaskDispatcher();
        dispatcher.run();
    }
}
