/*
 * Exam Question #446
 * Generated on: 2025-05-11 23:12:18
 * Generated by: Account 5
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Hospital Appointment Scheduler
 * 
 * **Problem Description:**
 * 
 * You are tasked with developing a simplified Hospital Appointment Scheduling system. The system needs to manage a list of registered patients and a queue of appointments waiting to be seen by a doctor. Users should be able to perform several actions via a command-line interface: register new patients, schedule appointments for registered patients, view the current appointment queue, process (complete) the next appointment in the queue, and list all registered patients.
 * 
 * **System Requirements:**
 * 
 * 1.  **Patient Management:**
 *     *   Maintain a list of registered patients. Each patient should have a unique ID (integer), a name (string), and an age (integer).
 *     *   Allow users to register new patients by providing their name and age. The system should automatically assign a unique, sequential ID starting from 1.
 * 2.  **Appointment Scheduling:**
 *     *   Maintain a queue of appointments. An appointment should link a registered patient to the queue.
 *     *   Allow users to schedule an appointment for an *existing* registered patient by entering the patient's ID.
 *     *   If the patient ID does not exist, display an error.
 * 3.  **Queue Operations:**
 *     *   Allow users to view the current appointments waiting in the queue (without removing them). Display the patient details for each appointment in queue order.
 *     *   Allow users to process the next appointment. This simulates a patient being seen. The system should remove the appointment from the front of the queue and display details of the processed patient. If the queue is empty, display an error.
 * 4.  **Listing Patients:**
 *     *   Allow users to list all registered patients, displaying their ID, name, and age.
 * 5.  **User Interface:**
 *     *   Present a menu of options to the user.
 *     *   Use `Scanner` to read user input (menu choices, patient details, patient IDs).
 *     *   Use a `switch` statement to handle the different menu options.
 *     *   Use `System.out` for displaying the menu, successful operations, and lists.
 *     *   Use `System.err` for displaying error messages (invalid input, patient not found, empty queue operations).
 * 6.  **Exception Handling:**
 *     *   Implement robust error handling using `try-catch` blocks.
 *     *   Handle cases where the user enters non-integer input when an integer is expected (e.g., for menu choices, patient ID, age).
 *     *   Handle logical errors such as trying to schedule an appointment for a non-existent patient or trying to process an appointment from an empty queue.
 *     *   Implement class-wide exception handling where appropriate (e.g., wrapping the main operational loop).
 * 7.  **Code Structure and Best Practices:**
 *     *   Create appropriate classes (`Patient`, `Appointment`, `HospitalScheduler`).
 *     *   Use private fields and public methods for proper encapsulation.
 *     *   Use meaningful variable and method names.
 *     *   Include comments to explain complex parts.
 *     *   Declare collections using the interface type (`List`, `Queue`) and instantiate with concrete classes (`ArrayList`, `LinkedList` or `ArrayDeque`). You *must* use `List` and `ArrayList` specifically as required. For the `Queue`, you can choose an appropriate implementation (like `LinkedList` or `ArrayDeque`).
 *     *   Ensure resources like `Scanner` are managed properly (though closing Scanner connected to System.in is debated, for an exam context, it's often omitted or handled carefully).
 * 
 * **Required Java Components (MUST use ALL):**
 * 
 * *   `java.util.Queue`
 * *   `java.util.ArrayList`
 * *   `java.util.List`
 * *   `java.util.Scanner`
 * *   `switch` statement
 * *   `System.err`
 * *   `System.out`
 * *   `try-catch` blocks
 * 
 * **Expected Interaction:**
 * 
 * The program should display a menu like this:
 * 
 * ```
 * Hospital Appointment Scheduler Menu:
 * 1. Register Patient
 * 2. Schedule Appointment
 * 3. View Appointment Queue
 * 4. Process Next Appointment
 * 5. List All Patients
 * 6. Exit
 * Enter your choice:
 * ```
 * 
 * Based on the choice, the system will prompt for necessary input or display information/errors.
 * 
 * **Example Flow:**
 * 
 * 1.  User chooses 1 (Register Patient). Prompts for name and age. Registers patient 1.
 * 2.  User chooses 1 (Register Patient). Prompts for name and age. Registers patient 2.
 * 3.  User chooses 5 (List All Patients). Displays patient 1 and 2.
 * 4.  User chooses 2 (Schedule Appointment). Prompts for Patient ID. User enters 1. Appointment for patient 1 added to queue.
 * 5.  User chooses 2 (Schedule Appointment). Prompts for Patient ID. User enters 3. Displays error "Patient with ID 3 not found."
 * 6.  User chooses 2 (Schedule Appointment). Prompts for Patient ID. User enters 2. Appointment for patient 2 added to queue.
 * 7.  User chooses 3 (View Appointment Queue). Displays appointments for patient 1, then patient 2.
 * 8.  User chooses 4 (Process Next Appointment). Removes patient 1's appointment, displays "Processing appointment for Patient ID: 1, Name: Patient1".
 * 9.  User chooses 3 (View Appointment Queue). Displays appointment for patient 2.
 * 10. User chooses 4 (Process Next Appointment). Removes patient 2's appointment, displays "Processing appointment for Patient ID: 2, Name: Patient2".
 * 11. User chooses 4 (Process Next Appointment). Displays error "Appointment queue is empty."
 * 12. User chooses 6 (Exit). Program terminates.
 * 
 * **Constraints:**
 * 
 * *   Use *only* the specified Java components and standard libraries.
 * *   Focus on demonstrating the required components effectively within the described scenario.
 * 
 * ---
 *
 * EXPLANATION:
 * This solution implements the Hospital Appointment Scheduler system as described, demonstrating the required Java concepts and adhering to best practices.
 * 
 * 1.  **Class Structure:**
 *     *   `Patient`: A simple Plain Old Java Object (POJO) class to hold patient data (ID, name, age) with private fields and public getters, ensuring encapsulation. `toString()` is overridden for convenient printing.
 *     *   `Appointment`: A simple class linking an appointment to a `Patient` object. It also uses encapsulation and overrides `toString()`.
 *     *   `HospitalScheduler`: The main class orchestrating the system logic. It holds the collections (`registeredPatients` and `appointmentQueue`) and the `Scanner`.
 * 
 * 2.  **Required Component Usage:**
 *     *   `java.util.List` and `java.util.ArrayList`: The `registeredPatients` field is declared as `List<Patient>` and instantiated as `new ArrayList<>()`. This demonstrates programming to the interface. `ArrayList` is used for storing patients because random access by index isn't heavily used, but iteration and adding elements are common, which `ArrayList` handles efficiently.
 *     *   `java.util.Queue`: The `appointmentQueue` field is declared as `Queue<Appointment>` and instantiated as `new LinkedList<>()` (or `ArrayDeque`). `LinkedList` is a common choice for a `Queue` implementation as it provides efficient additions (`offer`) and removals (`poll`) from the ends. The `scheduleAppointment` method uses `offer` to add to the tail, and `processNextAppointment` uses `poll` to remove from the head, following the FIFO (First-In, First-Out) principle of a queue.
 *     *   `java.util.Scanner`: An instance of `Scanner` is created to read input from `System.in` in the `HospitalScheduler` constructor. It's used in the `run`, `registerPatient`, and `scheduleAppointment` methods to get menu choices, patient details, and patient IDs from the user. `scanner.nextLine()` is used after `nextInt()` to consume the leftover newline character, preventing input issues.
 *     *   `switch` statement: The `run()` method uses a `switch` statement on the user's menu `choice` to direct execution to the appropriate method (`registerPatient`, `scheduleAppointment`, etc.). This provides clear and structured flow control based on discrete options.
 *     *   `System.err`: Used specifically for printing error messages, such as invalid menu choices, input type mismatches, patient not found errors, and attempts to process an empty queue. This distinguishes error output from normal program output.
 *     *   `System.out`: Used for all normal output, including the menu, prompts for input, success messages, and displaying the lists of patients and the appointment queue.
 *     *   `try-catch` blocks:
 *         *   Input Validation: `try-catch(InputMismatchException e)` blocks are used around `scanner.nextInt()` calls (in `run`, `registerPatient`, `scheduleAppointment`) to gracefully handle cases where the user enters non-integer input when a number is expected.
 *         *   Logical Errors: `if` conditions are used to check for logical errors like an empty queue (`appointmentQueue.isEmpty()` before `poll`) or a patient not being found (`findPatientById` returning `null`). Error messages for these are printed using `System.err`.
 *         *   Class-wide Handling: A large `try-catch(Exception e)` block wraps the main `while` loop in the `run()` method. This provides a safety net to catch any unexpected runtime exceptions that might occur during the program's execution, preventing the program from crashing abruptly and providing a basic error message.
 * 
 * 3.  **Logic Implementation:**
 *     *   Patient IDs are managed using a simple counter (`nextPatientId`) incremented each time a patient is registered, ensuring uniqueness.
 *     *   `registerPatient` collects name and age (with basic age validation and input type handling) and adds a new `Patient` object to the `registeredPatients` `ArrayList`.
 *     *   `scheduleAppointment` prompts for a patient ID, uses the helper method `findPatientById` to locate the patient in the `registeredPatients` `List`, and if found, creates an `Appointment` object and adds it to the `appointmentQueue`. Input validation for the ID type is included.
 *     *   `findPatientById` iterates through the `registeredPatients` `List` to find a patient matching the given ID.
 *     *   `viewAppointmentQueue` iterates through the `appointmentQueue` (without removing elements) and prints the details of the patient for each appointment. It handles the empty queue case.
 *     *   `processNextAppointment` uses `appointmentQueue.poll()` to retrieve and remove the element at the head of the queue. It checks if `poll` returned `null` (indicating an empty queue) before attempting to process.
 *     *   `listRegisteredPatients` iterates through the `registeredPatients` `List` and prints each patient's details. It handles the empty list case.
 *     *   The `run` method contains the main loop, menu display, input reading, `switch` control, and core exception handling.
 * 
 * 4.  **Best Practices:**
 *     *   Private fields and public methods enforce encapsulation.
 *     *   Method and variable names are descriptive (e.g., `registeredPatients`, `scheduleAppointment`, `findPatientById`).
 *     *   Comments explain the purpose of classes, methods, and specific code sections (like `scanner.nextLine()` after `nextInt()`).
 *     *   Input validation (checking age > 0, catching `InputMismatchException`) is present.
 *     *   Error handling distinguishes between input errors (`InputMismatchException`) and logical errors (empty queue, patient not found).
 *     *   The use of `List` and `Queue` interfaces promotes flexibility, although the problem specifically required `ArrayList` for the list implementation.
 * 
 * This solution effectively combines the required Java components within a practical scenario, demonstrating understanding of data structures, object-oriented programming principles, user interaction, and robust error handling.
 */

import java.util.ArrayList;
import java.util.LinkedList; // A common Queue implementation
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.InputMismatchException;

// Represents a patient
class Patient {
    private int id;
    private String name;
    private int age;

    // Constructor
    public Patient(int id, String name, int age) {
        this.id = id;
        this.name = name;
        this.age = age;
    }

    // Getters
    public int getId() {
        return id;
    }

    public String getName() {
        return name;
    }

    public int getAge() {
        return age;
    }

    // Override toString for easy printing
    @Override
    public String toString() {
        return "Patient [ID=" + id + ", Name=" + name + ", Age=" + age + "]";
    }
}

// Represents an appointment (simply holds a reference to the patient)
class Appointment {
    private Patient patient;

    // Constructor
    public Appointment(Patient patient) {
        this.patient = patient;
    }

    // Getter
    public Patient getPatient() {
        return patient;
    }

    // Override toString for easy printing
    @Override
    public String toString() {
        return "Appointment for " + patient.toString();
    }
}

// Main class managing the hospital scheduling logic
public class HospitalScheduler {

    // Required: List to store registered patients
    private List<Patient> registeredPatients;

    // Required: Queue to store appointments
    private Queue<Appointment> appointmentQueue;

    // Required: Scanner for user input
    private Scanner scanner;

    // Counter for unique patient IDs
    private int nextPatientId;

    // Constructor
    public HospitalScheduler() {
        // Instantiate the required collections
        this.registeredPatients = new ArrayList<>(); // Required: ArrayList
        this.appointmentQueue = new LinkedList<>(); // Common Queue implementation
        this.scanner = new Scanner(System.in); // Required: Scanner
        this.nextPatientId = 1; // Start IDs from 1
    }

    // Main method to start the application
    public static void main(String[] args) {
        HospitalScheduler scheduler = new HospitalScheduler();
        scheduler.run(); // Start the main operational loop
    }

    // Main application loop
    public void run() {
        System.out.println("Welcome to the Hospital Appointment Scheduler!");
        int choice = -1;

        // Class-wide exception handling for the main loop
        try {
            while (choice != 6) {
                printMenu();
                try {
                    System.out.print("Enter your choice: ");
                    choice = scanner.nextInt();
                    scanner.nextLine(); // Consume newline left-over

                    // Required: switch statement for flow control
                    switch (choice) {
                        case 1:
                            registerPatient();
                            break;
                        case 2:
                            scheduleAppointment();
                            break;
                        case 3:
                            viewAppointmentQueue();
                            break;
                        case 4:
                            processNextAppointment();
                            break;
                        case 5:
                            listRegisteredPatients();
                            break;
                        case 6:
                            System.out.println("Exiting Hospital Appointment Scheduler. Goodbye!");
                            break;
                        default:
                            // Required: System.err for error messages
                            System.err.println("Invalid choice. Please enter a number between 1 and 6.");
                    }
                } catch (InputMismatchException e) {
                    // Required: try-catch for input validation errors
                    System.err.println("Invalid input. Please enter a number.");
                    scanner.nextLine(); // Consume the invalid input to prevent infinite loop
                    choice = -1; // Reset choice to stay in the loop
                }
                System.out.println(); // Add a newline for better readability between operations
            }
        } catch (Exception e) {
            // Generic catch for any unexpected errors in the main loop
            System.err.println("An unexpected error occurred: " + e.getMessage());
            e.printStackTrace(); // Print stack trace for debugging
        } finally {
            // Close the scanner when the application exits
            if (scanner != null) {
                // scanner.close(); // Closing System.in is generally avoided in applications
            }
        }
    }

    // Displays the main menu
    private void printMenu() {
        System.out.println("Hospital Appointment Scheduler Menu:");
        System.out.println("1. Register Patient");
        System.out.println("2. Schedule Appointment");
        System.out.println("3. View Appointment Queue");
        System.out.println("4. Process Next Appointment");
        System.out.println("5. List All Patients");
        System.out.println("6. Exit");
    }

    // Handles patient registration
    private void registerPatient() {
        System.out.println("--- Register New Patient ---");
        System.out.print("Enter patient name: ");
        String name = scanner.nextLine();

        int age = -1;
        boolean validAge = false;
        while (!validAge) {
            try {
                System.out.print("Enter patient age: ");
                age = scanner.nextInt();
                scanner.nextLine(); // Consume newline
                if (age > 0) {
                    validAge = true;
                } else {
                    System.err.println("Age must be a positive number.");
                }
            } catch (InputMismatchException e) {
                System.err.println("Invalid input for age. Please enter a number.");
                scanner.nextLine(); // Consume invalid input
            }
        }

        Patient newPatient = new Patient(nextPatientId++, name, age);
        registeredPatients.add(newPatient); // Add to the List
        System.out.println("Patient registered successfully: " + newPatient); // Required: System.out
    }

    // Handles scheduling an appointment for a registered patient
    private void scheduleAppointment() {
        System.out.println("--- Schedule Appointment ---");
        if (registeredPatients.isEmpty()) {
            System.err.println("No patients registered yet. Please register a patient first.");
            return;
        }

        System.out.print("Enter Patient ID to schedule appointment: ");
        try {
            int patientId = scanner.nextInt();
            scanner.nextLine(); // Consume newline

            // Find the patient by ID in the List
            Patient patientToSchedule = findPatientById(patientId);

            if (patientToSchedule != null) {
                Appointment newAppointment = new Appointment(patientToSchedule);
                appointmentQueue.offer(newAppointment); // Add to the Queue (offer is safer than add)
                System.out.println("Appointment scheduled for Patient ID: " + patientId + ", Name: " + patientToSchedule.getName()); // Required: System.out
            } else {
                // Required: System.err for error messages
                System.err.println("Patient with ID " + patientId + " not found.");
            }
        } catch (InputMismatchException e) {
            // Required: try-catch for input validation errors
            System.err.println("Invalid input. Please enter a valid Patient ID (number).");
            scanner.nextLine(); // Consume invalid input
        }
    }

    // Finds a patient in the registeredPatients list by ID
    private Patient findPatientById(int id) {
        // Iterate through the List to find the patient
        for (Patient patient : registeredPatients) {
            if (patient.getId() == id) {
                return patient;
            }
        }
        return null; // Patient not found
    }

    // Views the current appointment queue without removing elements
    private void viewAppointmentQueue() {
        System.out.println("--- Current Appointment Queue ---");
        if (appointmentQueue.isEmpty()) {
            System.out.println("Appointment queue is empty."); // Required: System.out
        } else {
            int i = 1;
            // Iterate through the Queue (using a loop is fine, iterator also works)
            for (Appointment appointment : appointmentQueue) {
                System.out.println(i++ + ". " + appointment.getPatient().toString()); // Required: System.out
            }
        }
    }

    // Processes the next appointment in the queue
    private void processNextAppointment() {
        System.out.println("--- Processing Next Appointment ---");
        // Required: Queue operation (poll or remove)
        Appointment nextAppointment = appointmentQueue.poll(); // poll is safer, returns null if empty

        if (nextAppointment != null) {
            Patient patient = nextAppointment.getPatient();
            System.out.println("Processing appointment for " + patient.toString()); // Required: System.out
            // Simulate processing...
        } else {
            // Required: System.err for error messages
            System.err.println("Appointment queue is empty. No appointments to process.");
        }
    }

    // Lists all registered patients
    private void listRegisteredPatients() {
        System.out.println("--- All Registered Patients ---");
        // Required: List operation (iteration)
        if (registeredPatients.isEmpty()) {
            System.out.println("No patients registered yet."); // Required: System.out
        } else {
            for (Patient patient : registeredPatients) {
                System.out.println(patient.toString()); // Required: System.out
            }
        }
    }
}
