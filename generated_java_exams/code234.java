/*
 * Exam Question #234
 * Generated on: 2025-05-11 22:36:33
 * Generated by: Account 4
 * 
 * QUESTION:
 * **Java Programming Exam: Automated Resource Allocation System**
 * 
 * **Problem Description:**
 * 
 * You are tasked with developing a simple Automated Resource Allocation System. This system manages requests for various resources. Requests arrive and are processed in a First-In, First-Out (FIFO) manner. The system should allow users to add new resource requests, process the next pending request, and view both pending and completed requests.
 * 
 * Your implementation must adhere to the following requirements and best practices:
 * 
 * 1.  **Data Structures:**
 *     *   Use a `java.util.Queue` to store pending resource requests.
 *     *   Use a `java.util.ArrayList` to store completed resource allocations.
 *     *   Use the `java.util.List` interface for declaring the type of the completed requests collection (demonstrating interface usage).
 * 
 * 2.  **User Interaction:**
 *     *   Use `java.util.Scanner` to get user input for menu choices and request details.
 *     *   Implement a menu-driven interface with options:
 *         1.  Add New Request
 *         2.  Process Next Request
 *         3.  View Pending Requests
 *         4.  View Completed Requests
 *         5.  Exit
 *     *   Use a `switch` statement to handle the user's menu choice.
 * 
 * 3.  **Output:**
 *     *   Use `System.out` for displaying the menu, request details, and success messages.
 *     *   Use `System.err` for displaying error messages (e.g., invalid input, queue empty).
 * 
 * 4.  **Error Handling:**
 *     *   Implement class-wide exception handling using a `try-catch` block around the main application loop to catch unexpected runtime errors.
 *     *   Implement input validation within the "Add New Request" functionality, specifically handling non-integer input for quantity and ensuring quantity is positive. Report validation errors using `System.err`.
 * 
 * 5.  **Object-Oriented Design:**
 *     *   Create a class `AllocationRequest` to represent a single resource request with private fields for request ID, resource type (String), and quantity (int). Include a constructor, getters, and a `toString()` method.
 *     *   Create a class `ResourceAllocationSystem` that encapsulates the `Queue` and `List` data structures and provides methods for the system's operations (add, process, view).
 *     *   Ensure proper encapsulation (private fields, public methods).
 * 
 * 6.  **Code Quality:**
 *     *   Use meaningful variable and method names.
 *     *   Include appropriate comments and documentation (e.g., Javadoc for classes and methods).
 *     *   Maintain a clean and readable code structure.
 * 
 * **Expected Output Structure:**
 * 
 * The program should continuously display the menu, accept user input, and perform the requested action. Output should clearly indicate the results of each operation, including error messages when appropriate.
 * 
 * Example interaction flow (truncated):
 * 
 * ```
 * --- Resource Allocation Menu ---
 * 1. Add New Request
 * 2. Process Next Request
 * 3. View Pending Requests
 * 4. View Completed Requests
 * 5. Exit
 * Enter your choice: 1
 * Enter resource type: CPU
 * Enter quantity: 5
 * Request ID 1 (CPU, Quantity: 5) added to pending queue.
 * 
 * --- Resource Allocation Menu ---
 * 1. Add New Request
 * ...
 * Enter your choice: 2
 * Processing request ID 1 (CPU, Quantity: 5). Moved to completed.
 * 
 * --- Resource Allocation Menu ---
 * ...
 * Enter your choice: 3
 * Pending Requests:
 * Queue is empty.
 * 
 * --- Resource Allocation Menu ---
 * ...
 * Enter your choice: 4
 * Completed Requests:
 * Request ID 1 (CPU, Quantity: 5)
 * 
 * --- Resource Allocation Menu ---
 * ...
 * Enter your choice: 5
 * Exiting system.
 * ```
 * 
 * If invalid input is given for quantity:
 * 
 * ```
 * Enter resource type: Memory
 * Enter quantity: abc
 * Error: Invalid quantity. Please enter a positive integer.
 * ```
 * 
 * If processing an empty queue:
 * 
 * ```
 * Enter your choice: 2
 * System.err: Error: No pending requests to process.
 * ```
 * 
 * **Task:**
 * 
 * Write the complete Java code for the `AllocationRequest` and `ResourceAllocationSystem` classes, including the `main` method to run the system, fulfilling all the requirements above.
 *
 * EXPLANATION:
 * The solution implements the `ResourceAllocationSystem` as required, demonstrating the use of various Java components and best practices.
 * 
 * 1.  **`AllocationRequest` Class:** This simple class encapsulates the data for a single request (`requestId`, `resourceType`, `quantity`). It follows encapsulation principles with private fields and public getters. The `toString()` method provides a convenient way to print request details.
 * 
 * 2.  **`ResourceAllocationSystem` Class:** This is the core class managing the system's state and operations.
 *     *   **Data Structures:**
 *         *   `pendingRequests`: Declared as `Queue<AllocationRequest>` and initialized with `LinkedList`. This correctly uses `Queue` for FIFO behavior.
 *         *   `completedRequests`: Declared as `List<AllocationRequest>` and initialized with `ArrayList`. This fulfills the requirement to use both `List` interface and `ArrayList` implementation.
 *     *   **State:** `nextRequestId` is used to assign unique IDs to new requests.
 *     *   **`Scanner` Management:** The `Scanner` is created and managed within the `ResourceAllocationSystem` class, and properly closed in the `finally` block of the `run` method.
 *     *   **`displayMenu()`:** A simple private helper method to print the menu options to `System.out`.
 *     *   **`addRequest()`:**
 *         *   Takes user input for resource type and quantity.
 *         *   Includes input validation:
 *             *   It first checks if the next input is an integer using `scanner.hasNextInt()` before attempting to read it. This prevents `InputMismatchException`.
 *             *   It uses a `try-catch` block specifically for `NumberFormatException` if `hasNextInt()` was not used (though the current implementation with `hasNextInt()` makes this less likely, it's good practice to show error handling for parsing).
 *             *   It throws and catches an `IllegalArgumentException` if the quantity is not positive.
 *         *   Uses `System.err` to report validation errors.
 *         *   If input is valid, it creates an `AllocationRequest` and adds it to the `pendingRequests` queue using `offer()`. `offer()` is generally preferred over `add()` for queues as it's designed to handle capacity-constrained queues gracefully (though `LinkedList` is not capacity-constrained).
 *     *   **`processNextRequest()`:**
 *         *   Checks if the `pendingRequests` queue is empty. If so, it prints an error to `System.err`.
 *         *   If not empty, it removes the head of the queue using `poll()` (which returns `null` if empty, but we've already checked, or the element if present) and adds it to the `completedRequests` `ArrayList`.
 *         *   Prints a success message to `System.out`.
 *     *   **`viewPendingRequests()`:**
 *         *   Prints a header to `System.out`.
 *         *   Checks if the queue is empty.
 *         *   If not empty, it iterates through the queue to print its contents. Note that iterating directly over a `Queue` doesn't remove elements. Creating a temporary `ArrayList` is one way to easily iterate and print without modifying the queue.
 *     *   **`viewCompletedRequests()`:**
 *         *   Prints a header to `System.out`.
 *         *   Checks if the list is empty.
 *         *   If not empty, it iterates through the `ArrayList` and prints each completed request.
 *     *   **`run()`:**
 *         *   Contains the main application loop (`while`).
 *         *   **Class-wide Exception Handling:** The entire `while` loop is wrapped in a `try-catch(Exception e)` block. This fulfills the requirement for class-wide handling, catching any *unanticipated* exceptions that might occur within the loop's execution (e.g., NullPointerException, ArrayIndexOutOfBoundsException, etc., if they weren't handled more specifically elsewhere). It prints the error details to `System.err`.
 *         *   **Input Reading `try-catch`:** A nested `try-catch` block handles potential issues specifically when reading the user's menu choice using `scanner.nextInt()`, preventing the program from crashing on non-integer menu input. It uses `NoSuchElementException` and `IllegalStateException` which can occur with `Scanner`, and a general `Exception` for other input issues, printing errors to `System.err`.
 *         *   **`switch` Statement:** Used effectively to direct program flow based on the user's valid menu choice.
 *         *   **`finally` Block:** Ensures the `scanner.close()` method is called regardless of whether an exception occurred or the loop exited normally. This is crucial for resource management.
 * 
 * 3.  **`main` Method:** The standard entry point that creates an instance of `ResourceAllocationSystem` and calls its `run()` method to start the application.
 * 
 * This solution effectively combines the required data structures, handles user input with validation and error reporting (`System.err`), uses a `switch` statement for control flow, and demonstrates both specific and class-wide exception handling using `try-catch`, all within a well-structured, object-oriented design.
 */

import java.util.Queue;
import java.util.LinkedList;
import java.util.List;
import java.util.ArrayList;
import java.util.Scanner;
import java.util.NoSuchElementException; // For Scanner issues

/**
 * Represents a single resource allocation request.
 */
class AllocationRequest {
    private int requestId;
    private String resourceType;
    private int quantity;

    /**
     * Constructs a new AllocationRequest.
     *
     * @param requestId The unique ID for the request.
     * @param resourceType The type of resource requested.
     * @param quantity The quantity of the resource requested.
     */
    public AllocationRequest(int requestId, String resourceType, int quantity) {
        this.requestId = requestId;
        this.resourceType = resourceType;
        this.quantity = quantity;
    }

    // Getters
    public int getRequestId() {
        return requestId;
    }

    public String getResourceType() {
        return resourceType;
    }

    public int getQuantity() {
        return quantity;
    }

    /**
     * Provides a string representation of the request.
     *
     * @return A formatted string describing the request.
     */
    @Override
    public String toString() {
        return "Request ID " + requestId + " (" + resourceType + ", Quantity: " + quantity + ")";
    }
}

/**
 * Manages the resource allocation process using a pending queue and a completed list.
 */
public class ResourceAllocationSystem {

    private Queue<AllocationRequest> pendingRequests;
    private List<AllocationRequest> completedRequests; // Using List interface type
    private int nextRequestId;
    private Scanner scanner; // Scanner is managed within the system class

    /**
     * Constructs a new ResourceAllocationSystem.
     */
    public ResourceAllocationSystem() {
        // Using LinkedList as an implementation of Queue
        this.pendingRequests = new LinkedList<>();
        // Using ArrayList as an implementation of List
        this.completedRequests = new ArrayList<>();
        this.nextRequestId = 1;
        this.scanner = new Scanner(System.in);
    }

    /**
     * Displays the main menu options to the user.
     */
    private void displayMenu() {
        System.out.println("\n--- Resource Allocation Menu ---");
        System.out.println("1. Add New Request");
        System.out.println("2. Process Next Request");
        System.out.println("3. View Pending Requests");
        System.out.println("4. View Completed Requests");
        System.out.println("5. Exit");
        System.out.print("Enter your choice: ");
    }

    /**
     * Adds a new resource request based on user input.
     * Handles input validation for quantity.
     */
    private void addRequest() {
        System.out.print("Enter resource type: ");
        String resourceType = scanner.nextLine();

        int quantity = -1; // Use a default invalid value
        System.out.print("Enter quantity: ");

        try {
            // Check if the next input is an integer before reading
            if (scanner.hasNextInt()) {
                quantity = scanner.nextInt();
                // Consume the newline character left by nextInt()
                scanner.nextLine();
            } else {
                // Consume the invalid input
                scanner.nextLine();
                throw new NumberFormatException("Input is not an integer.");
            }

            // Validate quantity is positive
            if (quantity <= 0) {
                throw new IllegalArgumentException("Quantity must be a positive integer.");
            }

            // Create and add the request
            AllocationRequest newRequest = new AllocationRequest(nextRequestId++, resourceType, quantity);
            pendingRequests.offer(newRequest); // offer is generally preferred over add for queues
            System.out.println(newRequest + " added to pending queue.");

        } catch (NumberFormatException e) {
            System.err.println("Error: Invalid quantity. Please enter an integer.");
        } catch (IllegalArgumentException e) {
            System.err.println("Error: " + e.getMessage());
        }
    }

    /**
     * Processes the next pending request (FIFO).
     * Moves the request from the pending queue to the completed list.
     */
    private void processNextRequest() {
        if (pendingRequests.isEmpty()) {
            System.err.println("Error: No pending requests to process.");
        } else {
            AllocationRequest processedRequest = pendingRequests.poll(); // poll removes and returns the head
            completedRequests.add(processedRequest);
            System.out.println("Processing " + processedRequest + ". Moved to completed.");
        }
    }

    /**
     * Displays all pending requests in the queue.
     */
    private void viewPendingRequests() {
        System.out.println("\nPending Requests:");
        if (pendingRequests.isEmpty()) {
            System.out.println("Queue is empty.");
        } else {
            // Iterate through the queue without removing elements
            // Creating a temporary list or using an iterator is common
            List<AllocationRequest> tempPendingList = new ArrayList<>(pendingRequests);
            for (AllocationRequest request : tempPendingList) {
                System.out.println(request);
            }
        }
    }

    /**
     * Displays all completed requests in the list.
     */
    private void viewCompletedRequests() {
        System.out.println("\nCompleted Requests:");
        if (completedRequests.isEmpty()) {
            System.out.println("No requests completed yet.");
        } else {
            for (AllocationRequest request : completedRequests) {
                System.out.println(request);
            }
        }
    }

    /**
     * Runs the main application loop, handling user interaction and exceptions.
     */
    public void run() {
        int choice = 0;
        // Class-wide exception handling for the main loop
        try {
            while (choice != 5) {
                displayMenu();

                // Read user choice, handling potential non-integer input for the choice itself
                try {
                    choice = scanner.nextInt();
                    // Consume the newline character left by nextInt()
                    scanner.nextLine();
                } catch (NoSuchElementException | IllegalStateException e) {
                    System.err.println("Error reading input. Exiting.");
                    // Break loop or re-throw if necessary
                    break;
                } catch (Exception e) { // Catch any other potential input issues
                     System.err.println("Invalid input. Please enter a number.");
                     // Consume the rest of the line to prevent infinite loop on bad input
                     scanner.nextLine();
                     choice = 0; // Reset choice to prevent unintended action
                     continue; // Continue to the next iteration
                }


                // Use a switch statement for flow control based on user choice
                switch (choice) {
                    case 1:
                        addRequest();
                        break;
                    case 2:
                        processNextRequest();
                        break;
                    case 3:
                        viewPendingRequests();
                        break;
                    case 4:
                        viewCompletedRequests();
                        break;
                    case 5:
                        System.out.println("Exiting system.");
                        break;
                    default:
                        System.err.println("Invalid choice. Please enter a number between 1 and 5.");
                }
            }
        } catch (Exception e) {
            // Catch any unexpected runtime exceptions that were not handled elsewhere
            System.err.println("\nAn unexpected system error occurred:");
            e.printStackTrace(System.err); // Print stack trace to standard error
        } finally {
            // Ensure the scanner is closed when the application exits
            if (scanner != null) {
                scanner.close();
            }
            System.out.println("Scanner closed."); // Confirmation
        }
    }

    /**
     * Main method to start the application.
     *
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        ResourceAllocationSystem system = new ResourceAllocationSystem();
        system.run();
    }
}
