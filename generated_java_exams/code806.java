/*
 * Exam Question #806
 * Generated on: 2025-05-12 16:43:25
 * Generated by: Account 1
 * 
 * QUESTION:
 * ## Advanced Java Programming Exam Task: Task Processing System
 * 
 * **Objective:** Design and implement a command-line based system to manage and process tasks. The system should allow users to add tasks, process the next pending task, and view lists of pending and completed tasks. This task requires demonstrating proficiency in core Java data structures, input handling, control flow, object-oriented principles, and exception handling.
 * 
 * **Scenario:** You are developing a simple task management backend. Tasks are added to a queue for processing in a First-In, First-Out (FIFO) manner. Once processed, tasks are moved to a list of completed items.
 * 
 * **Requirements:**
 * 
 * 1.  **Task Representation:** Create a class `Task` with the following attributes:
 *     *   `taskId` (int): A unique identifier for the task.
 *     *   `description` (String): A brief description of the task.
 *     *   `priority` (String): The priority level (e.g., "High", "Standard").
 *     *   `status` (String): The current status (e.g., "Pending", "Completed").
 *     *   Implement appropriate constructors, getters, and a `toString()` method for easy display. Ensure fields are private.
 * 
 * 2.  **Task Processing System:** Create a class `TaskProcessingSystem` that manages the tasks. It must include:
 *     *   A `Queue<Task>` to hold tasks waiting to be processed.
 *     *   A `List<Task>` (declared as `java.util.List`, instantiated as `java.util.ArrayList`) to store completed tasks.
 *     *   A `Scanner` object for reading user input from the console.
 *     *   A mechanism to generate unique task IDs (e.g., an incrementing counter).
 * 
 * 3.  **Functionality:** The system should provide the following options via a command-line menu:
 *     *   `1. Add New Task`: Prompt the user for a task description and priority. Create a `Task` object with a unique ID, set its status to "Pending", and add it to the processing queue.
 *     *   `2. Process Next Task`: Remove the task at the front of the queue. Update its status to "Completed" and add it to the list of completed tasks. If the queue is empty, inform the user.
 *     *   `3. View Pending Tasks`: Display all tasks currently in the processing queue, maintaining their order. If the queue is empty, display an appropriate message.
 *     *   `4. View Completed Tasks`: Display all tasks in the completed tasks list. If the list is empty, display an appropriate message.
 *     *   `5. Exit`: Terminate the program.
 * 
 * 4.  **Implementation Constraints:**
 *     *   You *must* use `java.util.Queue`. A standard `LinkedList` or `ArrayDeque` can be used as the concrete implementation.
 *     *   You *must* use `java.util.ArrayList`.
 *     *   You *must* declare the completed tasks storage variable using the `java.util.List` interface type.
 *     *   You *must* use `java.util.Scanner` for all user input.
 *     *   You *must* use a `switch` statement to handle the user's menu choice.
 *     *   You *must* use `System.err` for displaying error messages (e.g., invalid menu choice, input errors).
 *     *   You *must* use `System.out` for all normal output (menu, prompts, task details, success messages).
 *     *   Implement class-wide exception handling within the main processing loop using a `try-catch` block to gracefully handle unexpected errors during execution.
 * 
 * 5.  **Best Practices:**
 *     *   Apply proper encapsulation (private fields, public methods).
 *     *   Use meaningful variable and method names.
 *     *   Include comments and documentation (Javadoc where appropriate).
 *     *   Implement input validation where necessary (e.g., ensuring menu choice is an integer within the valid range).
 *     *   Handle cases where queues/lists are empty before attempting to process or display.
 *     *   Ensure the `Scanner` is closed upon program exit.
 * 
 * **Expected Output:**
 * 
 * The program should present a menu, accept user input, and perform the requested actions, displaying output or error messages as specified.
 * 
 * ```
 * --- Task Processing System Menu ---
 * 1. Add New Task
 * 2. Process Next Task
 * 3. View Pending Tasks
 * 4. View Completed Tasks
 * 5. Exit
 * Enter your choice: 1
 * Enter task description: Implement user authentication
 * Enter priority (High/Standard): High
 * Task 1 added to the queue.
 * 
 * --- Task Processing System Menu ---
 * ...
 * Enter your choice: 3
 * Pending Tasks:
 * [Task ID: 1, Description: Implement user authentication, Priority: High, Status: Pending]
 * 
 * --- Task Processing System Menu ---
 * ...
 * Enter your choice: 2
 * Processing task 1...
 * Task 1 completed.
 * 
 * --- Task Processing System Menu ---
 * ...
 * Enter your choice: 4
 * Completed Tasks:
 * [Task ID: 1, Description: Implement user authentication, Priority: High, Status: Completed]
 * 
 * --- Task Processing System Menu ---
 * ...
 * Enter your choice: 5
 * Exiting Task Processing System.
 * ```
 * (Error messages should go to System.err)
 * 
 * **Evaluation:** Your solution will be evaluated based on:
 * *   Correctness and completeness of the implementation according to all requirements.
 * *   Proper usage of all specified Java components (`Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.err`, `System.out`, `try-catch`).
 * *   Adherence to best practices (encapsulation, naming, documentation, validation, error handling).
 * *   Code structure and readability.
 *
 * EXPLANATION:
 * The provided solution implements a `TaskProcessingSystem` based on the requirements, demonstrating the use of all specified Java components and adhering to best practices.
 * 
 * 1.  **`Task` Class:**
 *     *   This class serves as a simple Plain Old Java Object (POJO) to represent a task.
 *     *   It has private fields (`taskId`, `description`, `priority`, `status`) ensuring encapsulation.
 *     *   A constructor initializes these fields, and a default status "Pending" is set.
 *     *   Public getter methods provide controlled access to the task's attributes.
 *     *   A public setter `setStatus` allows modifying the task's status.
 *     *   The `toString()` method provides a convenient, formatted string representation of a `Task` object, useful for printing.
 * 
 * 2.  **`TaskProcessingSystem` Class:**
 *     *   This is the main class containing the system's logic.
 *     *   It declares a `taskQueue` of type `Queue<Task>` and instantiates it with `LinkedList`. `Queue` is used because tasks are processed in the order they are added (FIFO). `LinkedList` is a common implementation of `Queue`.
 *     *   It declares `completedTasks` of type `List<Task>` and instantiates it with `ArrayList`. Using the `List` interface for the variable type demonstrates polymorphism and good practice, while `ArrayList` provides a dynamic, resizable array for storing completed tasks.
 *     *   A `Scanner` object is used for reading user input.
 *     *   `nextTaskId` is a simple integer counter to generate unique IDs for new tasks.
 *     *   The constructor initializes these data structures and the `Scanner`.
 * 
 * 3.  **Functionality Implementation:**
 *     *   `displayMenu()`: A simple helper method to print the menu options to `System.out`.
 *     *   `addNewTask()`: Prompts the user for input, validates the priority ("High" or "Standard" case-insensitive), creates a new `Task` object, and adds it to the `taskQueue` using `offer()`, which is the preferred `Queue` method for adding elements.
 *     *   `processNextTask()`: Checks if the `taskQueue` is empty. If not, it uses `poll()` to retrieve and remove the task at the head of the queue. It then updates the task's status and adds it to the `completedTasks` list. If the queue is empty, it prints a message to `System.out`.
 *     *   `viewPendingTasks()`: Prints a header to `System.out`. It checks if `taskQueue` is empty and prints a message if so. Otherwise, it iterates through the `taskQueue` using a for-each loop. This loop iterates over the elements without removing them, preserving the queue's state and order for viewing.
 *     *   `viewCompletedTasks()`: Prints a header to `System.out`. It checks if `completedTasks` is empty and prints a message if so. Otherwise, it iterates through the `completedTasks` list using a for-each loop and prints each task.
 *     *   `runSystem()`: This method contains the main application loop.
 *         *   It runs indefinitely (`while(running)` or `while(true)` with a break) until the user chooses to exit.
 *         *   **Class-wide Exception Handling:** The entire core logic inside the `while` loop is wrapped in a `try-catch(Exception e)` block. This fulfills the requirement for class-wide exception handling, catching any unhandled exception that might occur within the loop's execution and printing an error message to `System.err`. A more specific `catch (InputMismatchException e)` is also included *before* the general `Exception` catch to handle non-integer input specifically, demonstrating more granular error handling while still having the broad catch as a fallback.
 *         *   It calls `displayMenu()` and reads the user's integer choice using `scanner.nextInt()`.
 *         *   `scanner.nextLine()` is called immediately after `scanner.nextInt()` to consume the leftover newline character, preventing issues in subsequent `scanner.nextLine()` calls within the menu options.
 *         *   A `switch` statement is used to direct the program flow based on the user's `choice`. Each case calls the corresponding method (`addNewTask`, `processNextTask`, etc.).
 *         *   The `default` case of the `switch` handles invalid integer choices, printing an error message to `System.err`.
 *         *   Case `5` sets `running` to `false`, exiting the loop.
 *         *   The `Scanner` is closed *outside* the loop using `scanner.close()` to release system resources once the program finishes.
 * 
 * 4.  **Main Method:**
 *     *   The `main` method is the entry point of the application.
 *     *   It creates an instance of `TaskProcessingSystem` and calls its `runSystem()` method to start the interactive loop.
 * 
 * This solution effectively integrates all required components, simulates a practical scenario, and demonstrates key Java concepts like data structures, object-oriented design, input/output, control flow, and exception handling following best practices.
 */

import java.util.Queue;
import java.util.LinkedList; // Concrete implementation for Queue
import java.util.List;
import java.util.ArrayList; // Concrete implementation for List
import java.util.Scanner;
import java.util.InputMismatchException;

/**
 * Represents a single task in the system.
 */
class Task {
    private int taskId;
    private String description;
    private String priority; // e.g., "High", "Standard"
    private String status;   // e.g., "Pending", "Completed"

    /**
     * Constructs a new Task.
     *
     * @param taskId      The unique identifier for the task.
     * @param description A brief description of the task.
     * @param priority    The priority level of the task.
     */
    public Task(int taskId, String description, String priority) {
        this.taskId = taskId;
        this.description = description;
        this.priority = priority;
        this.status = "Pending"; // Default status
    }

    // Getters
    public int getTaskId() {
        return taskId;
    }

    public String getDescription() {
        return description;
    }

    public String getPriority() {
        return priority;
    }

    public String getStatus() {
        return status;
    }

    // Setter for status
    public void setStatus(String status) {
        this.status = status;
    }

    /**
     * Provides a string representation of the Task.
     *
     * @return A formatted string describing the task.
     */
    @Override
    public String toString() {
        return "[Task ID: " + taskId +
               ", Description: " + description +
               ", Priority: " + priority +
               ", Status: " + status + "]";
    }
}

/**
 * Manages the task processing system, handling task queues and completed tasks.
 */
public class TaskProcessingSystem {

    private Queue<Task> taskQueue;
    private List<Task> completedTasks; // Declared as List interface
    private Scanner scanner;
    private int nextTaskId; // Counter for generating unique task IDs

    /**
     * Constructs a new TaskProcessingSystem.
     * Initializes the task queue, completed tasks list, scanner, and task ID counter.
     */
    public TaskProcessingSystem() {
        this.taskQueue = new LinkedList<>(); // Using LinkedList as concrete Queue
        this.completedTasks = new ArrayList<>(); // Using ArrayList as concrete List
        this.scanner = new Scanner(System.in);
        this.nextTaskId = 1; // Start task IDs from 1
    }

    /**
     * Displays the main menu options to the user.
     */
    private void displayMenu() {
        System.out.println("\n--- Task Processing System Menu ---");
        System.out.println("1. Add New Task");
        System.out.println("2. Process Next Task");
        System.out.println("3. View Pending Tasks");
        System.out.println("4. View Completed Tasks");
        System.out.println("5. Exit");
        System.out.print("Enter your choice: ");
    }

    /**
     * Adds a new task based on user input.
     */
    private void addNewTask() {
        System.out.print("Enter task description: ");
        String description = scanner.nextLine();

        String priority;
        while (true) {
            System.out.print("Enter priority (High/Standard): ");
            priority = scanner.nextLine().trim();
            if (priority.equalsIgnoreCase("High") || priority.equalsIgnoreCase("Standard")) {
                break; // Valid priority entered
            } else {
                System.err.println("Invalid priority. Please enter 'High' or 'Standard'.");
            }
        }

        Task newTask = new Task(nextTaskId++, description, priority);
        taskQueue.offer(newTask); // Add task to the end of the queue
        System.out.println("Task " + newTask.getTaskId() + " added to the queue.");
    }

    /**
     * Processes the next task in the queue (FIFO).
     */
    private void processNextTask() {
        if (taskQueue.isEmpty()) {
            System.out.println("No pending tasks to process.");
        } else {
            Task taskToProcess = taskQueue.poll(); // Get and remove the head of the queue
            System.out.println("Processing task " + taskToProcess.getTaskId() + "...");
            taskToProcess.setStatus("Completed");
            completedTasks.add(taskToProcess); // Add to the completed list
            System.out.println("Task " + taskToProcess.getTaskId() + " completed.");
        }
    }

    /**
     * Displays all tasks currently in the pending queue.
     */
    private void viewPendingTasks() {
        System.out.println("\nPending Tasks:");
        if (taskQueue.isEmpty()) {
            System.out.println("No tasks currently pending.");
        } else {
            // Iterate through the queue without removing elements
            for (Task task : taskQueue) {
                System.out.println(task);
            }
        }
    }

    /**
     * Displays all tasks that have been completed.
     */
    private void viewCompletedTasks() {
        System.out.println("\nCompleted Tasks:");
        if (completedTasks.isEmpty()) {
            System.out.println("No tasks have been completed yet.");
        } else {
            for (Task task : completedTasks) {
                System.out.println(task);
            }
        }
    }

    /**
     * Runs the main system loop, handling user input and menu options.
     * Includes class-wide exception handling.
     */
    public void runSystem() {
        boolean running = true;
        while (running) {
            try { // Class-wide exception handling for the main loop
                displayMenu();
                int choice = scanner.nextInt();
                scanner.nextLine(); // Consume newline left-over after nextInt()

                switch (choice) {
                    case 1:
                        addNewTask();
                        break;
                    case 2:
                        processNextTask();
                        break;
                    case 3:
                        viewPendingTasks();
                        break;
                    case 4:
                        viewCompletedTasks();
                        break;
                    case 5:
                        System.out.println("Exiting Task Processing System.");
                        running = false;
                        break;
                    default:
                        System.err.println("Invalid choice. Please enter a number between 1 and 5.");
                }
            } catch (InputMismatchException e) {
                System.err.println("Invalid input. Please enter a number.");
                scanner.nextLine(); // Consume the invalid input to prevent infinite loop
            } catch (Exception e) {
                // Catch any other unexpected exceptions
                System.err.println("An unexpected error occurred: " + e.getMessage());
                // e.printStackTrace(); // Uncomment for debugging
            }
        }
        scanner.close(); // Close the scanner when exiting
    }

    /**
     * Main method to start the Task Processing System.
     *
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        TaskProcessingSystem system = new TaskProcessingSystem();
        system.runSystem();
    }
}
