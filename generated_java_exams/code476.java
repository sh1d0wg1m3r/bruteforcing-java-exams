/*
 * Exam Question #476
 * Generated on: 2025-05-11 23:16:42
 * Generated by: Account 2
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Package Delivery Hub Management
 * 
 * **Scenario:**
 * 
 * You are tasked with developing a command-line application for a small package delivery hub. The hub receives packages that are initially placed in a central holding area (a queue) waiting to be assigned to available delivery routes. There are several predefined delivery routes, and each route can hold multiple packages assigned to it. Your system needs to manage the flow of packages from the waiting area to the routes based on user commands.
 * 
 * **Requirements:**
 * 
 * Implement a Java application that simulates this package delivery hub. Your application must meet the following requirements:
 * 
 * 1.  **Data Structures:**
 *     *   Maintain a collection of packages waiting for assignment using `java.util.Queue`.
 *     *   Maintain a collection of available delivery routes using `java.util.List`.
 *     *   Each `DeliveryRoute` object must internally manage the packages assigned to it using `java.util.ArrayList` (implementing the `java.util.List` interface).
 * 
 * 2.  **User Interface:**
 *     *   Provide a simple text-based menu using `java.util.Scanner` for user input.
 *     *   The menu should offer the following options:
 *         1.  Add New Package to Waiting Queue
 *         2.  Assign Next Waiting Package to Route
 *         3.  View Waiting Packages
 *         4.  View Packages on a Specific Route
 *         5.  Exit
 * 
 * 3.  **Core Logic:**
 *     *   **Add Package:** Prompt the user for a package ID and destination address, create a `Package` object, and add it to the waiting queue.
 *     *   **Assign Package:** Take the package at the front of the waiting queue, prompt the user for a route ID, find the specified route, and add the package to that route's list of assigned packages. If the waiting queue is empty or the route ID is invalid, handle the error.
 *     *   **View Waiting:** Display the details (ID and destination) of all packages currently in the waiting queue without removing them.
 *     *   **View Route:** Prompt the user for a route ID, find the route, and display the details of all packages assigned to that route. If the route ID is invalid, handle the error.
 *     *   **Exit:** Terminate the application.
 * 
 * 4.  **Control Flow & Error Handling:**
 *     *   Use a `switch` statement to process the user's menu choice.
 *     *   Use `System.out` for displaying the menu, success messages, and requested information (package lists).
 *     *   Use `System.err` for displaying all error messages (e.g., invalid input, route not found, queue empty).
 *     *   Implement comprehensive input validation (e.g., ensuring numeric input where expected, checking if routes exist).
 *     *   Implement class-wide exception handling using `try-catch` blocks to gracefully handle potential runtime errors (e.g., `NumberFormatException` from parsing, or other unexpected issues).
 * 
 * 5.  **Best Practices:**
 *     *   Create separate classes for `Package` and `DeliveryRoute` with appropriate private fields and public methods (encapsulation).
 *     *   Use meaningful variable, method, and class names.
 *     *   Include comments where necessary to explain complex logic.
 *     *   Ensure clean code structure.
 *     *   Pre-populate the system with at least two `DeliveryRoute` objects when the application starts.
 * 
 * **Expected Output:**
 * 
 * The program should present a menu, accept user input, perform the requested operations, and display results or errors.
 * 
 * Example Interaction Flow:
 * 
 * ```
 * Package Delivery Hub Menu:
 * 1. Add New Package to Waiting Queue
 * 2. Assign Next Waiting Package to Route
 * 3. View Waiting Packages
 * 4. View Packages on a Specific Route
 * 5. Exit
 * Enter your choice: 1
 * Enter Package ID: PKG101
 * Enter Destination Address: 123 Main St
 * Package PKG101 added to waiting queue.
 * 
 * Package Delivery Hub Menu:
 * ...
 * Enter your choice: 1
 * Enter Package ID: PKG102
 * Enter Destination Address: 456 Oak Ave
 * Package PKG102 added to waiting queue.
 * 
 * Package Delivery Hub Menu:
 * ...
 * Enter your choice: 3
 * Waiting Packages:
 * - PKG101 -> 123 Main St
 * - PKG102 -> 456 Oak Ave
 * 
 * Package Delivery Hub Menu:
 * ...
 * Enter your choice: 2
 * Next package to assign: PKG101 -> 123 Main St
 * Enter Route ID to assign to: 1
 * Package PKG101 assigned to Route 1.
 * 
 * Package Delivery Hub Menu:
 * ...
 * Enter your choice: 4
 * Enter Route ID to view: 1
 * Packages on Route 1:
 * - PKG101 -> 123 Main St
 * 
 * Package Delivery Hub Menu:
 * ...
 * Enter your choice: 4
 * Enter Route ID to view: 99
 * Error: Route with ID 99 not found.
 * 
 * Package Delivery Hub Menu:
 * ...
 * Enter your choice: 2
 * Next package to assign: PKG102 -> 456 Oak Ave
 * Enter Route ID to assign to: 2
 * Package PKG102 assigned to Route 2.
 * 
 * Package Delivery Hub Menu:
 * ...
 * Enter your choice: 3
 * Waiting Packages:
 * (Queue is empty)
 * 
 * Package Delivery Hub Menu:
 * ...
 * Enter your choice: 2
 * Error: No packages waiting in the queue.
 * 
 * Package Delivery Hub Menu:
 * ...
 * Enter your choice: 5
 * Exiting Delivery Hub System.
 * ```
 * 
 * Your solution should be a single Java file containing all necessary classes.
 *
 * EXPLANATION:
 * This solution implements the `Package Delivery Hub Management` system as described in the problem statement, demonstrating the required Java concepts and best practices.
 * 
 * 1.  **Class Structure:**
 *     *   `Package`: A simple class encapsulating package data (`packageId`, `destinationAddress`). It follows encapsulation principles with private fields and public getters. The `toString()` method provides a convenient representation for printing.
 *     *   `DeliveryRoute`: Represents a delivery route with an ID and a `List` of `Package` objects assigned to it. It uses `ArrayList` as the concrete implementation for the list. It has methods for getting the ID and adding packages.
 *     *   `DeliverySystem`: The main class that orchestrates the application. It holds the `Queue` of waiting packages and the `List` of delivery routes. It contains the `main` method, the `Scanner`, and methods for each menu operation.
 * 
 * 2.  **Data Structures (`Queue`, `ArrayList`, `List`):**
 *     *   `Queue<Package> waitingPackages;`: Declared as a `Queue` interface type, initialized with `new LinkedList<>()`. `LinkedList` is a common class that implements the `Queue` interface in Java, providing efficient adding (`offer`) and removing (`poll`) operations from the ends, suitable for a waiting line.
 *     *   `List<DeliveryRoute> deliveryRoutes;`: Declared as a `List` interface type, initialized with `new ArrayList<>()`. `ArrayList` is used to store the available routes, allowing easy access and iteration.
 *     *   `List<Package> assignedPackages;` within `DeliveryRoute`: Declared as a `List` interface type, initialized with `new ArrayList<>()`. This `ArrayList` holds the packages specifically assigned to that route. Using the `List` interface here is good practice, allowing flexibility to change the underlying implementation later if needed (though `ArrayList` is suitable here).
 * 
 * 3.  **User Input (`Scanner`):**
 *     *   A `Scanner` object is used to read user input from `System.in`. It's initialized once in the `DeliverySystem` constructor and closed in the `finally` block of the `main` method to release system resources. Care is taken to consume the newline character after reading numbers (`nextInt()`) using `scanner.nextLine()` to prevent issues with subsequent `nextLine()` calls.
 * 
 * 4.  **Control Flow (`switch`):**
 *     *   The `main` method contains a `while` loop that keeps the application running until the user chooses to exit.
 *     *   Inside the loop, a `switch` statement is used to direct execution based on the integer value of the user's menu choice, calling the appropriate helper method (`addPackage`, `assignPackageToRoute`, etc.). A `default` case handles invalid numeric input.
 * 
 * 5.  **Output (`System.out`, `System.err`):**
 *     *   `System.out.println()` is used for displaying the menu, prompts, success messages, and lists of packages (both waiting and assigned).
 *     *   `System.err.println()` is used exclusively for displaying error messages, such as invalid menu choices, non-numeric input, trying to assign from an empty queue, or attempting to view/assign to a non-existent route. This visually distinguishes errors from normal output and is a standard practice.
 * 
 * 6.  **Exception Handling (`try-catch`):**
 *     *   A large `try-catch(Exception e)` block surrounds the main `while` loop in the `main` method. This provides a form of class-wide exception handling, catching any unexpected runtime exceptions that might occur during the system's operation and preventing the program from crashing abruptly. It prints an error message and the stack trace for debugging.
 *     *   More specific `try-catch(InputMismatchException e)` blocks are used when reading integer input (`scanner.nextInt()`) for menu choices and route IDs. This specifically handles cases where the user enters non-numeric text instead of a number. It prints a user-friendly error message using `System.err`, consumes the invalid input, and allows the program to continue gracefully. The `finally` block ensures `scanner.nextLine()` is called regardless of whether an exception occurred or not after `nextInt()`.
 * 
 * 7.  **Best Practices:**
 *     *   **Encapsulation:** Fields in `Package` and `DeliveryRoute` are `private`, accessed via public methods.
 *     *   **Meaningful Names:** Classes, methods, and variables have names that clearly indicate their purpose (e.g., `waitingPackages`, `assignPackageToRoute`, `findRouteById`).
 *     *   **Comments:** Comments are included to explain the purpose of classes, methods, and specific logic sections.
 *     *   **Input Validation:** Checks are performed for empty package details, empty waiting queue, non-existent routes, and non-numeric user input.
 *     *   **Clean Structure:** The logic is divided into small, focused methods within the `DeliverySystem` class, improving readability and maintainability. The `Package` and `DeliveryRoute` classes separate data concerns.
 *     *   **Pre-population:** The constructor of `DeliverySystem` pre-populates the `deliveryRoutes` list, fulfilling that requirement.
 * 
 * This solution effectively integrates all specified Java components into a functional and well-structured application that simulates a real-world scenario while demonstrating key programming concepts and error handling techniques.
 */

import java.util.ArrayList;
import java.util.LinkedList; // LinkedList implements Queue
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.InputMismatchException; // Specific exception for Scanner

// Represents a package to be delivered
class Package {
    private String packageId;
    private String destinationAddress;

    public Package(String packageId, String destinationAddress) {
        this.packageId = packageId;
        this.destinationAddress = destinationAddress;
    }

    public String getPackageId() {
        return packageId;
    }

    public String getDestinationAddress() {
        return destinationAddress;
    }

    @Override
    public String toString() {
        return packageId + " -> " + destinationAddress;
    }
}

// Represents a delivery route with assigned packages
class DeliveryRoute {
    private int routeId;
    private List<Package> assignedPackages; // Using List interface, implemented by ArrayList

    public DeliveryRoute(int routeId) {
        this.routeId = routeId;
        this.assignedPackages = new ArrayList<>(); // Concrete implementation
    }

    public int getRouteId() {
        return routeId;
    }

    public void addPackage(Package pkg) {
        if (pkg != null) {
            this.assignedPackages.add(pkg);
        }
    }

    public List<Package> getAssignedPackages() {
        // Return a copy or unmodifiable list if external modification is not desired
        // For this problem, returning the direct list is acceptable for viewing
        return assignedPackages;
    }

    @Override
    public String toString() {
        return "Route " + routeId;
    }
}

// Main class managing the delivery system
public class DeliverySystem {

    private Queue<Package> waitingPackages; // Packages waiting for assignment
    private List<DeliveryRoute> deliveryRoutes; // Available delivery routes
    private Scanner scanner; // Scanner for user input

    public DeliverySystem() {
        // Initialize data structures
        waitingPackages = new LinkedList<>(); // LinkedList is a common Queue implementation
        deliveryRoutes = new ArrayList<>(); // ArrayList for routes
        scanner = new Scanner(System.in);

        // Pre-populate some routes
        deliveryRoutes.add(new DeliveryRoute(1));
        deliveryRoutes.add(new DeliveryRoute(2));
        deliveryRoutes.add(new DeliveryRoute(3));

        System.out.println("Delivery Hub System Initialized with " + deliveryRoutes.size() + " routes.");
    }

    // Displays the main menu
    private void displayMenu() {
        System.out.println("\nPackage Delivery Hub Menu:");
        System.out.println("1. Add New Package to Waiting Queue");
        System.out.println("2. Assign Next Waiting Package to Route");
        System.out.println("3. View Waiting Packages");
        System.out.println("4. View Packages on a Specific Route");
        System.out.println("5. Exit");
        System.out.print("Enter your choice: ");
    }

    // Adds a new package based on user input
    private void addPackage() {
        System.out.print("Enter Package ID: ");
        String packageId = scanner.nextLine();
        System.out.print("Enter Destination Address: ");
        String destinationAddress = scanner.nextLine();

        if (packageId.trim().isEmpty() || destinationAddress.trim().isEmpty()) {
             System.err.println("Error: Package ID and Destination Address cannot be empty.");
             return;
        }

        Package newPackage = new Package(packageId, destinationAddress);
        waitingPackages.offer(newPackage); // offer is generally preferred over add for queues
        System.out.println("Package " + newPackage.getPackageId() + " added to waiting queue.");
    }

    // Assigns the next waiting package to a specified route
    private void assignPackageToRoute() {
        if (waitingPackages.isEmpty()) {
            System.err.println("Error: No packages waiting in the queue.");
            return;
        }

        // Peek at the next package without removing it yet
        Package packageToAssign = waitingPackages.peek();
        System.out.println("Next package to assign: " + packageToAssign);

        System.out.print("Enter Route ID to assign to: ");
        int routeId = -1;
        try {
            routeId = scanner.nextInt();
        } catch (InputMismatchException e) {
            System.err.println("Error: Invalid input. Please enter a numeric Route ID.");
            scanner.nextLine(); // Consume the invalid input
            return;
        } finally {
             scanner.nextLine(); // Consume the newline character left by nextInt()
        }


        DeliveryRoute targetRoute = findRouteById(routeId);

        if (targetRoute == null) {
            System.err.println("Error: Route with ID " + routeId + " not found.");
        } else {
            // Found the route, now poll the package from the queue
            Package assignedPackage = waitingPackages.poll(); // Remove from queue
            targetRoute.addPackage(assignedPackage); // Add to route's list
            System.out.println("Package " + assignedPackage.getPackageId() + " assigned to " + targetRoute + ".");
        }
    }

    // Finds a route by its ID
    private DeliveryRoute findRouteById(int routeId) {
        for (DeliveryRoute route : deliveryRoutes) {
            if (route.getRouteId() == routeId) {
                return route;
            }
        }
        return null; // Route not found
    }

    // Displays all packages currently in the waiting queue
    private void viewWaitingPackages() {
        System.out.println("Waiting Packages:");
        if (waitingPackages.isEmpty()) {
            System.out.println("(Queue is empty)");
        } else {
            // Iterate without removing
            for (Package pkg : waitingPackages) {
                System.out.println("- " + pkg);
            }
        }
    }

    // Displays packages assigned to a specific route
    private void viewRoutePackages() {
        System.out.print("Enter Route ID to view: ");
        int routeId = -1;
         try {
            routeId = scanner.nextInt();
        } catch (InputMismatchException e) {
            System.err.println("Error: Invalid input. Please enter a numeric Route ID.");
            scanner.nextLine(); // Consume the invalid input
            return;
        } finally {
             scanner.nextLine(); // Consume the newline character left by nextInt()
        }

        DeliveryRoute targetRoute = findRouteById(routeId);

        if (targetRoute == null) {
            System.err.println("Error: Route with ID " + routeId + " not found.");
        } else {
            System.out.println("Packages on " + targetRoute + ":");
            List<Package> packagesOnRoute = targetRoute.getAssignedPackages();
            if (packagesOnRoute.isEmpty()) {
                System.out.println("(No packages assigned to this route)");
            } else {
                for (Package pkg : packagesOnRoute) {
                    System.out.println("- " + pkg);
                }
            }
        }
    }

    // Main method to run the system
    public static void main(String[] args) {
        DeliverySystem system = new DeliverySystem();
        boolean running = true;

        // Class-wide exception handling around the main operational loop
        try {
            while (running) {
                system.displayMenu();
                int choice = -1;

                // Handle potential InputMismatchException for the menu choice
                try {
                    choice = system.scanner.nextInt();
                } catch (InputMismatchException e) {
                    System.err.println("Error: Invalid input. Please enter a number.");
                    system.scanner.nextLine(); // Consume the invalid input
                    continue; // Skip the rest of the loop and show menu again
                } finally {
                    system.scanner.nextLine(); // Consume the newline character after nextInt()
                }


                // Use switch statement for menu navigation
                switch (choice) {
                    case 1:
                        system.addPackage();
                        break;
                    case 2:
                        system.assignPackageToRoute();
                        break;
                    case 3:
                        system.viewWaitingPackages();
                        break;
                    case 4:
                        system.viewRoutePackages();
                        break;
                    case 5:
                        running = false;
                        System.out.println("Exiting Delivery Hub System.");
                        break;
                    default:
                        System.err.println("Error: Invalid choice. Please enter a number between 1 and 5.");
                }
            }
        } catch (Exception e) {
            // Catch any other unexpected runtime exceptions
            System.err.println("An unexpected error occurred: " + e.getMessage());
            e.printStackTrace(); // Print stack trace for debugging
        } finally {
            // Ensure scanner is closed when the application exits
            system.scanner.close();
            System.out.println("Scanner closed.");
        }
    }
}
