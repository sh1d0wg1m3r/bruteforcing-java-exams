/*
 * Exam Question #697
 * Generated on: 2025-05-12 16:27:22
 * Generated by: Account 4
 * 
 * QUESTION:
 * ## Java Programming Exam: Advanced Job Management System
 * 
 * **Scenario:**
 * 
 * You are tasked with building a simplified Print Job Management System. This system will manage a queue of pending print jobs and maintain a list of completed jobs. Users will interact with the system via a console menu to add new jobs, process the next job in the queue, list all jobs, or exit.
 * 
 * **Requirements:**
 * 
 * 1.  **`PrintJob` Class:** Create a class named `PrintJob` to represent a single print job.
 *     *   It must have private fields: `id` (an integer, unique), `fileName` (String), `pages` (int), and `status` (an enum `PrintJobStatus`).
 *     *   Create a constructor to initialize a new job with a given ID, file name, and number of pages. The initial status should be `PENDING`.
 *     *   Include appropriate public getter methods for all fields.
 *     *   Include a public method `markAsCompleted()` that changes the job's status to `COMPLETED`.
 *     *   Override the `toString()` method to provide a user-friendly string representation of the job.
 * 
 * 2.  **`PrintJobStatus` Enum:** Create an enum `PrintJobStatus` with values `PENDING` and `COMPLETED`.
 * 
 * 3.  **`PrintJobManager` Class:** Create a class named `PrintJobManager` to manage the print jobs.
 *     *   It must have a private field `pendingJobs` of type `Queue<PrintJob>`. Use a suitable implementation (e.g., `LinkedList`).
 *     *   It must have a private field `completedJobs` of type `List<PrintJob>`. Use a suitable implementation (e.g., `ArrayList`).
 *     *   It must have a private integer field `nextJobId`, initialized to 1, to generate unique job IDs.
 *     *   **Methods:**
 *         *   `addJob(String fileName, int pages)`: Creates a new `PrintJob` with the next available ID, adds it to the `pendingJobs` queue, and increments `nextJobId`. Perform input validation: `fileName` cannot be null or empty, and `pages` must be greater than 0. If validation fails, print an error message using `System.err` and do not add the job.
 *         *   `processNextJob()`: Takes the job from the front of the `pendingJobs` queue. If the queue is not empty, mark the job as completed using its `markAsCompleted()` method and move it to the `completedJobs` list. If the queue is empty, print a message to `System.out` indicating that there are no pending jobs.
 *         *   `listAllJobs()`: Prints a formatted list of all jobs, showing pending jobs first, then completed jobs. For each job, use its `toString()` representation. Print appropriate headers (e.g., "--- Pending Jobs ---", "--- Completed Jobs ---").
 *         *   `run()`: This method contains the main application loop.
 *             *   Use a `Scanner` to read user input from the console.
 *             *   Present a menu to the user with options: `1. Add Job`, `2. Process Next Job`, `3. List All Jobs`, `4. Exit`.
 *             *   Use a `while` loop to keep the application running until the user chooses to exit.
 *             *   Inside the loop:
 *                 *   Prompt the user for their choice.
 *                 *   Use a `switch` statement to handle the different menu options.
 *                 *   Implement class-wide exception handling using `try-catch` blocks. Specifically, handle `InputMismatchException` when reading integer input (like menu choice or number of pages). If caught, print an error message to `System.err` and clear the invalid input from the `Scanner` buffer. Also include a general `catch (Exception e)` block to catch any other unexpected errors and print their stack trace to `System.err`.
 *                 *   Call the appropriate methods (`addJob`, `processNextJob`, `listAllJobs`) based on the user's choice.
 *                 *   For "Add Job", prompt the user for the file name and number of pages.
 *                 *   For "Exit", break the loop.
 *             *   Ensure the `Scanner` is closed when the application exits.
 * 
 * 4.  **Main Class:** Create a class with a `main` method that creates an instance of `PrintJobManager` and calls its `run()` method to start the application.
 * 
 * **Constraints:**
 * 
 * *   You must use `java.util.Queue`, `java.util.ArrayList`, `java.util.List`, `java.util.Scanner`.
 * *   You must use a `switch` statement for menu handling.
 * *   You must use `System.err` for error messages and `System.out` for normal output.
 * *   You must implement class-wide exception handling using `try-catch`.
 * *   Adhere to best practices: encapsulation, meaningful names, comments, input validation, error handling.
 * 
 * **Expected Output:**
 * 
 * The system should present a menu, accept user input, perform actions, and display results or errors. Examples:
 * 
 * ```
 * Print Job Management System
 * Menu:
 * 1. Add Job
 * 2. Process Next Job
 * 3. List All Jobs
 * 4. Exit
 * Enter choice: 1
 * Enter file name: report.pdf
 * Enter number of pages: 15
 * Job added: [ID: 1, File: report.pdf, Pages: 15, Status: PENDING]
 * 
 * Enter choice: 1
 * Enter file name: presentation.pptx
 * Enter number of pages: 30
 * Job added: [ID: 2, File: presentation.pptx, Pages: 30, Status: PENDING]
 * 
 * Enter choice: 3
 * --- Pending Jobs ---
 * [ID: 1, File: report.pdf, Pages: 15, Status: PENDING]
 * [ID: 2, File: presentation.pptx, Pages: 30, Status: PENDING]
 * --- Completed Jobs ---
 * (No completed jobs)
 * 
 * Enter choice: 2
 * Processing job: [ID: 1, File: report.pdf, Pages: 15, Status: PENDING]
 * Job [ID: 1] completed.
 * 
 * Enter choice: 3
 * --- Pending Jobs ---
 * [ID: 2, File: presentation.pptx, Pages: 30, Status: PENDING]
 * --- Completed Jobs ---
 * [ID: 1, File: report.pdf, Pages: 15, Status: COMPLETED]
 * 
 * Enter choice: 2
 * Processing job: [ID: 2, File: presentation.pptx, Pages: 30, Status: PENDING]
 * Job [ID: 2] completed.
 * 
 * Enter choice: 2
 * No pending jobs to process.
 * 
 * Enter choice: 4
 * Exiting Print Job Management System.
 * ```
 * 
 * Error examples:
 * 
 * ```
 * Enter choice: 1
 * Enter file name:
 * Enter number of pages: 10
 * Error: File name cannot be empty. Job not added.
 * 
 * Enter choice: 1
 * Enter file name: document.docx
 * Enter number of pages: -5
 * Error: Number of pages must be positive. Job not added.
 * 
 * Enter choice: abc
 * Error: Invalid input. Please enter a number.
 * ```
 * 
 * Your solution must be a single, complete Java program file.
 *
 * EXPLANATION:
 * This solution implements a `PrintJobManagementSystem` that fulfills all the requirements of the exam question.
 * 
 * 1.  **`PrintJobStatus` Enum:** Defines the possible states for a print job (`PENDING`, `COMPLETED`). This improves code readability and prevents using arbitrary strings for status.
 * 
 * 2.  **`PrintJob` Class:**
 *     *   Encapsulates the data for a single job (`id`, `fileName`, `pages`, `status`) using private fields.
 *     *   Provides public getter methods for accessing the data.
 *     *   Includes a specific method `markAsCompleted()` to manage the state transition, demonstrating controlled modification of the object's state.
 *     *   Overrides `toString()` for easy printing of job details.
 * 
 * 3.  **`PrintJobManager` Class:**
 *     *   Manages the collections of jobs using private fields: `pendingJobs` (a `Queue<PrintJob>`) and `completedJobs` (a `List<PrintJob>`). `LinkedList` is used for the queue as it implements the `Queue` interface and is efficient for adding/removing from ends. `ArrayList` is used for the list as it's a common, versatile list implementation. Declaring them using the `Queue` and `List` interfaces is good practice.
 *     *   `nextJobId` is a private field used to generate unique sequential IDs for new jobs.
 *     *   **`addJob` Method:** Takes file name and pages as input. It performs validation using `if` statements, printing error messages to `System.err` if validation fails. If valid, it creates a new `PrintJob`, adds it to the `pendingJobs` queue using `offer()` (a Queue method), and increments `nextJobId`. Prints confirmation to `System.out`.
 *     *   **`processNextJob` Method:** Checks if `pendingJobs` is empty. If not, it uses `poll()` to retrieve and remove the job from the head of the queue. It then calls `markAsCompleted()` on the retrieved job and adds it to the `completedJobs` list. Prints status messages to `System.out`.
 *     *   **`listAllJobs` Method:** Iterates through both `pendingJobs` and `completedJobs` collections (using enhanced for loops) and prints the `toString()` representation of each job. It prints headers to `System.out` to distinguish between the two lists.
 *     *   **`run` Method:**
 *         *   Contains the main application loop (`while(running)`).
 *         *   Uses `Scanner` for user input.
 *         *   Presents a menu and reads the user's integer choice.
 *         *   **Exception Handling:**
 *             *   A `try-catch(InputMismatchException)` block is specifically used *around* `scanner.nextInt()` calls to catch non-integer input. It prints an error to `System.err` and uses `scanner.next()` to consume the invalid token, preventing an infinite loop. `continue` restarts the loop to show the menu again.
 *             *   A general `try-catch(Exception e)` block wraps the entire `while` loop. This serves as a class-wide handler for any other unexpected runtime errors that might occur within the main application flow. It prints a generic error message and the stack trace to `System.err` for debugging.
 *         *   A `switch` statement is used to direct program flow based on the user's valid integer choice, calling the appropriate `PrintJobManager` methods.
 *         *   The `finally` block ensures the `Scanner` is closed when the `run` method exits (either normally or due to an unhandled exception).
 * 
 * 4.  **`JobManagementApp` Class:**
 *     *   The main entry point of the program.
 *     *   Its `main` method simply creates an instance of `PrintJobManager` and calls its `run()` method to start the interactive system.
 * 
 * This solution effectively demonstrates the required Java components and best practices within a functional, albeit simplified, real-world context. It shows how to use a `Queue` for managing a processing order (FIFO), a `List` for storing processed items, handle user input robustly with `Scanner` and validation, control flow with `switch` and loops, and manage errors gracefully with `try-catch` blocks and directing output to `System.out` and `System.err`.
 * 
 * Key concepts demonstrated include:
 * *   Object-Oriented Programming (classes, objects, encapsulation)
 * *   Enum types
 * *   Collection Framework (`Queue`, `List`, `LinkedList`, `ArrayList`)
 * *   Basic I/O (`Scanner`, `System.out`, `System.err`)
 * *   Control Structures (`while`, `switch`)
 * *   Exception Handling (`try-catch`, `InputMismatchException`, general `Exception`)
 * *   Input Validation
 * *   Method Design and Usage
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.InputMismatchException;

// Enum for Print Job Status
enum PrintJobStatus {
    PENDING,
    COMPLETED
}

// Represents a single print job
class PrintJob {
    private int id;
    private String fileName;
    private int pages;
    private PrintJobStatus status;

    /**
     * Constructs a new PrintJob.
     * @param id The unique job ID.
     * @param fileName The name of the file to print.
     * @param pages The number of pages to print.
     */
    public PrintJob(int id, String fileName, int pages) {
        this.id = id;
        this.fileName = fileName;
        this.pages = pages;
        this.status = PrintJobStatus.PENDING; // New jobs are always pending
    }

    // --- Getters ---
    public int getId() {
        return id;
    }

    public String getFileName() {
        return fileName;
    }

    public int getPages() {
        return pages;
    }

    public PrintJobStatus getStatus() {
        return status;
    }

    /**
     * Marks the job's status as COMPLETED.
     */
    public void markAsCompleted() {
        this.status = PrintJobStatus.COMPLETED;
    }

    /**
     * Provides a string representation of the PrintJob.
     * @return Formatted string describing the job.
     */
    @Override
    public String toString() {
        return String.format("[ID: %d, File: %s, Pages: %d, Status: %s]",
                             id, fileName, pages, status);
    }
}

// Manages the queue of pending print jobs and list of completed jobs
class PrintJobManager {
    private Queue<PrintJob> pendingJobs;
    private List<PrintJob> completedJobs;
    private int nextJobId;

    /**
     * Constructs a new PrintJobManager.
     * Initializes the pending and completed job collections and sets the starting job ID.
     */
    public PrintJobManager() {
        // Use LinkedList as it implements Queue
        this.pendingJobs = new LinkedList<>();
        // Use ArrayList as it implements List
        this.completedJobs = new ArrayList<>();
        this.nextJobId = 1; // Start ID from 1
    }

    /**
     * Adds a new print job to the pending queue after validation.
     * @param fileName The name of the file.
     * @param pages The number of pages.
     */
    public void addJob(String fileName, int pages) {
        // Input validation
        if (fileName == null || fileName.trim().isEmpty()) {
            System.err.println("Error: File name cannot be empty. Job not added.");
            return;
        }
        if (pages <= 0) {
            System.err.println("Error: Number of pages must be positive. Job not added.");
            return;
        }

        PrintJob newJob = new PrintJob(nextJobId, fileName.trim(), pages);
        pendingJobs.offer(newJob); // offer() is preferred over add() for queues
        System.out.println("Job added: " + newJob);
        nextJobId++; // Increment for the next job
    }

    /**
     * Processes the next job in the pending queue.
     * Moves the job to the completed list if the queue is not empty.
     */
    public void processNextJob() {
        // Check if the queue is empty
        if (pendingJobs.isEmpty()) {
            System.out.println("No pending jobs to process.");
            return;
        }

        // Get and remove the head of the queue
        PrintJob jobToProcess = pendingJobs.poll();

        System.out.println("Processing job: " + jobToProcess);

        // Mark as completed and move to completed list
        jobToProcess.markAsCompleted();
        completedJobs.add(jobToProcess);

        System.out.println("Job [ID: " + jobToProcess.getId() + "] completed.");
    }

    /**
     * Lists all pending and completed jobs.
     */
    public void listAllJobs() {
        System.out.println("--- Pending Jobs ---");
        if (pendingJobs.isEmpty()) {
            System.out.println("(No pending jobs)");
        } else {
            // Iterate through the queue (order matters for pending)
            for (PrintJob job : pendingJobs) {
                System.out.println(job);
            }
        }

        System.out.println("--- Completed Jobs ---");
        if (completedJobs.isEmpty()) {
            System.out.println("(No completed jobs)");
        } else {
            // Iterate through the list
            for (PrintJob job : completedJobs) {
                System.out.println(job);
            }
        }
    }

    /**
     * Runs the main application loop, handling user interaction.
     */
    public void run() {
        Scanner scanner = new Scanner(System.in);
        boolean running = true;

        System.out.println("Print Job Management System");

        // Main application loop with class-wide exception handling
        try {
            while (running) {
                System.out.println("\nMenu:");
                System.out.println("1. Add Job");
                System.out.println("2. Process Next Job");
                System.out.println("3. List All Jobs");
                System.out.println("4. Exit");
                System.out.print("Enter choice: ");

                int choice = -1; // Default invalid choice

                try {
                    // Read integer choice
                    choice = scanner.nextInt();
                } catch (InputMismatchException e) {
                    System.err.println("Error: Invalid input. Please enter a number.");
                    scanner.next(); // Consume the invalid input to prevent infinite loop
                    continue; // Skip the rest of the loop and show menu again
                }

                // Use switch statement for menu navigation
                switch (choice) {
                    case 1:
                        // Add Job
                        scanner.nextLine(); // Consume newline left-over from nextInt()
                        System.out.print("Enter file name: ");
                        String fileName = scanner.nextLine();

                        int pages = -1; // Default invalid pages
                        System.out.print("Enter number of pages: ");
                        try {
                            pages = scanner.nextInt();
                        } catch (InputMismatchException e) {
                            System.err.println("Error: Invalid input for pages. Please enter a number.");
                            scanner.next(); // Consume invalid input
                            // No need to add job, validation will handle pages <= 0
                            continue; // Skip to next menu iteration
                        }

                        addJob(fileName, pages);
                        break;

                    case 2:
                        // Process Next Job
                        processNextJob();
                        break;

                    case 3:
                        // List All Jobs
                        listAllJobs();
                        break;

                    case 4:
                        // Exit
                        running = false;
                        System.out.println("Exiting Print Job Management System.");
                        break;

                    default:
                        // Invalid choice
                        System.out.println("Invalid choice. Please try again.");
                        break;
                }
            }
        } catch (Exception e) {
            // Catch any unexpected exceptions during the main loop
            System.err.println("An unexpected error occurred:");
            e.printStackTrace(System.err); // Print stack trace to System.err
        } finally {
            // Ensure scanner is closed
            if (scanner != null) {
                scanner.close();
                System.out.println("Scanner closed.");
            }
        }
    }
}

// Main class to start the application
public class JobManagementApp {
    public static void main(String[] args) {
        PrintJobManager manager = new PrintJobManager();
        manager.run(); // Start the main application loop
    }
}
