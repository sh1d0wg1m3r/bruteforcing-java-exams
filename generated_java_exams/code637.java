/*
 * Exam Question #637
 * Generated on: 2025-05-12 16:18:13
 * Generated by: Account 3
 * 
 * QUESTION:
 * **Airport Baggage Handling Simulation**
 * 
 * **Problem Description:**
 * 
 * You are tasked with developing a simplified command-line simulation of an airport's baggage handling system. Baggage arrives on a conveyor belt (simulated by a queue), is processed by handlers, and then moved to a storage area (simulated by a list). Your program should allow users to add bags to the incoming queue, process the next bag, and view the status of bags in both the waiting queue and the processed storage.
 * 
 * **Requirements:**
 * 
 * 1.  **Class Structure:**
 *     *   Create a class `Bag` representing a single piece of luggage. It must have private fields: `bagId` (String, unique identifier), `weight` (double), `destinationGate` (String), and `isPriority` (boolean). Provide public getter methods for all fields. Implement a meaningful `toString()` method for displaying bag details.
 *     *   Create a class `BaggageSystem` to manage the baggage flow. It must contain:
 *         *   A private `java.util.Queue<Bag>` (use `java.util.LinkedList` as the implementation) to represent the incoming baggage queue.
 *         *   A private `java.util.List<Bag>` (use `java.util.ArrayList` as the implementation) to store processed bags.
 *         *   A public method `addBag(Bag bag)` to add a bag to the incoming queue.
 *         *   A public method `processNextBag()` that removes the bag from the front of the queue, adds it to the processed list, and returns the processed bag. If the queue is empty, it should indicate this gracefully (e.g., return `null`).
 *         *   Public methods `displayWaitingBags()` and `displayProcessedBags()` that print the details of bags in their respective collections to `System.out`.
 *     *   Create a main class `AirportBaggageApp` containing the `main` method to run the simulation.
 * 
 * 2.  **Application Logic (`AirportBaggageApp.main`):**
 *     *   Use `java.util.Scanner` to read user input from the console.
 *     *   Create instances of `BaggageSystem` and `Scanner`.
 *     *   Implement a command loop that continuously displays a menu to the user and processes their choice until they choose to exit.
 *     *   Use a `switch` statement to handle the user's menu choice.
 * 
 * 3.  **Menu Options:** The program should display the following menu:
 *     ```
 *     --- Baggage Handling Menu ---
 *     1. Add New Bag
 *     2. Process Next Bag
 *     3. View Waiting Bags
 *     4. View Processed Bags
 *     5. Exit
 *     Enter your choice: 
 *     ```
 * 
 * 4.  **Input Handling and Validation:**
 *     *   When adding a bag (Option 1), prompt the user sequentially for `bagId`, `weight`, `destinationGate`, and `isPriority`.
 *     *   Validate user input rigorously:
 *         *   Menu choice must be an integer between 1 and 5. Handle non-integer input.
 *         *   `bagId` should not be empty or whitespace-only.
 *         *   `weight` must be a positive double. Handle `NumberFormatException` and negative/zero values.
 *         *   `isPriority` must be entered as "true" or "false" (case-insensitive). Handle invalid input.
 *     *   Use `try-catch` blocks to handle potential exceptions during input parsing (e.g., `NumberFormatException`, issues with reading boolean/double). Specifically, wrap the input process for adding a bag within a `try-catch` block to manage potential parsing errors. Also consider handling potential issues when processing (e.g., queue empty).
 *     *   Use `System.err.println()` to report all input validation errors and operational errors (like attempting to process from an empty queue).
 * 
 * 5.  **Output:**
 *     *   Use `System.out.println()` for the menu, prompts, successful operation confirmations (e.g., "Bag XXX added."), and listing bag details.
 *     *   Use `System.err.println()` for all error messages (invalid input, queue empty, etc.).
 * 
 * 6.  **Java Components:** Your solution MUST utilize ALL of the following:
 *     *   `java.util.Queue` interface
 *     *   `java.util.ArrayList` class
 *     *   `java.util.List` interface (used as a type)
 *     *   `java.util.Scanner`
 *     *   `switch` statement
 *     *   `System.err`
 *     *   `System.out`
 *     *   `try-catch` blocks for exception handling (specifically for input parsing and operational errors).
 * 
 * 7.  **Best Practices:**
 *     *   Implement proper encapsulation (private fields, public methods/getters).
 *     *   Use meaningful variable, method, and class names.
 *     *   Include appropriate comments to explain complex logic or class/method purpose.
 *     *   Ensure clean code structure.
 * 
 * **Expected Output Behavior:**
 * 
 * *   The menu is displayed repeatedly until 'Exit' is chosen.
 * *   Adding a bag prompts for details, validates them, and confirms success or reports an error via `System.err`.
 * *   Processing a bag removes the oldest bag from the waiting queue, adds it to processed, and confirms. If the queue is empty, an error is printed to `System.err`.
 * *   Viewing lists prints the current contents of the waiting queue and processed list to `System.out`. Empty lists should be indicated.
 * *   Invalid menu choices or bag detail inputs result in an error message on `System.err`, and the menu is redisplayed.
 * 
 * **Evaluation Criteria:**
 * 
 * Your solution will be evaluated on:
 * *   Correctness and completeness of implementation according to requirements.
 * *   Proper usage of all required Java components.
 * *   Effective use of `switch` for menu navigation.
 * *   Robust input validation and error handling using `try-catch` and `System.err`.
 * *   Adherence to object-oriented principles (encapsulation).
 * *   Code readability, naming conventions, and commenting.
 *
 * EXPLANATION:
 * The solution implements a basic Airport Baggage Handling Simulation as requested, demonstrating the use of all specified Java components and adhering to best practices.
 * 
 * **Key Components and Concepts Demonstrated:**
 * 
 * 1.  **`Bag` Class:**
 *     *   Represents the core data entity with private fields (`bagId`, `weight`, `destinationGate`, `isPriority`), enforcing **encapsulation**.
 *     *   Public getter methods provide controlled access to the data.
 *     *   The `toString()` method provides a convenient way to display bag information.
 * 
 * 2.  **`BaggageSystem` Class:**
 *     *   Manages the collections (`waitingQueue` and `processedList`) and the core logic.
 *     *   Uses `java.util.Queue<Bag>` implemented by `java.util.LinkedList` for the waiting line, correctly simulating FIFO (First-In, First-Out) behavior. `offer()` adds to the tail, and `poll()` removes from the head.
 *     *   Uses `java.util.List<Bag>` implemented by `java.util.ArrayList` for storing processed bags. `ArrayList` is suitable here as processed bags are typically accessed by index or iterated through.
 *     *   `addBag()`: Adds a bag to the `waitingQueue`.
 *     *   `processNextBag()`: Demonstrates removing an element from the `Queue` using `poll()`. It handles the case where the queue is empty by checking the return value (`null`) and printing an error to `System.err`. If successful, it adds the bag to the `processedList`.
 *     *   `displayWaitingBags()` and `displayProcessedBags()`: Iterate through the respective collections and print bag details to `System.out`, showing the current state of the system.
 * 
 * 3.  **`AirportBaggageApp` Class (`main` method):**
 *     *   Contains the main application loop and user interaction logic.
 *     *   **`Scanner`:** Used to read input from `System.in`. The `scanner.nextLine()` calls after `nextInt()` or `nextDouble()` are crucial to consume the leftover newline character and prevent input issues in subsequent `nextLine()` calls.
 *     *   **Command Loop:** A `while(running)` loop keeps the application active until the user chooses to exit.
 *     *   **`try-catch` (Input Validation):**
 *         *   A `try-catch(InputMismatchException)` block specifically handles non-integer input for the menu choice, printing an error to `System.err` and consuming the invalid input.
 *         *   A larger `try-catch` block wraps the entire "Add New Bag" process (Option 1). This block catches `InputMismatchException` for numerical/boolean parsing (weight, priority) and a general `Exception` for any other potential issues during bag creation or addition. Error messages are printed to `System.err`.
 *         *   Additional checks are performed for empty strings (`bagId`, `destinationGate`) and non-positive weight, with errors reported to `System.err`.
 *     *   **`switch` Statement:** Efficiently directs the program flow based on the user's integer menu choice. Each case corresponds to a specific operation (add, process, view, exit).
 *     *   **`System.out`:** Used for displaying the menu, user prompts, confirmation messages, and the contents of the baggage lists.
 *     *   **`System.err`:** Used exclusively for printing error messages, such as invalid input, attempting to process from an empty queue, or unexpected exceptions caught by the `try-catch` blocks. This distinguishes error output from normal program output.
 *     *   **Resource Management:** The `scanner.close()` call ensures the `Scanner` resource is released when the application exits.
 * 
 * **Best Practices:**
 * 
 * *   **Encapsulation:** Achieved by making `Bag` fields private and providing public getters.
 * *   **Meaningful Names:** Classes (`Bag`, `BaggageSystem`, `AirportBaggageApp`), variables (`bagId`, `weight`, `waitingQueue`, `processedList`, `choice`, `running`), and methods (`addBag`, `processNextBag`, `displayWaitingBags`) have names that clearly indicate their purpose.
 * *   **Comments:** Added to explain the purpose of classes, methods, and key logic sections (like the `try-catch` blocks and input consumption).
 * *   **Input Validation:** Implemented checks for range (menu choice), format (`weight`, `isPriority`), and presence (`bagId`, `destinationGate`).
 * *   **Error Handling:** `try-catch` blocks are used specifically where exceptions are anticipated (input parsing), and `System.err` is used for error reporting. The `processNextBag` method also handles the empty queue case gracefully.
 * *   **Clean Structure:** The code is organized into logical classes, separating data representation (`Bag`), system logic (`BaggageSystem`), and user interface/application flow (`AirportBaggageApp`).
 * 
 * This solution effectively combines the required Java features within a practical scenario, demonstrating robust handling of user input, state management with collections, and error reporting.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.InputMismatchException;

// Represents a single piece of baggage
class Bag {
    private String bagId;
    private double weight;
    private String destinationGate;
    private boolean isPriority;

    // Constructor
    public Bag(String bagId, double weight, String destinationGate, boolean isPriority) {
        this.bagId = bagId;
        this.weight = weight;
        this.destinationGate = destinationGate;
        this.isPriority = isPriority;
    }

    // Public getters
    public String getBagId() {
        return bagId;
    }

    public double getWeight() {
        return weight;
    }

    public String getDestinationGate() {
        return destinationGate;
    }

    public boolean isPriority() {
        return isPriority;
    }

    // String representation for easy printing
    @Override
    public String toString() {
        return "Bag [ID=" + bagId + ", Weight=" + weight + "kg, Gate=" + destinationGate + ", Priority=" + isPriority + "]";
    }
}

// Manages the flow of baggage through the system
class BaggageSystem {
    // Queue for incoming bags (simulating conveyor belt)
    private Queue<Bag> waitingQueue;
    // List for processed bags (simulating storage area)
    private List<Bag> processedList;

    // Constructor
    public BaggageSystem() {
        this.waitingQueue = new LinkedList<>(); // LinkedList implements Queue
        this.processedList = new ArrayList<>(); // ArrayList implements List
    }

    /**
     * Adds a new bag to the waiting queue.
     * @param bag The Bag object to add.
     */
    public void addBag(Bag bag) {
        if (bag != null) {
            waitingQueue.offer(bag); // offer is preferred over add in queues as it doesn't throw exception on capacity limits (though LinkedList doesn't have capacity limits)
            System.out.println("Bag " + bag.getBagId() + " added to waiting queue.");
        }
    }

    /**
     * Processes the next bag from the waiting queue.
     * Moves the bag to the processed list.
     * @return The processed Bag object, or null if the waiting queue is empty.
     */
    public Bag processNextBag() {
        Bag processedBag = waitingQueue.poll(); // poll retrieves and removes the head of the queue, returns null if empty
        if (processedBag != null) {
            processedList.add(processedBag);
            System.out.println("Processed bag: " + processedBag.getBagId());
        } else {
            System.err.println("Error: Waiting queue is empty. No bags to process.");
        }
        return processedBag;
    }

    /**
     * Displays all bags currently in the waiting queue.
     */
    public void displayWaitingBags() {
        System.out.println("\n--- Waiting Bags ---");
        if (waitingQueue.isEmpty()) {
            System.out.println("No bags currently waiting.");
        } else {
            // Iterate through the queue without removing elements
            waitingQueue.forEach(System.out::println);
        }
        System.out.println("--------------------");
    }

    /**
     * Displays all bags that have been processed.
     */
    public void displayProcessedBags() {
        System.out.println("\n--- Processed Bags ---");
        if (processedList.isEmpty()) {
            System.out.println("No bags have been processed yet.");
        } else {
            // Iterate through the list
            processedList.forEach(System.out::println);
        }
        System.out.println("----------------------");
    }
}

// Main application class
public class AirportBaggageApp {

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        BaggageSystem baggageSystem = new BaggageSystem();
        boolean running = true;

        while (running) {
            printMenu();

            int choice = -1;
            // Try-catch for reading the menu choice
            try {
                System.out.print("Enter your choice: ");
                choice = scanner.nextInt();
                // Consume the newline character left by nextInt()
                scanner.nextLine(); 
            } catch (InputMismatchException e) {
                System.err.println("Error: Invalid input. Please enter a number between 1 and 5.");
                scanner.nextLine(); // Consume the invalid input to prevent infinite loop
                continue; // Skip to the next iteration
            }

            // Switch statement to handle menu options
            switch (choice) {
                case 1: // Add New Bag
                    // Try-catch block for adding a bag, handling input errors
                    try {
                        System.out.println("\n--- Add New Bag ---");
                        System.out.print("Enter Bag ID: ");
                        String bagId = scanner.nextLine().trim();
                        if (bagId.isEmpty()) {
                            System.err.println("Error: Bag ID cannot be empty.");
                            break; // Exit this case
                        }

                        System.out.print("Enter Weight (kg): ");
                        double weight = scanner.nextDouble();
                        // Consume the newline
                        scanner.nextLine(); 
                        if (weight <= 0) {
                            System.err.println("Error: Weight must be a positive number.");
                            break; // Exit this case
                        }

                        System.out.print("Enter Destination Gate: ");
                        String destinationGate = scanner.nextLine().trim();
                         if (destinationGate.isEmpty()) {
                            System.err.println("Error: Destination Gate cannot be empty.");
                            break; // Exit this case
                        }


                        System.out.print("Is Priority (true/false): ");
                        String priorityInput = scanner.nextLine().trim();
                        boolean isPriority;
                        if (priorityInput.equalsIgnoreCase("true")) {
                            isPriority = true;
                        } else if (priorityInput.equalsIgnoreCase("false")) {
                            isPriority = false;
                        } else {
                            System.err.println("Error: Invalid input for Priority. Please enter 'true' or 'false'.");
                            break; // Exit this case
                        }

                        // If all inputs are valid, create and add the bag
                        Bag newBag = new Bag(bagId, weight, destinationGate, isPriority);
                        baggageSystem.addBag(newBag);

                    } catch (InputMismatchException e) {
                        System.err.println("Error: Invalid input format. Please check weight (number) and priority (true/false).");
                         // Consume the invalid input line to prevent issues in the next loop iteration
                        if (scanner.hasNextLine()) {
                           scanner.nextLine(); 
                        }
                    } catch (Exception e) {
                         // Catch any other unexpected errors during bag creation/addition
                        System.err.println("An unexpected error occurred while adding bag: " + e.getMessage());
                         e.printStackTrace(System.err); // Print stack trace to err
                    }
                    break;

                case 2: // Process Next Bag
                    System.out.println("\n--- Processing Bag ---");
                    baggageSystem.processNextBag(); // Method itself prints success or error
                    break;

                case 3: // View Waiting Bags
                    baggageSystem.displayWaitingBags();
                    break;

                case 4: // View Processed Bags
                    baggageSystem.displayProcessedBags();
                    break;

                case 5: // Exit
                    System.out.println("Exiting Baggage Handling Simulation. Goodbye!");
                    running = false;
                    break;

                default:
                    System.err.println("Error: Invalid choice. Please enter a number between 1 and 5.");
                    break;
            }
            System.out.println(); // Add a newline for better readability between operations
        }

        scanner.close(); // Close the scanner resource
    }

    /**
     * Prints the main menu options to the console.
     */
    private static void printMenu() {
        System.out.println("--- Baggage Handling Menu ---");
        System.out.println("1. Add New Bag");
        System.out.println("2. Process Next Bag");
        System.out.println("3. View Waiting Bags");
        System.out.println("4. View Processed Bags");
        System.out.println("5. Exit");
    }
}
