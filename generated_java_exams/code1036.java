/*
 * Exam Question #1036
 * Generated on: 2025-05-12 17:15:52
 * Generated by: Account 4
 * 
 * QUESTION:
 * ## Java Programming Exam: Advanced Resource Management System
 * 
 * **Problem Description:**
 * 
 * You are tasked with building a simplified **Resource Management System**. This system manages tasks that require a limited processing resource. Tasks are submitted, wait in a queue, are moved to a processing state when a resource becomes available, and are finally marked as completed. The system needs to handle user interaction for adding tasks, initiating processing, completing tasks, and viewing the current status.
 * 
 * **Requirements:**
 * 
 * 1.  **Task Representation:** Create a class `Task` to represent a single unit of work. It should have:
 *     *   A unique integer ID (assigned by the system).
 *     *   A String description.
 *     *   A status (e.g., using an enum or constants: `WAITING`, `PROCESSING`, `COMPLETED`).
 *     *   Appropriate getters and a method to update the status. Ensure fields are private.
 * 2.  **Resource Manager:** Create a class `ResourceManager` that manages the tasks. It should maintain:
 *     *   A queue of tasks waiting for processing.
 *     *   A list of tasks currently being processed.
 *     *   A list of tasks that have been completed.
 *     *   A maximum capacity for concurrently processing tasks.
 *     *   A counter for assigning unique task IDs.
 *     *   All data structures and counters must be private.
 *     *   Provide public methods for:
 *         *   `addTask(String description)`: Creates a new task with status `WAITING` and adds it to the waiting queue.
 *         *   `processNextTask()`: Attempts to move the next task from the waiting queue to the processing list *only if* the current number of processing tasks is less than the maximum capacity. If successful, update the task's status to `PROCESSING`. If the queue is empty or capacity is full, print an informative message to `System.err`.
 *         *   `completeTask(int taskId)`: Finds a task with the given ID in the processing list, removes it, adds it to the completed list, and updates its status to `COMPLETED`. If the task is not found in the processing list, print an error message to `System.err`.
 *         *   `viewStatus()`: Prints the current state of the system, showing the number of waiting tasks, the details of tasks being processed, and the number of completed tasks.
 * 3.  **User Interface:** Create a `Main` class with a `main` method to interact with the `ResourceManager`.
 *     *   Use `Scanner` to get user input for menu choices and task details.
 *     *   Implement a menu loop with options:
 *         1.  Add New Task
 *         2.  Process Next Task
 *         3.  Complete Task
 *         4.  View Status
 *         5.  Exit
 *     *   Use a `switch` statement to handle the user's menu choice.
 *     *   Handle invalid menu input (non-integer or out of range) by printing an error message to `System.err` and prompting again.
 * 4.  **Exception Handling:**
 *     *   Implement class-wide exception handling in the `main` method using a `try-catch` block to catch general exceptions that might occur during the main loop or operations, printing an error message to `System.err`.
 *     *   Specifically handle potential `InputMismatchException` when reading integer input from the `Scanner`.
 * 5.  **Required Java Components:** Your solution **must** use ALL of the following:
 *     *   `java.util.Queue`
 *     *   `java.util.ArrayList`
 *     *   `java.util.List` interface
 *     *   `java.util.Scanner`
 *     *   `switch` statement
 *     *   `System.err`
 *     *   `System.out`
 *     *   `try-catch` blocks (including class-wide handling in `main`).
 * 6.  **Best Practices:**
 *     *   Use meaningful variable and method names.
 *     *   Include comments to explain complex logic.
 *     *   Use proper encapsulation (private fields, public methods).
 *     *   Perform input validation where necessary.
 * 
 * **Example Interaction (Illustrative):**
 * 
 * ```
 * Resource Management System
 * Max Concurrent Tasks: 2
 * 
 * Menu:
 * 1. Add New Task
 * 2. Process Next Task
 * 3. Complete Task
 * 4. View Status
 * 5. Exit
 * Enter choice: 1
 * Enter task description: Process User Data
 * 
 * Menu:
 * ...
 * Enter choice: 1
 * Enter task description: Generate Report
 * 
 * Menu:
 * ...
 * Enter choice: 2
 * Attempting to process next task...
 * Task 1 [Process User Data] moved to PROCESSING.
 * 
 * Menu:
 * ...
 * Enter choice: 2
 * Attempting to process next task...
 * Task 2 [Generate Report] moved to PROCESSING.
 * 
 * Menu:
 * ...
 * Enter choice: 2
 * Attempting to process next task...
 * System Error: Cannot process more tasks. Resource capacity reached (2/2).
 * 
 * Menu:
 * ...
 * Enter choice: 4
 * --- System Status ---
 * Waiting Tasks: 0
 * Processing Tasks (2):
 *   Task 1 [Process User Data] - PROCESSING
 *   Task 2 [Generate Report] - PROCESSING
 * Completed Tasks: 0
 * --------------------
 * 
 * Menu:
 * ...
 * Enter choice: 3
 * Enter Task ID to complete: 1
 * Completing task 1...
 * Task 1 [Process User Data] moved to COMPLETED.
 * 
 * Menu:
 * ...
 * Enter choice: 4
 * --- System Status ---
 * Waiting Tasks: 0
 * Processing Tasks (1):
 *   Task 2 [Generate Report] - PROCESSING
 * Completed Tasks (1):
 *   Task 1 [Process User Data] - COMPLETED
 * --------------------
 * 
 * Menu:
 * ...
 * Enter choice: 2
 * Attempting to process next task...
 * Waiting queue is empty. No tasks to process.
 * 
 * Menu:
 * ...
 * Enter choice: 5
 * Exiting system.
 * ```
 * 
 * **Expected Output:**
 * 
 * The program should display a menu, accept user input, perform the requested actions using the `ResourceManager`, and print status or error messages as demonstrated in the example interaction. Status updates and menu prompts should go to `System.out`, while errors (like invalid input, queue empty, capacity full, task not found) should go to `System.err`.
 *
 * EXPLANATION:
 * This solution implements a `Resource Management System` that effectively utilizes the required Java components and demonstrates several advanced concepts.
 * 
 * 1.  **`Task` Class:**
 *     *   Represents the basic unit of work with `taskId`, `description`, and `status`.
 *     *   Uses an `enum` `TaskStatus` for clear and type-safe status representation (`WAITING`, `PROCESSING`, `COMPLETED`).
 *     *   Encapsulation is maintained by making fields `private` and providing public getters and a `setStatus` method.
 *     *   The constructor includes basic input validation for the description.
 *     *   The `toString()` method provides a convenient way to print task details.
 * 
 * 2.  **`ResourceManager` Class:**
 *     *   Acts as the central controller for task management.
 *     *   **`Queue<Task> waitingTasks`**: Implemented using `java.util.LinkedList` (which implements `Queue`). This correctly models the waiting line where tasks are processed in FIFO (First-In, First-Out) order using `offer()` to add and `poll()` to remove.
 *     *   **`List<Task> processingTasks`**: Declared using the `java.util.List` interface and instantiated with `java.util.ArrayList`. This list holds tasks currently being processed. `ArrayList` is suitable here as we need to iterate, add, and remove specific elements by value or index (though we remove by object reference after finding it).
 *     *   **`List<Task> completedTasks`**: Also declared as `List<Task>` and instantiated with `ArrayList`, storing tasks that have finished processing.
 *     *   **`maxProcessingCapacity`**: Limits the number of tasks that can be in the `processingTasks` list simultaneously.
 *     *   **`nextTaskId`**: Ensures each task gets a unique ID.
 *     *   **Methods (`addTask`, `processNextTask`, `completeTask`, `viewStatus`)**: These methods encapsulate the core logic for managing tasks, interacting with the data structures while respecting the processing capacity constraint.
 *     *   **Error Handling (`System.err`)**: Methods like `processNextTask` and `completeTask` print error messages to `System.err` when operations cannot be completed (e.g., queue empty, capacity full, task not found).
 *     *   **Encapsulation**: All data members (`waitingTasks`, `processingTasks`, `completedTasks`, etc.) are `private`.
 * 
 * 3.  **`Main` Class:**
 *     *   Contains the `main` method, the entry point of the application.
 *     *   **`Scanner`**: Used to read user input from the console for menu choices and task details.
 *     *   **Menu Loop**: An infinite `while(true)` loop keeps the application running until the user chooses to exit.
 *     *   **`switch` Statement**: Handles the user's menu selection, directing execution to the appropriate `ResourceManager` method or exit logic. This effectively controls the program flow based on user input.
 *     *   **Input Validation & Error Handling**:
 *         *   A `try-catch(InputMismatchException)` block specifically handles cases where the user enters non-integer input when a number is expected (for menu choice or task ID), printing an error to `System.err` and clearing the invalid input from the scanner buffer to prevent an infinite loop.
 *         *   **Class-wide `try-catch(Exception)`**: The main `while` loop is wrapped in a `try-catch` block. This demonstrates catching any unexpected `Exception` that might propagate up from the called methods, providing a fallback error message on `System.err` and preventing the program from crashing abruptly. This is a form of class-wide handling for the main execution flow.
 *     *   **Resource Management (`Scanner` closing)**: The `finally` block ensures the `Scanner` resource is closed properly when the program exits (either normally via the 'Exit' option or due to an uncaught exception).
 *     *   `System.out` is used for standard program output (menu, successful actions, status).
 *     *   `System.err` is used specifically for error messages (invalid input, operational failures like queue empty, task not found).
 * 
 * **How it meets the requirements:**
 * 
 * *   `Queue` (`waitingTasks`) is used for FIFO task waiting.
 * *   `ArrayList` (`processingTasks`, `completedTasks`) is used for dynamic lists.
 * *   `List` interface is used for declaring `processingTasks` and `completedTasks`.
 * *   `Scanner` is used for user input.
 * *   `switch` statement controls the main menu flow.
 * *   `System.err` is used for error output.
 * *   `System.out` is used for normal output.
 * *   `try-catch` blocks are used for input validation (`InputMismatchException`) and general class-wide exception handling in `main`.
 * *   Best practices like encapsulation, meaningful names, comments, and input validation are applied.
 * *   The problem simulates a practical resource allocation scenario.
 * 
 * This solution provides a robust structure for managing tasks with limited resources, demonstrating the practical application of fundamental and intermediate Java concepts required by the problem statement.
 */

import java.util.LinkedList;
import java.util.Queue;
import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;
import java.util.InputMismatchException;

// Represents a single task in the system
class Task {
    private int taskId;
    private String description;
    private TaskStatus status;

    // Enum for task status
    public enum TaskStatus {
        WAITING,
        PROCESSING,
        COMPLETED
    }

    /**
     * Constructs a new Task.
     * @param taskId The unique ID for the task.
     * @param description The description of the task.
     */
    public Task(int taskId, String description) {
        if (description == null || description.trim().isEmpty()) {
            throw new IllegalArgumentException("Task description cannot be empty.");
        }
        this.taskId = taskId;
        this.description = description.trim();
        this.status = TaskStatus.WAITING; // New tasks start as WAITING
    }

    // Getters
    public int getTaskId() {
        return taskId;
    }

    public String getDescription() {
        return description;
    }

    public TaskStatus getStatus() {
        return status;
    }

    /**
     * Updates the status of the task.
     * @param newStatus The new status to set.
     */
    public void setStatus(TaskStatus newStatus) {
        // Optional: Add validation for status transitions if needed (e.g., cannot go from COMPLETED to WAITING)
        this.status = newStatus;
    }

    @Override
    public String toString() {
        return "Task " + taskId + " [" + description + "] - " + status;
    }
}

// Manages the lifecycle and state of tasks
class ResourceManager {
    // Using LinkedList as a Queue implementation
    private Queue<Task> waitingTasks;
    // Using ArrayList to store processing and completed tasks
    private List<Task> processingTasks;
    private List<Task> completedTasks;

    private int maxProcessingCapacity;
    private int nextTaskId;

    /**
     * Constructs a ResourceManager with a specified maximum processing capacity.
     * @param maxProcessingCapacity The maximum number of tasks that can be processed concurrently.
     */
    public ResourceManager(int maxProcessingCapacity) {
        if (maxProcessingCapacity <= 0) {
             System.err.println("Warning: Max processing capacity should be positive. Setting to 1.");
             this.maxProcessingCapacity = 1;
        } else {
             this.maxProcessingCapacity = maxProcessingCapacity;
        }

        this.waitingTasks = new LinkedList<>(); // LinkedList implements Queue
        this.processingTasks = new ArrayList<>(); // ArrayList implements List
        this.completedTasks = new ArrayList<>(); // ArrayList implements List
        this.nextTaskId = 1; // Start task IDs from 1
    }

    /**
     * Adds a new task to the waiting queue.
     * @param description The description for the new task.
     */
    public void addTask(String description) {
        try {
            Task newTask = new Task(nextTaskId++, description);
            waitingTasks.offer(newTask); // Add to the end of the queue
            System.out.println("Added task: " + newTask.getDescription() + " with ID " + newTask.getTaskId());
        } catch (IllegalArgumentException e) {
            System.err.println("Error adding task: " + e.getMessage());
        }
    }

    /**
     * Attempts to move the next task from the waiting queue to processing.
     * Only succeeds if capacity is available and the queue is not empty.
     */
    public void processNextTask() {
        System.out.println("Attempting to process next task...");
        if (processingTasks.size() >= maxProcessingCapacity) {
            System.err.println("System Error: Cannot process more tasks. Resource capacity reached ("
                               + processingTasks.size() + "/" + maxProcessingCapacity + ").");
            return;
        }

        Task taskToProcess = waitingTasks.poll(); // Retrieve and remove the head of the queue
        if (taskToProcess == null) {
            System.err.println("System Error: Waiting queue is empty. No tasks to process.");
            return;
        }

        taskToProcess.setStatus(Task.TaskStatus.PROCESSING);
        processingTasks.add(taskToProcess); // Add to the processing list
        System.out.println("Task " + taskToProcess.getTaskId() + " [" + taskToProcess.getDescription() + "] moved to PROCESSING.");
    }

    /**
     * Finds and completes a task currently in the processing list.
     * @param taskId The ID of the task to complete.
     */
    public void completeTask(int taskId) {
        System.out.println("Completing task " + taskId + "...");
        Task taskToComplete = null;
        // Find the task in the processing list
        for (Task task : processingTasks) {
            if (task.getTaskId() == taskId) {
                taskToComplete = task;
                break;
            }
        }

        if (taskToComplete == null) {
            System.err.println("System Error: Task with ID " + taskId + " not found in the processing list.");
            return;
        }

        // Remove from processing and add to completed
        processingTasks.remove(taskToComplete);
        taskToComplete.setStatus(Task.TaskStatus.COMPLETED);
        completedTasks.add(taskToComplete);
        System.out.println("Task " + taskId + " [" + taskToComplete.getDescription() + "] moved to COMPLETED.");
    }

    /**
     * Prints the current status of the task queues and lists.
     */
    public void viewStatus() {
        System.out.println("\n--- System Status ---");
        System.out.println("Waiting Tasks: " + waitingTasks.size());

        System.out.println("Processing Tasks (" + processingTasks.size() + "):");
        if (processingTasks.isEmpty()) {
            System.out.println("  None");
        } else {
            for (Task task : processingTasks) {
                System.out.println("  " + task);
            }
        }

        System.out.println("Completed Tasks (" + completedTasks.size() + "):");
        if (completedTasks.isEmpty()) {
            System.out.println("  None");
        } else {
             // Could iterate and print here too, but just printing count for brevity as per example
            for (Task task : completedTasks) {
                 System.out.println("  " + task);
             }
        }
        System.out.println("--------------------");
    }

    // Helper method (optional, but good for clarity)
    public int getMaxProcessingCapacity() {
        return maxProcessingCapacity;
    }
}

// Main class for user interaction and system startup
public class Main {

    public static void main(String[] args) {
        // Define resource capacity
        final int MAX_CAPACITY = 2;
        ResourceManager resourceManager = new ResourceManager(MAX_CAPACITY);
        Scanner scanner = new Scanner(System.in);

        System.out.println("Resource Management System");
        System.out.println("Max Concurrent Tasks: " + resourceManager.getMaxProcessingCapacity());

        // Class-wide exception handling for the main loop
        try {
            while (true) {
                printMenu();
                int choice = -1;
                try {
                    System.out.print("Enter choice: ");
                    choice = scanner.nextInt();
                    scanner.nextLine(); // Consume newline left-over

                } catch (InputMismatchException e) {
                    System.err.println("System Error: Invalid input. Please enter a number.");
                    scanner.nextLine(); // Consume the invalid input to prevent infinite loop
                    continue; // Skip to the next iteration
                }

                // Use switch statement for menu navigation
                switch (choice) {
                    case 1: // Add New Task
                        System.out.print("Enter task description: ");
                        String description = scanner.nextLine();
                        resourceManager.addTask(description);
                        break;
                    case 2: // Process Next Task
                        resourceManager.processNextTask();
                        break;
                    case 3: // Complete Task
                        System.out.print("Enter Task ID to complete: ");
                        int taskIdToComplete = -1;
                        try {
                             taskIdToComplete = scanner.nextInt();
                             scanner.nextLine(); // Consume newline
                             resourceManager.completeTask(taskIdToComplete);
                        } catch (InputMismatchException e) {
                            System.err.println("System Error: Invalid input for Task ID. Please enter a number.");
                            scanner.nextLine(); // Consume invalid input
                        }
                        break;
                    case 4: // View Status
                        resourceManager.viewStatus();
                        break;
                    case 5: // Exit
                        System.out.println("Exiting system.");
                        return; // Exit the main method
                    default:
                        System.err.println("System Error: Invalid choice. Please enter a number between 1 and 5.");
                }
            }
        } catch (Exception e) {
            // Catch any unexpected exceptions during the main loop execution
            System.err.println("\nAn unexpected system error occurred: " + e.getMessage());
            e.printStackTrace(); // Print stack trace for debugging
        } finally {
            // Ensure scanner is closed when the program exits
            scanner.close();
            System.out.println("Scanner closed.");
        }
    }

    /**
     * Prints the main menu options to the console.
     */
    private static void printMenu() {
        System.out.println("\nMenu:");
        System.out.println("1. Add New Task");
        System.out.println("2. Process Next Task");
        System.out.println("3. Complete Task");
        System.out.println("4. View Status");
        System.out.println("5. Exit");
    }
}
