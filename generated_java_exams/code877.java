/*
 * Exam Question #877
 * Generated on: 2025-05-12 16:53:59
 * Generated by: Account 5
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Advanced Library Management System
 * 
 * **Objective:** Design and implement a simplified library management system demonstrating advanced Java concepts, including collection usage, exception handling, and object-oriented principles.
 * 
 * **Scenario:** You are tasked with building a console-based application for a small library. The system needs to manage books and borrowers, handle borrowing and returning, and maintain a waiting list for popular books.
 * 
 * **Requirements:**
 * 
 * 1.  **Classes:**
 *     *   `Book`: Represents a book with attributes: `isbn` (String, unique identifier), `title` (String), `author` (String), and `totalCopies` (int). It should also track the number of `availableCopies` (int). Implement proper encapsulation.
 *     *   `Borrower`: Represents a library member with attributes: `borrowerId` (String, unique identifier) and `name` (String). Implement proper encapsulation.
 *     *   `Library`: Manages the collection of books and borrowers and handles library operations. It should contain:
 *         *   A collection to store all `Book` objects (use `List` interface, implemented by `ArrayList`).
 *         *   A collection to store all `Borrower` objects (use `List` interface, implemented by `ArrayList`).
 *         *   A mechanism to track which books are currently borrowed by which borrowers.
 *         *   A waiting list for books that are currently unavailable (use `Queue` interface). The waiting list should be per book title (or ISBN).
 *         *   Methods for adding books, adding borrowers, borrowing books, returning books, and listing information.
 * 
 * 2.  **Functionality:**
 *     *   **Add Book:** Allows adding a new book to the library catalog. If a book with the same ISBN already exists, update its total copies.
 *     *   **Add Borrower:** Allows adding a new library member. If a borrower with the same ID already exists, indicate an error.
 *     *   **Borrow Book:**
 *         *   Takes `borrowerId` and `isbn` as input.
 *         *   Validate if the borrower and book exist.
 *         *   Check if the borrower already has borrowed a copy of this specific book (by ISBN). If so, display an error.
 *         *   Check if `availableCopies` for the book > 0.
 *             *   If yes, decrement `availableCopies`, record that this borrower has borrowed this book.
 *             *   If no, add the borrower to the waiting list for this book's ISBN. Implement a maximum waiting list size (e.g., 3). If the waiting list is full, display an error.
 *     *   **Return Book:**
 *         *   Takes `borrowerId` and `isbn` as input.
 *         *   Validate if the borrower and book exist.
 *         *   Check if the borrower actually borrowed this book. If not, display an error.
 *         *   If yes, increment `availableCopies`, remove the record of the borrower having this book.
 *         *   Check the waiting list for this book's ISBN. If not empty, dequeue the next borrower and display a message indicating the book is now available for them.
 *     *   **List All Books:** Display details of all books including ISBN, title, author, total copies, available copies, and the current size of the waiting list for that book.
 *     *   **List Borrowed Books:** Display which borrower has borrowed which book(s).
 * 
 * 3.  **User Interface:**
 *     *   Use `java.util.Scanner` to get user input from the console.
 *     *   Present a menu of options (Add Book, Add Borrower, Borrow, Return, List Books, List Borrowed, Exit).
 *     *   Use a `switch` statement to handle menu selections.
 *     *   Provide clear prompts for user input.
 * 
 * 4.  **Error Handling & Output:**
 *     *   Use `System.err` for displaying error messages (e.g., "Book not found!", "Borrower already exists!").
 *     *   Use `System.out` for displaying menu, prompts, success messages, and list outputs.
 *     *   Implement class-wide exception handling using `try-catch` blocks, particularly around user input processing and potentially the main application loop, to catch unexpected errors gracefully. Handle potential `InputMismatchException` when reading numbers.
 * 
 * 5.  **Best Practices:**
 *     *   Use meaningful variable and method names.
 *     *   Include appropriate comments and documentation (JavaDocs are a plus but simple comments are sufficient for clarity).
 *     *   Ensure proper encapsulation (private fields with public getters/setters where necessary).
 *     *   Implement input validation where appropriate (e.g., checking if book/borrower exists).
 *     *   Maintain clean code structure.
 * 
 * **Maximum Waiting List Size:** 3 borrowers per book.
 * 
 * **Expected Output:** The system should interact via the console, providing clear prompts, displaying results of operations, and reporting errors appropriately using `System.err`.
 * 
 * **Example Interaction Snippet (Illustrative):**
 * 
 * ```
 * Library Menu:
 * 1. Add Book
 * 2. Add Borrower
 * 3. Borrow Book
 * 4. Return Book
 * 5. List All Books
 * 6. List Borrowed Books
 * 7. Exit
 * Enter choice: 1
 * Enter ISBN: 978-0321765723
 * Enter Title: Effective Java
 * Enter Author: Joshua Bloch
 * Enter Total Copies: 2
 * Book added: Effective Java (ISBN: 978-0321765723)
 * 
 * Library Menu:
 * ...
 * Enter choice: 2
 * Enter Borrower ID: B001
 * Enter Name: Alice
 * Borrower added: Alice (ID: B001)
 * 
 * Library Menu:
 * ...
 * Enter choice: 3
 * Enter Borrower ID: B001
 * Enter ISBN: 978-0321765723
 * Book 'Effective Java' borrowed by Alice.
 * 
 * Library Menu:
 * ...
 * Enter choice: 5
 * Library Catalog:
 * ISBN: 978-0321765723, Title: Effective Java, Author: Joshua Bloch, Copies: 2, Available: 1, Waiting List: 0
 * 
 * Library Menu:
 * ...
 * Enter choice: 3
 * Enter Borrower ID: B002
 * Enter ISBN: 978-0321765723
 * Book 'Effective Java' borrowed by B002.
 * 
 * Library Menu:
 * ...
 * Enter choice: 3
 * Enter Borrower ID: B003
 * Enter ISBN: 978-0321765723
 * Book 'Effective Java' is currently unavailable. You have been added to the waiting list.
 * 
 * Library Menu:
 * ...
 * Enter choice: 3
 * Enter Borrower ID: B004
 * Enter ISBN: 978-0321765723
 * System.err: Waiting list for 'Effective Java' is full. Cannot add more borrowers.
 * 
 * Library Menu:
 * ...
 * Enter choice: 4
 * Enter Borrower ID: B001
 * Enter ISBN: 978-0321765723
 * Book 'Effective Java' returned by Alice.
 * Book 'Effective Java' is now available. B003 is next on the waiting list.
 * 
 * ... (and so on)
 * ```
 * 
 * Your solution should be a complete, runnable Java program.
 *
 * EXPLANATION:
 * This solution implements a simplified library management system using the specified Java components and best practices.
 * 
 * 1.  **Class Structure:**
 *     *   `Book` class: Encapsulates book data (`isbn`, `title`, `author`, `totalCopies`, `availableCopies`). It includes getters and a setter for `totalCopies` which correctly adjusts `availableCopies`. Methods `borrowCopy` and `returnCopy` manage the available count. `equals` and `hashCode` are overridden based on ISBN for correct comparison and use in collections like `HashMap`.
 *     *   `Borrower` class: Encapsulates borrower data (`borrowerId`, `name`). Includes getters. `equals` and `hashCode` are overridden based on `borrowerId`.
 *     *   `Library` class: This is the core class managing the library's state and operations.
 *         *   It uses `List<Book> catalog` and `List<Borrower> members` (implemented by `ArrayList`) to store the main collections. Using the `List` interface allows flexibility if a different list implementation were desired later.
 *         *   `Map<Borrower, List<String>> borrowedItems`: A `HashMap` where keys are `Borrower` objects and values are `ArrayLists` of ISBN strings. This tracks which specific book ISBNs each borrower currently possesses.
 *         *   `Map<String, Queue<Borrower>> waitingLists`: A `HashMap` where keys are ISBN strings and values are `Queue<Borrower>` objects (implemented by `LinkedList`). This manages the waiting list for each book title. The `Queue` ensures a First-In, First-Out (FIFO) order for borrowers waiting for a book.
 *         *   Private helper methods (`findBookByIsbn`, `findBorrowerById`) encapsulate lookup logic.
 *         *   Public methods (`addBook`, `addBorrower`, `borrowBook`, `returnBook`, `listAllBooks`, `listBorrowedBooks`) implement the required library operations.
 * 
 * 2.  **Required Component Usage:**
 *     *   `Queue`: Used in `waitingLists` (`Map<String, Queue<Borrower>>`) to manage borrowers waiting for a specific book in FIFO order. `offer()` adds to the queue, `peek()` looks at the head, and the logic in `returnBook` conceptually uses the queue head (though `poll()` isn't strictly needed just for notification in this implementation).
 *     *   `ArrayList`: Used to implement the `List` interfaces for `catalog` and `members`. Also used for the `List<String>` values in the `borrowedItems` map.
 *     *   `List interface`: Declared for `catalog` and `members` (`List<Book> catalog = new ArrayList<>();`).
 *     *   `Scanner`: Used in the `main` method (`LibrarySystem` class) to read user input from `System.in`.
 *     *   `Switch statement`: Used in the `main` loop to direct program flow based on the user's menu choice.
 *     *   `System.err`: Used extensively throughout the `Library` and `LibrarySystem` classes to print error messages (e.g., book not found, borrower exists, waiting list full).
 *     *   `System.out`: Used for printing the menu, prompts, success messages, and the output of listing functions.
 *     *   `try-catch`:
 *         *   A broad `try-catch(Exception e)` block wraps the main `do-while` loop in `LibrarySystem.main` to catch any unexpected runtime exceptions, printing them to `System.err`.
 *         *   A specific `try-catch(InputMismatchException e)` is used inside the loop to handle cases where the user enters non-numeric input when a number (like the menu choice or total copies) is expected, preventing the program from crashing and prompting the user to re-enter.
 *         *   `IllegalArgumentException` is caught when adding books with negative copies.
 * 
 * 3.  **Logic Implementation:**
 *     *   Adding: Checks for existing IDs/ISBNs and either updates (books) or reports an error (borrowers).
 *     *   Borrowing: Validates borrower/book, checks if the borrower already has the book, checks availability. If available, updates counts and records the borrow. If unavailable, adds to the waiting list (if not already there and list is not full).
 *     *   Returning: Validates borrower/book, checks if the borrower actually borrowed it. If yes, updates counts and removes the borrow record. Then, it checks the waiting list for that book and notifies the next borrower if someone is waiting.
 *     *   Listing: Iterates through the catalog and borrowed items maps, printing formatted information. The waiting list size is retrieved and displayed for each book.
 * 
 * 4.  **Best Practices:**
 *     *   **Encapsulation:** Fields in `Book` and `Borrower` are private, accessed via public getters. Setters are provided only where necessary and safe (`setTotalCopies`).
 *     *   **Meaningful Names:** Variables and methods have descriptive names (e.g., `borrowedItems`, `waitingLists`, `findBookByIsbn`, `borrowBook`).
 *     *   **Comments/Documentation:** Comments explain the purpose of classes, methods, and key logic sections.
 *     *   **Input Validation:** Checks are performed for existing books/borrowers, negative copy counts, borrower already having a book, borrower returning a book they didn't borrow, and waiting list capacity.
 *     *   **Error Handling:** `System.err` is used for errors. `try-catch` handles input format issues and general exceptions.
 *     *   **Clean Code Structure:** The code is separated into logical classes (`Book`, `Borrower`, `Library`, `LibrarySystem`) with clear responsibilities. The main logic is in the `Library` class, while `LibrarySystem` handles the user interaction loop.
 * 
 * This solution effectively demonstrates the required components in a practical context, including handling different collection types, managing state across objects, and implementing robust error handling for user input and logical conditions.
 */

import java.util.*;

// Represents a book in the library
class Book {
    private String isbn;
    private String title;
    private String author;
    private int totalCopies;
    private int availableCopies;

    public Book(String isbn, String title, String author, int totalCopies) {
        if (totalCopies < 0) {
            throw new IllegalArgumentException("Total copies cannot be negative.");
        }
        this.isbn = isbn;
        this.title = title;
        this.author = author;
        this.totalCopies = totalCopies;
        this.availableCopies = totalCopies; // Initially all copies are available
    }

    // Getters
    public String getIsbn() {
        return isbn;
    }

    public String getTitle() {
        return title;
    }

    public String getAuthor() {
        return author;
    }

    public int getTotalCopies() {
        return totalCopies;
    }

    public int getAvailableCopies() {
        return availableCopies;
    }

    // Setters (only for updating total copies and recalculating available)
    public void setTotalCopies(int totalCopies) {
        if (totalCopies < 0) {
             throw new IllegalArgumentException("Total copies cannot be negative.");
        }
        // Adjust available copies based on the change in total copies
        int change = totalCopies - this.totalCopies;
        this.availableCopies += change;
        if (this.availableCopies < 0) {
             // This scenario shouldn't happen if borrowed counts are tracked properly,
             // but as a safeguard or if logic changes, ensure available isn't negative.
             this.availableCopies = 0;
        }
        this.totalCopies = totalCopies;
    }

    // Methods for managing copies
    public boolean borrowCopy() {
        if (availableCopies > 0) {
            availableCopies--;
            return true;
        }
        return false;
    }

    public void returnCopy() {
        if (availableCopies < totalCopies) {
            availableCopies++;
        } else {
            // Should not happen in correct flow, indicates a logic error
            System.err.println("Warning: Returning a book copy that was not marked as borrowed for ISBN: " + isbn);
        }
    }

    @Override
    public String toString() {
        return String.format("ISBN: %s, Title: %s, Author: %s, Copies: %d, Available: %d",
                             isbn, title, author, totalCopies, availableCopies);
    }

    // Equals and hashCode based on ISBN for collection lookups
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Book book = (Book) o;
        return Objects.equals(isbn, book.isbn);
    }

    @Override
    public int hashCode() {
        return Objects.hash(isbn);
    }
}

// Represents a library member
class Borrower {
    private String borrowerId;
    private String name;

    public Borrower(String borrowerId, String name) {
        this.borrowerId = borrowerId;
        this.name = name;
    }

    // Getters
    public String getBorrowerId() {
        return borrowerId;
    }

    public String getName() {
        return name;
    }

    @Override
    public String toString() {
        return String.format("ID: %s, Name: %s", borrowerId, name);
    }

    // Equals and hashCode based on borrowerId
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Borrower borrower = (Borrower) o;
        return Objects.equals(borrowerId, borrower.borrowerId);
    }

    @Override
    public int hashCode() {
        return Objects.hash(borrowerId);
    }
}

// Manages the library's collection and operations
class Library {
    // Use List interface, implemented by ArrayList
    private List<Book> catalog;
    private List<Borrower> members;

    // Map to track borrowed books: Borrower -> List of ISBNs they have borrowed
    private Map<Borrower, List<String>> borrowedItems;

    // Map for waiting lists: ISBN -> Queue of Borrowers
    private Map<String, Queue<Borrower>> waitingLists;

    private static final int MAX_WAITING_LIST_SIZE = 3;

    public Library() {
        this.catalog = new ArrayList<>();
        this.members = new ArrayList<>();
        this.borrowedItems = new HashMap<>();
        this.waitingLists = new HashMap<>();
    }

    /**
     * Finds a book by its ISBN.
     * @param isbn The ISBN to search for.
     * @return The Book object if found, null otherwise.
     */
    private Book findBookByIsbn(String isbn) {
        for (Book book : catalog) {
            if (book.getIsbn().equals(isbn)) {
                return book;
            }
        }
        return null;
    }

    /**
     * Finds a borrower by their ID.
     * @param borrowerId The ID to search for.
     * @return The Borrower object if found, null otherwise.
     */
    private Borrower findBorrowerById(String borrowerId) {
        for (Borrower borrower : members) {
            if (borrower.getBorrowerId().equals(borrowerId)) {
                return borrower;
            }
        }
        return null;
    }

    /**
     * Adds a new book or updates copies if it exists.
     * @param isbn The ISBN of the book.
     * @param title The title of the book.
     * @param author The author of the book.
     * @param totalCopies The total number of copies.
     * @return The Book object added or updated.
     */
    public Book addBook(String isbn, String title, String author, int totalCopies) {
        Book existingBook = findBookByIsbn(isbn);
        if (existingBook != null) {
            // Book exists, update copies
            int oldTotal = existingBook.getTotalCopies();
            existingBook.setTotalCopies(totalCopies);
            System.out.println("Book with ISBN " + isbn + " already exists. Updated total copies from " + oldTotal + " to " + totalCopies + ".");
            return existingBook;
        } else {
            // New book
            Book newBook = new Book(isbn, title, author, totalCopies);
            catalog.add(newBook);
            System.out.println("Book added: " + newBook.getTitle() + " (ISBN: " + newBook.getIsbn() + ")");
            return newBook;
        }
    }

    /**
     * Adds a new borrower.
     * @param borrowerId The ID of the borrower.
     * @param name The name of the borrower.
     * @return The Borrower object added, or null if ID already exists.
     */
    public Borrower addBorrower(String borrowerId, String name) {
        if (findBorrowerById(borrowerId) != null) {
            System.err.println("Error: Borrower with ID " + borrowerId + " already exists.");
            return null;
        }
        Borrower newBorrower = new Borrower(borrowerId, name);
        members.add(newBorrower);
        borrowedItems.put(newBorrower, new ArrayList<>()); // Initialize borrowed list for new borrower
        System.out.println("Borrower added: " + newBorrower.getName() + " (ID: " + newBorrower.getBorrowerId() + ")");
        return newBorrower;
    }

    /**
     * Handles the borrowing of a book by a borrower.
     * @param borrowerId The ID of the borrower.
     * @param isbn The ISBN of the book.
     */
    public void borrowBook(String borrowerId, String isbn) {
        Borrower borrower = findBorrowerById(borrowerId);
        if (borrower == null) {
            System.err.println("Error: Borrower with ID " + borrowerId + " not found.");
            return;
        }

        Book book = findBookByIsbn(isbn);
        if (book == null) {
            System.err.println("Error: Book with ISBN " + isbn + " not found.");
            return;
        }

        // Check if borrower already has this book
        List<String> borrowed = borrowedItems.get(borrower);
        if (borrowed != null && borrowed.contains(isbn)) {
            System.err.println("Error: Borrower " + borrower.getName() + " already has a copy of '" + book.getTitle() + "'.");
            return;
        }

        if (book.getAvailableCopies() > 0) {
            // Book is available, borrow it
            book.borrowCopy();
            borrowedItems.get(borrower).add(isbn);
            System.out.println("Book '" + book.getTitle() + "' borrowed by " + borrower.getName() + ".");
        } else {
            // Book is not available, add to waiting list
            Queue<Borrower> waitQueue = waitingLists.getOrDefault(isbn, new LinkedList<>());

            if (waitQueue.contains(borrower)) {
                 System.err.println("Error: Borrower " + borrower.getName() + " is already on the waiting list for '" + book.getTitle() + "'.");
                 return;
            }

            if (waitQueue.size() < MAX_WAITING_LIST_SIZE) {
                waitQueue.offer(borrower); // Add to the end of the queue
                waitingLists.put(isbn, waitQueue); // Update the map (important if getOrDefault created a new queue)
                System.out.println("Book '" + book.getTitle() + "' is currently unavailable. " + borrower.getName() + " has been added to the waiting list.");
            } else {
                System.err.println("Error: Waiting list for '" + book.getTitle() + "' is full. Cannot add more borrowers.");
            }
        }
    }

    /**
     * Handles the returning of a book by a borrower.
     * @param borrowerId The ID of the borrower.
     * @param isbn The ISBN of the book.
     */
    public void returnBook(String borrowerId, String isbn) {
        Borrower borrower = findBorrowerById(borrowerId);
        if (borrower == null) {
            System.err.println("Error: Borrower with ID " + borrowerId + " not found.");
            return;
        }

        Book book = findBookByIsbn(isbn);
        if (book == null) {
            System.err.println("Error: Book with ISBN " + isbn + " not found.");
            return;
        }

        // Check if borrower actually borrowed this book
        List<String> borrowed = borrowedItems.get(borrower);
        if (borrowed == null || !borrowed.contains(isbn)) {
            System.err.println("Error: Borrower " + borrower.getName() + " did not borrow the book '" + book.getTitle() + "'.");
            return;
        }

        // Return the book
        borrowed.remove(isbn);
        book.returnCopy();
        System.out.println("Book '" + book.getTitle() + "' returned by " + borrower.getName() + ".");

        // Check the waiting list
        Queue<Borrower> waitQueue = waitingLists.get(isbn);
        if (waitQueue != null && !waitQueue.isEmpty()) {
            Borrower nextBorrower = waitQueue.peek(); // Just peek, don't remove yet
             // Optional: Notify the next person
            System.out.println("Book '" + book.getTitle() + "' is now available. " + nextBorrower.getName() + " (" + nextBorrower.getBorrowerId() + ") is next on the waiting list.");
            // Note: The system doesn't automatically borrow for them here.
            // A real system might, but for this exam, notifying is sufficient.
        }
    }

    /**
     * Lists all books in the library catalog.
     */
    public void listAllBooks() {
        System.out.println("\n--- Library Catalog ---");
        if (catalog.isEmpty()) {
            System.out.println("Catalog is empty.");
            return;
        }
        for (Book book : catalog) {
            Queue<Borrower> waitQueue = waitingLists.get(book.getIsbn());
            int waitingSize = (waitQueue != null) ? waitQueue.size() : 0;
            System.out.println(book + ", Waiting List: " + waitingSize);
        }
        System.out.println("-----------------------");
    }

    /**
     * Lists all currently borrowed books and by whom.
     */
    public void listBorrowedBooks() {
        System.out.println("\n--- Borrowed Books ---");
        boolean anyBorrowed = false;
        for (Map.Entry<Borrower, List<String>> entry : borrowedItems.entrySet()) {
            Borrower borrower = entry.getKey();
            List<String> borrowedIsbns = entry.getValue();
            if (!borrowedIsbns.isEmpty()) {
                anyBorrowed = true;
                System.out.print(borrower.getName() + " (ID: " + borrower.getBorrowerId() + ") has borrowed: ");
                List<String> bookTitles = new ArrayList<>();
                for (String isbn : borrowedIsbns) {
                    Book book = findBookByIsbn(isbn);
                    if (book != null) {
                        bookTitles.add("'" + book.getTitle() + "' (ISBN: " + isbn + ")");
                    } else {
                         bookTitles.add("Unknown Book (ISBN: " + isbn + ")");
                    }
                }
                System.out.println(String.join(", ", bookTitles));
            }
        }
        if (!anyBorrowed) {
            System.out.println("No books are currently borrowed.");
        }
        System.out.println("----------------------");
    }

    /**
     * Gets the waiting list for a specific ISBN.
     * Useful for checking contains or size in main logic if needed, but encapsulated here.
     * @param isbn The ISBN.
     * @return The Queue of borrowers, or null if no waiting list exists for this ISBN.
     */
    // public Queue<Borrower> getWaitingList(String isbn) {
    //     return waitingLists.get(isbn);
    // }

     /**
     * Checks if a borrower is on the waiting list for a specific ISBN.
     * @param borrowerId The ID of the borrower.
     * @param isbn The ISBN of the book.
     * @return true if the borrower is on the waiting list, false otherwise.
     */
    // public boolean isBorrowerOnWaitingList(String borrowerId, String isbn) {
    //     Queue<Borrower> waitQueue = waitingLists.get(isbn);
    //     if (waitQueue == null || waitQueue.isEmpty()) {
    //         return false;
    //     }
    //     Borrower borrower = findBorrowerById(borrowerId);
    //     if (borrower == null) {
    //         return false; // Borrower doesn't exist
    //     }
    //     return waitQueue.contains(borrower);
    // }
}

public class LibrarySystem {

    private static final int MAX_WAITING_LIST_SIZE = 3; // Redundant definition, but good for clarity in main

    public static void main(String[] args) {
        Library library = new Library();
        Scanner scanner = new Scanner(System.in);

        // Class-wide exception handling for unexpected errors
        try {
            int choice;
            do {
                printMenu();
                System.out.print("Enter choice: ");

                // Input validation for menu choice
                try {
                    choice = scanner.nextInt();
                    scanner.nextLine(); // Consume newline left-over

                    // Switch statement for flow control
                    switch (choice) {
                        case 1: // Add Book
                            System.out.print("Enter ISBN: ");
                            String isbn = scanner.nextLine();
                            System.out.print("Enter Title: ");
                            String title = scanner.nextLine();
                            System.out.print("Enter Author: ");
                            String author = scanner.nextLine();
                            System.out.print("Enter Total Copies: ");
                            int totalCopies = scanner.nextInt();
                            scanner.nextLine(); // Consume newline

                            if (totalCopies < 0) {
                                System.err.println("Error: Total copies cannot be negative.");
                            } else {
                                library.addBook(isbn, title, author, totalCopies);
                            }
                            break;

                        case 2: // Add Borrower
                            System.out.print("Enter Borrower ID: ");
                            String borrowerId = scanner.nextLine();
                            System.out.print("Enter Name: ");
                            String name = scanner.nextLine();
                            library.addBorrower(borrowerId, name);
                            break;

                        case 3: // Borrow Book
                            System.out.print("Enter Borrower ID: ");
                            String borrowBorrowerId = scanner.nextLine();
                            System.out.print("Enter ISBN: ");
                            String borrowIsbn = scanner.nextLine();
                            library.borrowBook(borrowBorrowerId, borrowIsbn);
                            break;

                        case 4: // Return Book
                            System.out.print("Enter Borrower ID: ");
                            String returnBorrowerId = scanner.nextLine();
                            System.out.print("Enter ISBN: ");
                            String returnIsbn = scanner.nextLine();
                            library.returnBook(returnBorrowerId, returnIsbn);
                            break;

                        case 5: // List All Books
                            library.listAllBooks();
                            break;

                        case 6: // List Borrowed Books
                             library.listBorrowedBooks();
                             break;

                        case 7: // Exit
                            System.out.println("Exiting Library System. Goodbye!");
                            break;

                        default:
                            System.err.println("Invalid choice. Please enter a number between 1 and 7.");
                    }
                } catch (InputMismatchException e) {
                    System.err.println("Invalid input. Please enter a number for the menu choice or number of copies.");
                    scanner.nextLine(); // Consume the invalid input to prevent infinite loop
                    choice = 0; // Set choice to 0 to continue loop
                } catch (IllegalArgumentException e) {
                     System.err.println("Input Error: " + e.getMessage());
                }

            } while (choice != 7);

        } catch (Exception e) {
            // Catch any other unexpected exceptions
            System.err.println("An unexpected error occurred: " + e.getMessage());
            e.printStackTrace(System.err); // Print stack trace to error stream
        } finally {
            scanner.close(); // Ensure scanner is closed
        }
    }

    /**
     * Prints the main menu options.
     */
    private static void printMenu() {
        System.out.println("\n--- Library Menu ---");
        System.out.println("1. Add Book");
        System.out.println("2. Add Borrower");
        System.out.println("3. Borrow Book");
        System.out.println("4. Return Book");
        System.out.println("5. List All Books");
        System.out.println("6. List Borrowed Books");
        System.out.println("7. Exit");
        System.out.println("--------------------");
    }
}
