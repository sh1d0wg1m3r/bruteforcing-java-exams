/*
 * Exam Question #963
 * Generated on: 2025-05-12 17:05:54
 * Generated by: Account 3
 * 
 * QUESTION:
 * **Java Programming Exam: Advanced Task Management System**
 * 
 * **Problem Description:**
 * 
 * You are tasked with developing a simple command-line Task Management System for a small team. The system should allow users to add tasks, view tasks based on their status, and manage the task workflow from pending to completion. Tasks have a description, a priority (High, Medium, Low), and a status (Pending, In Progress, Completed).
 * 
 * The system will maintain three main collections of tasks:
 * 1.  **Pending Tasks:** A list of tasks that have been added but not yet started.
 * 2.  **Tasks In Progress:** A queue of tasks that have been moved from the pending list and are currently being worked on.
 * 3.  **Completed Tasks:** A list of tasks that have finished.
 * 
 * The system should provide a menu-driven interface for user interaction.
 * 
 * **Requirements:**
 * 
 * 1.  **Task Class:** Create a `Task` class with private fields for `description` (String), `priority` (enum), and `status` (enum). Include a constructor, public getter methods for all fields, and a public method `setStatus(Status status)` to update the task's status. Override the `toString()` method to provide a user-friendly representation of the task.
 * 2.  **Enums:** Define two enums: `Priority` (with values HIGH, MEDIUM, LOW) and `Status` (with values PENDING, IN_PROGRESS, COMPLETED).
 * 3.  **TaskManager Class:** Create a `TaskManager` class to manage the collections of tasks.
 *     *   It must have private fields:
 *         *   A `List` (specifically an `ArrayList`) to store pending tasks.
 *         *   A `Queue` to store tasks currently in progress.
 *         *   A `List` (specifically an `ArrayList`) to store completed tasks.
 *     *   Implement the following public methods:
 *         *   `addTask(String description, Priority priority)`: Adds a new task with `PENDING` status to the pending tasks list.
 *         *   `viewPendingTasks()`: Prints all tasks in the pending list to `System.out`.
 *         *   `viewTasksInProgress()`: Prints all tasks in the in-progress queue to `System.out`.
 *         *   `viewCompletedTasks()`: Prints all tasks in the completed tasks list to `System.out`.
 *         *   `moveHighestPriorityPendingTaskToInProgress()`:
 *             *   Finds the highest priority task in the *pending* list (HIGH > MEDIUM > LOW). If multiple tasks have the same highest priority, choose the first one encountered.
 *             *   If a pending task is found:
 *                 *   Remove it from the pending list.
 *                 *   Change its status to `IN_PROGRESS`.
 *                 *   Add it to the tasks in progress queue.
 *                 *   Print a confirmation message to `System.out`.
 *             *   If no pending tasks are found, print an error message to `System.err`.
 *         *   `completeTaskFromInProgress()`:
 *             *   Removes (polls) the task at the front of the tasks in progress queue.
 *             *   If a task is retrieved:
 *                 *   Change its status to `COMPLETED`.
 *                 *   Add it to the completed tasks list.
 *                 *   Print a confirmation message to `System.out`.
 *             *   If the in-progress queue is empty, print an error message to `System.err`.
 * 4.  **Main Application Class:** Create a class (e.g., `TaskApp`) with a `main` method.
 *     *   Initialize a `Scanner` for user input and a `TaskManager` instance.
 *     *   Implement a menu loop that presents the following options to the user:
 *         1.  Add New Task
 *         2.  View Pending Tasks
 *         3.  View Tasks In Progress
 *         4.  View Completed Tasks
 *         5.  Move Highest Priority Pending Task to In Progress
 *         6.  Complete Task from In Progress Queue
 *         7.  Exit
 *     *   Use a `switch` statement to handle the user's menu choice.
 *     *   Implement input validation for priority when adding a task (accept "HIGH", "MEDIUM", "LOW", case-insensitive). If input is invalid, print an error to `System.err` and do not add the task.
 *     *   Implement class-wide exception handling using `try-catch` blocks. Wrap the main menu loop or critical operations to catch potential runtime exceptions and print an informative error message to `System.err`.
 *     *   Use `System.out` for all normal output (menus, task lists, success messages).
 *     *   Use `System.err` for all error messages (invalid input, operation on empty collection, caught exceptions).
 * 5.  **Best Practices:**
 *     *   Use appropriate data types and collections as specified.
 *     *   Employ proper encapsulation (private fields, public methods).
 *     *   Use meaningful variable and method names.
 *     *   Include comments and basic documentation (e.g., Javadoc for classes/methods).
 *     *   Ensure clean code structure.
 * 
 * **Example Interaction (Partial):**
 * 
 * ```
 * --- Task Management Menu ---
 * 1. Add New Task
 * 2. View Pending Tasks
 * 3. View Tasks In Progress
 * 4. View Completed Tasks
 * 5. Move Highest Priority Pending Task to In Progress
 * 6. Complete Task from In Progress Queue
 * 7. Exit
 * Enter your choice: 1
 * Enter task description: Implement Task Class
 * Enter priority (HIGH, MEDIUM, LOW): HIGH
 * Task added successfully.
 * 
 * --- Task Management Menu ---
 * ...
 * Enter your choice: 1
 * Enter task description: Design UI
 * Enter priority (HIGH, MEDIUM, LOW): MEDIUM
 * Task added successfully.
 * 
 * --- Task Management Menu ---
 * ...
 * Enter your choice: 2
 * Pending Tasks:
 * - [HIGH] Implement Task Class [PENDING]
 * - [MEDIUM] Design UI [PENDING]
 * 
 * --- Task Management Menu ---
 * ...
 * Enter your choice: 5
 * Moved task "[HIGH] Implement Task Class [PENDING]" to In Progress.
 * 
 * --- Task Management Menu ---
 * ...
 * Enter your choice: 3
 * Tasks In Progress:
 * - [HIGH] Implement Task Class [IN_PROGRESS]
 * 
 * --- Task Management Menu ---
 * ...
 * Enter your choice: 6
 * Completed task "[HIGH] Implement Task Class [IN_PROGRESS]".
 * 
 * --- Task Management Menu ---
 * ...
 * Enter your choice: 4
 * Completed Tasks:
 * - [HIGH] Implement Task Class [COMPLETED]
 * ```
 * 
 * **Evaluation:**
 * 
 * Your solution will be evaluated based on:
 * *   Correctness and completeness of implementation based on all requirements.
 * *   Proper usage of `Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.err`, `System.out`, and `try-catch`.
 * *   Adherence to best practices (encapsulation, naming, comments, clean code).
 * *   Correct input validation and error handling.
 * 
 * **Deliverable:**
 * 
 * Provide the complete Java source code for all classes (`Task`, `Priority`, `Status`, `TaskManager`, `TaskApp`).
 *
 * EXPLANATION:
 * This solution implements a simple Task Management System demonstrating the required Java concepts and best practices.
 * 
 * 1.  **Task Class:** Represents the core data structure. It uses private fields (`description`, `priority`, `status`) and public getters, adhering to encapsulation. The `setStatus` method allows controlled modification of the task's state. The `toString` method provides a convenient way to display task details.
 * 2.  **Enums (`Priority`, `Status`):** Define a fixed set of possible values for task priority and status, making the code more readable and preventing invalid values. Using `ordinal()` for priority comparison leverages the declaration order (HIGH=0, MEDIUM=1, LOW=2) for easy priority checking.
 * 3.  **TaskManager Class:** This class acts as the system's controller, managing the different task collections.
 *     *   It uses `List<Task> pendingTasks = new ArrayList<>();` to store pending tasks. `ArrayList` is suitable here as we need to add, iterate, and specifically remove elements by index or object after finding the highest priority task. Using the `List` interface for the variable type is good practice, allowing flexibility to change the implementation later if needed (though `ArrayList` is appropriate here).
 *     *   It uses `Queue<Task> tasksInProgressQueue = new LinkedList<>();` to store tasks currently being worked on. `LinkedList` is a common and efficient implementation for the `Queue` interface, providing O(1) complexity for adding to the end (`offer`) and removing from the front (`poll`), which fits the "in-progress" workflow where tasks are processed in the order they enter this state. The `Queue` interface ensures that queue-specific methods like `offer` and `poll` are used.
 *     *   It uses `List<Task> completedTasks = new ArrayList<>();` to store finished tasks. Similar to pending tasks, `ArrayList` is suitable for simply storing and listing completed items.
 *     *   Methods like `addTask`, `view...Tasks`, `moveHighestPriorityPendingTaskToInProgress`, and `completeTaskFromInProgress` encapsulate the system's logic.
 *     *   `moveHighestPriorityPendingTaskToInProgress`: This method iterates through the `pendingTasks` `ArrayList` to find the task with the lowest `priority.ordinal()` value (which corresponds to the highest priority enum value). It then removes the task from the `ArrayList` using its index, updates its status, and adds it to the `tasksInProgressQueue` using the `offer()` method. It includes a check for an empty pending list, printing an error to `System.err`.
 *     *   `completeTaskFromInProgress`: This method uses `poll()` to retrieve and remove the task at the head of the `tasksInProgressQueue`. It checks if the queue was empty before polling, printing an error to `System.err` if so. If a task is retrieved, its status is updated, and it's added to the `completedTasks` `ArrayList`.
 * 4.  **Main Application Class (`TaskApp`):** This class contains the `main` method and handles the user interface.
 *     *   A `Scanner` is used to read user input from `System.in`.
 *     *   A `while` loop runs the main application menu until the user chooses to exit.
 *     *   A `switch` statement efficiently directs control flow based on the user's integer choice.
 *     *   Input validation is performed for the menu choice (checking for non-integer input using `try-catch` around `scanner.nextInt()`) and for the priority input when adding a task (using `Priority.valueOf` within a `try-catch` block and checking for empty description in the `Task` constructor). Invalid inputs result in error messages printed to `System.err`.
 *     *   All normal output (menu, task lists, success messages) goes to `System.out`.
 *     *   All error messages (invalid input, operational errors like empty lists/queues, general exceptions) go to `System.err`.
 *     *   **Class-wide Exception Handling:** The outermost `try-catch (Exception e)` block in the `main` method demonstrates a form of class-wide handling. While specific input validation is handled inline, this block catches any other unexpected `RuntimeException` or checked `Exception` that might propagate up, preventing the program from crashing abruptly and printing a stack trace to `System.err` for debugging.
 *     *   The `Scanner` is closed when the application exits to release system resources.
 * 5.  **Best Practices:** The code uses meaningful variable and method names (`pendingTasks`, `moveHighestPriorityPendingTaskToInProgress`, etc.), includes basic comments and Javadoc, separates concerns into different classes, and uses encapsulation effectively. The use of interfaces (`List`, `Queue`) is demonstrated.
 * 
 * This solution effectively integrates all the required Java components into a practical, albeit simple, task management scenario, demonstrating understanding of collections, enums, control flow, and error handling.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.InputMismatchException; // Although not strictly required for this input, good practice

// --- Enums ---

/**
 * Represents the priority level of a task.
 */
enum Priority {
    HIGH, MEDIUM, LOW
}

/**
 * Represents the status of a task in its lifecycle.
 */
enum Status {
    PENDING, IN_PROGRESS, COMPLETED
}

// --- Task Class ---

/**
 * Represents a single task with a description, priority, and status.
 */
class Task {
    private String description;
    private Priority priority;
    private Status status;

    /**
     * Constructs a new Task.
     *
     * @param description The description of the task.
     * @param priority    The priority of the task.
     */
    public Task(String description, Priority priority) {
        if (description == null || description.trim().isEmpty()) {
            throw new IllegalArgumentException("Task description cannot be empty.");
        }
        if (priority == null) {
            throw new IllegalArgumentException("Task priority cannot be null.");
        }
        this.description = description.trim();
        this.priority = priority;
        this.status = Status.PENDING; // New tasks start as PENDING
    }

    // --- Getters ---
    public String getDescription() {
        return description;
    }

    public Priority getPriority() {
        return priority;
    }

    public Status getStatus() {
        return status;
    }

    // --- Setter for Status ---
    public void setStatus(Status status) {
        if (status == null) {
            throw new IllegalArgumentException("Task status cannot be null.");
        }
        this.status = status;
    }

    /**
     * Provides a user-friendly string representation of the task.
     *
     * @return String representation of the task.
     */
    @Override
    public String toString() {
        return String.format("[%s] %s [%s]", priority, description, status);
    }
}

// --- TaskManager Class ---

/**
 * Manages collections of tasks based on their status.
 */
class TaskManager {
    // Using List interface with ArrayList implementation for pending and completed tasks
    private List<Task> pendingTasks;
    // Using Queue interface with LinkedList implementation for tasks in progress
    private Queue<Task> tasksInProgressQueue;
    // Using List interface with ArrayList implementation for completed tasks
    private List<Task> completedTasks;

    /**
     * Constructs a new TaskManager with empty task collections.
     */
    public TaskManager() {
        this.pendingTasks = new ArrayList<>();
        this.tasksInProgressQueue = new LinkedList<>(); // LinkedList is a common Queue implementation
        this.completedTasks = new ArrayList<>();
    }

    /**
     * Adds a new task to the pending list.
     *
     * @param description The description of the task.
     * @param priority    The priority of the task.
     */
    public void addTask(String description, Priority priority) {
        try {
            Task newTask = new Task(description, priority);
            pendingTasks.add(newTask);
            System.out.println("Task added successfully.");
        } catch (IllegalArgumentException e) {
            System.err.println("Error adding task: " + e.getMessage());
        }
    }

    /**
     * Prints all tasks currently in the pending list.
     */
    public void viewPendingTasks() {
        System.out.println("\n--- Pending Tasks ---");
        if (pendingTasks.isEmpty()) {
            System.out.println("No pending tasks.");
        } else {
            for (int i = 0; i < pendingTasks.size(); i++) {
                System.out.println((i + 1) + ". " + pendingTasks.get(i));
            }
        }
    }

    /**
     * Prints all tasks currently in the in-progress queue.
     */
    public void viewTasksInProgress() {
        System.out.println("\n--- Tasks In Progress ---");
        if (tasksInProgressQueue.isEmpty()) {
            System.out.println("No tasks in progress.");
        } else {
            // Iterate through the queue without removing elements
            int i = 0;
            for (Task task : tasksInProgressQueue) {
                 System.out.println((i + 1) + ". " + task);
                 i++;
            }
        }
    }

    /**
     * Prints all tasks currently in the completed list.
     */
    public void viewCompletedTasks() {
        System.out.println("\n--- Completed Tasks ---");
        if (completedTasks.isEmpty()) {
            System.out.println("No completed tasks.");
        } else {
            for (int i = 0; i < completedTasks.size(); i++) {
                System.out.println((i + 1) + ". " + completedTasks.get(i));
            }
        }
    }

    /**
     * Finds the highest priority task in the pending list, moves it to the in-progress queue,
     * and updates its status.
     */
    public void moveHighestPriorityPendingTaskToInProgress() {
        if (pendingTasks.isEmpty()) {
            System.err.println("No pending tasks to move to in progress.");
            return;
        }

        Task highestPriorityTask = null;
        int highestPriorityIndex = -1;

        // Find the highest priority task
        for (int i = 0; i < pendingTasks.size(); i++) {
            Task currentTask = pendingTasks.get(i);
            if (highestPriorityTask == null || currentTask.getPriority().ordinal() < highestPriorityTask.getPriority().ordinal()) {
                 // Enums are ordered by declaration: HIGH(0), MEDIUM(1), LOW(2)
                 // Smaller ordinal means higher priority
                highestPriorityTask = currentTask;
                highestPriorityIndex = i;
            }
        }

        // Move the task
        if (highestPriorityTask != null && highestPriorityIndex != -1) {
            // Remove from pending list using index
            Task taskToMove = pendingTasks.remove(highestPriorityIndex);
            taskToMove.setStatus(Status.IN_PROGRESS);
            tasksInProgressQueue.offer(taskToMove); // offer is generally preferred over add for queues
            System.out.println("Moved task \"" + taskToMove.getDescription() + "\" to In Progress.");
        } else {
             // This case should ideally not be reached if pendingTasks is not empty,
             // but included for robustness.
             System.err.println("Could not find a suitable pending task to move.");
        }
    }

    /**
     * Completes the task at the front of the in-progress queue, moves it to the completed list,
     * and updates its status.
     */
    public void completeTaskFromInProgress() {
        if (tasksInProgressQueue.isEmpty()) {
            System.err.println("No tasks in progress to complete.");
            return;
        }

        // Poll the task from the front of the queue
        Task taskToComplete = tasksInProgressQueue.poll();

        if (taskToComplete != null) {
            taskToComplete.setStatus(Status.COMPLETED);
            completedTasks.add(taskToComplete);
            System.out.println("Completed task \"" + taskToComplete.getDescription() + "\".");
        } else {
             // This case should not be reached if queue.isEmpty() is false,
             // but poll returns null if empty, so checking is safer.
             System.err.println("Error: Could not retrieve task from in-progress queue.");
        }
    }
}

// --- Main Application Class ---

/**
 * Main class to run the Task Management System.
 * Handles user interaction and calls TaskManager methods.
 */
public class TaskApp {

    public static void main(String[] args) {
        // Class-wide exception handling for the main application loop
        try {
            Scanner scanner = new Scanner(System.in);
            TaskManager taskManager = new TaskManager();
            boolean running = true;

            System.out.println("--- Welcome to Task Management System ---");

            while (running) {
                printMenu();
                int choice = -1; // Initialize with an invalid choice

                // Input handling for menu choice
                try {
                    System.out.print("Enter your choice: ");
                    choice = scanner.nextInt();
                    scanner.nextLine(); // Consume newline left-over
                } catch (InputMismatchException e) {
                    System.err.println("Invalid input. Please enter a number.");
                    scanner.nextLine(); // Consume the invalid input
                    continue; // Skip to the next iteration
                }

                // Switch statement for menu navigation
                switch (choice) {
                    case 1: // Add New Task
                        System.out.print("Enter task description: ");
                        String description = scanner.nextLine();
                        System.out.print("Enter priority (HIGH, MEDIUM, LOW): ");
                        String priorityInput = scanner.nextLine().trim().toUpperCase();
                        try {
                            Priority priority = Priority.valueOf(priorityInput);
                            taskManager.addTask(description, priority);
                        } catch (IllegalArgumentException e) {
                            // Catching the exception if valueOf fails or Task constructor throws
                            System.err.println("Invalid priority entered. Task not added.");
                        }
                        break;

                    case 2: // View Pending Tasks
                        taskManager.viewPendingTasks();
                        break;

                    case 3: // View Tasks In Progress
                        taskManager.viewTasksInProgress();
                        break;

                    case 4: // View Completed Tasks
                        taskManager.viewCompletedTasks();
                        break;

                    case 5: // Move Highest Priority Pending Task to In Progress
                        taskManager.moveHighestPriorityPendingTaskToInProgress();
                        break;

                    case 6: // Complete Task from In Progress Queue
                        taskManager.completeTaskFromInProgress();
                        break;

                    case 7: // Exit
                        running = false;
                        System.out.println("Exiting Task Management System. Goodbye!");
                        break;

                    default: // Invalid choice
                        System.err.println("Invalid choice. Please enter a number between 1 and 7.");
                        break;
                }
                System.out.println(); // Add a blank line for readability
            }

            scanner.close(); // Close the scanner when exiting

        } catch (Exception e) {
            // Catch any unexpected exceptions not handled elsewhere
            System.err.println("\nAn unexpected error occurred:");
            e.printStackTrace(System.err); // Print stack trace to standard error
        }
    }

    /**
     * Prints the main menu options to the console.
     */
    private static void printMenu() {
        System.out.println("--- Task Management Menu ---");
        System.out.println("1. Add New Task");
        System.out.println("2. View Pending Tasks");
        System.out.println("3. View Tasks In Progress");
        System.out.println("4. View Completed Tasks");
        System.out.println("5. Move Highest Priority Pending Task to In Progress");
        System.out.println("6. Complete Task from In Progress Queue");
        System.out.println("7. Exit");
    }
}
