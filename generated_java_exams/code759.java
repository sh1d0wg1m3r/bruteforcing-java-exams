/*
 * Exam Question #759
 * Generated on: 2025-05-12 16:36:52
 * Generated by: Account 5
 * 
 * QUESTION:
 * Create a Java program for a simple Customer Support Ticket Processing System. The system should allow users to add new support tickets, process the oldest pending ticket, view current pending tickets, and view a history of processed tickets.
 * 
 * Your solution must adhere to the following requirements:
 * 
 * 1.  **Data Structures:**
 *     *   Use a `java.util.Queue` to manage pending support tickets (First-In, First-Out).
 *     *   Use a `java.util.List` (specifically implemented using `java.util.ArrayList`) to store a history of processed tickets.
 * 
 * 2.  **Classes:**
 *     *   Create a `Ticket` class to represent a single support ticket. It should have private fields for an ID (integer), description (String), type (String, e.g., "BUG", "SUPPORT", "FEATURE\_REQUEST"), and status (String, e.g., "PENDING", "PROCESSING", "RESOLVED"). Include a constructor, getters, a setter for status, and a `toString()` method.
 *     *   Create a `TicketSystem` class that contains the main logic. It should have private fields for the pending ticket queue, the processed ticket list, and a counter for generating unique ticket IDs.
 * 
 * 3.  **Functionality (in `TicketSystem`):**
 *     *   A method to add a new ticket: Takes description and type as input. Assigns a unique ID, sets the initial status to "PENDING", and adds the ticket to the pending queue. Validate the ticket type (only "BUG", "SUPPORT", "FEATURE\_REQUEST" allowed).
 *     *   A method to process the next pending ticket: Removes the oldest ticket from the pending queue, changes its status to "PROCESSING", simulates processing (e.g., print a message based on type using a `switch` statement), changes status to "RESOLVED", and moves it to the processed tickets list. Handle the case where there are no pending tickets.
 *     *   A method to view all pending tickets: Prints details of tickets in the pending queue without removing them.
 *     *   A method to view all processed tickets: Prints details of tickets in the processed list.
 *     *   A main loop (`run` method or similar) that presents a menu to the user via `System.out` and reads their choice using `java.util.Scanner`. The menu should include options to Add Ticket, Process Ticket, View Pending, View Processed, and Exit. Use a `switch` statement to handle the user's menu choice.
 * 
 * 4.  **Error Handling & Output:**
 *     *   Implement class-wide exception handling using `try-catch` blocks within the `TicketSystem` class to manage potential issues (e.g., invalid user input, attempting to process an empty queue, invalid ticket data).
 *     *   Use `System.err` exclusively for printing error messages.
 *     *   Use `System.out` for all normal output, prompts, menu, and success messages.
 *     *   Validate user input where necessary (e.g., menu choice, ticket type).
 * 
 * 5.  **Best Practices:**
 *     *   Use proper encapsulation (private fields, public methods).
 *     *   Use meaningful variable and method names.
 *     *   Include appropriate comments and documentation (e.g., Javadoc for methods).
 *     *   Ensure clean code structure.
 * 
 * **Expected Output:**
 * The program should start by printing a welcome message and displaying the menu. Based on user input, it should perform the requested action, printing results or errors accordingly, and loop back to the menu until the user chooses to exit.
 * 
 * Example Interaction Flow:
 * ```
 * --- Customer Support Ticket System ---
 * 
 * Select an option:
 * 1. Add New Ticket
 * 2. Process Next Pending Ticket
 * 3. View Pending Tickets
 * 4. View Processed Tickets History
 * 5. Exit
 * Enter your choice: 1
 * Enter ticket description: My application crashed
 * Enter ticket type (BUG, SUPPORT, FEATURE_REQUEST): BUG
 * Ticket #1 added to pending queue.
 * 
 * Select an option:
 * ... (menu) ...
 * Enter your choice: 1
 * Enter ticket description: How do I reset my password?
 * Enter ticket type (BUG, SUPPORT, FEATURE_REQUEST): SUPPORT
 * Ticket #2 added to pending queue.
 * 
 * Select an option:
 * ... (menu) ...
 * Enter your choice: 3
 * --- Pending Tickets ---
 * Ticket [ID=1, Type=BUG, Status=PENDING, Desc='My application crashed']
 * Ticket [ID=2, Type=SUPPORT, Status=PENDING, Desc='How do I reset my password?']
 * -----------------------
 * 
 * Select an option:
 * ... (menu) ...
 * Enter your choice: 2
 * Processing Ticket #1...
 * Handling as a bug report. Escalating to development team.
 * Ticket #1 resolved and moved to history.
 * 
 * Select an option:
 * ... (menu) ...
 * Enter your choice: 3
 * --- Pending Tickets ---
 * Ticket [ID=2, Type=SUPPORT, Status=PENDING, Desc='How do I reset my password?']
 * -----------------------
 * 
 * Select an option:
 * ... (menu) ...
 * Enter your choice: 4
 * --- Processed Tickets History ---
 * Ticket [ID=1, Type=BUG, Status=RESOLVED, Desc='My application crashed']
 * -------------------------------
 * 
 * Select an option:
 * ... (menu) ...
 * Enter your choice: 5
 * Exiting Ticket System. Goodbye!
 * ```
 * Handle error cases like entering invalid menu options, invalid ticket types, or trying to process when no tickets are pending, printing appropriate messages to `System.err`.
 *
 * EXPLANATION:
 * This solution implements a simple Customer Support Ticket System, demonstrating the required Java concepts in a practical context.
 * 
 * 1.  **`Ticket` Class:** This class serves as a blueprint for individual support tickets. It encapsulates the ticket's state (`id`, `description`, `type`, `status`) using private fields. Getters provide read access, and a setter allows updating the status. The constructor includes basic validation for the ticket `type`, throwing an `IllegalArgumentException` if the type is invalid. The `toString()` method provides a convenient way to print ticket details.
 * 
 * 2.  **`TicketSystem` Class:** This is the main class that manages the ticket workflow.
 *     *   **Data Structures:**
 *         *   `pendingTickets`: A `Queue<Ticket>` (implemented using `java.util.LinkedList`) is used to store tickets awaiting processing. The Queue's FIFO nature ensures that the oldest ticket is processed first, simulating a real-world support queue. Methods like `offer()` (to add) and `poll()` (to retrieve and remove the head) are used.
 *         *   `processedTickets`: A `java.util.List<Ticket>` (implemented using `java.util.ArrayList`) is used to keep a history of tickets that have been resolved. The `ArrayList` provides dynamic resizing and easy iteration for viewing the history.
 *     *   **Functionality Methods:**
 *         *   `addTicket(String description, String type)`: Creates a new `Ticket` object. It utilizes a `try-catch` block to handle the `IllegalArgumentException` that might be thrown by the `Ticket` constructor if the type is invalid, printing an error to `System.err`. If successful, the ticket is added to the `pendingTickets` queue using `offer()`, and a success message is printed to `System.out`.
 *         *   `processNextTicket()`: Retrieves the next ticket from the `pendingTickets` queue using `poll()`. It first checks if the queue is empty to avoid errors. If a ticket is retrieved, its status is updated, and a `switch` statement is used to demonstrate different processing logic based on the ticket's `type`. After simulating processing (including a small delay), the status is updated to "RESOLVED", and the ticket is added to the `processedTickets` list. A `try-catch` block is included to handle potential exceptions during processing, printing errors to `System.err`.
 *         *   `viewPendingTickets()` and `viewProcessedTickets()`: These methods iterate through the `pendingTickets` queue and `processedTickets` list, respectively, printing the details of each ticket to `System.out`. They include checks for empty collections.
 *     *   **`run()` Method:** This method contains the main application loop.
 *         *   It uses `java.util.Scanner` to read user input from `System.in`.
 *         *   A menu is displayed using `System.out`.
 *         *   User input for the menu choice is read. Input validation (`hasNextInt()`) is performed to handle non-numeric input gracefully, printing an error to `System.err` and consuming the invalid input.
 *         *   A `switch` statement is used to direct the program flow based on the valid user choice, calling the appropriate methods (`addTicket`, `processNextTicket`, `viewPendingTickets`, `viewProcessedTickets`).
 *         *   **Exception Handling:** The `run` method incorporates class-wide exception handling with nested `try-catch` blocks.
 *             *   The outer `try-catch` handles potential issues directly related to reading input with the `Scanner`.
 *             *   The inner `try-catch` wraps the `switch` statement, acting as a safety net for any unexpected exceptions that might occur during the execution of the chosen menu action (even if the individual methods have their own error handling for specific cases). All caught exceptions result in an error message printed to `System.err`, often including a stack trace for debugging.
 *         *   The loop continues until the user selects the 'Exit' option (choice 5).
 *         *   The `Scanner` resource is closed before the program terminates.
 * 
 * 3.  **Best Practices:**
 *     *   **Encapsulation:** Fields in both classes are private, accessed via public methods.
 *     *   **Meaningful Names:** Variable and method names clearly indicate their purpose (`pendingTickets`, `processNextTicket`, `viewProcessedTickets`).
 *     *   **Comments & Documentation:** Javadoc comments explain the purpose of classes and methods, while inline comments clarify specific logic.
 *     *   **Input Validation:** Ticket type is validated in the `Ticket` constructor, and menu input is validated in the `run` method.
 *     *   **Error Handling:** `try-catch` blocks are used extensively to handle anticipated (e.g., invalid input, empty queue) and unanticipated exceptions, directing error output to `System.err`.
 *     *   **Clean Structure:** The code is organized into logical classes, and methods have single responsibilities.
 * 
 * This solution effectively demonstrates the required Java components (`Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.err`, `System.out`, `try-catch`) within a functional, well-structured program that simulates a practical scenario.
 */

import java.util.Queue;
import java.util.LinkedList; // A common implementation of Queue
import java.util.List;
import java.util.ArrayList; // Implementation of List for processed tickets
import java.util.Scanner;
// No need to explicitly import NoSuchElementException if using poll() and checking isEmpty()

// Ticket.java - Represents a customer support ticket
class Ticket {
    private int id;
    private String description;
    private String type; // e.g., "BUG", "SUPPORT", "FEATURE_REQUEST"
    private String status; // e.g., "PENDING", "PROCESSING", "RESOLVED"

    /**
     * Constructs a new Ticket object.
     *
     * @param id The unique identifier for the ticket.
     * @param description The description of the issue or request.
     * @param type The type of the ticket ("BUG", "SUPPORT", or "FEATURE_REQUEST").
     * @throws IllegalArgumentException if the provided type is null, empty, or not one of the valid types.
     */
    public Ticket(int id, String description, String type) {
        this.id = id;
        this.description = description;
        // Validate and set the ticket type
        if (isValidType(type)) {
            this.type = type.toUpperCase(); // Standardize case
        } else {
            throw new IllegalArgumentException("Invalid ticket type provided: '" + type + "'. Valid types are: BUG, SUPPORT, FEATURE_REQUEST.");
        }
        this.status = "PENDING"; // Initial status
    }

    /**
     * Checks if the provided ticket type string is valid.
     *
     * @param type The type string to validate.
     * @return true if the type is "BUG", "SUPPORT", or "FEATURE_REQUEST" (case-insensitive), false otherwise.
     */
    private boolean isValidType(String type) {
        if (type == null || type.trim().isEmpty()) {
            return false;
        }
        String upperType = type.trim().toUpperCase();
        return upperType.equals("BUG") || upperType.equals("SUPPORT") || upperType.equals("FEATURE_REQUEST");
    }

    // --- Getters ---
    public int getId() {
        return id;
    }

    public String getDescription() {
        return description;
    }

    public String getType() {
        return type;
    }

    public String getStatus() {
        return status;
    }

    // --- Setter ---
    public void setStatus(String status) {
        this.status = status;
    }

    /**
     * Provides a string representation of the Ticket.
     *
     * @return A formatted string describing the ticket.
     */
    @Override
    public String toString() {
        return "Ticket [ID=" + id + ", Type=" + type + ", Status=" + status + ", Desc='" + description + "']";
    }
}

// TicketSystem.java - Manages the collection and processing of tickets
public class TicketSystem {

    // Use Queue for pending tickets (FIFO)
    private Queue<Ticket> pendingTickets;
    // Use List (ArrayList) for processed tickets history
    private List<Ticket> processedTickets;
    // Counter for generating unique ticket IDs
    private int nextTicketId;
    // Scanner for reading user input
    private Scanner scanner;

    /**
     * Constructs a new TicketSystem, initializing data structures and resources.
     */
    public TicketSystem() {
        this.pendingTickets = new LinkedList<>(); // LinkedList implements Queue
        this.processedTickets = new ArrayList<>(); // ArrayList implements List
        this.nextTicketId = 1; // Start ticket IDs from 1
        this.scanner = new Scanner(System.in);
    }

    /**
     * Adds a new ticket to the pending queue after validating its type.
     *
     * @param description The description of the ticket.
     * @param type        The type of the ticket (e.g., "BUG", "SUPPORT"). Case-insensitive input is handled.
     */
    public void addTicket(String description, String type) {
        // Use try-catch block for handling potential errors during ticket creation or adding
        try {
            // Ticket constructor validates type and might throw IllegalArgumentException
            Ticket newTicket = new Ticket(nextTicketId, description, type);
            // offer() is generally preferred over add() for queues as it handles capacity restrictions gracefully (though LinkedList is unbounded)
            boolean added = pendingTickets.offer(newTicket);
            if (added) {
                System.out.println("Ticket #" + newTicket.getId() + " added to pending queue.");
                nextTicketId++; // Increment ID only if ticket was successfully created and offered
            } else {
                 // This case is unlikely with LinkedList, but good practice for bounded queues
                 System.err.println("Error: Failed to add ticket to the queue.");
            }
        } catch (IllegalArgumentException e) {
            // Catch specific validation errors from the Ticket constructor
            System.err.println("Error adding ticket: " + e.getMessage());
            // nextTicketId is not incremented if ticket creation failed, so no need to decrement
        } catch (Exception e) {
             // Catch any other unexpected exceptions during the process
             System.err.println("An unexpected error occurred while adding ticket: " + e.getMessage());
             e.printStackTrace(System.err); // Print stack trace for debugging unexpected errors
        }
    }

    /**
     * Processes the next ticket from the head of the pending queue.
     * Changes its status and moves it to the processed tickets list.
     */
    public void processNextTicket() {
        // Use try-catch block for handling potential errors during processing
        try {
            // Check if the queue is empty before attempting to process
            if (pendingTickets.isEmpty()) {
                System.out.println("No pending tickets to process.");
                return; // Exit the method if nothing to process
            }

            // poll() retrieves and removes the head of the queue, returns null if empty
            Ticket ticketToProcess = pendingTickets.poll();

            // Should not be null due to isEmpty() check, but good practice to check
            if (ticketToProcess != null) {
                System.out.println("Processing Ticket #" + ticketToProcess.getId() + "...");
                ticketToProcess.setStatus("PROCESSING");

                // Simulate processing logic based on ticket type using a switch statement
                switch (ticketToProcess.getType()) {
                    case "BUG":
                        System.out.println("Action: Investigating bug report.");
                        // Add specific bug processing steps here
                        break;
                    case "SUPPORT":
                        System.out.println("Action: Providing direct customer support.");
                        // Add specific support steps here
                        break;
                    case "FEATURE_REQUEST":
                        System.out.println("Action: Forwarding feature request to product team.");
                        // Add specific feature request steps here
                        break;
                    default:
                        // This case should theoretically not happen if addTicket validates types
                        System.err.println("Warning: Encountered ticket with unknown type '" + ticketToProcess.getType() + "' during processing.");
                        // Handle or log the unexpected type
                        break;
                }

                // Simulate some processing time (optional)
                try {
                    Thread.sleep(300); // Pause for 300 milliseconds
                } catch (InterruptedException e) {
                    // Restore interrupted status
                    Thread.currentThread().interrupt();
                    System.err.println("Ticket processing interrupted.");
                }

                ticketToProcess.setStatus("RESOLVED"); // Set final status
                processedTickets.add(ticketToProcess); // Add the processed ticket to the history list
                System.out.println("Ticket #" + ticketToProcess.getId() + " resolved and moved to history.");
            } else {
                 // Fallback error if poll somehow returns null after isEmpty() check
                 System.err.println("Internal Error: Queue poll returned null unexpectedly.");
            }
        } catch (Exception e) {
            // Catch any other unexpected exceptions during processing
            System.err.println("An unexpected error occurred during ticket processing: " + e.getMessage());
            e.printStackTrace(System.err); // Print stack trace for debugging
        }
    }

    /**
     * Displays all tickets currently waiting in the pending queue.
     */
    public void viewPendingTickets() {
        System.out.println("\n--- Pending Tickets ---");
        if (pendingTickets.isEmpty()) {
            System.out.println("No tickets currently pending.");
        } else {
            // Iterate through the queue without removing elements
            for (Ticket ticket : pendingTickets) {
                System.out.println(ticket);
            }
        }
        System.out.println("-----------------------");
    }

    /**
     * Displays all tickets that have been processed and moved to the history list.
     */
    public void viewProcessedTickets() {
        System.out.println("\n--- Processed Tickets History ---");
        if (processedTickets.isEmpty()) {
            System.out.println("No tickets have been processed yet.");
        } else {
            // Iterate through the list
            for (Ticket ticket : processedTickets) {
                System.out.println(ticket);
            }
        }
        System.out.println("-------------------------------");
    }

    /**
     * Prints the main menu options to the console.
     */
    private void printMenu() {
        System.out.println("\nSelect an option:");
        System.out.println("1. Add New Ticket");
        System.out.println("2. Process Next Pending Ticket");
        System.out.println("3. View Pending Tickets");
        System.out.println("4. View Processed Tickets History");
        System.out.println("5. Exit");
    }

    /**
     * Runs the main application loop, handling user interaction via the console.
     * Includes input validation and exception handling for the main loop.
     */
    public void run() {
        System.out.println("--- Customer Support Ticket System ---");
        int choice = -1; // Variable to store user's menu choice

        // Main application loop continues until user chooses to exit (choice 5)
        while (choice != 5) {
            printMenu(); // Display the menu

            // Outer try-catch block for handling potential Scanner or input issues
            try {
                System.out.print("Enter your choice: ");
                // Validate that the next input is an integer
                if (scanner.hasNextInt()) {
                    choice = scanner.nextInt();
                    scanner.nextLine(); // Consume the newline character left by nextInt()
                } else {
                    // Handle non-integer input error
                    System.err.println("Invalid input. Please enter a number corresponding to the menu options.");
                    scanner.nextLine(); // Consume the invalid input to prevent infinite loop
                    choice = -1; // Reset choice to ensure the loop continues and menu is shown again
                    continue; // Skip the switch statement and go to the next loop iteration
                }

                // Inner try-catch block to handle potential exceptions during the execution of the chosen action
                // This provides a safety net if methods like addTicket or processNextTicket
                // throw unexpected runtime exceptions not caught internally.
                try {
                    // Use a switch statement to perform actions based on user choice
                    switch (choice) {
                        case 1:
                            // Add New Ticket
                            System.out.print("Enter ticket description: ");
                            String description = scanner.nextLine();
                            System.out.print("Enter ticket type (BUG, SUPPORT, FEATURE_REQUEST): ");
                            String type = scanner.nextLine();
                            // Call method to add ticket; addTicket handles its own specific errors (like invalid type)
                            addTicket(description, type);
                            break;
                        case 2:
                            // Process Next Pending Ticket
                            // Call method to process ticket; processNextTicket handles its own specific errors (like empty queue)
                            processNextTicket();
                            break;
                        case 3:
                            // View Pending Tickets
                            viewPendingTickets();
                            break;
                        case 4:
                            // View Processed Tickets History
                            viewProcessedTickets();
                            break;
                        case 5:
                            // Exit the system
                            System.out.println("Exiting Ticket System. Goodbye!");
                            break;
                        default:
                            // Handle choices that are integers but not between 1 and 5
                            System.err.println("Invalid choice. Please enter a number between 1 and 5.");
                    }
                } catch (Exception e) {
                    // Catch any unexpected runtime exceptions that might occur within the switch block
                    System.err.println("An unexpected system error occurred during operation: " + e.getMessage());
                    e.printStackTrace(System.err); // Print stack trace for debugging
                }

            } catch (Exception e) {
                // This outer catch block handles potential critical exceptions from the Scanner
                // or other issues outside the main operation logic within the switch.
                 System.err.println("A critical error occurred during input processing or system operation: " + e.getMessage());
                 e.printStackTrace(System.err);
                 choice = 5; // Set choice to 5 to exit the loop gracefully after a critical error
            }
             System.out.println(); // Add a newline for better readability between menu interactions
        }

        // Close the scanner resource when the application exits
        scanner.close();
        System.out.println("Scanner closed."); // Confirmation message
    }

    /**
     * Main method to start the Ticket System application.
     *
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        // Create an instance of the TicketSystem and run it
        TicketSystem system = new TicketSystem();
        system.run();
    }
}
