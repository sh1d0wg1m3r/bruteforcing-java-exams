/*
 * Exam Question #783
 * Generated on: 2025-05-12 16:40:13
 * Generated by: Account 4
 * 
 * QUESTION:
 * **Java Programming Exam: Advanced Hospital Appointment System**
 * 
 * **Problem Description:**
 * 
 * You are tasked with developing a simplified console-based hospital appointment management system. The system needs to manage a waiting list of patients and a list of doctors, assigning patients from the waiting list to available doctors.
 * 
 * **System Requirements:**
 * 
 * 1.  **Patient Waiting List:** Patients who arrive without a pre-assigned appointment are added to a waiting list. This list should process patients in the order they arrive (First-In, First-Out).
 * 2.  **Doctors:** The hospital has a fixed set of doctors. Each doctor can handle one appointment at a time.
 * 3.  **Commands:** The system must accept the following commands via console input:
 *     *   `add patient <patientName>`: Adds a new patient with the specified name to the end of the waiting list.
 *     *   `assign`: Takes the next patient from the front of the waiting list and assigns them to the first available doctor. If no patient is waiting or no doctor is available, an appropriate message should be displayed.
 *     *   `list queue`: Displays all patients currently in the waiting list in order.
 *     *   `list doctors`: Displays all doctors and whether they are currently assigned to a patient.
 *     *   `cancel <doctorName>`: Frees up the appointment slot for the specified doctor. The patient previously assigned to this doctor is removed from the doctor's assignment.
 *     *   `exit`: Terminates the program.
 * 
 * **Technical Requirements:**
 * 
 * Your solution MUST utilize ALL of the following Java components:
 * 
 * *   `java.util.Queue` for the patient waiting list.
 * *   `java.util.ArrayList` for storing the list of doctors.
 * *   `java.util.List` interface as the declared type for the list of doctors.
 * *   `java.util.Scanner` for reading user input from the console.
 * *   A `switch` statement for handling the different commands.
 * *   `System.err` for displaying error messages (e.g., invalid command, patient queue empty, doctor not found, doctor already available).
 * *   `System.out` for displaying normal output (prompts, success messages, list contents).
 * *   Class-wide exception handling using `try-catch` blocks to manage potential runtime issues during program execution (e.g., input issues, unexpected errors).
 * 
 * **Implementation Details:**
 * 
 * *   Create separate classes for `Patient` and `Doctor` with appropriate private fields and public getter/setter methods (encapsulation).
 * *   The `Doctor` class should have a field to represent the currently assigned `Patient` (or `null` if available).
 * *   The main logic should reside in a class with a `main` method.
 * *   Include input validation where necessary (e.g., checking if command format is correct, if a doctor exists).
 * *   Use meaningful variable and method names.
 * *   Add comments to explain complex parts of the code.
 * *   Pre-populate the system with a few doctors at the start.
 * 
 * **Expected Output Examples:**
 * 
 * ```
 * Enter command: add patient Alice
 * Patient Alice added to the waiting list.
 * 
 * Enter command: list queue
 * Waiting List:
 * 1. Alice
 * 
 * Enter command: add patient Bob
 * Patient Bob added to the waiting list.
 * 
 * Enter command: list queue
 * Waiting List:
 * 1. Alice
 * 2. Bob
 * 
 * Enter command: list doctors
 * Doctors:
 * - Dr. Smith: Available
 * - Dr. Jones: Available
 * 
 * Enter command: assign
 * Assigned Alice to Dr. Smith.
 * 
 * Enter command: list queue
 * Waiting List:
 * 2. Bob
 * 
 * Enter command: list doctors
 * Doctors:
 * - Dr. Smith: Assigned to Alice
 * - Dr. Jones: Available
 * 
 * Enter command: assign
 * Assigned Bob to Dr. Jones.
 * 
 * Enter command: assign
 * Error: No patients in the waiting list.
 * 
 * Enter command: list doctors
 * Doctors:
 * - Dr. Smith: Assigned to Alice
 * - Dr. Jones: Assigned to Bob
 * 
 * Enter command: cancel Dr. Smith
 * Dr. Smith is now available.
 * 
 * Enter command: list doctors
 * Doctors:
 * - Dr. Smith: Available
 * - Dr. Jones: Assigned to Bob
 * 
 * Enter command: cancel Dr. NonExistent
 * Error: Doctor 'Dr. NonExistent' not found.
 * 
 * Enter command: invalid command
 * Error: Unknown command or invalid format.
 * 
 * Enter command: exit
 * Exiting system.
 * ```
 * 
 * **Evaluation Criteria:**
 * 
 * *   Correct implementation of all required commands.
 * *   Proper use of `Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.err`, `System.out`.
 * *   Effective use of `try-catch` for exception handling.
 * *   Adherence to object-oriented principles (encapsulation).
 * *   Code readability, naming conventions, and comments.
 * *   Correct input validation and error handling.
 * 
 * **Constraint:** You must provide the complete, runnable Java code for this system.
 *
 * EXPLANATION:
 * This solution implements a simplified hospital appointment system demonstrating the required Java concepts.
 * 
 * 1.  **Class Structure:**
 *     *   `Patient` class: A simple class to hold patient data (`name`). Uses a private field and a public getter, demonstrating encapsulation.
 *     *   `Doctor` class: Holds the doctor's `name` and a reference to the `assignedPatient`. The `assignedPatient` field is `null` when the doctor is available. It includes methods for checking availability (`isAvailable`), assigning (`assignPatient`), and releasing (`releasePatient`), adhering to encapsulation.
 *     *   `HospitalSystem` class: Contains the main logic and the `main` method. It holds the core data structures (`waitingList`, `doctors`) and the `Scanner`.
 * 
 * 2.  **Required Component Usage:**
 *     *   `java.util.Queue`: The `waitingList` is declared as a `Queue<Patient>` and initialized with `new LinkedList<>()`. `LinkedList` is chosen as it implements the `Queue` interface and is suitable for FIFO operations (`offer` to add, `poll` to remove from the front).
 *     *   `java.util.ArrayList`: The `doctors` list is initialized with `new ArrayList<>()`. `ArrayList` is suitable for storing and iterating over a collection of doctors where indexed access or dynamic resizing is needed.
 *     *   `java.util.List interface`: The `doctors` variable is declared using the `List` interface type (`List<Doctor> doctors`), promoting good practice by programming to the interface rather than the specific implementation (`ArrayList`).
 *     *   `java.util.Scanner`: A `Scanner` object is used to read command lines from `System.in`. It's initialized once and used within the `run` method's loop.
 *     *   `switch statement`: The main command processing logic within the `run` method uses a `switch` statement to dispatch control based on the first word of the user's input command (`add`, `assign`, `list`, `cancel`, `exit`).
 *     *   `System.err`: Used specifically for printing error messages, such as invalid commands, missing arguments, queue empty conditions, or doctor not found errors. This separates error output from normal program output.
 *     *   `System.out`: Used for all normal program output, including prompts, success messages, and listing the contents of the queue or doctor assignments.
 *     *   Class-wide `try-catch`: The entire command processing loop within the `run` method is wrapped in a `try-catch` block. This demonstrates handling potential exceptions that might occur during the execution of the loop (e.g., unexpected errors during input reading or processing), preventing the program from crashing abruptly. A `finally` block ensures the `Scanner` is closed.
 * 
 * 3.  **Logic Implementation:**
 *     *   Commands are parsed by splitting the input line. Basic validation checks the number of parts for commands like `add patient` and `cancel`.
 *     *   `add patient`: Creates a `Patient` object and uses `waitingList.offer()` to add it to the queue.
 *     *   `assign`: Checks if the queue is empty (`waitingList.isEmpty()`) and if an available doctor exists (`findAvailableDoctor()`). If both conditions are met, it uses `waitingList.poll()` to remove the next patient and assigns them to the found doctor using the doctor's `assignPatient` method.
 *     *   `list queue`: Iterates through the `waitingList` (using a for-each loop, which iterates in queue order) and prints each patient's name.
 *     *   `list doctors`: Iterates through the `doctors` `List` and prints the `toString()` representation of each `Doctor` object, which indicates their assignment status.
 *     *   `cancel <doctorName>`: Finds the doctor by name (`findDoctorByName()`). If found, it checks if they are assigned (`!isAvailable()`) and, if so, calls `releasePatient()` to free up their slot. Error messages are printed if the doctor isn't found or is already available.
 *     *   `exit`: Sets a flag (`running = false`) to terminate the main loop.
 * 
 * 4.  **Best Practices:**
 *     *   **Encapsulation:** Private fields (`name`, `assignedPatient`) and public methods (`getName`, `isAvailable`, `assignPatient`, etc.) are used in `Patient` and `Doctor` classes.
 *     *   **Naming:** Variable and method names are descriptive (e.g., `waitingList`, `assignPatientToDoctor`, `findAvailableDoctor`).
 *     *   **Comments:** Comments explain the purpose of classes, methods, and specific code sections, especially where logic might be less obvious.
 *     *   **Input Validation:** Basic checks are performed on command format and arguments (e.g., checking if a doctor name is provided for `cancel`).
 *     *   **Error Handling:** `System.err` is used for errors, and the main loop is wrapped in `try-catch` to handle unexpected exceptions. Specific error messages are provided for different failure scenarios (queue empty, no doctors, doctor not found, etc.).
 *     *   **Clean Code Structure:** The code is organized into classes, and methods are used to break down the functionality (e.g., `addPatient`, `assignPatientToDoctor`, `listWaitingQueue`, `listDoctors`, `cancelAppointment`, `findAvailableDoctor`, `findDoctorByName`, `run`).
 * 
 * This solution effectively integrates all required components into a functional, albeit simplified, system while adhering to good programming practices and demonstrating error handling.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.InputMismatchException; // Although not strictly needed for string input, good practice to import

// Represents a patient
class Patient {
    private String name;

    public Patient(String name) {
        this.name = name;
    }

    public String getName() {
        return name;
    }

    @Override
    public String toString() {
        return name;
    }
}

// Represents a doctor with an appointment slot
class Doctor {
    private String name;
    private Patient assignedPatient; // null if available

    public Doctor(String name) {
        this.name = name;
        this.assignedPatient = null; // Initially available
    }

    public String getName() {
        return name;
    }

    public Patient getAssignedPatient() {
        return assignedPatient;
    }

    public boolean isAvailable() {
        return assignedPatient == null;
    }

    public void assignPatient(Patient patient) {
        if (patient != null) {
            this.assignedPatient = patient;
        } else {
            // Should not happen with current logic, but good practice
            System.err.println("Error: Cannot assign a null patient.");
        }
    }

    public void releasePatient() {
        this.assignedPatient = null;
    }

    @Override
    public String toString() {
        return "Dr. " + name + ": " + (isAvailable() ? "Available" : "Assigned to " + assignedPatient.getName());
    }
}

// Main class for the Hospital Appointment System
public class HospitalSystem {

    // Required components
    private Queue<Patient> waitingList;
    private List<Doctor> doctors; // Declared as List interface
    private Scanner scanner;

    public HospitalSystem() {
        // Initialize components
        waitingList = new LinkedList<>(); // LinkedList implements Queue
        doctors = new ArrayList<>();     // ArrayList implements List
        scanner = new Scanner(System.in);

        // Pre-populate doctors
        doctors.add(new Doctor("Smith"));
        doctors.add(new Doctor("Jones"));
        doctors.add(new Doctor("Brown"));
    }

    // --- Core System Logic Methods ---

    public void addPatient(String patientName) {
        if (patientName == null || patientName.trim().isEmpty()) {
            System.err.println("Error: Patient name cannot be empty.");
            return;
        }
        Patient newPatient = new Patient(patientName.trim());
        waitingList.offer(newPatient); // Add to the end of the queue
        System.out.println("Patient " + newPatient.getName() + " added to the waiting list.");
    }

    public void assignPatientToDoctor() {
        if (waitingList.isEmpty()) {
            System.err.println("Error: No patients in the waiting list.");
            return;
        }

        Doctor availableDoctor = findAvailableDoctor();

        if (availableDoctor == null) {
            System.err.println("Error: No doctors currently available.");
            return;
        }

        Patient patientToAssign = waitingList.poll(); // Get and remove patient from front of queue
        availableDoctor.assignPatient(patientToAssign);
        System.out.println("Assigned " + patientToAssign.getName() + " to Dr. " + availableDoctor.getName() + ".");
    }

    private Doctor findAvailableDoctor() {
        for (Doctor doctor : doctors) {
            if (doctor.isAvailable()) {
                return doctor;
            }
        }
        return null; // No available doctor found
    }

    public void listWaitingQueue() {
        if (waitingList.isEmpty()) {
            System.out.println("Waiting List: Empty");
            return;
        }
        System.out.println("Waiting List:");
        int i = 1;
        for (Patient patient : waitingList) {
            System.out.println(i++ + ". " + patient.getName());
        }
    }

    public void listDoctors() {
        System.out.println("Doctors:");
        if (doctors.isEmpty()) {
            System.out.println("  No doctors in the system.");
            return;
        }
        for (Doctor doctor : doctors) {
            System.out.println("- " + doctor.toString());
        }
    }

    public void cancelAppointment(String doctorName) {
        if (doctorName == null || doctorName.trim().isEmpty()) {
            System.err.println("Error: Doctor name cannot be empty for cancellation.");
            return;
        }
        Doctor targetDoctor = findDoctorByName(doctorName.trim());

        if (targetDoctor == null) {
            System.err.println("Error: Doctor '" + doctorName + "' not found.");
            return;
        }

        if (targetDoctor.isAvailable()) {
            System.err.println("Error: Dr. " + targetDoctor.getName() + " is already available.");
        } else {
            // Patient assignedPatient = targetDoctor.getAssignedPatient(); // Could retrieve if needed
            targetDoctor.releasePatient();
            System.out.println("Dr. " + targetDoctor.getName() + " is now available.");
        }
    }

    private Doctor findDoctorByName(String name) {
        for (Doctor doctor : doctors) {
            if (doctor.getName().equalsIgnoreCase(name)) {
                return doctor;
            }
        }
        return null; // Doctor not found
    }

    // --- Main Program Loop ---

    public void run() {
        boolean running = true;
        System.out.println("--- Hospital Appointment System ---");

        // Use try-catch block for class-wide exception handling
        try {
            while (running) {
                System.out.print("\nEnter command: ");
                String commandLine = scanner.nextLine().trim();

                // Basic command parsing
                String[] parts = commandLine.split(" ", 2); // Split into command and potential arguments
                String command = parts[0].toLowerCase();
                String argument = parts.length > 1 ? parts[1].trim() : "";

                // Use switch statement for command handling
                switch (command) {
                    case "add":
                        // Expecting "add patient <name>"
                        String[] addParts = commandLine.split(" ", 3); // Split into add, patient, name
                        if (addParts.length == 3 && addParts[1].equalsIgnoreCase("patient")) {
                            addPatient(addParts[2]);
                        } else {
                            System.err.println("Error: Invalid 'add' command format. Use 'add patient <name>'.");
                        }
                        break;
                    case "assign":
                        if (argument.isEmpty()) {
                           assignPatientToDoctor();
                        } else {
                           System.err.println("Error: 'assign' command takes no arguments.");
                        }
                        break;
                    case "list":
                        if (argument.equalsIgnoreCase("queue")) {
                            listWaitingQueue();
                        } else if (argument.equalsIgnoreCase("doctors")) {
                            listDoctors();
                        } else {
                            System.err.println("Error: Invalid 'list' command format. Use 'list queue' or 'list doctors'.");
                        }
                        break;
                    case "cancel":
                         if (!argument.isEmpty()) {
                            cancelAppointment(argument);
                         } else {
                            System.err.println("Error: 'cancel' command requires a doctor name. Use 'cancel <doctorName>'.");
                         }
                        break;
                    case "exit":
                        running = false;
                        System.out.println("Exiting system.");
                        break;
                    default:
                        System.err.println("Error: Unknown command or invalid format.");
                        System.err.println("Available commands: add patient <name>, assign, list queue, list doctors, cancel <doctorName>, exit");
                }
            }
        } catch (Exception e) {
            // Catch any unexpected exceptions during the main loop
            System.err.println("\nAn unexpected error occurred: " + e.getMessage());
            e.printStackTrace(System.err); // Print stack trace to error stream
        } finally {
            // Ensure scanner is closed
            if (scanner != null) {
                scanner.close();
            }
            System.out.println("System terminated.");
        }
    }

    public static void main(String[] args) {
        HospitalSystem system = new HospitalSystem();
        system.run();
    }
}
