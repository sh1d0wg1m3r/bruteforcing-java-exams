/*
 * Exam Question #857
 * Generated on: 2025-05-12 16:51:15
 * Generated by: Account 5
 * 
 * QUESTION:
 * **Digital Asset Processing System**
 * 
 * You are tasked with developing a command-line application to simulate a simplified digital asset processing workflow. The system should manage incoming digital assets (like images, videos, documents) that are queued for processing. Once processed, assets are moved to a completed list.
 * 
 * Your solution must demonstrate proficiency in core Java data structures, input/output, control flow, and exception handling.
 * 
 * **Requirements:**
 * 
 * 1.  **`DigitalAsset` Class:**
 *     *   Create a `public` class named `DigitalAsset`.
 *     *   It must have `private` fields: `id` (int), `name` (String), `type` (String), `sizeBytes` (long).
 *     *   Implement a constructor to initialize these fields.
 *     *   Provide `public` getter methods for all fields.
 *     *   Override the `toString()` method to provide a user-friendly representation of the asset (e.g., "Asset ID: [id], Name: [name], Type: [type], Size: [sizeBytes] bytes").
 * 
 * 2.  **`AssetProcessingSystem` Class:**
 *     *   Create a `public` class named `AssetProcessingSystem`.
 *     *   It must manage two collections:
 *         *   A `Queue<DigitalAsset>` to hold assets waiting for processing. Use `java.util.LinkedList` as the implementation.
 *         *   A `List<DigitalAsset>` to hold assets that have been processed. Use `java.util.ArrayList` as the implementation, but declare the variable using the `List` interface type (`List<DigitalAsset> processedAssets`).
 *     *   Use a `Scanner` (from `java.util.Scanner`) to read user input from the console.
 *     *   Implement the following functionalities accessible via a menu:
 *         *   **Add Asset:** Prompt the user for asset details (name, type, size in bytes). Validate that name and type are not empty, and size is a positive integer. Create a `DigitalAsset` object (assign a unique ID, e.g., using a simple counter) and add it to the processing queue.
 *         *   **Process Next Asset:** Take the next asset from the front of the processing queue and move it to the list of processed assets. If the queue is empty, report an error.
 *         *   **View Processing Queue:** Display the details of all assets currently in the processing queue, in order.
 *         *   **View Processed Assets:** Display the details of all assets that have been processed.
 *         *   **Exit:** Terminate the application.
 *     *   Use a `switch` statement to handle the user's menu selection.
 *     *   Use `System.out` for displaying the menu, prompts, success messages, and asset lists.
 *     *   Use `System.err` for displaying error messages (e.g., invalid input, empty queue on process attempt).
 *     *   Implement class-wide exception handling using `try-catch` blocks to catch potential runtime errors during the program's execution and print an informative message to `System.err` before exiting gracefully. Handle specific input parsing errors within the input reading logic.
 * 
 * **Constraints:**
 * 
 * *   You MUST use `java.util.Queue`, `java.util.ArrayList`, `java.util.List`, `java.util.Scanner`, `switch` statement, `System.err`, `System.out`, and `try-catch` blocks as specified.
 * *   Follow Java coding best practices: meaningful names, proper indentation, comments where necessary, encapsulation.
 * *   Ensure robust input validation and error handling.
 * 
 * **Expected Output:**
 * 
 * The program should present a menu, accept user input, perform the requested action, and display results or errors as described. Example interaction flow:
 * 
 * ```
 * --- Digital Asset Processing System ---
 * 1. Add Asset
 * 2. Process Next Asset
 * 3. View Processing Queue
 * 4. View Processed Assets
 * 5. Exit
 * Enter your choice: 1
 * Enter Asset Name: Image1.jpg
 * Enter Asset Type: Image
 * Enter Asset Size (bytes): 102400
 * Asset 'Image1.jpg' added to the queue.
 * 
 * --- Digital Asset Processing System ---
 * ... (menu repeats)
 * Enter your choice: 3
 * Processing Queue:
 * Asset ID: 1, Name: Image1.jpg, Type: Image, Size: 102400 bytes
 * 
 * --- Digital Asset Processing System ---
 * ... (menu repeats)
 * Enter your choice: 2
 * Processing asset 'Image1.jpg'... Processed successfully.
 * 
 * --- Digital Asset Processing System ---
 * ... (menu repeats)
 * Enter your choice: 3
 * Processing Queue is empty.
 * 
 * --- Digital Asset Processing System ---
 * ... (menu repeats)
 * Enter your choice: 4
 * Processed Assets:
 * Asset ID: 1, Name: Image1.jpg, Type: Image, Size: 102400 bytes
 * 
 * --- Digital Asset Processing System ---
 * ... (menu repeats)
 * Enter your choice: 2
 * Error: Processing queue is empty. Cannot process.
 * 
 * --- Digital Asset Processing System ---
 * ... (menu repeats)
 * Enter your choice: 5
 * Exiting system.
 * ```
 * 
 * Handle invalid numeric input gracefully (e.g., entering text for size).
 * 
 * ```
 * Enter Asset Size (bytes): abc
 * Error: Invalid size input. Please enter a positive integer.
 * Enter Asset Size (bytes): 5000
 * Asset 'Document.pdf' added to the queue.
 * ```
 * 
 * Handle invalid menu choice:
 * ```
 * Enter your choice: 9
 * Error: Invalid choice. Please enter a number between 1 and 5.
 * ```
 * 
 * Implement the solution in a single Java file with the `main` method.
 *
 * EXPLANATION:
 * The solution implements the `Digital Asset Processing System` as required, demonstrating the use of all specified Java components and adhering to best practices.
 * 
 * 1.  **`DigitalAsset` Class:** This class is a simple Plain Old Java Object (POJO) representing an asset. It follows encapsulation principles with `private` fields and `public` getter methods. The `toString()` method is overridden for convenient printing of asset details.
 * 
 * 2.  **`AssetProcessingSystem` Class:** This is the core class managing the system's logic.
 *     *   **Data Structures:** It correctly uses a `Queue<DigitalAsset>` (`LinkedList` implementation) for the waiting list, ensuring FIFO (First-In, First-Out) order, and a `List<DigitalAsset>` (`ArrayList` implementation, declared as `List`) for the processed items, allowing flexible access to completed tasks.
 *     *   **`Scanner`:** A `Scanner` object is initialized to read user input from `System.in`. Input reading includes handling potential `InputMismatchException` for numeric inputs (`choice`, `sizeBytes`) to prevent program crashes if the user enters non-numeric text. The `scanner.nextLine()` calls after reading numbers are crucial to consume the newline character left in the input buffer, preventing issues with subsequent `nextLine()` calls.
 *     *   **Menu and `switch`:** The `displayMenu()` method presents options, and the `run()` method contains a `while` loop that repeatedly displays the menu, reads the user's choice, and uses a `switch` statement to direct execution to the appropriate method (`addAsset`, `processNextAsset`, `viewQueue`, `viewProcessed`) or exit the loop. Invalid menu choices are caught in the `default` case of the `switch`.
 *     *   **Functionality Methods (`addAsset`, `processNextAsset`, `viewQueue`, `viewProcessed`):**
 *         *   `addAsset` prompts for details, performs basic validation (non-empty name/type, positive size), handles potential `InputMismatchException` for the size input, creates a `DigitalAsset` with a unique ID (simple counter `nextAssetId`), and adds it to the `processingQueue` using `offer()`.
 *         *   `processNextAsset` checks if the `processingQueue` is empty using `isEmpty()`. If not empty, it uses `poll()` to remove the head of the queue and adds it to the `processedAssets` list. If empty, it reports an error.
 *         *   `viewQueue` and `viewProcessed` iterate through their respective collections (queue and list) and print the details of each asset using the `toString()` method. They also handle the case where the collections are empty.
 *     *   **Input/Output:** `System.out` is used for all standard messages, menu display, prompts, and listing assets. `System.err` is specifically used for displaying error conditions, such as invalid user input, attempting to process an empty queue, or an invalid menu choice, as required.
 *     *   **Exception Handling:**
 *         *   **Specific Input Handling:** `try-catch (InputMismatchException)` blocks are used around `scanner.nextInt()` and `scanner.nextLong()` calls within the `run` and `addAsset` methods to catch non-numeric input errors gracefully, print an error to `System.err`, consume the invalid input, and allow the program to continue.
 *         *   **Class-wide Handling:** The main `while` loop in the `run()` method is wrapped in a `try-catch (Exception e)` block. This serves as the class-wide exception handler, catching any unexpected runtime errors that might occur during the program's execution. If such an error occurs, it prints a generic error message to `System.err` including the exception's message and then the `finally` block ensures the `Scanner` is closed before the program potentially terminates.
 * 
 * 3.  **`main` Method:** The standard entry point creates an instance of `AssetProcessingSystem` and calls its `run()` method to start the application loop.
 * 
 * This solution effectively utilizes all required components in a practical scenario, demonstrating proper data structure usage, flow control, input handling, and robust error management.
 */

import java.util.Queue;
import java.util.LinkedList;
import java.util.List;
import java.util.ArrayList;
import java.util.Scanner;
import java.util.InputMismatchException;

// Represents a digital asset
class DigitalAsset {
    private int id;
    private String name;
    private String type;
    private long sizeBytes;

    // Constructor
    public DigitalAsset(int id, String name, String type, long sizeBytes) {
        this.id = id;
        this.name = name;
        this.type = type;
        this.sizeBytes = sizeBytes;
    }

    // Getters
    public int getId() {
        return id;
    }

    public String getName() {
        return name;
    }

    public String getType() {
        return type;
    }

    public long getSizeBytes() {
        return sizeBytes;
    }

    // Override toString for easy printing
    @Override
    public String toString() {
        return "Asset ID: " + id + ", Name: " + name + ", Type: " + type + ", Size: " + sizeBytes + " bytes";
    }
}

// Manages the asset processing queue and processed list
public class AssetProcessingSystem {

    private Queue<DigitalAsset> processingQueue;
    private List<DigitalAsset> processedAssets;
    private Scanner scanner;
    private int nextAssetId; // Simple counter for unique IDs

    // Constructor
    public AssetProcessingSystem() {
        // Requirement: Use LinkedList for Queue
        this.processingQueue = new LinkedList<>();
        // Requirement: Use ArrayList for List, declared as List interface
        this.processedAssets = new ArrayList<>();
        // Requirement: Use Scanner for user input
        this.scanner = new Scanner(System.in);
        this.nextAssetId = 1;
    }

    // Displays the main menu
    private void displayMenu() {
        System.out.println("\n--- Digital Asset Processing System ---");
        System.out.println("1. Add Asset");
        System.out.println("2. Process Next Asset");
        System.out.println("3. View Processing Queue");
        System.out.println("4. View Processed Assets");
        System.out.println("5. Exit");
        System.out.print("Enter your choice: ");
    }

    // Handles adding a new asset to the queue
    private void addAsset() {
        System.out.print("Enter Asset Name: ");
        String name = scanner.nextLine().trim();
        if (name.isEmpty()) {
            System.err.println("Error: Asset Name cannot be empty.");
            return;
        }

        System.out.print("Enter Asset Type: ");
        String type = scanner.nextLine().trim();
        if (type.isEmpty()) {
            System.err.println("Error: Asset Type cannot be empty.");
            return;
        }

        long sizeBytes = -1;
        boolean validInput = false;
        while (!validInput) {
            System.out.print("Enter Asset Size (bytes): ");
            try {
                sizeBytes = scanner.nextLong();
                if (sizeBytes <= 0) {
                    System.err.println("Error: Asset Size must be a positive integer.");
                } else {
                    validInput = true;
                }
            } catch (InputMismatchException e) {
                System.err.println("Error: Invalid size input. Please enter a positive integer.");
                scanner.next(); // Consume the invalid input
            } finally {
                // Consume the rest of the line after reading the long/invalid input
                // Important to avoid issues with nextLine() after nextLong()
                if (scanner.hasNextLine()) {
                     scanner.nextLine();
                }
            }
        }

        DigitalAsset newAsset = new DigitalAsset(nextAssetId++, name, type, sizeBytes);
        processingQueue.offer(newAsset); // offer is generally preferred over add for queues
        System.out.println("Asset '" + name + "' added to the queue.");
    }

    // Handles processing the next asset from the queue
    private void processNextAsset() {
        if (processingQueue.isEmpty()) {
            // Requirement: Use System.err for error messages
            System.err.println("Error: Processing queue is empty. Cannot process.");
        } else {
            DigitalAsset assetToProcess = processingQueue.poll(); // Retrieves and removes the head of the queue
            processedAssets.add(assetToProcess);
            System.out.println("Processing asset '" + assetToProcess.getName() + "'... Processed successfully.");
        }
    }

    // Handles viewing the processing queue
    private void viewQueue() {
        System.out.println("\nProcessing Queue:");
        if (processingQueue.isEmpty()) {
            System.out.println("Processing Queue is empty.");
        } else {
            // Iterate through the queue without removing elements
            for (DigitalAsset asset : processingQueue) {
                // Requirement: Use System.out for normal output
                System.out.println(asset);
            }
        }
    }

    // Handles viewing the processed assets list
    private void viewProcessed() {
        System.out.println("\nProcessed Assets:");
        if (processedAssets.isEmpty()) {
            System.out.println("No assets have been processed yet.");
        } else {
            for (DigitalAsset asset : processedAssets) {
                // Requirement: Use System.out for normal output
                System.out.println(asset);
            }
        }
    }

    // Main method to run the system loop
    public void run() {
        boolean running = true;
        // Requirement: Class-wide exception handling with try-catch
        try {
            while (running) {
                displayMenu();
                int choice = -1;
                try {
                    // Read menu choice
                    choice = scanner.nextInt();
                } catch (InputMismatchException e) {
                    // Requirement: Use System.err for error messages
                    System.err.println("Error: Invalid input. Please enter a number.");
                    scanner.next(); // Consume the invalid input
                    continue; // Skip the rest of the loop and show menu again
                } finally {
                     // Consume the rest of the line after reading the int/invalid input
                     if (scanner.hasNextLine()) {
                         scanner.nextLine();
                     }
                }


                // Requirement: Use switch statement for flow control
                switch (choice) {
                    case 1:
                        addAsset();
                        break;
                    case 2:
                        processNextAsset();
                        break;
                    case 3:
                        viewQueue();
                        break;
                    case 4:
                        viewProcessed();
                        break;
                    case 5:
                        System.out.println("Exiting system.");
                        running = false;
                        break;
                    default:
                        // Requirement: Use System.err for error messages
                        System.err.println("Error: Invalid choice. Please enter a number between 1 and 5.");
                }
            }
        } catch (Exception e) {
            // Catch any unexpected exceptions during the main loop
            System.err.println("\nAn unexpected error occurred: " + e.getMessage());
            // e.printStackTrace(); // Uncomment for debugging if needed
        } finally {
            // Close the scanner when the application exits
            if (scanner != null) {
                scanner.close();
            }
        }
    }

    // Entry point of the application
    public static void main(String[] args) {
        AssetProcessingSystem system = new AssetProcessingSystem();
        system.run();
    }
}
