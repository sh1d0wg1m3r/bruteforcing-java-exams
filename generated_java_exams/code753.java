/*
 * Exam Question #753
 * Generated on: 2025-05-12 16:35:50
 * Generated by: Account 4
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Simple Task Processor System
 * 
 * **Objective:** Design and implement a simple console-based Task Processor System that manages pending and completed tasks. The system should allow users to add new tasks, process the next pending task in order, and view lists of pending and completed tasks.
 * 
 * **Scenario:** You are building a basic system for managing small, sequential tasks in an office. New tasks are added to a queue, and the system processes them one by one from the front of the queue. Once a task is processed, it is moved to a list of completed tasks.
 * 
 * **Requirements:**
 * 
 * 1.  **Task Representation:** Create a class `Task` with the following attributes:
 *     *   `taskId` (int): A unique identifier for the task.
 *     *   `description` (String): A brief description of the task.
 *     *   `status` (String): Represents the current status ("Pending", "Completed"). Initialize to "Pending".
 *     *   Include appropriate constructor, getters, and a method to update the status. Implement a `toString()` method for easy printing.
 * 
 * 2.  **Task Processor System:** Create a class `TaskProcessorSystem` that manages the tasks.
 *     *   It must internally use a `java.util.Queue<Task>` to hold tasks that are pending. Use a concrete implementation like `java.util.LinkedList`.
 *     *   It must internally use a `java.util.List<Task>` (declared as `List`, implemented with `java.util.ArrayList`) to hold tasks that have been completed.
 *     *   Implement the following public methods:
 *         *   `addTask(String description)`: Creates a new `Task` with a unique ID and the given description, adds it to the pending queue.
 *         *   `processNextTask()`: Removes the next task from the pending queue, updates its status to "Completed", and adds it to the completed tasks list. If the queue is empty, it should handle this gracefully (e.g., print a message).
 *         *   `getPendingTasks()`: Returns the `Queue` of pending tasks (consider returning a copy or an unmodifiable view to prevent external modification, or just the internal reference for simplicity in this exam context).
 *         *   `getCompletedTasks()`: Returns the `List` of completed tasks.
 * 
 * 3.  **User Interface:** Create a `Main` class with a `main` method to interact with the `TaskProcessorSystem`.
 *     *   Use `java.util.Scanner` to get user input from the console.
 *     *   Present a menu of options to the user:
 *         1.  Add New Task
 *         2.  Process Next Task
 *         3.  View Pending Tasks
 *         4.  View Completed Tasks
 *         5.  Exit
 *     *   Use a `switch` statement to handle the user's menu choice.
 *     *   Implement a loop that continues until the user chooses to exit.
 * 
 * 4.  **Error Handling:**
 *     *   Use `try-catch` blocks in the `main` method to handle potential exceptions, particularly `java.util.InputMismatchException` if the user enters non-integer input for the menu choice.
 *     *   Display informative error messages using `System.err`.
 *     *   Handle the case where the user tries to process a task when the pending queue is empty, printing a message to `System.out`.
 * 
 * 5.  **Input Validation:** Ensure that the task description is not empty when adding a new task.
 * 
 * 6.  **Output:**
 *     *   Use `System.out` for displaying the menu, prompts, and lists of tasks.
 *     *   Use `System.err` for displaying error messages.
 * 
 * 7.  **Best Practices:** Adhere to Java best practices including encapsulation (private fields, public methods), meaningful variable and method names, and basic comments where necessary.
 * 
 * **Expected Output:**
 * 
 * The program should run interactively. Example interaction might look like this:
 * 
 * ```
 * Task Processor Menu:
 * 1. Add New Task
 * 2. Process Next Task
 * 3. View Pending Tasks
 * 4. View Completed Tasks
 * 5. Exit
 * Enter your choice: 1
 * Enter task description: Write report
 * Task added: Task{id=1, description='Write report', status='Pending'}
 * 
 * Task Processor Menu:
 * 1. Add New Task
 * 2. Process Next Task
 * 3. View Pending Tasks
 * 4. View Completed Tasks
 * 5. Exit
 * Enter your choice: 1
 * Enter task description: Send email
 * Task added: Task{id=2, description='Send email', status='Pending'}
 * 
 * Task Processor Menu:
 * 1. Add New Task
 * 2. Process Next Task
 * 3. View Pending Tasks
 * 4. View Completed Tasks
 * 5. Exit
 * Enter your choice: 3
 * --- Pending Tasks ---
 * Task{id=1, description='Write report', status='Pending'}
 * Task{id=2, description='Send email', status='Pending'}
 * ---------------------
 * 
 * Task Processor Menu:
 * 1. Add New Task
 * 2. Process Next Task
 * 3. View Pending Tasks
 * 4. View Completed Tasks
 * 5. Exit
 * Enter your choice: 2
 * Processing task: Task{id=1, description='Write report', status='Pending'}
 * Task completed: Task{id=1, description='Write report', status='Completed'}
 * 
 * Task Processor Menu:
 * 1. Add New Task
 * 2. Process Next Task
 * 3. View Pending Tasks
 * 4. View Completed Tasks
 * 5. Exit
 * Enter your choice: 4
 * --- Completed Tasks ---
 * Task{id=1, description='Write report', status='Completed'}
 * -----------------------
 * 
 * Task Processor Menu:
 * 1. Add New Task
 * 2. Process Next Task
 * 3. View Pending Tasks
 * 4. View Completed Tasks
 * 5. Exit
 * Enter your choice: 6
 * System.err> Invalid choice. Please enter a number between 1 and 5.
 * 
 * Task Processor Menu:
 * 1. Add New Task
 * 2. Process Next Task
 * 3. View Pending Tasks
 * 4. View Completed Tasks
 * 5. Exit
 * Enter your choice: abc
 * System.err> Invalid input. Please enter a number.
 * 
 * Task Processor Menu:
 * 1. Add New Task
 * 2. Process Next Task
 * 3. View Pending Tasks
 * 4. View Completed Tasks
 * 5. Exit
 * Enter your choice: 5
 * Exiting Task Processor System. Goodbye!
 * ```
 * 
 * **Evaluation:** Your solution will be evaluated on correctness, adherence to requirements (especially using all specified components), code quality, error handling robustness, and clarity.
 *
 * EXPLANATION:
 * This solution implements the Simple Task Processor System as required, demonstrating the usage of all specified Java components and adhering to best practices.
 * 
 * 1.  **`Task` Class:** This class encapsulates the data for a single task (`taskId`, `description`, `status`). It provides a constructor, getters for accessing data, a setter for updating the status, and an overridden `toString()` method for convenient display. This demonstrates proper encapsulation.
 * 
 * 2.  **`TaskProcessorSystem` Class:**
 *     *   It uses a `java.util.Queue<Task>` (`pendingTasks`), specifically a `LinkedList` implementation, to manage tasks waiting to be processed. The `Queue` interface ensures FIFO (First-In, First-Out) behavior, which is suitable for processing tasks in the order they were added. `offer()` is used to add tasks, and `poll()` is used to retrieve and remove the next task.
 *     *   It uses a `java.util.List<Task>` (`completedTasks`), specifically an `ArrayList` implementation, to store tasks after they have been processed. The `List` interface provides ordered storage and allows easy iteration over completed tasks. `add()` is used to append completed tasks.
 *     *   `nextTaskId` is a simple counter to ensure unique IDs for tasks.
 *     *   Methods like `addTask`, `processNextTask`, `getPendingTasks`, and `getCompletedTasks` provide the core functionality, abstracting the underlying data structures.
 * 
 * 3.  **`SimpleTaskProcessor` (Main Class):**
 *     *   The `main` method drives the application.
 *     *   A `java.util.Scanner` is used to read input from the console (`System.in`).
 *     *   A `while` loop keeps the application running until the user chooses to exit.
 *     *   A `try-catch` block wraps the core interaction loop. This provides class-wide exception handling. It specifically catches `InputMismatchException` for invalid integer input and a general `Exception` for any other unforeseen errors.
 *     *   Inside the `try` block, the menu is printed, user input is read, and a `switch` statement is used to dispatch actions based on the user's choice (1-5).
 *     *   Each case in the `switch` calls the appropriate method on the `TaskProcessorSystem` instance.
 *     *   Input validation is performed in `addTask` to check for empty descriptions.
 *     *   Output for success messages and task lists is directed to `System.out`.
 *     *   Error messages (invalid menu choice, invalid input type, other exceptions) are directed to `System.err`.
 *     *   The `scanner.nextLine()` call after `scanner.nextInt()` is crucial to consume the leftover newline character, preventing issues with subsequent `scanner.nextLine()` calls.
 *     *   The scanner is closed at the end.
 * 
 * **Key Concepts Demonstrated:**
 * 
 * *   **Object-Oriented Programming:** Usage of classes (`Task`, `TaskProcessorSystem`, `SimpleTaskProcessor`) with encapsulation.
 * *   **Data Structures:** Practical application of `Queue` (FIFO) and `List` (ordered collection) interfaces and their common implementations (`LinkedList`, `ArrayList`).
 * *   **Polymorphism/Interfaces:** Using `Queue` and `List` interfaces for variable declarations promotes flexibility.
 * *   **User Input:** Reading user input using `Scanner`.
 * *   **Control Flow:** Using `while` loop and `switch` statement for program flow.
 * *   **Exception Handling:** Implementing `try-catch` blocks for robust error management, differentiating between specific input errors (`InputMismatchException`) and general errors. Using `System.err` for error reporting.
 * *   **Basic I/O:** Using `System.out` for standard output and `System.err` for error output.
 * *   **Best Practices:** Naming conventions, basic comments, input validation, clear code structure.
 * 
 * This solution effectively integrates the required components into a functional, albeit simple, application, demonstrating a solid understanding of core and intermediate Java concepts suitable for an exam setting.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.InputMismatchException;

// Represents a single task in the system
class Task {
    private int taskId;
    private String description;
    private String status; // e.g., "Pending", "Completed"

    // Constructor
    public Task(int taskId, String description) {
        this.taskId = taskId;
        this.description = description;
        this.status = "Pending"; // Default status
    }

    // Getters
    public int getTaskId() {
        return taskId;
    }

    public String getDescription() {
        return description;
    }

    public String getStatus() {
        return status;
    }

    // Method to update status
    public void setStatus(String status) {
        this.status = status;
    }

    // String representation for easy printing
    @Override
    public String toString() {
        return "Task{id=" + taskId + ", description='" + description + "', status='" + status + "'}";
    }
}

// Manages the collection of pending and completed tasks
class TaskProcessorSystem {
    // Queue for tasks waiting to be processed (FIFO)
    private Queue<Task> pendingTasks;
    // List for tasks that have been completed
    private List<Task> completedTasks;
    // Counter for generating unique task IDs
    private int nextTaskId;

    // Constructor
    public TaskProcessorSystem() {
        // Use LinkedList as a concrete implementation of Queue
        this.pendingTasks = new LinkedList<>();
        // Use ArrayList as a concrete implementation of List
        this.completedTasks = new ArrayList<>();
        this.nextTaskId = 1; // Start task IDs from 1
    }

    /**
     * Adds a new task to the pending queue.
     * @param description The description of the task.
     * @return The newly created task, or null if description is invalid.
     */
    public Task addTask(String description) {
        if (description == null || description.trim().isEmpty()) {
            System.err.println("Error: Task description cannot be empty.");
            return null;
        }
        Task newTask = new Task(nextTaskId++, description.trim());
        pendingTasks.offer(newTask); // Add task to the end of the queue
        return newTask;
    }

    /**
     * Processes the next task in the pending queue.
     * Removes the task, updates its status, and moves it to the completed list.
     */
    public void processNextTask() {
        if (pendingTasks.isEmpty()) {
            System.out.println("No pending tasks to process.");
            return;
        }

        Task taskToProcess = pendingTasks.poll(); // Get and remove the task from the front
        System.out.println("Processing task: " + taskToProcess);

        taskToProcess.setStatus("Completed"); // Update status
        completedTasks.add(taskToProcess); // Add to the completed list

        System.out.println("Task completed: " + taskToProcess);
    }

    /**
     * Returns the queue of pending tasks.
     * @return The Queue of pending tasks.
     */
    public Queue<Task> getPendingTasks() {
        // In a real-world scenario, might return an unmodifiable view
        // For this exam, returning the direct reference is acceptable
        return pendingTasks;
    }

    /**
     * Returns the list of completed tasks.
     * @return The List of completed tasks.
     */
    public List<Task> getCompletedTasks() {
         // In a real-world scenario, might return an unmodifiable view
        // For this exam, returning the direct reference is acceptable
        return completedTasks;
    }
}

// Main class for user interaction and system execution
public class SimpleTaskProcessor {

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        TaskProcessorSystem system = new TaskProcessorSystem();
        boolean running = true;

        // Class-wide exception handling loop
        while (running) {
            try {
                printMenu();
                System.out.print("Enter your choice: ");

                int choice = scanner.nextInt();
                // Consume the newline character left by nextInt()
                scanner.nextLine();

                // Use a switch statement to handle menu options
                switch (choice) {
                    case 1:
                        System.out.print("Enter task description: ");
                        String description = scanner.nextLine();
                        Task addedTask = system.addTask(description);
                        if (addedTask != null) {
                             System.out.println("Task added: " + addedTask);
                        }
                        break;
                    case 2:
                        system.processNextTask();
                        break;
                    case 3:
                        System.out.println("--- Pending Tasks ---");
                        Queue<Task> pending = system.getPendingTasks();
                        if (pending.isEmpty()) {
                            System.out.println("No pending tasks.");
                        } else {
                            // Iterate through the queue without removing elements
                            for (Task task : pending) {
                                System.out.println(task);
                            }
                        }
                        System.out.println("---------------------");
                        break;
                    case 4:
                        System.out.println("--- Completed Tasks ---");
                        List<Task> completed = system.getCompletedTasks();
                        if (completed.isEmpty()) {
                             System.out.println("No completed tasks.");
                        } else {
                            // Iterate through the list
                            for (Task task : completed) {
                                System.out.println(task);
                            }
                        }
                        System.out.println("-----------------------");
                        break;
                    case 5:
                        running = false;
                        System.out.println("Exiting Task Processor System. Goodbye!");
                        break;
                    default:
                        // Handle invalid integer choices
                        System.err.println("Invalid choice. Please enter a number between 1 and 5.");
                        break;
                }
            } catch (InputMismatchException e) {
                // Handle non-integer input for the menu choice
                System.err.println("Invalid input. Please enter a number.");
                scanner.nextLine(); // Consume the invalid input to prevent infinite loop
            } catch (Exception e) {
                // Catch any other unexpected exceptions
                System.err.println("An unexpected error occurred: " + e.getMessage());
                e.printStackTrace(System.err); // Print stack trace to System.err
            }
            System.out.println(); // Add a blank line for readability
        }

        scanner.close(); // Close the scanner when done
    }

    // Helper method to print the menu
    private static void printMenu() {
        System.out.println("Task Processor Menu:");
        System.out.println("1. Add New Task");
        System.out.println("2. Process Next Task");
        System.out.println("3. View Pending Tasks");
        System.out.println("4. View Completed Tasks");
        System.out.println("5. Exit");
    }
}
