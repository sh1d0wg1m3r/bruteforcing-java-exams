/*
 * Exam Question #572
 * Generated on: 2025-05-11 23:30:59
 * Generated by: Account 3
 * 
 * QUESTION:
 * **Complex Java Programming Exam Task: Cafe Order Management System**
 * 
 * **Problem Description:**
 * 
 * You are tasked with developing a simple command-line application for a small cafe to manage customer orders. The system should allow staff to:
 * 
 * 1.  Place new orders by selecting items from a fixed menu.
 * 2.  Process the next pending order, simulating the kitchen completing it.
 * 3.  View all orders currently waiting in the queue.
 * 4.  View the cafe's menu.
 * 5.  Exit the application.
 * 
 * The system must handle user input, manage a queue of orders, maintain a list of menu items, and implement robust error handling.
 * 
 * **Requirements:**
 * 
 * Your solution must be a single Java program (`.java` file) that demonstrates the following:
 * 
 * 1.  **Data Structures:**
 *     *   Use `java.util.Queue` to manage the pending customer orders (First-In, First-Out).
 *     *   Use `java.util.ArrayList` to store the cafe's menu items.
 *     *   Utilize the `java.util.List` interface when appropriate (e.g., declaring variables, method parameters/return types where a List is expected).
 * 2.  **Input/Output:**
 *     *   Use `java.util.Scanner` to read user input from the console.
 *     *   Use `System.out` for all normal output (menus, prompts, order details, queue status, success messages).
 *     *   Use `System.err` specifically for displaying error messages (e.g., invalid input, operational errors).
 * 3.  **Control Flow:**
 *     *   Use a `switch` statement to handle the main menu selection.
 * 4.  **Error Handling:**
 *     *   Implement input validation to handle cases like non-integer input or invalid menu item IDs.
 *     *   Implement class-wide exception handling using `try-catch` blocks to gracefully handle unexpected runtime errors during the application's execution. Specific error conditions (like processing an empty queue) should also be handled appropriately.
 * 5.  **Object-Oriented Design & Best Practices:**
 *     *   Create separate classes to represent `MenuItem` and `Order`.
 *     *   Implement proper encapsulation (private fields, public getter methods where necessary).
 *     *   Use meaningful variable and method names.
 *     *   Include appropriate comments and documentation (Javadocs or inline comments) explaining the code.
 *     *   Structure the code cleanly with logical methods.
 * 
 * **Implementation Details:**
 * 
 * *   **MenuItem Class:** Should have fields for item ID (int), name (String), and price (double). Include a constructor and getter methods. Override `toString()` for easy printing.
 * *   **Order Class:** Should have fields for a unique order ID (consider using a static counter), a list of `MenuItem` objects in the order (`List<MenuItem>`), and a status (e.g., "Pending", "Completed"). Include methods to add items, calculate the total price, and update status. Override `toString()` for easy printing of order details.
 * *   **CafeOrderSystem Class:** This will be the main class containing the `main` method. It should manage the `Queue` of orders and the `List` of menu items. Implement methods corresponding to the menu options (place order, process order, view queue, view menu). The main application loop with the `switch` statement and `try-catch` handling should reside here.
 * 
 * **Example Flow:**
 * 
 * 1.  System starts, displays main menu.
 * 2.  User selects "View Menu". System displays menu items.
 * 3.  User selects "Place New Order". System displays menu again, prompts for item IDs. User enters IDs (one by one) and finally 0 to finish. If input is invalid, `System.err` is used. Order is created and added to the queue. `System.out` confirms.
 * 4.  User selects "View Pending Order Queue". System iterates through the queue (without removing) and prints details of pending orders to `System.out`.
 * 5.  User selects "Process Next Order". If queue is not empty, the head order is removed, its status updated (conceptually), and its details printed to `System.out`. If queue is empty, `System.out` indicates this.
 * 6.  User selects "Exit". System exits.
 * 7.  If the user enters non-numeric input for a menu choice or item ID, `System.err` prints an error, and the system prompts again.
 * 8.  If an unexpected error occurs (e.g., a null pointer in an unhandled situation), the class-wide `try-catch` should print an error message to `System.err` and potentially the stack trace before the program terminates or recovers.
 * 
 * **Expected Output:**
 * 
 * The output should be interactive, displaying menus, prompts, and results of operations clearly using `System.out`. Error conditions should be reported using `System.err`.
 *
 * EXPLANATION:
 * The provided solution implements a simple Cafe Order Management System demonstrating the required Java concepts and best practices.
 * 
 * **Key Concepts Demonstrated:**
 * 
 * 1.  **`java.util.Queue`:** The `orderQueue` variable is declared as `Queue<Order>` and instantiated using `LinkedList`. This correctly models the FIFO (First-In, First-Out) nature of processing orders. `offer()` is used to add orders to the tail, and `poll()` is used to remove orders from the head. Iteration over the queue in `viewOrderQueue()` shows the elements without removing them.
 * 2.  **`java.util.ArrayList`:** The `menu` variable in `CafeOrderSystem` and the `items` variable within the `Order` class are instantiated as `ArrayList`. This is suitable for storing collections where elements are added sequentially during initialization/order creation and accessed by index or iterated over.
 * 3.  **`java.util.List` interface:** The `menu` variable is declared using the `List` interface (`List<MenuItem> menu;`), promoting flexibility. Similarly, the `items` field in `Order` is declared as `List<MenuItem> items;`, and the `getItems()` method returns `List<MenuItem>`. This adheres to the principle of programming to interfaces.
 * 4.  **`java.util.Scanner`:** A `Scanner` object is used throughout the `runSystem` and `placeOrder` methods to read integer input for menu choices and item IDs from `System.in`. `scanner.nextLine()` is used after reading integers to consume the leftover newline character, preventing input issues in subsequent reads.
 * 5.  **`switch` statement:** The main application loop in `runSystem` uses a `switch` statement based on the user's integer choice to direct the program flow to the appropriate method (`placeOrder`, `processNextOrder`, etc.).
 * 6.  **`System.err`:** `System.err.println()` is used specifically for displaying error messages to the user, such as when invalid input (non-numeric or out-of-range choice/item ID) is detected. This distinguishes error output from normal application output.
 * 7.  **`System.out`:** `System.out.println()` is used for all standard output, including displaying the menu, prompts, confirmation messages, order details, and the contents of the order queue.
 * 8.  **Class-wide `try-catch`:** A `try-catch(Exception e)` block is wrapped around the main `while` loop in the `runSystem` method. This serves as a top-level exception handler, catching any unhandled runtime exceptions that might occur within the system's operations. It prints a generic error message and the stack trace to `System.err` before the `finally` block ensures resources (the scanner) are closed. A more specific `try-catch(InputMismatchException e)` is used around input reading within the loop to handle common input errors gracefully without stopping the entire system loop.
 * 9.  **Object-Oriented Design & Best Practices:**
 *     *   **Encapsulation:** The `MenuItem` and `Order` classes have private fields (`id`, `name`, `price`, `orderId`, `items`, `status`) and provide public getter methods where necessary (`getId`, `getName`, `getPrice`, `getOrderId`, `getItems`, `getStatus`).
 *     *   **Meaningful Names:** Variables (`orderQueue`, `currentOrder`, `selectedItem`), methods (`placeOrder`, `processNextOrder`, `viewOrderQueue`, `runSystem`), and classes (`MenuItem`, `Order`, `CafeOrderSystem`) have names that clearly indicate their purpose.
 *     *   **Comments:** Inline comments and Javadoc-style comments explain the purpose of classes, methods, fields, and key logic sections.
 *     *   **Input Validation:** The code checks if entered item IDs exist in the menu and handles `InputMismatchException` if the user enters non-integer input, printing errors to `System.err`.
 *     *   **Error Handling:** Specific checks like `orderQueue.isEmpty()` prevent attempting operations on an empty queue. The `try-catch` blocks handle potential exceptions during input parsing and any unexpected runtime errors.
 *     *   **Clean Structure:** The code is organized into logical classes and methods, making it modular and easier to understand. The main application logic is contained within the `runSystem` method, called from `main`.
 * 
 * This solution effectively combines the required Java components in a practical scenario, demonstrating advanced understanding of data structures, control flow, input/output, and error handling within an object-oriented structure.
 */

import java.util.ArrayList;
import java.util.LinkedList; // LinkedList implements Queue
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.InputMismatchException; // Specific exception for input

// --- MenuItem Class ---
/**
 * Represents an item available on the cafe menu.
 */
class MenuItem {
    private int id;
    private String name;
    private double price;

    /**
     * Constructs a new MenuItem.
     * @param id The unique identifier for the menu item.
     * @param name The name of the menu item.
     * @param price The price of the menu item.
     */
    public MenuItem(int id, String name, double price) {
        this.id = id;
        this.name = name;
        this.price = price;
    }

    // --- Getters ---
    public int getId() {
        return id;
    }

    public String getName() {
        return name;
    }

    public double getPrice() {
        return price;
    }

    /**
     * Returns a string representation of the menu item.
     */
    @Override
    public String toString() {
        return id + ". " + name + " - $" + String.format("%.2f", price);
    }
}

// --- Order Class ---
/**
 * Represents a customer order containing multiple menu items.
 */
class Order {
    private static int nextOrderId = 1; // Static counter for unique order IDs
    private int orderId;
    private List<MenuItem> items; // Using List interface for items in the order
    private String status; // e.g., "Pending", "Completed"

    /**
     * Constructs a new Order with a unique ID and initial status "Pending".
     */
    public Order() {
        this.orderId = nextOrderId++;
        this.items = new ArrayList<>(); // Use ArrayList implementation for the list of items
        this.status = "Pending";
    }

    // --- Getters ---
    public int getOrderId() {
        return orderId;
    }

    public List<MenuItem> getItems() {
        return items; // Return as List interface
    }

    public String getStatus() {
        return status;
    }

    /**
     * Adds a MenuItem to this order.
     * @param item The item to add.
     */
    public void addItem(MenuItem item) {
        this.items.add(item);
    }

    /**
     * Sets the status of the order.
     * @param status The new status.
     */
    public void setStatus(String status) {
        this.status = status;
    }

    /**
     * Calculates the total price of the order.
     * @return The total price.
     */
    public double getTotal() {
        double total = 0;
        for (MenuItem item : items) {
            total += item.getPrice();
        }
        return total;
    }

    /**
     * Returns a detailed string representation of the order.
     */
    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        sb.append("Order #").append(orderId).append(" [").append(status).append("]\n");
        if (items.isEmpty()) {
            sb.append("  (No items)");
        } else {
            for (MenuItem item : items) {
                sb.append("  - ").append(item.getName()).append(" ($").append(String.format("%.2f", item.getPrice())).append(")\n");
            }
        }
        sb.append("  Total: $").append(String.format("%.2f", getTotal()));
        return sb.toString();
    }
}

// --- CafeOrderSystem Class ---
/**
 * Main class for the Cafe Order Management System.
 * Manages the menu, order queue, and user interaction.
 */
public class CafeOrderSystem {

    // Using List interface for menu, implemented by ArrayList
    private List<MenuItem> menu;
    // Using Queue interface for orders, implemented by LinkedList for FIFO
    private Queue<Order> orderQueue;
    private Scanner scanner;

    /**
     * Constructs the CafeOrderSystem, initializes menu, queue, and scanner.
     */
    public CafeOrderSystem() {
        menu = new ArrayList<>(); // ArrayList implementation for menu
        orderQueue = new LinkedList<>(); // LinkedList implementation for Queue
        scanner = new Scanner(System.in);
        initializeMenu();
    }

    /**
     * Initializes the cafe menu with some default items.
     */
    private void initializeMenu() {
        menu.add(new MenuItem(1, "Coffee", 2.50));
        menu.add(new MenuItem(2, "Tea", 2.00));
        menu.add(new MenuItem(3, "Pastry", 3.50));
        menu.add(new MenuItem(4, "Sandwich", 5.00));
        System.out.println("Cafe menu initialized.");
    }

    /**
     * Displays the current menu to System.out.
     */
    private void displayMenu() {
        System.out.println("\n--- Cafe Menu ---");
        if (menu.isEmpty()) {
            System.out.println("Menu is currently empty.");
        } else {
            for (MenuItem item : menu) {
                System.out.println(item); // Uses MenuItem's toString()
            }
        }
        System.out.println("-----------------");
    }

    /**
     * Allows a customer to place an order by selecting items from the menu.
     * Adds the completed order to the order queue.
     */
    private void placeOrder() {
        Order currentOrder = new Order();
        System.out.println("\n--- Place New Order (Order #" + currentOrder.getOrderId() + ") ---");
        displayMenu();

        boolean addingItems = true;
        while (addingItems) {
            System.out.print("Enter item ID to add (or 0 to finish order): ");
            try {
                int itemId = scanner.nextInt();
                scanner.nextLine(); // Consume newline character after reading int

                if (itemId == 0) {
                    addingItems = false;
                    continue; // Exit item adding loop
                }

                // Find the menu item by ID
                MenuItem selectedItem = null;
                for (MenuItem item : menu) {
                    if (item.getId() == itemId) {
                        selectedItem = item;
                        break;
                    }
                }

                if (selectedItem != null) {
                    currentOrder.addItem(selectedItem);
                    System.out.println("--> Added: " + selectedItem.getName());
                } else {
                    System.err.println("Error: Invalid item ID. Please enter a number from the menu.");
                }

            } catch (InputMismatchException e) {
                System.err.println("Error: Invalid input. Please enter a number.");
                scanner.nextLine(); // Consume the invalid input to prevent infinite loop
            }
        }

        // Add order to queue only if items were added
        if (currentOrder.getItems().isEmpty()) {
            System.out.println("Order cancelled as no items were added.");
        } else {
            orderQueue.offer(currentOrder); // Add order to the end of the queue
            System.out.println("\nOrder #" + currentOrder.getOrderId() + " placed successfully!");
            System.out.println(currentOrder); // Display the placed order details
        }
    }

    /**
     * Processes the next order from the front of the queue.
     * Simulates the kitchen completing the order.
     */
    private void processNextOrder() {
        System.out.println("\n--- Process Next Order ---");
        // Check if the queue is empty before attempting to poll
        if (orderQueue.isEmpty()) {
            System.out.println("No pending orders in the queue to process.");
        } else {
            // Retrieve and remove the head of the queue
            Order processedOrder = orderQueue.poll();
            if (processedOrder != null) { // poll returns null if empty, redundant check but good practice
                 processedOrder.setStatus("Completed"); // Update status
                 System.out.println("Processing and completing order #" + processedOrder.getOrderId() + ":");
                 System.out.println(processedOrder);
                 System.out.println("Order #" + processedOrder.getOrderId() + " completed.");
            }
        }
    }

    /**
     * Views all pending orders in the queue without removing them.
     */
    private void viewOrderQueue() {
        System.out.println("\n--- Pending Order Queue ---");
        if (orderQueue.isEmpty()) {
            System.out.println("The order queue is empty.");
        } else {
            // Iterate through the queue using an enhanced for loop (does not remove elements)
            int position = 1;
            for (Order order : orderQueue) {
                System.out.println("--- Position " + position + " ---");
                System.out.println(order); // Uses Order's toString()
                position++;
            }
        }
        System.out.println("---------------------------");
    }

    /**
     * Runs the main application loop, handling user interaction.
     * Includes the main switch statement and class-wide try-catch.
     */
    public void runSystem() {
        int choice = -1;

        // Class-wide try-catch block wrapping the main operational loop
        // This catches any unexpected runtime exceptions that might occur
        // within the system's operation and haven't been handled locally.
        try {
            while (choice != 0) {
                System.out.println("\n--- Cafe Order System Menu ---");
                System.out.println("1. Place New Order");
                System.out.println("2. Process Next Order");
                System.out.println("3. View Pending Order Queue");
                System.out.println("4. View Menu");
                System.out.println("0. Exit");
                System.out.print("Enter your choice: ");

                // Inner try-catch specifically for handling input reading errors
                try {
                    choice = scanner.nextInt();
                    scanner.nextLine(); // Consume the rest of the line (newline)

                    // Switch statement for main menu navigation
                    switch (choice) {
                        case 1:
                            placeOrder();
                            break;
                        case 2:
                            processNextOrder();
                            break;
                        case 3:
                            viewOrderQueue();
                            break;
                        case 4:
                            displayMenu();
                            break;
                        case 0:
                            System.out.println("Exiting Cafe Order System. Goodbye!");
                            break;
                        default:
                            System.err.println("Error: Invalid choice. Please enter a number between 0 and 4.");
                    }
                } catch (InputMismatchException e) {
                    System.err.println("Error: Invalid input. Please enter a number.");
                    scanner.nextLine(); // Consume the invalid input to prevent infinite loop
                    choice = -1; // Reset choice to ensure loop continues
                }
                // Note: Other potential runtime exceptions within the called methods
                // like NullPointerException would be caught by the outer try-catch.

            }
        } catch (Exception e) {
            // This catches any unhandled exceptions that escape the inner try-catch
            // or occur outside of the specific input reading block.
            System.err.println("\nAn unexpected system error occurred:");
            e.printStackTrace(System.err); // Print stack trace to System.err for debugging
            System.err.println("System is shutting down due to an error.");
        } finally {
            // Ensure the scanner resource is closed when the system exits or errors out
            if (scanner != null) {
                scanner.close();
                System.out.println("Scanner closed.");
            }
        }
    }

    /**
     * Main method to start the Cafe Order Management System application.
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        CafeOrderSystem system = new CafeOrderSystem();
        system.runSystem();
    }
}
