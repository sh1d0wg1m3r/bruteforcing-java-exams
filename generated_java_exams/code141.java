/*
 * Exam Question #141
 * Generated on: 2025-05-11 22:20:44
 * Generated by: Account 5
 * 
 * QUESTION:
 * ## Advanced Java Programming Exam Task: Technical Support Request Processor
 * 
 * **Problem Description:**
 * 
 * You are tasked with developing a core system for managing technical support requests. The system should allow support staff to add new requests to a processing queue, process the next available request, and view lists of both pending and completed requests.
 * 
 * Your solution must demonstrate a strong understanding of fundamental Java data structures, control flow, input/output, and exception handling.
 * 
 * **Requirements:**
 * 
 * 1.  **Data Structures:**
 *     *   Use a `java.util.Queue` to store support requests that are waiting to be processed (pending).
 *     *   Use a `java.util.ArrayList` to store support requests that have been completed.
 *     *   Use the `java.util.List` interface in method signatures where appropriate (e.g., for returning collections of requests).
 * 2.  **Input/Output:**
 *     *   Use `java.util.Scanner` to read user input from the console (menu choices and request details).
 *     *   Use `System.out` for displaying menus, prompts, success messages, and lists of requests.
 *     *   Use `System.err` for displaying error messages (e.g., invalid input, attempting to process an empty queue).
 * 3.  **Control Flow:**
 *     *   Implement a main application loop that continues until the user chooses to exit.
 *     *   Use a `switch` statement to handle the different menu options selected by the user.
 * 4.  **Exception Handling:**
 *     *   Implement class-wide or method-level `try-catch` blocks to handle potential runtime errors, particularly those related to user input (e.g., non-integer input when expecting a number).
 *     *   Gracefully handle the scenario where a user attempts to process a request when the queue is empty.
 * 5.  **Object-Oriented Design:**
 *     *   Create a `SupportRequest` class to represent individual requests. This class should encapsulate request details (e.g., ID, description).
 *     *   Create a `SupportQueueManager` class responsible for managing the pending queue and completed list. This class should contain the methods for adding, processing, and retrieving requests, ensuring proper encapsulation.
 * 6.  **Best Practices:**
 *     *   Use meaningful variable and method names.
 *     *   Include appropriate comments and documentation (e.g., Javadoc comments for classes and methods).
 *     *   Implement input validation where necessary (e.g., ensuring menu choices are valid numbers within the expected range).
 *     *   Ensure proper encapsulation (private fields, public methods).
 * 
 * **Application Flow:**
 * 
 * The application should present a menu with the following options:
 * 
 * 1.  Add New Request
 * 2.  Process Next Request
 * 3.  View Pending Requests
 * 4.  View Completed Requests
 * 5.  Exit
 * 
 * Based on the user's input, the application should perform the corresponding action using the `SupportQueueManager`.
 * 
 * **Example Interaction (Partial):**
 * 
 * ```
 * --- Support Request Processor ---
 * 1. Add New Request
 * 2. Process Next Request
 * 3. View Pending Requests
 * 4. View Completed Requests
 * 5. Exit
 * Enter your choice: 1
 * Enter request description: My printer is not working.
 * Request added with ID 1.
 * 
 * --- Support Request Processor ---
 * ... (menu repeats)
 * Enter your choice: 1
 * Enter request description: Software installation failed.
 * Request added with ID 2.
 * 
 * --- Support Request Processor ---
 * ... (menu repeats)
 * Enter your choice: 3
 * --- Pending Requests ---
 * ID: 1, Description: My printer is not working.
 * ID: 2, Description: Software installation failed.
 * --------------------------
 * 
 * --- Support Request Processor ---
 * ... (menu repeats)
 * Enter your choice: 2
 * Processing request ID 1.
 * Request ID 1 completed.
 * 
 * --- Support Request Processor ---
 * ... (menu repeats)
 * Enter your choice: 3
 * --- Pending Requests ---
 * ID: 2, Description: Software installation failed.
 * --------------------------
 * 
 * --- Support Request Processor ---
 * ... (menu repeats)
 * Enter your choice: 4
 * --- Completed Requests ---
 * ID: 1, Description: My printer is not working.
 * --------------------------
 * 
 * --- Support Request Processor ---
 * ... (menu repeats)
 * Enter your choice: 5
 * Exiting Support Request Processor.
 * ```
 * 
 * **Task:**
 * 
 * Write the complete Java code for this Support Request Processor system, adhering to all the requirements and best practices listed above.
 *
 * EXPLANATION:
 * This solution implements a basic technical support request processing system, fulfilling all the requirements of the exam task.
 * 
 * **Key Components and Concepts Demonstrated:**
 * 
 * 1.  **`SupportRequest` Class:** This simple class encapsulates the data for a single request (ID and description). It follows encapsulation principles with private fields and public getter methods. The `toString()` method provides a convenient way to print request details.
 * 2.  **`SupportQueueManager` Class:** This is the core management class.
 *     *   **`Queue<SupportRequest> pendingRequests`:** A `LinkedList` is used to implement the `Queue` interface. This correctly models the FIFO (First-In, First-Out) nature of a processing queue where the oldest request is processed first.
 *     *   **`List<SupportRequest> completedRequests`:** An `ArrayList` is used to store completed requests. An `ArrayList` is suitable here as completed requests are typically viewed or iterated over, and their order of completion is maintained by adding them to the list as they are processed.
 *     *   **`List` Interface:** The `getPendingRequests()` and `getCompletedRequests()` methods return `List<SupportRequest>`. This is good practice as it returns a more general interface type, allowing the caller flexibility without exposing the specific implementation (`LinkedList` for pending, `ArrayList` for completed). `getPendingRequests()` returns a *copy* in an `ArrayList` to prevent external modification of the live queue.
 *     *   **Encapsulation:** All data fields (`pendingRequests`, `completedRequests`, `nextRequestId`) are `private`. Access and modification are controlled through public methods (`addRequest`, `processNextRequest`, `getPendingRequests`, `getCompletedRequests`).
 *     *   **`addRequest(String description)`:** Creates a new `SupportRequest` with a unique ID (managed by `nextRequestId`) and adds it to the `pendingRequests` queue using `offer()`. Includes basic input validation for the description.
 *     *   **`processNextRequest()`:** Uses `poll()` to remove and return the head of the `pendingRequests` queue. `poll()` is safe for empty queues (returns `null`), which is handled gracefully with an `System.err` message. If a request is processed, it's added to the `completedRequests` list.
 * 3.  **`SupportSystemApp` Class:**
 *     *   **`Scanner`:** Used to read user input. `scanner.nextLine()` is used to read the entire line, which is then parsed. This avoids common issues when mixing `nextInt()` or `nextDouble()` with `nextLine()`.
 *     *   **Main Loop:** A `while(running)` loop keeps the application running until the user chooses to exit.
 *     *   **`displayMenu()`:** A helper method for clear output using `System.out`.
 *     *   **Input Validation and Exception Handling (`try-catch`):**
 *         *   A nested `try-catch` block is used specifically around `Integer.parseInt(inputLine)` to catch `NumberFormatException` if the user enters non-numeric input for the menu choice. An error message is printed to `System.err`, and the loop continues.
 *         *   The main `while` loop is wrapped in a larger `try-catch(Exception e)` block to catch any other unexpected runtime errors that might occur, printing the error message and stack trace to `System.err` for debugging.
 *     *   **`switch` Statement:** Controls the application flow based on the user's valid integer choice, calling the appropriate methods of the `SupportQueueManager`.
 *     *   **`System.out` and `System.err`:** Used appropriately for normal output (menu, success messages, lists) and error messages (invalid input, empty queue processing).
 *     *   **Resource Management:** The `Scanner` is closed in a `finally` block (or implicitly via try-with-resources if used on the `Scanner` itself, though closing `System.in` is sometimes avoided) to release system resources. In this specific code, the `Scanner` is declared `static final` and closed in the `finally` block of the `main` method's `try-catch`.
 * 
 * This solution effectively combines the required Java components and programming concepts to create a functional and robust application that simulates a real-world task queue scenario, demonstrating advanced understanding of Java programming principles.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.InputMismatchException; // Specific exception for Scanner issues

/**
 * Represents a single technical support request.
 */
class SupportRequest {
    private int id;
    private String description;

    /**
     * Constructs a new SupportRequest.
     * @param id The unique identifier for the request.
     * @param description A brief description of the issue.
     */
    public SupportRequest(int id, String description) {
        this.id = id;
        this.description = description;
    }

    /**
     * Gets the request ID.
     * @return The request ID.
     */
    public int getId() {
        return id;
    }

    /**
     * Gets the request description.
     * @return The request description.
     */
    public String getDescription() {
        return description;
    }

    @Override
    public String toString() {
        return "ID: " + id + ", Description: " + description;
    }
}

/**
 * Manages the queue of pending support requests and the list of completed requests.
 */
class SupportQueueManager {
    // Queue to hold requests waiting for processing (FIFO)
    private Queue<SupportRequest> pendingRequests;
    // List to hold requests that have been processed
    private List<SupportRequest> completedRequests;
    // Counter for generating unique request IDs
    private int nextRequestId;

    /**
     * Constructs a new SupportQueueManager.
     * Initializes the queue and list, and sets the initial request ID.
     */
    public SupportQueueManager() {
        // LinkedList implements the Queue interface
        this.pendingRequests = new LinkedList<>();
        // ArrayList implements the List interface
        this.completedRequests = new ArrayList<>();
        this.nextRequestId = 1; // Start ID from 1
    }

    /**
     * Adds a new support request to the pending queue.
     * @param description The description of the new request.
     * @return The ID of the newly added request.
     */
    public int addRequest(String description) {
        if (description == null || description.trim().isEmpty()) {
            // Simple validation
            System.err.println("Error: Request description cannot be empty.");
            return -1; // Indicate failure
        }
        SupportRequest newRequest = new SupportRequest(nextRequestId++, description);
        // offer() is generally preferred over add() for queues as it returns false on failure
        pendingRequests.offer(newRequest);
        return newRequest.getId();
    }

    /**
     * Processes the next request from the pending queue.
     * Moves the processed request to the completed list.
     * Handles the case where the queue is empty.
     * @return The processed SupportRequest, or null if the queue was empty.
     */
    public SupportRequest processNextRequest() {
        // poll() retrieves and removes the head of the queue, returns null if queue is empty
        SupportRequest processedRequest = pendingRequests.poll();
        if (processedRequest != null) {
            System.out.println("Processing request ID " + processedRequest.getId() + "...");
            // Simulate processing time if needed, but not required by problem
            completedRequests.add(processedRequest);
            System.out.println("Request ID " + processedRequest.getId() + " completed.");
        } else {
            System.err.println("Error: No pending requests to process.");
        }
        return processedRequest;
    }

    /**
     * Gets a list of all pending support requests.
     * @return A List view of the pending requests. Returns an empty list if no pending requests.
     */
    public List<SupportRequest> getPendingRequests() {
        // Return a new ArrayList containing elements from the queue
        // This avoids exposing the internal Queue structure directly
        return new ArrayList<>(pendingRequests);
    }

    /**
     * Gets a list of all completed support requests.
     * @return A List of the completed requests. Returns an empty list if no completed requests.
     */
    public List<SupportRequest> getCompletedRequests() {
        // Return the completedRequests list
        return completedRequests;
    }
}

/**
 * Main application class for the Support Request Processor.
 * Handles user interaction and drives the SupportQueueManager.
 */
public class SupportSystemApp {

    private static final Scanner scanner = new Scanner(System.in);
    private static final SupportQueueManager manager = new SupportQueueManager();

    /**
     * Displays the main menu to the user.
     */
    private static void displayMenu() {
        System.out.println("\n--- Support Request Processor ---");
        System.out.println("1. Add New Request");
        System.out.println("2. Process Next Request");
        System.out.println("3. View Pending Requests");
        System.out.println("4. View Completed Requests");
        System.out.println("5. Exit");
        System.out.print("Enter your choice: ");
    }

    /**
     * Main method to run the Support System Application.
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        boolean running = true;

        // Use a try-with-resources block for the scanner to ensure it's closed
        // Although closing System.in is debated, in this context it's fine.
        // A general try-catch block is also used around the main loop for robustness.
        try {
            while (running) {
                displayMenu();

                int choice = -1;
                // Use a nested try-catch for reading integer input specifically
                try {
                    // Read the whole line first to avoid issues with Scanner and nextInt/nextLine mix
                    String inputLine = scanner.nextLine();
                    choice = Integer.parseInt(inputLine); // Parse the line as an integer

                } catch (NumberFormatException e) {
                    // Catch non-integer input
                    System.err.println("Invalid input. Please enter a number.");
                    continue; // Skip to the next iteration of the main loop
                }

                // Switch statement to handle the valid integer choice
                switch (choice) {
                    case 1:
                        System.out.print("Enter request description: ");
                        String description = scanner.nextLine();
                        int requestId = manager.addRequest(description);
                        if (requestId != -1) { // Check if addRequest was successful
                            System.out.println("Request added with ID " + requestId + ".");
                        }
                        break;
                    case 2:
                        manager.processNextRequest(); // Method handles empty queue message
                        break;
                    case 3:
                        System.out.println("\n--- Pending Requests ---");
                        List<SupportRequest> pending = manager.getPendingRequests();
                        if (pending.isEmpty()) {
                            System.out.println("No pending requests.");
                        } else {
                            for (SupportRequest req : pending) {
                                System.out.println(req); // Uses SupportRequest's toString()
                            }
                        }
                        System.out.println("--------------------------");
                        break;
                    case 4:
                        System.out.println("\n--- Completed Requests ---");
                        List<SupportRequest> completed = manager.getCompletedRequests();
                        if (completed.isEmpty()) {
                            System.out.println("No completed requests.");
                        } else {
                            for (SupportRequest req : completed) {
                                System.out.println(req); // Uses SupportRequest's toString()
                            }
                        }
                        System.out.println("--------------------------");
                        break;
                    case 5:
                        System.out.println("Exiting Support Request Processor.");
                        running = false; // Set flag to exit loop
                        break;
                    default:
                        // Handle choices outside the valid range 1-5
                        System.err.println("Invalid choice. Please enter a number between 1 and 5.");
                }
            }
        } catch (Exception e) {
            // Catch any other unexpected exceptions during execution
            System.err.println("An unexpected error occurred: " + e.getMessage());
            e.printStackTrace(System.err); // Print stack trace to error stream
        } finally {
            // Ensure scanner is closed when the application exits
            if (scanner != null) {
                scanner.close();
                System.out.println("Scanner closed.");
            }
        }
    }
}
