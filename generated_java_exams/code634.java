/*
 * Exam Question #634
 * Generated on: 2025-05-12 16:17:45
 * Generated by: Account 1
 * 
 * QUESTION:
 * ## Advanced Java Programming Exam: Hospital Appointment Management System
 * 
 * **Objective:** Design and implement a simple console-based system for managing hospital appointments. The system should allow scheduling appointments, listing scheduled appointments, and managing a waiting list for patients who couldn't get their preferred slot.
 * 
 * **Requirements:**
 * 
 * 1.  **Core Functionality:**
 *     *   **Schedule Appointment:** Allow scheduling an appointment for a patient with a specific doctor at a given time slot.
 *     *   **List Appointments:** Display all currently scheduled appointments.
 *     *   **Add to Waiting List:** If an appointment slot is unavailable, allow the patient to be added to a general waiting list. The waiting list has a maximum capacity.
 *     *   **Exit:** Terminate the program.
 * 
 * 2.  **Data Structures:**
 *     *   Use `java.util.ArrayList` (declared as `java.util.List`) to store scheduled appointments.
 *     *   Use `java.util.Queue` to manage the waiting list of patients.
 * 
 * 3.  **User Interaction:**
 *     *   Use `java.util.Scanner` to read user input from the console.
 *     *   Present a menu of options to the user.
 * 
 * 4.  **Control Flow:**
 *     *   Use a `switch` statement to handle the user's menu selection.
 * 
 * 5.  **Output:**
 *     *   Use `System.out` for displaying the menu, successful messages, and lists of appointments/waiting list contents.
 *     *   Use `System.err` for displaying error messages (e.g., invalid input, appointment conflict, waiting list full).
 * 
 * 6.  **Error Handling:**
 *     *   Implement robust input validation (e.g., ensuring non-empty strings, valid menu choices).
 *     *   Handle potential exceptions using `try-catch` blocks. Include a broad `try-catch(Exception e)` block in the main application loop to catch unexpected errors, printing the error to `System.err`.
 *     *   Implement specific error handling for scenarios like:
 *         *   Scheduling an appointment that conflicts with an existing one (same doctor, same time slot).
 *         *   Attempting to add a patient to a full waiting list.
 *         *   Invalid numerical input from the user.
 * 
 * 7.  **Object-Oriented Design:**
 *     *   Create appropriate classes (e.g., `Patient`, `Doctor`, `Appointment`, `AppointmentScheduler`).
 *     *   Implement proper encapsulation (private fields, public methods).
 *     *   Use meaningful variable and method names.
 *     *   Include basic comments explaining key parts of the code.
 * 
 * 8.  **Constraints:**
 *     *   Assume a fixed set of available doctors (you can hardcode a few).
 *     *   Assume time slots are simple strings (e.g., "10:00 AM", "2:30 PM").
 *     *   Define a maximum capacity for the waiting list (e.g., 5 patients).
 * 
 * **Expected Output:**
 * 
 * The program should run interactively, presenting a menu, accepting input, and providing feedback or displaying lists based on the user's choices. Error messages should be clearly printed to `System.err`.
 * 
 * ```
 * --- Hospital Appointment System ---
 * 1. Schedule Appointment
 * 2. List Scheduled Appointments
 * 3. Add to Waiting List
 * 4. Exit
 * Enter your choice:
 * ```
 * (Example interaction for scheduling)
 * ```
 * Enter patient name: John Doe
 * Enter doctor name: Dr. Smith
 * Enter time slot (e.g., 10:00 AM): 10:00 AM
 * Appointment scheduled successfully for John Doe with Dr. Smith at 10:00 AM.
 * ```
 * (Example interaction for conflict)
 * ```
 * Enter patient name: Jane Doe
 * Enter doctor name: Dr. Smith
 * Enter time slot (e.g., 10:00 AM): 10:00 AM
 * Error: Appointment conflict! Dr. Smith is already booked at 10:00 AM.
 * Do you want to add Jane Doe to the waiting list? (yes/no): yes
 * Jane Doe added to the waiting list. Waiting list size: 1/5
 * ```
 * (Example interaction for listing)
 * ```
 * --- Scheduled Appointments ---
 * Patient: John Doe, Doctor: Dr. Smith, Time: 10:00 AM
 * --- Waiting List (1/5) ---
 * Patient: Jane Doe
 * ```
 * (Example interaction for waiting list full)
 * ```
 * ... (attempt to add to waiting list when full) ...
 * Error: Waiting list is full. Cannot add more patients.
 * ```
 * 
 * **Evaluation:**
 * 
 * Your solution will be evaluated based on:
 * *   Correctness and completeness of the implementation according to the requirements.
 * *   Proper usage of `Queue`, `ArrayList` (as `List`), `Scanner`, `switch`, `System.err`, `System.out`.
 * *   Effective use of `try-catch` for error handling.
 * *   Adherence to object-oriented principles (encapsulation, meaningful names).
 * *   Code clarity, comments, and structure.
 * *   Input validation and robust error reporting.
 * 
 * ```java
 * // Start your solution code below this line
 * ```
 *
 * EXPLANATION:
 * This solution implements a console-based Hospital Appointment System demonstrating the required Java concepts.
 * 
 * 1.  **Class Structure:**
 *     *   `Patient`, `Doctor`, and `Appointment` classes represent the core entities with private fields and public getters (encapsulation). Basic validation is included in constructors.
 *     *   `AppointmentScheduler` class manages the state of the system, holding the list of appointments and the waiting list. It contains the logic for scheduling and managing the waiting queue.
 *     *   `AppointmentSchedulerApp` is the main application class with the `main` method, handling user interaction and the main menu loop.
 *     *   `AppointmentConflictException` and `WaitingListFullException` are custom exceptions for specific error conditions, making the error handling clearer.
 * 
 * 2.  **Data Structures:**
 *     *   `List<Appointment> scheduledAppointments = new ArrayList<>();` in `AppointmentScheduler`: This uses the `List` interface to declare the collection, implemented by `ArrayList`. `ArrayList` is suitable for storing scheduled appointments as it provides efficient access and iteration.
 *     *   `Queue<Patient> waitingList = new LinkedList<>();` in `AppointmentScheduler`: This uses the `Queue` interface, implemented by `LinkedList`. `Queue` is the appropriate data structure for a waiting list because it enforces a First-In, First-Out (FIFO) order, meaning patients are served (or added to the waiting list) in the order they arrived. `LinkedList` is a common and efficient implementation of `Queue`.
 * 
 * 3.  **User Input (`Scanner`):**
 *     *   A `Scanner` object (`scanner`) is used in `AppointmentSchedulerApp` to read input from `System.in`.
 *     *   `scanner.nextLine()` is used after `scanner.nextInt()` to consume the leftover newline character, preventing input issues in subsequent `nextLine()` calls.
 *     *   Input reading is wrapped in `try-catch` blocks, specifically `InputMismatchException`, to handle cases where the user enters non-integer input when a number is expected.
 * 
 * 4.  **Control Flow (`switch`):**
 *     *   The `runMenu()` method in `AppointmentSchedulerApp` uses a `while` loop to keep the program running until the user chooses to exit.
 *     *   Inside the loop, a `switch` statement is used to direct the program flow based on the integer choice entered by the user, calling the relevant private methods (`scheduleAppointment`, `listAppointmentsAndWaitingList`, `addToWaitingListPrompt`).
 * 
 * 5.  **Output (`System.out`, `System.err`):**
 *     *   `System.out.println()` is used for displaying the menu, prompts, successful operation messages, and the contents of the lists.
 *     *   `System.err.println()` is used specifically for printing error messages, such as invalid input, appointment conflicts, and waiting list full errors. This directs error output to the standard error stream, which is good practice for separating normal output from errors.
 * 
 * 6.  **Exception Handling (`try-catch`):**
 *     *   **Class-wide (Main Method) `try-catch`:** The `main` method in `AppointmentSchedulerApp` has a `try-catch(Exception e)` block wrapping the `runMenu()` call. This serves as a final safety net to catch any uncaught exceptions that might occur during the program's execution, printing an error message to `System.err` before the program terminates.
 *     *   **Specific `try-catch` blocks:**
 *         *   In `runMenu()`, `InputMismatchException` is caught around `scanner.nextInt()` to handle non-integer input gracefully.
 *         *   In `scheduleAppointment()`, `IllegalArgumentException` (for invalid input or doctor not found) and `AppointmentConflictException` are caught specifically to provide user-friendly error messages and handle the conflict scenario (prompting for waiting list).
 *         *   In `addToWaitingListPrompt()`, `WaitingListFullException` and `IllegalArgumentException` are caught.
 *     *   Custom exceptions (`AppointmentConflictException`, `WaitingListFullException`) are thrown by the `AppointmentScheduler` methods to signal specific business logic errors, which are then caught and handled in the `AppointmentSchedulerApp`.
 * 
 * 7.  **Best Practices:**
 *     *   **Encapsulation:** Class fields are `private`, and access/modification is via `public` methods.
 *     *   **Meaningful Names:** Variables (`scheduledAppointments`, `waitingList`, `timeSlot`), methods (`scheduleAppointment`, `addToWaitingList`, `listAppointmentsAndWaitingList`), and classes (`Patient`, `Doctor`, `AppointmentScheduler`) have names that clearly indicate their purpose.
 *     *   **Comments:** Basic comments explain the purpose of classes, methods, and key logic sections.
 *     *   **Input Validation:** Checks for null or empty strings are done before creating objects or performing operations (e.g., in constructors and `scheduleAppointment` method).
 *     *   **Error Handling:** Multiple levels of `try-catch` and custom exceptions provide structured error management. `System.err` is used for error output.
 *     *   **Clean Code Structure:** Logic is separated into different methods and classes based on responsibility. The `main` method is clean, primarily calling the menu runner.
 * 
 * 8.  **Implementation Details:**
 *     *   The `Appointment` class includes a `conflictsWith` method for easy checking against existing appointments based on doctor and time slot.
 *     *   The `AppointmentScheduler` includes a helper method `findDoctorByName` and stores a hardcoded list of available doctors.
 *     *   The waiting list capacity is a constant, and the `addToWaitingList` method checks against it, throwing `WaitingListFullException`. `Queue.offer()` is used, which is suitable when dealing with capacity constraints.
 *     *   Listing methods convert the `Queue` to an `ArrayList` (`new ArrayList<>(waitingList)`) for easy iteration and display, preserving the FIFO order.
 * 
 * This solution effectively integrates all required components into a functional application, demonstrating advanced concepts like exception handling strategies, appropriate data structure selection, and object-oriented design principles in a practical context.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.InputMismatchException;

// Custom Exception for Appointment Conflict
class AppointmentConflictException extends Exception {
    public AppointmentConflictException(String message) {
        super(message);
    }
}

// Custom Exception for Waiting List Full
class WaitingListFullException extends Exception {
    public WaitingListFullException(String message) {
        super(message);
    }
}

// Represents a Patient
class Patient {
    private String name;

    public Patient(String name) {
        if (name == null || name.trim().isEmpty()) {
            throw new IllegalArgumentException("Patient name cannot be null or empty.");
        }
        this.name = name.trim();
    }

    public String getName() {
        return name;
    }

    @Override
    public String toString() {
        return name;
    }
}

// Represents a Doctor (simplified)
class Doctor {
    private String name;

    public Doctor(String name) {
         if (name == null || name.trim().isEmpty()) {
            throw new IllegalArgumentException("Doctor name cannot be null or empty.");
        }
        this.name = name.trim();
    }

    public String getName() {
        return name;
    }

    // Simple equality check based on name for this problem's scope
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Doctor doctor = (Doctor) o;
        return name.equals(doctor.name);
    }

    @Override
    public int hashCode() {
        return name.hashCode();
    }

    @Override
    public String toString() {
        return name;
    }
}

// Represents an Appointment
class Appointment {
    private Patient patient;
    private Doctor doctor;
    private String timeSlot; // Simplified: e.g., "10:00 AM"

    public Appointment(Patient patient, Doctor doctor, String timeSlot) {
         if (patient == null || doctor == null || timeSlot == null || timeSlot.trim().isEmpty()) {
            throw new IllegalArgumentException("Appointment details cannot be null or empty.");
        }
        this.patient = patient;
        this.doctor = doctor;
        this.timeSlot = timeSlot.trim();
    }

    public Patient getPatient() {
        return patient;
    }

    public Doctor getDoctor() {
        return doctor;
    }

    public String getTimeSlot() {
        return timeSlot;
    }

    // Check for conflict based on doctor and time slot
    public boolean conflictsWith(Appointment other) {
        return this.doctor.equals(other.doctor) && this.timeSlot.equalsIgnoreCase(other.timeSlot);
    }

    @Override
    public String toString() {
        return "Patient: " + patient.getName() + ", Doctor: " + doctor.getName() + ", Time: " + timeSlot;
    }
}

// Manages appointments and the waiting list
class AppointmentScheduler {
    // Using List interface for flexibility, implemented by ArrayList
    private List<Appointment> scheduledAppointments;
    // Using Queue interface for FIFO waiting list, implemented by LinkedList
    private Queue<Patient> waitingList;
    private final int WAITING_LIST_CAPACITY = 5; // Example capacity

    // Hardcoded doctors for simplicity
    private final List<Doctor> availableDoctors;

    public AppointmentScheduler() {
        scheduledAppointments = new ArrayList<>();
        waitingList = new LinkedList<>(); // LinkedList implements Queue
        availableDoctors = new ArrayList<>();
        availableDoctors.add(new Doctor("Dr. Smith"));
        availableDoctors.add(new Doctor("Dr. Jones"));
        availableDoctors.add(new Doctor("Dr. Adams"));
    }

    // Helper to find a doctor by name (case-insensitive simple search)
    private Doctor findDoctorByName(String name) {
        for (Doctor doc : availableDoctors) {
            if (doc.getName().equalsIgnoreCase(name.trim())) {
                return doc;
            }
        }
        return null; // Doctor not found
    }

    /**
     * Schedules a new appointment.
     *
     * @param patientName The name of the patient.
     * @param doctorName  The name of the doctor.
     * @param timeSlot    The desired time slot.
     * @throws AppointmentConflictException if the slot is already booked.
     * @throws IllegalArgumentException if input is invalid or doctor not found.
     */
    public void scheduleAppointment(String patientName, String doctorName, String timeSlot)
            throws AppointmentConflictException, IllegalArgumentException {

        if (patientName == null || patientName.trim().isEmpty() ||
            doctorName == null || doctorName.trim().isEmpty() ||
            timeSlot == null || timeSlot.trim().isEmpty()) {
            throw new IllegalArgumentException("All appointment details must be provided.");
        }

        Patient patient = new Patient(patientName);
        Doctor doctor = findDoctorByName(doctorName);

        if (doctor == null) {
            throw new IllegalArgumentException("Doctor '" + doctorName + "' not found.");
        }

        Appointment newAppointment = new Appointment(patient, doctor, timeSlot);

        // Check for conflicts
        for (Appointment existingAppt : scheduledAppointments) {
            if (newAppointment.conflictsWith(existingAppt)) {
                throw new AppointmentConflictException(
                        "Dr. " + doctor.getName() + " is already booked at " + timeSlot + ".");
            }
        }

        // If no conflict, add the appointment
        scheduledAppointments.add(newAppointment);
    }

    /**
     * Adds a patient to the waiting list.
     *
     * @param patientName The name of the patient.
     * @throws WaitingListFullException if the waiting list is at capacity.
     * @throws IllegalArgumentException if patient name is invalid.
     */
    public void addToWaitingList(String patientName) throws WaitingListFullException, IllegalArgumentException {
         if (patientName == null || patientName.trim().isEmpty()) {
            throw new IllegalArgumentException("Patient name for waiting list cannot be null or empty.");
        }

        if (waitingList.size() >= WAITING_LIST_CAPACITY) {
            throw new WaitingListFullException("Waiting list is full. Cannot add more patients.");
        }

        Patient patient = new Patient(patientName);
        waitingList.offer(patient); // offer is generally preferred over add for capacity-constrained queues
    }

    /**
     * Gets the list of scheduled appointments.
     *
     * @return A List of Appointment objects.
     */
    public List<Appointment> getScheduledAppointments() {
        // Return a copy or unmodifiable list to prevent external modification
        return new ArrayList<>(scheduledAppointments);
    }

     /**
     * Gets the list of patients on the waiting list.
     *
     * @return A List of Patient objects currently in the queue.
     */
    public List<Patient> getWaitingList() {
        // Convert queue to list for easy display
        return new ArrayList<>(waitingList);
    }

    public int getWaitingListSize() {
        return waitingList.size();
    }

    public int getWaitingListCapacity() {
        return WAITING_LIST_CAPACITY;
    }

     public List<Doctor> getAvailableDoctors() {
        return new ArrayList<>(availableDoctors); // Return a copy
    }
}

// Main application class
public class AppointmentSchedulerApp {

    private static AppointmentScheduler scheduler = new AppointmentScheduler();
    private static Scanner scanner = new Scanner(System.in);

    public static void main(String[] args) {
        System.out.println("--- Welcome to the Hospital Appointment System ---");

        // Class-wide exception handling for unexpected errors
        try {
            runMenu();
        } catch (Exception e) {
            System.err.println("An unexpected system error occurred: " + e.getMessage());
            // Optionally print stack trace for debugging during development/testing
            // e.printStackTrace(System.err);
        } finally {
            // Ensure scanner is closed
            if (scanner != null) {
                scanner.close();
            }
             System.out.println("System shutting down. Goodbye!");
        }
    }

    private static void runMenu() {
        int choice = -1;

        while (choice != 4) {
            printMenu();

            try {
                System.out.print("Enter your choice: ");
                choice = scanner.nextInt();
                scanner.nextLine(); // Consume newline left-over

                // Use switch statement for flow control
                switch (choice) {
                    case 1:
                        scheduleAppointment();
                        break;
                    case 2:
                        listAppointmentsAndWaitingList();
                        break;
                    case 3:
                         addToWaitingListPrompt();
                        break;
                    case 4:
                        System.out.println("Exiting system.");
                        break;
                    default:
                        System.err.println("Invalid choice. Please enter a number between 1 and 4.");
                }
            } catch (InputMismatchException e) {
                System.err.println("Invalid input. Please enter a number.");
                scanner.nextLine(); // Consume the invalid input to prevent infinite loop
                choice = -1; // Reset choice to continue loop
            } catch (IllegalArgumentException e) {
                 System.err.println("Input error: " + e.getMessage());
            } catch (Exception e) {
                // Catch any other specific exceptions thrown by methods,
                // though the main try-catch in main() is the final fallback.
                 System.err.println("An error occurred during operation: " + e.getMessage());
            }
            System.out.println(); // Add a blank line for readability
        }
    }

    private static void printMenu() {
        System.out.println("--- Hospital Appointment System ---");
        System.out.println("1. Schedule Appointment");
        System.out.println("2. List Scheduled Appointments and Waiting List");
        System.out.println("3. Add Patient to Waiting List");
        System.out.println("4. Exit");
    }

    private static void scheduleAppointment() {
        System.out.println("\n--- Schedule New Appointment ---");
        System.out.print("Enter patient name: ");
        String patientName = scanner.nextLine().trim();

        System.out.println("Available Doctors: " + scheduler.getAvailableDoctors());
        System.out.print("Enter doctor name: ");
        String doctorName = scanner.nextLine().trim();

        System.out.print("Enter time slot (e.g., 10:00 AM): ");
        String timeSlot = scanner.nextLine().trim();

        try {
            scheduler.scheduleAppointment(patientName, doctorName, timeSlot);
            System.out.println("Appointment scheduled successfully for " + patientName +
                               " with " + doctorName + " at " + timeSlot + ".");
        } catch (IllegalArgumentException e) {
            // Catch validation errors from scheduler.scheduleAppointment
             System.err.println("Scheduling failed: " + e.getMessage());
        } catch (AppointmentConflictException e) {
            // Catch conflict specifically
            System.err.println("Scheduling failed: " + e.getMessage());
            // Offer to add to waiting list if there's a conflict
            promptAddToWaitingList(patientName);
        }
    }

    private static void promptAddToWaitingList(String patientName) {
         System.out.print("Do you want to add " + patientName + " to the waiting list? (yes/no): ");
         String response = scanner.nextLine().trim().toLowerCase();
         if (response.equals("yes")) {
             try {
                 scheduler.addToWaitingList(patientName);
                 System.out.println(patientName + " added to the waiting list. Waiting list size: " +
                                    scheduler.getWaitingListSize() + "/" + scheduler.getWaitingListCapacity());
             } catch (WaitingListFullException e) {
                 System.err.println("Failed to add to waiting list: " + e.getMessage());
             } catch (IllegalArgumentException e) {
                  System.err.println("Failed to add to waiting list: " + e.getMessage());
             }
         } else {
             System.out.println("Patient not added to waiting list.");
         }
    }

     private static void addToWaitingListPrompt() {
         System.out.println("\n--- Add Patient to Waiting List ---");
         System.out.print("Enter patient name to add to waiting list: ");
         String patientName = scanner.nextLine().trim();

         try {
             scheduler.addToWaitingList(patientName);
             System.out.println(patientName + " added to the waiting list. Waiting list size: " +
                                scheduler.getWaitingListSize() + "/" + scheduler.getWaitingListCapacity());
         } catch (WaitingListFullException e) {
             System.err.println("Failed to add to waiting list: " + e.getMessage());
         } catch (IllegalArgumentException e) {
              System.err.println("Failed to add to waiting list: " + e.getMessage());
         }
     }


    private static void listAppointmentsAndWaitingList() {
        System.out.println("\n--- Scheduled Appointments ---");
        List<Appointment> appointments = scheduler.getScheduledAppointments();
        if (appointments.isEmpty()) {
            System.out.println("No appointments scheduled yet.");
        } else {
            for (Appointment appt : appointments) {
                System.out.println(appt);
            }
        }

        System.out.println("\n--- Waiting List (" + scheduler.getWaitingListSize() + "/" + scheduler.getWaitingListCapacity() + ") ---");
        List<Patient> waitingPatients = scheduler.getWaitingList();
         if (waitingPatients.isEmpty()) {
            System.out.println("Waiting list is empty.");
        } else {
            // Note: Iterating a List converted from a Queue shows elements in FIFO order
            for (Patient patient : waitingPatients) {
                System.out.println("Patient: " + patient.getName());
            }
        }
    }
}
