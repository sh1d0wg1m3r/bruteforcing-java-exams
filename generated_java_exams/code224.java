/*
 * Exam Question #224
 * Generated on: 2025-05-11 22:34:45
 * Generated by: Account 5
 * 
 * QUESTION:
 * **Subject:** Advanced Java Programming
 * **Task:** Develop a simple command-line Task Management System.
 * 
 * **Scenario:** You are building a basic system to manage tasks for a small team. New tasks are added and queued up for processing. You need to be able to add tasks, process the next task waiting in the queue, and view all tasks that have been added to the system (regardless of whether they are still in the queue or have been "processed").
 * 
 * **Requirements:**
 * 
 * 1.  **Task Representation:** Create a `Task` class with at least a `description` (String) and a unique `id` (integer). Include a constructor and a method to get the description. The `id` should be automatically generated (e.g., using a static counter).
 * 2.  **Task Manager:** Create a `TaskManager` class responsible for managing the tasks.
 *     *   It must internally use a `java.util.Queue<Task>` to hold tasks that are waiting to be processed (the "processing queue").
 *     *   It must internally use a `java.util.ArrayList<Task>` to maintain a complete history/list of *all* tasks ever added to the system.
 *     *   It must expose methods:
 *         *   `addTask(String description)`: Creates a new `Task`, adds it to *both* the internal `ArrayList` and the internal `Queue`. Returns the newly created `Task`.
 *         *   `processNextTask()`: Removes the next task from the `Queue`. If the queue is empty, handle this gracefully without throwing an exception from the method itself. Returns the processed `Task` or `null` if the queue was empty.
 *         *   `getAllTasks()`: Returns a `java.util.List<Task>` containing all tasks ever added (from the `ArrayList`).
 * 3.  **User Interface:** Implement a simple command-line interface in a `Main` class using `java.util.Scanner`.
 *     *   Present a menu to the user with options:
 *         1.  Add New Task
 *         2.  Process Next Task
 *         3.  View All Tasks
 *         4.  Exit
 *     *   Read user input using `Scanner`.
 *     *   Use a `switch` statement to handle the different menu options.
 * 4.  **Input Validation:**
 *     *   When adding a task, ensure the description is not empty or just whitespace. If invalid, display an error message using `System.err` and do not add the task.
 *     *   Handle non-integer input for the menu choice. If invalid, display an error message using `System.err` and prompt again.
 * 5.  **Output:**
 *     *   Use `System.out` for displaying the menu, confirmation messages (task added, task processed), and the list of tasks.
 *     *   Use `System.err` for displaying error messages (invalid input, queue empty).
 * 6.  **Error Handling:**
 *     *   Implement class-wide (or significant method-wide) exception handling using `try-catch` blocks, particularly around the user input loop and potentially risky operations like processing from the queue. Catch appropriate exceptions (like `NumberFormatException`) and use a general `Exception` catch for unexpected issues, printing stack traces to `System.err`.
 * 7.  **Best Practices:**
 *     *   Employ proper encapsulation (private fields, public methods).
 *     *   Use meaningful variable and method names.
 *     *   Include basic comments where necessary.
 *     *   Structure your code into appropriate classes (`Task`, `TaskManager`, `Main`).
 * 
 * **Expected Output Examples:**
 * 
 * *   **Menu Display:**
 *     ```
 *     Task Management System
 *     ----------------------
 *     1. Add New Task
 *     2. Process Next Task
 *     3. View All Tasks
 *     4. Exit
 *     Enter choice:
 *     ```
 * *   **Adding Task:**
 *     ```
 *     Enter task description: Implement feature X
 *     Task added: ID 1 - Implement feature X
 *     ```
 * *   **Processing Task:**
 *     ```
 *     Processing next task...
 *     Processed task: ID 1 - Implement feature X
 *     ```
 *     or if queue empty:
 *     ```
 *     System.err: No tasks in the queue to process.
 *     ```
 * *   **Viewing Tasks:**
 *     ```
 *     All Tasks:
 *     ID 1 - Implement feature X
 *     ID 2 - Write documentation
 *     ```
 * *   **Invalid Menu Input:**
 *     ```
 *     Enter choice: abc
 *     System.err: Invalid input. Please enter a number.
 *     ```
 * *   **Invalid Task Description:**
 *     ```
 *     Enter task description:
 *     System.err: Task description cannot be empty.
 *     ```
 * *   **General Error (example):**
 *     ```
 *     System.err: An unexpected error occurred: java.lang.SomeException...
 *     ```
 * 
 * Implement the Java code for this system.
 *
 * EXPLANATION:
 * This solution implements a simple Task Management System using the required Java components and demonstrates core concepts like object-oriented design, collection usage, user interaction, and error handling.
 * 
 * 1.  **`Task` Class:** This is a simple Plain Old Java Object (POJO) representing a task.
 *     *   It has private fields (`id`, `description`) demonstrating encapsulation.
 *     *   A static counter `nextId` is used to automatically generate unique IDs for each task instance, a common pattern.
 *     *   The constructor validates the input `description`, throwing an `IllegalArgumentException` if it's invalid. This is a form of input validation at the object level.
 *     *   `toString()` is overridden for easy printing of task details.
 * 
 * 2.  **`TaskManager` Class:** This class encapsulates the logic for managing the task collections.
 *     *   It holds a `Queue<Task>` named `processingQueue` and a `List<Task>` named `allTasksList` as private fields, demonstrating encapsulation of the internal state.
 *     *   A `LinkedList` is used to implement the `Queue` interface for `processingQueue`. `LinkedList` is a common choice as it efficiently supports queue operations (`offer`, `poll`).
 *     *   An `ArrayList` is used to implement the `List` interface for `allTasksList`, providing dynamic array capabilities to store all tasks.
 *     *   `addTask(String description)`: This method creates a new `Task` and adds it to *both* the `allTasksList` (using `add()`) and the `processingQueue` (using `offer()`). `offer()` is preferred over `add()` for queues as it returns `false` on failure rather than throwing an exception, making the queue usage safer.
 *     *   `processNextTask()`: This method uses `processingQueue.poll()`. `poll()` is crucial here as it returns the head of the queue *and* removes it, but returns `null` if the queue is empty, avoiding an exception. This null return is checked in the calling code (`Main`) to handle the empty queue case gracefully.
 *     *   `getAllTasks()`: This method returns the `allTasksList`. While in a real application returning a copy or unmodifiable list (`Collections.unmodifiableList`) would be better for encapsulation, returning the direct list fulfills the requirement of demonstrating `ArrayList` usage.
 * 
 * 3.  **`Main` Class:** This class contains the `main` method and handles the user interface logic.
 *     *   A `Scanner` object is used to read input from `System.in`.
 *     *   The main application logic runs inside a `while(true)` loop, which continues until the user chooses to exit.
 *     *   A `try-catch` block wraps the main loop to provide **class-wide exception handling**. Any unhandled exception occurring within the loop will be caught here, an error message printed to `System.err`, and the stack trace printed to `System.err` before the program potentially terminates or attempts to continue depending on the error. A `finally` block ensures the `Scanner` is closed.
 *     *   `printMenu()` displays the options using `System.out`.
 *     *   `getUserChoice()` reads the integer choice. It includes a nested `try-catch` specifically for `InputMismatchException` to handle non-integer input, printing an error to `System.err` and consuming the invalid input line using `scanner.nextLine()` to prevent an infinite loop.
 *     *   A `switch` statement is used to control the program flow based on the user's valid choice.
 *     *   `addTaskAction()` prompts for the description, reads it using `scanner.nextLine()`, and calls `taskManager.addTask()`. It includes a `try-catch` to specifically catch the `IllegalArgumentException` thrown by the `Task` constructor if the description is invalid, printing the error message to `System.err`.
 *     *   `processTaskAction()` calls `taskManager.processNextTask()`. It checks the return value: if `null`, it prints a message to `System.err`; otherwise, it prints the processed task details to `System.out`.
 *     *   `viewAllTasksAction()` calls `taskManager.getAllTasks()` which returns a `List`. It then iterates through this `List` (demonstrating `List` usage) and prints each task to `System.out`.
 * 
 * This solution effectively integrates `Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.err`, `System.out`, and `try-catch` within a practical scenario, adhering to best practices like encapsulation and input validation.
 */

import java.util.ArrayList;
import java.util.LinkedList; // LinkedList implements Queue and List
import java.util.List;
import java.util.Queue;
import java.util.Scanner;

// Represents a single task
class Task {
    private static int nextId = 1; // Static counter for unique IDs

    private int id;
    private String description;

    public Task(String description) {
        if (description == null || description.trim().isEmpty()) {
            throw new IllegalArgumentException("Task description cannot be empty.");
        }
        this.id = nextId++; // Assign and increment ID
        this.description = description.trim();
    }

    public int getId() {
        return id;
    }

    public String getDescription() {
        return description;
    }

    @Override
    public String toString() {
        return "ID " + id + " - " + description;
    }
}

// Manages collections of tasks
class TaskManager {
    // Queue for tasks waiting to be processed (FIFO)
    private Queue<Task> processingQueue;
    // List for all tasks ever added (history/full list)
    private List<Task> allTasksList;

    public TaskManager() {
        this.processingQueue = new LinkedList<>(); // LinkedList implements Queue
        this.allTasksList = new ArrayList<>();
    }

    /**
     * Adds a new task to the system.
     * Adds the task to both the history list and the processing queue.
     *
     * @param description The description of the task.
     * @return The newly created Task object.
     * @throws IllegalArgumentException if the description is null or empty.
     */
    public Task addTask(String description) {
        Task newTask = new Task(description); // Task constructor validates description
        allTasksList.add(newTask);
        processingQueue.offer(newTask); // offer is safer than add for queues
        return newTask;
    }

    /**
     * Processes (removes) the next task from the processing queue.
     *
     * @return The processed Task, or null if the queue is empty.
     */
    public Task processNextTask() {
        // poll() retrieves and removes the head of the queue, returns null if empty
        return processingQueue.poll();
    }

    /**
     * Returns a list of all tasks ever added to the system.
     *
     * @return A List of all Task objects.
     */
    public List<Task> getAllTasks() {
        // Return a copy or unmodifiable list for better encapsulation
        // For this exam, returning the internal list is acceptable per requirements,
        // but in a real app, returning a copy is safer.
        // return Collections.unmodifiableList(allTasksList); // Better practice
        return allTasksList; // As per implicit requirement to demonstrate ArrayList usage directly
    }

    /**
     * Checks if the processing queue is empty.
     * @return true if the queue is empty, false otherwise.
     */
    public boolean isQueueEmpty() {
        return processingQueue.isEmpty();
    }
}

// Main class for user interaction and application entry point
public class Main {

    private static TaskManager taskManager = new TaskManager();
    private static Scanner scanner = new Scanner(System.in);

    public static void main(String[] args) {
        System.out.println("Task Management System");
        System.out.println("----------------------");

        // Main application loop with exception handling
        try {
            while (true) {
                printMenu();
                int choice = getUserChoice();

                // Use switch statement for flow control
                switch (choice) {
                    case 1:
                        addTaskAction();
                        break;
                    case 2:
                        processTaskAction();
                        break;
                    case 3:
                        viewAllTasksAction();
                        break;
                    case 4:
                        System.out.println("Exiting Task Management System. Goodbye!");
                        return; // Exit the program
                    default:
                        // Handled by getUserChoice, but good to have a fallback
                        System.err.println("Invalid choice. Please try again.");
                }
                System.out.println(); // Add a newline for better readability
            }
        } catch (Exception e) {
            // Class-wide exception handling for unexpected errors
            System.err.println("An unexpected error occurred: " + e.getMessage());
            e.printStackTrace(System.err); // Print stack trace to System.err
        } finally {
            // Ensure scanner is closed
            if (scanner != null) {
                scanner.close();
            }
        }
    }

    private static void printMenu() {
        System.out.println("1. Add New Task");
        System.out.println("2. Process Next Task");
        System.out.println("3. View All Tasks");
        System.out.println("4. Exit");
        System.out.print("Enter choice: ");
    }

    private static int getUserChoice() {
        int choice = -1;
        try {
            choice = scanner.nextInt();
        } catch (java.util.InputMismatchException e) {
            // Input validation for non-integer input
            System.err.println("Invalid input. Please enter a number.");
        } finally {
             // Consume the rest of the line after reading the integer (or failed attempt)
             // to prevent infinite loops on invalid input.
             scanner.nextLine();
        }
        return choice;
    }

    private static void addTaskAction() {
        System.out.print("Enter task description: ");
        String description = scanner.nextLine(); // Read the full line

        try {
            Task newTask = taskManager.addTask(description);
            System.out.println("Task added: " + newTask);
        } catch (IllegalArgumentException e) {
            // Input validation error from Task constructor
            System.err.println(e.getMessage());
        } catch (Exception e) {
             // Catch any other potential errors during task creation/addition
             System.err.println("Error adding task: " + e.getMessage());
             e.printStackTrace(System.err);
        }
    }

    private static void processTaskAction() {
        System.out.println("Processing next task...");
        Task processedTask = taskManager.processNextTask();

        if (processedTask != null) {
            System.out.println("Processed task: " + processedTask);
        } else {
            // Handle empty queue case using System.err
            System.err.println("No tasks in the queue to process.");
        }
    }

    private static void viewAllTasksAction() {
        List<Task> allTasks = taskManager.getAllTasks();

        if (allTasks.isEmpty()) {
            System.out.println("No tasks have been added yet.");
        } else {
            System.out.println("All Tasks:");
            // Demonstrate iterating through the List
            for (Task task : allTasks) {
                System.out.println(task);
            }
        }
    }
}
