/*
 * Exam Question #874
 * Generated on: 2025-05-12 16:53:29
 * Generated by: Account 4
 * 
 * QUESTION:
 * **Exam Task: Warehouse Order Processing Simulation**
 * 
 * You are tasked with developing a simple simulation of a warehouse order processing system. The system manages incoming orders that need to be processed sequentially and keeps a record of all orders that have been completed.
 * 
 * Your solution must demonstrate a strong understanding of core Java data structures, control flow, exception handling, and object-oriented programming principles.
 * 
 * **Requirements:**
 * 
 * 1.  **Order Representation:** Create a class named `Order` with the following private fields:
 *     *   `orderId` (String)
 *     *   `description` (String)
 *     *   `status` (String - e.g., "Pending", "Completed")
 *     *   Include a constructor to initialize `orderId`, `description`, and set initial status to "Pending".
 *     *   Provide public getter methods for all fields.
 *     *   Provide a public method `markCompleted()` to change the status to "Completed".
 *     *   Override the `toString()` method to provide a user-friendly representation of an order (e.g., "Order [ID: O101, Desc: Laptop, Status: Pending]").
 * 
 * 2.  **Order Management System:** Create a class named `WarehouseOrderManager` that manages the orders.
 *     *   It must have a private field representing the **queue** of incoming orders waiting to be processed. Use `java.util.Queue`.
 *     *   It must have a private field representing the **list** of completed orders. Declare this field using the `java.util.List` interface.
 *     *   Implement the following public methods:
 *         *   `addIncomingOrder(Order order)`: Adds a new order to the end of the incoming queue.
 *         *   `processNextOrder()`: Removes the order at the front of the incoming queue, marks it as "Completed", and adds it to the completed orders list. If the queue is empty, it should indicate an error condition (e.g., return false or throw a custom exception, but for this task, printing to `System.err` and returning a boolean indicating failure is sufficient).
 *         *   `getPendingOrders()`: Returns a `List` view of the orders currently in the incoming queue without removing them.
 *         *   `getCompletedOrders()`: Returns the `List` of completed orders.
 * 
 * 3.  **Simulation Main Class:** Create a main class (e.g., `WarehouseSimulation`) with a `main` method to run the simulation.
 *     *   Use `java.util.Scanner` to get user input from the console.
 *     *   Implement a menu-driven interface with the following options:
 *         *   1. Add New Order
 *         *   2. Process Next Order
 *         *   3. View Pending Orders
 *         *   4. View Completed Orders
 *         *   5. Exit
 *     *   Use a `switch` statement to handle the user's menu choice.
 *     *   Use `System.out` for displaying the menu, prompts, and successful operation results (like listing orders).
 *     *   Use `System.err` for displaying error messages (e.g., invalid menu input, attempting to process an empty queue).
 *     *   Implement **class-wide exception handling** using `try-catch` blocks within the `main` method's loop to catch potential issues like invalid numeric input from the user or errors reported by the `WarehouseOrderManager`. Print a user-friendly error message to `System.err` in the catch block.
 *     *   Ensure the `Scanner` resource is properly managed (e.g., using try-with-resources).
 *     *   Include basic input validation (e.g., checking if menu choice is a valid number within the range).
 * 
 * **Expected Output:**
 * 
 * The program should loop, presenting the menu. Based on user input, it should perform the requested action and display appropriate messages or lists of orders. Error messages should go to `System.err`.
 * 
 * Example Interaction (User input is shown in `bold`):
 * 
 * ```
 * --- Warehouse Order System ---
 * 1. Add New Order
 * 2. Process Next Order
 * 3. View Pending Orders
 * 4. View Completed Orders
 * 5. Exit
 * Enter choice: **1**
 * Enter Order ID: **O101**
 * Enter Order Description: **Laptop**
 * Order O101 added to the queue.
 * --- Warehouse Order System ---
 * 1. Add New Order
 * 2. Process Next Order
 * 3. View Pending Orders
 * 4. View Completed Orders
 * 5. Exit
 * Enter choice: **1**
 * Enter Order ID: **O102**
 * Enter Order Description: **Keyboard**
 * Order O102 added to the queue.
 * --- Warehouse Order System ---
 * 1. Add New Order
 * 2. Process Next Order
 * 3. View Pending Orders
 * 4. View Completed Orders
 * 5. Exit
 * Enter choice: **3**
 * --- Pending Orders ---
 * Order [ID: O101, Desc: Laptop, Status: Pending]
 * Order [ID: O102, Desc: Keyboard, Status: Pending]
 * --------------------
 * --- Warehouse Order System ---
 * 1. Add New Order
 * 2. Process Next Order
 * 3. View Pending Orders
 * 4. View Completed Orders
 * 5. Exit
 * Enter choice: **2**
 * Processing next order...
 * Order O101 processed and moved to completed.
 * --- Warehouse Order System ---
 * 1. Add New Order
 * 2. Process Next Order
 * 3. View Pending Orders
 * 4. View Completed Orders
 * 5. Exit
 * Enter choice: **3**
 * --- Pending Orders ---
 * Order [ID: O102, Desc: Keyboard, Status: Pending]
 * --------------------
 * --- Warehouse Order System ---
 * 1. Add New Order
 * 2. Process Next Order
 * 3. View Pending Orders
 * 4. View Completed Orders
 * 5. Exit
 * Enter choice: **4**
 * --- Completed Orders ---
 * Order [ID: O101, Desc: Laptop, Status: Completed]
 * --------------------
 * --- Warehouse Order System ---
 * 1. Add New Order
 * 2. Process Next Order
 * 3. View Pending Orders
 * 4. View Completed Orders
 * 5. Exit
 * Enter choice: **2**
 * Processing next order...
 * Order O102 processed and moved to completed.
 * --- Warehouse Order System ---
 * 1. Add New Order
 * 2. Process Next Order
 * 3. View Pending Orders
 * 4. View Completed Orders
 * 5. Exit
 * Enter choice: **2**
 * Processing next order...
 * Error: No pending orders to process.
 * --- Warehouse Order System ---
 * 1. Add New Order
 * 2. Process Next Order
 * 3. View Pending Orders
 * 4. View Completed Orders
 * 5. Exit
 * Enter choice: **6**
 * Error: Invalid choice. Please enter a number between 1 and 5.
 * --- Warehouse Order System ---
 * 1. Add New Order
 * 2. Process Next Order
 * 3. View Pending Orders
 * 4. View Completed Orders
 * 5. Exit
 * Enter choice: **exit**
 * Error: Invalid input. Please enter a number.
 * --- Warehouse Order System ---
 * 1. Add New Order
 * 2. Process Next Order
 * 3. View Pending Orders
 * 4. View Completed Orders
 * 5. Exit
 * Enter choice: **5**
 * Exiting system.
 * ```
 * 
 * **Evaluation Criteria:**
 * 
 * *   Correct implementation of `Order` class with encapsulation and `toString()`.
 * *   Correct use of `Queue` and `List` in `WarehouseOrderManager`.
 * *   Correct implementation of `WarehouseOrderManager` methods (`add`, `process`, `get`).
 * *   Effective use of `Scanner` for user input.
 * *   Correct implementation of the menu loop using `switch`.
 * *   Proper use of `System.out` and `System.err`.
 * *   Effective class-wide exception handling using `try-catch` in the `main` loop.
 * *   Input validation for menu choices.
 * *   Proper resource management (`Scanner`).
 * *   Clean code structure, meaningful names, and comments.
 *
 * EXPLANATION:
 * This solution implements a simple warehouse order processing simulation, demonstrating the required Java concepts and best practices.
 * 
 * 1.  **`Order` Class:**
 *     *   Represents an individual order with `orderId`, `description`, and `status` fields.
 *     *   Fields are `private` for encapsulation.
 *     *   Public getters provide controlled access to the data.
 *     *   `markCompleted()` is a public method that modifies the internal state (`status`).
 *     *   The constructor includes basic validation for input parameters, throwing `IllegalArgumentException` if they are invalid. This is a good practice for ensuring object integrity.
 *     *   `toString()` is overridden for easy printing of order details.
 * 
 * 2.  **`WarehouseOrderManager` Class:**
 *     *   Manages the collection of orders using appropriate data structures.
 *     *   `pendingOrders`: Declared as `Queue<Order>`. `LinkedList` is used as the concrete implementation because it efficiently supports adding to the end and removing from the beginning (FIFO - First-In, First-Out), which is characteristic of a queue for processing.
 *     *   `completedOrders`: Declared as `List<Order>`. `ArrayList` is used as the concrete implementation. `List` is used as the interface type, adhering to the principle of programming to interfaces. `ArrayList` is suitable for storing completed items where efficient access by index or iteration is common.
 *     *   `addIncomingOrder()`: Uses `queue.add()` to place the order at the end of the `pendingOrders` queue.
 *     *   `processNextOrder()`: Uses `queue.poll()` to retrieve and remove the head of the queue. It checks if the result is `null` (indicating an empty queue) and handles that case by printing an error to `System.err` and returning `false`. If an order is retrieved, it calls `markCompleted()` on the order and adds it to the `completedOrders` `List`.
 *     *   `getPendingOrders()`: Returns a *copy* of the pending orders as an `ArrayList`. This is important because returning the internal `LinkedList` directly would allow external code to modify the queue structure unexpectedly. Returning a `List` interface also provides flexibility.
 *     *   `getCompletedOrders()`: Returns the internal `completedOrders` `List`.
 * 
 * 3.  **`WarehouseSimulation` Class (`main` method):**
 *     *   This is the entry point and handles user interaction.
 *     *   `Scanner`: Used to read input from `System.in`. It's placed in a try-with-resources block (`try (Scanner scanner = new Scanner(System.in))`) to ensure it is automatically closed, preventing resource leaks.
 *     *   `WarehouseOrderManager`: An instance is created to manage the orders.
 *     *   Main Loop: A `while(running)` loop keeps the simulation active until the user chooses to exit.
 *     *   **Class-wide Exception Handling:** The entire `while` loop body is wrapped in a `try-catch(Exception e)` block. This catches any unexpected errors that might occur during the execution of the menu options, preventing the program from crashing and providing a general error message to `System.err`. A stack trace is printed for debugging.
 *     *   **Input-Specific Exception Handling:** An inner `try-catch(InputMismatchException e)` block is specifically used around the `scanner.nextInt()` call. This catches non-integer input for the menu choice, prints a specific error to `System.err`, consumes the invalid input line using `scanner.nextLine()`, and uses `continue` to restart the loop, prompting the user again. This is crucial for robust input handling with `Scanner`.
 *     *   `switch` Statement: Used effectively to direct the program flow based on the validated user choice.
 *     *   `System.out` vs. `System.err`: `System.out` is used for normal output (menu, prompts, lists, success messages). `System.err` is used exclusively for error conditions (invalid input, processing empty queue, exceptions). This is a best practice for separating standard output from error messages.
 *     *   Input Validation: The code checks if the menu choice is within the valid range (1-5) in the `default` case of the `switch` and reports an error to `System.err`. The `Order` constructor also validates its inputs.
 * 
 * This solution demonstrates the required components (`Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.err`, `System.out`, `try-catch`) in a cohesive, practical scenario, while adhering to object-oriented principles (encapsulation) and best practices (meaningful names, comments, resource management, robust error handling).
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.InputMismatchException;

// Represents an order in the system
class Order {
    private String orderId;
    private String description;
    private String status; // e.g., "Pending", "Completed"

    /**
     * Constructs a new Order.
     * @param orderId The unique ID of the order.
     * @param description A description of the order contents.
     */
    public Order(String orderId, String description) {
        if (orderId == null || orderId.trim().isEmpty()) {
            throw new IllegalArgumentException("Order ID cannot be null or empty.");
        }
        if (description == null || description.trim().isEmpty()) {
            throw new IllegalArgumentException("Order description cannot be null or empty.");
        }
        this.orderId = orderId.trim();
        this.description = description.trim();
        this.status = "Pending"; // Initial status
    }

    // Getters
    public String getOrderId() {
        return orderId;
    }

    public String getDescription() {
        return description;
    }

    public String getStatus() {
        return status;
    }

    /**
     * Marks the order status as "Completed".
     */
    public void markCompleted() {
        this.status = "Completed";
    }

    @Override
    public String toString() {
        return String.format("Order [ID: %s, Desc: %s, Status: %s]", orderId, description, status);
    }
}

// Manages the queue of incoming orders and the list of completed orders
class WarehouseOrderManager {
    // Queue for orders waiting to be processed (FIFO)
    private Queue<Order> pendingOrders;

    // List for orders that have been processed
    private List<Order> completedOrders;

    /**
     * Constructs a new WarehouseOrderManager.
     */
    public WarehouseOrderManager() {
        // Using LinkedList as a concrete implementation of Queue
        this.pendingOrders = new LinkedList<>();
        // Using ArrayList as a concrete implementation of List
        this.completedOrders = new ArrayList<>();
    }

    /**
     * Adds a new order to the incoming queue.
     * @param order The order to add.
     */
    public void addIncomingOrder(Order order) {
        if (order != null) {
            this.pendingOrders.add(order);
        }
    }

    /**
     * Processes the next order from the incoming queue.
     * Removes the order, marks it as completed, and moves it to the completed list.
     * @return true if an order was processed, false if the pending queue was empty.
     */
    public boolean processNextOrder() {
        // poll() retrieves and removes the head of the queue, returns null if queue is empty
        Order orderToProcess = this.pendingOrders.poll();

        if (orderToProcess != null) {
            orderToProcess.markCompleted();
            this.completedOrders.add(orderToProcess);
            System.out.println("Order " + orderToProcess.getOrderId() + " processed and moved to completed.");
            return true;
        } else {
            // Use System.err for error condition feedback
            System.err.println("Error: No pending orders to process.");
            return false;
        }
    }

    /**
     * Returns a list containing the orders currently in the pending queue.
     * The orders remain in the queue.
     * @return A new ArrayList containing the pending orders.
     */
    public List<Order> getPendingOrders() {
        // Create a new list from the queue elements to avoid modifying the queue
        // when the returned list is iterated or modified externally.
        // This also allows using List interface for the return type.
        return new ArrayList<>(this.pendingOrders);
    }

    /**
     * Returns the list of completed orders.
     * @return The list of completed orders.
     */
    public List<Order> getCompletedOrders() {
        // Return the actual list of completed orders
        return this.completedOrders;
    }

    /**
     * Checks if the pending orders queue is empty.
     * @return true if the pending queue is empty, false otherwise.
     */
    public boolean isPendingQueueEmpty() {
        return this.pendingOrders.isEmpty();
    }
}

// Main class to run the simulation
public class WarehouseSimulation {

    public static void main(String[] args) {
        // Use try-with-resources for Scanner to ensure it's closed
        try (Scanner scanner = new Scanner(System.in)) {
            WarehouseOrderManager manager = new WarehouseOrderManager();
            boolean running = true;

            // Class-wide try-catch block to handle exceptions during the main loop
            try {
                while (running) {
                    printMenu();
                    int choice = -1;

                    // Inner try-catch for handling Scanner input specifically
                    try {
                        System.out.print("Enter choice: ");
                        choice = scanner.nextInt();
                        // Consume the newline character left by nextInt()
                        scanner.nextLine();
                    } catch (InputMismatchException e) {
                        System.err.println("Error: Invalid input. Please enter a number.");
                        // Consume the invalid input to prevent infinite loop
                        scanner.nextLine();
                        continue; // Skip to the next iteration of the while loop
                    }

                    // Use a switch statement for menu control
                    switch (choice) {
                        case 1:
                            System.out.print("Enter Order ID: ");
                            String id = scanner.nextLine();
                            System.out.print("Enter Order Description: ");
                            String description = scanner.nextLine();
                            try {
                                Order newOrder = new Order(id, description);
                                manager.addIncomingOrder(newOrder);
                                System.out.println("Order " + newOrder.getOrderId() + " added to the queue.");
                            } catch (IllegalArgumentException e) {
                                // Catch exceptions from Order constructor validation
                                System.err.println("Error adding order: " + e.getMessage());
                            }
                            break;

                        case 2:
                            System.out.println("Processing next order...");
                            // The manager's method already prints success/failure messages
                            manager.processNextOrder();
                            break;

                        case 3:
                            List<Order> pending = manager.getPendingOrders();
                            System.out.println("--- Pending Orders ---");
                            if (pending.isEmpty()) {
                                System.out.println("No pending orders.");
                            } else {
                                for (Order order : pending) {
                                    System.out.println(order);
                                }
                            }
                            System.out.println("--------------------");
                            break;

                        case 4:
                            List<Order> completed = manager.getCompletedOrders();
                            System.out.println("--- Completed Orders ---");
                             if (completed.isEmpty()) {
                                System.out.println("No completed orders.");
                            } else {
                                for (Order order : completed) {
                                    System.out.println(order);
                                }
                            }
                            System.out.println("--------------------");
                            break;

                        case 5:
                            running = false;
                            System.out.println("Exiting system.");
                            break;

                        default:
                            // Use System.err for invalid choices
                            System.err.println("Error: Invalid choice. Please enter a number between 1 and 5.");
                            break;
                    }
                }
            } catch (Exception e) {
                // Catch any unexpected exceptions during the main loop execution
                System.err.println("An unexpected error occurred: " + e.getMessage());
                e.printStackTrace(); // Print stack trace for debugging unexpected errors
            }

        } // Scanner is automatically closed here by try-with-resources
    }

    /**
     * Prints the main menu options to the console.
     */
    private static void printMenu() {
        System.out.println("\n--- Warehouse Order System ---");
        System.out.println("1. Add New Order");
        System.out.println("2. Process Next Order");
        System.out.println("3. View Pending Orders");
        System.out.println("4. View Completed Orders");
        System.out.println("5. Exit");
    }
}
