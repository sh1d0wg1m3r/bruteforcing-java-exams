/*
 * Exam Question #144
 * Generated on: 2025-05-11 22:21:05
 * Generated by: Account 2
 * 
 * QUESTION:
 * **Complex Java Programming Exam Task: Data Center Print Queue Manager**
 * 
 * **Problem Description:**
 * 
 * You are tasked with developing a simplified simulation of a print queue management system for a large data center. The system needs to manage print jobs submitted by various users. Jobs are processed in the order they are submitted (First-In, First-Out). The system should allow users to add new print jobs, process the next available job, view the current queue of pending jobs, and view a history of completed jobs.
 * 
 * Your solution must demonstrate a strong understanding of core Java data structures, control flow, input handling, and error management.
 * 
 * **Requirements:**
 * 
 * 1.  **PrintJob Class:** Create a class `PrintJob` to represent a single print job. It should have:
 *     *   A unique integer ID (`jobId`).
 *     *   A string for the file name (`fileName`).
 *     *   An integer for the number of pages (`pages`).
 *     *   A status (`status`) indicating if the job is "Pending", "Processing", or "Completed". Use an `enum` for the status.
 *     *   Private fields with public getter methods.
 *     *   A method to set the status (e.g., `setStatus(JobStatus status)`).
 *     *   A meaningful `toString()` method for displaying job details.
 * 
 * 2.  **PrintQueueManager Class:** Create a class `PrintQueueManager` to manage the print jobs. It should have:
 *     *   A `Queue<PrintJob>` to hold jobs that are waiting to be processed. Use `java.util.LinkedList` as the implementation.
 *     *   A `List<PrintJob>` to hold jobs that have been completed. Use `java.util.ArrayList` as the implementation.
 *     *   An integer counter for generating unique job IDs.
 *     *   Private fields with public methods for the following operations:
 *         *   `addJob(String fileName, int pages)`: Creates a new `PrintJob`, assigns it a unique ID, sets its status to "Pending", and adds it to the print queue. Returns the newly assigned job ID. Validate that `pages` is positive; if not, throw an `IllegalArgumentException`.
 *         *   `processNextJob()`: Removes the next job from the queue (`poll()`), updates its status to "Completed", and adds it to the completed jobs list. Returns the processed `PrintJob` object, or `null` if the queue was empty.
 *         *   `getPendingJobs()`: Returns the current `Queue` of pending jobs (or an unmodifiable view).
 *         *   `getCompletedJobs()`: Returns the current `List` of completed jobs (or an unmodifiable view).
 * 
 * 3.  **Main Application (`PrintQueueApp`)**:
 *     *   Implement the main application logic in a class with a `main` method.
 *     *   Use `java.util.Scanner` to get user input from the console.
 *     *   Present a menu of options to the user:
 *         1.  Add New Print Job
 *         2.  Process Next Job
 *         3.  View Pending Jobs
 *         4.  View Completed Jobs
 *         5.  Exit
 *     *   Use a `switch` statement to handle the user's choice.
 *     *   Implement input validation for numeric input (e.g., pages, menu choice) using `try-catch` blocks to handle potential `InputMismatchException`. If input is invalid, clear the scanner buffer and inform the user using `System.err`.
 *     *   Handle cases where the queue is empty when trying to process a job, printing a message to `System.out`.
 *     *   Handle the `IllegalArgumentException` from `addJob` using a `try-catch` block and print an error message using `System.err`.
 *     *   Use `System.out` for normal program output (menu, job details, success messages).
 *     *   Use `System.err` for all error messages (invalid input, empty queue processing error, invalid pages error).
 *     *   Include a class-wide `try-catch` block around the main application loop to catch any unexpected exceptions and print a generic error message to `System.err`.
 *     *   Ensure the `Scanner` is properly closed.
 * 
 * 4.  **Code Structure and Best Practices:**
 *     *   Use meaningful variable and method names.
 *     *   Include comments to explain complex parts of the code.
 *     *   Follow standard Java coding conventions.
 *     *   Ensure proper encapsulation in your classes.
 * 
 * **Expected Output:**
 * 
 * The program should interact with the user via the console, displaying a menu, prompting for input, and printing results or error messages based on the chosen action.
 * 
 * *   Adding a job should confirm the job ID.
 * *   Processing a job should indicate which job was processed or state that the queue is empty.
 * *   Viewing queues should list jobs with their details or state that the queue/list is empty.
 * *   Invalid menu choices or input errors should result in error messages printed to `System.err`.
 * *   Unexpected errors should be caught and reported to `System.err`.
 * 
 * **Example Interaction Snippet:**
 * 
 * ```
 * --- Print Queue Manager ---
 * 1. Add New Print Job
 * 2. Process Next Job
 * 3. View Pending Jobs
 * 4. View Completed Jobs
 * 5. Exit
 * Enter your choice: 1
 * Enter file name: report.pdf
 * Enter number of pages: 15
 * Job added with ID: 1
 * 
 * --- Print Queue Manager ---
 * ...
 * Enter your choice: 3
 * --- Pending Jobs ---
 * [Job ID: 1, File: report.pdf, Pages: 15, Status: Pending]
 * 
 * --- Print Queue Manager ---
 * ...
 * Enter your choice: 2
 * Processing job ID: 1
 * Job ID 1 completed.
 * 
 * --- Print Queue Manager ---
 * ...
 * Enter your choice: 3
 * --- Pending Jobs ---
 * (Queue is empty)
 * 
 * --- Print Queue Manager ---
 * ...
 * Enter your choice: 4
 * --- Completed Jobs ---
 * [Job ID: 1, File: report.pdf, Pages: 15, Status: Completed]
 * 
 * --- Print Queue Manager ---
 * ...
 * Enter your choice: 1
 * Enter file name: invalid_pages.txt
 * Enter number of pages: -5
 * Error: Number of pages must be positive.
 * 
 * --- Print Queue Manager ---
 * ...
 * Enter your choice: invalid_input
 * Error: Invalid input. Please enter a number.
 * ```
 *
 * EXPLANATION:
 * This solution implements a `Data Center Print Queue Manager` simulation using the required Java components and best practices.
 * 
 * 1.  **`PrintJob` Class:**
 *     *   Represents a single print job with `jobId`, `fileName`, `pages`, and `status`.
 *     *   Uses an `enum` `JobStatus` for type-safe status representation (`PENDING`, `COMPLETED`).
 *     *   Includes a constructor, getters, a setter for status, and an overridden `toString()` for clear display.
 *     *   Fields are `private` demonstrating encapsulation.
 * 
 * 2.  **`PrintQueueManager` Class:**
 *     *   Manages the collection of print jobs.
 *     *   `printQueue`: A `Queue<PrintJob>` (implemented with `LinkedList`) stores jobs waiting to be processed, ensuring FIFO order. `offer()` is used for adding, `poll()` for removing the head.
 *     *   `completedJobs`: A `List<PrintJob>` (implemented with `ArrayList`) stores jobs after they have been processed.
 *     *   `nextJobId`: An integer counter to assign unique IDs to new jobs.
 *     *   `addJob()`: Creates a new `PrintJob`, increments the ID counter, and adds it to the `printQueue`. Includes input validation for `pages` and throws `IllegalArgumentException`.
 *     *   `processNextJob()`: Removes the job at the front of the `printQueue` using `poll()`. If a job is retrieved (`poll()` returns non-null), its status is updated to `COMPLETED`, and it's added to the `completedJobs` list. Returns the processed job or `null` if the queue is empty.
 *     *   `getPendingJobs()` and `getCompletedJobs()`: Provide access to the internal collections. `Collections.unmodifiableQueue()` and `Collections.unmodifiableList()` are used to return unmodifiable views, preventing external code from directly altering the manager's internal state, which is a good practice for encapsulation and data integrity.
 * 
 * 3.  **`PrintQueueApp` Class (Main Application):**
 *     *   Contains the `main` method where execution begins.
 *     *   A `Scanner` is initialized within a `try-with-resources` block (implicitly handled by the outer `try` and explicit `scanner.close()` or could be written as `try (Scanner scanner = new Scanner(System.in)) { ... }`) to handle user input and ensure the resource is closed.
 *     *   A `PrintQueueManager` instance is created.
 *     *   The main logic runs in a `while(running)` loop, controlled by the user's choice to exit.
 *     *   A `displayMenu()` method keeps the main loop clean.
 *     *   Input handling for the menu choice uses a `try-catch (InputMismatchException)` block. If non-integer input is detected, an error is printed to `System.err`, the invalid input is consumed from the scanner buffer (`scanner.nextLine()`), and the loop continues.
 *     *   A `switch` statement directs execution based on the valid menu choice.
 *     *   **Case 1 (Add Job):** Prompts for file name and pages. Uses another `try-catch` for `InputMismatchException` when reading pages. It also uses a `try-catch` specifically for `IllegalArgumentException` which might be thrown by `manager.addJob()` if the page count is invalid, printing the error to `System.err`.
 *     *   **Case 2 (Process Job):** Calls `manager.processNextJob()`. Checks if the returned job is `null` to determine if the queue was empty, printing appropriate messages to `System.out`.
 *     *   **Case 3 (View Pending):** Calls `manager.getPendingJobs()`. Checks if the queue is empty and iterates through it (using a for-each loop, which works on `Queue` as it implements `Iterable`) to print job details to `System.out`.
 *     *   **Case 4 (View Completed):** Calls `manager.getCompletedJobs()`. Checks if the list is empty and iterates through it to print job details to `System.out`.
 *     *   **Case 5 (Exit):** Sets `running` to `false` to terminate the loop.
 *     *   **Default Case (Invalid Choice):** Handles any integer input outside the valid range (1-5), printing an error to `System.err`.
 *     *   **Class-wide Exception Handling:** The entire `main` method logic is wrapped in a `try-catch (Exception e)`. This block catches any unexpected runtime exceptions that weren't handled by the more specific `try-catch` blocks, printing a generic error message and the stack trace to `System.err`.
 *     *   `System.out` is used for all successful operations, menu display, and informational messages.
 *     *   `System.err` is strictly used for displaying error messages, making them distinct from normal output.
 * 
 * This solution effectively combines object-oriented design (`PrintJob`, `PrintQueueManager`), data structures (`Queue`, `List`, `LinkedList`, `ArrayList`), control flow (`switch`, `while`), user interaction (`Scanner`), and robust error handling (`try-catch`, `InputMismatchException`, `IllegalArgumentException`, `System.err`), fulfilling all requirements of the complex task.
 */

import java.util.Queue;
import java.util.LinkedList;
import java.util.List;
import java.util.ArrayList;
import java.util.Scanner;
import java.util.InputMismatchException;
import java.util.Collections; // For unmodifiable views

// Enum for job status
enum JobStatus {
    PENDING,
    PROCESSING, // Optional intermediate status, not strictly required by prompt but good practice
    COMPLETED
}

/**
 * Represents a single print job in the system.
 */
class PrintJob {
    private int jobId;
    private String fileName;
    private int pages;
    private JobStatus status;

    /**
     * Constructs a new PrintJob.
     * @param jobId The unique identifier for the job.
     * @param fileName The name of the file to print.
     * @param pages The number of pages in the job.
     */
    public PrintJob(int jobId, String fileName, int pages) {
        this.jobId = jobId;
        this.fileName = fileName;
        this.pages = pages;
        this.status = JobStatus.PENDING; // Jobs start as pending
    }

    // --- Getters ---
    public int getJobId() {
        return jobId;
    }

    public String getFileName() {
        return fileName;
    }

    public int getPages() {
        return pages;
    }

    public JobStatus getStatus() {
        return status;
    }

    /**
     * Sets the status of the print job.
     * @param status The new status for the job.
     */
    public void setStatus(JobStatus status) {
        this.status = status;
    }

    /**
     * Provides a string representation of the PrintJob.
     * @return A formatted string describing the job.
     */
    @Override
    public String toString() {
        return "[Job ID: " + jobId + ", File: " + fileName + ", Pages: " + pages + ", Status: " + status + "]";
    }
}

/**
 * Manages the queue and completion history of print jobs.
 */
class PrintQueueManager {
    // Using LinkedList as a Queue implementation (FIFO)
    private Queue<PrintJob> printQueue;
    // Using ArrayList as a List implementation to store completed jobs
    private List<PrintJob> completedJobs;
    private int nextJobId; // Counter for unique job IDs

    /**
     * Constructs a new PrintQueueManager.
     */
    public PrintQueueManager() {
        printQueue = new LinkedList<>();
        completedJobs = new ArrayList<>();
        nextJobId = 1; // Start job IDs from 1
    }

    /**
     * Adds a new print job to the queue.
     * @param fileName The name of the file.
     * @param pages The number of pages.
     * @return The ID assigned to the new job.
     * @throws IllegalArgumentException if pages is not positive.
     */
    public int addJob(String fileName, int pages) {
        if (pages <= 0) {
            throw new IllegalArgumentException("Number of pages must be positive.");
        }
        PrintJob newJob = new PrintJob(nextJobId++, fileName, pages);
        printQueue.offer(newJob); // offer() is preferred over add() in queues as it returns false on failure
        return newJob.getJobId();
    }

    /**
     * Processes the next job in the queue.
     * Removes the job from the queue, marks it as completed, and adds it to the completed list.
     * @return The completed PrintJob, or null if the queue was empty.
     */
    public PrintJob processNextJob() {
        PrintJob jobToProcess = printQueue.poll(); // Retrieves and removes the head of the queue
        if (jobToProcess != null) {
            // jobToProcess.setStatus(JobStatus.PROCESSING); // Optional intermediate status
            jobToProcess.setStatus(JobStatus.COMPLETED);
            completedJobs.add(jobToProcess);
            return jobToProcess;
        }
        return null; // Queue was empty
    }

    /**
     * Gets an unmodifiable view of the current pending jobs queue.
     * @return A Queue containing pending jobs.
     */
    public Queue<PrintJob> getPendingJobs() {
        // Return an unmodifiable view to prevent external modification
        return Collections.unmodifiableQueue(printQueue);
    }

    /**
     * Gets an unmodifiable view of the completed jobs list.
     * @return A List containing completed jobs.
     */
    public List<PrintJob> getCompletedJobs() {
        // Return an unmodifiable view to prevent external modification
        return Collections.unmodifiableList(completedJobs);
    }
}

/**
 * Main application class for the Print Queue Manager.
 */
public class PrintQueueApp {

    public static void main(String[] args) {
        // Class-wide exception handling for unexpected errors
        try {
            Scanner scanner = new Scanner(System.in);
            PrintQueueManager manager = new PrintQueueManager();
            boolean running = true;

            System.out.println("--- Data Center Print Queue Manager ---");

            while (running) {
                displayMenu();

                int choice = -1;
                // Try-catch for input validation (menu choice)
                try {
                    System.out.print("Enter your choice: ");
                    choice = scanner.nextInt();
                    scanner.nextLine(); // Consume the newline character
                } catch (InputMismatchException e) {
                    System.err.println("Error: Invalid input. Please enter a number.");
                    scanner.nextLine(); // Consume the invalid input to prevent infinite loop
                    continue; // Skip to the next loop iteration
                }

                // Switch statement for flow control based on user choice
                switch (choice) {
                    case 1: // Add New Print Job
                        System.out.print("Enter file name: ");
                        String fileName = scanner.nextLine();
                        int pages = -1;
                        // Try-catch for input validation (pages)
                        try {
                            System.out.print("Enter number of pages: ");
                            pages = scanner.nextInt();
                            scanner.nextLine(); // Consume newline
                        } catch (InputMismatchException e) {
                            System.err.println("Error: Invalid input for pages. Please enter a number.");
                            scanner.nextLine(); // Consume invalid input
                            break; // Exit case 1, return to main menu
                        }

                        // Try-catch for IllegalArgumentException from addJob
                        try {
                            int jobId = manager.addJob(fileName, pages);
                            System.out.println("Job added with ID: " + jobId);
                        } catch (IllegalArgumentException e) {
                            System.err.println("Error: " + e.getMessage());
                        }
                        break;

                    case 2: // Process Next Job
                        System.out.println("Attempting to process next job...");
                        PrintJob processedJob = manager.processNextJob();
                        if (processedJob != null) {
                            System.out.println("Processing job ID: " + processedJob.getJobId());
                            System.out.println("Job ID " + processedJob.getJobId() + " completed.");
                        } else {
                            System.out.println("No pending jobs in the queue.");
                        }
                        break;

                    case 3: // View Pending Jobs
                        System.out.println("--- Pending Jobs ---");
                        Queue<PrintJob> pendingJobs = manager.getPendingJobs();
                        if (pendingJobs.isEmpty()) {
                            System.out.println("(Queue is empty)");
                        } else {
                            // Iterate through the queue without removing elements
                            for (PrintJob job : pendingJobs) {
                                System.out.println(job);
                            }
                        }
                        break;

                    case 4: // View Completed Jobs
                        System.out.println("--- Completed Jobs ---");
                        List<PrintJob> completedJobs = manager.getCompletedJobs();
                        if (completedJobs.isEmpty()) {
                            System.out.println("(No jobs completed yet)");
                        } else {
                            for (PrintJob job : completedJobs) {
                                System.out.println(job);
                            }
                        }
                        break;

                    case 5: // Exit
                        System.out.println("Exiting Print Queue Manager. Goodbye!");
                        running = false;
                        break;

                    default: // Invalid choice
                        System.err.println("Error: Invalid choice. Please enter a number between 1 and 5.");
                        break;
                }
                System.out.println(); // Add a blank line for readability
            }

            // Ensure scanner is closed
            scanner.close();

        } catch (Exception e) {
            // Catch any unexpected exceptions
            System.err.println("An unexpected error occurred: " + e.getMessage());
            e.printStackTrace(System.err); // Print stack trace to standard error
        }
    }

    /**
     * Displays the main menu options to the user.
     */
    private static void displayMenu() {
        System.out.println("--- Print Queue Manager Menu ---");
        System.out.println("1. Add New Print Job");
        System.out.println("2. Process Next Job");
        System.out.println("3. View Pending Jobs");
        System.out.println("4. View Completed Jobs");
        System.out.println("5. Exit");
    }
}
