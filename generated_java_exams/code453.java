/*
 * Exam Question #453
 * Generated on: 2025-05-11 23:13:14
 * Generated by: Account 2
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Task Management System
 * 
 * **Objective:** Design and implement a simple console-based Task Management System that allows users to add, view, and process tasks. This task requires demonstrating proficiency in core Java data structures, input handling, control flow, and exception management.
 * 
 * **Scenario:** You are building the backend logic for a basic task manager. Tasks are submitted and placed into a queue. A user can then process the next task from the queue, moving it to a list of completed tasks. The system should be interactive via the console.
 * 
 * **Requirements:**
 * 
 * 1.  **Task Class:** Create a `Task` class with the following private fields:
 *     *   `id` (int): A unique identifier for the task.
 *     *   `description` (String): A brief description of the task.
 *     *   `priority` (int): An integer representing the task's priority (e.g., 1 is high, 5 is low).
 *     *   Implement a constructor to initialize these fields.
 *     *   Provide public getter methods for all fields.
 *     *   Override the `toString()` method to provide a user-friendly representation of the task (including ID, description, and priority).
 * 
 * 2.  **Task Management Logic:** Create a main class (e.g., `TaskManagementApp`) to manage the tasks. This class should contain:
 *     *   A private field `pendingTasks` of type `java.util.Queue<Task>` to hold tasks waiting to be processed. Use a suitable implementation (e.g., `java.util.LinkedList`).
 *     *   A private field `completedTasks` of type `java.util.List<Task>` to hold tasks that have been processed. Initialize this field with a `java.util.ArrayList<Task>`.
 *     *   A private field `nextTaskId` (int) to generate unique IDs for new tasks, starting from 1.
 *     *   A private field `scanner` of type `java.util.Scanner` to read user input from `System.in`.
 * 
 * 3.  **Menu-Driven Interface:** Implement a console menu using `System.out` with the following options:
 *     *   1. Add New Task
 *     *   2. View Pending Tasks
 *     *   3. Process Next Task
 *     *   4. View Completed Tasks
 *     *   5. Exit
 *     *   Use a `switch` statement to handle the user's menu choice.
 * 
 * 4.  **Functionality Implementation:**
 *     *   **Add New Task:** Prompt the user for the task description (String) and priority (int). Validate that the priority is a positive integer. If the input is invalid (non-integer or non-positive), display an error message using `System.err` and do not add the task, prompting the user again or returning to the menu. Create a new `Task` object with a unique `nextTaskId`, add it to the `pendingTasks` queue, and increment `nextTaskId`. Display a success message using `System.out`.
 *     *   **View Pending Tasks:** Iterate through the `pendingTasks` queue and display each task using `System.out`. Do NOT remove tasks from the queue. If the queue is empty, display a message using `System.out` indicating this.
 *     *   **Process Next Task:** Remove the task at the head of the `pendingTasks` queue and add it to the `completedTasks` list. Use `System.out` to confirm which task was processed. If the `pendingTasks` queue is empty, display an error message using `System.err`.
 *     *   **View Completed Tasks:** Iterate through the `completedTasks` list and display each task using `System.out`. If the list is empty, display a message using `System.out` indicating this.
 *     *   **Exit:** Terminate the program gracefully.
 * 
 * 5.  **Error Handling:**
 *     *   Use `System.err` specifically for displaying error messages (e.g., invalid input, operational errors like processing an empty queue).
 *     *   Use `System.out` for all normal output (menu, prompts, task lists, success messages).
 *     *   Implement **class-wide exception handling** using `try-catch` blocks in the main execution loop (`run` method) to catch potential runtime errors (like `InputMismatchException` from `Scanner` for menu choices) and handle them gracefully, preventing the program from crashing. Ensure the `Scanner` resource is closed properly.
 * 
 * 6.  **Best Practices:**
 *     *   Employ proper encapsulation (private fields, public methods).
 *     *   Use meaningful variable and method names.
 *     *   Include appropriate comments and documentation (e.g., Javadoc for classes and methods).
 *     *   Ensure clean and readable code structure.
 * 
 * **Constraint:** Your solution MUST utilize ALL of the following Java components: `java.util.Queue`, `java.util.ArrayList`, `java.util.List`, `java.util.Scanner`, `switch` statement, `System.err`, `System.out`, and `try-catch` blocks for exception handling as specified.
 * 
 * **Expected Output:** The program should run interactively in the console, displaying a menu, accepting numbered choices, and performing the corresponding actions, showing appropriate output or error messages based on user input and system state.
 * 
 * ```
 * --- Task Management Menu ---
 * 1. Add New Task
 * 2. View Pending Tasks
 * 3. Process Next Task
 * 4. View Completed Tasks
 * 5. Exit
 * Enter your choice: 1
 * --- Add New Task ---
 * Enter task description: Complete exam question
 * Enter task priority (positive integer): 2
 * Successfully added: Task [ID=1, Description='Complete exam question', Priority=2]
 * 
 * --- Task Management Menu ---
 * ... (user selects 2)
 * --- Pending Tasks ---
 * Task [ID=1, Description='Complete exam question', Priority=2]
 * 
 * --- Task Management Menu ---
 * ... (user selects 3)
 * --- Processing Next Task ---
 * Successfully processed: Task [ID=1, Description='Complete exam question', Priority=2]
 * 
 * --- Task Management Menu ---
 * ... (user selects 3 again)
 * --- Processing Next Task ---
 * Error: No pending tasks to process. (Output to System.err)
 * 
 * --- Task Management Menu ---
 * ... (user selects 4)
 * --- Completed Tasks ---
 * Task [ID=1, Description='Complete exam question', Priority=2]
 * 
 * --- Task Management Menu ---
 * ... (user enters invalid input like "abc")
 * Error: Invalid input. Please enter a number for your choice. (Output to System.err)
 * 
 * --- Task Management Menu ---
 * ... (user selects 5)
 * Exiting Task Management System. Goodbye!
 * Application terminated.
 * ```
 *
 * EXPLANATION:
 * The provided solution implements a simple console-based Task Management System as required by the exam question. It demonstrates the practical application of several core Java concepts and best practices.
 * 
 * **Key Concepts Demonstrated:**
 * 
 * 1.  **`java.util.Queue`:** The `pendingTasks` field is declared as a `Queue<Task>` and initialized with `LinkedList`. This structure is used to maintain tasks in a waiting list, processed in a First-In, First-Out (FIFO) manner by default. New tasks are added using `offer()`, and tasks are retrieved and removed from the front using `poll()`. The `viewPendingTasks` method iterates through the queue using a for-each loop, which allows viewing elements without removing them, respecting the queue's structure.
 * 
 * 2.  **`java.util.ArrayList` & `java.util.List`:** The `completedTasks` field is declared using the `List<Task>` interface and instantiated as an `ArrayList<Task>`. This is standard practice to program to interfaces. `ArrayList` is used because completed tasks are stored in a simple list where order of completion is maintained, and elements can be easily added and iterated over. Tasks are added using the `add()` method.
 * 
 * 3.  **`java.util.Scanner`:** A `Scanner` object is used to read user input from `System.in` for menu choices and task details (description and priority). Careful handling of the newline character after reading integers (`nextInt()`) using `nextLine()` is implemented to prevent input issues when subsequently reading strings (`nextLine()`).
 * 
 * 4.  **`switch` statement:** A `switch` statement in the `run()` method is used to control the program flow based on the integer menu choice entered by the user, directing execution to the appropriate method (`addTask`, `viewPendingTasks`, `processNextTask`, `viewCompletedTasks`, or exit).
 * 
 * 5.  **`System.err`:** This stream is specifically used for outputting error messages. Examples include messages for invalid priority input in `addTask`, attempting to process a task when the queue is empty in `processNextTask`, and handling invalid menu choices or unexpected exceptions in the `run()` method. This distinguishes error output from normal program output.
 * 
 * 6.  **`System.out`:** This standard output stream is used for all non-error messages, including displaying the menu, prompts for input, lists of tasks (pending and completed), success messages (task added, task processed), and the exit message.
 * 
 * 7.  **`try-catch` blocks:**
 *     *   **Class-wide Handling:** A large `try-catch(Exception e)` block wraps the main `while` loop in the `run()` method. This serves as a general catch-all for any unexpected runtime exceptions that might occur during the program's execution, preventing the application from crashing abruptly. It prints the stack trace to `System.err` for debugging.
 *     *   **Specific Input Handling:** Inner `try-catch(InputMismatchException e)` blocks are used when reading integer input (menu choice in `run` and priority in `addTask`). This specifically handles cases where the user enters non-integer text when an integer is expected, displays an informative error message via `System.err`, consumes the invalid input using `scanner.nextLine()`, and allows the program to continue running without crashing. A `finally` block in the priority input loop ensures the newline after `nextInt()` is consumed even if an exception occurs.
 * 
 * **Best Practices:**
 * 
 * *   **Encapsulation:** The `Task` class fields (`id`, `description`, `priority`) are `private`, and their values are accessed only through public getter methods. The collections and state variables (`pendingTasks`, `completedTasks`, `nextTaskId`, `scanner`) in `TaskManagementApp` are also `private`, with functionality provided through public or private methods as appropriate.
 * *   **Meaningful Names:** Variables (`pendingTasks`, `completedTasks`, `nextTaskId`, `choice`, `description`, `priority`) and methods (`addTask`, `viewPendingTasks`, `processNextTask`, `displayMenu`, `run`) have names that clearly indicate their purpose, improving code readability.
 * *   **Comments and Documentation:** Javadoc comments are used to describe the purpose of classes and methods. Inline comments explain specific logic, particularly the crucial `scanner.nextLine()` calls needed after reading integers.
 * *   **Input Validation:** The `addTask` method explicitly checks if the entered priority is positive and handles `InputMismatchException` for non-integer input. The `run` method handles `InputMismatchException` for menu choices and checks for valid integer ranges.
 * *   **Error Handling:** Errors are explicitly checked for (e.g., `pendingTasks.isEmpty()` before processing) and reported using `System.err`. Input errors are caught and handled gracefully. The general `try-catch` provides robustness against unforeseen issues.
 * *   **Clean Code Structure:** The code is organized into two classes with clear responsibilities (`Task` for data, `TaskManagementApp` for logic). The `TaskManagementApp` methods are modular, each performing a single, well-defined task (displaying menu, adding, viewing, processing). The `run` method orchestrates the main application loop. The `finally` block ensures resource cleanup (`scanner.close()`).
 * 
 * This solution effectively integrates the required Java components and adheres to best practices to create a functional, robust, and well-structured console application within the specified constraints.
 */

// Package declaration (optional, but good practice)
// package com.example.taskmanager;

import java.util.ArrayList;
import java.util.LinkedList; // LinkedList implements Queue
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.InputMismatchException;

/**
 * Represents a single task in the management system.
 * Demonstrates encapsulation.
 */
class Task {
    private int id;
    private String description;
    private int priority;

    /**
     * Constructs a new Task.
     * @param id The unique identifier for the task.
     * @param description A brief description of the task.
     * @param priority The priority level of the task (positive integer).
     */
    public Task(int id, String description, int priority) {
        this.id = id;
        this.description = description;
        this.priority = priority;
    }

    // --- Public Getter Methods ---
    public int getId() {
        return id;
    }

    public String getDescription() {
        return description;
    }

    public int getPriority() {
        return priority;
    }

    /**
     * Provides a string representation of the Task for easy display.
     * @return A formatted string describing the task.
     */
    @Override
    public String toString() {
        return "Task [ID=" + id + ", Description='" + description + "', Priority=" + priority + "]";
    }
}

/**
 * Main class for the Task Management Application.
 * Manages pending and completed tasks via user interaction.
 * Demonstrates use of Queue, List (ArrayList), Scanner, switch,
 * System.out/err, and try-catch for error handling.
 */
public class TaskManagementApp {

    // Queue to hold tasks waiting to be processed (FIFO order in this implementation)
    private Queue<Task> pendingTasks;

    // List to hold tasks that have been completed
    // Declared as List, initialized as ArrayList
    private List<Task> completedTasks;

    // Counter for generating unique task IDs
    private int nextTaskId;

    // Scanner for reading user input from the console
    private Scanner scanner;

    /**
     * Constructs a new TaskManagementApp, initializing collections and scanner.
     */
    public TaskManagementApp() {
        // Initialize pending tasks using LinkedList, which implements the Queue interface
        this.pendingTasks = new LinkedList<>();
        // Initialize completed tasks using ArrayList, which implements the List interface
        this.completedTasks = new ArrayList<>();
        this.nextTaskId = 1; // Start task IDs from 1
        this.scanner = new Scanner(System.in); // Initialize scanner for standard input
    }

    /**
     * Displays the main menu options to the user using System.out.
     */
    private void displayMenu() {
        System.out.println("\n--- Task Management Menu ---");
        System.out.println("1. Add New Task");
        System.out.println("2. View Pending Tasks");
        System.out.println("3. Process Next Task");
        System.out.println("4. View Completed Tasks");
        System.out.println("5. Exit");
        System.out.print("Enter your choice: ");
    }

    /**
     * Prompts user for task details (description, priority) and adds a new task
     * to the pending queue after validating the priority input.
     * Uses Scanner for input, System.out for prompts, System.err for validation errors.
     */
    private void addTask() {
        System.out.println("\n--- Add New Task ---");

        // Consume the newline character left by the previous scanner.nextInt() call (from menu choice)
        // This is necessary before reading the description with scanner.nextLine().
        if (scanner.hasNextLine()) {
             scanner.nextLine();
        }

        System.out.print("Enter task description: ");
        String description = scanner.nextLine(); // Read the full line for description

        int priority = -1;
        boolean validInput = false;
        // Loop until valid priority input is received
        while (!validInput) {
            System.out.print("Enter task priority (positive integer): ");
            try {
                priority = scanner.nextInt(); // Attempt to read an integer
                if (priority <= 0) {
                    // Validation check: priority must be positive
                    System.err.println("Error: Priority must be a positive integer.");
                } else {
                    validInput = true; // Input is valid, exit loop
                }
            } catch (InputMismatchException e) {
                // Catch exception if input is not an integer
                System.err.println("Error: Invalid input. Please enter an integer for priority.");
                scanner.nextLine(); // Consume the invalid input from the scanner buffer
            } finally {
                 // This finally block ensures the newline character after reading the integer
                 // is consumed, regardless of whether an exception occurred or not.
                 if (scanner.hasNextLine()) {
                      scanner.nextLine();
                 }
            }
        }

        // Create a new Task object with a unique ID and validated details
        Task newTask = new Task(nextTaskId++, description, priority);
        // Add the new task to the pending queue using offer()
        pendingTasks.offer(newTask); // offer() is generally preferred over add() for queues
        System.out.println("Successfully added: " + newTask); // Confirm addition
    }

    /**
     * Displays all tasks currently present in the pending tasks queue
     * without removing them. Uses System.out.
     */
    private void viewPendingTasks() {
        System.out.println("\n--- Pending Tasks ---");
        if (pendingTasks.isEmpty()) {
            System.out.println("No pending tasks."); // Message for empty queue
        } else {
            // Iterate through the Queue using a for-each loop to view elements
            // This does not remove elements from the queue.
            for (Task task : pendingTasks) {
                System.out.println(task); // Print each task's details
            }
        }
    }

    /**
     * Processes the next task from the pending queue (removes it)
     * and adds it to the completed tasks list.
     * Uses Queue's poll() method and List's add() method.
     * Uses System.out for success, System.err for errors.
     */
    private void processNextTask() {
        System.out.println("\n--- Processing Next Task ---");
        // Use poll() to retrieve and remove the head of the queue.
        // poll() returns null if the queue is empty.
        Task nextTask = pendingTasks.poll();

        if (nextTask == null) {
            // Display error message to System.err if the queue was empty
            System.err.println("Error: No pending tasks to process.");
        } else {
            // Add the processed task to the completed tasks list
            completedTasks.add(nextTask);
            System.out.println("Successfully processed: " + nextTask); // Confirm processing
        }
    }

    /**
     * Displays all tasks currently present in the completed tasks list.
     * Uses System.out.
     */
    private void viewCompletedTasks() {
        System.out.println("\n--- Completed Tasks ---");
        if (completedTasks.isEmpty()) {
            System.out.println("No tasks completed yet."); // Message for empty list
        } else {
            // Iterate through the List to display completed tasks
            for (Task task : completedTasks) {
                System.out.println(task); // Print each task's details
            }
        }
    }

    /**
     * Runs the main application loop, displaying the menu and handling user choices.
     * Includes class-wide exception handling using a try-catch block around the loop.
     * Uses switch for menu navigation.
     */
    public void run() {
        int choice = -1; // Variable to store user's menu choice

        // --- Class-wide Exception Handling ---
        // This try-catch block wraps the main application loop to catch
        // any unexpected exceptions that might occur during execution,
        // providing a graceful shutdown.
        try {
            // Main application loop continues until the user chooses to exit (choice 5)
            while (choice != 5) {
                displayMenu(); // Show the main menu

                // --- Specific Input Exception Handling for Menu Choice ---
                // This inner try-catch handles potential InputMismatchException
                // when reading the integer menu choice.
                try {
                    // Attempt to read the user's integer choice from standard input
                    choice = scanner.nextInt();

                    // Consume the newline character left by nextInt() to prevent issues
                    // with subsequent scanner.nextLine() calls in other methods (like addTask).
                    if (scanner.hasNextLine()) { // Defensive check if there's a line to consume
                        scanner.nextLine();
                    }

                    // --- Switch Statement for Menu Navigation ---
                    // Directs program flow based on the validated user choice
                    switch (choice) {
                        case 1:
                            addTask(); // Call method to add a new task
                            break;
                        case 2:
                            viewPendingTasks(); // Call method to view pending tasks
                            break;
                        case 3:
                            processNextTask(); // Call method to process the next task
                            break;
                        case 4:
                            viewCompletedTasks(); // Call method to view completed tasks
                            break;
                        case 5:
                            // Exit case
                            System.out.println("Exiting Task Management System. Goodbye!");
                            break;
                        default:
                            // Handle integer choices that are not valid menu options
                            System.err.println("Error: Invalid choice. Please enter a number between 1 and 5.");
                    }
                } catch (InputMismatchException e) {
                    // Catch block for non-integer menu input
                    System.err.println("Error: Invalid input. Please enter a number for your choice.");
                    scanner.nextLine(); // Consume the invalid input from the scanner buffer
                    choice = -1; // Reset choice to a non-exit value to continue the loop
                }
                // Note: Error handling for specific operations (like processing an empty queue)
                // is done within the respective methods (e.g., processNextTask) using System.err.

            } // End of while loop (when choice becomes 5)

        } catch (Exception e) {
            // --- Generic Catch Block for Unexpected Errors ---
            // This outer catch block catches any other runtime exceptions not specifically handled
            // by the inner blocks or individual method logic.
            System.err.println("\nAn unexpected error occurred during application execution:");
            e.printStackTrace(System.err); // Print stack trace to standard error stream for debugging
        } finally {
            // --- Resource Cleanup ---
            // The finally block ensures that resources like the scanner are closed
            // regardless of whether the loop finished normally or an exception occurred.
            if (scanner != null) {
                scanner.close(); // Close the scanner to release system resources
                // System.out.println("Scanner resource closed."); // Optional confirmation
            }
            System.out.println("Application terminated."); // Final message printed upon program exit
        }
    }

    /**
     * The main method, the entry point of the application.
     * Creates an instance of TaskManagementApp and starts the main loop.
     * @param args Command line arguments (not used in this application).
     */
    public static void main(String[] args) {
        TaskManagementApp app = new TaskManagementApp();
        app.run(); // Start the task management application
    }
}
