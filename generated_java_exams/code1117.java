/*
 * Exam Question #1117
 * Generated on: 2025-05-12 17:27:28
 * Generated by: Account 3
 * 
 * QUESTION:
 * ## Advanced Java Programming Exam Task: Project Task Scheduler
 * 
 * **Scenario:** You are tasked with building a simple command-line application to manage tasks for a small project. The system should allow adding new tasks, processing the next task in a queue, listing all tasks, and listing only the tasks currently waiting in the processing queue.
 * 
 * **Requirements:**
 * 
 * 1.  **Task Representation:** Create a `Task` class with the following attributes:
 *     *   An integer `id` (unique identifier, automatically generated).
 *     *   A `String` `description`.
 *     *   A status (`TaskStatus` enum: `PENDING`, `PROCESSING`, `COMPLETED`, `FAILED`).
 *     *   Implement appropriate constructors, getters, and a method to update the status. Ensure proper encapsulation.
 * 
 * 2.  **Task Management System:** Create a `ProjectScheduler` class that manages the tasks. It must include:
 *     *   A `List<Task>` (using `ArrayList`) to store *all* tasks ever created.
 *     *   A `Queue<Task>` (using `java.util.Queue`) to hold tasks that are currently `PENDING` and waiting to be processed in a First-In, First-Out (FIFO) manner.
 *     *   A mechanism to generate unique task IDs.
 *     *   Methods for:
 *         *   `addTask(String description)`: Creates a new `Task` with status `PENDING`, adds it to both the `allTasks` list and the `taskQueue`.
 *         *   `processNextTask()`: Retrieves the next task from the `taskQueue`. If a task is retrieved, update its status to `PROCESSING` (simulate processing), then immediately update its status to `COMPLETED`. If the queue is empty, report an error.
 *         *   `listAllTasks()`: Prints details of all tasks stored in the `allTasks` list.
 *         *   `listPendingTasks()`: Prints details of tasks currently in the `taskQueue`.
 * 
 * 3.  **User Interface:** Implement a command-line interface in the `main` method of the `ProjectScheduler` class (or a separate `Main` class) using `java.util.Scanner`.
 *     *   Present a menu of options:
 *         1.  Add New Task
 *         2.  Process Next Task
 *         3.  List All Tasks
 *         4.  List Pending Tasks
 *         5.  Exit
 *     *   Use a `switch` statement to handle the user's choice.
 *     *   Prompt the user for necessary input (e.g., task description).
 *     *   Handle invalid menu choices.
 * 
 * 4.  **Error Handling and Output:**
 *     *   Use `System.out` for displaying the menu, task lists, and success messages.
 *     *   Use `System.err` to print error messages (e.g., invalid input, processing an empty queue).
 *     *   Implement class-wide exception handling using a `try-catch` block to catch potential runtime errors during the main execution loop (e.g., non-integer input for menu choice).
 * 
 * 5.  **Best Practices:**
 *     *   Employ proper encapsulation (private fields, public methods/getters).
 *     *   Use meaningful variable and method names.
 *     *   Include appropriate comments and documentation (e.g., Javadoc for classes/methods).
 *     *   Perform basic input validation (e.g., check if task description is empty).
 * 
 * **Expected Output Format:**
 * 
 * *   Menu should be clearly displayed.
 * *   Task listings should show Task ID, Description, and Status. Example: `Task ID: 1, Description: Implement login feature, Status: COMPLETED`
 * *   Error messages should be distinct (using `System.err`).
 * 
 * **Evaluation Criteria:**
 * 
 * *   Correct usage of `Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.err`, `System.out`, and `try-catch`.
 * *   Correct implementation of the `Task` and `ProjectScheduler` classes.
 * *   Proper task flow (adding to list and queue, processing from queue).
 * *   Effective use of encapsulation and meaningful names.
 * *   Appropriate error handling and input validation.
 * *   Clear and correct output.
 * *   Code structure and comments.
 * 
 * **Time Limit:** 45-60 minutes
 *
 * EXPLANATION:
 * The provided solution implements a `ProjectScheduler` application that meets all the specified requirements, demonstrating the use of various core Java concepts.
 * 
 * 1.  **Task Representation (`Task` class and `TaskStatus` enum):**
 *     *   The `TaskStatus` enum clearly defines the possible states of a task, making the code more readable and preventing invalid status values.
 *     *   The `Task` class encapsulates task data (`id`, `description`, `status`). Fields are `private`, and access is provided via `public` getters. The `setStatus` method allows controlled modification of the status.
 *     *   Input validation is performed in the `Task` constructor to ensure the description is not null or empty, throwing an `IllegalArgumentException` if it is invalid.
 *     *   `toString()` is overridden for easy printing of task details.
 * 
 * 2.  **Task Management (`ProjectScheduler` class):**
 *     *   `allTasks`: A `List<Task>` implemented using `ArrayList` is used to maintain a complete history of all tasks ever added to the system. `ArrayList` is suitable here as we primarily add tasks and iterate through the list.
 *     *   `taskQueue`: A `Queue<Task>` implemented using `LinkedList` is used for managing tasks that are ready for processing. `LinkedList` is a common and efficient implementation for a Queue, providing O(1) time complexity for add (`offer`) and remove (`poll`) operations at the ends. The Queue naturally enforces the FIFO processing order required by the problem.
 *     *   `nextTaskId`: A simple integer counter ensures each task gets a unique ID.
 *     *   `addTask()`: Creates a `Task` object, increments the ID counter, adds the task to *both* the `allTasks` list (for historical record) and the `taskQueue` (for processing). Includes a `try-catch` block to handle the `IllegalArgumentException` from the `Task` constructor's input validation.
 *     *   `processNextTask()`: Uses `taskQueue.poll()` to retrieve and remove the task at the head of the queue. It checks if the result is `null` (meaning the queue was empty) and prints an error using `System.err` if so. Otherwise, it simulates processing by updating the task's status.
 *     *   `listAllTasks()`: Iterates through the `allTasks` list and prints each task's details using `System.out`.
 *     *   `listPendingTasks()`: Iterates through the `taskQueue` (using `forEach` which internally uses an iterator) and prints each task's details using `System.out`. Note that iterating a Queue typically does *not* remove elements, which is the desired behavior for listing pending tasks.
 * 
 * 3.  **User Interface (`main` and `run` methods):**
 *     *   The `main` method creates an instance of `ProjectScheduler` and calls its `run` method to start the application loop.
 *     *   The `run` method contains the main application loop. It uses `Scanner` to read user input from `System.in`.
 *     *   A `while` loop keeps the application running until the user chooses to exit.
 *     *   A `switch` statement is used to handle the user's integer choice, directing execution to the appropriate `ProjectScheduler` method (`addTask`, `processNextTask`, etc.).
 *     *   Input validation for the menu choice handles `InputMismatchException` if the user enters non-integer input, printing an error to `System.err` and consuming the invalid input to prevent an infinite loop.
 *     *   `scanner.nextLine()` is used after `scanner.nextInt()` to consume the remaining newline character, preventing issues with subsequent `nextLine()` calls when reading the task description.
 * 
 * 4.  **Error Handling and Output:**
 *     *   `System.out` is used for all standard output, including the menu, task listings, and success messages.
 *     *   `System.err` is used specifically for printing error messages, making them visually distinct and directing them to the standard error stream, which is good practice.
 *     *   A `try-catch(Exception e)` block surrounds the main `while` loop in the `run` method. This provides "class-wide" exception handling as requested, catching any unexpected runtime exceptions that might occur within the main application flow and printing an error message to `System.err`. A more specific `try-catch` is also used around `scanner.nextInt()` to handle `InputMismatchException` specifically. The `finally` block ensures the `Scanner` is closed when the `run` method exits.
 * 
 * 5.  **Best Practices:**
 *     *   Encapsulation is applied in both `Task` and `ProjectScheduler`.
 *     *   Method and variable names (`addTask`, `taskQueue`, `allTasks`, `processNextTask`, `description`, `status`) are descriptive.
 *     *   Basic Javadoc comments explain the purpose of classes and methods.
 *     *   Input validation for task descriptions and menu choices is included.
 *     *   Error handling uses `System.err` and `try-catch`.
 *     *   The code is structured logically with separate classes for data (`Task`) and logic (`ProjectScheduler`).
 * 
 * This solution effectively integrates the required Java components into a practical, albeit simple, application, demonstrating understanding of collections, control flow, object-oriented principles, and error handling.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.InputMismatchException;

// Enum for task status
enum TaskStatus {
    PENDING,
    PROCESSING,
    COMPLETED,
    FAILED
}

// Represents a single task
class Task {
    private int id;
    private String description;
    private TaskStatus status;

    /**
     * Constructs a new Task.
     *
     * @param id The unique ID for the task.
     * @param description The description of the task.
     */
    public Task(int id, String description) {
        if (description == null || description.trim().isEmpty()) {
            throw new IllegalArgumentException("Task description cannot be null or empty.");
        }
        this.id = id;
        this.description = description.trim();
        this.status = TaskStatus.PENDING; // New tasks start as PENDING
    }

    // Getters
    public int getId() {
        return id;
    }

    public String getDescription() {
        return description;
    }

    public TaskStatus getStatus() {
        return status;
    }

    /**
     * Sets the status of the task.
     *
     * @param status The new status for the task.
     */
    public void setStatus(TaskStatus status) {
        this.status = status;
    }

    @Override
    public String toString() {
        return "Task ID: " + id + ", Description: " + description + ", Status: " + status;
    }
}

// Manages the collection and processing of tasks
public class ProjectScheduler {
    private List<Task> allTasks; // List to store all tasks ever created
    private Queue<Task> taskQueue; // Queue for tasks waiting to be processed (PENDING)
    private int nextTaskId; // Counter for generating unique task IDs

    /**
     * Constructs a new ProjectScheduler.
     */
    public ProjectScheduler() {
        allTasks = new ArrayList<>(); // Use ArrayList for the List
        taskQueue = new LinkedList<>(); // Use LinkedList as a Queue implementation
        nextTaskId = 1; // Start task IDs from 1
    }

    /**
     * Adds a new task to the system.
     * Creates a Task object, adds it to the list of all tasks,
     * and adds it to the processing queue.
     *
     * @param description The description of the task.
     */
    public void addTask(String description) {
        try {
            Task newTask = new Task(nextTaskId++, description);
            allTasks.add(newTask);
            taskQueue.offer(newTask); // Add to the end of the queue
            System.out.println("Task added: " + newTask.toString());
        } catch (IllegalArgumentException e) {
            System.err.println("Error adding task: " + e.getMessage());
        }
    }

    /**
     * Processes the next task in the queue.
     * Retrieves the task, updates its status to PROCESSING and then COMPLETED.
     * Reports an error if the queue is empty.
     */
    public void processNextTask() {
        Task taskToProcess = taskQueue.poll(); // Retrieve and remove the head of the queue
        if (taskToProcess == null) {
            System.err.println("No tasks in the queue to process.");
        } else {
            System.out.println("Processing task: " + taskToProcess.getId() + " - " + taskToProcess.getDescription());
            taskToProcess.setStatus(TaskStatus.PROCESSING);
            // Simulate work...
            taskToProcess.setStatus(TaskStatus.COMPLETED);
            System.out.println("Task completed: " + taskToProcess.getId());
        }
    }

    /**
     * Lists all tasks ever added to the system.
     */
    public void listAllTasks() {
        System.out.println("\n--- All Tasks ---");
        if (allTasks.isEmpty()) {
            System.out.println("No tasks have been added yet.");
        } else {
            for (Task task : allTasks) {
                System.out.println(task);
            }
        }
        System.out.println("-----------------");
    }

    /**
     * Lists tasks currently in the processing queue (PENDING).
     */
    public void listPendingTasks() {
        System.out.println("\n--- Pending Tasks in Queue ---");
        if (taskQueue.isEmpty()) {
            System.out.println("The task queue is empty.");
        } else {
            // Iterate over the queue without removing elements
            taskQueue.forEach(System.out::println);
        }
        System.out.println("----------------------------");
    }

    /**
     * Displays the main menu options.
     */
    private void displayMenu() {
        System.out.println("\n--- Project Scheduler Menu ---");
        System.out.println("1. Add New Task");
        System.out.println("2. Process Next Task");
        System.out.println("3. List All Tasks");
        System.out.println("4. List Pending Tasks");
        System.out.println("5. Exit");
        System.out.print("Enter your choice: ");
    }

    /**
     * Runs the main application loop.
     * Handles user input and delegates actions.
     */
    public void run() {
        Scanner scanner = new Scanner(System.in);
        boolean running = true;

        // Class-wide exception handling for the main loop
        try {
            while (running) {
                displayMenu();
                int choice = -1;
                try {
                    choice = scanner.nextInt();
                } catch (InputMismatchException e) {
                    System.err.println("Invalid input. Please enter a number.");
                    scanner.next(); // Consume the invalid input
                    continue; // Skip to the next iteration
                } finally {
                     // Consume the newline character left by nextInt()
                     // unless it's the last operation before closing scanner
                }

                scanner.nextLine(); // Consume the rest of the line after the number

                switch (choice) {
                    case 1:
                        System.out.print("Enter task description: ");
                        String description = scanner.nextLine();
                        addTask(description);
                        break;
                    case 2:
                        processNextTask();
                        break;
                    case 3:
                        listAllTasks();
                        break;
                    case 4:
                        listPendingTasks();
                        break;
                    case 5:
                        System.out.println("Exiting Project Scheduler. Goodbye!");
                        running = false;
                        break;
                    default:
                        System.err.println("Invalid choice. Please enter a number between 1 and 5.");
                }
            }
        } catch (Exception e) {
            // Generic catch-all for unexpected errors in the main loop
            System.err.println("An unexpected error occurred: " + e.getMessage());
            e.printStackTrace(); // Print stack trace for debugging
        } finally {
            scanner.close(); // Ensure scanner is closed
            System.out.println("Scanner closed.");
        }
    }

    public static void main(String[] args) {
        ProjectScheduler scheduler = new ProjectScheduler();
        scheduler.run();
    }
}
