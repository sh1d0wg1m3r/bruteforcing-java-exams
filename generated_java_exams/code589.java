/*
 * Exam Question #589
 * Generated on: 2025-05-12 16:11:25
 * Generated by: Account 3
 * 
 * QUESTION:
 * ## Advanced Java Programming Exam Task: Print Job Management System
 * 
 * **Objective:** Design and implement a console-based application in Java that simulates a basic print job management system. This task requires demonstrating proficiency in using core Java collections, input handling, control flow, exception handling, and object-oriented programming principles.
 * 
 * **Scenario:** You need to build a system that allows users to add print jobs, process them in the order they were received, and view lists of pending and completed jobs.
 * 
 * **Requirements:**
 * 
 * 1.  **`PrintJob` Class:**
 *     *   Create a public class named `PrintJob`.
 *     *   It must have private instance variables: an integer `jobId`, a `String` `fileName`, and a `String` `userName`.
 *     *   `jobId` should be automatically assigned sequentially, starting from 1, when a new `PrintJob` object is created. Use a static class variable for this purpose.
 *     *   Include a constructor that takes `fileName` and `userName` as arguments.
 *     *   Implement public getter methods for `jobId`, `fileName`, and `userName`.
 *     *   Add a private boolean instance variable `processed` initialized to `false`.
 *     *   Implement a public method `markProcessed()` that sets the `processed` flag to `true`.
 *     *   Override the `toString()` method to provide a user-friendly representation of the print job (including ID, file name, user, and status).
 *     *   The constructor must validate that `fileName` and `userName` are not null or empty strings (after trimming whitespace). If validation fails, throw an `IllegalArgumentException`.
 * 
 * 2.  **`PrintManager` Class:**
 *     *   Create a public class named `PrintManager`.
 *     *   It must use a `java.util.Queue<PrintJob>` to store pending print jobs. Use the `java.util.LinkedList` implementation for the queue.
 *     *   It must use a `java.util.List<PrintJob>` to store processed print jobs. Use the `java.util.ArrayList` implementation for the list.
 *     *   Implement the following public methods:
 *         *   `addJob(String fileName, String userName)`: Creates a new `PrintJob` object (handling potential `IllegalArgumentException` from the constructor) and adds it to the pending queue. Print a success message to `System.out` or an error message to `System.err` if validation fails.
 *         *   `processNextJob()`: Removes the job at the front of the pending queue. Mark the job as processed and add it to the processed list. If the pending queue is empty, print an error message to `System.err`. **Challenge:** Simulate a processing error: if the `fileName` of the job contains the word "error" (case-insensitive), print a processing error message to `System.err` and discard the job (do not add it to the processed list).
 *         *   `viewPendingJobs()`: Iterate through and print the details of all jobs currently in the pending queue to `System.out`. Report if the queue is empty.
 *         *   `viewProcessedJobs()`: Iterate through and print the details of all jobs in the processed list to `System.out`. Report if the list is empty.
 *         *   `start()`: This method should contain the main application loop. It must:
 *             *   Display a menu of options to the user (Add Job, Process Next, View Pending, View Processed, Exit).
 *             *   Use `java.util.Scanner` to read the user's menu choice and any required job details.
 *             *   Use a `switch` statement to handle the user's choice and call the appropriate methods.
 *             *   The loop should continue until the user selects the 'Exit' option.
 * 
 * 3.  **Input, Output, and Error Handling:**
 *     *   Use `java.util.Scanner` for all user input.
 *     *   Use `System.out.println` for displaying the menu, prompts, successful operations, and job listings.
 *     *   Use `System.err.println` for *all* error messages, including:
 *         *   Invalid menu choices.
 *         *   Input validation errors (empty file/user names).
 *         *   Attempting to process from an empty queue.
 *         *   Simulated processing errors.
 *     *   Implement **class-wide exception handling** in the `start()` method using a `try-catch` block that wraps the main application loop (`while` loop and `switch` statement) to catch and report any unexpected `RuntimeException` or `Exception` using `System.err`.
 *     *   Handle `InputMismatchException` specifically when reading the menu choice to prevent crashes on non-integer input. Use `System.err` for this error.
 *     *   Ensure the `Scanner` resource is closed properly when the application exits.
 * 
 * 4.  **Best Practices:**
 *     *   Apply proper encapsulation (private fields, public methods).
 *     *   Use meaningful names for classes, variables, and methods.
 *     *   Include appropriate comments and documentation (e.g., Javadoc for public methods).
 *     *   Structure your code logically into classes and methods.
 * 
 * **Expected Output:**
 * 
 * The program should provide a clear menu and respond to user input as described in the requirements. Error messages should be distinct (using `System.err`). Job details should be printed clearly.
 * 
 * **Example Interaction Snippet:**
 * 
 * ```
 * --- Print Job Manager ---
 * 
 * Select an option:
 * 1. Add Print Job
 * 2. Process Next Job
 * 3. View Pending Jobs
 * 4. View Processed Jobs
 * 5. Exit
 * Enter your choice: 1
 * Enter file name: document.txt
 * Enter user name: alice
 * Job added: document.txt (ID: 1)
 * 
 * Select an option:
 * ...
 * Enter your choice: 1
 * Enter file name: report_error.pdf
 * Enter user name: bob
 * Job added: report_error.pdf (ID: 2)
 * 
 * Select an option:
 * ...
 * Enter your choice: 3
 * --- Pending Print Jobs ---
 * Job ID: 1, File: document.txt, User: alice, Status: PENDING
 * Job ID: 2, File: report_error.pdf, User: bob, Status: PENDING
 * Total pending jobs: 2
 * --------------------------
 * 
 * Select an option:
 * ...
 * Enter your choice: 2
 * Processed Job ID 1: document.txt
 * 
 * Select an option:
 * ...
 * Enter your choice: 2
 * Simulating processing error for Job ID 2: report_error.pdf
 * 
 * Select an option:
 * ...
 * Enter your choice: 4
 * --- Processed Print Jobs ---
 * Job ID: 1, File: document.txt, User: alice, Status: PROCESSED
 * Total processed jobs: 1
 * --------------------------
 * 
 * Select an option:
 * ...
 * Enter your choice: 6
 * Invalid choice. Please try again.
 * 
 * Select an option:
 * ...
 * Enter your choice: abc
 * Invalid input. Please enter a number.
 * 
 * Select an option:
 * ...
 * Enter your choice: 5
 * Exiting Print Job Manager.
 * Scanner closed.
 * ```
 * 
 * Submit the complete Java code for the `PrintJob`, `PrintManager`, and a `Main` class to run the application.
 *
 * EXPLANATION:
 * The provided solution implements a `Print Job Management System` as requested, demonstrating the use of various core Java concepts and adhering to best practices.
 * 
 * 1.  **`PrintJob` Class:**
 *     *   This class encapsulates the data for a single print job (`jobId`, `fileName`, `userName`, `processed`).
 *     *   `jobId` is managed using a `static int nextJobId` to ensure uniqueness across all job instances.
 *     *   The constructor includes input validation using `if` checks and throws an `IllegalArgumentException` for invalid inputs, demonstrating specific error conditions.
 *     *   Private fields and public getters/methods (`markProcessed`) ensure proper encapsulation.
 *     *   The `toString()` method provides a clear representation for output.
 * 
 * 2.  **`PrintManager` Class:**
 *     *   This class manages the collection of jobs.
 *     *   `pendingJobs` is declared as a `Queue<PrintJob>` and initialized with `new LinkedList<>()`. This fulfills the requirement for using a `Queue` and a specific implementation (`LinkedList`). The `Queue` interface methods like `offer()` (for adding) and `poll()` (for removing from the head) are used, respecting the FIFO nature of a print queue. `peek()` is used to inspect the next job without removing it for the simulated error check.
 *     *   `processedJobs` is declared as a `List<PrintJob>` and initialized with `new ArrayList<>()`. This fulfills the requirement for using the `List` interface and the `ArrayList` implementation. Processed jobs are added to this list.
 *     *   The `addJob` method demonstrates handling an exception (`IllegalArgumentException`) thrown by another class (`PrintJob`), printing the error message to `System.err`.
 *     *   The `processNextJob` method checks for an empty queue using `isEmpty()` before attempting to process, printing an error to `System.err` if empty. It also includes a simulated processing error based on the file name, discarding the job and reporting the error to `System.err`.
 *     *   `viewPendingJobs` and `viewProcessedJobs` iterate through the respective collections and print job details to `System.out`. Iterating through the `Queue` using a for-each loop is a standard way to view elements without removing them.
 * 
 * 3.  **User Interface and Interaction:**
 *     *   The `start()` method contains the main application loop.
 *     *   A `Scanner` is used to read input from `System.in`.
 *     *   A `switch` statement is used to control the flow based on the user's integer choice from the menu, calling the appropriate `PrintManager` methods. This fulfills the `Scanner` and `switch` requirements.
 *     *   `System.out.println` is used for all normal output, including the menu, prompts, and job listings.
 *     *   `System.err.println` is used exclusively for error messages, making them stand out from normal output. This fulfills the `System.out` and `System.err` requirements.
 * 
 * 4.  **Error Handling and Validation:**
 *     *   Input validation for file/user names is done in the `PrintJob` constructor, throwing `IllegalArgumentException`. This is caught and reported in `addJob`.
 *     *   Empty queue handling in `processNextJob` uses an `if` check and `System.err`.
 *     *   A specific `try-catch(InputMismatchException)` block is used within the loop in `start()` to handle cases where the user enters non-integer input for the menu choice. This prevents the program from crashing and prompts the user to try again, consuming the invalid input from the scanner.
 *     *   A broader `try-catch(Exception e)` block wraps the entire `while` loop in the `start()` method. This serves as the **class-wide exception handling** mechanism, catching any other unexpected runtime exceptions that might propagate up from method calls within the loop (e.g., `NullPointerException` if there was a logic error, though the code is designed to prevent common ones). This fulfills the requirement for class-wide exception handling.
 *     *   A `finally` block ensures the `Scanner` resource is closed when the `start()` method exits, whether normally or due to an exception, preventing resource leaks.
 * 
 * 5.  **Best Practices:**
 *     *   Encapsulation is used in `PrintJob` and `PrintManager` by keeping state private and exposing functionality through public methods.
 *     *   Variable and method names are descriptive (e.g., `pendingJobs`, `processNextJob`, `fileName`).
 *     *   Javadoc comments are provided for public methods and classes, explaining their purpose and parameters.
 *     *   The code is structured logically into three classes (`Main`, `PrintManager`, `PrintJob`) with clear responsibilities.
 * 
 * This solution effectively demonstrates the required Java components in a practical, cohesive application, incorporating essential error handling and best practices suitable for an advanced programming exam.
 */

package com.example.printsystem;

import java.util.Queue;
import java.util.LinkedList;
import java.util.List;
import java.util.ArrayList;
import java.util.Scanner;
import java.util.InputMismatchException;

/**
 * Represents a single print job with details and status.
 */
class PrintJob {
    private static int nextJobId = 1; // Static counter for unique job IDs

    private int jobId;
    private String fileName;
    private String userName;
    private boolean processed;

    /**
     * Constructs a new PrintJob.
     *
     * @param fileName The name of the file to print.
     * @param userName The user submitting the job.
     * @throws IllegalArgumentException if fileName or userName is null or empty.
     */
    public PrintJob(String fileName, String userName) {
        // Input validation
        if (fileName == null || fileName.trim().isEmpty()) {
            throw new IllegalArgumentException("File name cannot be empty.");
        }
        if (userName == null || userName.trim().isEmpty()) {
            throw new IllegalArgumentException("User name cannot be empty.");
        }

        this.jobId = nextJobId++; // Assign unique ID and increment counter
        this.fileName = fileName.trim();
        this.userName = userName.trim();
        this.processed = false;
    }

    // --- Getters ---
    public int getJobId() {
        return jobId;
    }

    public String getFileName() {
        return fileName;
    }

    public String getUserName() {
        return userName;
    }

    public boolean isProcessed() {
        return processed;
    }

    /**
     * Marks this print job as processed.
     */
    public void markProcessed() {
        this.processed = true;
    }

    /**
     * Provides a string representation of the print job.
     *
     * @return Formatted string describing the job.
     */
    @Override
    public String toString() {
        return "Job ID: " + jobId + ", File: " + fileName + ", User: " + userName + ", Status: " + (processed ? "PROCESSED" : "PENDING");
    }
}

/**
 * Manages the queue of print jobs and processed jobs.
 */
class PrintManager {
    // Use LinkedList as a Queue implementation for pending jobs (FIFO)
    private Queue<PrintJob> pendingJobs;
    // Use ArrayList as a List implementation for processed jobs
    private List<PrintJob> processedJobs;

    /**
     * Constructs a new PrintManager, initializing the job queues/lists.
     */
    public PrintManager() {
        this.pendingJobs = new LinkedList<>();
        this.processedJobs = new ArrayList<>();
    }

    /**
     * Adds a new print job to the pending queue.
     * Handles potential validation errors during job creation.
     *
     * @param fileName The name of the file for the job.
     * @param userName The user submitting the job.
     */
    public void addJob(String fileName, String userName) {
        try {
            // PrintJob constructor handles validation and throws IllegalArgumentException
            PrintJob newJob = new PrintJob(fileName, userName);
            pendingJobs.offer(newJob); // offer() is preferred over add() for queues
            System.out.println("Job added: " + newJob.getFileName() + " (ID: " + newJob.getJobId() + ")");
        } catch (IllegalArgumentException e) {
            // Catch validation errors from PrintJob constructor
            System.err.println("Error adding job: " + e.getMessage());
            // Note: nextJobId is incremented in PrintJob constructor *before* validation.
            // A robust system might need to manage IDs differently or decrement on failure.
            // For this exam, we accept the potential ID skip on validation error for simplicity.
        }
    }

    /**
     * Processes the next job from the pending queue.
     * Simulates processing errors and moves successful jobs to the processed list.
     */
    public void processNextJob() {
        if (pendingJobs.isEmpty()) {
            System.err.println("No jobs in the pending queue to process.");
            return;
        }

        // Peek at the next job without removing it yet
        PrintJob jobToProcess = pendingJobs.peek();

        // Simulate a processing error based on file name
        if (jobToProcess != null && jobToProcess.getFileName().toLowerCase().contains("error")) {
            System.err.println("Simulating processing error for Job ID " + jobToProcess.getJobId() + ": " + jobToProcess.getFileName());
            pendingJobs.poll(); // Remove the job from the queue as it failed processing
            // The job is discarded and not added to the processed list
            return;
        }

        // If no simulated error, proceed with processing
        jobToProcess = pendingJobs.poll(); // Remove the job from the pending queue

        if (jobToProcess != null) { // Should not be null because of isEmpty check, but defensive
            jobToProcess.markProcessed(); // Mark the job as processed
            processedJobs.add(jobToProcess); // Add the job to the processed list
            System.out.println("Processed Job ID " + jobToProcess.getJobId() + ": " + jobToProcess.getFileName());
        }
    }

    /**
     * Displays all jobs currently waiting in the pending queue.
     */
    public void viewPendingJobs() {
        System.out.println("\n--- Pending Print Jobs ---");
        if (pendingJobs.isEmpty()) {
            System.out.println("No pending jobs.");
        } else {
            // Iterate through the queue using for-each loop (uses iterator)
            int count = 0;
            for (PrintJob job : pendingJobs) {
                System.out.println(job); // Print job details using PrintJob's toString()
                count++;
            }
            System.out.println("Total pending jobs: " + count);
        }
        System.out.println("--------------------------\n");
    }

    /**
     * Displays all jobs that have been successfully processed.
     */
    public void viewProcessedJobs() {
        System.out.println("\n--- Processed Print Jobs ---");
        if (processedJobs.isEmpty()) {
            System.out.println("No processed jobs.");
        } else {
            // Iterate through the List
            for (PrintJob job : processedJobs) {
                System.out.println(job); // Print job details
            }
            System.out.println("Total processed jobs: " + processedJobs.size());
        }
        System.out.println("--------------------------\n");
    }

    /**
     * Displays the main menu options to the user.
     */
    private void printMenu() {
        System.out.println("\nSelect an option:");
        System.out.println("1. Add Print Job");
        System.out.println("2. Process Next Job");
        System.out.println("3. View Pending Jobs");
        System.out.println("4. View Processed Jobs");
        System.out.println("5. Exit");
    }

    /**
     * Starts the interactive print management system application loop.
     * Includes main menu handling, input reading, and exception handling.
     */
    public void start() {
        Scanner scanner = new Scanner(System.in);
        System.out.println("--- Print Job Manager ---");

        // Class-wide exception handling for the main application loop
        try {
            while (true) {
                printMenu();
                int choice = -1; // Default invalid choice

                try {
                    System.out.print("Enter your choice: ");
                    choice = scanner.nextInt();
                    // Consume the rest of the line after reading the integer
                    scanner.nextLine();
                } catch (InputMismatchException e) {
                    // Handle non-integer input specifically
                    System.err.println("Invalid input. Please enter a number.");
                    scanner.nextLine(); // Consume the invalid input to prevent infinite loop
                    continue; // Skip the rest of this loop iteration and show menu again
                }

                // Use switch statement for flow control based on valid integer choice
                switch (choice) {
                    case 1:
                        System.out.print("Enter file name: ");
                        String fileName = scanner.nextLine();
                        System.out.print("Enter user name: ");
                        String userName = scanner.nextLine();
                        addJob(fileName, userName); // addJob handles its own validation errors
                        break;
                    case 2:
                        processNextJob(); // processNextJob handles empty queue and simulated errors
                        break;
                    case 3:
                        viewPendingJobs();
                        break;
                    case 4:
                        viewProcessedJobs();
                        break;
                    case 5:
                        System.out.println("Exiting Print Job Manager.");
                        return; // Exit the start method, ending the application loop
                    default:
                        // Handle valid integer input that is not a menu option
                        System.err.println("Invalid choice. Please try again.");
                }
            }
        } catch (Exception e) {
            // Catch any other unexpected runtime exceptions that might occur
            // This serves as the broad "class-wide" handler for the main loop
            System.err.println("An unexpected error occurred during application execution: " + e.getMessage());
            e.printStackTrace(); // Print stack trace for debugging unexpected errors
        } finally {
            // Ensure the scanner resource is closed regardless of how the try block exits
            if (scanner != null) {
                scanner.close();
                System.out.println("Scanner resource closed.");
            }
        }
    }
}

/**
 * Main class to run the Print Job Management System.
 */
public class Main {
    public static void main(String[] args) {
        PrintManager manager = new PrintManager();
        manager.start(); // Start the application loop
    }
}
