/*
 * Exam Question #921
 * Generated on: 2025-05-12 16:59:52
 * Generated by: Account 1
 * 
 * QUESTION:
 * **Subject:** Advanced Java Programming
 * **Task Title:** System Resource Manager Simulation
 * 
 * **Problem Description:**
 * 
 * You are tasked with creating a simplified simulation of a System Resource Manager. This manager handles incoming tasks, processes them based on their type, and keeps track of tasks that are pending, successfully processed, or failed.
 * 
 * The system should operate interactively, accepting commands from the user to add tasks, process the next task in the queue, and list the status of tasks.
 * 
 * **Requirements:**
 * 
 * 1.  **Task Representation:**
 *     *   Create a `Task` class.
 *     *   Each `Task` must have:
 *         *   A unique integer `id` (automatically assigned).
 *         *   A `TaskType` (e.g., `CPU_INTENSIVE`, `IO_BOUND`, `NETWORK_REQUEST`) using an `enum`.
 *         *   A `String` `description`.
 *         *   A `TaskStatus` (e.g., `PENDING`, `PROCESSED`, `FAILED`) using an `enum`.
 *     *   Implement appropriate getters and setters (at least for status).
 *     *   Override `toString()` for easy printing.
 * 
 * 2.  **Resource Manager:**
 *     *   Create a `ResourceManager` class.
 *     *   It must internally manage:
 *         *   A queue of tasks waiting to be processed.
 *         *   A list of tasks that have been successfully processed.
 *         *   A list of tasks that have failed processing.
 *     *   Implement the following public methods:
 *         *   `addTask(Task task)`: Adds a task to the pending queue.
 *         *   `processNextTask()`: Takes the next task from the pending queue, simulates processing based on its type, updates its status, and moves it to either the processed or failed list.
 *         *   `listPendingTasks()`: Prints details of all tasks currently in the pending queue.
 *         *   `listProcessedTasks()`: Prints details of all tasks in the processed list.
 *         *   `listFailedTasks()`: Prints details of all tasks in the failed list.
 * 
 * 3.  **User Interface:**
 *     *   Implement a `main` method within the `ResourceManager` class (or a separate class, but keeping it together is fine for this exam).
 *     *   Use `java.util.Scanner` to read commands from the console.
 *     *   Implement a command loop that accepts the following commands:
 *         *   `add`: Prompts the user for task type and description, then creates and adds a new task.
 *         *   `process`: Calls the `processNextTask()` method.
 *         *   `list pending`: Calls `listPendingTasks()`.
 *         *   `list processed`: Calls `listProcessedTasks()`.
 *         *   `list failed`: Calls `listFailedTasks()`.
 *         *   `list all`: Calls all three list methods.
 *         *   `help`: Displays available commands.
 *         *   `exit`: Terminates the application.
 *     *   Use a `switch` statement to handle the user commands.
 * 
 * 4.  **Core Java Concepts Implementation:**
 *     *   You **must** use `java.util.Queue` for the pending tasks. Use a concrete implementation like `LinkedList`.
 *     *   You **must** use `java.util.ArrayList` for the processed and failed task lists.
 *     *   You **must** declare the processed and failed task lists using the `java.util.List` interface type.
 *     *   You **must** use `java.util.Scanner` for all user input.
 *     *   You **must** use a `switch` statement for command processing in the `main` method and/or for task type simulation in `processNextTask`.
 *     *   You **must** use `System.err` to print error messages (e.g., invalid input, processing errors, trying to process when the queue is empty).
 *     *   You **must** use `System.out` for all normal output (prompts, success messages, list contents, help).
 *     *   Implement class-wide exception handling using `try-catch` blocks. Specifically, wrap the core logic within the `processNextTask` method and the command processing loop in `main` with `try-catch` blocks to handle potential runtime issues or simulated processing failures gracefully.
 * 
 * 5.  **Best Practices:**
 *     *   Apply proper encapsulation (`private` fields, `public` methods).
 *     *   Use meaningful variable and method names.
 *     *   Include appropriate comments and basic documentation (like Javadoc for classes/methods).
 *     *   Implement basic input validation (e.g., check if task description is empty, handle invalid task types).
 *     *   Ensure proper error handling as specified above.
 *     *   Structure your code clearly.
 * 
 * **Simulating Task Processing:**
 * Inside `processNextTask()`, simulate processing time (e.g., using `Thread.sleep`) and a chance of failure for different task types. If an exception occurs during simulation (either real or simulated by throwing one), the task should be moved to the failed list. Otherwise, it moves to the processed list.
 * 
 * **Expected Output:**
 * The output should be interactive, showing prompts, command output, and error messages appropriately using `System.out` and `System.err`. Listing commands should display the current tasks in the respective collections.
 * 
 * **Example Interaction Flow:**
 * ```
 * System Resource Manager
 * Enter 'help' for options.
 * > add
 * Enter task type (CPU, IO, NETWORK): CPU
 * Enter task description: Calculate pi to 1 million digits
 * Task added to queue: Task{id=1, type=CPU_INTENSIVE, desc='Calculate pi to 1 million digits', status=PENDING}
 * > add
 * Enter task type (CPU, IO, NETWORK): IO
 * Enter task description: Backup database
 * Task added to queue: Task{id=2, type=IO_BOUND, desc='Backup database', status=PENDING}
 * > list pending
 * --- Pending Tasks ---
 * 1. Task{id=1, type=CPU_INTENSIVE, desc='Calculate pi to 1 million digits', status=PENDING}
 * 2. Task{id=2, type=IO_BOUND, desc='Backup database', status=PENDING}
 * ---------------------
 * > process
 * Processing task: Task{id=1, type=CPU_INTENSIVE, desc='Calculate pi to 1 million digits', status=PENDING}
 * Simulating CPU intensive work...
 * Task processed successfully: 1
 * > process
 * Processing task: Task{id=2, type=IO_BOUND, desc='Backup database', status=PENDING}
 * Simulating I/O operations...
 * Task processing failed for task 2: I/O error simulation failed task 2 (or similar error message)
 * > list processed
 * --- Processed Tasks ---
 * 1. Task{id=1, type=CPU_INTENSIVE, desc='Calculate pi to 1 million digits', status=PROCESSED}
 * -----------------------
 * > list failed
 * --- Failed Tasks ---
 * 1. Task{id=2, type=IO_BOUND, desc='Backup database', status=FAILED}
 * --------------------
 * > list pending
 * --- Pending Tasks ---
 * No pending tasks.
 * ---------------------
 * > exit
 * Exiting System Resource Manager.
 * ```
 * 
 * This task assesses your ability to integrate various core Java data structures, control flow mechanisms, exception handling, and object-oriented principles to build a functional, interactive application simulation.
 *
 * EXPLANATION:
 * This solution implements a System Resource Manager simulation demonstrating the required Java concepts and best practices.
 * 
 * 1.  **Task Class:** The `Task` class encapsulates the data for each unit of work. It includes an auto-incrementing `id`, an `enum` for `TaskType` and `TaskStatus`, a `description`, and appropriate getters/setters. The `toString()` method provides a convenient way to print task details.
 * 
 * 2.  **ResourceManager Class:** This class acts as the core of the simulation.
 *     *   It uses a `java.util.Queue<Task>` (`pendingTasks`) implemented by `java.util.LinkedList` to hold tasks waiting for processing, adhering to the FIFO principle typically associated with queues.
 *     *   It uses two `java.util.List<Task>` variables (`processedTasks` and `failedTasks`) implemented by `java.util.ArrayList` to store tasks after they have been processed or failed, fulfilling the requirement of using both `List` interface and `ArrayList` implementation.
 *     *   The `addTask` method simply adds a task to the end of the `pendingTasks` queue using `offer()`.
 *     *   The `processNextTask` method is central. It first checks if the queue is empty using `isEmpty()` and prints an error to `System.err` if it is. Otherwise, it retrieves and removes the next task using `poll()`.
 *         *   Inside `processNextTask`, a `switch` statement is used to simulate different behaviors based on `TaskType`. `Thread.sleep()` (via `TimeUnit`) simulates processing time.
 *         *   Random chance is used to simulate processing failures by explicitly throwing a `RuntimeException`.
 *         *   A `try-catch(Exception e)` block is used to wrap the simulation logic. If any exception occurs (including the simulated ones or `InterruptedException` from `sleep`), the task's status is set to `FAILED`, and it's added to the `failedTasks` list. An error message is printed to `System.err`.
 *         *   If the `try` block completes without an exception, the task's status is set to `PROCESSED`, and it's added to the `processedTasks` list. A success message is printed to `System.out`.
 *     *   The `listPendingTasks`, `listProcessedTasks`, and `listFailedTasks` methods iterate through their respective collections and print task details to `System.out`. They include checks for emptiness.
 * 
 * 3.  **User Interface (`main` method):**
 *     *   A `java.util.Scanner` is used to read user input from `System.in`.
 *     *   A `while` loop keeps the application running until the 'exit' command is given.
 *     *   A `switch` statement handles different user commands.
 *     *   Input validation is performed for the 'add' command (checking task type and description emptiness), printing errors to `System.err`.
 *     *   All normal output (prompts, command results, list contents, help) goes to `System.out`.
 *     *   **Class-wide Exception Handling:** A `try-catch(Exception mainLoopException)` block is wrapped around the main `switch` statement within the `while` loop. This demonstrates handling unexpected errors that might occur during the command parsing or initial execution steps within the main loop, ensuring the application doesn't crash abruptly and prints an error message to `System.err`.
 * 
 * 4.  **Required Components Usage:**
 *     *   `Queue`: Used for `pendingTasks`.
 *     *   `ArrayList`: Used for `processedTasks` and `failedTasks` implementations.
 *     *   `List interface`: Used for declaring `processedTasks` and `failedTasks`.
 *     *   `Scanner`: Used in `main` for input.
 *     *   `Switch statement`: Used in `main` for commands and `processNextTask` for task types.
 *     *   `System.err`: Used for all error messages.
 *     *   `System.out`: Used for all normal output.
 *     *   `try-catch`: Used in `processNextTask` for processing errors and in `main` for command loop errors.
 * 
 * 5.  **Best Practices:**
 *     *   Encapsulation is used in both `Task` and `ResourceManager`.
 *     *   Variable and method names are descriptive (e.g., `pendingTasks`, `processNextTask`).
 *     *   Basic Javadoc comments are included for classes and methods.
 *     *   Input validation is present for adding tasks.
 *     *   Error handling covers empty queue, invalid input, and processing failures using `try-catch` and `System.err`.
 *     *   The code is structured into logical classes and methods.
 * 
 * This solution effectively combines the required Java features within a practical simulation, demonstrating understanding of data structures, control flow, error handling, and basic object-oriented design.
 */

import java.util.Queue;
import java.util.LinkedList;
import java.util.List;
import java.util.ArrayList;
import java.util.Scanner;
import java.util.concurrent.TimeUnit;

/**
 * Represents a single task in the system resource manager.
 */
class Task {
    private static int nextId = 1; // For generating unique task IDs
    private int id;
    private TaskType type;
    private String description;
    private TaskStatus status;

    /**
     * Enum defining possible types of tasks.
     */
    enum TaskType {
        CPU_INTENSIVE, IO_BOUND, NETWORK_REQUEST
    }

    /**
     * Enum defining possible statuses of a task.
     */
    enum TaskStatus {
        PENDING, PROCESSED, FAILED
    }

    /**
     * Constructs a new Task.
     * @param type The type of the task.
     * @param description A brief description of the task.
     */
    public Task(TaskType type, String description) {
        this.id = nextId++; // Assign unique ID
        this.type = type;
        this.description = description;
        this.status = TaskStatus.PENDING; // Initially pending
    }

    // --- Getters ---
    public int getId() {
        return id;
    }

    public TaskType getType() {
        return type;
    }

    public String getDescription() {
        return description;
    }

    public TaskStatus getStatus() {
        return status;
    }

    // --- Setters ---
    /**
     * Sets the status of the task.
     * @param status The new status.
     */
    public void setStatus(TaskStatus status) {
        this.status = status;
    }

    /**
     * Provides a string representation of the Task.
     * @return Formatted string describing the task.
     */
    @Override
    public String toString() {
        return String.format("Task{id=%d, type=%s, desc='%s', status=%s}",
                             id, type, description, status);
    }
}

/**
 * Manages system resources and processes tasks from a queue.
 */
public class ResourceManager { // Made public for the main method entry point
    private Queue<Task> pendingTasks;
    private List<Task> processedTasks;
    private List<Task> failedTasks;

    /**
     * Constructs a new ResourceManager, initializing task collections.
     */
    public ResourceManager() {
        // Requirement: Use Queue (LinkedList implementation)
        this.pendingTasks = new LinkedList<>();
        // Requirement: Use List interface with ArrayList implementation
        this.processedTasks = new ArrayList<>();
        this.failedTasks = new ArrayList<>();
    }

    /**
     * Adds a new task to the pending queue.
     * @param task The task to add.
     */
    public void addTask(Task task) {
        if (task == null) {
            System.err.println("Error: Cannot add a null task.");
            return;
        }
        pendingTasks.offer(task); // offer() is preferred over add() for capacity-constrained queues, though LinkedList is not capacity-constrained. It's good practice.
        System.out.println("Task added to queue: " + task);
    }

    /**
     * Processes the next task from the pending queue.
     * Simulates work and potential failure.
     */
    public void processNextTask() {
        // Input validation: Check if queue is empty
        if (pendingTasks.isEmpty()) {
            System.err.println("Error: No pending tasks to process.");
            return;
        }

        // Retrieve and remove the next task from the queue
        Task currentTask = pendingTasks.poll();

        System.out.println("Processing task: " + currentTask);

        // Requirement: Class-wide exception handling (part 1: processing logic)
        try {
            // Simulate processing based on task type using switch (Requirement: Switch statement)
            switch (currentTask.getType()) {
                case CPU_INTENSIVE:
                    System.out.println("Simulating CPU intensive work...");
                    // Simulate potential failure (e.g., 10% chance)
                    if (Math.random() < 0.10) {
                        throw new RuntimeException("Simulated CPU overload failure");
                    }
                    TimeUnit.MILLISECONDS.sleep(300); // Simulate time
                    break;
                case IO_BOUND:
                    System.out.println("Simulating I/O operations...");
                    // Simulate potential failure (e.g., 5% chance)
                     if (Math.random() < 0.05) {
                        throw new RuntimeException("Simulated I/O access error");
                    }
                    TimeUnit.MILLISECONDS.sleep(200); // Simulate time
                    break;
                case NETWORK_REQUEST:
                    System.out.println("Simulating network request...");
                    // Simulate potential failure (e.g., 15% chance)
                     if (Math.random() < 0.15) {
                         throw new RuntimeException("Simulated Network timeout");
                    }
                    TimeUnit.MILLISECONDS.sleep(400); // Simulate time
                    break;
                default:
                    // Should not happen with enum, but good defensive programming
                    System.err.println("Internal Error: Unknown task type encountered.");
                    throw new IllegalArgumentException("Unknown task type: " + currentTask.getType());
            }

            // If simulation completes without throwing an exception:
            currentTask.setStatus(Task.TaskStatus.PROCESSED);
            processedTasks.add(currentTask);
            System.out.println("Task " + currentTask.getId() + " processed successfully.");

        } catch (InterruptedException ie) {
             // Handle sleep interruption specifically if needed, or let the general catch handle it
             currentTask.setStatus(Task.TaskStatus.FAILED);
             failedTasks.add(currentTask);
             System.err.println("Task " + currentTask.getId() + " processing interrupted: " + ie.getMessage());
             Thread.currentThread().interrupt(); // Restore interrupt flag
        } catch (Exception e) {
            // Catch any other exception during processing simulation
            currentTask.setStatus(Task.TaskStatus.FAILED);
            failedTasks.add(currentTask);
            // Requirement: Use System.err for error messages
            System.err.println("Task " + currentTask.getId() + " processing failed: " + e.getMessage());
        }
    }

    /**
     * Lists all tasks currently in the pending queue.
     */
    public void listPendingTasks() {
        // Requirement: Use System.out for normal output
        System.out.println("\n--- Pending Tasks ---");
        if (pendingTasks.isEmpty()) {
            System.out.println("No pending tasks.");
        } else {
            int i = 1;
            // Iterate through the queue without removing elements
            for (Task task : pendingTasks) {
                System.out.println(i++ + ". " + task);
            }
        }
        System.out.println("---------------------");
    }

    /**
     * Lists all tasks that were successfully processed.
     */
    public void listProcessedTasks() {
        // Requirement: Use System.out for normal output
        System.out.println("\n--- Processed Tasks ---");
        if (processedTasks.isEmpty()) {
            System.out.println("No tasks processed successfully yet.");
        } else {
            int i = 1;
            for (Task task : processedTasks) {
                System.out.println(i++ + ". " + task);
            }
        }
        System.out.println("-----------------------");
    }

     /**
     * Lists all tasks that failed during processing.
     */
     public void listFailedTasks() {
        // Requirement: Use System.out for normal output
        System.out.println("\n--- Failed Tasks ---");
        if (failedTasks.isEmpty()) {
            System.out.println("No tasks have failed yet.");
        } else {
            int i = 1;
            for (Task task : failedTasks) {
                System.out.println(i++ + ". " + task);
            }
        }
        System.out.println("--------------------");
    }

    /**
     * Main method to run the System Resource Manager simulation.
     * Handles user interaction and command processing.
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        ResourceManager manager = new ResourceManager();
        // Requirement: Use Scanner for user input
        Scanner scanner = new Scanner(System.in);

        System.out.println("System Resource Manager");
        System.out.println("Enter 'help' for options.");

        boolean running = true;
        while (running) {
            System.out.print("> ");
            String command = scanner.nextLine().trim().toLowerCase();

            // Requirement: Class-wide exception handling (part 2: main loop commands)
            // Catch unexpected errors during command parsing or execution setup
            try {
                // Requirement: Use switch statement for flow control
                switch (command) {
                    case "add":
                        System.out.print("Enter task type (CPU, IO, NETWORK): ");
                        String typeStr = scanner.nextLine().trim().toUpperCase();
                        Task.TaskType type = null;
                        try {
                             // Input validation: Validate task type string
                             type = Task.TaskType.valueOf(typeStr);
                        } catch (IllegalArgumentException e) {
                            // Requirement: Use System.err for error messages
                            System.err.println("Invalid task type: '" + typeStr + "'. Please use CPU, IO, or NETWORK.");
                            break; // Exit switch, continue main loop
                        }
                        System.out.print("Enter task description: ");
                        String description = scanner.nextLine().trim();
                        // Input validation: Check for empty description
                        if (description.isEmpty()) {
                            System.err.println("Task description cannot be empty.");
                            break; // Exit switch, continue main loop
                        }
                        manager.addTask(new Task(type, description));
                        break;
                    case "process":
                        manager.processNextTask();
                        break;
                    case "list pending":
                        manager.listPendingTasks();
                        break;
                    case "list processed":
                        manager.listProcessedTasks();
                        break;
                     case "list failed":
                        manager.listFailedTasks();
                        break;
                    case "list all":
                         manager.listPendingTasks();
                         manager.listProcessedTasks();
                         manager.listFailedTasks();
                         break;
                    case "help":
                        System.out.println("Available commands:");
                        System.out.println("  add          - Add a new task");
                        System.out.println("  process      - Process the next task in the queue");
                        System.out.println("  list pending - List tasks waiting in the queue");
                        System.out.println("  list processed - List tasks that were successfully processed");
                        System.out.println("  list failed  - List tasks that failed processing");
                        System.out.println("  list all     - List all tasks");
                        System.out.println("  exit         - Exit the application");
                        break;
                    case "exit":
                        running = false;
                        System.out.println("Exiting System Resource Manager.");
                        break;
                    default:
                        // Requirement: Use System.err for error messages
                        System.err.println("Unknown command: '" + command + "'. Enter 'help' for options.");
                }
            } catch (Exception mainLoopException) {
                 // Catch any unexpected exceptions that escape the specific handlers within the switch cases
                 System.err.println("An unexpected error occurred during command execution: " + mainLoopException.getMessage());
                 // mainLoopException.printStackTrace(); // Optional: for debugging purposes in an exam, maybe print stack trace
            }
        }

        scanner.close(); // Close the scanner resource
    }
}
