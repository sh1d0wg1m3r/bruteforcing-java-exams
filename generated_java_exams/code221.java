/*
 * Exam Question #221
 * Generated on: 2025-05-11 22:34:26
 * Generated by: Account 1
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Facility Maintenance Request System
 * 
 * **Objective:** Implement a command-line application to manage maintenance requests for a facility. The system should allow adding new requests, processing the oldest pending request, and viewing pending and completed requests.
 * 
 * **Requirements:**
 * 
 * 1.  **Classes:**
 *     *   `MaintenanceRequest`: Represents a single request. It must have:
 *         *   A unique integer ID (generated by the system).
 *         *   A description (String).
 *         *   A priority level (LOW, MEDIUM, HIGH) using an `enum`.
 *         *   Appropriate constructor, getters, and `toString()` method.
 *     *   `RequestManager`: Manages collections of requests. It must have:
 *         *   A `Queue` to store pending requests (FIFO order).
 *         *   A `List` to store completed requests.
 *         *   Methods to add a new request to the pending queue, process (move from pending queue to completed list), retrieve the pending queue, and retrieve the completed list.
 *         *   Handle unique ID generation for new requests.
 *     *   `FacilityMaintenanceSystem`: Contains the `main` method and handles user interaction.
 * 
 * 2.  **Functionality:**
 *     *   Present a menu to the user with options:
 *         1.  Add New Request
 *         2.  Process Next Request
 *         3.  View Pending Requests
 *         4.  View Completed Requests
 *         5.  Exit
 *     *   Use `Scanner` to read user input for menu choices and request details.
 *     *   Use a `switch` statement to handle the user's menu choice.
 *     *   When adding a request, prompt for description and priority. Validate that the priority entered by the user is one of the valid enum values.
 *     *   When processing a request, remove the oldest request from the pending queue and add it to the completed list. If the pending queue is empty, report an error.
 *     *   When viewing pending or completed requests, iterate through the respective collection and print the details of each request. Report if a list/queue is empty.
 * 
 * 3.  **Required Java Components Usage:**
 *     *   `java.util.Queue` (interface)
 *     *   `java.util.ArrayList` (concrete class for completed requests)
 *     *   `java.util.List` (interface for completed requests variable declaration)
 *     *   `java.util.Scanner`
 *     *   `switch` statement
 *     *   `System.err` (for printing error messages)
 *     *   `System.out` (for printing menu, prompts, success messages, and request details)
 *     *   Class-wide exception handling using `try-catch` blocks (at least around the main application loop to catch unexpected errors, and specific handling for input errors).
 * 
 * 4.  **Best Practices:**
 *     *   Proper encapsulation (private fields, public methods).
 *     *   Meaningful variable and method names.
 *     *   Appropriate comments and documentation (Javadocs for classes/methods, inline comments for complex logic).
 *     *   Input validation (e.g., valid priority, handling non-integer menu input).
 *     *   Proper error handling (using `try-catch`, checking for empty collections).
 *     *   Clean code structure (separation of concerns into classes).
 * 
 * **Expected Output:**
 * 
 * The program should run interactively, displaying a menu, taking user input, and printing output or error messages based on the operations performed. Example interactions:
 * 
 * ```
 * --- Maintenance Request System ---
 * 1. Add New Request
 * 2. Process Next Request
 * 3. View Pending Requests
 * 4. View Completed Requests
 * 5. Exit
 * ----------------------------------
 * Enter choice: 1
 * Enter request description: Leaky faucet in room 101
 * Enter priority (LOW, MEDIUM, HIGH): MEDIUM
 * Request added: Request [ID=1, Priority=MEDIUM, Description='Leaky faucet in room 101']
 * 
 * --- Maintenance Request System ---
 * ... (menu) ...
 * Enter choice: 1
 * Enter request description: HVAC failure in main hall
 * Enter priority (LOW, MEDIUM, HIGH): HIGH
 * Request added: Request [ID=2, Priority=HIGH, Description='HVAC failure in main hall']
 * 
 * --- Maintenance Request System ---
 * ... (menu) ...
 * Enter choice: 3
 * 
 * --- Pending Requests ---
 * Request [ID=1, Priority=MEDIUM, Description='Leaky faucet in room 101']
 * Request [ID=2, Priority=HIGH, Description='HVAC failure in main hall']
 * ------------------------
 * 
 * --- Maintenance Request System ---
 * ... (menu) ...
 * Enter choice: 2
 * Processed request: Request [ID=1, Priority=MEDIUM, Description='Leaky faucet in room 101']
 * 
 * --- Maintenance Request System ---
 * ... (menu) ...
 * Enter choice: 3
 * 
 * --- Pending Requests ---
 * Request [ID=2, Priority=HIGH, Description='HVAC failure in main hall']
 * ------------------------
 * 
 * --- Maintenance Request System ---
 * ... (menu) ...
 * Enter choice: 4
 * 
 * --- Completed Requests ---
 * Request [ID=1, Priority=MEDIUM, Description='Leaky faucet in room 101']
 * --------------------------
 * 
 * --- Maintenance Request System ---
 * ... (menu) ...
 * Enter choice: 6
 * Invalid choice. Please enter a number between 1 and 5.
 * 
 * --- Maintenance Request System ---
 * ... (menu) ...
 * Enter choice: abc
 * Invalid input. Please enter a number.
 * 
 * --- Maintenance Request System ---
 * ... (menu) ...
 * Enter choice: 2
 * No pending requests to process. (If queue is empty)
 * 
 * --- Maintenance Request System ---
 * ... (menu) ...
 * Enter choice: 5
 * Exiting system. Goodbye!
 * Scanner closed.
 * ```
 * 
 * Your solution should be a single Java file containing all necessary classes.
 *
 * EXPLANATION:
 * This solution implements a simple Facility Maintenance Request System using the required Java components and best practices.
 * 
 * 1.  **`MaintenanceRequest` Class:**
 *     *   Encapsulates the data for a single request (`id`, `description`, `priority`).
 *     *   Uses an `enum` (`Priority`) for type-safe priority levels.
 *     *   Provides a clear `toString()` method for easy printing.
 * 
 * 2.  **`RequestManager` Class:**
 *     *   Manages two collections: `pendingRequests` (a `Queue`) and `completedRequests` (a `List`).
 *     *   `pendingRequests` is declared as `Queue<MaintenanceRequest>` and instantiated using `LinkedList`, which implements the `Queue` interface, ensuring FIFO behavior for processing.
 *     *   `completedRequests` is declared as `List<MaintenanceRequest>` and instantiated using `ArrayList`, providing a dynamic array to store completed items.
 *     *   `addRequest` method adds a new request to the `pendingRequests` queue and automatically generates a unique ID using a static counter (`nextId`). Basic validation for description is included.
 *     *   `processNextRequest` uses `pendingRequests.poll()` to retrieve and remove the head of the queue (the oldest request). It returns `null` if the queue is empty, which is handled by the caller. The processed request is then added to the `completedRequests` list.
 *     *   `getPendingRequests` and `getCompletedRequests` provide access to the respective collections.
 * 
 * 3.  **`FacilityMaintenanceSystem` Class (Main Application):**
 *     *   The `main` method drives the application.
 *     *   A `Scanner` is used for all user input.
 *     *   The core logic runs in a `while` loop controlled by the `running` flag.
 *     *   **Class-wide Exception Handling:** The main `while` loop is wrapped in a `try-catch (Exception e)` block. This serves as a safety net to catch any unexpected runtime exceptions that might occur within the application loop, preventing the program from crashing abruptly and printing the error details to `System.err`.
 *     *   **Specific Input Handling:** An inner `try-catch (InputMismatchException e)` is used specifically when reading the integer menu choice. If the user enters non-integer input, this block catches the exception, prints an error message to `System.err`, consumes the invalid input from the scanner, and uses `continue` to restart the loop, prompting the user again.
 *     *   **`switch` Statement:** The `switch` statement is used to direct the program flow based on the validated user's menu choice, calling the appropriate methods in the `RequestManager`.
 *     *   **Input Validation:**
 *         *   Menu choice: Handled by the inner `try-catch` for `InputMismatchException`.
 *         *   Priority: When adding a request, `Priority.valueOf(priorityStr)` is used. This method throws `IllegalArgumentException` if the input string does not match any enum constant name. A `try-catch (IllegalArgumentException e)` block is used to catch this specific error and print a user-friendly message to `System.err`.
 *         *   Description: A check `description.trim().isEmpty()` is performed to prevent adding requests with empty descriptions, printing an error to `System.err`.
 *     *   **Error Handling:**
 *         *   Processing an empty queue: The `processNextRequest` method returns `null`. The `main` method checks for `null` and prints an error message to `System.err` if no request was processed.
 *         *   Invalid menu choice: The `default` case in the `switch` handles choices outside the 1-5 range, printing an error to `System.err`.
 *     *   **Output:** `System.out.println` is used for the menu, prompts, successful operation confirmations, and displaying the contents of the pending queue and completed list. `System.err.println` is strictly used for error messages, distinguishing them from normal output.
 *     *   **Resource Management:** The `Scanner` is closed in a `finally` block to ensure it's released regardless of whether an exception occurred.
 * 
 * This solution effectively demonstrates the required components, separation of concerns, basic input validation, and robust error handling within a practical simulation context.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.InputMismatchException;
import java.util.NoSuchElementException; // Although poll() doesn't throw this, peek() or remove() might

/**
 * Enum representing the priority levels for maintenance requests.
 */
enum Priority {
    LOW, MEDIUM, HIGH
}

/**
 * Represents a single maintenance request with a unique ID, description, and priority.
 */
class MaintenanceRequest {
    private int id;
    private String description;
    private Priority priority;

    /**
     * Constructs a new MaintenanceRequest.
     *
     * @param id The unique ID for the request.
     * @param description A brief description of the request.
     * @param priority The priority level of the request.
     */
    public MaintenanceRequest(int id, String description, Priority priority) {
        this.id = id;
        this.description = description;
        this.priority = priority;
    }

    // --- Getters ---
    public int getId() {
        return id;
    }

    public String getDescription() {
        return description;
    }

    public Priority getPriority() {
        return priority;
    }

    /**
     * Provides a string representation of the maintenance request.
     * @return A formatted string describing the request.
     */
    @Override
    public String toString() {
        return "Request [ID=" + id + ", Priority=" + priority + ", Description='" + description + "']";
    }
}

/**
 * Manages collections of maintenance requests, separating pending from completed.
 */
class RequestManager {
    private Queue<MaintenanceRequest> pendingRequests;
    private List<MaintenanceRequest> completedRequests;
    private static int nextId = 1; // Static counter for generating unique request IDs

    /**
     * Constructs a new RequestManager, initializing the pending queue and completed list.
     */
    public RequestManager() {
        // Use LinkedList as a concrete implementation of Queue
        this.pendingRequests = new LinkedList<>();
        // Use ArrayList as a concrete implementation of List
        this.completedRequests = new ArrayList<>();
    }

    /**
     * Adds a new maintenance request to the pending queue.
     * Generates a unique ID for the request.
     *
     * @param description The description of the request.
     * @param priority The priority level of the request.
     */
    public void addRequest(String description, Priority priority) {
        // Basic validation for description
        if (description == null || description.trim().isEmpty()) {
            // Error handled by caller before calling this method is better,
            // but adding a defensive check here.
             System.err.println("Error: Request description cannot be empty.");
             return; // Or throw an exception
        }
        MaintenanceRequest newRequest = new MaintenanceRequest(nextId++, description.trim(), priority);
        pendingRequests.add(newRequest); // add() throws exception on failure, offer() returns false
        System.out.println("Request added: " + newRequest);
    }

    /**
     * Processes the next pending request by removing it from the queue
     * and adding it to the list of completed requests.
     *
     * @return The MaintenanceRequest that was processed, or null if the pending queue is empty.
     */
    public MaintenanceRequest processNextRequest() {
        if (pendingRequests.isEmpty()) {
            // No requests to process
            return null;
        }
        // poll() removes and returns the head of the queue, returns null if empty
        MaintenanceRequest processed = pendingRequests.poll();
        completedRequests.add(processed);
        return processed;
    }

    /**
     * Returns the queue of pending maintenance requests.
     * @return The Queue of pending requests.
     */
    public Queue<MaintenanceRequest> getPendingRequests() {
        // In a real application, returning a copy or unmodifiable view is safer
        return pendingRequests;
    }

    /**
     * Returns the list of completed maintenance requests.
     * @return The List of completed requests.
     */
    public List<MaintenanceRequest> getCompletedRequests() {
        // In a real application, returning a copy or unmodifiable view is safer
        return completedRequests;
    }
}

/**
 * Main application class for the Facility Maintenance Request System.
 * Handles user interaction and manages the RequestManager.
 */
public class FacilityMaintenanceSystem {

    /**
     * The main entry point of the application.
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        RequestManager requestManager = new RequestManager();
        boolean running = true;

        // Class-wide exception handling using a try-catch block around the main loop
        try {
            while (running) {
                printMenu();
                int choice = -1; // Default invalid choice

                // Specific exception handling for reading the menu choice
                try {
                    System.out.print("Enter choice: ");
                    choice = scanner.nextInt();
                    scanner.nextLine(); // Consume the newline character left by nextInt()
                } catch (InputMismatchException e) {
                    System.err.println("Invalid input. Please enter a number.");
                    scanner.nextLine(); // Consume the invalid input to prevent infinite loop
                    continue; // Skip the rest of the loop and show the menu again
                }

                // Use a switch statement to handle the user's choice
                switch (choice) {
                    case 1: // Add New Request
                        System.out.print("Enter request description: ");
                        String description = scanner.nextLine();
                        if (description.trim().isEmpty()) {
                             System.err.println("Error: Request description cannot be empty.");
                             break; // Exit switch case
                        }

                        System.out.print("Enter priority (LOW, MEDIUM, HIGH): ");
                        String priorityStr = scanner.nextLine().trim().toUpperCase();
                        try {
                            // Validate priority input using enum's valueOf method
                            Priority priority = Priority.valueOf(priorityStr);
                            requestManager.addRequest(description, priority);
                        } catch (IllegalArgumentException e) {
                            // Catch exception if the priority string does not match an enum constant
                            System.err.println("Invalid priority entered. Please use LOW, MEDIUM, or HIGH.");
                        }
                        break;

                    case 2: // Process Next Request
                        MaintenanceRequest processed = requestManager.processNextRequest();
                        if (processed != null) {
                            System.out.println("Processed request: " + processed);
                        } else {
                            System.err.println("No pending requests to process.");
                        }
                        break;

                    case 3: // View Pending Requests
                        System.out.println("\n--- Pending Requests ---");
                        Queue<MaintenanceRequest> pending = requestManager.getPendingRequests();
                        if (pending.isEmpty()) {
                            System.out.println("No pending requests.");
                        } else {
                            // Iterate over the queue elements without removing them
                            pending.forEach(System.out::println);
                        }
                        System.out.println("------------------------");
                        break;

                    case 4: // View Completed Requests
                        System.out.println("\n--- Completed Requests ---");
                        List<MaintenanceRequest> completed = requestManager.getCompletedRequests();
                        if (completed.isEmpty()) {
                            System.out.println("No completed requests.");
                        } else {
                            // Iterate over the list elements
                            completed.forEach(System.out::println);
                        }
                        System.out.println("--------------------------");
                        break;

                    case 5: // Exit
                        running = false;
                        System.out.println("Exiting system. Goodbye!");
                        break;

                    default: // Invalid menu choice
                        System.err.println("Invalid choice. Please enter a number between 1 and 5.");
                }
                System.out.println(); // Add a newline for better readability between operations
            }
        } catch (Exception e) {
            // Catch any other unexpected exceptions at the top level
            System.err.println("An unexpected error occurred: " + e.getMessage());
            e.printStackTrace(System.err); // Print stack trace to the error stream for debugging
        } finally {
            // Ensure the scanner resource is closed
            scanner.close();
            // System.out.println("Scanner closed."); // Optional confirmation
        }
    }

    /**
     * Prints the main menu options to the console.
     */
    private static void printMenu() {
        System.out.println("--- Maintenance Request System ---");
        System.out.println("1. Add New Request");
        System.out.println("2. Process Next Request");
        System.out.println("3. View Pending Requests");
        System.out.println("4. View Completed Requests");
        System.out.println("5. Exit");
        System.out.println("----------------------------------");
    }
}
