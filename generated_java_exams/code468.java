/*
 * Exam Question #468
 * Generated on: 2025-05-11 23:15:28
 * Generated by: Account 1
 * 
 * QUESTION:
 * ## Advanced Java Programming Exam Task: Warehouse Logistics Simulator
 * 
 * **Problem Description:**
 * 
 * You are tasked with developing a simple command-line simulation for managing the logistics of trucks arriving, waiting, and being processed at a warehouse loading dock facility. The facility has a fixed number of loading docks. Trucks arrive and join a waiting queue. When a loading dock becomes free, the next truck from the waiting queue can be assigned to it. Once a truck finishes processing at a dock, the dock becomes free again.
 * 
 * Your program must simulate these operations based on user commands and maintain the state of the waiting queue and the loading docks.
 * 
 * **Requirements:**
 * 
 * 1.  **Core Data Structures:**
 *     *   Use `java.util.Queue` to represent the waiting line of trucks.
 *     *   Use `java.util.ArrayList` to store the available loading docks.
 *     *   Declare the collection of docks using the `java.util.List` interface type (`List<LoadingDock> loadingDocks = new ArrayList<>();`).
 * 2.  **Input:** Use `java.util.Scanner` to read commands from the standard input.
 * 3.  **Control Flow:** Use a `switch` statement to handle different user commands.
 * 4.  **Output:**
 *     *   Use `System.out` for normal status updates and command results.
 *     *   Use `System.err` for all error messages (e.g., invalid command, invalid input, operation failed).
 * 5.  **Error Handling:** Implement class-wide exception handling using `try-catch` blocks to gracefully handle potential runtime errors, especially those related to user input parsing (like `NumberFormatException`) or invalid operations (like accessing non-existent docks).
 * 6.  **Classes:**
 *     *   Create a `Truck` class with private fields for `truckId` (String) and `cargoType` (String), and public getter methods.
 *     *   Create a `LoadingDock` class with private fields for `dockIndex` (int), `isBusy` (boolean), and `currentTruck` (`Truck` object, null if free). Include public methods like `assignTruck(Truck truck)`, `releaseDock()`, `isBusy()`, `getDockIndex()`, and `getCurrentTruck()`.
 *     *   Create a main class (e.g., `WarehouseLogistics`) to manage the `Queue` and `List` of docks, process commands, and handle the simulation loop.
 * 7.  **Best Practices:**
 *     *   Implement proper encapsulation (private fields, public methods).
 *     *   Use meaningful variable and method names.
 *     *   Include appropriate comments and documentation (Javadocs or inline comments).
 *     *   Perform input validation where necessary (e.g., checking command format, validating dock indices).
 *     *   Ensure clean code structure.
 * 8.  **Simulation Setup:**
 *     *   The simulation starts with a fixed number of loading docks (e.g., 3 or 4). Initialize these docks as free.
 *     *   The waiting queue starts empty.
 * 
 * **User Commands:**
 * 
 * The program should accept the following commands (case-insensitive, but parameters are case-sensitive):
 * 
 * *   `ARRIVE <truckId> <cargoType>`: A truck with the given ID and cargo type arrives and joins the waiting queue.
 * *   `ASSIGN`: Attempts to assign the next truck from the waiting queue to the first available loading dock. If no trucks are waiting or no docks are available, print an appropriate error message to `System.err`.
 * *   `COMPLETE <dockIndex>`: Marks the loading dock at the given index as complete. The truck currently at that dock departs, and the dock becomes free. The `<dockIndex>` is 0-based. If the dock index is invalid or the dock is not busy, print an appropriate error message to `System.err`.
 * *   `STATUS`: Prints the current state of the waiting queue and each loading dock.
 * *   `EXIT`: Terminates the simulation.
 * 
 * **Expected Output Format:**
 * 
 * *   **ARRIVE:** `Truck <truckId> arrived and joined the queue.`
 * *   **ASSIGN (Success):** `Truck <truckId> assigned to Dock <dockIndex>.`
 * *   **ASSIGN (Failure - Queue Empty):** Error message to `System.err`.
 * *   **ASSIGN (Failure - No Docks):** Error message to `System.err`.
 * *   **COMPLETE (Success):** `Truck <truckId> completed at Dock <dockIndex>. Dock is now free.`
 * *   **COMPLETE (Failure - Invalid Index):** Error message to `System.err`.
 * *   **COMPLETE (Failure - Dock Not Busy):** Error message to `System.err`.
 * *   **STATUS:**
 *     ```
 *     --- Warehouse Status ---
 *     Waiting Queue: <number of trucks> trucks
 *     [ <truckId1>(<cargo1>), <truckId2>(<cargo2>), ... ] (or [ Empty ] if empty)
 *     Loading Docks:
 *     Dock 0: <Status: Busy with Truck <truckId> (<cargoType>) / Free>
 *     Dock 1: <Status: Busy with Truck <truckId> (<cargoType>) / Free>
 *     ...
 *     ------------------------
 *     ```
 * *   **EXIT:** `Simulation ending.`
 * *   **Invalid Command:** Error message to `System.err`.
 * 
 * **Example Interaction (Illustrative):**
 * 
 * ```
 * > ARRIVE T1 Electronics
 * Truck T1 arrived and joined the queue.
 * > ARRIVE T2 Furniture
 * Truck T2 arrived and joined the queue.
 * > STATUS
 * --- Warehouse Status ---
 * Waiting Queue: 2 trucks
 * [ T1(Electronics), T2(Furniture) ]
 * Loading Docks:
 * Dock 0: Free
 * Dock 1: Free
 * Dock 2: Free
 * ------------------------
 * > ASSIGN
 * Truck T1 assigned to Dock 0.
 * > ASSIGN
 * Truck T2 assigned to Dock 1.
 * > STATUS
 * --- Warehouse Status ---
 * Waiting Queue: 0 trucks
 * [ Empty ]
 * Loading Docks:
 * Dock 0: Busy with Truck T1 (Electronics)
 * Dock 1: Busy with Truck T2 (Furniture)
 * Dock 2: Free
 * ------------------------
 * > COMPLETE 0
 * Truck T1 completed at Dock 0. Dock is now free.
 * > ASSIGN
 * System.err: No trucks waiting to be assigned.
 * > COMPLETE 5
 * System.err: Invalid dock index: 5. Please provide an index between 0 and 2.
 * > COMPLETE 2
 * System.err: Dock 2 is not busy.
 * > EXIT
 * Simulation ending.
 * ```
 * 
 * Your solution should be a single Java file containing all necessary classes.
 *
 * EXPLANATION:
 * This solution implements a warehouse logistics simulator using the required Java components and best practices.
 * 
 * 1.  **Class Structure:**
 *     *   `Truck`: A simple Plain Old Java Object (POJO) representing a truck with its ID and cargo type. It uses private fields and public getters, demonstrating encapsulation. The `toString()` method provides a convenient string representation.
 *     *   `LoadingDock`: Represents a single loading dock. It tracks its index, whether it's busy, and which truck (if any) is currently assigned. The `assignTruck()` and `releaseDock()` methods manage the dock's state and include basic internal validation (throwing `IllegalStateException`) to ensure operations are valid for the current state (e.g., cannot assign to a busy dock). This demonstrates encapsulation and state management within an object.
 *     *   `WarehouseLogistics`: The main class orchestrating the simulation. It holds the primary data structures (`waitingQueue` and `loadingDocks`) and contains the logic for processing commands, managing the flow of trucks, and displaying status.
 * 
 * 2.  **Required Components Usage:**
 *     *   `java.util.Queue`: `waitingQueue` is declared as `Queue<Truck>` and instantiated as `LinkedList<Truck>`. `LinkedList` is a common implementation of `Queue`. `offer()` is used to add trucks to the end of the queue (arrival), and `poll()` is used to remove trucks from the front of the queue (assignment), following the FIFO (First-In, First-Out) principle of a queue.
 *     *   `java.util.ArrayList`: `loadingDocks` is instantiated as `ArrayList<LoadingDock>`. `ArrayList` is used here because we need to access docks by their index (`loadingDocks.get(dockIndex)`) and iterate through them to find a free one.
 *     *   `java.util.List`: `loadingDocks` is declared using the `List` interface (`List<LoadingDock>`), demonstrating the principle of programming to interfaces rather than concrete implementations.
 *     *   `java.util.Scanner`: An instance of `Scanner` reads command lines from `System.in` in the `startSimulation()` loop.
 *     *   `switch` statement: The `handleCommand()` method uses a `switch` statement to efficiently dispatch control based on the first word of the user input command.
 *     *   `System.err`: Used exclusively for printing error messages, such as invalid command format, invalid dock index, queue empty, or dock not busy.
 *     *   `System.out`: Used for all normal output, including successful command confirmations, status displays, and simulation start/end messages.
 *     *   `try-catch`:
 *         *   A `try-catch (Exception e)` block is placed around the call to `handleCommand()` in the main simulation loop (`startSimulation()`) to catch any unexpected exceptions that might occur during command processing, providing a basic level of robustness for the main loop.
 *         *   More specific `try-catch` blocks are used within `handleCommand()`:
 *             *   Around `Integer.parseInt()` in the `COMPLETE` command handling to catch `NumberFormatException` if the user provides non-integer input for the dock index.
 *         *   The `completeDock()` method includes a `try-catch (IllegalStateException e)` block around the `dock.releaseDock()` call to catch the specific exception thrown by the `LoadingDock` class if `releaseDock()` is called on a non-busy dock. This demonstrates handling exceptions thrown by other objects.
 * 
 * 3.  **Input Validation and Error Handling:**
 *     *   Command format is checked by splitting the input line and verifying the number of parts.
 *     *   The `COMPLETE` command specifically validates the dock index range (`dockIndex < 0 || dockIndex >= loadingDocks.size()`) before attempting to access the `ArrayList`.
 *     *   Business logic errors (like trying to `ASSIGN` when the queue is empty or no docks are free, or trying to `COMPLETE` a dock that isn't busy) are checked explicitly using `if` statements, and informative error messages are printed to `System.err`.
 *     *   Parsing errors (`NumberFormatException`) are caught and reported to `System.err`.
 *     *   Exceptions thrown by the `LoadingDock` methods (`IllegalStateException`) are caught in `WarehouseLogistics` and reported as errors.
 * 
 * 4.  **Best Practices:**
 *     *   Meaningful names (`waitingQueue`, `loadingDocks`, `assignTruck`, `completeDock`, `truckId`, `cargoType`).
 *     *   Encapsulation via private fields and public getters/methods in `Truck` and `LoadingDock`.
 *     *   Comments explaining the purpose of classes, methods, and key logic sections.
 *     *   Clean separation of concerns (Truck knows about truck data, LoadingDock knows about dock state, WarehouseLogistics manages the overall system).
 *     *   The `Scanner` is closed when the simulation exits.
 * 
 * 5.  **Simulation Logic:**
 *     *   `ARRIVE`: Creates a `Truck` object and adds it to the `waitingQueue` using `offer()`.
 *     *   `ASSIGN`: Checks if the queue is empty or if any dock is free. If conditions are met, it finds the first free dock, takes the next truck from the queue using `poll()`, and assigns it to the dock using the `LoadingDock` object's method.
 *     *   `COMPLETE`: Validates the dock index. If valid, it retrieves the `LoadingDock` object and calls its `releaseDock()` method.
 *     *   `STATUS`: Iterates through the queue and the list of docks to print their current state. `StringJoiner` is used for cleaner formatting of the queue contents.
 * 
 * This solution effectively integrates the required Java components into a functional simulation, demonstrating understanding of data structures, object-oriented design, input/output, control flow, and robust error handling.
 */

import java.util.Queue;
import java.util.LinkedList; // LinkedList implements Queue
import java.util.List;
import java.util.ArrayList;
import java.util.Scanner;
import java.util.StringJoiner;

/**
 * Represents a truck waiting for or assigned to a loading dock.
 */
class Truck {
    private String truckId;
    private String cargoType;

    /**
     * Constructs a new Truck object.
     * @param truckId The unique identifier for the truck.
     * @param cargoType The type of cargo the truck is carrying.
     */
    public Truck(String truckId, String cargoType) {
        this.truckId = truckId;
        this.cargoType = cargoType;
    }

    /**
     * Gets the truck's ID.
     * @return The truck ID.
     */
    public String getTruckId() {
        return truckId;
    }

    /**
     * Gets the truck's cargo type.
     * @return The cargo type.
     */
    public String getCargoType() {
        return cargoType;
    }

    @Override
    public String toString() {
        return truckId + "(" + cargoType + ")";
    }
}

/**
 * Represents a loading dock at the warehouse.
 */
class LoadingDock {
    private int dockIndex;
    private boolean isBusy;
    private Truck currentTruck;

    /**
     * Constructs a new LoadingDock object.
     * @param dockIndex The 0-based index of the dock.
     */
    public LoadingDock(int dockIndex) {
        this.dockIndex = dockIndex;
        this.isBusy = false;
        this.currentTruck = null;
    }

    /**
     * Assigns a truck to this dock.
     * @param truck The truck to assign.
     * @throws IllegalStateException if the dock is already busy.
     */
    public void assignTruck(Truck truck) {
        if (this.isBusy) {
            throw new IllegalStateException("Dock " + dockIndex + " is already busy.");
        }
        this.currentTruck = truck;
        this.isBusy = true;
    }

    /**
     * Releases the dock, making it free.
     * @return The truck that was previously assigned to this dock.
     * @throws IllegalStateException if the dock is not busy.
     */
    public Truck releaseDock() {
        if (!this.isBusy) {
            throw new IllegalStateException("Dock " + dockIndex + " is not busy.");
        }
        Truck releasedTruck = this.currentTruck;
        this.currentTruck = null;
        this.isBusy = false;
        return releasedTruck;
    }

    /**
     * Checks if the dock is currently busy.
     * @return true if the dock is busy, false otherwise.
     */
    public boolean isBusy() {
        return isBusy;
    }

    /**
     * Gets the index of the dock.
     * @return The dock index.
     */
    public int getDockIndex() {
        return dockIndex;
    }

    /**
     * Gets the truck currently assigned to this dock.
     * @return The current truck, or null if the dock is free.
     */
    public Truck getCurrentTruck() {
        return currentTruck;
    }

    @Override
    public String toString() {
        if (isBusy) {
            return "Dock " + dockIndex + ": Busy with Truck " + currentTruck.getTruckId() + " (" + currentTruck.getCargoType() + ")";
        } else {
            return "Dock " + dockIndex + ": Free";
        }
    }
}

/**
 * Manages the warehouse logistics simulation.
 */
public class WarehouseLogistics {
    private Queue<Truck> waitingQueue;
    private List<LoadingDock> loadingDocks;
    private Scanner scanner;
    private static final int NUMBER_OF_DOCKS = 3; // Fixed number of docks

    /**
     * Constructs a new WarehouseLogistics simulation.
     */
    public WarehouseLogistics() {
        this.waitingQueue = new LinkedList<>(); // LinkedList implements Queue
        this.loadingDocks = new ArrayList<>();  // ArrayList implements List
        for (int i = 0; i < NUMBER_OF_DOCKS; i++) {
            this.loadingDocks.add(new LoadingDock(i));
        }
        this.scanner = new Scanner(System.in);
    }

    /**
     * Starts the simulation loop.
     */
    public void startSimulation() {
        System.out.println("Warehouse Logistics Simulation Started (" + NUMBER_OF_DOCKS + " docks available).");
        System.out.println("Enter commands: ARRIVE <id> <cargo>, ASSIGN, COMPLETE <dockIndex>, STATUS, EXIT");

        boolean running = true;
        while (running) {
            System.out.print("> ");
            String commandLine = scanner.nextLine().trim();
            if (commandLine.isEmpty()) {
                continue;
            }

            // Use try-catch for potential errors during command processing
            try {
                running = handleCommand(commandLine);
            } catch (Exception e) {
                // Catch any unexpected exceptions during command handling
                System.err.println("An unexpected error occurred: " + e.getMessage());
                // Optionally print stack trace for debugging during development
                // e.printStackTrace(System.err);
            }
        }

        System.out.println("Simulation ending.");
        scanner.close(); // Close the scanner when done
    }

    /**
     * Handles a single command line input.
     * @param commandLine The input string from the user.
     * @return true if the simulation should continue, false if it should exit.
     */
    private boolean handleCommand(String commandLine) {
        String[] parts = commandLine.split("\\s+", 3); // Split into max 3 parts: command, param1, param2
        String command = parts[0].toUpperCase();

        switch (command) {
            case "ARRIVE":
                if (parts.length == 3) {
                    String truckId = parts[1];
                    String cargoType = parts[2];
                    arriveTruck(truckId, cargoType);
                } else {
                    System.err.println("Invalid ARRIVE command format. Usage: ARRIVE <truckId> <cargoType>");
                }
                break;

            case "ASSIGN":
                if (parts.length == 1) {
                    assignTruckToDock();
                } else {
                    System.err.println("Invalid ASSIGN command format. Usage: ASSIGN");
                }
                break;

            case "COMPLETE":
                if (parts.length == 2) {
                    try {
                        int dockIndex = Integer.parseInt(parts[1]);
                        completeDock(dockIndex);
                    } catch (NumberFormatException e) {
                        System.err.println("Invalid dock index format. Please provide an integer.");
                    }
                } else {
                    System.err.println("Invalid COMPLETE command format. Usage: COMPLETE <dockIndex>");
                }
                break;

            case "STATUS":
                if (parts.length == 1) {
                    displayStatus();
                } else {
                    System.err.println("Invalid STATUS command format. Usage: STATUS");
                }
                break;

            case "EXIT":
                if (parts.length == 1) {
                    return false; // Signal to end simulation
                } else {
                     System.err.println("Invalid EXIT command format. Usage: EXIT");
                }
                break;

            default:
                System.err.println("Unknown command: " + command + ". Available commands: ARRIVE, ASSIGN, COMPLETE, STATUS, EXIT");
                break;
        }
        return true; // Continue simulation
    }

    /**
     * Handles a truck arriving and joining the queue.
     * @param truckId The ID of the arriving truck.
     * @param cargoType The cargo type of the arriving truck.
     */
    private void arriveTruck(String truckId, String cargoType) {
        Truck newTruck = new Truck(truckId, cargoType);
        waitingQueue.offer(newTruck); // offer is safer than add as it returns false if queue is full (not the case for LinkedList)
        System.out.println("Truck " + truckId + " arrived and joined the queue.");
    }

    /**
     * Attempts to assign the next waiting truck to an available dock.
     */
    private void assignTruckToDock() {
        if (waitingQueue.isEmpty()) {
            System.err.println("No trucks waiting to be assigned.");
            return;
        }

        LoadingDock availableDock = null;
        for (LoadingDock dock : loadingDocks) {
            if (!dock.isBusy()) {
                availableDock = dock;
                break; // Found a free dock
            }
        }

        if (availableDock == null) {
            System.err.println("No loading docks currently available.");
            return;
        }

        Truck truckToAssign = waitingQueue.poll(); // Get and remove the head of the queue
        if (truckToAssign != null) { // poll returns null if queue is empty, though we checked isEmpty() already
            try {
                availableDock.assignTruck(truckToAssign);
                System.out.println("Truck " + truckToAssign.getTruckId() + " assigned to Dock " + availableDock.getDockIndex() + ".");
            } catch (IllegalStateException e) {
                 // This catch block is mostly for robustness, should not happen with the isBusy check
                 System.err.println("Failed to assign truck to dock " + availableDock.getDockIndex() + ": " + e.getMessage());
            }
        }
    }

    /**
     * Completes the process at a specific dock, making it free.
     * @param dockIndex The 0-based index of the dock to complete.
     */
    private void completeDock(int dockIndex) {
        // Input validation for dock index
        if (dockIndex < 0 || dockIndex >= loadingDocks.size()) {
            System.err.println("Invalid dock index: " + dockIndex + ". Please provide an index between 0 and " + (NUMBER_OF_DOCKS - 1) + ".");
            return;
        }

        LoadingDock dock = loadingDocks.get(dockIndex);

        try {
            Truck completedTruck = dock.releaseDock();
            System.out.println("Truck " + completedTruck.getTruckId() + " completed at Dock " + dockIndex + ". Dock is now free.");
        } catch (IllegalStateException e) {
            // Catch the exception thrown by releaseDock if it's not busy
            System.err.println("Failed to complete dock " + dockIndex + ": " + e.getMessage());
        }
    }

    /**
     * Displays the current status of the waiting queue and all loading docks.
     */
    private void displayStatus() {
        System.out.println("--- Warehouse Status ---");

        // Status of the waiting queue
        System.out.println("Waiting Queue: " + waitingQueue.size() + " trucks");
        if (waitingQueue.isEmpty()) {
            System.out.println("[ Empty ]");
        } else {
            StringJoiner sj = new StringJoiner(", ", "[ ", " ]");
            for (Truck truck : waitingQueue) {
                sj.add(truck.toString());
            }
            System.out.println(sj.toString());
        }

        // Status of loading docks
        System.out.println("Loading Docks:");
        for (LoadingDock dock : loadingDocks) {
            System.out.println(dock.toString());
        }
        System.out.println("------------------------");
    }

    /**
     * Main method to start the simulation.
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        // The main method itself is kept simple, delegating the simulation logic
        // to an instance of WarehouseLogistics. This promotes better structure.
        WarehouseLogistics simulation = new WarehouseLogistics();
        simulation.startSimulation();
    }
}
