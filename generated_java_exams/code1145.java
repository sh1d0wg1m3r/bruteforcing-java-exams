/*
 * Exam Question #1145
 * Generated on: 2025-05-12 17:31:11
 * Generated by: Account 3
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Airport Baggage Processing Simulation
 * 
 * **Scenario:**
 * 
 * You are tasked with developing a simplified simulation of an airport baggage processing system. The system receives incoming bags, processes them one by one based on a first-come, first-served principle, and sorts them into categories based on certain criteria (in this case, weight). The system should be interactive, allowing an operator to manage the process via a command-line interface.
 * 
 * **Task:**
 * 
 * Implement a Java program that simulates this baggage processing system. Your solution must adhere strictly to the requirements listed below and demonstrate a strong understanding of fundamental Java concepts, data structures, and error handling.
 * 
 * **Requirements:**
 * 
 * 1.  **Classes:**
 *     *   Create a `Bag` class representing a single piece of luggage. It should have private fields for `bagId` (an integer, auto-generated sequentially), `destination` (String), and `weight` (double). Include a constructor, public getter methods for all fields, and a meaningful `toString()` method.
 *     *   Create a `BaggageProcessingSystem` class that manages the overall process. This class will contain the main logic and data structures.
 * 
 * 2.  **Data Structures:**
 *     *   Use a `java.util.Queue<Bag>` to hold bags that are waiting to be processed (incoming bags).
 *     *   Use a `java.util.ArrayList<Bag>` to store bags that have been successfully processed and are ready for transport. This list should be referenced by a `java.util.List` interface variable (`List<Bag>`).
 *     *   Use another `java.util.ArrayList<Bag>` (also referenced by a `List` interface variable) to store bags that were processed but flagged as "oversized" based on weight.
 * 
 * 3.  **User Interface:**
 *     *   Use `java.util.Scanner` to read user input from the console.
 *     *   Implement a menu-driven interface with options for:
 *         *   Add a new incoming bag.
 *         *   Process the next bag from the incoming queue.
 *         *   View all bags currently waiting in the incoming queue.
 *         *   View all bags that have been processed (both standard and oversized).
 *         *   Exit the system.
 *     *   Use a `switch` statement to handle the different menu options.
 * 
 * 4.  **Processing Logic:**
 *     *   When processing a bag:
 *         *   Dequeue the next bag from the incoming queue.
 *         *   Simulate a weight check: If the bag's weight is greater than 23.0 kg, consider it "oversized".
 *         *   If not oversized, add the bag to the standard processed bags list.
 *         *   If oversized, add the bag to the oversized bags list.
 *         *   Provide feedback to the user about the outcome of the processing (which bag was processed and where it was placed).
 * 
 * 5.  **Error Handling:**
 *     *   Implement robust input validation using `try-catch` blocks, especially when reading numeric input (bag weight, menu choice). Handle cases where the user enters non-numeric data or invalid menu options.
 *     *   Handle the case where the user attempts to process a bag when the incoming queue is empty. Use `System.err` to report this specific error condition.
 *     *   Implement **class-wide exception handling** using a `try-catch` block that wraps the main interactive loop in the `BaggageProcessingSystem` class. This catch block should handle any unexpected runtime exceptions that might occur during the system's operation and print a generic error message to `System.err` before the program potentially terminates or attempts to continue.
 * 
 * 6.  **Output:**
 *     *   Use `System.out` for all normal output (menu, prompts, successful operations, list contents).
 *     *   Use `System.err` for all error messages (invalid input, empty queue processing attempt, unexpected exceptions).
 * 
 * 7.  **Best Practices:**
 *     *   Apply proper encapsulation (private fields, public methods).
 *     *   Use meaningful variable and method names.
 *     *   Include appropriate comments and documentation (e.g., Javadoc-style comments for classes and methods).
 *     *   Ensure clean code structure and logical flow.
 * 
 * **Expected Output:**
 * 
 * The program should present a menu, accept user input, perform the requested operations, and display results or error messages accordingly. Examples:
 * 
 * ```
 * --- Baggage Processing Menu ---
 * 1. Add Incoming Bag
 * 2. Process Next Bag
 * 3. View Incoming Queue
 * 4. View Processed Bags
 * 5. Exit
 * Enter choice: 1
 * Enter destination: London
 * Enter weight (kg): 20.5
 * Bag 1 (To London, 20.5 kg) added to incoming queue.
 * 
 * --- Baggage Processing Menu ---
 * ...
 * Enter choice: 2
 * Processing bag: Bag 1 (To London, 20.5 kg)
 * Bag 1 processed and added to standard processed bags.
 * 
 * --- Baggage Processing Menu ---
 * ...
 * Enter choice: 2
 * Processing bag: Bag 2 (To New York, 25.1 kg)
 * Bag 2 processed and added to oversized bags.
 * 
 * --- Baggage Processing Menu ---
 * ...
 * Enter choice: 3
 * Incoming Queue:
 * (Queue is empty)
 * 
 * --- Baggage Processing Menu ---
 * ...
 * Enter choice: 4
 * --- Processed Bags ---
 * Standard:
 * Bag 1 (To London, 20.5 kg)
 * --- Oversized Bags ---
 * Bag 2 (To New York, 25.1 kg)
 * 
 * --- Baggage Processing Menu ---
 * ...
 * Enter choice: 6
 * Invalid menu choice. Please try again.
 * 
 * --- Baggage Processing Menu ---
 * ...
 * Enter choice: 2
 * Error: Cannot process bag. Incoming queue is empty.
 * 
 * --- Baggage Processing Menu ---
 * ...
 * Enter choice: 5
 * Exiting Baggage Processing System.
 * ```
 * 
 * Implement the complete solution in a single Java file.
 * 
 * **Evaluation Criteria:**
 * 
 * *   Correct usage of all required Java components (`Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.err`, `System.out`, `try-catch`).
 * *   Correct implementation of the baggage processing logic (queueing, dequeuing, weight check, sorting).
 * *   Robust error handling and input validation.
 * *   Adherence to best practices (encapsulation, naming, comments, structure).
 * *   Clear and correct output formatting.
 *
 * EXPLANATION:
 * This solution implements the Airport Baggage Processing Simulation as required, demonstrating the use of various Java concepts and data structures.
 * 
 * 1.  **`Bag` Class:** A simple POJO (Plain Old Java Object) representing a bag. It encapsulates `bagId`, `destination`, and `weight` with private fields and public getters, adhering to encapsulation principles. The `toString()` method provides a convenient way to print bag details.
 * 
 * 2.  **`BaggageProcessingSystem` Class:** This is the core class managing the simulation.
 *     *   **Data Structures:** It uses a `Queue<Bag>` (`incomingBags`) implemented by `LinkedList` for the first-in, first-out processing of incoming bags. It uses two `List<Bag>` variables (`processedBags` and `oversizedBags`) implemented by `ArrayList` to store bags after processing, categorized by weight.
 *     *   **Constructor:** Initializes the collections and the `Scanner` object. It also initializes `nextBagId` to ensure unique IDs for bags.
 *     *   **`displayMenu()`:** A helper method to print the interactive menu to `System.out`.
 *     *   **`addBag()`:** Handles the "Add Incoming Bag" operation. It prompts the user for destination and weight using the `Scanner`. It includes a `while` loop and a `try-catch` block specifically for validating the weight input, ensuring it's a positive number and handling `InputMismatchException` if non-numeric input is entered. It consumes the invalid input to prevent an infinite loop. A new `Bag` object is created with an auto-incremented ID and added to the `incomingBags` queue using `offer()`.
 *     *   **`processNextBag()`:** Handles the "Process Next Bag" operation. It first checks if the `incomingBags` queue is empty. If so, it prints an error message to `System.err` and returns. Otherwise, it uses `poll()` to remove the next bag from the queue. It then checks the bag's weight against the `OVERSIZE_WEIGHT_LIMIT`. Based on this check, the bag is added to either the `processedBags` or `oversizedBags` list. Status messages are printed to `System.out`.
 *     *   **`viewIncomingBags()`:** Displays the contents of the `incomingBags` queue. It iterates through the queue using `forEach` without removing elements. It prints a message to `System.out` if the queue is empty.
 *     *   **`viewProcessedBags()`:** Displays the contents of both the `processedBags` and `oversizedBags` lists to `System.out`. It indicates if either list is empty.
 *     *   **`run()`:** This method contains the main application loop (`while(running)`). It repeatedly displays the menu and reads the user's choice.
 *         *   A `try-catch` block is used *inside* the loop specifically for reading the integer menu choice to handle `InputMismatchException` if the user enters non-numeric input, preventing the program from crashing and allowing the loop to continue.
 *         *   A `switch` statement is used to execute the corresponding method based on the user's valid choice.
 *     *   **Class-wide `try-catch`:** The *entire* `while(running)` loop within the `run()` method is wrapped in a broad `try-catch(Exception e)`. This block serves as the "class-wide" exception handler. If any unexpected runtime exception occurs anywhere within the `run()` method's execution that isn't caught by more specific handlers (like the `InputMismatchException` inside the loop), this block will catch it, print a generic error message to `System.err`, and the `finally` block will ensure the scanner is closed before the program potentially terminates or enters an unstable state (though catching `Exception` and continuing might not always be safe in complex apps, for this simulation it fulfills the requirement).
 *     *   **`finally` Block:** A `finally` block is used in the `run()` method to ensure the `Scanner` is closed when the loop terminates (either by exiting normally or due to an exception). This is important for resource management.
 *     *   **`main()`:** The entry point of the program. It creates an instance of `BaggageProcessingSystem` and calls its `run()` method to start the simulation.
 * 
 * This solution effectively integrates all required components, simulates a practical scenario, adheres to best practices like encapsulation and meaningful naming, and implements robust error handling using `try-catch` blocks at different levels (specific input validation and a broader class-wide handler). `System.out` and `System.err` are used appropriately for normal output and error reporting, respectively.
 */

import java.util.Queue;
import java.util.LinkedList; // LinkedList implements Queue
import java.util.List;
import java.util.ArrayList;
import java.util.Scanner;
import java.util.InputMismatchException; // Specific exception for Scanner type mismatch

/**
 * Represents a piece of luggage in the airport system.
 */
class Bag {
    private int bagId;
    private String destination;
    private double weight;

    /**
     * Constructs a new Bag object.
     * @param bagId The unique identifier for the bag.
     * @param destination The destination city/airport.
     * @param weight The weight of the bag in kilograms.
     */
    public Bag(int bagId, String destination, double weight) {
        this.bagId = bagId;
        this.destination = destination;
        this.weight = weight;
    }

    // --- Getters ---
    public int getBagId() {
        return bagId;
    }

    public String getDestination() {
        return destination;
    }

    public double getWeight() {
        return weight;
    }

    /**
     * Returns a string representation of the Bag.
     * @return A formatted string describing the bag.
     */
    @Override
    public String toString() {
        return "Bag " + bagId + " (To " + destination + ", " + String.format("%.1f", weight) + " kg)";
    }
}

/**
 * Manages the airport baggage processing system.
 * Handles incoming bags, processing, and sorting.
 */
public class BaggageProcessingSystem {

    private Queue<Bag> incomingBags;
    private List<Bag> processedBags; // Standard processed bags
    private List<Bag> oversizedBags; // Bags exceeding weight limit
    private Scanner scanner;
    private int nextBagId; // Auto-incrementing ID for new bags

    private static final double OVERSIZE_WEIGHT_LIMIT = 23.0; // kg

    /**
     * Constructs a new BaggageProcessingSystem.
     * Initializes data structures and scanner.
     */
    public BaggageProcessingSystem() {
        incomingBags = new LinkedList<>(); // LinkedList implements Queue
        processedBags = new ArrayList<>();
        oversizedBags = new ArrayList<>();
        scanner = new Scanner(System.in);
        nextBagId = 1; // Start bag IDs from 1
    }

    /**
     * Displays the main menu options to the user.
     */
    private void displayMenu() {
        System.out.println("\n--- Baggage Processing Menu ---");
        System.out.println("1. Add Incoming Bag");
        System.out.println("2. Process Next Bag");
        System.out.println("3. View Incoming Queue");
        System.out.println("4. View Processed Bags");
        System.out.println("5. Exit");
        System.out.print("Enter choice: ");
    }

    /**
     * Adds a new bag to the incoming queue based on user input.
     * Includes input validation for weight.
     */
    private void addBag() {
        System.out.print("Enter destination: ");
        String destination = scanner.nextLine();

        double weight = -1.0;
        boolean validWeight = false;
        while (!validWeight) {
            System.out.print("Enter weight (kg): ");
            try {
                weight = scanner.nextDouble();
                if (weight > 0) {
                    validWeight = true;
                } else {
                    System.err.println("Error: Weight must be a positive number.");
                }
            } catch (InputMismatchException e) {
                System.err.println("Error: Invalid input. Please enter a numeric value for weight.");
                scanner.next(); // Consume the invalid input to prevent infinite loop
            } finally {
                // Consume the rest of the line after reading the double/invalid input
                scanner.nextLine();
            }
        }

        Bag newBag = new Bag(nextBagId++, destination, weight);
        incomingBags.offer(newBag); // offer() is generally preferred over add() for queues as it doesn't throw exception if full (though LinkedList won't be full)
        System.out.println(newBag + " added to incoming queue.");
    }

    /**
     * Processes the next bag from the incoming queue.
     * Checks weight and moves the bag to the appropriate processed list.
     * Handles the case of an empty queue.
     */
    private void processNextBag() {
        if (incomingBags.isEmpty()) {
            System.err.println("Error: Cannot process bag. Incoming queue is empty.");
            return;
        }

        Bag bagToProcess = incomingBags.poll(); // poll() returns null if queue is empty, but we already checked
        System.out.println("Processing bag: " + bagToProcess);

        if (bagToProcess.getWeight() > OVERSIZE_WEIGHT_LIMIT) {
            oversizedBags.add(bagToProcess);
            System.out.println(bagToProcess + " processed and added to oversized bags.");
        } else {
            processedBags.add(bagToProcess);
            System.out.println(bagToProcess + " processed and added to standard processed bags.");
        }
    }

    /**
     * Displays all bags currently waiting in the incoming queue.
     */
    private void viewIncomingBags() {
        System.out.println("\n--- Incoming Queue ---");
        if (incomingBags.isEmpty()) {
            System.out.println("(Queue is empty)");
        } else {
            // Iterate through the queue without removing elements
            incomingBags.forEach(System.out::println);
        }
    }

    /**
     * Displays all bags that have been processed (standard and oversized).
     */
    private void viewProcessedBags() {
        System.out.println("\n--- Processed Bags ---");
        System.out.println("Standard:");
        if (processedBags.isEmpty()) {
            System.out.println("(No standard processed bags)");
        } else {
            processedBags.forEach(System.out::println);
        }

        System.out.println("--- Oversized Bags ---");
        if (oversizedBags.isEmpty()) {
            System.out.println("(No oversized bags)");
        } else {
            oversizedBags.forEach(System.out::println);
        }
    }

    /**
     * Runs the main interactive loop of the system.
     * Includes the switch statement for menu handling and class-wide try-catch.
     */
    public void run() {
        boolean running = true;

        // Class-wide exception handling wrapping the main interactive loop
        try {
            while (running) {
                displayMenu();
                int choice = -1;
                try {
                    choice = scanner.nextInt();
                } catch (InputMismatchException e) {
                    System.err.println("Error: Invalid input. Please enter a number.");
                    scanner.next(); // Consume the invalid input
                    continue; // Skip the rest of the loop iteration
                } finally {
                     scanner.nextLine(); // Consume the newline character left by nextInt()
                }


                switch (choice) {
                    case 1:
                        addBag();
                        break;
                    case 2:
                        processNextBag();
                        break;
                    case 3:
                        viewIncomingBags();
                        break;
                    case 4:
                        viewProcessedBags();
                        break;
                    case 5:
                        running = false;
                        System.out.println("Exiting Baggage Processing System.");
                        break;
                    default:
                        System.err.println("Invalid menu choice. Please try again.");
                }
            }
        } catch (Exception e) {
            // Catch any other unexpected runtime exceptions
            System.err.println("\nAn unexpected system error occurred: " + e.getMessage());
            // e.printStackTrace(); // Uncomment for detailed debugging info
        } finally {
            // Ensure the scanner is closed when the system exits
            if (scanner != null) {
                scanner.close();
            }
        }
    }

    /**
     * Main method to start the Baggage Processing System.
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        BaggageProcessingSystem system = new BaggageProcessingSystem();
        system.run();
    }
}
