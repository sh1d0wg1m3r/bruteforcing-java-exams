/*
 * Exam Question #174
 * Generated on: 2025-05-11 22:26:01
 * Generated by: Account 2
 * 
 * QUESTION:
 * **Java Programming Exam: Advanced Package Delivery Simulation**
 * 
 * **Scenario:**
 * You are tasked with developing a simplified simulation for a package delivery center. Packages arrive and are placed in a queue for processing. Once processed, they are assigned to a "completed" list, ready for dispatch. The system should allow users to interact with this simulation via a command-line interface.
 * 
 * **Requirements:**
 * 
 * 1.  **Data Structures:**
 *     *   Use a `java.util.Queue` to manage packages waiting for processing.
 *     *   Use a `java.util.ArrayList` to store packages that have been processed.
 *     *   Refer to the processed packages storage using the `java.util.List` interface type (programming to interface).
 * 
 * 2.  **Package Representation:**
 *     *   Create a `Package` class with private fields: `packageId` (String), `destination` (String), and `weight` (double).
 *     *   Include a constructor, appropriate getters, and a `toString()` method for easy printing.
 * 
 * 3.  **Simulation Logic:**
 *     *   Implement the simulation logic in a main class (e.g., `DeliverySimulator`).
 *     *   Maintain instances of the processing `Queue` and the processed `List`.
 *     *   Implement the following operations via user commands:
 *         *   **Add Package:** Prompt for package details (ID, destination, weight) and add a new `Package` object to the processing queue. Validate that weight is a positive number.
 *         *   **Process Next Package:** Take the package at the front of the processing queue, simulate processing (e.g., print a message), and move it to the processed packages list. Handle the case where the queue is empty.
 *         *   **View Processing Queue:** Display all packages currently in the processing queue.
 *         *   **View Processed Packages:** Display all packages that have been processed.
 *         *   **Exit:** Terminate the program.
 * 
 * 4.  **User Interface:**
 *     *   Use `java.util.Scanner` to read user input from the console.
 *     *   Present a menu of options to the user.
 *     *   Use a `switch` statement to handle the user's choice.
 * 
 * 5.  **Error Handling and Output:**
 *     *   Use `System.out` for normal program output (prompts, successful operations, displaying lists).
 *     *   Use `System.err` to display error messages (e.g., invalid input, trying to process from an empty queue).
 *     *   Implement class-wide exception handling using `try-catch` blocks to gracefully handle potential runtime errors, especially around user input (e.g., non-numeric input when expecting a number). Ensure the main program loop is wrapped to catch unexpected errors.
 * 
 * 6.  **Code Quality:**
 *     *   Adhere to best practices: meaningful variable/method names, proper encapsulation, comments, and clear code structure.
 * 
 * **Expected Output:**
 * 
 * The program should run interactively. Example interaction might look like this:
 * 
 * ```
 * Package Delivery Simulation Menu:
 * 1. Add Package to Queue
 * 2. Process Next Package
 * 3. View Processing Queue
 * 4. View Processed Packages
 * 5. Exit
 * Enter your choice: 1
 * Enter Package ID: P101
 * Enter Destination: New York
 * Enter Weight (kg): 5.5
 * Package P101 added to processing queue.
 * 
 * Package Delivery Simulation Menu:
 * 1. Add Package to Queue
 * 2. Process Next Package
 * 3. View Processing Queue
 * 4. View Processed Packages
 * 5. Exit
 * Enter your choice: 3
 * Processing Queue:
 * [Package{packageId='P101', destination='New York', weight=5.5}]
 * 
 * Package Delivery Simulation Menu:
 * ...
 * Enter your choice: 2
 * Processing package: Package{packageId='P101', destination='New York', weight=5.5}
 * Package P101 processed and moved to completed list.
 * 
 * Package Delivery Simulation Menu:
 * ...
 * Enter your choice: 3
 * Processing Queue:
 * []
 * 
 * Package Delivery Simulation Menu:
 * ...
 * Enter your choice: 4
 * Processed Packages:
 * [Package{packageId='P101', destination='New York', weight=5.5}]
 * 
 * Package Delivery Simulation Menu:
 * ...
 * Enter your choice: 2
 * Error: The processing queue is empty. No packages to process.
 * 
 * Package Delivery Simulation Menu:
 * ...
 * Enter your choice: invalid
 * Error: Invalid choice. Please enter a number between 1 and 5.
 * 
 * Package Delivery Simulation Menu:
 * ...
 * Enter your choice: 1
 * Enter Package ID: P102
 * Enter Destination: Los Angeles
 * Enter Weight (kg): abc
 * Error: Invalid weight input. Please enter a valid number.
 * 
 * Package Delivery Simulation Menu:
 * ...
 * Enter your choice: 5
 * Exiting Package Delivery Simulation.
 * ```
 * 
 * Your solution should be a single Java file containing the `Package` class and the main simulation class with the `main` method.
 *
 * EXPLANATION:
 * This solution implements a simple package delivery simulation demonstrating the required Java concepts.
 * 
 * 1.  **`Package` Class:** This is a simple POJO (Plain Old Java Object) representing a package. It encapsulates the package's attributes (`packageId`, `destination`, `weight`) using private fields and provides public getter methods. The constructor includes basic validation for the input data (non-null/empty strings, positive weight) throwing `IllegalArgumentException` if validation fails. The `toString()` method provides a convenient way to print package details.
 * 
 * 2.  **`DeliverySimulator` Class:** This is the main class containing the simulation logic.
 *     *   **Data Structures:**
 *         *   `processingQueue`: Declared as `Queue<Package>` and initialized with a `LinkedList`. `LinkedList` is a common implementation of the `Queue` interface, providing FIFO (First-In, First-Out) behavior suitable for a processing queue. We use the `Queue` interface type (`Queue<Package>`) to program to the interface rather than the concrete implementation (`LinkedList`), which is a best practice. Packages are added using `offer()` and removed using `poll()`.
 *         *   `processedPackages`: Declared as `List<Package>` and initialized with an `ArrayList`. `ArrayList` is a common implementation of the `List` interface, suitable for storing processed items in a dynamic array. Using the `List` interface type (`List<Package>`) follows the principle of programming to the interface. Packages are added using `add()`.
 *     *   **User Input (`Scanner`):** A `Scanner` object is used to read input from `System.in`. It's initialized in the constructor and closed in the `finally` block of the `run` method to release resources.
 *     *   **Menu and `switch`:** The `displayMenu()` method shows the available options. The `run()` method contains the main loop that reads the user's integer choice using `scanner.nextInt()`. A `switch` statement is then used to direct the program flow based on the user's input, calling the appropriate private methods (`addPackage`, `processNextPackage`, etc.).
 *     *   **Operations:**
 *         *   `addPackage()`: Prompts the user for package details. It reads the weight using `scanner.nextDouble()` and includes a `try-catch` block specifically for `InputMismatchException` to handle non-numeric input for weight. It also consumes the remaining newline character using `scanner.nextLine()` after reading the number. It creates a new `Package` object, relying on the `Package` constructor for data validation, and adds it to the `processingQueue` using `offer()`. Error messages from validation or input are printed to `System.err`.
 *         *   `processNextPackage()`: Uses `processingQueue.poll()` to retrieve and remove the next package. `poll()` is safe as it returns `null` if the queue is empty. It checks for `null` and prints an error message to `System.err` if the queue is empty. Otherwise, it prints a processing message and adds the package to the `processedPackages` list.
 *         *   `viewProcessingQueue()` and `viewProcessedPackages()`: These methods iterate through the respective collections and print each package's details using its `toString()` method. They check if the collections are empty and print an appropriate message.
 *     *   **Error Handling (`try-catch`, `System.err`):**
 *         *   Input-specific `try-catch` blocks are used in `addPackage()` and `run()` (for reading the menu choice) to handle `InputMismatchException`.
 *         *   Validation errors from the `Package` constructor (`IllegalArgumentException`) are caught in `addPackage()`.
 *         *   Operational errors (like processing an empty queue) are checked explicitly, and messages are printed to `System.err`.
 *         *   A broad `try-catch (Exception e)` block wraps the main `while` loop in the `run()` method. This provides class-wide exception handling, catching any unexpected exceptions that might occur during the simulation's execution and printing an error message and stack trace to `System.err`.
 *     *   **Output (`System.out`, `System.err`):** `System.out` is used for standard messages, prompts, and displaying the contents of the queues/lists. `System.err` is used exclusively for error messages, making them distinct in the console output.
 *     *   **Best Practices:** Private fields, public methods, meaningful names (`processingQueue`, `processNextPackage`), comments, and the use of interfaces (`Queue`, `List`) demonstrate good practices. The `scanner.nextLine()` calls after reading numbers are crucial for correct `Scanner` behavior when mixing `next...()` and `nextLine()`.
 * 
 * This solution effectively integrates all the required components into a functional, albeit simplified, simulation, demonstrating a solid understanding of core and advanced Java concepts including collections, I/O, control flow, object-oriented principles, and robust error handling.
 */

import java.util.ArrayList;
import java.util.InputMismatchException;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;

/**
 * Represents a package in the delivery simulation.
 */
class Package {
    private String packageId;
    private String destination;
    private double weight; // weight in kg

    /**
     * Constructs a new Package object.
     *
     * @param packageId   The unique identifier for the package.
     * @param destination The destination address or location for the package.
     * @param weight      The weight of the package in kilograms.
     */
    public Package(String packageId, String destination, double weight) {
        if (packageId == null || packageId.trim().isEmpty()) {
            throw new IllegalArgumentException("Package ID cannot be null or empty.");
        }
        if (destination == null || destination.trim().isEmpty()) {
            throw new IllegalArgumentException("Destination cannot be null or empty.");
        }
        if (weight <= 0) {
            throw new IllegalArgumentException("Weight must be a positive number.");
        }
        this.packageId = packageId.trim();
        this.destination = destination.trim();
        this.weight = weight;
    }

    // Getters
    public String getPackageId() {
        return packageId;
    }

    public String getDestination() {
        return destination;
    }

    public double getWeight() {
        return weight;
    }

    /**
     * Returns a string representation of the Package object.
     *
     * @return A formatted string describing the package.
     */
    @Override
    public String toString() {
        return "Package{" +
               "packageId='" + packageId + '\'' +
               ", destination='" + destination + '\'' +
               ", weight=" + weight +
               '}';
    }
}

/**
 * Simulates a package delivery center, managing packages in a queue
 * for processing and a list for completed packages.
 */
public class DeliverySimulator {

    // Use Queue interface, implemented by LinkedList
    private Queue<Package> processingQueue;
    // Use List interface, implemented by ArrayList
    private List<Package> processedPackages;
    private Scanner scanner;

    /**
     * Constructs a new DeliverySimulator.
     * Initializes the processing queue and processed packages list.
     */
    public DeliverySimulator() {
        this.processingQueue = new LinkedList<>(); // LinkedList is a common Queue implementation
        this.processedPackages = new ArrayList<>();
        this.scanner = new Scanner(System.in);
    }

    /**
     * Displays the main menu options to the user.
     */
    private void displayMenu() {
        System.out.println("\nPackage Delivery Simulation Menu:");
        System.out.println("1. Add Package to Queue");
        System.out.println("2. Process Next Package");
        System.out.println("3. View Processing Queue");
        System.out.println("4. View Processed Packages");
        System.out.println("5. Exit");
        System.out.print("Enter your choice: ");
    }

    /**
     * Adds a new package to the processing queue based on user input.
     * Handles input validation and exceptions.
     */
    private void addPackage() {
        System.out.print("Enter Package ID: ");
        String id = scanner.nextLine();

        System.out.print("Enter Destination: ");
        String destination = scanner.nextLine();

        double weight = -1; // Initialize with invalid value
        System.out.print("Enter Weight (kg): ");
        try {
            weight = scanner.nextDouble();
            // Consume the rest of the line after reading double
            scanner.nextLine();
        } catch (InputMismatchException e) {
            System.err.println("Error: Invalid weight input. Please enter a valid number.");
            // Consume the invalid input to prevent infinite loop
            scanner.nextLine();
            return; // Exit method on input error
        }

        try {
            Package newPackage = new Package(id, destination, weight);
            processingQueue.offer(newPackage); // offer is generally preferred over add for queues (returns boolean)
            System.out.println("Package " + newPackage.getPackageId() + " added to processing queue.");
        } catch (IllegalArgumentException e) {
            System.err.println("Error creating package: " + e.getMessage());
        }
    }

    /**
     * Processes the next package from the queue, moving it to the processed list.
     * Handles the case where the queue is empty.
     */
    private void processNextPackage() {
        Package packageToProcess = processingQueue.poll(); // poll retrieves and removes the head, returns null if empty

        if (packageToProcess != null) {
            System.out.println("Processing package: " + packageToProcess);
            // Simulate processing time or logic here if needed
            processedPackages.add(packageToProcess);
            System.out.println("Package " + packageToProcess.getPackageId() + " processed and moved to completed list.");
        } else {
            System.err.println("Error: The processing queue is empty. No packages to process.");
        }
    }

    /**
     * Displays the contents of the processing queue.
     */
    private void viewProcessingQueue() {
        System.out.println("Processing Queue:");
        if (processingQueue.isEmpty()) {
            System.out.println("  Queue is empty.");
        } else {
            // Iterate without removing elements
            for (Package pkg : processingQueue) {
                System.out.println("  " + pkg);
            }
        }
    }

    /**
     * Displays the contents of the processed packages list.
     */
    private void viewProcessedPackages() {
        System.out.println("Processed Packages:");
        if (processedPackages.isEmpty()) {
            System.out.println("  No packages have been processed yet.");
        } else {
            for (Package pkg : processedPackages) {
                System.out.println("  " + pkg);
            }
        }
    }

    /**
     * Runs the main simulation loop, handling user interaction.
     * Includes class-wide exception handling.
     */
    public void run() {
        boolean running = true;

        // Class-wide exception handling for the main simulation loop
        try {
            while (running) {
                displayMenu();
                int choice = -1; // Initialize with an invalid value
                try {
                    choice = scanner.nextInt();
                    // Consume the newline character left by nextInt()
                    scanner.nextLine();
                } catch (InputMismatchException e) {
                    System.err.println("Error: Invalid choice. Please enter a number.");
                    // Consume the invalid input to prevent infinite loop
                    scanner.nextLine();
                    continue; // Skip to the next iteration
                }

                // Use a switch statement for flow control based on user choice
                switch (choice) {
                    case 1:
                        addPackage();
                        break;
                    case 2:
                        processNextPackage();
                        break;
                    case 3:
                        viewProcessingQueue();
                        break;
                    case 4:
                        viewProcessedPackages();
                        break;
                    case 5:
                        running = false;
                        System.out.println("Exiting Package Delivery Simulation.");
                        break;
                    default:
                        System.err.println("Error: Invalid choice. Please enter a number between 1 and 5.");
                        break;
                }
            }
        } catch (Exception e) {
            // Catch any unexpected exceptions during the main loop
            System.err.println("An unexpected error occurred during simulation: " + e.getMessage());
            e.printStackTrace(System.err); // Print stack trace to stderr for debugging
        } finally {
            // Ensure the scanner is closed regardless of how the loop exits
            if (scanner != null) {
                scanner.close();
            }
        }
    }

    /**
     * The main method to start the package delivery simulation.
     *
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        DeliverySimulator simulator = new DeliverySimulator();
        simulator.run();
    }
}
