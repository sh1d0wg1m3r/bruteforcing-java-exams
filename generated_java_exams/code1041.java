/*
 * Exam Question #1041
 * Generated on: 2025-05-12 17:16:38
 * Generated by: Account 4
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Task Processor Simulation
 * 
 * **Problem Description:**
 * 
 * You are tasked with developing a simple Task Processor Simulation system in Java. This system manages incoming tasks, holds them in a queue, and allows processing them one by one. The system should also keep track of tasks that have been processed.
 * 
 * Each `Task` object must have:
 * *   A unique integer ID (automatically generated).
 * *   A `String` description.
 * *   A `Priority` level (e.g., HIGH, MEDIUM, LOW).
 * 
 * The system should maintain two main collections:
 * 1.  A queue of pending tasks waiting to be processed.
 * 2.  A list of tasks that have already been processed.
 * 
 * The system should provide a command-line interface allowing the user to perform the following operations:
 * 1.  **Add New Task:** Prompt the user for a task description and priority. Create a new `Task` object with a unique ID and add it to the pending tasks queue.
 * 2.  **Process Next Task:** Take the next task from the head of the pending tasks queue and move it to the processed tasks list. Report which task was processed. Handle the case where the queue is empty.
 * 3.  **View Pending Tasks:** Display all tasks currently in the pending tasks queue in the order they would be processed.
 * 4.  **View Processed Tasks:** Display all tasks that have been moved to the processed tasks list.
 * 5.  **Exit:** Terminate the program.
 * 
 * **Requirements:**
 * 
 * Your solution must:
 * *   Use the `java.util.Queue` interface (e.g., implemented by `LinkedList`) for the pending tasks.
 * *   Use the `java.util.ArrayList` class, declared using the `java.util.List` interface, for the processed tasks.
 * *   Use `java.util.Scanner` to read user input from the console.
 * *   Use a `switch` statement to control the program flow based on user choices.
 * *   Use `System.err` to display error messages (e.g., invalid input, processing an empty queue).
 * *   Use `System.out` for all normal output (menu, prompts, task lists, success messages).
 * *   Implement class-wide exception handling using `try-catch` blocks, particularly for handling potential input errors.
 * *   Adhere to best practices including:
 *     *   Proper encapsulation (private fields, public getters/methods).
 *     *   Meaningful variable and method names.
 *     *   Appropriate comments and documentation (basic Javadoc or inline comments).
 *     *   Input validation (e.g., non-empty description, valid priority).
 *     *   Clean code structure (e.g., separate class for `Task`, main system class).
 * 
 * **Example Interaction (Illustrative):**
 * 
 * ```
 * Task Processor Simulation Started.
 * --- Menu ---
 * 1. Add New Task
 * 2. Process Next Task
 * 3. View Pending Tasks
 * 4. View Processed Tasks
 * 5. Exit
 * ------------
 * Enter your choice: 1
 * --- Add New Task ---
 * Enter task description: Implement login feature
 * Enter priority (HIGH, MEDIUM, LOW): HIGH
 * Task added to pending queue: Task [ID=1, Priority=HIGH, Description='Implement login feature']
 * 
 * --- Menu ---
 * ...
 * Enter your choice: 1
 * --- Add New Task ---
 * Enter task description: Fix minor UI bug
 * Enter priority (HIGH, MEDIUM, LOW): low
 * Task added to pending queue: Task [ID=2, Priority=LOW, Description='Fix minor UI bug']
 * 
 * --- Menu ---
 * ...
 * Enter your choice: 3
 * --- Pending Tasks ---
 * 1. Task [ID=1, Priority=HIGH, Description='Implement login feature']
 * 2. Task [ID=2, Priority=LOW, Description='Fix minor UI bug']
 * 
 * --- Menu ---
 * ...
 * Enter your choice: 2
 * --- Process Next Task ---
 * Processed task: Task [ID=1, Priority=HIGH, Description='Implement login feature']
 * 
 * --- Menu ---
 * ...
 * Enter your choice: 3
 * --- Pending Tasks ---
 * 1. Task [ID=2, Priority=LOW, Description='Fix minor UI bug']
 * 
 * --- Menu ---
 * ...
 * Enter your choice: 4
 * --- Processed Tasks ---
 * 1. Task [ID=1, Priority=HIGH, Description='Implement login feature']
 * 
 * --- Menu ---
 * ...
 * Enter your choice: 2
 * --- Process Next Task ---
 * Processed task: Task [ID=2, Priority=LOW, Description='Fix minor UI bug']
 * 
 * --- Menu ---
 * ...
 * Enter your choice: 2
 * --- Process Next Task ---
 * No tasks in the pending queue to process.
 * 
 * --- Menu ---
 * ...
 * Enter your choice: invalid
 * Invalid input. Please enter a number.
 * 
 * --- Menu ---
 * ...
 * Enter your choice: 5
 * Exiting Task Processor Simulation.
 * ```
 * 
 * **Expected Output:**
 * 
 * The output should match the example interaction, clearly displaying the menu, prompts, task details, and error messages using `System.out` and `System.err` as specified.
 *
 * EXPLANATION:
 * This solution implements the Task Processor Simulation system by effectively utilizing the required Java components and adhering to good programming practices.
 * 
 * **Core Components Usage:**
 * 
 * 1.  **`java.util.Queue` (`LinkedList`):** The `pendingTasks` variable is declared as a `Queue<Task>` and initialized with a `LinkedList`. `LinkedList` is a common implementation of the `Queue` interface, providing FIFO (First-In, First-Out) behavior. Tasks are added to the queue using `offer()` and removed from the head using `poll()`.
 * 2.  **`java.util.ArrayList` (`List`):** The `processedTasks` variable is declared using the `List<Task>` interface and initialized with an `ArrayList`. `ArrayList` is used here as a dynamic list to store tasks after they have been processed. Tasks are added to this list using the `add()` method. Using the `List` interface for the variable declaration is a good practice as it allows for easier swapping of implementations later if needed.
 * 3.  **`java.util.Scanner`:** The `scanner` object is used throughout the `TaskProcessorSystem` class to read user input from `System.in`. It reads integer choices using `nextInt()` and string inputs (description, priority) using `nextLine()`. It's important to consume the leftover newline character after `nextInt()` using `scanner.nextLine()` to prevent issues with subsequent `nextLine()` calls. The scanner is closed upon exiting the program to release the system resource.
 * 4.  **`switch` statement:** A `switch` statement in the `start()` method is used to direct the program flow based on the user's integer choice, invoking the appropriate private method (`addTask`, `processNextTask`, etc.).
 * 5.  **`System.err`:** Used specifically for displaying error messages, such as when the user enters invalid input (non-numeric choice, empty description, invalid priority) or attempts to process a task when the pending queue is empty. This distinguishes error output from normal program output.
 * 6.  **`System.out`:** Used for all standard program output, including the menu, prompts for input, confirmation messages (task added, task processed), and listing the contents of the pending and processed task collections.
 * 7.  **`try-catch` blocks:** Exception handling is implemented in multiple layers.
 *     *   A `try-catch(InputMismatchException)` block is placed around `scanner.nextInt()` within the main loop in `start()` to gracefully handle cases where the user enters non-numeric input when a number is expected.
 *     *   A `try-catch(IllegalArgumentException)` block is used in the `addTask()` method when parsing the priority string using `Priority.valueOf()`. This handles cases where the user enters a priority string that doesn't match the `Priority` enum values.
 *     *   A general `try-catch(Exception)` is included within the `while(true)` loop in `start()` as a fallback to catch any other unexpected runtime exceptions that might occur during an operation cycle, preventing the program from crashing immediately and providing a general error message.
 *     *   A top-level `try-catch(Exception)` block is placed around the `system.start()` call in the `main` method. This serves as a final safety net for any unhandled exceptions that might propagate up, fulfilling the requirement for "class-wide" exception handling by wrapping the core logic execution.
 * 
 * **Best Practices and Code Structure:**
 * 
 * *   **Encapsulation:** The `Task` class has private fields (`id`, `description`, `priority`) and public getter methods (`getId`, `getDescription`, `getPriority`). The `TaskProcessorSystem` class also has private fields (`pendingTasks`, `processedTasks`, `scanner`) and public/private methods (`start` is public, others are private helpers). This protects the internal state and exposes functionality through controlled methods.
 * *   **Meaningful Names:** Variables (`pendingTasks`, `processedTasks`, `taskToProcess`, `description`, `priorityString`) and methods (`addTask`, `processNextTask`, `viewPendingTasks`, `displayMenu`) have names that clearly indicate their purpose.
 * *   **Comments:** Basic Javadoc-style comments explain the purpose of classes, enums, constructors, and key methods. Inline comments are used for specific logic details (e.g., consuming newline, explaining `offer()` vs `add()`, `poll()` vs `remove()`).
 * *   **Input Validation:** The `addTask()` method checks if the description is empty and validates the priority string against the `Priority` enum, providing informative error messages via `System.err`. The `try-catch` for `InputMismatchException` handles validation of the menu choice input type.
 * *   **Clean Code Structure:** The code is organized into two logical classes: `Task` representing the data model and `TaskProcessorSystem` handling the application logic and user interaction. The `TaskProcessorSystem` class separates concerns into distinct methods for each operation (`addTask`, `processNextTask`, etc.), making the code more readable and maintainable.
 * *   **Task ID Generation:** A static counter (`nextId`) within the `Task` class ensures that each new `Task` object receives a unique, sequential ID.
 * 
 * This solution effectively demonstrates the required Java concepts and data structures within a practical, simulated scenario, incorporating essential error handling and best practices expected in robust Java applications.
 */

import java.util.Queue;
import java.util.LinkedList;
import java.util.List;
import java.util.ArrayList;
import java.util.Scanner;
import java.util.InputMismatchException;

/**
 * Enum to represent task priority levels.
 */
enum Priority {
    HIGH, MEDIUM, LOW
}

/**
 * Represents a single task in the system.
 */
class Task {
    private static int nextId = 1; // Static counter for unique IDs
    private int id;
    private String description;
    private Priority priority;

    /**
     * Constructs a new Task with a unique ID.
     * @param description The task description.
     * @param priority The task priority.
     */
    public Task(String description, Priority priority) {
        this.id = nextId++; // Assign unique ID and increment counter
        this.description = description;
        this.priority = priority;
    }

    // --- Getters ---
    public int getId() {
        return id;
    }

    public String getDescription() {
        return description;
    }

    public Priority getPriority() {
        return priority;
    }

    /**
     * Provides a string representation of the Task.
     * @return Formatted string including ID, Priority, and Description.
     */
    @Override
    public String toString() {
        return "Task [ID=" + id + ", Priority=" + priority + ", Description='" + description + "']";
    }
}

/**
 * The main class for the Task Processor Simulation system.
 * Manages pending and processed tasks via a command-line interface.
 */
public class TaskProcessorSystem {

    // --- Data Structures ---
    // Queue for tasks waiting to be processed (FIFO behavior)
    private Queue<Task> pendingTasks;
    // List for tasks that have been processed
    private List<Task> processedTasks;
    // Scanner for reading user input
    private Scanner scanner;

    /**
     * Constructs a new TaskProcessorSystem, initializing collections and scanner.
     */
    public TaskProcessorSystem() {
        pendingTasks = new LinkedList<>(); // LinkedList implements Queue
        processedTasks = new ArrayList<>(); // ArrayList implements List
        scanner = new Scanner(System.in);
    }

    /**
     * Starts the task processor simulation, running the main menu loop.
     * Includes class-wide exception handling for the main loop.
     */
    public void start() {
        System.out.println("Task Processor Simulation Started.");
        displayMenu();

        // Main loop for the simulation
        while (true) {
            System.out.print("Enter your choice: ");
            int choice = -1;

            try {
                // Attempt to read integer choice
                choice = scanner.nextInt();
                scanner.nextLine(); // Consume the newline character left by nextInt()

                // Use switch statement for command handling
                switch (choice) {
                    case 1:
                        addTask();
                        break;
                    case 2:
                        processNextTask();
                        break;
                    case 3:
                        viewPendingTasks();
                        break;
                    case 4:
                        viewProcessedTasks();
                        break;
                    case 5:
                        System.out.println("Exiting Task Processor Simulation.");
                        scanner.close(); // Close the scanner resource
                        return; // Exit the start method and thus the program
                    default:
                        // Handle choices outside the valid range
                        System.err.println("Invalid choice. Please enter a number between 1 and 5.");
                }
            } catch (InputMismatchException e) {
                // Handle cases where the user enters non-integer input for choice
                System.err.println("Invalid input. Please enter a number for your choice.");
                scanner.nextLine(); // Consume the invalid input to prevent infinite loop
            } catch (Exception e) {
                // General catch for any other unexpected errors during the loop iteration
                System.err.println("An unexpected error occurred: " + e.getMessage());
                // Optionally print stack trace for debugging critical errors
                // e.printStackTrace();
            }

            System.out.println(); // Add a newline for better readability between operations
            displayMenu(); // Display the menu again after completing an operation
        }
    }

    /**
     * Displays the main menu options to the user.
     */
    private void displayMenu() {
        System.out.println("--- Menu ---");
        System.out.println("1. Add New Task");
        System.out.println("2. Process Next Task");
        System.out.println("3. View Pending Tasks");
        System.out.println("4. View Processed Tasks");
        System.out.println("5. Exit");
        System.out.println("------------");
    }

    /**
     * Prompts the user for task details and adds a new task to the pending queue.
     * Includes input validation for description and priority.
     */
    private void addTask() {
        System.out.println("--- Add New Task ---");
        System.out.print("Enter task description: ");
        String description = scanner.nextLine().trim(); // Read description and trim whitespace

        // Validate description
        if (description.isEmpty()) {
            System.err.println("Task description cannot be empty. Task not added.");
            return;
        }

        System.out.print("Enter priority (HIGH, MEDIUM, LOW): ");
        String priorityString = scanner.nextLine().trim().toUpperCase(); // Read priority and convert to uppercase

        Priority priority = null;
        try {
            // Validate and parse priority string into Priority enum
            priority = Priority.valueOf(priorityString);
        } catch (IllegalArgumentException e) {
            // Handle invalid priority input
            System.err.println("Invalid priority entered. Please use HIGH, MEDIUM, or LOW. Task not added.");
            return;
        }

        // Create new Task object and add to the pending queue
        Task newTask = new Task(description, priority);
        pendingTasks.offer(newTask); // offer() is recommended for queues, returns boolean indicating success
        System.out.println("Task added to pending queue: " + newTask);
    }

    /**
     * Processes the next task from the pending queue and moves it to the processed list.
     * Handles the case where the pending queue is empty.
     */
    private void processNextTask() {
        System.out.println("--- Process Next Task ---");
        // Retrieve and remove the head of the queue using poll()
        Task taskToProcess = pendingTasks.poll(); // poll() returns null if queue is empty

        if (taskToProcess == null) {
            // Handle empty queue scenario
            System.err.println("No tasks in the pending queue to process.");
        } else {
            // Add the processed task to the processed list
            processedTasks.add(taskToProcess);
            System.out.println("Processed task: " + taskToProcess);
        }
    }

    /**
     * Displays all tasks currently in the pending tasks queue.
     */
    private void viewPendingTasks() {
        System.out.println("--- Pending Tasks ---");
        if (pendingTasks.isEmpty()) {
            System.out.println("No tasks are pending.");
        } else {
            // Iterate through the queue without removing elements
            int i = 1;
            for (Task task : pendingTasks) {
                System.out.println(i++ + ". " + task);
            }
            // Alternatively, create a temporary list to iterate if needed,
            // but direct iteration is sufficient here.
            // List<Task> pendingList = new ArrayList<>(pendingTasks);
            // for (int j = 0; j < pendingList.size(); j++) {
            //     System.out.println((j + 1) + ". " + pendingList.get(j));
            // }
        }
    }

    /**
     * Displays all tasks that have been moved to the processed tasks list.
     */
    private void viewProcessedTasks() {
        System.out.println("--- Processed Tasks ---");
        if (processedTasks.isEmpty()) {
            System.out.println("No tasks have been processed yet.");
        } else {
            // Iterate through the list
            for (int i = 0; i < processedTasks.size(); i++) {
                System.out.println((i + 1) + ". " + processedTasks.get(i));
            }
        }
    }

    /**
     * The main method to start the Task Processor Simulation.
     * Includes a top-level catch for any unhandled exceptions.
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        // Top-level try-catch for catching any critical, unhandled exceptions
        // that might escape the start() method's loop handling.
        try {
             TaskProcessorSystem system = new TaskProcessorSystem();
             system.start();
        } catch (Exception e) {
             System.err.println("A critical system error occurred: " + e.getMessage());
             e.printStackTrace(); // Print stack trace for debugging critical failures
        }
    }
}
