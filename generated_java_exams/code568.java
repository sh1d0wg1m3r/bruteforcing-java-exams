/*
 * Exam Question #568
 * Generated on: 2025-05-11 23:30:27
 * Generated by: Account 4
 * 
 * QUESTION:
 * **Subject:** Advanced Java Programming
 * **Task Title:** Package Delivery Dispatch System Simulation
 * 
 * **Problem Description:**
 * 
 * Design and implement a simple console-based simulation of a package delivery dispatch system. The system manages a list of available delivery drivers and a queue of incoming package delivery requests. Your program should allow a dispatcher to perform several actions via a menu-driven interface.
 * 
 * **System Requirements:**
 * 
 * 1.  **Data Structures:**
 *     *   Maintain a dynamic list of `Driver` objects.
 *     *   Maintain a queue of `PackageRequest` objects representing deliveries waiting to be assigned.
 * 2.  **Functionality:**
 *     *   **Add New Request:** Allow the user to input details for a new package request (destination address, description) and add it to the end of the pending requests queue.
 *     *   **Dispatch Next Request:** Take the next package request from the front of the queue and assign it to a specific driver selected by the user from the list of drivers. This action should remove the request from the queue.
 *     *   **View Pending Requests:** Display all package requests currently waiting in the queue.
 *     *   **View Available Drivers:** Display the list of drivers available for dispatch.
 *     *   **Exit:** Terminate the application.
 * 3.  **User Interface:**
 *     *   Use a menu system presented via `System.out`.
 *     *   Read user input for menu choices and data using `java.util.Scanner`.
 *     *   Use a `switch` statement to handle the different menu options.
 * 4.  **Error Handling & Validation:**
 *     *   Implement robust input validation. If the user enters non-numeric input when a number is expected (like a menu choice or driver index), or an invalid driver index, handle this gracefully.
 *     *   Use `try-catch` blocks to handle potential runtime exceptions, particularly around input parsing and operations that might fail (e.g., attempting to dispatch from an empty queue). A general `try-catch` around the main application loop is encouraged for catching unexpected errors.
 *     *   Display error messages to `System.err`.
 *     *   Display normal output (menu, prompts, lists, success messages) to `System.out`.
 *     *   Handle the case where a dispatch is attempted when the request queue is empty.
 *     *   Handle the case where an invalid driver index is entered.
 * 5.  **Code Structure & Best Practices:**
 *     *   Create separate classes for `Driver` and `PackageRequest` with appropriate private fields and public getter methods (encapsulation).
 *     *   Use meaningful variable and method names.
 *     *   Include comments to explain complex logic or sections.
 *     *   Ensure proper resource management (e.g., closing the `Scanner`).
 *     *   Use the `List` interface when declaring the variable holding the drivers, even if the implementation is `ArrayList`.
 *     *   Ensure all required components (`Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.err`, `System.out`, `try-catch`) are used effectively.
 * 
 * **Initial State:**
 * The system should start with an empty package request queue and a pre-populated list of at least three drivers.
 * 
 * **Expected Output:**
 * The output should be interactive, displaying a menu, prompts for input, lists of requests/drivers, confirmation messages, and error messages on `System.err` when validation fails or an operation cannot be performed.
 * 
 * **Example Interaction Snippet (Illustrative):**
 * 
 * ```
 * --- Delivery Dispatch System ---
 * 1. Add New Package Request
 * 2. Dispatch Next Request
 * 3. View Pending Requests
 * 4. View Available Drivers
 * 5. Exit
 * Enter your choice: 1
 * Enter destination address: 123 Main St
 * Enter package description: Small box of books
 * Package request added to queue.
 * 
 * --- Delivery Dispatch System ---
 * 1. Add New Package Request
 * 2. Dispatch Next Request
 * ...
 * Enter your choice: 3
 * Pending Requests:
 * 1. [123 Main St] Small box of books
 * 
 * --- Delivery Dispatch System ---
 * 1. Add New Package Request
 * ...
 * Enter your choice: 2
 * Next request to dispatch: [123 Main St] Small box of books
 * Available Drivers:
 * 0. Alice
 * 1. Bob
 * 2. Charlie
 * Enter driver index: 1
 * Dispatching package to Bob: [123 Main St] Small box of books
 * 
 * --- Delivery Dispatch System ---
 * 1. Add New Package Request
 * ...
 * Enter your choice: 3
 * Pending Requests:
 * (Queue is empty)
 * 
 * --- Delivery Dispatch System ---
 * ...
 * Enter your choice: 2
 * Error: No pending packages to dispatch.
 * ```
 * 
 * **Evaluation Criteria:**
 * *   Correct usage of all required Java components.
 * *   Correct implementation of core functionality (add, dispatch, view).
 * *   Robust error handling and input validation using `try-catch` and `System.err`.
 * *   Adherence to best practices (encapsulation, naming, comments, structure).
 * *   Clear and correct output format.
 * 
 * **Note:** You do not need to simulate the actual delivery process, only the dispatching of the request from the queue to a driver.
 *
 * EXPLANATION:
 * This solution implements the Package Delivery Dispatch System as described in the problem.
 * 
 * 1.  **Classes `Driver` and `PackageRequest`:** These simple classes encapsulate the data for drivers (name) and package requests (address, description). They have private fields and public getter methods, demonstrating basic encapsulation. The `toString()` method is overridden for convenient printing.
 * 
 * 2.  **`DeliveryDispatchSystem` Class:** This is the main class containing the application logic.
 *     *   **Data Structures:** It uses `private Queue<PackageRequest> pendingRequests` (implemented with `LinkedList`) and `private List<Driver> availableDrivers` (implemented with `ArrayList`) to hold the core data, fulfilling the `Queue`, `List`, and `ArrayList` requirements.
 *     *   **Constructor:** Initializes the data structures and the `Scanner` for input. It also pre-populates the `availableDrivers` list as required.
 *     *   **`scanner`:** A `private Scanner scanner` field is used throughout the class for reading user input, satisfying the `Scanner` requirement.
 *     *   **`displayMenu()`:** A helper method to print the menu options to `System.out`.
 *     *   **`addNewRequest()`:** Prompts the user for package details using `System.out` and `scanner.nextLine()`, creates a `PackageRequest` object, and adds it to the `pendingRequests` queue using `offer()`. Success message is printed to `System.out`.
 *     *   **`dispatchNextRequest()`:**
 *         *   Checks if the `pendingRequests` queue is empty. If so, it prints an error message to `System.err` and returns, demonstrating error handling for an empty queue.
 *         *   If not empty, it uses `peek()` to show the next request without removing it yet.
 *         *   Calls `displayDrivers()` to show the drivers with their indices (`System.out`).
 *         *   Uses a `try-catch` block specifically for reading and parsing the driver index.
 *         *   Inside the `try` block:
 *             *   Reads the input using `scanner.nextLine()`.
 *             *   Parses it to an integer using `Integer.parseInt()`.
 *             *   Validates the parsed index against the bounds of the `availableDrivers` list. If invalid, it prints an error to `System.err`.
 *             *   If the index is valid, it retrieves the `Driver` using `availableDrivers.get(driverIndex)`.
 *             *   It then removes the request from the queue using `poll()`, which is appropriate here as the request is being processed/dispatched.
 *             *   A success message is printed to `System.out`.
 *         *   `catch (NumberFormatException e)` handles cases where the user enters non-integer text for the driver index, printing an error to `System.err`.
 *         *   A general `catch (Exception e)` is included for other unexpected errors during the dispatch process.
 *     *   **`viewPendingRequests()`:** Iterates through the `pendingRequests` queue (using a for-each loop, which doesn't remove elements) and prints each request to `System.out`. It handles the empty queue case with a message to `System.out`.
 *     *   **`displayDrivers()`:** Iterates through the `availableDrivers` list and prints each driver with their index to `System.out`.
 *     *   **`run()`:** Contains the main application loop (`while(isRunning)`).
 *         *   It calls `displayMenu()` and prompts for input.
 *         *   A `try-catch` block wraps the input reading (`scanner.nextLine()`) and the `switch` statement. This provides class-wide exception handling for the main operational loop.
 *         *   Inside the `try` block, the user's menu choice is parsed using `Integer.parseInt()`.
 *         *   A `switch` statement directs execution based on the parsed choice, calling the appropriate methods (`addNewRequest`, `dispatchNextRequest`, etc.), fulfilling the `switch` requirement.
 *         *   The `default` case in the `switch` handles invalid numeric choices, printing an error to `System.err`.
 *         *   `catch (NumberFormatException e)` outside the `switch` specifically handles cases where the main menu input is not a valid integer, printing an error to `System.err`.
 *         *   A general `catch (Exception e)` provides a fallback for any other unhandled exceptions occurring within the main loop, printing to `System.err`.
 *         *   The loop continues until the user chooses option 5, setting `isRunning` to `false`.
 *         *   Finally, `scanner.close()` is called to release the system resource.
 *     *   **`main(String[] args)`:** The entry point of the application, which creates an instance of `DeliveryDispatchSystem` and calls its `run()` method.
 * 
 * This solution effectively uses all the required components (`Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.err`, `System.out`, `try-catch`) in a practical scenario, demonstrating encapsulation, validation, and error handling according to best practices.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;

// Represents a delivery driver
class Driver {
    private String name;

    public Driver(String name) {
        this.name = name;
    }

    public String getName() {
        return name;
    }

    @Override
    public String toString() {
        return name;
    }
}

// Represents a package delivery request
class PackageRequest {
    private String destinationAddress;
    private String description;

    public PackageRequest(String destinationAddress, String description) {
        this.destinationAddress = destinationAddress;
        this.description = description;
    }

    public String getDestinationAddress() {
        return destinationAddress;
    }

    public String getDescription() {
        return description;
    }

    @Override
    public String toString() {
        return "[" + destinationAddress + "] " + description;
    }
}

// Main class for the Delivery Dispatch System
public class DeliveryDispatchSystem {

    private Queue<PackageRequest> pendingRequests;
    private List<Driver> availableDrivers;
    private Scanner scanner;

    public DeliveryDispatchSystem() {
        // Use LinkedList to implement the Queue interface
        pendingRequests = new LinkedList<>();
        // Use ArrayList to implement the List interface for drivers
        availableDrivers = new ArrayList<>();
        scanner = new Scanner(System.in);

        // Initialize with some sample drivers
        availableDrivers.add(new Driver("Alice"));
        availableDrivers.add(new Driver("Bob"));
        availableDrivers.add(new Driver("Charlie"));
    }

    // Displays the main menu
    private void displayMenu() {
        System.out.println("\n--- Delivery Dispatch System ---");
        System.out.println("1. Add New Package Request");
        System.out.println("2. Dispatch Next Request");
        System.out.println("3. View Pending Requests");
        System.out.println("4. View Available Drivers");
        System.out.println("5. Exit");
        System.out.print("Enter your choice: ");
    }

    // Adds a new package request to the queue
    private void addNewRequest() {
        System.out.print("Enter destination address: ");
        String address = scanner.nextLine();
        System.out.print("Enter package description: ");
        String description = scanner.nextLine();

        PackageRequest newRequest = new PackageRequest(address, description);
        pendingRequests.offer(newRequest); // offer is preferred over add for queues

        System.out.println("Package request added to queue.");
    }

    // Dispatches the next request from the queue to a selected driver
    private void dispatchNextRequest() {
        if (pendingRequests.isEmpty()) {
            System.err.println("Error: No pending packages to dispatch.");
            return;
        }

        PackageRequest nextRequest = pendingRequests.peek(); // Peek to show before polling
        System.out.println("Next request to dispatch: " + nextRequest);

        displayDrivers(); // Show drivers with indices

        try {
            System.out.print("Enter driver index: ");
            String driverIndexInput = scanner.nextLine();
            int driverIndex = Integer.parseInt(driverIndexInput);

            // Validate driver index against the list size
            if (driverIndex < 0 || driverIndex >= availableDrivers.size()) {
                System.err.println("Error: Invalid driver index. Please enter a number between 0 and " + (availableDrivers.size() - 1) + ".");
            } else {
                Driver selectedDriver = availableDrivers.get(driverIndex);
                // Now poll the request as we have a valid driver
                PackageRequest dispatchedRequest = pendingRequests.poll();
                System.out.println("Dispatching package to " + selectedDriver.getName() + ": " + dispatchedRequest);
            }
        } catch (NumberFormatException e) {
            // Handles cases where input is not an integer
            System.err.println("Error: Invalid input. Please enter a numeric driver index.");
        } catch (Exception e) {
             // Catch any other unexpected errors during dispatch
             System.err.println("An unexpected error occurred during dispatch: " + e.getMessage());
             // e.printStackTrace(); // Uncomment for debugging
        }
    }

    // Displays all pending package requests in the queue
    private void viewPendingRequests() {
        System.out.println("\nPending Requests:");
        if (pendingRequests.isEmpty()) {
            System.out.println("(Queue is empty)");
        } else {
            // Iterate through the queue without removing elements
            int index = 1;
            for (PackageRequest request : pendingRequests) {
                System.out.println(index++ + ". " + request);
            }
        }
    }

    // Displays all available drivers with their indices
    private void displayDrivers() {
        System.out.println("\nAvailable Drivers:");
        if (availableDrivers.isEmpty()) {
             System.out.println("(No drivers available)");
        } else {
            for (int i = 0; i < availableDrivers.size(); i++) {
                System.out.println(i + ". " + availableDrivers.get(i).getName());
            }
        }
    }

    // Main application loop
    public void run() {
        boolean isRunning = true;
        while (isRunning) {
            displayMenu();
            try {
                String choiceInput = scanner.nextLine();
                int choice = Integer.parseInt(choiceInput);

                // Use switch statement for menu navigation
                switch (choice) {
                    case 1:
                        addNewRequest();
                        break;
                    case 2:
                        dispatchNextRequest();
                        break;
                    case 3:
                        viewPendingRequests();
                        break;
                    case 4:
                        displayDrivers();
                        break;
                    case 5:
                        System.out.println("Exiting Dispatch System. Goodbye!");
                        isRunning = false;
                        break;
                    default:
                        // Handle invalid menu choices
                        System.err.println("Error: Invalid choice. Please enter a number between 1 and 5.");
                }
            } catch (NumberFormatException e) {
                // Catch non-integer input for the main menu choice
                System.err.println("Error: Invalid input. Please enter a numeric menu choice.");
            } catch (Exception e) {
                // Class-wide exception handling for any other unexpected errors
                System.err.println("An unexpected system error occurred: " + e.getMessage());
                // e.printStackTrace(); // Uncomment for debugging
            }
        }
        scanner.close(); // Close the scanner resource
    }

    // Main method to start the application
    public static void main(String[] args) {
        DeliveryDispatchSystem system = new DeliveryDispatchSystem();
        system.run();
    }
}
