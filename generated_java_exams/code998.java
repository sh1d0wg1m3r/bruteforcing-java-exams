/*
 * Exam Question #998
 * Generated on: 2025-05-12 17:10:48
 * Generated by: Account 5
 * 
 * QUESTION:
 * **Java Programming Exam Task: Event Management System - Attendee Check-in**
 * 
 * **Problem Description:**
 * 
 * You are tasked with building a simplified Event Management System focusing on attendee registration and check-in. The system should allow managing a list of registered attendees and processing attendees as they arrive for check-in.
 * 
 * **Requirements:**
 * 
 * 1.  **Attendee Representation:** Create a class `Attendee` with private fields for `id` (String) and `name` (String). Include a constructor, public getters for both fields, and override `equals()` and `hashCode()` based on the `id` to uniquely identify attendees. Also, provide a `toString()` method for easy printing.
 * 2.  **Event Manager:** Create a class `EventManager` that manages the event. It should contain:
 *     *   A private `List<Attendee>` to store all officially registered attendees. Use `ArrayList` as the concrete implementation.
 *     *   A private `Queue<Attendee>` to manage attendees who have arrived and are waiting to be checked in. Use `LinkedList` as the concrete implementation.
 * 3.  **Functionality:** The `EventManager` class must provide the following public methods:
 *     *   `addRegisteredAttendee(String id, String name)`: Adds a new attendee to the list of registered attendees. Should check if an attendee with the same ID already exists and prevent adding duplicates.
 *     *   `checkInAttendee(String attendeeId)`: Simulates an attendee arriving. It should first verify if the attendee with the given ID is present in the *registered* list. If found, the attendee object (from the registered list) should be added to the *check-in queue*. If not found in the registered list, an appropriate error message should be displayed. An attendee should only be added to the queue if they are registered.
 *     *   `processNextInQueue()`: Simulates processing the next attendee waiting in the check-in queue. Removes the attendee at the front of the queue and prints a success message. If the queue is empty, an appropriate error message should be displayed.
 *     *   `viewRegisteredAttendees()`: Prints the details of all attendees in the registered list.
 *     *   `viewCheckInQueue()`: Prints the details of all attendees currently waiting in the check-in queue.
 * 4.  **User Interface:** Implement a simple command-line interface in the `main` method of a separate class (e.g., `EventApp`). The interface should present a menu to the user:
 *     *   1. Add Registered Attendee
 *     *   2. Check-in Attendee
 *     *   3. Process Next In Queue
 *     *   4. View Registered Attendees
 *     *   5. View Check-in Queue
 *     *   6. Exit
 *     The program should continuously prompt the user for input until '6' is selected.
 * 5.  **Input Handling:** Use `java.util.Scanner` to read user input for menu choices and attendee details.
 * 6.  **Flow Control:** Use a `switch` statement to handle the different menu options.
 * 7.  **Output:**
 *     *   Use `System.out.println()` for menu display, successful operations, and viewing lists.
 *     *   Use `System.err.println()` for all error messages (e.g., invalid menu choice, attendee not registered, queue empty, duplicate attendee ID).
 * 8.  **Error Handling:** Implement exception handling using `try-catch` blocks. Specifically, wrap the main loop's input reading to catch potential `InputMismatchException` if the user enters non-integer input for the menu choice. Handle other operational errors (like queue empty or attendee not found) using `System.err` messages within the `EventManager` methods.
 * 9.  **Best Practices:**
 *     *   Ensure proper encapsulation (private fields, public methods).
 *     *   Use meaningful variable and method names.
 *     *   Include basic comments explaining classes and methods.
 *     *   Perform input validation where necessary (e.g., checking for empty queue before processing, checking registration before check-in, checking for duplicate registration).
 *     *   Maintain a clean code structure.
 * 
 * **Expected Output:**
 * 
 * The output should be interactive, displaying a menu, prompting for input, and showing results or errors based on user actions.
 * 
 * Example flow:
 * ```
 * Event Management Menu:
 * 1. Add Registered Attendee
 * 2. Check-in Attendee
 * 3. Process Next In Queue
 * 4. View Registered Attendees
 * 5. View Check-in Queue
 * 6. Exit
 * Enter choice: 1
 * Enter Attendee ID: A101
 * Enter Attendee Name: Alice Smith
 * Attendee A101 (Alice Smith) registered successfully.
 * 
 * Event Management Menu:
 * ...
 * Enter choice: 1
 * Enter Attendee ID: A102
 * Enter Attendee Name: Bob Johnson
 * Attendee A102 (Bob Johnson) registered successfully.
 * 
 * Event Management Menu:
 * ...
 * Enter choice: 4
 * Registered Attendees:
 * ID: A101, Name: Alice Smith
 * ID: A102, Name: Bob Johnson
 * 
 * Event Management Menu:
 * ...
 * Enter choice: 2
 * Enter Attendee ID: A101
 * Attendee A101 added to check-in queue.
 * 
 * Event Management Menu:
 * ...
 * Enter choice: 2
 * Enter Attendee ID: A999
 * Error: Attendee with ID A999 is not registered.
 * 
 * Event Management Menu:
 * ...
 * Enter choice: 5
 * Check-in Queue:
 * ID: A101, Name: Alice Smith
 * 
 * Event Management Menu:
 * ...
 * Enter choice: 3
 * Processing attendee: ID: A101, Name: Alice Smith
 * Attendee processed successfully.
 * 
 * Event Management Menu:
 * ...
 * Enter choice: 5
 * Check-in Queue is empty.
 * 
 * Event Management Menu:
 * ...
 * Enter choice: 3
 * Error: Check-in queue is empty.
 * 
 * Event Management Menu:
 * ...
 * Enter choice: 7
 * Error: Invalid choice. Please enter a number between 1 and 6.
 * 
 * Event Management Menu:
 * ...
 * Enter choice: abc
 * Error: Invalid input. Please enter a number.
 * 
 * Event Management Menu:
 * ...
 * Enter choice: 6
 * Exiting Event Management System.
 * ```
 * 
 * Your solution should consist of the `Attendee` class, the `EventManager` class, and the main application class (`EventApp`) containing the `main` method.
 *
 * EXPLANATION:
 * The solution implements a simple Event Management System focusing on attendee registration and check-in, fulfilling all specified requirements.
 * 
 * 1.  **`Attendee` Class:** This class models an attendee with a unique `id` and a `name`.
 *     *   `private` fields ensure encapsulation.
 *     *   Public getters provide controlled access to the data.
 *     *   The constructor includes basic validation to prevent null/empty IDs or names, throwing an `IllegalArgumentException`.
 *     *   Crucially, `equals()` and `hashCode()` are overridden based *only* on the `id`. This is essential for correctly using `List.contains()` and `List.indexOf()` to find attendees by ID in the `registeredAttendees` list, even if the name might be slightly different or we only have the ID string.
 *     *   `toString()` provides a convenient way to print attendee details.
 * 
 * 2.  **`EventManager` Class:** This class contains the core logic and data structures.
 *     *   `private List<Attendee> registeredAttendees = new ArrayList<>();`: An `ArrayList` is used to store registered attendees. It's declared using the `List` interface type, demonstrating polymorphism and good practice (coding to interfaces). `ArrayList` is suitable here as we might need to iterate through it or find elements by value (`indexOf`).
 *     *   `private Queue<Attendee> checkInQueue = new LinkedList<>();`: A `LinkedList` is used as the implementation for the `Queue` interface. This is appropriate for the check-in queue because attendees are added to the end (`offer`) and removed from the front (`poll`), which are efficient operations in a linked list when used as a queue. The `Queue` interface guarantees FIFO (First-In, First-Out) behavior.
 *     *   **`addRegisteredAttendee(String id, String name)`:** Creates an `Attendee` object. It uses `registeredAttendees.contains()` which relies on the overridden `equals()` method in `Attendee` to check for duplicate IDs before adding, printing an error to `System.err` if a duplicate is found. It wraps the `Attendee` constructor call in a `try-catch` to handle `IllegalArgumentException` from invalid input.
 *     *   **`checkInAttendee(String attendeeId)`:** Creates a temporary `Attendee` object with the given ID. It uses `registeredAttendees.indexOf()` (which also relies on `equals()`) to find if the attendee is registered. If found, it retrieves the *actual* `Attendee` object from the list and adds it to the `checkInQueue` using `offer()`. If not found, it prints an error to `System.err`.
 *     *   **`processNextInQueue()`:** Uses `checkInQueue.poll()` to retrieve and remove the head of the queue. `poll()` returns `null` if the queue is empty, which is checked to print an error message to `System.err` instead of potentially throwing an exception like `remove()`. If an attendee is retrieved, their details are printed to `System.out`.
 *     *   **`viewRegisteredAttendees()`:** Iterates through the `registeredAttendees` list and prints each attendee's details to `System.out`.
 *     *   **`viewCheckInQueue()`:** Iterates through the `checkInQueue` and prints each attendee's details to `System.out`. It iterates directly over the queue (which is possible because `LinkedList` implements `Iterable`) without removing elements.
 * 
 * 3.  **`EventApp` Class (`main` method):** This is the entry point of the application.
 *     *   It creates instances of `EventManager` and `Scanner`.
 *     *   A `do-while` or `while` loop runs the main application cycle.
 *     *   The menu is printed using `System.out`.
 *     *   User input for the menu choice is read using `scanner.nextInt()`.
 *     *   `scanner.nextLine()` is called immediately after reading the integer to consume the leftover newline character, preventing issues with subsequent `nextLine()` calls.
 *     *   A `switch` statement directs the program flow based on the user's integer choice, calling the appropriate `EventManager` methods.
 *     *   Invalid integer choices fall into the `default` case of the `switch`, printing an error to `System.err`.
 *     *   **Exception Handling (`try-catch`):** A `try-catch` block is placed around the input reading (`scanner.nextInt()`) and the `switch` block. This specifically catches `InputMismatchException` if the user enters non-integer input, prints an error to `System.err`, and consumes the invalid input using `scanner.next()` to prevent an infinite loop. A general `Exception` catch is also included as a fallback for unexpected errors within the loop operations, printing to `System.err`.
 *     *   **Class-wide Exception Handling:** While not strictly "class-wide" in the sense of a single handler for the entire class, the `try-catch` block wrapping the core application loop in `main` serves as the primary, broad exception handling mechanism for the application's interactive phase, catching errors stemming from user input or unexpected operational issues within the loop.
 *     *   **`finally` block:** Ensures that `scanner.close()` is called when the loop finishes (either by exiting normally with choice 6 or due to an uncaught exception), releasing system resources.
 * 
 * This solution effectively demonstrates the use of `Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.err`, `System.out`, and `try-catch` in a practical, object-oriented structure with basic error handling and input validation. The use of `equals`/`hashCode` with `List.contains`/`indexOf` and the distinction between `List` and `Queue` operations are key advanced concepts showcased.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.InputMismatchException;

// Represents an attendee for the event
class Attendee {
    private String id;
    private String name;

    /**
     * Constructs a new Attendee.
     * @param id The unique ID of the attendee.
     * @param name The name of the attendee.
     */
    public Attendee(String id, String name) {
        if (id == null || id.trim().isEmpty()) {
            throw new IllegalArgumentException("Attendee ID cannot be null or empty.");
        }
        if (name == null || name.trim().isEmpty()) {
            throw new IllegalArgumentException("Attendee name cannot be null or empty.");
        }
        this.id = id.trim();
        this.name = name.trim();
    }

    // --- Getters ---
    public String getId() {
        return id;
    }

    public String getName() {
        return name;
    }

    // --- Object overrides for unique identification by ID ---
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Attendee attendee = (Attendee) o;
        return id.equals(attendee.id);
    }

    @Override
    public int hashCode() {
        return id.hashCode();
    }

    // --- String representation ---
    @Override
    public String toString() {
        return "ID: " + id + ", Name: " + name;
    }
}

// Manages the event attendees and check-in process
class EventManager {
    // Using List interface type, implemented by ArrayList for random access/storage
    private List<Attendee> registeredAttendees;
    // Using Queue interface type, implemented by LinkedList for FIFO behavior
    private Queue<Attendee> checkInQueue;

    /**
     * Constructs a new EventManager.
     */
    public EventManager() {
        this.registeredAttendees = new ArrayList<>();
        this.checkInQueue = new LinkedList<>();
    }

    /**
     * Adds a new attendee to the registered list.
     * Prevents adding duplicates based on ID.
     * @param id The ID of the attendee.
     * @param name The name of the attendee.
     */
    public void addRegisteredAttendee(String id, String name) {
        try {
            Attendee newAttendee = new Attendee(id, name);

            // Check for duplicate ID using the overridden equals method
            if (registeredAttendees.contains(newAttendee)) {
                System.err.println("Error: Attendee with ID " + id + " is already registered.");
            } else {
                registeredAttendees.add(newAttendee);
                System.out.println("Attendee " + newAttendee.getId() + " (" + newAttendee.getName() + ") registered successfully.");
            }
        } catch (IllegalArgumentException e) {
            System.err.println("Error adding attendee: " + e.getMessage());
        }
    }

    /**
     * Attempts to check in an attendee.
     * Attendee must be registered to be added to the queue.
     * @param attendeeId The ID of the attendee attempting to check in.
     */
    public void checkInAttendee(String attendeeId) {
        // Create a dummy Attendee object with just the ID for searching
        // This works because Attendee.equals() only compares IDs
        Attendee searchAttendee = new Attendee(attendeeId, "dummy"); // Name doesn't matter for equals check

        int index = registeredAttendees.indexOf(searchAttendee);

        if (index != -1) {
            // Attendee is registered, get the actual Attendee object from the list
            Attendee registeredAttendee = registeredAttendees.get(index);

            // Optional: Prevent adding to queue if already in queue (more complex, skip for exam scope)
            // if (checkInQueue.contains(registeredAttendee)) {
            //     System.err.println("Error: Attendee with ID " + attendeeId + " is already in the check-in queue.");
            // } else {
                checkInQueue.offer(registeredAttendee); // offer is preferred over add for queues (returns false on failure)
                System.out.println("Attendee " + attendeeId + " added to check-in queue.");
            // }
        } else {
            System.err.println("Error: Attendee with ID " + attendeeId + " is not registered.");
        }
    }

    /**
     * Processes the next attendee from the check-in queue (FIFO).
     * Removes the attendee from the queue.
     */
    public void processNextInQueue() {
        Attendee nextAttendee = checkInQueue.poll(); // poll returns null if queue is empty

        if (nextAttendee != null) {
            System.out.println("Processing attendee: " + nextAttendee);
            System.out.println("Attendee processed successfully.");
        } else {
            System.err.println("Error: Check-in queue is empty.");
        }
    }

    /**
     * Displays all currently registered attendees.
     */
    public void viewRegisteredAttendees() {
        System.out.println("Registered Attendees:");
        if (registeredAttendees.isEmpty()) {
            System.out.println("No attendees registered yet.");
        } else {
            for (Attendee attendee : registeredAttendees) {
                System.out.println(attendee);
            }
        }
    }

    /**
     * Displays all attendees currently waiting in the check-in queue.
     */
    public void viewCheckInQueue() {
        System.out.println("Check-in Queue:");
        if (checkInQueue.isEmpty()) {
            System.out.println("Check-in queue is empty.");
        } else {
            // Iterate without removing using peek or enhanced for loop
            for (Attendee attendee : checkInQueue) {
                System.out.println(attendee);
            }
        }
    }
}

// Main application class with the user interface
public class EventApp {

    public static void main(String[] args) {
        EventManager eventManager = new EventManager();
        Scanner scanner = new Scanner(System.in);
        int choice = -1;

        System.out.println("Welcome to the Event Management System!");

        // Class-wide exception handling for input loop
        try {
            while (choice != 6) {
                printMenu();

                try {
                    System.out.print("Enter choice: ");
                    choice = scanner.nextInt();
                    scanner.nextLine(); // Consume newline left-over

                    switch (choice) {
                        case 1: // Add Registered Attendee
                            System.out.print("Enter Attendee ID: ");
                            String regId = scanner.nextLine();
                            System.out.print("Enter Attendee Name: ");
                            String regName = scanner.nextLine();
                            eventManager.addRegisteredAttendee(regId, regName);
                            break;

                        case 2: // Check-in Attendee
                            System.out.print("Enter Attendee ID: ");
                            String checkInId = scanner.nextLine();
                            eventManager.checkInAttendee(checkInId);
                            break;

                        case 3: // Process Next In Queue
                            eventManager.processNextInQueue();
                            break;

                        case 4: // View Registered Attendees
                            eventManager.viewRegisteredAttendees();
                            break;

                        case 5: // View Check-in Queue
                            eventManager.viewCheckInQueue();
                            break;

                        case 6: // Exit
                            System.out.println("Exiting Event Management System.");
                            break;

                        default:
                            System.err.println("Error: Invalid choice. Please enter a number between 1 and 6.");
                    }
                } catch (InputMismatchException e) {
                    System.err.println("Error: Invalid input. Please enter a number.");
                    scanner.next(); // Consume the invalid input to prevent infinite loop
                    choice = -1; // Reset choice to stay in loop
                } catch (Exception e) {
                    // Catch any other unexpected exceptions during operation
                    System.err.println("An unexpected error occurred: " + e.getMessage());
                    // e.printStackTrace(); // Uncomment for debugging
                }
                System.out.println(); // Add a newline for better readability between operations
            }
        } finally {
            // Ensure scanner is closed even if an exception occurs
            scanner.close();
            System.out.println("Scanner closed.");
        }
    }

    /**
     * Prints the main menu options to the console.
     */
    private static void printMenu() {
        System.out.println("Event Management Menu:");
        System.out.println("1. Add Registered Attendee");
        System.out.println("2. Check-in Attendee");
        System.out.println("3. Process Next In Queue");
        System.out.println("4. View Registered Attendees");
        System.out.println("5. View Check-in Queue");
        System.out.println("6. Exit");
    }
}
