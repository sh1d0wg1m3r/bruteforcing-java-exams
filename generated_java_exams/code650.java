/*
 * Exam Question #650
 * Generated on: 2025-05-12 16:20:02
 * Generated by: Account 2
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Support Ticket Processing System
 * 
 * **Scenario:**
 * You are tasked with developing a command-line application to simulate a basic support ticket processing system. The system needs to manage incoming support requests, allow agents to process them in the order they were received, and maintain an archive of completed tickets.
 * 
 * **Core Functionality:**
 * 1.  **Add Ticket:** Users can add new support tickets by providing a description. Each ticket should automatically be assigned a unique sequential ID and start in a "Pending" state. New tickets enter a queue for processing.
 * 2.  **Process Ticket:** An agent can process the next ticket waiting in the incoming queue. Processing a ticket removes it from the queue, marks its status as "Completed", and moves it to a separate archive list.
 * 3.  **View Tickets:** Users should be able to view either the list of tickets currently waiting in the incoming queue or the list of tickets that have been completed and archived.
 * 4.  **Exit:** The application should provide an option to terminate.
 * 
 * **User Interface:**
 * The system will interact with the user through a simple text-based menu in the console.
 * 
 * **Technical Requirements:**
 * Your solution must demonstrate proficiency with fundamental Java concepts and specifically utilize the following components:
 * 
 * *   `java.util.Queue`: Must be used to store the incoming support tickets, ensuring they are processed in a First-In, First-Out (FIFO) manner.
 * *   `java.util.ArrayList`: Must be used to store the completed support tickets in an archive.
 * *   `java.util.List` interface: The archive collection (`ArrayList`) must be declared using the `List` interface type.
 * *   `java.util.Scanner`: Must be used to read user input from the console (menu choices, ticket descriptions, view options).
 * *   `switch` statement: Must be used to control the main application flow based on the user's menu selection. A nested `switch` can be used for sub-options (like viewing type).
 * *   `System.out`: Must be used for displaying the menu, prompts, success messages, and the contents of the ticket lists.
 * *   `System.err`: Must be used exclusively for displaying error messages (e.g., invalid menu options, attempting to process an empty queue, invalid input).
 * *   Class-wide exception handling: Implement `try-catch` blocks in the main application loop to gracefully handle potential runtime errors, such as invalid user input or system-specific errors (like trying to process a ticket when the queue is empty). Consider defining a custom exception for clarity if appropriate.
 * 
 * **Design Requirements:**
 * *   Create a `Ticket` class with private fields for ID, description, and status, and public methods (getters, constructor, a method to mark as completed). Implement a mechanism for generating unique ticket IDs.
 * *   Create a `SupportSystem` class to encapsulate the application's state (the incoming queue and the completed list) and core logic (adding, processing, viewing tickets). Ensure its fields are private and accessed via public methods.
 * *   Use meaningful names for classes, variables, and methods.
 * *   Include appropriate comments and documentation (e.g., Javadoc for classes and methods).
 * *   Implement basic input validation (e.g., ensure a ticket description is not empty).
 * *   Structure your code into separate classes for clarity and maintainability.
 * 
 * **Expected Output:**
 * The program should start by displaying a menu. Based on user input, it should perform the requested action, print relevant output to `System.out`, print error messages to `System.err` if necessary, and loop back to the menu until the user chooses to exit. A sample interaction might look like this:
 * 
 * ```
 * Support Ticket Processing System
 * Choose an action:
 *   (A)dd new ticket
 *   (P)rocess next ticket
 *   (V)iew tickets
 *   (E)xit
 * Enter your choice: A
 * Enter ticket description: Printer not working
 * 
 * Ticket added: Ticket [ID=1, Status=Pending, Description='Printer not working']
 * 
 * Choose an action:
 *   (A)dd new ticket
 *   (P)rocess next ticket
 *   (V)iew tickets
 *   (E)xit
 * Enter your choice: A
 * Enter ticket description: Can't access email
 * 
 * Ticket added: Ticket [ID=2, Status=Pending, Description='Can't access email']
 * 
 * Choose an action:
 *   (A)dd new ticket
 *   (P)rocess next ticket
 *   (V)iew tickets
 *   (E)xit
 * Enter your choice: V
 * View (I)ncoming or (C)ompleted tickets? I
 * 
 * --- Incoming Tickets ---
 * Ticket [ID=1, Status=Pending, Description='Printer not working']
 * Ticket [ID=2, Status=Pending, Description='Can't access email']
 * ------------------------
 * 
 * Choose an action:
 *   (A)dd new ticket
 *   (P)rocess next ticket
 *   (V)iew tickets
 *   (E)xit
 * Enter your choice: P
 * 
 * Ticket processed: Ticket [ID=1, Status=Completed, Description='Printer not working']
 * 
 * Choose an action:
 *   (A)dd new ticket
 *   (P)rocess next ticket
 *   (V)iew tickets
 *   (E)xit
 * Enter your choice: V
 * View (I)ncoming or (C)ompleted tickets? C
 * 
 * --- Completed Tickets ---
 * Ticket [ID=1, Status=Completed, Description='Printer not working']
 * -------------------------
 * 
 * Choose an action:
 *   (A)dd new ticket
 *   (P)rocess next ticket
 *   (V)iew tickets
 *   (E)xit
 * Enter your choice: X
 * Invalid option. Please enter A, P, V, or E.
 * 
 * Choose an action:
 *   (A)dd new ticket
 *   (P)rocess next ticket
 *   (V)iew tickets
 *   (E)xit
 * Enter your choice: P
 * 
 * Error processing ticket: No tickets in the incoming queue to process.
 * 
 * Choose an action:
 *   (A)dd new ticket
 *   (P)rocess next ticket
 *   (V)iew tickets
 *   (E)xit
 * Enter your choice: E
 * Exiting system. Goodbye!
 * ```
 * 
 * **Constraints:**
 * *   The solution should be a single Java program file containing all necessary classes.
 * *   Focus on meeting all specified technical and design requirements.
 * 
 * **Evaluation:**
 * Your solution will be evaluated on:
 * *   Correctness of implementation according to the requirements.
 * *   Proper usage of all specified Java components.
 * *   Adherence to best practices (encapsulation, naming, comments, validation, error handling).
 * *   Code structure and readability.
 * 
 * Good luck!
 *
 * EXPLANATION:
 * The provided solution implements a simplified support ticket processing system demonstrating the required Java concepts and best practices.
 * 
 * **Architecture:**
 * The system is structured into three main classes:
 * 1.  `Ticket`: Represents a single support ticket, holding its ID, description, and status. It includes a static counter (`nextId`) to ensure each new ticket gets a unique, sequential ID. Encapsulation is achieved by keeping fields private and providing public getters and methods (`markAsCompleted`).
 * 2.  `EmptyQueueException`: A simple custom exception class extending `Exception`. This is used to signal a specific error condition: attempting to process a ticket when the incoming queue is empty. Using a custom exception makes the error handling in the main application clearer.
 * 3.  `SupportSystem`: This class acts as the core manager. It holds the two main collections (`incomingTickets` and `completedTickets`) and contains the business logic for adding, processing, and viewing tickets. Fields are private for encapsulation.
 * 4.  `SupportSystemApp`: This class contains the `main` method, which is the application's entry point. It handles user interaction via the console, drives the main application loop, calls methods on the `SupportSystem` instance, and manages exception handling.
 * 
 * **Usage of Required Components:**
 * 
 * *   **`java.util.Queue`**: The `incomingTickets` field in `SupportSystem` is declared as `Queue<Ticket>` and instantiated using `java.util.LinkedList`. `LinkedList` is a common implementation of `Queue` suitable for this purpose. New tickets are added using `incomingTickets.add()`, and tickets are processed (removed from the front) using `incomingTickets.poll()`, adhering to the FIFO principle.
 * *   **`java.util.ArrayList`**: The `completedTickets` field in `SupportSystem` is instantiated as `new ArrayList<>()`. This collection stores tickets that have been processed. `ArrayList` is suitable as it provides a dynamic, ordered list for archiving.
 * *   **`java.util.List` interface**: The `completedTickets` field is declared using the `List<Ticket>` interface type (`private List<Ticket> completedTickets;`). This demonstrates programming to an interface, which is a key object-oriented design principle offering flexibility (e.g., easily changing the implementation from `ArrayList` to `LinkedList` or `Vector` later if needed, without changing the code that uses the `List` interface methods).
 * *   **`java.util.Scanner`**: An instance of `Scanner` is used in the `main` method of `SupportSystemApp` to read user input from `System.in` for menu choices, ticket descriptions, and view options.
 * *   **`switch` statement**: The main application loop in `main` uses a `switch` statement based on the user's input character ('A', 'P', 'V', 'E') to direct the program flow to the appropriate action. A nested `switch` is used within the 'V' case to handle the sub-option for viewing either incoming or completed tickets.
 * *   **`System.out`**: Used throughout the application for standard output. This includes printing the menu, prompts for input, confirmation messages after adding or processing tickets, and listing the tickets when viewing the queues/lists.
 * *   **`System.err`**: Used specifically for error messages. This is employed when the user enters an invalid menu option, an invalid view sub-option, or when an exception is caught (like trying to process an empty queue or adding a ticket with an empty description).
 * *   **Class-wide exception handling with `try-catch` blocks**: The core logic within the `while` loop in the `main` method is wrapped in a `try-catch` block. This block catches specific exceptions like `IllegalArgumentException` (thrown by `addTicket` for invalid input) and the custom `EmptyQueueException` (thrown by `processNextTicket` when the queue is empty). A general `catch (Exception e)` is also included as a fallback for any other unexpected runtime errors, demonstrating robust error handling for the application's main processing flow.
 * 
 * **Best Practices:**
 * 
 * *   **Encapsulation**: Both `Ticket` and `SupportSystem` classes have their data fields declared as `private` and provide public methods (`getters`, `addTicket`, `processNextTicket`, etc.) to access or modify this data, controlling how the objects' state can be changed.
 * *   **Meaningful Variable and Method Names**: Names like `incomingTickets`, `completedTickets`, `addTicket`, `processNextTicket`, `viewIncomingTickets`, `markAsCompleted` clearly indicate their purpose.
 * *   **Appropriate Comments and Documentation**: Javadoc comments are used for classes and key methods to explain their purpose, parameters, and potential exceptions. Inline comments explain specific logic points (like the static ID counter or validation).
 * *   **Input Validation**: The `addTicket` method explicitly checks if the provided description is null or empty using `description.trim().isEmpty()`. If invalid, it throws an `IllegalArgumentException`, which is caught and reported via `System.err` in `main`.
 * *   **Proper Error Handling**: The use of specific `catch` blocks for known error types (`IllegalArgumentException`, `EmptyQueueException`) allows for tailored error messages. Using `System.err` for errors visually distinguishes them from normal output. The general `catch (Exception e)` prevents the application from crashing on unforeseen errors.
 * *   **Clean Code Structure**: The logic is separated into distinct classes with specific responsibilities (`Ticket` for data, `SupportSystem` for core logic, `SupportSystemApp` for UI/application flow). The `printMenu` method is extracted to keep the `main` method cleaner.
 * 
 * This solution effectively combines various Java collection types, control flow structures, I/O handling, and exception management techniques within a practical scenario, fulfilling all the requirements of the exam task.
 */

import java.util.Queue;
import java.util.LinkedList;
import java.util.List;
import java.util.ArrayList;
import java.util.Scanner;

/**
 * Represents a support ticket in the system.
 */
class Ticket {
    private int id;
    private String description;
    private String status; // e.g., "Pending", "Completed"

    // Static counter to generate unique ticket IDs
    private static int nextId = 1;

    /**
     * Constructs a new Ticket with a description.
     * A unique ID is assigned automatically, and status is set to "Pending".
     * @param description The description of the support issue.
     */
    public Ticket(String description) {
        this.id = nextId++;
        this.description = description;
        this.status = "Pending";
    }

    // --- Getters ---
    public int getId() {
        return id;
    }

    public String getDescription() {
        return description;
    }

    public String getStatus() {
        return status;
    }

    /**
     * Marks the ticket's status as "Completed".
     */
    public void markAsCompleted() {
        this.status = "Completed";
    }

    /**
     * Provides a string representation of the Ticket.
     * @return A formatted string displaying ticket details.
     */
    @Override
    public String toString() {
        return "Ticket [ID=" + id + ", Status=" + status + ", Description='" + description + "']";
    }
}

/**
 * Custom exception for signaling that a queue operation failed because the queue was empty.
 */
class EmptyQueueException extends Exception {
    /**
     * Constructs an EmptyQueueException with the specified detail message.
     * @param message The detail message.
     */
    public EmptyQueueException(String message) {
        super(message);
    }
}

/**
 * Manages the collection of support tickets, including incoming and completed tickets.
 */
class SupportSystem {
    // Queue for incoming tickets (FIFO processing)
    private Queue<Ticket> incomingTickets;
    // List for completed tickets (archive)
    private List<Ticket> completedTickets;

    /**
     * Constructs a new SupportSystem, initializing the incoming queue and completed list.
     */
    public SupportSystem() {
        // LinkedList implements the Queue interface and is suitable here
        incomingTickets = new LinkedList<>();
        // ArrayList implements the List interface and is suitable for the archive
        completedTickets = new ArrayList<>();
    }

    /**
     * Adds a new ticket to the incoming queue.
     * Performs basic validation on the description.
     * @param description The description for the new ticket.
     * @throws IllegalArgumentException if the description is null or empty.
     */
    public void addTicket(String description) {
        // Input validation: description must not be empty
        if (description == null || description.trim().isEmpty()) {
            throw new IllegalArgumentException("Ticket description cannot be empty.");
        }
        Ticket newTicket = new Ticket(description.trim());
        incomingTickets.add(newTicket); // Add to the tail of the queue
        System.out.println("Ticket added: " + newTicket);
    }

    /**
     * Processes the next ticket from the incoming queue.
     * Removes the ticket from the queue, marks it as completed, and adds it to the completed list.
     * @throws EmptyQueueException if the incoming queue is empty.
     */
    public void processNextTicket() throws EmptyQueueException {
        // Check if there are tickets to process
        if (incomingTickets.isEmpty()) {
            throw new EmptyQueueException("No tickets in the incoming queue to process.");
        }
        // Get and remove the head of the queue
        Ticket ticketToProcess = incomingTickets.poll();
        ticketToProcess.markAsCompleted();
        completedTickets.add(ticketToProcess); // Add to the end of the completed list
        System.out.println("Ticket processed: " + ticketToProcess);
    }

    /**
     * Displays all tickets currently in the incoming queue.
     */
    public void viewIncomingTickets() {
        System.out.println("\n--- Incoming Tickets ---");
        if (incomingTickets.isEmpty()) {
            System.out.println("No incoming tickets.");
            return;
        }
        // Iterate through the queue without removing elements
        for (Ticket ticket : incomingTickets) {
            System.out.println(ticket);
        }
        System.out.println("------------------------");
    }

    /**
     * Displays all tickets in the completed archive list.
     */
    public void viewCompletedTickets() {
        System.out.println("\n--- Completed Tickets ---");
        if (completedTickets.isEmpty()) {
            System.out.println("No completed tickets.");
            return;
        }
        // Iterate through the list
        for (Ticket ticket : completedTickets) {
            System.out.println(ticket);
        }
        System.out.println("-------------------------");
    }
}

/**
 * Main application class for the Support Ticket Processing System.
 * Handles user interaction and orchestrates operations on the SupportSystem.
 */
public class SupportSystemApp {

    /**
     * Prints the main menu options to the console.
     */
    private static void printMenu() {
        System.out.println("Choose an action:");
        System.out.println("  (A)dd new ticket");
        System.out.println("  (P)rocess next ticket");
        System.out.println("  (V)iew tickets");
        System.out.println("  (E)xit");
        System.out.print("Enter your choice: ");
    }

    /**
     * The main entry point of the application.
     * Initializes the system, handles user input loop, and manages exceptions.
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        SupportSystem supportSystem = new SupportSystem();
        Scanner scanner = new Scanner(System.in);
        boolean running = true;

        System.out.println("Support Ticket Processing System");

        // Main application loop
        while (running) {
            printMenu();
            // Read user input and convert to uppercase for case-insensitive comparison
            String choice = scanner.nextLine().trim().toUpperCase();

            // Use try-catch block for class-wide exception handling
            try {
                // Use switch statement to handle different menu options
                switch (choice) {
                    case "A": // Add Ticket
                        System.out.print("Enter ticket description: ");
                        String description = scanner.nextLine();
                        supportSystem.addTicket(description); // Potential IllegalArgumentException
                        break;

                    case "P": // Process Ticket
                        supportSystem.processNextTicket(); // Potential EmptyQueueException
                        break;

                    case "V": // View Tickets
                        System.out.print("View (I)ncoming or (C)ompleted tickets? ");
                        String viewChoice = scanner.nextLine().trim().toUpperCase();
                        // Nested switch for view options
                        switch (viewChoice) {
                            case "I":
                                supportSystem.viewIncomingTickets(); // Uses System.out
                                break;
                            case "C":
                                supportSystem.viewCompletedTickets(); // Uses System.out
                                break;
                            default:
                                // Invalid view option handled by System.err
                                System.err.println("Invalid view option. Please enter 'I' or 'C'.");
                        }
                        break;

                    case "E": // Exit
                        System.out.println("Exiting system. Goodbye!"); // Uses System.out
                        running = false; // Exit the loop
                        break;

                    default:
                        // Invalid main menu option handled by System.err
                        System.err.println("Invalid option. Please enter A, P, V, or E.");
                        break;
                }
            } catch (IllegalArgumentException e) {
                // Catch specific validation errors from addTicket
                System.err.println("Error adding ticket: " + e.getMessage());
            } catch (EmptyQueueException e) {
                // Catch specific system state errors from processNextTicket
                System.err.println("Error processing ticket: " + e.getMessage());
            } catch (Exception e) {
                // Catch any other unexpected exceptions
                System.err.println("An unexpected error occurred: " + e.getMessage());
                // e.printStackTrace(); // Uncomment for detailed debugging stack trace
            }

            // Add a blank line for better readability between interactions
            if (running) { // Don't print after exiting
                System.out.println();
            }
        }

        // Close the scanner resource
        scanner.close();
    }
}
