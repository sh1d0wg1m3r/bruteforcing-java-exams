/*
 * Exam Question #943
 * Generated on: 2025-05-12 17:03:11
 * Generated by: Account 4
 * 
 * QUESTION:
 * **Java Programming Exam Task: Task Management System**
 * 
 * **Scenario:**
 * You are tasked with developing a simple command-line application for managing tasks. The system should allow users to add new tasks, process the next task waiting, view pending tasks, and view completed tasks.
 * 
 * **Requirements:**
 * 
 * 1.  **Data Structures:**
 *     *   Maintain a queue (`java.util.Queue`) to hold tasks that are waiting to be processed. Tasks should be processed in First-In, First-Out (FIFO) order.
 *     *   Maintain a list (`java.util.List`, specifically using `java.util.ArrayList`) to store tasks that have been completed.
 * 
 * 2.  **User Interaction:**
 *     *   The application should run in a loop, prompting the user for commands.
 *     *   Use `java.util.Scanner` to read user input from the console (`System.in`).
 * 
 * 3.  **Commands:** Implement the following commands:
 *     *   `add`: Prompts the user for a task description and adds it to the pending task queue.
 *     *   `process`: Takes the next task from the pending queue and moves it to the completed tasks list.
 *     *   `list_pending`: Displays all tasks currently in the pending queue, in order.
 *     *   `list_completed`: Displays all tasks in the completed tasks list.
 *     *   `menu`: Displays the list of available commands.
 *     *   `exit`: Terminates the application.
 * 
 * 4.  **Control Flow:**
 *     *   Use a `switch` statement to handle the different user commands.
 * 
 * 5.  **Output:**
 *     *   Use `System.out` for normal application output (prompts, task lists, confirmations, menu).
 *     *   Use `System.err` for displaying error messages (e.g., invalid command, trying to process from an empty queue, adding an empty task).
 * 
 * 6.  **Error Handling & Validation:**
 *     *   Implement input validation: A task description cannot be empty. Use `System.err` for the error message.
 *     *   Handle the case where the `process` command is issued when the pending queue is empty. Use `System.err` for the error message.
 *     *   Implement class-wide exception handling: Wrap the main execution loop or method in a `try-catch` block to catch any unexpected runtime exceptions and print an error message (including potentially the stack trace) to `System.err`.
 *     *   Handle invalid commands by printing an error message to `System.err`.
 * 
 * 7.  **Best Practices:**
 *     *   Use proper encapsulation (private fields, public methods where necessary).
 *     *   Use meaningful variable and method names.
 *     *   Include appropriate comments to explain the code.
 *     *   Ensure resources like the `Scanner` are properly closed.
 *     *   Structure the code cleanly within a single class.
 * 
 * **Expected Behavior Examples:**
 * 
 * ```
 * --- Task Management System ---
 * Available Commands:
 *   add          - Add a new task
 *   process      - Process the next task from the queue
 *   list_pending - List all pending tasks
 *   list_completed - List all completed tasks
 *   menu         - Display this menu
 *   exit         - Exit the application
 * 
 * Enter command: add
 * Enter task description: Buy groceries
 * Task added to pending: "Buy groceries"
 * 
 * Enter command: add
 * Enter task description: Walk the dog
 * Task added to pending: "Walk the dog"
 * 
 * Enter command: list_pending
 * 
 * --- Pending Tasks ---
 * 1. Buy groceries
 * 2. Walk the dog
 * ---------------------
 * 
 * Enter command: process
 * Processed task: "Buy groceries"
 * 
 * Enter command: list_pending
 * 
 * --- Pending Tasks ---
 * 1. Walk the dog
 * ---------------------
 * 
 * Enter command: list_completed
 * 
 * --- Completed Tasks ---
 * 1. Buy groceries
 * -----------------------
 * 
 * Enter command: process
 * Processed task: "Walk the dog"
 * 
 * Enter command: process
 * Error: No pending tasks to process.
 * 
 * Enter command: add
 * Enter task description:
 * Error: Task description cannot be empty.
 * 
 * Enter command: invalid_command
 * Error: Invalid command. Type 'menu' to see options.
 * 
 * Enter command: exit
 * Exiting Task Management System. Goodbye!
 * System shutdown complete.
 * ```
 * 
 * Your solution should be a single Java file containing the `TaskManagementApp` class (or similar name) with a `main` method to start the application.
 *
 * EXPLANATION:
 * The provided solution implements a simple command-line task management system, demonstrating the required Java concepts:
 * 
 * 1.  **`Queue` and `List`/`ArrayList`:**
 *     *   A `java.util.Queue<String>` named `pendingTasks` is used to store tasks waiting to be processed. `LinkedList` is chosen as a concrete implementation because it efficiently supports queue operations (`offer` for adding, `poll` for removing from the head). This fulfills the FIFO requirement.
 *     *   A `java.util.List<String>` named `completedTasks` is used to store tasks once they are processed. `ArrayList` is used as the concrete implementation, suitable for storing and iterating over completed tasks.
 * 
 * 2.  **`Scanner`:**
 *     *   A `java.util.Scanner` is initialized to read input from `System.in`, allowing the user to interact with the application by typing commands.
 * 
 * 3.  **`switch` Statement:**
 *     *   The main application loop reads user commands and uses a `switch` statement to direct execution to the appropriate method (`addTask`, `processNextTask`, etc.) based on the command string.
 * 
 * 4.  **`System.out` and `System.err`:**
 *     *   `System.out.println()` and `System.out.print()` are used for standard output, such as displaying the menu, prompts, task lists, and confirmations.
 *     *   `System.err.println()` is used specifically for error messages, such as indicating an invalid command, an empty task description, or an attempt to process a task when the pending queue is empty.
 * 
 * 5.  **`try-catch` for Class-wide Exception Handling:**
 *     *   The core `run()` method, which contains the main application loop, is wrapped in a `try-catch-finally` block. This demonstrates class-wide exception handling. While specific, expected errors (like empty queue) are handled with `if` checks and `System.err`, this top-level `catch (Exception e)` block serves as a safety net to capture any unexpected runtime exceptions that might occur during the application's execution, printing the error details to `System.err`.
 *     *   The `finally` block ensures that the `Scanner` resource is closed regardless of whether an exception occurred or the loop terminated normally via the "exit" command.
 * 
 * 6.  **Input Validation and Error Handling:**
 *     *   The `addTask` method checks if the provided `taskDescription` is null or empty using an `if` condition. If invalid, it prints an error to `System.err` and returns without adding the task.
 *     *   The `processNextTask` method uses `pendingTasks.poll()`. If the queue is empty, `poll()` returns `null`. The code checks for this `null` return value and prints an error message to `System.err` if there are no tasks to process.
 *     *   The `default` case in the `switch` statement handles any command that doesn't match the expected cases, printing an "Invalid command" error to `System.err`.
 * 
 * 7.  **Best Practices:**
 *     *   **Encapsulation:** Class fields (`pendingTasks`, `completedTasks`, `scanner`, `running`) are declared as `private`. Public methods (`run`, `main`) provide the external interface, while helper methods (`addTask`, `processNextTask`, etc.) are private.
 *     *   **Meaningful Names:** Variable names (`pendingTasks`, `completedTasks`, `command`, `description`) and method names (`addTask`, `processNextTask`, `listPendingTasks`, `displayMenu`) clearly indicate their purpose.
 *     *   **Comments:** Basic comments explain the purpose of the class, fields, and key methods.
 *     *   **Resource Management:** The `closeScanner()` method is called in the `finally` block to ensure the `Scanner` is closed, preventing resource leaks.
 *     *   **Clean Structure:** The code is organized into distinct methods for each operation, making it readable and maintainable. The `main` method simply creates an instance and calls the `run` method, separating application setup from the main logic.
 * 
 * This solution effectively integrates the required Java components into a functional, albeit simple, application while adhering to good programming practices and demonstrating robust error handling for common scenarios and a general safety net for unexpected issues.
 */

import java.util.Queue;
import java.util.LinkedList; // A common implementation of Queue
import java.util.List;
import java.util.ArrayList;
import java.util.Scanner;

/**
 * A simple command-line application for managing tasks using a Queue and a List.
 * Demonstrates use of Scanner, switch, System.out, System.err, and exception handling.
 */
public class TaskManagementApp {

    // Queue to hold tasks waiting to be processed (FIFO)
    private Queue<String> pendingTasks;
    // List to hold tasks that have been completed
    private List<String> completedTasks;
    // Scanner for reading user input
    private Scanner scanner;
    // Flag to control the main application loop
    private boolean running;

    /**
     * Constructor to initialize the task management system.
     */
    public TaskManagementApp() {
        // Initialize Queue using LinkedList
        this.pendingTasks = new LinkedList<>();
        // Initialize List using ArrayList
        this.completedTasks = new ArrayList<>();
        // Initialize Scanner for standard input
        this.scanner = new Scanner(System.in);
        this.running = true; // Start the application loop
    }

    /**
     * The main method to run the task management application.
     * Includes class-wide exception handling.
     */
    public void run() {
        // Class-wide exception handling using try-catch-finally
        try {
            System.out.println("--- Task Management System ---");
            displayMenu(); // Show initial commands

            // Main application loop
            while (running) {
                System.out.print("\nEnter command: ");
                // Read the whole line and trim whitespace
                String command = scanner.nextLine().trim().toLowerCase();

                // Use switch statement to handle different commands
                switch (command) {
                    case "add":
                        System.out.print("Enter task description: ");
                        String description = scanner.nextLine().trim();
                        addTask(description); // Call method to add task
                        break;
                    case "process":
                        processNextTask(); // Call method to process task
                        break;
                    case "list_pending":
                        listPendingTasks(); // Call method to list pending tasks
                        break;
                    case "list_completed":
                        listCompletedTasks(); // Call method to list completed tasks
                        break;
                    case "menu":
                        displayMenu(); // Call method to display menu
                        break;
                    case "exit":
                        System.out.println("Exiting Task Management System. Goodbye!");
                        running = false; // Set flag to terminate the loop
                        break;
                    default:
                        // Handle invalid commands using System.err
                        System.err.println("Error: Invalid command. Type 'menu' to see options.");
                        break;
                }
            }
        } catch (Exception e) {
            // Catch any unexpected runtime exceptions during the application execution
            System.err.println("\nAn unexpected error occurred:");
            // Print the stack trace to System.err for debugging
            e.printStackTrace(System.err);
        } finally {
            // Ensure the scanner resource is closed properly
            closeScanner();
            System.out.println("System shutdown complete.");
        }
    }

    /**
     * Adds a new task to the pending tasks queue.
     * Includes input validation for the task description.
     * @param taskDescription The description of the task to add.
     */
    private void addTask(String taskDescription) {
        // Validate that the task description is not empty
        if (taskDescription == null || taskDescription.isEmpty()) {
            System.err.println("Error: Task description cannot be empty.");
            return; // Do not add the task if description is invalid
        }
        // Add the task to the end of the pending queue
        // offer() is generally preferred over add() for queues as it returns false on failure
        pendingTasks.offer(taskDescription);
        System.out.println("Task added to pending: \"" + taskDescription + "\"");
    }

    /**
     * Processes the next task from the pending queue.
     * Removes the task from the queue and adds it to the completed list.
     * Handles the case where the pending queue is empty.
     */
    private void processNextTask() {
        // Retrieve and remove the head of the queue.
        // poll() returns null if the queue is empty.
        String task = pendingTasks.poll();
        if (task == null) {
            // Handle the case where the queue is empty using System.err
            System.err.println("Error: No pending tasks to process.");
        } else {
            // Add the processed task to the completed tasks list
            completedTasks.add(task);
            System.out.println("Processed task: \"" + task + "\"");
        }
    }

    /**
     * Displays all tasks currently in the pending tasks queue.
     */
    private void listPendingTasks() {
        System.out.println("\n--- Pending Tasks ---");
        if (pendingTasks.isEmpty()) {
            System.out.println("No pending tasks.");
        } else {
            // Iterate through the queue and print each task.
            // Iterating does not remove elements from the queue.
            int index = 1;
            for (String task : pendingTasks) {
                System.out.println(index++ + ". " + task);
            }
        }
        System.out.println("---------------------");
    }

    /**
     * Displays all tasks currently in the completed tasks list.
     */
    private void listCompletedTasks() {
        System.out.println("\n--- Completed Tasks ---");
        if (completedTasks.isEmpty()) {
            System.out.println("No completed tasks.");
        } else {
            // Iterate through the list and print each completed task.
            for (int i = 0; i < completedTasks.size(); i++) {
                System.out.println((i + 1) + ". " + completedTasks.get(i));
            }
        }
        System.out.println("-----------------------");
    }

    /**
     * Displays the list of available commands to the user.
     */
    private void displayMenu() {
        System.out.println("\nAvailable Commands:");
        System.out.println("  add          - Add a new task");
        System.out.println("  process      - Process the next task from the queue");
        System.out.println("  list_pending - List all pending tasks");
        System.out.println("  list_completed - List all completed tasks");
        System.out.println("  menu         - Display this menu");
        System.out.println("  exit         - Exit the application");
    }

    /**
     * Closes the Scanner resource.
     */
    private void closeScanner() {
        if (scanner != null) {
            scanner.close();
        }
    }

    /**
     * The entry point of the application.
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        // Create an instance of the application and run it
        TaskManagementApp app = new TaskManagementApp();
        app.run();
    }
}
