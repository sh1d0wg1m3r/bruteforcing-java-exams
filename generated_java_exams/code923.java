/*
 * Exam Question #923
 * Generated on: 2025-05-12 17:00:13
 * Generated by: Account 3
 * 
 * QUESTION:
 * ## Advanced Java Programming Exam Task: Building Maintenance Request System
 * 
 * **Problem Description:**
 * 
 * You are tasked with developing a simple command-line application to manage maintenance requests for a building. The system should allow users to add new requests, process the oldest pending request, view all pending requests, and view all completed requests.
 * 
 * **Requirements:**
 * 
 * 1.  **Data Structures:**
 *     *   Use a `java.util.Queue` to store pending maintenance requests. Requests should be processed in the order they are received (First-In, First-Out).
 *     *   Use a `java.util.ArrayList` to store completed maintenance requests.
 *     *   Declare variables holding collections using the `java.util.List` interface where appropriate (e.g., for the completed requests list).
 * 2.  **User Interaction:**
 *     *   Use `java.util.Scanner` to read user input from the console.
 *     *   Present a menu to the user with options:
 *         *   1. Add New Request
 *         *   2. Process Next Request
 *         *   3. View Pending Requests
 *         *   4. View Completed Requests
 *         *   5. Exit
 * 3.  **Flow Control:**
 *     *   Use a `switch` statement to handle the user's menu selection.
 * 4.  **Output:**
 *     *   Use `System.out.println()` for normal output (menu, prompts, request lists, success messages).
 *     *   Use `System.err.println()` for displaying error messages (e.g., invalid input, attempting to process when no requests are pending).
 * 5.  **Error Handling:**
 *     *   Implement class-wide exception handling using `try-catch` blocks to gracefully manage potential issues, such as `InputMismatchException` when reading integer input or handling operations on empty collections where appropriate.
 *     *   Validate user input where necessary (e.g., ensuring a request description is not empty).
 * 6.  **Object-Oriented Design:**
 *     *   Create a class (e.g., `MaintenanceSystem`) to encapsulate the system's state (the queue and list) and behavior (the operations).
 *     *   Use private fields for the data structures and public methods for operations (add, process, view).
 *     *   Include appropriate constructors if needed.
 * 7.  **Code Quality:**
 *     *   Use meaningful variable and method names.
 *     *   Add comments and documentation (e.g., Javadoc) to explain the code.
 *     *   Ensure proper resource management (e.g., closing the `Scanner`).
 * 
 * **Implementation Details:**
 * 
 * *   Each maintenance request can be represented as a simple `String` description (e.g., "Leaky faucet in room 301", "Broken light fixture in hallway").
 * *   When processing a request, remove the request from the queue and add it to the list of completed requests.
 * *   Handle the case where the user tries to process a request when the queue is empty.
 * 
 * **Expected Output:**
 * 
 * The program should display a menu, accept user input, perform the requested action, and display results or errors.
 * 
 * Example Interaction:
 * 
 * ```
 * Maintenance System Menu:
 * 1. Add New Request
 * 2. Process Next Request
 * 3. View Pending Requests
 * 4. View Completed Requests
 * 5. Exit
 * Enter your choice: 1
 * Enter request description: Fix noisy AC in office 5B
 * Request added: Fix noisy AC in office 5B
 * 
 * Maintenance System Menu:
 * ...
 * Enter your choice: 1
 * Enter request description: Replace burnt out bulb in lobby
 * Request added: Replace burnt out bulb in lobby
 * 
 * Maintenance System Menu:
 * ...
 * Enter your choice: 3
 * Pending Requests:
 * 1. Fix noisy AC in office 5B
 * 2. Replace burnt out bulb in lobby
 * 
 * Maintenance System Menu:
 * ...
 * Enter your choice: 2
 * Processing request: Fix noisy AC in office 5B
 * Request processed.
 * 
 * Maintenance System Menu:
 * ...
 * Enter your choice: 3
 * Pending Requests:
 * 1. Replace burnt out bulb in lobby
 * 
 * Maintenance System Menu:
 * ...
 * Enter your choice: 4
 * Completed Requests:
 * 1. Fix noisy AC in office 5B
 * 
 * Maintenance System Menu:
 * ...
 * Enter your choice: 2
 * Processing request: Replace burnt out bulb in lobby
 * Request processed.
 * 
 * Maintenance System Menu:
 * ...
 * Enter your choice: 2
 * System.err: No pending requests to process.
 * 
 * Maintenance System Menu:
 * ...
 * Enter your choice: 5
 * Exiting Maintenance System.
 * ```
 * 
 * Your solution should provide the complete Java code for the `MaintenanceSystem` class and a `main` method to run it.
 * 
 * **Note:** Focus on demonstrating the correct usage of the required Java components and adherence to best practices within the context of this problem.
 *
 * EXPLANATION:
 * This solution provides a `MaintenanceSystem` class that manages maintenance requests using a queue and a list, demonstrating the required Java concepts and best practices.
 * 
 * 1.  **`MaintenanceSystem` Class:** Encapsulates the system's state (`requestQueue`, `completedRequests`) and behavior (methods like `addRequest`, `processNextRequest`).
 * 2.  **Data Structures (`Queue`, `List`, `ArrayList`):**
 *     *   `private Queue<String> requestQueue;`: Declares a field using the `Queue` interface type. It's initialized with a `LinkedList` (`new LinkedList<>()`) because `LinkedList` implements the `Queue` interface and is efficient for adding/removing from ends. This field holds requests waiting to be processed (FIFO).
 *     *   `private List<String> completedRequests;`: Declares a field using the `List` interface type. It's initialized with an `ArrayList` (`new ArrayList<>()`). `ArrayList` is suitable here as we might need to iterate through completed requests or access them by index (though not strictly required by the problem, it's a common use case for completed lists). This field holds requests that have been processed.
 * 3.  **User Input (`Scanner`):**
 *     *   `private Scanner scanner;`: A `Scanner` object is created in the constructor to read input from `System.in`.
 *     *   The `run()` method uses `scanner.nextInt()` to read the menu choice and `scanner.nextLine()` to read the request description. The `scanner.nextLine()` call after `nextInt()` is crucial to consume the leftover newline character.
 * 4.  **Flow Control (`Switch`):**
 *     *   The `run()` method uses a `switch` statement based on the user's `choice` to execute the corresponding method (`addRequest`, `processNextRequest`, etc.).
 * 5.  **Output (`System.out`, `System.err`):**
 *     *   `System.out.println()` is used for displaying the menu, prompts, successful operations, and the contents of the pending and completed lists.
 *     *   `System.err.println()` is used specifically for error messages, such as invalid menu input or attempting to process an empty queue.
 * 6.  **Exception Handling (`try-catch`):**
 *     *   A large `try-catch` block wraps the main `while` loop in the `run()` method. This demonstrates class-wide handling of potential exceptions during the system's operation.
 *     *   Specific `catch` blocks are included within the loop to handle `InputMismatchException` (if the user enters non-integer input for the menu choice) and `IllegalArgumentException` (thrown by `addRequest` for invalid descriptions).
 *     *   A general `catch (Exception e)` is included in the outer block as a fallback for any other unexpected runtime errors.
 *     *   A `finally` block ensures the `Scanner` is closed when the `run` method finishes (either normally or due to an exception).
 * 7.  **Input Validation:**
 *     *   The `addRequest` method explicitly checks if the provided `description` is null or empty using `if (description == null || description.trim().isEmpty())` and throws an `IllegalArgumentException` if it's invalid. This exception is caught and handled in the `run` method.
 * 8.  **Methods:**
 *     *   `addRequest(String description)`: Uses `requestQueue.offer()` to add an element to the end of the queue. `offer()` is generally preferred over `add()` in queues as it returns `false` on failure (though in `LinkedList` it won't fail unless memory is exhausted).
 *     *   `processNextRequest()`: Uses `requestQueue.poll()` to retrieve and remove the head of the queue. `poll()` returns `null` if the queue is empty, which is handled gracefully by printing an error message to `System.err`. If successful, the request is added to the `completedRequests` list using `completedRequests.add()`.
 *     *   `viewPendingRequests()`: Iterates through the `requestQueue` using a for-each loop to display elements without removing them. Checks if the queue is empty first.
 *     *   `viewCompletedRequests()`: Iterates through the `completedRequests` list using a standard for loop (demonstrating indexed access capability of `List`/`ArrayList`). Checks if the list is empty first.
 *     *   `displayMenu()`: A private helper method to print the menu options.
 *     *   `run()`: Contains the main application loop, handles user input, calls other methods based on the `switch` choice, and manages the overall `try-catch` structure.
 * 9.  **Best Practices:**
 *     *   Fields are `private`.
 *     *   Methods are `public` (except `displayMenu` which is an internal helper).
 *     *   Variable and method names are descriptive (`requestQueue`, `processNextRequest`, `completedRequests`).
 *     *   Javadoc comments are included for the class and public methods.
 *     *   Resource management (`scanner.close()`) is handled in the `finally` block.
 * 
 * This solution effectively combines the required Java components and demonstrates essential programming practices within a functional, albeit simple, application.
 */

import java.util.LinkedList;
import java.util.Queue;
import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;
import java.util.InputMismatchException;

/**
 * A system to manage building maintenance requests using a Queue for pending
 * and a List for completed requests.
 */
public class MaintenanceSystem {

    private Queue<String> requestQueue;
    private List<String> completedRequests;
    private Scanner scanner;

    /**
     * Constructs a new MaintenanceSystem.
     */
    public MaintenanceSystem() {
        // Use LinkedList as a Queue implementation
        this.requestQueue = new LinkedList<>();
        // Use ArrayList as a List implementation
        this.completedRequests = new ArrayList<>();
        this.scanner = new Scanner(System.in);
    }

    /**
     * Adds a new maintenance request to the queue.
     *
     * @param description The description of the maintenance request.
     * @throws IllegalArgumentException if the description is null or empty.
     */
    public void addRequest(String description) {
        if (description == null || description.trim().isEmpty()) {
            throw new IllegalArgumentException("Request description cannot be empty.");
        }
        requestQueue.offer(description.trim()); // offer is preferred over add in queues
        System.out.println("Request added: " + description);
    }

    /**
     * Processes the next pending request from the queue.
     * Removes the oldest request from the queue and adds it to the completed list.
     *
     * @return The description of the processed request, or null if the queue was empty.
     */
    public String processNextRequest() {
        String request = requestQueue.poll(); // poll returns null if queue is empty
        if (request != null) {
            completedRequests.add(request);
            System.out.println("Processing request: " + request);
            System.out.println("Request processed.");
        } else {
            System.err.println("No pending requests to process.");
        }
        return request;
    }

    /**
     * Displays all pending maintenance requests currently in the queue.
     */
    public void viewPendingRequests() {
        System.out.println("\n--- Pending Requests ---");
        if (requestQueue.isEmpty()) {
            System.out.println("No pending requests.");
        } else {
            int i = 1;
            // Iterate through the queue without removing elements
            for (String request : requestQueue) {
                System.out.println(i++ + ". " + request);
            }
        }
        System.out.println("------------------------\n");
    }

    /**
     * Displays all completed maintenance requests currently in the list.
     */
    public void viewCompletedRequests() {
        System.out.println("\n--- Completed Requests ---");
        if (completedRequests.isEmpty()) {
            System.out.println("No completed requests.");
        } else {
            for (int i = 0; i < completedRequests.size(); i++) {
                System.out.println((i + 1) + ". " + completedRequests.get(i));
            }
        }
        System.out.println("--------------------------\n");
    }

    /**
     * Displays the main menu to the user.
     */
    private void displayMenu() {
        System.out.println("\nMaintenance System Menu:");
        System.out.println("1. Add New Request");
        System.out.println("2. Process Next Request");
        System.out.println("3. View Pending Requests");
        System.out.println("4. View Completed Requests");
        System.out.println("5. Exit");
        System.out.print("Enter your choice: ");
    }

    /**
     * Runs the main application loop, handling user interaction.
     * Includes class-wide exception handling.
     */
    public void run() {
        int choice = 0;
        boolean running = true;

        // Class-wide try-catch block for the main application loop
        try {
            while (running) {
                displayMenu();

                try {
                    choice = scanner.nextInt();
                    scanner.nextLine(); // Consume newline left-over

                    switch (choice) {
                        case 1:
                            System.out.print("Enter request description: ");
                            String description = scanner.nextLine();
                            addRequest(description); // addRequest has its own validation
                            break;
                        case 2:
                            processNextRequest();
                            break;
                        case 3:
                            viewPendingRequests();
                            break;
                        case 4:
                            viewCompletedRequests();
                            break;
                        case 5:
                            System.out.println("Exiting Maintenance System.");
                            running = false;
                            break;
                        default:
                            System.err.println("Invalid choice. Please enter a number between 1 and 5.");
                    }
                } catch (InputMismatchException e) {
                    System.err.println("Invalid input. Please enter a number.");
                    scanner.nextLine(); // Consume the invalid input to prevent infinite loop
                } catch (IllegalArgumentException e) {
                    System.err.println("Error adding request: " + e.getMessage());
                }
            }
        } catch (Exception e) {
            // Catch any unexpected exceptions during the system's runtime
            System.err.println("An unexpected error occurred: " + e.getMessage());
            e.printStackTrace(); // Print stack trace for debugging
        } finally {
            // Ensure scanner is closed when the application exits
            if (scanner != null) {
                scanner.close();
            }
        }
    }

    /**
     * Main method to start the Maintenance System application.
     *
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        MaintenanceSystem system = new MaintenanceSystem();
        system.run();
    }
}
