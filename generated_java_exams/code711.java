/*
 * Exam Question #711
 * Generated on: 2025-05-12 16:29:14
 * Generated by: Account 3
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Simple Task Scheduler
 * 
 * **Objective:** Design and implement a command-line application for a simple task scheduler. The application should allow users to add new tasks, view all tasks, and process the next task in a queue. This task requires demonstrating proficiency in using core Java collections, input handling, control flow, and error management.
 * 
 * **Scenario:** You are building a basic system to manage tasks. Tasks are added to a master list for record-keeping and also placed into a processing queue. When a user chooses to "process" a task, the next task from the processing queue is removed and marked as processed.
 * 
 * **Requirements:**
 * 
 * 1.  **Task Representation:** Create a `Task` class with the following attributes:
 *     *   A unique integer ID (automatically generated).
 *     *   A String description.
 *     *   Provide appropriate constructors and getter methods.
 * 
 * 2.  **Task Management:** Create a `TaskScheduler` class to manage tasks. This class should internally maintain:
 *     *   A `List` (instantiated as `ArrayList`) to store *all* tasks ever added (a historical record).
 *     *   A `Queue` (choose an appropriate implementation like `LinkedList`) to hold tasks waiting to be processed.
 *     *   Implement methods:
 *         *   `addTask(String description)`: Creates a new `Task`, adds it to both the master `List` and the processing `Queue`. Returns the created `Task`.
 *         *   `getAllTasks()`: Returns the master `List` of tasks.
 *         *   `processNextTask()`: Removes and returns the next task from the processing `Queue`. If the queue is empty, it should indicate this condition (e.g., return null or throw a specific exception, but for this problem, returning null is acceptable).
 * 
 * 3.  **User Interface:** Implement a main application class (e.g., `SchedulerApp`) with a `main` method that provides a command-line interface using `Scanner`. The application should present a menu and process user commands in a loop until the user chooses to exit.
 * 
 * 4.  **Menu Options:** The application should support the following commands via a menu:
 *     *   `1`: Add New Task
 *     *   `2`: View All Tasks
 *     *   `3`: Process Next Task
 *     *   `4`: Exit
 *     *   Any other input should be considered invalid.
 * 
 * 5.  **Input Handling:**
 *     *   Use `Scanner` to read user input for menu choices and task descriptions.
 *     *   Validate user input where necessary (e.g., ensuring a task description is not empty, handling non-integer input for menu choices).
 * 
 * 6.  **Output:**
 *     *   Use `System.out` for displaying the menu, task lists, and successful operations (like adding or processing a task).
 *     *   Use `System.err` for displaying error messages (e.g., invalid menu choice, empty task description, trying to process when the queue is empty).
 * 
 * 7.  **Control Flow:** Use a `switch` statement to handle the different menu options.
 * 
 * 8.  **Exception Handling:** Implement class-wide exception handling in the `main` method using a `try-catch` block to catch potential runtime errors during the application's execution (e.g., `InputMismatchException` from `Scanner`, or other unexpected issues). Specific error conditions (like empty queue) should be handled gracefully within the `TaskScheduler` or immediately after calling its methods.
 * 
 * 9.  **Best Practices:** Adhere to Java best practices including:
 *     *   Proper encapsulation (private fields, public methods/getters).
 *     *   Meaningful variable and method names.
 *     *   Appropriate comments and documentation (briefly explain classes/methods).
 *     *   Clean code structure.
 * 
 * **Expected Output:**
 * 
 * The application should display a menu, prompt for input, and provide output based on the user's choice.
 * 
 * *   **Adding a Task:** Prompt for description, confirm task added with ID and description.
 * *   **Viewing All Tasks:** List all tasks added so far with their ID and description. Indicate if the list is empty.
 * *   **Processing Next Task:** If the queue is not empty, display the ID and description of the processed task. If the queue is empty, display an error message using `System.err`.
 * *   **Invalid Input:** Display an error message using `System.err` for invalid menu choices or invalid task descriptions.
 * *   **Exit:** Display an exit message.
 * *   **General Errors:** If an unexpected exception occurs, the `try-catch` block in `main` should catch it and print an error message using `System.err`.
 * 
 * **Example Interaction Snippet:**
 * 
 * ```
 * --- Task Scheduler Menu ---
 * 1. Add New Task
 * 2. View All Tasks
 * 3. Process Next Task
 * 4. Exit
 * Enter your choice: 1
 * Enter task description: Implement feature X
 * Task added: [ID: 1, Description: Implement feature X]
 * --- Task Scheduler Menu ---
 * 1. Add New Task
 * 2. View All Tasks
 * 3. Process Next Task
 * 4. Exit
 * Enter your choice: 1
 * Enter task description: Write unit tests
 * Task added: [ID: 2, Description: Write unit tests]
 * --- Task Scheduler Menu ---
 * 1. Add New Task
 * 2. View All Tasks
 * 3. Process Next Task
 * 4. Exit
 * Enter your choice: 2
 * All Tasks:
 * [ID: 1, Description: Implement feature X]
 * [ID: 2, Description: Write unit tests]
 * --- Task Scheduler Menu ---
 * 1. Add New Task
 * 2. View All Tasks
 * 3. Process Next Task
 * 4. Exit
 * Enter your choice: 3
 * Processing task: [ID: 1, Description: Implement feature X]
 * --- Task Scheduler Menu ---
 * 1. Add New Task
 * 2. View All Tasks
 * 3. Process Next Task
 * 4. Exit
 * Enter your choice: 3
 * Processing task: [ID: 2, Description: Write unit tests]
 * --- Task Scheduler Menu ---
 * 1. Add New Task
 * 2. View All Tasks
 * 3. Process Next Task
 * 4. Exit
 * Enter your choice: 3
 * Error: No tasks in the processing queue.
 * --- Task Scheduler Menu ---
 * 1. Add New Task
 * 2. View All Tasks
 * 3. Process Next Task
 * 4. Exit
 * Enter your choice: 5
 * Error: Invalid choice. Please enter a number between 1 and 4.
 * --- Task Scheduler Menu ---
 * 1. Add New Task
 * 2. View All Tasks
 * 3. Process Next Task
 * 4. Exit
 * Enter your choice: 4
 * Exiting Task Scheduler.
 * ```
 * 
 * **Evaluation:** Your solution will be evaluated based on correctness, adherence to all requirements (especially the use of specified Java components), code quality, error handling, and clarity.
 *
 * EXPLANATION:
 * This solution implements a simple task scheduler application demonstrating the required Java concepts and best practices.
 * 
 * 1.  **`Task` Class:**
 *     *   Represents a single task.
 *     *   Uses a `static int nextId` to ensure each `Task` object gets a unique, sequential ID upon creation, fulfilling the unique ID requirement.
 *     *   Fields `id` and `description` are `private` for encapsulation.
 *     *   Public `getId()` and `getDescription()` methods provide controlled access to the task's data.
 *     *   `toString()` is overridden for easy printing of task details.
 * 
 * 2.  **`TaskScheduler` Class:**
 *     *   Manages the collections of tasks.
 *     *   `private final List<Task> allTasks;`: Declared as `List`, instantiated with `ArrayList`. This list stores *all* tasks added, serving as a history or master list. `final` ensures the list reference itself isn't changed.
 *     *   `private final Queue<Task> processingQueue;`: Declared as `Queue`, instantiated with `LinkedList`. `LinkedList` is a common implementation of `Queue` and is suitable here for FIFO (First-In, First-Out) processing. This queue holds tasks waiting to be processed. `final` ensures the queue reference isn't changed.
 *     *   `addTask(String description)`:
 *         *   Validates the input description using `if (description == null || description.trim().isEmpty())` and throws an `IllegalArgumentException` if invalid. This demonstrates input validation.
 *         *   Creates a new `Task`.
 *         *   Adds the new task to `allTasks` using `add()`.
 *         *   Adds the new task to `processingQueue` using `offer()`. `offer()` is preferred over `add()` for queues in situations where adding might fail (though less likely with `LinkedList`), as it returns `false` instead of throwing an exception.
 *     *   `getAllTasks()`: Returns a *copy* of the `allTasks` list. Returning a copy (or an unmodifiable list) is a good practice to prevent external code from modifying the internal state of the `TaskScheduler`.
 *     *   `processNextTask()`:
 *         *   Uses `processingQueue.poll()`. The `poll()` method is the standard way to remove and return the head of a `Queue`. It gracefully returns `null` if the queue is empty, which is handled by the caller (`SchedulerApp`). This fulfills the requirement of processing the *next* task and handling the empty case.
 *     *   `isProcessingQueueEmpty()`: A helper method to check if the queue is empty before attempting to process.
 * 
 * 3.  **`SchedulerApp` Class (`main` method):**
 *     *   This is the application entry point and handles the user interaction loop.
 *     *   **`Scanner scanner = new Scanner(System.in)`:** Creates a `Scanner` to read from standard input (`System.in`). It's placed in a try-with-resources block to ensure it's automatically closed, preventing resource leaks.
 *     *   **Class-wide `try-catch`:** The main application logic (the `while` loop and the `switch` statement) is wrapped in a `try-catch(Exception e)` block. This demonstrates catching unexpected exceptions that might occur during the program's execution. The caught exception is printed to `System.err`.
 *     *   **Menu Loop:** A `while(running)` loop keeps the application running until the user chooses to exit.
 *     *   **Input Reading and Validation:**
 *         *   Reads the integer choice using `scanner.nextInt()`.
 *         *   A nested `try-catch(InputMismatchException e)` specifically handles cases where the user enters non-integer input for the menu choice. It prints an error to `System.err` and uses `scanner.next()` to consume the invalid input, preventing an infinite loop caused by `nextInt()` not consuming the non-integer token.
 *         *   `scanner.nextLine()` is called after `scanner.nextInt()` (in the `finally` block or after a successful read) to consume the leftover newline character, which is necessary before the next `scanner.nextLine()` call for reading the task description.
 *     *   **`switch (choice)`:** Controls the application flow based on the user's validated menu choice.
 *         *   **Case 1 (Add Task):** Prompts for description, calls `scheduler.addTask()`. It includes a `try-catch(IllegalArgumentException e)` specifically to handle the validation error thrown by `addTask()` and prints the error message to `System.err`.
 *         *   **Case 2 (View Tasks):** Calls `scheduler.getAllTasks()` and iterates through the returned `List`, printing each `Task` using `System.out`. Checks if the list is empty.
 *         *   **Case 3 (Process Task):** Calls `scheduler.processNextTask()`. Checks if the returned `Task` is `null` (indicating an empty queue) and prints an appropriate message to `System.out` or `System.err`.
 *         *   **Case 4 (Exit):** Sets `running` to `false` to terminate the loop and prints an exit message to `System.out`.
 *         *   **Default:** Handles invalid integer choices, printing an error message to `System.err`.
 *     *   **`System.out` and `System.err`:** Used distinctly as required. `System.out` for normal information, `System.err` for errors and invalid input notifications.
 *     *   **`printMenu()`:** A helper method to keep the `main` method cleaner.
 * 
 * This solution effectively integrates all required components (`Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.err`, `System.out`, `try-catch`) into a practical application, demonstrates good object-oriented design with encapsulation, uses meaningful names, includes basic input validation and error handling, and follows a clear structure.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.InputMismatchException;
import java.util.NoSuchElementException;

/**
 * Represents a single task with an ID and description.
 */
class Task {
    private static int nextId = 1; // Static counter for unique IDs
    private final int id;
    private final String description;

    /**
     * Constructs a new Task with a unique ID and a description.
     * @param description The description of the task.
     */
    public Task(String description) {
        this.id = nextId++;
        this.description = description;
    }

    /**
     * Gets the unique ID of the task.
     * @return The task ID.
     */
    public int getId() {
        return id;
    }

    /**
     * Gets the description of the task.
     * @return The task description.
     */
    public String getDescription() {
        return description;
    }

    @Override
    public String toString() {
        return "[ID: " + id + ", Description: " + description + "]";
    }
}

/**
 * Manages a collection of tasks using a List for history and a Queue for processing.
 */
class TaskScheduler {
    private final List<Task> allTasks; // Stores all tasks ever added
    private final Queue<Task> processingQueue; // Stores tasks waiting to be processed

    /**
     * Constructs a new TaskScheduler.
     */
    public TaskScheduler() {
        this.allTasks = new ArrayList<>();
        this.processingQueue = new LinkedList<>(); // LinkedList implements Queue
    }

    /**
     * Adds a new task to both the master list and the processing queue.
     * @param description The description of the task to add.
     * @return The newly created Task object.
     * @throws IllegalArgumentException if the description is null or empty.
     */
    public Task addTask(String description) {
        if (description == null || description.trim().isEmpty()) {
            throw new IllegalArgumentException("Task description cannot be empty.");
        }
        Task newTask = new Task(description.trim());
        allTasks.add(newTask);
        processingQueue.offer(newTask); // offer is safer than add, returns false if failed (unlikely for LinkedList)
        return newTask;
    }

    /**
     * Returns an immutable view of all tasks ever added to the scheduler.
     * @return A List containing all tasks.
     */
    public List<Task> getAllTasks() {
        // Return a copy or unmodifiable list to prevent external modification
        return new ArrayList<>(allTasks); // Simple copy for this example
    }

    /**
     * Removes and returns the next task from the processing queue.
     * @return The next Task to be processed, or null if the queue is empty.
     */
    public Task processNextTask() {
        // poll() retrieves and removes the head of the queue, or returns null if empty
        return processingQueue.poll();
    }

    /**
     * Checks if the processing queue is empty.
     * @return true if the processing queue is empty, false otherwise.
     */
    public boolean isProcessingQueueEmpty() {
        return processingQueue.isEmpty();
    }
}

/**
 * Main application class for the Simple Task Scheduler.
 * Provides a command-line interface.
 */
public class SchedulerApp {

    public static void main(String[] args) {
        // Use a try-with-resources block for Scanner to ensure it's closed
        try (Scanner scanner = new Scanner(System.in)) {
            TaskScheduler scheduler = new TaskScheduler();
            boolean running = true;

            // Class-wide exception handling for the main loop
            try {
                while (running) {
                    printMenu();
                    System.out.print("Enter your choice: ");

                    int choice = -1; // Default invalid choice
                    try {
                        choice = scanner.nextInt();
                    } catch (InputMismatchException e) {
                        // Consume the invalid input line to prevent infinite loop
                        scanner.next();
                        System.err.println("Error: Invalid input. Please enter a number.");
                        continue; // Go back to the start of the loop
                    } finally {
                         // Consume the newline character left by nextInt()
                         // This is crucial before calling nextLine() later
                         if (scanner.hasNextLine()) {
                             scanner.nextLine();
                         }
                    }


                    // Switch statement for command handling
                    switch (choice) {
                        case 1: // Add New Task
                            System.out.print("Enter task description: ");
                            String description = scanner.nextLine();
                            try {
                                Task newTask = scheduler.addTask(description);
                                System.out.println("Task added: " + newTask);
                            } catch (IllegalArgumentException e) {
                                System.err.println("Error: " + e.getMessage());
                            }
                            break;

                        case 2: // View All Tasks
                            List<Task> allTasks = scheduler.getAllTasks();
                            if (allTasks.isEmpty()) {
                                System.out.println("No tasks added yet.");
                            } else {
                                System.out.println("All Tasks:");
                                for (Task task : allTasks) {
                                    System.out.println(task);
                                }
                            }
                            break;

                        case 3: // Process Next Task
                            Task processedTask = scheduler.processNextTask();
                            if (processedTask != null) {
                                System.out.println("Processing task: " + processedTask);
                            } else {
                                System.err.println("Error: No tasks in the processing queue.");
                            }
                            break;

                        case 4: // Exit
                            running = false;
                            System.out.println("Exiting Task Scheduler.");
                            break;

                        default: // Invalid choice
                            System.err.println("Error: Invalid choice. Please enter a number between 1 and 4.");
                            break;
                    }
                    System.out.println(); // Add a blank line for readability
                }
            } catch (Exception e) {
                // Catch any unexpected exceptions during the main loop execution
                System.err.println("An unexpected error occurred: " + e.getMessage());
                e.printStackTrace(System.err); // Print stack trace to standard error
            }

        } catch (Exception e) {
             // Catch exceptions related to Scanner initialization or closure (less likely in this setup)
             System.err.println("An error occurred while setting up the application: " + e.getMessage());
             e.printStackTrace(System.err);
        }
    }

    /**
     * Prints the main menu options to the console.
     */
    private static void printMenu() {
        System.out.println("--- Task Scheduler Menu ---");
        System.out.println("1. Add New Task");
        System.out.println("2. View All Tasks");
        System.out.println("3. Process Next Task");
        System.out.println("4. Exit");
    }
}
