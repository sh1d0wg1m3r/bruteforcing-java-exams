/*
 * Exam Question #475
 * Generated on: 2025-05-11 23:16:37
 * Generated by: Account 5
 * 
 * QUESTION:
 * ## Java Programming Exam: Advanced Appointment Scheduling System
 * 
 * **Problem Description:**
 * 
 * You are tasked with developing a simplified Appointment Scheduling System for a small clinic. The system needs to manage registered patients and a waiting room queue for patients awaiting their turn to see a doctor.
 * 
 * Your solution must be a single Java program that provides a command-line interface for a receptionist to interact with the system.
 * 
 * **System Requirements:**
 * 
 * 1.  **Patient Management:**
 *     *   Maintain a list of all registered patients. Each patient has a unique ID (String) and a name (String).
 * 2.  **Waiting Room Management:**
 *     *   Maintain a queue of patients currently in the waiting room, processed in First-In, First-Out (FIFO) order. Only registered patients can enter the waiting room.
 * 3.  **User Interface:**
 *     *   Provide a menu-driven interface using `Scanner` for user input.
 *     *   The menu should offer the following options:
 *         *   Register a new patient.
 *         *   Add a registered patient to the waiting room.
 *         *   Call the next patient from the waiting room.
 *         *   List all registered patients.
 *         *   List patients currently in the waiting room.
 *         *   Exit the system.
 * 4.  **Error Handling and Validation:**
 *     *   Handle invalid menu choices.
 *     *   Handle cases where a user tries to add a patient to the waiting room who is not registered.
 *     *   Handle cases where a user tries to call the next patient when the waiting room is empty.
 *     *   Handle non-numeric input for menu choices gracefully using `try-catch`.
 *     *   Report errors using `System.err`.
 *     *   Report normal status messages and output using `System.out`.
 *     *   Implement class-wide exception handling to catch any unexpected runtime errors.
 * 
 * **Technical Requirements:**
 * 
 * Your solution **must** use **ALL** of the following Java components:
 * 
 * *   `java.util.Queue`
 * *   `java.util.ArrayList`
 * *   `java.util.List` interface
 * *   `java.util.Scanner` for user input
 * *   `switch` statement for menu flow control
 * *   `System.err` for error output
 * *   `System.out` for normal output
 * *   `try-catch` blocks for exception handling (including a top-level handler).
 * 
 * **Code Structure and Best Practices:**
 * 
 * *   Use proper encapsulation (private fields, public methods).
 * *   Use meaningful variable and method names.
 * *   Include appropriate comments (Javadoc where applicable, or inline).
 * *   Ensure input validation is performed where necessary.
 * *   Organize code into appropriate classes (e.g., `Patient`, `AppointmentScheduler`).
 * 
 * **Expected Output:**
 * 
 * The program should display a menu, prompt for input, and display relevant output or error messages based on user actions. Examples:
 * 
 * *   Displaying the menu.
 * *   Confirmation messages for successful operations (e.g., "Patient registered successfully.").
 * *   Lists of patients.
 * *   Error messages for invalid operations (e.g., "Error: Patient with ID ... not found.").
 * *   Messages for empty lists/queues (e.g., "Waiting room is empty.").
 * 
 * **Evaluation Criteria:**
 * 
 * *   Correct usage of all required Java components.
 * *   Correct implementation of the appointment scheduling logic.
 * *   Effective use of `Scanner`, `switch`, `System.out`, and `System.err`.
 * *   Robust error handling and input validation using `try-catch`.
 * *   Adherence to best practices (encapsulation, naming, comments).
 * *   Clean and readable code structure.
 * 
 * Good luck!
 *
 * EXPLANATION:
 * This solution implements a basic Appointment Scheduling System, demonstrating the required Java concepts and best practices.
 * 
 * 1.  **Class Structure:**
 *     *   `Patient` class: A simple class encapsulating patient data (`patientId`, `name`) with private fields and public getters, adhering to encapsulation. It includes basic validation in the constructor and overrides `equals` and `hashCode` based on `patientId` for correct behavior in collections.
 *     *   `AppointmentScheduler` class: The main class managing the system's logic and data structures.
 * 
 * 2.  **Data Structures:**
 *     *   `registeredPatients`: Declared as `List<Patient>` and initialized as `new ArrayList<>()`. This uses the `List` interface for type hinting and allows the flexibility of using any `List` implementation, while `ArrayList` provides a dynamic, index-accessible list suitable for storing all registered patients.
 *     *   `waitingRoom`: Declared as `Queue<Patient>` and initialized as `new LinkedList<>()`. `LinkedList` is a common and effective implementation of the `Queue` interface, providing the necessary FIFO behavior for the waiting room.
 * 
 * 3.  **User Input and Menu (`Scanner`, `switch`, `System.out`, `System.err`):**
 *     *   A `Scanner` object reads input from `System.in`.
 *     *   The `run()` method contains the main loop, displaying the menu using `printMenu()`.
 *     *   User input for the menu choice is read.
 *     *   A `switch` statement directs the program flow based on the user's choice, calling the appropriate private methods (`registerPatient`, `addPatientToWaitingRoom`, etc.).
 *     *   `System.out.println()` is used for displaying the menu, prompts, success messages, and lists of patients.
 *     *   `System.err.println()` is specifically used for reporting error conditions, such as invalid menu options, trying to add an unregistered patient, or attempting to call a patient from an empty waiting room.
 * 
 * 4.  **Queue and List Operations:**
 *     *   `registerPatient()`: Adds a new `Patient` object to the `registeredPatients` `ArrayList` using `add()`.
 *     *   `addPatientToWaitingRoom()`: Finds a `Patient` in the `registeredPatients` `List` using a loop and the `equals()` method (implicitly via `findPatientById`). If found, it adds the patient to the `waitingRoom` `Queue` using the `offer()` method (standard Queue method for adding).
 *     *   `callNextPatient()`: Removes and returns the head of the `waitingRoom` `Queue` using the `poll()` method. `poll()` is used because it returns `null` if the queue is empty, allowing for graceful handling without throwing an exception.
 *     *   `listRegisteredPatients()`: Iterates through the `registeredPatients` `List` using a standard for loop with index access (`get(i)`), demonstrating `ArrayList` features.
 *     *   `listWaitingRoom()`: Iterates through the `waitingRoom` `Queue` using an enhanced for loop. Iterating over a `Queue` typically uses an iterator or enhanced for loop which traverses elements without removing them, suitable for listing.
 * 
 * 5.  **Exception Handling (`try-catch`):**
 *     *   **Input Validation:** A `try-catch(InputMismatchException)` block is wrapped around reading the menu choice to handle cases where the user enters non-numeric input. It prints an error to `System.err` and consumes the invalid input from the scanner.
 *     *   **Domain-Specific Errors:** Logic checks (`if` statements) are used for domain-specific errors like "patient not registered" or "waiting room empty". These report errors via `System.err` but don't necessarily throw exceptions unless an invalid argument is passed (like null ID to `Patient` constructor).
 *     *   **IllegalArgumentException:** A `try-catch(IllegalArgumentException)` is included in the `run` method to catch exceptions thrown by the `Patient` constructor if invalid data is passed, demonstrating handling exceptions from other parts of the code.
 *     *   **Class-wide Exception Handling:** The `main` method wraps the call to `scheduler.run()` in a `try-catch(Exception e)` block. This serves as a top-level catch-all for any unexpected runtime exceptions that might propagate up, preventing the program from crashing abruptly and providing a final error message via `System.err` and a stack trace.
 * 
 * 6.  **Best Practices:**
 *     *   Private fields and public methods ensure proper encapsulation.
 *     *   Method names like `registerPatient`, `addPatientToWaitingRoom`, `callNextPatient`, `findPatientById` are descriptive.
 *     *   Variables like `registeredPatients`, `waitingRoom`, `patientId`, `name` are meaningful.
 *     *   Javadoc comments explain the purpose of classes and methods.
 *     *   Input validation checks for empty strings and duplicate IDs in `registerPatient`.
 *     *   Null checks (`patient == null`, `waitingRoom.isEmpty()`) prevent errors before attempting operations.
 *     *   The code is organized into logical methods within the `AppointmentScheduler` class.
 *     *   The `Scanner` is closed in the `run` method after the loop finishes.
 * 
 * This solution effectively integrates all required components into a practical scenario, demonstrating understanding of data structures, control flow, user interaction, and robust error handling in Java.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.InputMismatchException;

/**
 * Represents a Patient in the scheduling system.
 */
class Patient {
    private String patientId;
    private String name;

    /**
     * Constructs a new Patient.
     * @param patientId The unique ID of the patient.
     * @param name The name of the patient.
     */
    public Patient(String patientId, String name) {
        // Basic validation
        if (patientId == null || patientId.trim().isEmpty()) {
            throw new IllegalArgumentException("Patient ID cannot be null or empty.");
        }
        if (name == null || name.trim().isEmpty()) {
            throw new IllegalArgumentException("Patient name cannot be null or empty.");
        }
        this.patientId = patientId.trim();
        this.name = name.trim();
    }

    // Getters
    public String getPatientId() {
        return patientId;
    }

    public String getName() {
        return name;
    }

    @Override
    public String toString() {
        return "ID: " + patientId + ", Name: " + name;
    }

    // Optional: Override equals and hashCode for better collection handling
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Patient patient = (Patient) o;
        return patientId.equals(patient.patientId);
    }

    @Override
    public int hashCode() {
        return patientId.hashCode();
    }
}

/**
 * Manages patient registration and waiting room queue.
 */
public class AppointmentScheduler {

    // Use List interface with ArrayList implementation for registered patients
    private List<Patient> registeredPatients;

    // Use Queue interface with LinkedList implementation for the waiting room
    private Queue<Patient> waitingRoom;

    private Scanner scanner;

    /**
     * Constructs an AppointmentScheduler.
     */
    public AppointmentScheduler() {
        this.registeredPatients = new ArrayList<>(); // ArrayList for dynamic list
        this.waitingRoom = new LinkedList<>(); // LinkedList as a Queue implementation
        this.scanner = new Scanner(System.in);
    }

    /**
     * Runs the main application loop with the menu.
     */
    public void run() {
        int choice = -1;
        while (choice != 6) {
            printMenu();
            try {
                System.out.print("Enter your choice: ");
                choice = scanner.nextInt();
                scanner.nextLine(); // Consume newline left-over

                // Use switch statement for menu navigation
                switch (choice) {
                    case 1:
                        registerPatient();
                        break;
                    case 2:
                        addPatientToWaitingRoom();
                        break;
                    case 3:
                        callNextPatient();
                        break;
                    case 4:
                        listRegisteredPatients();
                        break;
                    case 5:
                        listWaitingRoom();
                        break;
                    case 6:
                        System.out.println("Exiting system. Goodbye!");
                        break;
                    default:
                        // Use System.err for invalid menu options
                        System.err.println("Error: Invalid choice. Please enter a number between 1 and 6.");
                }
            } catch (InputMismatchException e) {
                // Use System.err for non-integer input
                System.err.println("Error: Invalid input. Please enter a number.");
                scanner.nextLine(); // Consume the invalid input to prevent infinite loop
                choice = -1; // Reset choice to continue loop
            } catch (IllegalArgumentException e) {
                 // Catch exceptions from Patient constructor or other argument issues
                 System.err.println("Error: " + e.getMessage());
            } catch (Exception e) {
                // Class-wide exception handling for any unexpected errors
                System.err.println("An unexpected error occurred: " + e.getMessage());
                e.printStackTrace(); // Print stack trace for debugging
            }
            System.out.println(); // Add a blank line for readability
        }
        // Close the scanner when exiting
        scanner.close();
    }

    /**
     * Registers a new patient.
     */
    private void registerPatient() {
        System.out.print("Enter patient ID: ");
        String id = scanner.nextLine();
        System.out.print("Enter patient name: ");
        String name = scanner.nextLine();

        // Input validation for ID and name
        if (id.trim().isEmpty() || name.trim().isEmpty()) {
             System.err.println("Error: Patient ID and name cannot be empty.");
             return;
        }

        // Check if patient ID already exists
        if (findPatientById(id) != null) {
            System.err.println("Error: Patient with ID " + id + " already registered.");
            return;
        }

        try {
             Patient newPatient = new Patient(id, name);
             registeredPatients.add(newPatient); // Add to ArrayList
             System.out.println("Patient registered successfully: " + newPatient); // Use System.out
        } catch (IllegalArgumentException e) {
             // This catch block is technically redundant due to the check above,
             // but demonstrates handling exceptions thrown by other classes/constructors.
             System.err.println("Error creating patient: " + e.getMessage());
        }
    }

    /**
     * Adds a registered patient to the waiting room queue.
     */
    private void addPatientToWaitingRoom() {
        System.out.print("Enter patient ID to add to waiting room: ");
        String id = scanner.nextLine();

        // Find the patient in the registered list
        Patient patient = findPatientById(id);

        if (patient == null) {
            // Use System.err if patient is not registered
            System.err.println("Error: Patient with ID " + id + " is not registered.");
        } else {
             // Check if patient is already in the waiting room (optional but good practice)
             if (waitingRoom.contains(patient)) {
                  System.err.println("Error: Patient with ID " + id + " is already in the waiting room.");
             } else {
                 waitingRoom.offer(patient); // Add to the Queue
                 System.out.println("Patient " + patient.getName() + " added to waiting room."); // Use System.out
             }
        }
    }

    /**
     * Calls the next patient from the waiting room queue.
     */
    private void callNextPatient() {
        // Check if the waiting room is empty
        if (waitingRoom.isEmpty()) {
            // Use System.out for status message (not an error)
            System.out.println("Waiting room is empty. No patients to call.");
        } else {
            Patient nextPatient = waitingRoom.poll(); // Remove from the Queue
            System.out.println("Calling next patient: " + nextPatient.getName() + " (ID: " + nextPatient.getPatientId() + ")"); // Use System.out
        }
    }

    /**
     * Lists all registered patients.
     */
    private void listRegisteredPatients() {
        // Use List interface method size()
        if (registeredPatients.isEmpty()) {
            System.out.println("No patients registered yet."); // Use System.out
        } else {
            System.out.println("--- Registered Patients ---"); // Use System.out
            // Iterate through the List (ArrayList)
            for (int i = 0; i < registeredPatients.size(); i++) {
                Patient patient = registeredPatients.get(i); // Access element by index (ArrayList feature)
                System.out.println((i + 1) + ". " + patient); // Use System.out
            }
            System.out.println("---------------------------");
        }
    }

    /**
     * Lists patients currently in the waiting room.
     */
    private void listWaitingRoom() {
        // Use Queue interface method size()
        if (waitingRoom.isEmpty()) {
            System.out.println("Waiting room is empty."); // Use System.out
        } else {
            System.out.println("--- Waiting Room ---"); // Use System.out
            int i = 1;
            // Iterate through the Queue (LinkedList) without removing elements
            for (Patient patient : waitingRoom) {
                System.out.println(i++ + ". " + patient); // Use System.out
            }
            System.out.println("--------------------");
        }
    }

    /**
     * Finds a patient by their ID in the registered patients list.
     * @param patientId The ID to search for.
     * @return The Patient object if found, otherwise null.
     */
    private Patient findPatientById(String patientId) {
        // Iterate through the List to find a patient
        for (Patient patient : registeredPatients) {
            if (patient.getPatientId().equals(patientId)) {
                return patient;
            }
        }
        return null; // Patient not found
    }

    /**
     * Prints the main menu options.
     */
    private void printMenu() {
        System.out.println("--- Appointment Scheduler Menu ---");
        System.out.println("1. Register Patient");
        System.out.println("2. Add Patient to Waiting Room");
        System.out.println("3. Call Next Patient");
        System.out.println("4. List Registered Patients");
        System.out.println("5. List Waiting Room");
        System.out.println("6. Exit");
        System.out.println("----------------------------------");
    }

    /**
     * Main method to start the application. Includes top-level exception handling.
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        // Top-level try-catch block for class-wide exception handling
        try {
            AppointmentScheduler scheduler = new AppointmentScheduler();
            scheduler.run();
        } catch (Exception e) {
            System.err.println("A critical application error occurred: " + e.getMessage());
            e.printStackTrace(); // Print stack trace for debugging critical errors
        }
    }
}
