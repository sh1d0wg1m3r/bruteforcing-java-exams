/*
 * Exam Question #1151
 * Generated on: 2025-05-12 17:31:58
 * Generated by: Account 3
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Task Management Simulation
 * 
 * **Objective:** Design and implement a simple console-based Task Management System. This system will simulate managing tasks through a processing queue and tracking completed tasks. You must demonstrate your understanding of core Java collections, user input handling, control flow, and error management.
 * 
 * **Scenario:** You are building a basic system where users can submit tasks with a description and priority. These tasks enter a queue to await processing. The system can process the next task in line, moving it to a list of completed tasks. Users can also view the tasks currently waiting and the tasks that have been finished.
 * 
 * **Requirements:**
 * 
 * 1.  **`Task` Class:**
 *     *   Create a class named `Task` with the following **private** fields:
 *         *   `taskId` (int): A unique identifier for the task.
 *         *   `description` (String): A brief description of the task.
 *         *   `priority` (int): An integer representing the task's priority (e.g., 1 for High, 2 for Medium, 3 for Low).
 *         *   `status` (String): The current status of the task (e.g., "Pending", "Completed").
 *     *   Include a constructor to initialize `taskId`, `description`, and `priority`. The initial `status` should always be "Pending".
 *     *   Provide **public** getter methods for all fields.
 *     *   Include a **public** method `markAsCompleted()` that changes the task's status to "Completed".
 *     *   Override the `toString()` method to provide a user-friendly representation of the task.
 * 
 * 2.  **`TaskProcessingSystem` Class:**
 *     *   Create a class named `TaskProcessingSystem` that will manage the tasks.
 *     *   It must have a **private** field that is a `java.util.Queue<Task>` to store tasks waiting to be processed. Use `java.util.LinkedList` as the concrete implementation for the `Queue`.
 *     *   It must have a **private** field that is a `java.util.List<Task>` to store completed tasks. Use `java.util.ArrayList` as the concrete implementation for the `List`.
 *     *   It should have a **private** field `nextTaskId` (int) initialized to 1, used to assign unique IDs to new tasks.
 *     *   It should have a **private** field `scanner` (java.util.Scanner) for reading user input. Initialize it in the constructor.
 *     *   Implement a **public** method `submitTask(String description, int priority)`:
 *         *   Takes the task description and priority as input.
 *         *   Performs input validation: Check if the description is not null or empty, and if the priority is within a valid range (e.g., 1-3).
 *         *   If validation fails, print an appropriate error message using `System.err` and do not create/add the task.
 *         *   If validation passes, create a new `Task` object, assign it the `nextTaskId`, increment `nextTaskId`, and add the new task to the task queue. Print a success message using `System.out`.
 *     *   Implement a **public** method `processNextTask()`:
 *         *   Retrieves and removes the task at the front of the `taskQueue`.
 *         *   If the queue is empty, print an error message using `System.err`.
 *         *   If a task is retrieved, call its `markAsCompleted()` method and add it to the `completedTasks` list. Print a message using `System.out` indicating which task was processed.
 *     *   Implement a **public** method `viewQueue()`:
 *         *   Displays the tasks currently waiting in the `taskQueue`. Print a message using `System.out` if the queue is empty.
 *     *   Implement a **public** method `viewCompletedTasks()`:
 *         *   Displays the tasks in the `completedTasks` list. Print a message using `System.out` if no tasks are completed.
 *     *   Implement a **public** method `run()`:
 *         *   This method should contain the main application loop.
 *         *   Present a menu to the user with the following options:
 *             1.  Submit New Task
 *             2.  Process Next Task
 *             3.  View Waiting Queue
 *             4.  View Completed Tasks
 *             5.  Exit
 *         *   Use `java.util.Scanner` to read the user's menu choice and other required inputs (description, priority). **Be careful with Scanner's newline character issues when mixing `nextInt()` and `nextLine()`. Reading everything as `nextLine()` and parsing is recommended.**
 *         *   Use a `switch` statement to handle the different menu options, calling the appropriate methods (`submitTask`, `processNextTask`, etc.).
 *         *   Implement **class-wide exception handling** using `try-catch` blocks within the `run()` method to catch potential runtime errors (e.g., `NumberFormatException` when parsing input, or other unexpected errors). Report caught exceptions using `System.err`. Ensure the loop can continue after handling an error, unless it's a fatal system error.
 *         *   The loop should continue until the user chooses the "Exit" option.
 *         *   Ensure the `Scanner` is closed when the application exits.
 * 
 * 3.  **`Main` Class:**
 *     *   Create a class named `Main` with a `main` method.
 *     *   The `main` method should create an instance of `TaskProcessingSystem` and call its `run()` method to start the application.
 * 
 * **General Requirements:**
 * 
 * *   Adhere to Java best practices:
 *     *   Use meaningful variable and method names.
 *     *   Include appropriate comments and documentation (e.g., Javadoc for public methods).
 *     *   Maintain proper code indentation and formatting.
 * *   Ensure all required Java components (`Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.err`, `System.out`, `try-catch`) are used correctly as specified.
 * 
 * **Expected Output:** The program should start by displaying the menu. It should then interact with the user, accepting input, performing actions based on the input, and displaying results or error messages. Output should be directed to `System.out` for normal messages and `System.err` for errors.
 * 
 * ---
 *
 * EXPLANATION:
 * This solution implements the Task Management System as described, utilizing all the required Java components.
 * 
 * 1.  **`Task` Class:** A simple Plain Old Java Object (POJO) representing a task. It encapsulates the task's state (`taskId`, `description`, `priority`, `status`) with private fields and provides public getters and a method to change the status. The `toString()` method is overridden for easy printing.
 * 
 * 2.  **`TaskProcessingSystem` Class:** This is the core of the application logic.
 *     *   It uses a `java.util.Queue<Task>` (`LinkedList` implementation) to manage tasks waiting to be processed in a FIFO (First-In, First-Out) manner, fulfilling the `Queue` requirement.
 *     *   It uses a `java.util.List<Task>` (`ArrayList` implementation) to store completed tasks, fulfilling the `List` and `ArrayList` requirements.
 *     *   The `submitTask` method demonstrates input validation (checking for empty description and valid priority range) and adds new tasks to the queue using the `add` method. Validation errors are reported using `System.err`.
 *     *   The `processNextTask` method retrieves and removes the head of the queue using the `poll` method. If the queue is empty, it prints an error to `System.err`. Otherwise, it updates the task's status and adds it to the `completedTasks` list using the `add` method of the `List`.
 *     *   `viewQueue` and `viewCompletedTasks` iterate over the respective collections (using a for-each loop which works for both `Queue` and `List`) and print task details using `System.out`.
 *     *   The `run` method contains the main application loop. It continuously displays a menu and reads user input using `java.util.Scanner`. Reading input as `String` (`nextLine()`) and then parsing is used to avoid common issues with `Scanner`'s newline character when mixing `nextInt()`/`nextDouble()` with `nextLine()`.
 *     *   A `switch` statement is used to dispatch the user's choice to the appropriate method, fulfilling the `switch` requirement.
 *     *   **Exception Handling:** Specific `try-catch(NumberFormatException)` blocks are used around the `Integer.parseInt()` calls to gracefully handle non-numeric input for menu choices and priority, reporting errors to `System.err`. Additionally, the entire `while` loop within `run()` is wrapped in a `try-catch(Exception e)` block. This serves as the "class-wide" exception handler for the main operational part of the class, catching any unexpected runtime exceptions that might occur during the execution of the loop or called methods, printing an error message and stack trace to `System.err`. A `finally` block ensures the `Scanner` is closed when the loop terminates or an exception occurs.
 * 
 * 3.  **`Main` Class:** This is the standard entry point for the application. It simply creates an instance of `TaskProcessingSystem` and calls its `run` method to start the user interaction loop.
 * 
 * The solution adheres to best practices by using private fields with public getters (encapsulation), meaningful names, comments, and separating the concerns into different classes. It demonstrates the practical use of collections, input handling, control flow, and robust error management using `System.out`, `System.err`, and `try-catch` blocks in a cohesive application.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;

// Task.java
/**
 * Represents a single task in the Task Management System.
 */
class Task {
    private int taskId;
    private String description;
    private int priority; // 1: High, 2: Medium, 3: Low
    private String status; // "Pending", "Completed"

    /**
     * Constructs a new Task.
     * @param taskId The unique identifier for the task.
     * @param description The description of the task.
     * @param priority The priority of the task (1-3).
     */
    public Task(int taskId, String description, int priority) {
        this.taskId = taskId;
        this.description = description;
        this.priority = priority;
        this.status = "Pending";
    }

    // Getters
    public int getTaskId() {
        return taskId;
    }

    public String getDescription() {
        return description;
    }

    public int getPriority() {
        return priority;
    }

    public String getStatus() {
        return status;
    }

    /**
     * Marks the task's status as "Completed".
     */
    public void markAsCompleted() {
        this.status = "Completed";
    }

    /**
     * Provides a string representation of the Task.
     * @return A formatted string detailing the task's information.
     */
    @Override
    public String toString() {
        return "Task [ID=" + taskId + ", Desc='" + description + "', Priority=" + priority + ", Status=" + status + "]";
    }
}

// TaskProcessingSystem.java
/**
 * Manages the task queue and completed tasks list.
 * Handles user interaction and application logic.
 */
class TaskProcessingSystem {

    private Queue<Task> taskQueue;
    private List<Task> completedTasks;
    private int nextTaskId;
    private Scanner scanner;

    /**
     * Constructs a TaskProcessingSystem, initializing collections and scanner.
     */
    public TaskProcessingSystem() {
        // Requirement: Use Queue (LinkedList) and List (ArrayList)
        this.taskQueue = new LinkedList<>(); // LinkedList implements Queue
        this.completedTasks = new ArrayList<>(); // ArrayList implements List
        this.nextTaskId = 1;
        // Requirement: Use Scanner
        this.scanner = new Scanner(System.in);
    }

    /**
     * Submits a new task to the processing queue.
     * Validates description and priority before adding.
     * @param description The task description.
     * @param priority The task priority (1-3).
     */
    public void submitTask(String description, int priority) {
        // Input validation
        if (description == null || description.trim().isEmpty()) {
            // Requirement: Use System.err for error messages
            System.err.println("Error: Task description cannot be empty.");
            return;
        }
        if (priority < 1 || priority > 3) {
            // Requirement: Use System.err for error messages
            System.err.println("Error: Task priority must be between 1 (High) and 3 (Low).");
            return;
        }

        Task newTask = new Task(nextTaskId++, description.trim(), priority);
        taskQueue.add(newTask);
        // Requirement: Use System.out for normal output
        System.out.println("Task submitted successfully: " + newTask);
    }

    /**
     * Processes the next task from the queue.
     * Moves the task from the queue to the completed list.
     */
    public void processNextTask() {
        if (taskQueue.isEmpty()) {
            // Requirement: Use System.err for error messages
            System.err.println("Error: Task queue is empty. No tasks to process.");
        } else {
            // Requirement: Use Queue methods (poll)
            Task taskToProcess = taskQueue.poll(); // Retrieves and removes the head of the queue
            if (taskToProcess != null) { // Should not be null if queue is not empty, but good practice
                taskToProcess.markAsCompleted();
                // Requirement: Use List methods (add)
                completedTasks.add(taskToProcess);
                // Requirement: Use System.out for normal output
                System.out.println("Task processed: " + taskToProcess);
            }
        }
    }

    /**
     * Displays the tasks currently in the waiting queue.
     */
    public void viewQueue() {
        // Requirement: Use System.out for normal output
        System.out.println("\n--- Waiting Task Queue ---");
        if (taskQueue.isEmpty()) {
            System.out.println("The queue is currently empty.");
        } else {
            // Iterate without removing elements
            int index = 1;
            for (Task task : taskQueue) {
                System.out.println(index++ + ". " + task);
            }
        }
        System.out.println("--------------------------");
    }

    /**
     * Displays the list of completed tasks.
     */
    public void viewCompletedTasks() {
        // Requirement: Use System.out for normal output
        System.out.println("\n--- Completed Tasks ---");
        if (completedTasks.isEmpty()) {
            System.out.println("No tasks have been completed yet.");
        } else {
            // Requirement: Use List (ArrayList)
            int index = 1;
            for (Task task : completedTasks) {
                System.out.println(index++ + ". " + task);
            }
        }
        System.out.println("-----------------------");
    }

    /**
     * Runs the main application loop.
     * Includes the menu, user input handling, switch statement,
     * and class-wide exception handling.
     */
    public void run() {
        System.out.println("--- Task Management System ---");
        boolean running = true;

        // Requirement: Implement class-wide exception handling with try-catch
        try {
            while (running) {
                printMenu();
                // Requirement: Use System.out for normal output
                System.out.print("Enter your choice: ");

                String choiceStr = scanner.nextLine(); // Read input as string first

                try {
                    int choice = Integer.parseInt(choiceStr); // Parse to integer

                    // Requirement: Use Switch statement
                    switch (choice) {
                        case 1:
                            System.out.print("Enter task description: ");
                            String description = scanner.nextLine();

                            System.out.print("Enter priority (1=High, 2=Medium, 3=Low): ");
                            String priorityStr = scanner.nextLine();
                            try {
                                int priority = Integer.parseInt(priorityStr);
                                submitTask(description, priority);
                            } catch (NumberFormatException e) {
                                // Requirement: Use System.err for error messages
                                System.err.println("Invalid priority input. Please enter a number.");
                            }
                            break;
                        case 2:
                            processNextTask();
                            break;
                        case 3:
                            viewQueue();
                            break;
                        case 4:
                            viewCompletedTasks();
                            break;
                        case 5:
                            running = false;
                            System.out.println("Exiting Task Management System. Goodbye!");
                            break;
                        default:
                            // Requirement: Use System.err for error messages
                            System.err.println("Invalid choice. Please enter a number between 1 and 5.");
                    }
                } catch (NumberFormatException e) {
                    // Requirement: Use System.err for error messages
                    System.err.println("Invalid input. Please enter a number corresponding to the menu option.");
                }
                // Requirement: Use System.out for normal output
                System.out.println(); // Add a newline for better readability between operations
            }
        } catch (Exception e) {
            // This catches any unexpected runtime exceptions during the main loop
            // Requirement: Use System.err for error messages
            System.err.println("An unexpected system error occurred: " + e.getMessage());
            e.printStackTrace(System.err); // Print stack trace to error stream
        } finally {
            // Ensure the scanner is closed when the application exits
            if (scanner != null) {
                scanner.close();
            }
        }
    }

    /**
     * Prints the main menu options to the console.
     */
    private void printMenu() {
        // Requirement: Use System.out for normal output
        System.out.println("\nSelect an option:");
        System.out.println("1. Submit New Task");
        System.out.println("2. Process Next Task");
        System.out.println("3. View Waiting Queue");
        System.out.println("4. View Completed Tasks");
        System.out.println("5. Exit");
    }
}

// Main.java
/**
 * The main class to start the Task Management System application.
 */
class Main {
    /**
     * The entry point of the application.
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        TaskProcessingSystem system = new TaskProcessingSystem();
        system.run();
    }
}
