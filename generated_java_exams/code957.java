/*
 * Exam Question #957
 * Generated on: 2025-05-12 17:05:08
 * Generated by: Account 4
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Simple Task Processor System
 * 
 * **Objective:** Design and implement a console-based application that simulates a simple task processing system. The system should allow users to add new tasks, process the next task in a queue, and view pending or completed tasks. This task requires demonstrating proficiency in using fundamental Java collections, input handling, control flow, and exception handling.
 * 
 * **Requirements:**
 * 
 * 1.  **Task Representation:**
 *     *   Create a class named `Task` to represent a single task.
 *     *   It must have private fields for `description` (String) and `priority` (String, restricted to "High", "Medium", or "Low").
 *     *   Provide a constructor to initialize these fields.
 *     *   Include public getter methods for `description` and `priority`.
 *     *   Override the `toString()` method to provide a user-friendly string representation of the task (e.g., `"[Priority] Description"`).
 * 
 * 2.  **Task Processing Logic:**
 *     *   Create a class named `TaskProcessor`.
 *     *   This class must internally manage two primary data structures:
 *         *   A `java.util.Queue<Task>` to hold tasks that are waiting to be processed (pending tasks). Use a concrete implementation like `java.util.LinkedList`.
 *         *   A `java.util.List<Task>` to hold tasks that have been marked as completed. Use a concrete implementation like `java.util.ArrayList`.
 *     *   Implement the following public methods:
 *         *   `addTask(Task task)`: Adds the given `task` to the pending queue.
 *         *   `processNextTask()`: Attempts to remove a task from the front of the pending queue. If a task is retrieved, it should be added to the completed list. This method should print a message indicating whether a task was processed or if the queue was empty. It should return the processed `Task` object, or `null` if the queue was empty.
 *         *   `getPendingTasks()`: Returns a `java.util.List<Task>` containing all tasks currently in the pending queue. The order should reflect the queue's internal order.
 *         *   `getCompletedTasks()`: Returns a `java.util.List<Task>` containing all tasks that have been moved to the completed list.
 * 
 * 3.  **User Interface and Application Flow:**
 *     *   Create a main application class (e.g., `TaskProcessorApp`) with a `main` method.
 *     *   Use `java.util.Scanner` to read user commands from the console (`System.in`).
 *     *   Implement a command processing loop that continuously prompts the user for input until the "exit" command is entered.
 *     *   Use a `switch` statement to handle the following commands (case-insensitive):
 *         *   `add`: Prompt the user for the task description and priority. Validate that the description is not empty and the priority is one of "High", "Medium", or "Low". Create a `Task` object and add it using the `TaskProcessor`.
 *         *   `process`: Call the `processNextTask()` method of the `TaskProcessor`.
 *         *   `view pending`: Call `getPendingTasks()` and print all pending tasks, numbered.
 *         *   `view completed`: Call `getCompletedTasks()` and print all completed tasks, numbered.
 *         *   `exit`: Terminate the application gracefully.
 *         *   Any other input should be treated as an invalid command.
 *     *   Use `System.out` for all normal output (prompts, success messages, task lists).
 *     *   Use `System.err` for all error messages (invalid command, empty description, invalid priority, unexpected errors).
 * 
 * 4.  **Exception Handling:**
 *     *   Implement exception handling using `try-catch` blocks.
 *     *   Wrap the main command processing loop (or the method containing it) in a `try-catch` block to catch potential runtime exceptions that might occur during command execution (e.g., issues with input parsing if applicable, although less likely with string commands here, it demonstrates the pattern).
 *     *   Ensure graceful handling of scenarios like trying to process from an empty queue (the `Queue.poll()` method is helpful here, returning `null` instead of throwing an exception).
 * 
 * 5.  **Best Practices:**
 *     *   Adhere strictly to proper encapsulation (`private` fields, `public` methods where necessary).
 *     *   Use meaningful and descriptive variable, method, and class names.
 *     *   Include basic comments or Javadoc for classes and methods explaining their purpose.
 *     *   Perform input validation as specified (non-empty description, valid priority).
 *     *   Handle errors using `System.err`.
 *     *   Structure the code logically into appropriate classes.
 *     *   Close the `Scanner` resource when the application exits.
 * 
 * **Example Interaction:**
 * 
 * ```
 * Task Processor System
 * Enter commands: add, process, view pending, view completed, exit
 * > add
 * Enter task description: Finish exam question
 * Enter task priority (High, Medium, Low): High
 * Task added: [High] Finish exam question
 * > add
 * Enter task description: Check email
 * Enter task priority (High, Medium, Low): Low
 * Task added: [Low] Check email
 * > view pending
 * --- Pending Tasks ---
 * 1. [High] Finish exam question
 * 2. [Low] Check email
 * ---------------------
 * > process
 * Processed task: [High] Finish exam question
 * > process
 * Processed task: [Low] Check email
 * > process
 * No tasks in the pending queue to process.
 * > view completed
 * --- Completed Tasks ---
 * 1. [High] Finish exam question
 * 2. [Low] Check email
 * -----------------------
 * > view archive
 * Unknown command. Please use add, process, view pending, view completed, or exit.
 * > add
 * Enter task description:
 * Task description cannot be empty.
 * > add
 * Enter task description: Plan next week
 * Enter task priority (High, Medium, Low): urgent
 * Invalid priority. Please enter High, Medium, or Low.
 * Enter task priority (High, Medium, Low): Medium
 * Task added: [Medium] Plan next week
 * > exit
 * Exiting Task Processor.
 * ```
 *
 * EXPLANATION:
 * This solution implements a simple Task Processor system demonstrating the required Java concepts and best practices.
 * 
 * 1.  **`Task` Class:**
 *     *   Encapsulates task data (`description`, `priority`) using `private` fields.
 *     *   Provides a constructor and public getter methods.
 *     *   The `toString()` method provides a clear representation for printing.
 * 
 * 2.  **`TaskProcessor` Class:**
 *     *   Uses a `java.util.Queue<Task>` (`LinkedList`) for `pendingTasks`. `Queue` is suitable as tasks are processed in a FIFO manner (`processNextTask` takes from the head).
 *     *   Uses a `java.util.List<Task>` (`ArrayList`) for `completedTasks`. `List` is suitable for storing completed items where order might be relevant for viewing, and random access (`ArrayList` provides efficient random access) isn't strictly needed but `ArrayList` is a common concrete `List` implementation.
 *     *   `addTask` uses `queue.offer()` which is a safe way to add to a queue.
 *     *   `processNextTask` uses `queue.poll()`. This is crucial for graceful handling of an empty queue, as `poll()` returns `null` if the queue is empty, unlike `remove()` which would throw `NoSuchElementException`. The method checks for `null` and prints an appropriate message (via `System.out` in `TaskProcessorApp`).
 *     *   `getPendingTasks` and `getCompletedTasks` return `ArrayList` copies of the internal collections. This is good practice to prevent external code from directly modifying the processor's internal state.
 * 
 * 3.  **`TaskProcessorApp` Class:**
 *     *   Contains the `main` method, the entry point of the application.
 *     *   Initializes `Scanner` for console input.
 *     *   The `run()` method contains the main application loop.
 *     *   Reads user input using `scanner.nextLine()`.
 *     *   Converts input to lowercase using `toLowerCase(Locale.ENGLISH)` for case-insensitive command matching.
 *     *   A `switch` statement directs execution based on the command.
 *     *   **`System.out`**: Used for user prompts, successful task operations, and displaying task lists.
 *     *   **`System.err`**: Used specifically for error conditions such as unknown commands, empty descriptions, or invalid priorities.
 *     *   **`Scanner`**: Used for reading input line by line. The `scanner.close()` call in the `finally` block of the `run()` method ensures the resource is released when the application exits, even if an error occurs.
 *     *   **Input Validation**: The `addTask` method explicitly checks if the description is empty and if the entered priority string matches "High", "Medium", or "Low" (case-insensitively), printing `System.err` messages and preventing invalid tasks from being created or added.
 * 
 * 4.  **Exception Handling (`try-catch`):**
 *     *   The core `while (running)` loop in the `run()` method is wrapped in a `try-catch (Exception e)` block. This provides a "class-wide" safety net for the main application logic, catching unexpected runtime exceptions that might occur during command processing.
 *     *   Additionally, the `main` method itself wraps the call to `app.run()` in a `try-catch`. This catches any exceptions that might occur during the `TaskProcessorApp` constructor call or if an exception propagates out of the `run()` method's loop (though the inner `try-catch` in `run` is designed to catch most operational errors). This provides a robust top-level handler.
 * 
 * 5.  **Best Practices:**
 *     *   Code is structured into logical classes (`Task`, `TaskProcessor`, `TaskProcessorApp`).
 *     *   Fields are `private`, methods are `public` where they are part of the public API.
 *     *   Variable and method names are descriptive (e.g., `pendingTasks`, `processNextTask`).
 *     *   Basic comments explain the purpose of classes and methods.
 *     *   Input validation is implemented.
 *     *   Error messages use `System.err`.
 * 
 * This solution effectively integrates `Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.out`, `System.err`, and `try-catch` in a practical scenario, demonstrating a solid understanding of core Java programming concepts and best practices.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.Locale; // To handle case-insensitivity correctly

// Represents a single task with a description and priority.
class Task {
    private String description;
    private String priority; // "High", "Medium", "Low"

    /**
     * Constructs a new Task.
     * @param description The description of the task.
     * @param priority The priority of the task ("High", "Medium", "Low").
     */
    public Task(String description, String priority) {
        this.description = description;
        this.priority = priority;
    }

    /**
     * Gets the description of the task.
     * @return The task description.
     */
    public String getDescription() {
        return description;
    }

    /**
     * Gets the priority of the task.
     * @return The task priority ("High", "Medium", or "Low").
     */
    public String getPriority() {
        return priority;
    }

    /**
     * Returns a string representation of the task.
     * @return Formatted string like "[Priority] Description".
     */
    @Override
    public String toString() {
        return "[" + priority + "] " + description;
    }
}

// Manages the queue of pending tasks and the list of completed tasks.
class TaskProcessor {
    // Queue for tasks waiting to be processed (FIFO).
    private Queue<Task> pendingTasks;
    // List for tasks that have been completed.
    private List<Task> completedTasks;

    /**
     * Constructs a new TaskProcessor, initializing the pending and completed task collections.
     */
    public TaskProcessor() {
        pendingTasks = new LinkedList<>(); // LinkedList implements Queue
        completedTasks = new ArrayList<>(); // ArrayList implements List
    }

    /**
     * Adds a new task to the pending queue.
     * @param task The task to add. Must not be null.
     */
    public void addTask(Task task) {
        if (task != null) {
            pendingTasks.offer(task); // offer is safe, returns false if add fails (unlikely with LinkedList)
            System.out.println("Task added: " + task);
        } else {
            // This check might be redundant if input validation is done before creating Task,
            // but good practice in public methods.
            System.err.println("Error: Cannot add a null task.");
        }
    }

    /**
     * Processes the next task in the pending queue.
     * Moves the task from pending to completed list.
     * @return The processed task, or null if the pending queue was empty.
     */
    public Task processNextTask() {
        Task nextTask = pendingTasks.poll(); // poll retrieves and removes the head, returns null if empty
        if (nextTask != null) {
            completedTasks.add(nextTask);
            System.out.println("Processed task: " + nextTask);
            return nextTask;
        } else {
            // Informational message, not an error, so use System.out
            // The caller (TaskProcessorApp) will print the "No tasks..." message.
            // System.out.println("No tasks in the pending queue to process.");
            return null;
        }
    }

    /**
     * Returns a list containing all tasks currently in the pending queue.
     * Note: This returns a new list containing elements from the queue,
     * preserving the queue's state.
     * @return A List of pending tasks.
     */
    public List<Task> getPendingTasks() {
        // Create a new ArrayList from the queue elements for display.
        // This avoids exposing the internal Queue object and allows easy iteration/indexing.
        return new ArrayList<>(pendingTasks);
    }

    /**
     * Returns a list containing all tasks that have been completed.
     * @return A List of completed tasks.
     */
    public List<Task> getCompletedTasks() {
        // Return a copy of the completed tasks list to prevent external modification.
        return new ArrayList<>(completedTasks);
    }
}

// Main application class for the Task Processor system.
public class TaskProcessorApp {

    private TaskProcessor processor;
    private Scanner scanner;

    /**
     * Constructs the TaskProcessorApp, initializing the processor and scanner.
     */
    public TaskProcessorApp() {
        processor = new TaskProcessor();
        scanner = new Scanner(System.in);
    }

    /**
     * Runs the main application loop, handling user commands.
     */
    public void run() {
        System.out.println("Task Processor System");
        System.out.println("Enter commands: add, process, view pending, view completed, exit");

        boolean running = true;
        // Class-wide exception handling for the main application loop
        try {
            while (running) {
                System.out.print("> ");
                // Read command and convert to lowercase for case-insensitive matching
                String command = scanner.nextLine().trim().toLowerCase(Locale.ENGLISH);

                // Use switch statement for command processing
                switch (command) {
                    case "add":
                        addTask();
                        break;
                    case "process":
                        processTask();
                        break;
                    case "view pending":
                        viewPendingTasks();
                        break;
                    case "view completed":
                        viewCompletedTasks();
                        break;
                    case "exit":
                        running = false; // Set flag to exit loop
                        System.out.println("Exiting Task Processor.");
                        break;
                    default:
                        // Use System.err for invalid command messages
                        System.err.println("Unknown command. Please use add, process, view pending, view completed, or exit.");
                        break;
                }
            }
        } catch (Exception e) {
            // Catch any unexpected exceptions during the main loop execution
            System.err.println("An unexpected error occurred during command processing: " + e.getMessage());
            // Optionally print stack trace for debugging: e.printStackTrace();
        } finally {
             // Ensure the scanner is closed even if an exception occurs or loop exits normally
            if (scanner != null) {
                scanner.close();
            }
        }
    }

    // Handles the 'add' command logic.
    private void addTask() {
        System.out.print("Enter task description: ");
        String description = scanner.nextLine().trim();

        // Input validation for description
        if (description.isEmpty()) {
            System.err.println("Task description cannot be empty.");
            return; // Stop adding task if validation fails
        }

        String priority;
        // Loop for priority input until valid priority is entered
        while (true) {
            System.out.print("Enter task priority (High, Medium, Low): ");
            priority = scanner.nextLine().trim();
            // Input validation for priority (case-insensitive check)
            if (priority.equalsIgnoreCase("High") || priority.equalsIgnoreCase("Medium") || priority.equalsIgnoreCase("Low")) {
                // Capitalize the first letter for consistent storage/display
                priority = priority.substring(0, 1).toUpperCase() + priority.substring(1).toLowerCase(Locale.ENGLISH);
                break; // Valid priority entered, exit loop
            } else {
                System.err.println("Invalid priority. Please enter High, Medium, or Low.");
            }
        }

        // Create Task object and add to processor
        Task newTask = new Task(description, priority);
        processor.addTask(newTask);
    }

    // Handles the 'process' command logic.
    private void processTask() {
        // TaskProcessor's method handles the core logic and prints success message
        Task processedTask = processor.processNextTask();
        // If processNextTask returned null, it means the queue was empty.
        if (processedTask == null) {
            // Use System.out for the informational message about empty queue
            System.out.println("No tasks in the pending queue to process.");
        }
    }

    // Handles the 'view pending' command logic.
    private void viewPendingTasks() {
        List<Task> pending = processor.getPendingTasks(); // Get list from processor
        if (pending.isEmpty()) {
            System.out.println("No pending tasks.");
        } else {
            System.out.println("--- Pending Tasks ---");
            int index = 1;
            // Iterate and print pending tasks
            for (Task task : pending) {
                System.out.println(index++ + ". " + task);
            }
            System.out.println("---------------------");
        }
    }

    // Handles the 'view completed' command logic.
    private void viewCompletedTasks() {
        List<Task> completed = processor.getCompletedTasks(); // Get list from processor
        if (completed.isEmpty()) {
            System.out.println("No completed tasks.");
        } else {
            System.out.println("--- Completed Tasks ---");
            int index = 1;
            // Iterate and print completed tasks
            for (Task task : completed) {
                System.out.println(index++ + ". " + task);
            }
            System.out.println("-----------------------");
        }
    }

    /**
     * Main method to start the Task Processor application.
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        // Class-wide exception handling around the application startup and run
        try {
            TaskProcessorApp app = new TaskProcessorApp();
            app.run(); // Start the main application loop
        } catch (Exception e) {
            // Catch any critical exceptions that might occur during app initialization
            // or if an exception escapes the run() method's try-catch.
            System.err.println("A critical error occurred during application execution: " + e.getMessage());
            // e.printStackTrace(); // Uncomment for detailed debugging
        }
    }
}
