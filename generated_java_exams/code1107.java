/*
 * Exam Question #1107
 * Generated on: 2025-05-12 17:25:50
 * Generated by: Account 4
 * 
 * QUESTION:
 * ## Advanced Java Programming Exam Task: Task Management System
 * 
 * **Scenario:**
 * 
 * You are tasked with developing a simple command-line based Task Management application. This system should allow users to add tasks, track their status (Pending or Completed), and manage a prioritized queue of tasks that need immediate attention.
 * 
 * **Requirements:**
 * 
 * 1.  **Task Representation:** Create a `Task` class with the following attributes:
 *     *   A unique integer ID (assigned automatically).
 *     *   A String description.
 *     *   A status (either `PENDING` or `COMPLETED`). Use an enum for the status.
 *     *   Implement proper encapsulation (private fields, public getters/setters where needed).
 *     *   Override `equals()` and `hashCode()` based on the task ID to correctly identify tasks in collections.
 *     *   Override `toString()` for easy printing.
 * 
 * 2.  **Task Storage:**
 *     *   Maintain a primary list of *all* tasks created. This list should hold `Task` objects regardless of their status. Use `java.util.ArrayList` and declare it using the `java.util.List` interface type.
 *     *   Maintain a separate queue for tasks that have been marked as *prioritized*. Use `java.util.Queue`. When a task is processed from the queue, it should be marked as completed.
 * 
 * 3.  **User Interface:**
 *     *   Provide a text-based menu to the user via the console.
 *     *   Use `java.util.Scanner` to read user input (menu choices, task descriptions, task IDs).
 * 
 * 4.  **Functionality:** Implement the following menu options:
 *     *   `1. Add New Task`: Prompt for a task description and create a new task with status `PENDING`, adding it to the main task list. Assign a unique ID automatically (e.g., incrementing counter).
 *     *   `2. View All Tasks`: Display all tasks from the main list, including their ID, description, and status.
 *     *   `3. View Pending Tasks`: Display only tasks from the main list with status `PENDING`.
 *     *   `4. View Completed Tasks`: Display only tasks from the main list with status `COMPLETED`.
 *     *   `5. View Prioritized Queue`: Display the tasks currently in the prioritized queue.
 *     *   `6. Mark Task Completed`: Prompt for a Task ID. Find the task in the main list and change its status to `COMPLETED`. If the task is also in the prioritized queue, it should effectively be handled by the 'Process Next Prioritized Task' option, so perhaps add a check here. *Correction*: The requirement is to mark completed by ID *from the main list*. Processing from the queue is a separate action. So, this option changes status in the main list directly.
 *     *   `7. Prioritize Task`: Prompt for a Task ID. Find the task in the main list. If it exists, is not already completed, and is not already in the queue, add it to the prioritized queue.
 *     *   `8. Process Next Prioritized Task`: Take the task at the front of the prioritized queue, remove it from the queue, find it in the main list (by ID or reference), and change its status to `COMPLETED`. Handle the case where the queue is empty.
 *     *   `0. Exit`: Terminate the application.
 * 
 * 5.  **Control Flow:** Use a `switch` statement to handle the user's menu choice.
 * 
 * 6.  **Error Handling:**
 *     *   Use `System.err` to print error messages (e.g., invalid menu choice, task not found, invalid input type, attempting to prioritize a completed task or one already in the queue, attempting to process from an empty queue).
 *     *   Use `System.out` for all normal output (menu, task lists, success messages, prompts).
 *     *   Implement class-wide exception handling using `try-catch` blocks to gracefully handle potential runtime errors, such as invalid input formats from the `Scanner` or unexpected issues during operations. Wrap the main operational logic (e.g., the `switch` statement body within the loop) in a `try-catch`.
 * 
 * 7.  **Best Practices:**
 *     *   Ensure proper encapsulation in the `Task` class.
 *     *   Use meaningful names for variables, methods, and classes.
 *     *   Include appropriate comments to explain complex parts.
 *     *   Implement input validation, especially when reading integers for IDs or choices.
 *     *   Structure the code cleanly into classes and methods.
 * 
 * **Expected Output:**
 * 
 * Your program should display the menu, accept user input, perform actions, and print output to `System.out` or `System.err` as specified. Example interactions might look like:
 * 
 * ```
 * Task Management System Menu:
 * 1. Add New Task
 * 2. View All Tasks
 * 3. View Pending Tasks
 * 4. View Completed Tasks
 * 5. View Prioritized Queue
 * 6. Mark Task Completed
 * 7. Prioritize Task
 * 8. Process Next Prioritized Task
 * 0. Exit
 * Enter choice: 1
 * Enter task description: Buy groceries
 * Task 'Buy groceries' (ID 1) added.
 * 
 * Enter choice: 1
 * Enter task description: Prepare presentation
 * Task 'Prepare presentation' (ID 2) added.
 * 
 * Enter choice: 2
 * --- All Tasks ---
 * ID: 1, Description: 'Buy groceries', Status: PENDING
 * ID: 2, Description: 'Prepare presentation', Status: PENDING
 * 
 * Enter choice: 7
 * Enter Task ID to prioritize: 2
 * Task 'Prepare presentation' (ID 2) prioritized.
 * 
 * Enter choice: 5
 * --- Prioritized Queue ---
 * ID: 2, Description: 'Prepare presentation', Status: PENDING
 * 
 * Enter choice: 8
 * Processing next prioritized task...
 * Task 'Prepare presentation' (ID 2) processed and marked completed.
 * 
 * Enter choice: 5
 * --- Prioritized Queue ---
 * (Queue is empty)
 * 
 * Enter choice: 2
 * --- All Tasks ---
 * ID: 1, Description: 'Buy groceries', Status: PENDING
 * ID: 2, Description: 'Prepare presentation', Status: COMPLETED
 * 
 * Enter choice: 6
 * Enter Task ID to mark completed: 1
 * Task 'Buy groceries' (ID 1) marked completed.
 * 
 * Enter choice: 3
 * --- Pending Tasks ---
 * (No pending tasks)
 * 
 * Enter choice: 4
 * --- Completed Tasks ---
 * ID: 1, Description: 'Buy groceries', Status: COMPLETED
 * ID: 2, Description: 'Prepare presentation', Status: COMPLETED
 * 
 * Enter choice: 9
 * Invalid choice. Please try again.
 * (Error message might go to System.err depending on implementation)
 * 
 * Enter choice: abc
 * Invalid input. Please enter a number.
 * (Error message might go to System.err depending on implementation)
 * 
 * Enter choice: 0
 * Exiting Task Manager. Goodbye!
 * ```
 * 
 * Implement the complete Java code for this Task Management System.
 *
 * EXPLANATION:
 * This solution implements a simple Task Management System demonstrating the required Java concepts and best practices.
 * 
 * 1.  **Scenario Mapping:** The scenario of managing tasks with different statuses and a prioritized queue directly maps to the use of `List` (`ArrayList`) for the main task collection and `Queue` (`LinkedList`) for the prioritized tasks. User interaction is handled via a command-line menu using `Scanner` and a `switch` statement. Error reporting uses `System.err`, and normal output uses `System.out`. Unexpected issues are managed with `try-catch`.
 * 
 * 2.  **Required Java Components:**
 *     *   `java.util.Queue`: Used for `prioritizedTasks`. A `LinkedList` is used as the concrete implementation, providing the necessary `offer()` (add) and `poll()` (retrieve and remove) methods for queue operations.
 *     *   `java.util.ArrayList`: Used for `allTasks`. Provides a dynamic, resizable array implementation to store all `Task` objects.
 *     *   `java.util.List`: The `allTasks` variable is declared using the `List` interface type (`List<Task>`), promoting good practice by programming to the interface rather than the concrete implementation.
 *     *   `java.util.Scanner`: Used to read user input from `System.in` for menu choices and task details.
 *     *   `switch` statement: Controls the flow of the program based on the user's menu selection in the `run()` method.
 *     *   `System.err`: Used specifically for printing error messages, distinguishing them from standard output. Examples include invalid input, task not found, or attempting invalid operations (like processing an empty queue).
 *     *   `System.out`: Used for all standard output, such as displaying the menu, task lists, prompts, and success messages.
 *     *   Class-wide exception handling with `try-catch`: A `try-catch(Exception e)` block wraps the core logic within the main `while` loop in the `run()` method. This catches any unexpected runtime exceptions that might occur during the execution of the selected menu option, preventing the program from crashing and providing a basic error message. More specific input validation using `scanner.hasNextInt()` is also used to prevent `InputMismatchException` before it happens for critical integer inputs.
 * 
 * 3.  **Task Class (`Task.java`)**:
 *     *   Models a single task with `id`, `description`, and `status`.
 *     *   `TaskStatus` enum provides a clear and type-safe way to represent the two possible states.
 *     *   Private fields and public getters/setters (`setStatus`) ensure proper encapsulation.
 *     *   `toString()` provides a convenient way to print task details.
 *     *   `equals()` and `hashCode()` are overridden based on the unique `id`. This is crucial for correctly identifying and comparing `Task` objects within collections, particularly when using methods like `Queue.contains()`.
 * 
 * 4.  **Task Manager Class (`TaskManager.java`)**:
 *     *   Holds the main data structures (`allTasks` List, `prioritizedTasks` Queue) and the `Scanner`.
 *     *   `nextTaskId` ensures unique IDs for new tasks.
 *     *   Methods like `addTask`, `viewAllTasks`, `markTaskCompleted`, `prioritizeTask`, `processNextPrioritizedTask` encapsulate the core logic for each operation.
 *     *   `findTaskById` is a helper method to locate tasks in the main list.
 *     *   The `run()` method contains the main application loop, menu display, input reading, `switch` statement, and the primary `try-catch` block.
 *     *   Input validation (`scanner.hasNextInt()`) is performed before attempting to read integers to handle non-numeric input gracefully, printing an error to `System.err`.
 * 
 * 5.  **Error Handling and Input Validation:**
 *     *   Invalid menu choices or invalid task IDs entered by the user are detected and reported using `System.err`.
 *     *   Operations that cannot be performed (e.g., prioritizing a completed task, processing an empty queue) are checked, and appropriate error messages are printed to `System.err`.
 *     *   The `try-catch(Exception e)` in the `run()` method provides a safety net for unexpected errors during execution.
 * 
 * 6.  **Best Practices:**
 *     *   Encapsulation is used in the `Task` class.
 *     *   Method and variable names are descriptive (e.g., `prioritizedTasks`, `processNextPrioritizedTask`).
 *     *   Comments explain the purpose of classes, methods, and important logic sections.
 *     *   Input validation checks for expected input types.
 *     *   Error handling directs error messages to `System.err`.
 *     *   The code is structured into logical methods within the `TaskManager` class, improving readability and maintainability.
 * 
 * This solution effectively combines the required Java components within a practical scenario, demonstrating an understanding of collections, object-oriented principles, user interaction, and robust error handling.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.Objects;

// Enum to represent the status of a task
enum TaskStatus {
    PENDING, COMPLETED
}

// Represents a single task
class Task {
    private int id;
    private String description;
    private TaskStatus status;

    // Constructor
    public Task(int id, String description) {
        this.id = id;
        this.description = description;
        this.status = TaskStatus.PENDING; // New tasks start as PENDING
    }

    // Getters
    public int getId() {
        return id;
    }

    public String getDescription() {
        return description;
    }

    public TaskStatus getStatus() {
        return status;
    }

    // Setter for status
    public void setStatus(TaskStatus status) {
        this.status = status;
    }

    // Override toString for easy printing of task details
    @Override
    public String toString() {
        return "ID: " + id + ", Description: '" + description + "', Status: " + status;
    }

    // Override equals and hashCode based on ID for collection operations (like Queue.contains)
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Task task = (Task) o;
        return id == task.id;
    }

    @Override
    public int hashCode() {
        return Objects.hash(id);
    }
}

// The main class managing tasks
public class TaskManager {
    // Use List interface type, implemented by ArrayList
    private List<Task> allTasks;
    // Use Queue interface type, implemented by LinkedList
    private Queue<Task> prioritizedTasks;
    private Scanner scanner;
    private int nextTaskId; // Counter for assigning unique task IDs

    // Constructor
    public TaskManager() {
        this.allTasks = new ArrayList<>(); // Initialize ArrayList
        this.prioritizedTasks = new LinkedList<>(); // Initialize LinkedList as Queue
        this.scanner = new Scanner(System.in);
        this.nextTaskId = 1; // Start task IDs from 1
    }

    // Displays the main menu
    private void displayMenu() {
        System.out.println("\n--- Task Management System Menu ---");
        System.out.println("1. Add New Task");
        System.out.println("2. View All Tasks");
        System.out.println("3. View Pending Tasks");
        System.out.println("4. View Completed Tasks");
        System.out.println("5. View Prioritized Queue");
        System.out.println("6. Mark Task Completed (by ID)");
        System.out.println("7. Prioritize Task (by ID)");
        System.out.println("8. Process Next Prioritized Task");
        System.out.println("0. Exit");
        System.out.println("-----------------------------------");
    }

    // Adds a new task based on user input
    private void addTask() {
        System.out.print("Enter task description: ");
        String description = scanner.nextLine();
        if (description == null || description.trim().isEmpty()) {
            System.err.println("Error: Task description cannot be empty.");
            return;
        }
        Task newTask = new Task(nextTaskId++, description.trim());
        allTasks.add(newTask);
        System.out.println("Task '" + newTask.getDescription() + "' (ID " + newTask.getId() + ") added.");
    }

    // Displays all tasks in the main list
    private void viewAllTasks() {
        System.out.println("\n--- All Tasks ---");
        if (allTasks.isEmpty()) {
            System.out.println("(No tasks added yet)");
        } else {
            for (Task task : allTasks) {
                System.out.println(task);
            }
        }
    }

    // Displays only pending tasks
    private void viewPendingTasks() {
        System.out.println("\n--- Pending Tasks ---");
        boolean found = false;
        for (Task task : allTasks) {
            if (task.getStatus() == TaskStatus.PENDING) {
                System.out.println(task);
                found = true;
            }
        }
        if (!found) {
            System.out.println("(No pending tasks)");
        }
    }

    // Displays only completed tasks
    private void viewCompletedTasks() {
        System.out.println("\n--- Completed Tasks ---");
        boolean found = false;
        for (Task task : allTasks) {
            if (task.getStatus() == TaskStatus.COMPLETED) {
                System.out.println(task);
                found = true;
            }
        }
        if (!found) {
            System.out.println("(No completed tasks)");
        }
    }

    // Displays tasks in the prioritized queue
    private void viewPrioritizedTasks() {
        System.out.println("\n--- Prioritized Queue ---");
        if (prioritizedTasks.isEmpty()) {
            System.out.println("(Queue is empty)");
        } else {
            // Iterating over the queue does not remove elements
            for (Task task : prioritizedTasks) {
                System.out.println(task);
            }
        }
    }

    // Finds a task in the main list by its ID
    private Task findTaskById(int id) {
        for (Task task : allTasks) {
            if (task.getId() == id) {
                return task;
            }
        }
        return null; // Task not found
    }

    // Marks a task in the main list as completed
    private void markTaskCompleted(int id) {
        Task task = findTaskById(id);
        if (task == null) {
            System.err.println("Error: Task with ID " + id + " not found.");
            return;
        }
        if (task.getStatus() == TaskStatus.COMPLETED) {
            System.out.println("Task '" + task.getDescription() + "' (ID " + id + ") was already completed.");
        } else {
            task.setStatus(TaskStatus.COMPLETED);
            System.out.println("Task '" + task.getDescription() + "' (ID " + id + ") marked completed.");
            // Note: Marking completed manually does NOT remove it from the prioritized queue
            // if it was there. Processing from the queue is the intended way to complete
            // a prioritized task. This is a design choice for this specific scenario.
            // If it should be removed from queue, add: prioritizedTasks.remove(task);
        }
    }

    // Adds a task to the prioritized queue
    private void prioritizeTask(int id) {
        Task task = findTaskById(id);
        if (task == null) {
            System.err.println("Error: Task with ID " + id + " not found.");
            return;
        }
        if (task.getStatus() == TaskStatus.COMPLETED) {
            System.err.println("Error: Task '" + task.getDescription() + "' (ID " + id + ") is already completed.");
            return;
        }
        // Check if the task is already in the prioritized queue
        if (prioritizedTasks.contains(task)) { // Requires Task.equals() and hashCode()
             System.err.println("Error: Task '" + task.getDescription() + "' (ID " + id + ") is already in the prioritized queue.");
             return;
        }

        prioritizedTasks.offer(task); // Add to the end of the queue
        System.out.println("Task '" + task.getDescription() + "' (ID " + id + ") prioritized.");
    }

    // Processes the next task from the prioritized queue
    private void processNextPrioritizedTask() {
        System.out.println("Processing next prioritized task...");
        Task taskToProcess = prioritizedTasks.poll(); // Get and remove the head of the queue

        if (taskToProcess == null) {
            System.err.println("Error: Prioritized queue is empty. No tasks to process.");
            return;
        }

        // The Task object reference retrieved from the queue is the same object
        // stored in the allTasks list. Changing its status here updates it globally.
        if (taskToProcess.getStatus() == TaskStatus.COMPLETED) {
             System.out.println("Task '" + taskToProcess.getDescription() + "' (ID " + taskToProcess.getId() + ") was already completed. Skipping.");
             // This case might happen if a task was manually marked complete (option 6)
             // while also sitting in the prioritized queue.
        } else {
            taskToProcess.setStatus(TaskStatus.COMPLETED);
            System.out.println("Task '" + taskToProcess.getDescription() + "' (ID " + taskToProcess.getId() + ") processed and marked completed.");
        }
    }

    // Main method to run the Task Manager
    public void run() {
        int choice = -1; // Initialize choice to a non-exit value

        // Main application loop
        while (choice != 0) {
            displayMenu();
            System.out.print("Enter choice: ");

            // Class-wide exception handling for potential issues within the loop
            try {
                // Validate if the next input is an integer before reading
                if (scanner.hasNextInt()) {
                    choice = scanner.nextInt();
                    scanner.nextLine(); // Consume the newline character left by nextInt()
                } else {
                    // Handle non-integer input for choice
                    System.err.println("Invalid input. Please enter a number.");
                    scanner.next(); // Consume the invalid input (e.g., "abc")
                    choice = -1; // Reset choice to loop again and show menu
                    continue; // Skip the switch statement for this iteration
                }

                // Use switch statement for menu control
                switch (choice) {
                    case 1:
                        addTask();
                        break;
                    case 2:
                        viewAllTasks();
                        break;
                    case 3:
                        viewPendingTasks();
                        break;
                    case 4:
                        viewCompletedTasks();
                        break;
                    case 5:
                        viewPrioritizedTasks();
                        break;
                    case 6:
                        System.out.print("Enter Task ID to mark completed: ");
                        if (scanner.hasNextInt()) {
                            int id = scanner.nextInt();
                            scanner.nextLine(); // Consume newline
                            markTaskCompleted(id);
                        } else {
                            System.err.println("Invalid Task ID input. Please enter a number.");
                            scanner.next(); // Consume invalid input
                        }
                        break;
                    case 7:
                        System.out.print("Enter Task ID to prioritize: ");
                         if (scanner.hasNextInt()) {
                            int id = scanner.nextInt();
                            scanner.nextLine(); // Consume newline
                            prioritizeTask(id);
                        } else {
                            System.err.println("Invalid Task ID input. Please enter a number.");
                            scanner.next(); // Consume invalid input
                        }
                        break;
                    case 8:
                        processNextPrioritizedTask();
                        break;
                    case 0:
                        System.out.println("Exiting Task Manager. Goodbye!");
                        break;
                    default:
                        // Handle choices outside the defined range
                        System.err.println("Invalid choice. Please try again.");
                }
            } catch (Exception e) {
                // Catch any unexpected exceptions during operation execution
                System.err.println("An unexpected error occurred: " + e.getMessage());
                // In a real application, you might log the full stack trace:
                // e.printStackTrace(System.err);
            }
            System.out.println(); // Add a blank line for better readability between actions
        }

        scanner.close(); // Close the scanner when the application exits
    }

    // Main method to start the application
    public static void main(String[] args) {
        TaskManager manager = new TaskManager();
        manager.run();
    }
}
