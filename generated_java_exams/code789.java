/*
 * Exam Question #789
 * Generated on: 2025-05-12 16:41:06
 * Generated by: Account 4
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Simple Task Management System
 * 
 * **Scenario:**
 * 
 * You are tasked with developing a simple command-line application to manage tasks for a user. The system should allow adding new tasks, completing the oldest pending task, viewing current pending tasks, and viewing completed tasks. Tasks should be processed in the order they were added (First-In, First-Out).
 * 
 * **Requirements:**
 * 
 * 1.  **Design and Implement Classes:**
 *     *   Create a `Task` class to represent a single task. It should have private fields for a unique integer ID, a String description, and a timestamp of creation. Provide a constructor and public getter methods. Ensure the description is not empty or null.
 *     *   Create a `TaskManager` class that manages the collection of tasks. It should internally use a `Queue` to hold pending tasks and a `List` (specifically, an `ArrayList`) to store completed tasks. Provide public methods for:
 *         *   `addTask(String description)`: Adds a new task to the pending queue. Should return a boolean indicating success/failure.
 *         *   `completeNextTask()`: Removes the oldest task from the pending queue and moves it to the completed tasks list. Should return the completed `Task` object, or null if the queue was empty.
 *         *   `viewCurrentTasks()`: Returns a `List` containing all tasks currently in the pending queue, ordered by their position in the queue.
 *         *   `viewCompletedTasks()`: Returns a `List` containing all completed tasks.
 *     *   Create a main application class (e.g., `TaskApp`) containing the `main` method. This class will interact with the user via the console and use the `TaskManager`.
 * 
 * 2.  **Implement User Interface:**
 *     *   The `TaskApp` class should present a menu of options to the user using `System.out`.
 *     *   Use `java.util.Scanner` to read user input (menu choices and task descriptions).
 *     *   Use a loop to keep the application running until the user chooses to exit.
 *     *   Use a `switch` statement to handle the different menu options selected by the user.
 * 
 * 3.  **Implement Error Handling and Validation:**
 *     *   Validate user input where necessary (e.g., ensuring menu choice is a number within the valid range, ensuring task description is not empty).
 *     *   Use `System.err` to display error messages (e.g., invalid input, attempting to complete a task when the queue is empty).
 *     *   Use `System.out` for all normal output (menu, prompts, success messages, task lists).
 *     *   Implement class-wide exception handling using `try-catch` blocks in the `main` method to catch potential runtime issues (like invalid input format) and prevent the application from crashing unexpectedly. Also handle specific expected errors within methods (e.g., empty queue).
 * 
 * 4.  **Adhere to Best Practices:**
 *     *   Use proper encapsulation (private fields, public getters/methods).
 *     *   Use meaningful variable and method names.
 *     *   Include appropriate comments and documentation (e.g., Javadoc for public methods).
 *     *   Ensure clean code structure and formatting.
 * 
 * **Required Java Components:**
 * 
 * You MUST use all of the following components in your solution:
 * *   `java.util.Queue`
 * *   `java.util.ArrayList`
 * *   `java.util.List` interface
 * *   `java.util.Scanner`
 * *   `switch` statement
 * *   `System.err`
 * *   `System.out`
 * *   `try-catch` blocks for exception handling
 * 
 * **Expected Output Flow (Example):**
 * 
 * ```
 * Welcome to the Simple Task Manager!
 * --- Menu ---
 * 1. Add New Task
 * 2. Complete Next Task
 * 3. View Current Tasks
 * 4. View Completed Tasks
 * 5. Exit
 * ------------
 * System.out: Enter your choice: 1
 * System.out: Enter task description: Buy groceries
 * System.out: Task added: Buy groceries
 * 
 * --- Menu ---
 * 1. Add New Task
 * ...
 * System.out: Enter your choice: 1
 * System.out: Enter task description: Pay bills
 * System.out: Task added: Pay bills
 * 
 * --- Menu ---
 * ...
 * System.out: Enter your choice: 3
 * --- Current Tasks (Next to be completed first) ---
 * 1. Task #1: Buy groceries (Created: ...)
 * 2. Task #2: Pay bills (Created: ...)
 * -------------------------------------------------
 * 
 * --- Menu ---
 * ...
 * System.out: Enter your choice: 2
 * System.out: Task completed: Buy groceries
 * 
 * --- Menu ---
 * ...
 * System.out: Enter your choice: 3
 * --- Current Tasks (Next to be completed first) ---
 * 1. Task #2: Pay bills (Created: ...)
 * -------------------------------------------------
 * 
 * --- Menu ---
 * ...
 * System.out: Enter your choice: 2
 * System.out: Task completed: Pay bills
 * 
 * --- Menu ---
 * ...
 * System.out: Enter your choice: 2
 * System.err: No tasks in the queue to complete.
 * 
 * --- Menu ---
 * ...
 * System.out: Enter your choice: 4
 * --- Completed Tasks ---
 * 1. Task #1: Buy groceries (Created: ...)
 * 2. Task #2: Pay bills (Created: ...)
 * -----------------------
 * 
 * --- Menu ---
 * ...
 * System.out: Enter your choice: invalid_input
 * System.err: Invalid input. Please enter a number.
 * 
 * --- Menu ---
 * ...
 * System.out: Enter your choice: 6
 * System.err: Invalid choice. Please enter a number between 1 and 5.
 * 
 * --- Menu ---
 * ...
 * System.out: Enter your choice: 5
 * System.out: Exiting Task Manager. Goodbye!
 * System.out: Scanner closed.
 * ```
 * 
 * Your solution should compile and run, demonstrating the correct usage of all specified components and adherence to best practices.
 *
 * EXPLANATION:
 * This solution implements a simple task management system using core Java collections and control structures, fulfilling all the requirements of the exam question.
 * 
 * 1.  **Task Class:**
 *     *   Represents the data structure for a single task.
 *     *   Uses `private` fields (`id`, `description`, `creationTimestamp`) to enforce encapsulation.
 *     *   An `AtomicInteger` (`idCounter`) is used to generate unique IDs for tasks in a thread-safe manner (although threading isn't the focus here, it's good practice for shared counters).
 *     *   The constructor validates that the description is not empty or null, throwing an `IllegalArgumentException` if it is.
 *     *   Public getter methods provide controlled access to the task's properties.
 *     *   The `toString()` method provides a formatted string representation for easy printing.
 * 
 * 2.  **TaskManager Class:**
 *     *   Acts as the central manager for task collections.
 *     *   Uses a `private Queue<Task> taskQueue` (implemented with `LinkedList`) to store pending tasks. The `Queue` interface is ideal here because tasks are processed in a First-In, First-Out (FIFO) manner. `offer()` is used for adding and `poll()` for removing from the head, which are standard queue operations.
 *     *   Uses a `private List<Task> completedTasks` (implemented with `ArrayList`) to store tasks once they are finished. `ArrayList` provides a dynamic, ordered list suitable for archiving and viewing completed items.
 *     *   `addTask()` creates a `Task` object (triggering its validation) and adds it to the `taskQueue`. It includes a `try-catch` to handle the `IllegalArgumentException` thrown by the `Task` constructor and reports the error via `System.err`.
 *     *   `completeNextTask()` checks if the `taskQueue` is empty first, reporting an error to `System.err` if it is. Otherwise, it uses `poll()` to get and remove the next task from the queue and adds it to the `completedTasks` list.
 *     *   `viewCurrentTasks()` and `viewCompletedTasks()` return `List<Task>`. They create new `ArrayList` instances based on the internal collections and wrap them using `Collections.unmodifiableList()`. This is a best practice to prevent external code from modifying the internal state of the `TaskManager`'s collections directly.
 * 
 * 3.  **TaskApp Class (`main` application):**
 *     *   Contains the `main` method where the application execution begins.
 *     *   Initializes the `TaskManager` and `Scanner` instances.
 *     *   The main application logic is placed in a separate `runApp()` method for better structure.
 *     *   A `while(true)` loop runs the main application cycle until explicitly exited.
 *     *   Inside the loop:
 *         *   The menu is printed using `System.out`.
 *         *   User input for the menu choice is read using `scanner.nextInt()`.
 *         *   A `try-catch(InputMismatchException)` block specifically handles cases where the user enters non-integer input for the menu choice. An error is printed to `System.err`, the invalid input is consumed using `scanner.next()`, and `continue` restarts the loop.
 *         *   A `finally` block after the `nextInt()` read ensures that `scanner.nextLine()` is called to consume the leftover newline character. This is crucial to prevent subsequent `scanner.nextLine()` calls (like the one in `addTask`) from reading an empty string immediately.
 *         *   A `switch` statement processes the valid integer choice, calling the appropriate private helper method (`addTask`, `completeTask`, `viewCurrentTasks`, `viewCompletedTasks`) or exiting the loop (`case 5`). The `default` case handles invalid numeric choices, printing an error to `System.err`.
 *     *   A large `try-catch(Exception)` block wraps the call to `runApp()` in `main`. This provides "class-wide" exception handling, catching any unexpected runtime exceptions that might occur and printing an error to `System.err` before the application terminates.
 *     *   A `finally` block in `main` ensures that the `scanner` is closed when the application exits gracefully or due to an unexpected error, releasing system resources.
 *     *   Helper methods (`printMenu`, `addTask`, `completeTask`, `viewCurrentTasks`, `viewCompletedTasks`) encapsulate the logic for each menu option, improving code organization and readability. These methods interact with the `TaskManager` and use `System.out` and `System.err` as required.
 * 
 * This solution effectively demonstrates the use of `Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.out`, `System.err`, and `try-catch` blocks in a practical, well-structured program adhering to Java best practices.
 */

import java.util.Queue;
import java.util.LinkedList;
import java.util.List;
import java.util.ArrayList;
import java.util.Scanner;
import java.util.InputMismatchException;
import java.util.Collections; // To return unmodifiable lists
import java.util.concurrent.atomic.AtomicInteger; // For unique Task IDs

/**
 * Represents a single task with a unique ID, description, and creation timestamp.
 */
class Task {
    private static final AtomicInteger idCounter = new AtomicInteger(0); // Thread-safe counter for unique IDs
    private int id;
    private String description;
    private long creationTimestamp;

    /**
     * Constructs a new Task.
     * @param description The description of the task. Cannot be null or empty.
     * @throws IllegalArgumentException if the description is null or empty.
     */
    public Task(String description) {
        if (description == null || description.trim().isEmpty()) {
            throw new IllegalArgumentException("Task description cannot be empty.");
        }
        this.id = idCounter.incrementAndGet(); // Assign a unique ID
        this.description = description.trim();
        this.creationTimestamp = System.currentTimeMillis(); // Record creation time
    }

    // Public getter methods for encapsulation
    public int getId() {
        return id;
    }

    public String getDescription() {
        return description;
    }

    public long getCreationTimestamp() {
        return creationTimestamp;
    }

    /**
     * Returns a string representation of the Task.
     */
    @Override
    public String toString() {
        // Using %tF %tT for date and time formatting
        return String.format("Task #%d: %s (Created: %tF %tT)", id, description, creationTimestamp, creationTimestamp);
    }
}

/**
 * Manages the collection of tasks, using a Queue for pending tasks and an ArrayList for completed tasks.
 */
class TaskManager {
    // Using LinkedList as an implementation of Queue for FIFO task management
    private Queue<Task> taskQueue;
    // Using ArrayList as an implementation of List to store completed tasks
    private List<Task> completedTasks;

    /**
     * Constructs a new TaskManager.
     * Initializes the task queue and completed tasks list.
     */
    public TaskManager() {
        taskQueue = new LinkedList<>(); // Initialize the Queue
        completedTasks = new ArrayList<>(); // Initialize the ArrayList
    }

    /**
     * Adds a new task to the pending queue.
     *
     * @param description The description of the task.
     * @return true if the task was added successfully, false otherwise (e.g., invalid description).
     */
    public boolean addTask(String description) {
        try {
            // Task constructor handles description validation and throws IllegalArgumentException
            Task newTask = new Task(description);
            // offer() is generally preferred over add() for queues as it handles capacity constraints gracefully (though LinkedList doesn't have one)
            boolean added = taskQueue.offer(newTask);
            if (added) {
                System.out.println("System.out: Task added: " + newTask.getDescription());
            } else {
                 // This case is unlikely with LinkedList but included for robustness
                 System.err.println("System.err: Failed to add task to the queue unexpectedly.");
            }
            return added;
        } catch (IllegalArgumentException e) {
            // Catch validation errors from Task constructor
            System.err.println("System.err: Error adding task: " + e.getMessage());
            return false;
        } catch (Exception e) {
             // Catch any other unexpected errors during task creation/adding
             System.err.println("System.err: An unexpected error occurred while adding task: " + e.getMessage());
             return false;
        }
    }

    /**
     * Completes the next task in the queue (FIFO). Removes it from the queue and adds it to the completed list.
     *
     * @return The completed Task object, or null if the queue was empty or an error occurred.
     */
    public Task completeNextTask() {
        if (taskQueue.isEmpty()) {
            System.err.println("System.err: No tasks in the queue to complete.");
            return null;
        }
        try {
            // poll() retrieves and removes the head of the queue, returns null if queue is empty
            Task completedTask = taskQueue.poll();
            if (completedTask != null) {
                completedTasks.add(completedTask); // Add the completed task to the list
                System.out.println("System.out: Task completed: " + completedTask.getDescription());
            } else {
                 // This case is unlikely if isEmpty() check passes, but included for robustness
                 System.err.println("System.err: Failed to retrieve task from queue (poll returned null unexpectedly).");
            }
            return completedTask;
        } catch (Exception e) {
            // Catch any other unexpected errors during task completion
            System.err.println("System.err: An unexpected error occurred while completing task: " + e.getMessage());
            return null;
        }
    }

    /**
     * Gets an unmodifiable list of current tasks in the queue.
     * The order reflects the queue's processing order (FIFO).
     *
     * @return A List containing the current tasks. Returns an empty list if the queue is empty.
     */
    public List<Task> viewCurrentTasks() {
        // Create a new ArrayList from the queue elements.
        // This provides a snapshot and avoids exposing the internal queue structure directly.
        // Return an unmodifiable list to prevent external modification.
        return Collections.unmodifiableList(new ArrayList<>(taskQueue));
    }

    /**
     * Gets an unmodifiable list of completed tasks.
     *
     * @return A List containing the completed tasks. Returns an empty list if no tasks are completed.
     */
    public List<Task> viewCompletedTasks() {
        // Return an unmodifiable list of completed tasks to prevent external modification.
        return Collections.unmodifiableList(completedTasks);
    }
}

/**
 * Main application class for the Simple Task Manager. Handles user interaction.
 */
public class TaskApp {
    // Static instance of TaskManager to manage tasks throughout the application lifecycle
    private static TaskManager taskManager = new TaskManager();
    // Static instance of Scanner to read user input from the console
    private static Scanner scanner = new Scanner(System.in);

    public static void main(String[] args) {
        System.out.println("Welcome to the Simple Task Manager!");

        // Class-wide exception handling for the main application loop
        try {
            runApp(); // Delegate the main application logic to a separate method
        } catch (Exception e) {
            // Catch any unexpected runtime exceptions that propagate up
            System.err.println("System.err: An unexpected application error occurred: " + e.getMessage());
            e.printStackTrace(); // Print stack trace for debugging unexpected errors
        } finally {
            // Ensure the scanner is closed when the application exits, regardless of how it exits
            if (scanner != null) {
                scanner.close();
                System.out.println("System.out: Scanner closed.");
            }
        }
    }

    /**
     * Contains the main application loop and menu handling.
     */
    private static void runApp() {
         while (true) {
            printMenu(); // Display the main menu
            int choice = -1; // Variable to store user's menu choice

            // Specific try-catch block for handling potential InputMismatchException when reading integer choice
            try {
                System.out.print("System.out: Enter your choice: ");
                choice = scanner.nextInt();
            } catch (InputMismatchException e) {
                System.err.println("System.err: Invalid input. Please enter a number.");
                scanner.next(); // Consume the invalid input to prevent infinite loop
                continue; // Skip the rest of the loop iteration and show menu again
            } finally {
                 // Consume the rest of the line after reading the integer choice.
                 // This is crucial to prevent nextLine() from reading the leftover newline character.
                 scanner.nextLine();
            }

            // Use switch statement for flow control based on user's choice
            switch (choice) {
                case 1:
                    addTask(); // Call method to handle adding a task
                    break;
                case 2:
                    completeTask(); // Call method to handle completing the next task
                    break;
                case 3:
                    viewCurrentTasks(); // Call method to handle viewing current tasks
                    break;
                case 4:
                    viewCompletedTasks(); // Call method to handle viewing completed tasks
                    break;
                case 5:
                    System.out.println("System.out: Exiting Task Manager. Goodbye!");
                    return; // Exit the runApp method, which will lead to scanner closing in main's finally block
                default:
                    // Handle choices outside the valid range
                    System.err.println("System.err: Invalid choice. Please enter a number between 1 and 5.");
                    break;
            }
            System.out.println(); // Add a newline for better readability between operations
        }
    }

    /**
     * Prints the main menu options to the console.
     */
    private static void printMenu() {
        System.out.println("--- Menu ---");
        System.out.println("1. Add New Task");
        System.out.println("2. Complete Next Task");
        System.out.println("3. View Current Tasks");
        System.out.println("4. View Completed Tasks");
        System.out.println("5. Exit");
        System.out.println("------------");
    }

    /**
     * Handles the process of adding a new task based on user input.
     */
    private static void addTask() {
        System.out.print("System.out: Enter task description: ");
        String description = scanner.nextLine(); // Read the full line for the task description
        // TaskManager handles the actual task creation and adding, including validation feedback
        taskManager.addTask(description);
    }

    /**
     * Handles the process of completing the next task in the queue.
     */
    private static void completeTask() {
        // TaskManager handles the queue logic and provides feedback via System.out/err
        taskManager.completeNextTask();
    }

    /**
     * Handles displaying the current tasks in the queue.
     */
    private static void viewCurrentTasks() {
        List<Task> currentTasks = taskManager.viewCurrentTasks(); // Get the list of current tasks
        if (currentTasks.isEmpty()) {
            System.out.println("System.out: No tasks currently in the queue.");
        } else {
            System.out.println("--- Current Tasks (Next to be completed first) ---");
            // Iterate through the List and print each task
            for (int i = 0; i < currentTasks.size(); i++) {
                System.out.println((i + 1) + ". " + currentTasks.get(i));
            }
            System.out.println("-------------------------------------------------");
        }
    }

    /**
     * Handles displaying the completed tasks.
     */
    private static void viewCompletedTasks() {
         List<Task> completedTasks = taskManager.viewCompletedTasks(); // Get the list of completed tasks
         if (completedTasks.isEmpty()) {
             System.out.println("System.out: No tasks have been completed yet.");
         } else {
             System.out.println("--- Completed Tasks ---");
             // Iterate through the List and print each completed task
             for (int i = 0; i < completedTasks.size(); i++) {
                 System.out.println((i + 1) + ". " + completedTasks.get(i));
             }
             System.out.println("-----------------------");
         }
    }
}
