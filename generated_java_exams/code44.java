/*
 * Exam Question #44
 * Generated on: 2025-05-11 22:04:23
 * Generated by: Account 5
 * 
 * QUESTION:
 * ## Advanced Java Programming Exam Task: Technical Support Ticket Management System
 * 
 * **Problem Description:**
 * 
 * You are tasked with developing a simplified technical support ticket management system. The system should allow users (support agents) to submit new tickets, process the next waiting ticket, view the list of tickets currently waiting, and view a history of tickets that have been processed.
 * 
 * The system must operate interactively via the console, presenting a menu of options to the user.
 * 
 * **Core Requirements:**
 * 
 * 1.  **Ticket Representation:** Create a `Ticket` class to represent a support ticket. Each ticket should have:
 *     *   A unique integer ID (auto-generated or sequentially assigned).
 *     *   A String description of the problem.
 *     *   An integer priority level (e.g., 1 for High, 2 for Medium, 3 for Low).
 *     *   A String status (e.g., "Pending", "Processing", "Resolved").
 *     *   Use proper encapsulation (private fields, public getters).
 * 2.  **System State:** The system needs to manage two collections of tickets:
 *     *   A collection holding tickets that are waiting to be processed. This collection should process tickets in a First-In, First-Out (FIFO) manner, potentially prioritizing based on priority level (though simple FIFO is sufficient for this problem's requirements).
 *     *   A collection holding tickets that have been processed.
 * 3.  **User Interface:** Implement a console-based menu system with the following options:
 *     *   Submit New Ticket
 *     *   Process Next Ticket
 *     *   View Pending Tickets Queue
 *     *   View Processed Tickets History
 *     *   Exit
 * 4.  **Functionality Details:**
 *     *   **Submit New Ticket:** Prompt the user for a description and priority level. Create a new `Ticket` object with a unique ID (start from 1 and increment for each new ticket), initial status "Pending", and add it to the waiting collection.
 *     *   **Process Next Ticket:** Take the next ticket from the waiting collection, change its status to "Processing" (or "Resolved" for simplicity in this exercise), and move it to the processed collection. If the waiting collection is empty, report an error.
 *     *   **View Pending Tickets Queue:** Display the details of all tickets currently in the waiting collection, in the order they would be processed.
 *     *   **View Processed Tickets History:** Display the details of all tickets in the processed collection.
 *     *   **Exit:** Terminate the program.
 * 5.  **Required Java Components:** Your solution *must* utilize **ALL** of the following Java components:
 *     *   `java.util.Queue`: To manage the waiting tickets.
 *     *   `java.util.ArrayList`: To store the history of processed tickets.
 *     *   `java.util.List`: Use `List` as the declared type for the processed tickets history (demonstrating interface usage).
 *     *   `java.util.Scanner`: To read user input from the console.
 *     *   `switch` statement: To handle the user's menu selection.
 *     *   `System.err`: To output error messages (e.g., invalid input, trying to process an empty queue).
 *     *   `System.out`: To output normal information (menu, prompts, ticket details).
 *     *   `try-catch` blocks: To handle potential exceptions, particularly around user input operations and potentially when attempting operations on empty collections. Implement exception handling within the main loop and input reading sections.
 * 
 * **Best Practices:**
 * 
 * *   Implement proper encapsulation for class fields.
 * *   Use meaningful variable and method names.
 * *   Include appropriate comments and basic documentation (like Javadoc for classes/methods).
 * *   Validate user input (e.g., menu choices, priority levels).
 * *   Provide clear error messages using `System.err`.
 * *   Structure your code logically into classes and methods.
 * 
 * **Expected Output:**
 * 
 * The program should present a menu, accept user input, and perform actions based on the input. Example interaction might look like:
 * 
 * ```
 * --- Support Ticket System Menu ---
 * 1. Submit New Ticket
 * 2. Process Next Ticket
 * 3. View Pending Tickets Queue
 * 4. View Processed Tickets History
 * 5. Exit
 * Enter your choice: 1
 * Enter ticket description: Printer not working
 * Enter priority (1=High, 2=Medium, 3=Low): 2
 * Ticket #1 submitted. Status: Pending, Priority: 2
 * 
 * --- Support Ticket System Menu ---
 * 1. Submit New Ticket
 * ... (menu repeats)
 * Enter your choice: 3
 * --- Pending Tickets ---
 * Ticket ID: 1, Description: Printer not working, Priority: 2, Status: Pending
 * --- End Pending Tickets ---
 * 
 * --- Support Ticket System Menu ---
 * ... (menu repeats)
 * Enter your choice: 2
 * Processing ticket #1...
 * Ticket #1 processed. Status: Resolved.
 * 
 * --- Support Ticket System Menu ---
 * ... (menu repeats)
 * Enter your choice: 3
 * --- Pending Tickets ---
 * (Queue is empty)
 * --- End Pending Tickets ---
 * 
 * --- Support Ticket System Menu ---
 * ... (menu repeats)
 * Enter your choice: 4
 * --- Processed Tickets History ---
 * Ticket ID: 1, Description: Printer not working, Priority: 2, Status: Resolved
 * --- End Processed Tickets History ---
 * 
 * --- Support Ticket System Menu ---
 * ... (menu repeats)
 * Enter your choice: 5
 * Exiting system.
 * ```
 * 
 * Error messages should be printed to `System.err`. For example:
 * 
 * ```
 * Enter your choice: abc
 * Error: Invalid input. Please enter a number.
 * 
 * --- Support Ticket System Menu ---
 * ... (menu repeats)
 * Enter your choice: 2
 * Error: No tickets are currently pending processing.
 * ```
 * 
 * Your solution should be a single Java file containing all necessary classes.
 * 
 * **Assessment Criteria:**
 * 
 * *   Correct implementation of all required functionalities.
 * *   Effective use of all specified Java components (`Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.err`, `System.out`, `try-catch`).
 * *   Adherence to best practices (encapsulation, naming, comments, validation, error handling).
 * *   Code clarity and structure.
 * 
 * ```java
 * // Your solution code will go here
 * ```
 *
 * EXPLANATION:
 * This solution implements a simple Technical Support Ticket Management System demonstrating the required Java concepts and best practices.
 * 
 * 1.  **`Ticket` Class:**
 *     *   Represents the data structure for a single ticket.
 *     *   Uses `private` fields (`id`, `description`, `priority`, `status`) for encapsulation.
 *     *   Provides `public` getter methods (`getId`, `getDescription`, etc.) to access field values.
 *     *   Includes a `setStatus` setter method as status needs to change during processing.
 *     *   Uses a `static` `nextId` counter to ensure each new ticket gets a unique, sequential ID.
 *     *   The `toString()` method provides a convenient way to display ticket details.
 * 
 * 2.  **`SupportTicketSystem` Class:**
 *     *   This is the main class that orchestrates the system.
 *     *   **`Queue<Ticket> pendingTicketsQueue`**: Declared as a `Queue` interface type. `LinkedList` is used as the concrete implementation because it provides a common implementation of the `Queue` interface, suitable for FIFO behavior. This collection holds tickets waiting for processing. `offer()` is used to add elements, and `poll()` is used to remove and retrieve the head of the queue.
 *     *   **`List<Ticket> processedTicketsList`**: Declared as a `List` interface type, implemented by `ArrayList`. This demonstrates polymorphism and using the more general interface type. This collection stores tickets that have been processed. `add()` is used to add elements.
 *     *   **`Scanner scanner`**: Used to read input from `System.in`. It's initialized once in the constructor and closed in a `finally` block in the `run` method to ensure resources are released.
 *     *   **`displayMenu()`**: A helper method to print the menu options to `System.out`.
 *     *   **`submitNewTicket()`**: Reads ticket details from the user, creates a new `Ticket` object, and adds it to the `pendingTicketsQueue` using `offer()`. Includes input validation for priority and uses a `try-catch` block to handle `InputMismatchException` if the user enters non-numeric input for priority. Error messages are printed to `System.err`.
 *     *   **`processNextTicket()`**: Attempts to retrieve and remove the next ticket from the `pendingTicketsQueue` using `poll()`. If `poll()` returns `null` (meaning the queue is empty), an error message is printed to `System.err`. Otherwise, the ticket's status is updated, and it's added to the `processedTicketsList`.
 *     *   **`viewPendingTicketsQueue()`**: Iterates through the `pendingTicketsQueue` (using a for-each loop which doesn't remove elements) and prints each ticket's details to `System.out`. Checks if the queue is empty and prints a message accordingly.
 *     *   **`viewProcessedTicketsHistory()`**: Iterates through the `processedTicketsList` and prints each ticket's details to `System.out`. Checks if the list is empty.
 *     *   **`run()`**: This method contains the main application loop.
 *         *   It repeatedly displays the menu and reads the user's choice using the `scanner`.
 *         *   A `try-catch (InputMismatchException e)` block is used around `scanner.nextInt()` to catch non-integer input for the menu choice, printing an error to `System.err` and consuming the invalid input.
 *         *   A `switch` statement is used to execute the corresponding method based on the valid integer choice. The `default` case handles choices outside the valid range (1-5), printing an error to `System.err`.
 *         *   A broader `try-catch (Exception e)` block wraps the main `while` loop to catch any other unexpected runtime exceptions that might occur within the menu options, demonstrating a form of class-wide exception handling for the main execution flow. Error details are printed to `System.err`.
 *         *   A `finally` block ensures the `scanner` is closed when the loop terminates (either by choosing Exit or due to an unhandled exception caught by the outer try-catch).
 *     *   **`main(String[] args)`**: The entry point of the application. It creates an instance of `SupportTicketSystem` and calls its `run()` method.
 * 
 * **Demonstrated Concepts:**
 * 
 * *   **Object-Oriented Programming:** Use of classes (`Ticket`, `SupportTicketSystem`), objects, encapsulation, methods, and static members.
 * *   **Collections Framework:** Effective use of `Queue` (specifically `LinkedList`) for FIFO processing and `List` (specifically `ArrayList`) for storing a history. Demonstrates choosing appropriate data structures for different needs.
 * *   **Interfaces vs. Implementations:** Declaring collection variables using interface types (`Queue`, `List`) rather than concrete implementation types (`LinkedList`, `ArrayList`) where possible.
 * *   **User Input:** Using `Scanner` to read various types of user input (`nextLine`, `nextInt`).
 * *   **Control Flow:** Using a `while` loop for the main application loop and a `switch` statement for handling multiple distinct menu options.
 * *   **Exception Handling:** Using `try-catch` blocks to gracefully handle expected exceptions (`InputMismatchException` for invalid input) and a general `catch` for unexpected runtime errors in the main loop. Usage of `System.err` for error reporting.
 * *   **Basic I/O:** Using `System.out` for standard output and `System.err` for error output.
 * *   **Best Practices:** Adherence to naming conventions, basic comments, encapsulation, and input validation.
 * 
 * This solution effectively integrates all required components into a functional, albeit simple, application, demonstrating an understanding of core and intermediate Java concepts suitable for a challenging exam task.
 */

import java.util.LinkedList; // LinkedList is a common Queue implementation
import java.util.Queue;
import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;
import java.util.InputMismatchException;

// Represents a single support ticket
class Ticket {
    private int id;
    private String description;
    private int priority; // 1=High, 2=Medium, 3=Low
    private String status; // e.g., "Pending", "Resolved"

    // Static counter for unique ticket IDs
    private static int nextId = 1;

    /**
     * Constructs a new Ticket.
     * @param description The problem description.
     * @param priority The priority level (1, 2, or 3).
     */
    public Ticket(String description, int priority) {
        this.id = nextId++;
        this.description = description;
        this.priority = priority;
        this.status = "Pending"; // Initial status
    }

    // --- Getters ---
    public int getId() {
        return id;
    }

    public String getDescription() {
        return description;
    }

    public int getPriority() {
        return priority;
    }

    public String getStatus() {
        return status;
    }

    // --- Setter for status ---
    public void setStatus(String status) {
        this.status = status;
    }

    /**
     * Provides a string representation of the ticket.
     * @return String representation.
     */
    @Override
    public String toString() {
        return "Ticket ID: " + id +
               ", Description: " + description +
               ", Priority: " + priority +
               ", Status: " + status;
    }
}

// Manages the support ticket system
public class SupportTicketSystem {

    // Use Queue for pending tickets (FIFO)
    private Queue<Ticket> pendingTicketsQueue;
    // Use List (implemented by ArrayList) for processed tickets history
    private List<Ticket> processedTicketsList;
    private Scanner scanner;

    /**
     * Constructs the SupportTicketSystem.
     * Initializes the collections and scanner.
     */
    public SupportTicketSystem() {
        // LinkedList is a common implementation of Queue
        this.pendingTicketsQueue = new LinkedList<>();
        // ArrayList implements the List interface
        this.processedTicketsList = new ArrayList<>();
        this.scanner = new Scanner(System.in);
    }

    /**
     * Displays the main menu options to the user.
     */
    private void displayMenu() {
        System.out.println("\n--- Support Ticket System Menu ---");
        System.out.println("1. Submit New Ticket");
        System.out.println("2. Process Next Ticket");
        System.out.println("3. View Pending Tickets Queue");
        System.out.println("4. View Processed Tickets History");
        System.out.println("5. Exit");
        System.out.print("Enter your choice: ");
    }

    /**
     * Submits a new ticket based on user input.
     * Handles input validation for priority.
     */
    private void submitNewTicket() {
        System.out.print("Enter ticket description: ");
        String description = scanner.nextLine();

        int priority = -1;
        boolean validPriority = false;
        while (!validPriority) {
            System.out.print("Enter priority (1=High, 2=Medium, 3=Low): ");
            try {
                priority = scanner.nextInt();
                // Consume the newline character left by nextInt()
                scanner.nextLine();
                if (priority >= 1 && priority <= 3) {
                    validPriority = true;
                } else {
                    System.err.println("Error: Invalid priority. Please enter 1, 2, or 3.");
                }
            } catch (InputMismatchException e) {
                System.err.println("Error: Invalid input. Please enter a number for priority.");
                // Consume the invalid input to prevent infinite loop
                scanner.nextLine();
            }
        }

        Ticket newTicket = new Ticket(description, priority);
        pendingTicketsQueue.offer(newTicket); // Add to the end of the queue
        System.out.println("Ticket #" + newTicket.getId() + " submitted. Status: " + newTicket.getStatus() + ", Priority: " + newTicket.getPriority());
    }

    /**
     * Processes the next ticket from the pending queue.
     * Moves the ticket to the processed list.
     */
    private void processNextTicket() {
        Ticket ticketToProcess = pendingTicketsQueue.poll(); // Retrieve and remove the head of the queue

        if (ticketToProcess == null) {
            System.err.println("Error: No tickets are currently pending processing.");
        } else {
            System.out.println("Processing ticket #" + ticketToProcess.getId() + "...");
            ticketToProcess.setStatus("Resolved"); // Change status
            processedTicketsList.add(ticketToProcess); // Add to processed list
            System.out.println("Ticket #" + ticketToProcess.getId() + " processed. Status: " + ticketToProcess.getStatus() + ".");
        }
    }

    /**
     * Displays all tickets currently in the pending queue.
     */
    private void viewPendingTicketsQueue() {
        System.out.println("\n--- Pending Tickets ---");
        if (pendingTicketsQueue.isEmpty()) {
            System.out.println("(Queue is empty)");
        } else {
            // Iterate through the queue without removing elements
            for (Ticket ticket : pendingTicketsQueue) {
                System.out.println(ticket);
            }
        }
        System.out.println("--- End Pending Tickets ---");
    }

    /**
     * Displays all tickets in the processed history list.
     */
    private void viewProcessedTicketsHistory() {
        System.out.println("\n--- Processed Tickets History ---");
        if (processedTicketsList.isEmpty()) {
            System.out.println("(History is empty)");
        } else {
            // Iterate through the list
            for (Ticket ticket : processedTicketsList) {
                System.out.println(ticket);
            }
        }
        System.out.println("--- End Processed Tickets History ---");
    }

    /**
     * Runs the main application loop.
     * Handles user input and calls appropriate methods using a switch statement.
     * Includes a try-catch block for general exceptions during the main loop.
     */
    public void run() {
        int choice = 0;
        boolean exit = false;

        // Main application loop with general exception handling
        try {
            while (!exit) {
                displayMenu();
                try {
                    // Read user choice, handling potential non-integer input
                    choice = scanner.nextInt();
                    // Consume the newline character left by nextInt()
                    scanner.nextLine();

                    // Use switch statement for menu navigation
                    switch (choice) {
                        case 1:
                            submitNewTicket();
                            break;
                        case 2:
                            processNextTicket();
                            break;
                        case 3:
                            viewPendingTicketsQueue();
                            break;
                        case 4:
                            viewProcessedTicketsHistory();
                            break;
                        case 5:
                            exit = true;
                            System.out.println("Exiting system.");
                            break;
                        default:
                            System.err.println("Error: Invalid choice. Please enter a number between 1 and 5.");
                    }
                } catch (InputMismatchException e) {
                    System.err.println("Error: Invalid input. Please enter a number.");
                    // Consume the invalid input to prevent infinite loop
                    scanner.nextLine();
                } catch (Exception e) {
                    // Catch any other unexpected exceptions during an operation
                    System.err.println("An unexpected error occurred: " + e.getMessage());
                    e.printStackTrace(System.err); // Print stack trace to err
                }
            }
        } finally {
            // Ensure the scanner is closed when the program exits
            if (scanner != null) {
                scanner.close();
            }
        }
    }

    /**
     * Main method to start the application.
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        SupportTicketSystem system = new SupportTicketSystem();
        system.run();
    }
}
