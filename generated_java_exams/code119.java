/*
 * Exam Question #119
 * Generated on: 2025-05-11 22:17:15
 * Generated by: Account 3
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Warehouse Shipment Processing System
 * 
 * **Scenario:**
 * 
 * You are tasked with developing a simplified system for managing incoming shipment processing tasks in a warehouse. Shipments arrive and are added to a queue for processing. Warehouse staff process tasks one by one from the front of the queue. The system needs to keep track of pending tasks and a history of processed tasks.
 * 
 * **Requirements:**
 * 
 * Implement a Java application that fulfills the following requirements:
 * 
 * 1.  **Data Structures:**
 *     *   Use a `Queue` to store pending `ShipmentTask` objects. Tasks should be processed in the order they are added (FIFO).
 *     *   Use an `ArrayList` to store processed `ShipmentTask` objects.
 *     *   Declare the processed tasks list using the `List` interface (`List<ShipmentTask> processedTasks = new ArrayList<>();`).
 * 
 * 2.  **ShipmentTask Class:**
 *     *   Create a class named `ShipmentTask` to represent a single task.
 *     *   It should have private fields: `taskId` (an integer, automatically generated), `description` (String), `priority` (String, e.g., "HIGH", "STANDARD"), and `status` (String, e.g., "PENDING", "PROCESSED").
 *     *   Include a constructor to initialize `description` and `priority`. `taskId` should be assigned upon creation (use a static counter in the main class or a simple counter passed during creation), and `status` should initially be "PENDING".
 *     *   Provide public getter methods for all fields.
 *     *   Override the `toString()` method to provide a clear string representation of the task.
 * 
 * 3.  **WarehouseSystem Class:**
 *     *   Create a class named `WarehouseSystem` to manage the tasks.
 *     *   It should contain the `Queue` for pending tasks and the `List` for processed tasks as private fields.
 *     *   Implement the following public methods:
 *         *   `addTask(String description, String priority)`: Creates a new `ShipmentTask` and adds it to the pending queue. Assign a unique `taskId`.
 *         *   `processNextTask()`: Removes the task at the front of the pending queue, updates its status to "PROCESSED", and adds it to the processed tasks list. Handle the case where the queue is empty.
 *         *   `viewPendingTasks()`: Displays all tasks currently in the pending queue.
 *         *   `viewProcessedTasks()`: Displays all tasks in the processed tasks list.
 * 
 * 4.  **User Interface:**
 *     *   Use `Scanner` to interact with the user via the console.
 *     *   Present a menu with options:
 *         1.  Add New Shipment Task
 *         2.  Process Next Task
 *         3.  View Pending Tasks
 *         4.  View Processed Tasks
 *         5.  Exit
 *     *   Use a `switch` statement to handle the user's menu choice.
 *     *   The application should run in a loop until the user chooses to exit.
 * 
 * 5.  **Error Handling and Output:**
 *     *   Use `System.out` for normal output (menu, task details, successful operations).
 *     *   Use `System.err` for error messages (e.g., invalid menu choice, attempting to process from an empty queue, invalid input for task details).
 *     *   Implement robust input validation for menu choices (ensure it's an integer within the valid range) and task details (e.g., description not empty, priority is valid - "HIGH" or "STANDARD").
 *     *   Implement class-wide exception handling using `try-catch` blocks. Specifically, handle potential `InputMismatchException` from `Scanner` and `NoSuchElementException` when processing an empty queue.
 * 
 * **Best Practices:**
 * 
 * *   Follow Java naming conventions.
 * *   Use meaningful variable and method names.
 * *   Include comments where necessary to explain complex logic.
 * *   Ensure proper encapsulation (private fields, public methods).
 * *   Close the `Scanner` resource when the application exits.
 * 
 * **Expected Output:**
 * 
 * The application should display the menu, prompt for user input, and provide appropriate output or error messages based on the user's actions. For example:
 * 
 * ```
 * Warehouse Shipment Processing System Menu:
 * 1. Add New Shipment Task
 * 2. Process Next Task
 * 3. View Pending Tasks
 * 4. View Processed Tasks
 * 5. Exit
 * Enter your choice: 1
 * Enter task description: Box of Books
 * Enter priority (HIGH/STANDARD): STANDARD
 * Task added: ShipmentTask [taskId=1, description=Box of Books, priority=STANDARD, status=PENDING]
 * 
 * Warehouse Shipment Processing System Menu:
 * 1. Add New Shipment Task
 * 2. Process Next Task
 * 3. View Pending Tasks
 * 4. View Processed Tasks
 * 5. Exit
 * Enter your choice: 3
 * --- Pending Tasks ---
 * ShipmentTask [taskId=1, description=Box of Books, priority=STANDARD, status=PENDING]
 * ---------------------
 * 
 * Warehouse Shipment Processing System Menu:
 * 1. Add New Shipment Task
 * 2. Process Next Task
 * 3. View Pending Tasks
 * 4. View Processed Tasks
 * 5. Exit
 * Enter your choice: 2
 * Processing task: ShipmentTask [taskId=1, description=Box of Books, priority=STANDARD, status=PENDING]
 * Task 1 processed successfully.
 * 
 * Warehouse Shipment Processing System Menu:
 * 1. Add New Shipment Task
 * ... (and so on)
 * ```
 * 
 * If processing an empty queue:
 * ```
 * Error: No tasks in the pending queue to process.
 * ```
 * 
 * If invalid menu input:
 * ```
 * Error: Invalid input. Please enter a number between 1 and 5.
 * ```
 * 
 * **Evaluation Criteria:**
 * 
 * *   Correct usage of `Queue`, `ArrayList`, and `List`.
 * *   Correct implementation of the `ShipmentTask` class and its methods.
 * *   Correct implementation of the `WarehouseSystem` class and its methods.
 * *   Proper use of `Scanner`, `switch`, `System.out`, and `System.err`.
 * *   Effective implementation of input validation and exception handling using `try-catch`.
 * *   Adherence to best practices (encapsulation, naming, comments).
 * *   The application runs correctly and handles various scenarios as described.
 *
 * EXPLANATION:
 * This solution implements a simple Warehouse Shipment Processing System demonstrating the required Java concepts.
 * 
 * 1.  **`ShipmentTask` Class:**
 *     *   This class encapsulates the data for a single task (`taskId`, `description`, `priority`, `status`).
 *     *   Private fields ensure data is accessed and modified only through public methods (encapsulation).
 *     *   The constructor initializes the task with basic details and sets the initial status to "PENDING".
 *     *   Getter methods provide read access to the task's properties.
 *     *   `setStatus` is a setter used internally by the `WarehouseSystem` when a task is processed.
 *     *   `toString()` is overridden for easy printing of task details.
 * 
 * 2.  **`WarehouseSystem` Class:**
 *     *   This is the main class managing the system state and operations.
 *     *   **`Queue<ShipmentTask> pendingTasks`**: A `LinkedList` is used here because it implements the `Queue` interface and provides FIFO behavior suitable for tasks waiting to be processed in arrival order.
 *     *   **`List<ShipmentTask> processedTasks`**: An `ArrayList` is used here, declared with the `List` interface type. This stores tasks after they have been processed. `ArrayList` is efficient for adding and iterating through processed tasks.
 *     *   **`nextTaskId`**: A simple counter to assign unique IDs to new tasks.
 *     *   **`addTask(String description, String priority)`**: Creates a new `ShipmentTask` instance with the next available ID and adds it to the `pendingTasks` queue using the `add()` method. Includes basic input validation for description and priority, using `System.err` for errors.
 *     *   **`processNextTask()`**:
 *         *   Uses `pendingTasks.remove()` to get and remove the task at the head of the queue. This method adheres to the FIFO principle.
 *         *   A `try-catch (NoSuchElementException)` block is used to handle the specific error that occurs if `remove()` is called on an empty queue. An informative error message is printed to `System.err`.
 *         *   If successful, the task's status is updated, and it's added to the `processedTasks` list.
 *     *   **`viewPendingTasks()`**: Iterates through the `pendingTasks` queue using a for-each loop. This loop iterates over the elements without removing them, which is suitable for viewing.
 *     *   **`viewProcessedTasks()`**: Iterates through the `processedTasks` list using a for-each loop to display the processed tasks.
 *     *   **`displayMenu()`**: A helper method to print the menu options to `System.out`.
 *     *   **`run()`**:
 *         *   Contains the main application loop (`while(running)`).
 *         *   A `Scanner` is initialized to read user input.
 *         *   **Class-wide `try-catch`**: The entire `while` loop is wrapped in a `try-catch(Exception e)`. This provides a fallback for any unexpected errors that might occur within the loop, preventing the program from crashing abruptly. A specific `InputMismatchException` is caught *inside* the loop when reading the menu choice to handle non-integer input gracefully, printing an error to `System.err` and clearing the invalid input from the scanner buffer (`scanner.next()`). A `finally` block is used after the input reading `try-catch` to consume the leftover newline character, which is crucial before reading strings with `nextLine()`.
 *         *   **`switch` statement**: Handles the user's valid menu choice, calling the appropriate `WarehouseSystem` method. The `default` case handles valid integer inputs that are outside the expected range (1-5), printing an error to `System.err`.
 *         *   The loop continues until the user enters '5', setting `running` to `false`.
 *         *   A `finally` block outside the main `try-catch` ensures the `Scanner` resource is closed properly before the program exits, preventing resource leaks.
 *     *   **`main(String[] args)`**: The entry point of the application, creating a `WarehouseSystem` instance and calling its `run()` method.
 * 
 * **Key Concepts Demonstrated:**
 * 
 * *   **Data Structures:** Practical use of `Queue` (FIFO processing) and `List`/`ArrayList` (history/collection).
 * *   **Object-Oriented Programming:** Encapsulation (`ShipmentTask` class with private fields and public methods), class structure (`WarehouseSystem` managing `ShipmentTask` objects).
 * *   **User Interaction:** Using `Scanner` for console input.
 * *   **Control Flow:** Using `switch` for menu-driven logic and a `while` loop for the application flow.
 * *   **Error Handling:**
 *     *   Specific exception handling (`NoSuchElementException`, `InputMismatchException`) using `try-catch`.
 *     *   Class-wide/application-loop `try-catch` as a safety net.
 *     *   Using `System.err` for error output.
 *     *   Input validation (checking task details, menu range).
 * *   **Resource Management:** Closing the `Scanner` resource.
 * *   **Best Practices:** Meaningful names, comments, basic validation, clear output.
 * 
 * This solution effectively combines multiple core Java concepts and standard library components to build a functional, albeit simplified, real-world-like application demonstrating advanced understanding of Java programming principles.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.InputMismatchException;
import java.util.NoSuchElementException;

// Represents a single shipment processing task
class ShipmentTask {
    private int taskId;
    private String description;
    private String priority; // Using String for simplicity, enum could be better
    private String status;   // PENDING or PROCESSED

    /**
     * Constructs a new ShipmentTask.
     *
     * @param taskId The unique identifier for the task.
     * @param description A brief description of the task.
     * @param priority The priority of the task (e.g., "HIGH", "STANDARD").
     */
    public ShipmentTask(int taskId, String description, String priority) {
        this.taskId = taskId;
        this.description = description;
        this.priority = priority;
        this.status = "PENDING"; // New tasks are always pending
    }

    // --- Getters ---
    public int getTaskId() {
        return taskId;
    }

    public String getDescription() {
        return description;
    }

    public String getPriority() {
        return priority;
    }

    public String getStatus() {
        return status;
    }

    // --- Setters (used internally by the system) ---
    public void setStatus(String status) {
        this.status = status;
    }

    /**
     * Provides a string representation of the ShipmentTask.
     *
     * @return A formatted string detailing the task.
     */
    @Override
    public String toString() {
        return "ShipmentTask [taskId=" + taskId +
               ", description=" + description +
               ", priority=" + priority +
               ", status=" + status + "]";
    }
}

// Manages the collection of shipment tasks
public class WarehouseSystem {

    // Queue for tasks waiting to be processed (FIFO)
    private Queue<ShipmentTask> pendingTasks;

    // List for tasks that have been processed
    private List<ShipmentTask> processedTasks;

    // Counter for generating unique task IDs
    private int nextTaskId;

    /**
     * Constructs a new WarehouseSystem.
     * Initializes the pending and processed task collections.
     */
    public WarehouseSystem() {
        // Using LinkedList as a concrete implementation of Queue
        this.pendingTasks = new LinkedList<>();
        // Using ArrayList as a concrete implementation of List
        this.processedTasks = new ArrayList<>();
        this.nextTaskId = 1; // Start task IDs from 1
    }

    /**
     * Adds a new shipment task to the pending queue.
     *
     * @param description The description of the task.
     * @param priority The priority of the task ("HIGH" or "STANDARD").
     */
    public void addTask(String description, String priority) {
        // Basic validation
        if (description == null || description.trim().isEmpty()) {
            System.err.println("Error: Task description cannot be empty.");
            return;
        }
        if (!"HIGH".equalsIgnoreCase(priority) && !"STANDARD".equalsIgnoreCase(priority)) {
             System.err.println("Error: Invalid priority. Must be 'HIGH' or 'STANDARD'.");
             return;
        }

        ShipmentTask newTask = new ShipmentTask(nextTaskId++, description.trim(), priority.toUpperCase());
        pendingTasks.add(newTask);
        System.out.println("Task added: " + newTask);
    }

    /**
     * Processes the next task in the pending queue.
     * Removes it from the queue, updates its status, and adds it to the processed list.
     * Handles the case where the pending queue is empty.
     */
    public void processNextTask() {
        try {
            // remove() retrieves and removes the head of this queue.
            // Throws NoSuchElementException if this queue is empty.
            ShipmentTask taskToProcess = pendingTasks.remove();

            System.out.println("Processing task: " + taskToProcess);

            // Update status and move to processed list
            taskToProcess.setStatus("PROCESSED");
            processedTasks.add(taskToProcess);

            System.out.println("Task " + taskToProcess.getTaskId() + " processed successfully.");

        } catch (NoSuchElementException e) {
            // Use System.err for error messages
            System.err.println("Error: No tasks in the pending queue to process.");
        } catch (Exception e) {
             // Catch any other unexpected errors during processing
             System.err.println("An unexpected error occurred during task processing: " + e.getMessage());
             // Log the exception for debugging in a real application
             // e.printStackTrace();
        }
    }

    /**
     * Displays all tasks currently in the pending queue.
     * Iterates through the queue without removing elements.
     */
    public void viewPendingTasks() {
        System.out.println("--- Pending Tasks ---");
        if (pendingTasks.isEmpty()) {
            System.out.println("No pending tasks.");
        } else {
            // Iterate using a for-each loop. This does NOT remove elements.
            for (ShipmentTask task : pendingTasks) {
                System.out.println(task);
            }
        }
        System.out.println("---------------------");
    }

    /**
     * Displays all tasks that have been processed.
     * Iterates through the processed tasks list.
     */
    public void viewProcessedTasks() {
        System.out.println("--- Processed Tasks ---");
        if (processedTasks.isEmpty()) {
            System.out.println("No tasks have been processed yet.");
        } else {
            // Iterate through the List
            for (ShipmentTask task : processedTasks) {
                System.out.println(task);
            }
        }
        System.out.println("-----------------------");
    }

    /**
     * Displays the main menu options to the user.
     */
    private void displayMenu() {
        System.out.println("\nWarehouse Shipment Processing System Menu:");
        System.out.println("1. Add New Shipment Task");
        System.out.println("2. Process Next Task");
        System.out.println("3. View Pending Tasks");
        System.out.println("4. View Processed Tasks");
        System.out.println("5. Exit");
        System.out.print("Enter your choice: ");
    }

    /**
     * Runs the main application loop, handling user interaction.
     */
    public void run() {
        Scanner scanner = new Scanner(System.in);
        boolean running = true;

        // Class-wide try-catch for the main application loop
        try {
            while (running) {
                displayMenu();
                int choice = -1; // Default invalid choice

                // Input validation for menu choice
                try {
                    choice = scanner.nextInt();
                } catch (InputMismatchException e) {
                    System.err.println("Error: Invalid input. Please enter a number between 1 and 5.");
                    scanner.next(); // Consume the invalid input to prevent infinite loop
                    continue; // Skip the rest of the loop iteration
                } finally {
                     // Consume the newline character left by nextInt()
                     // This is important before calling nextLine() later
                     scanner.nextLine();
                }


                // Use switch statement for menu navigation
                switch (choice) {
                    case 1:
                        System.out.print("Enter task description: ");
                        String description = scanner.nextLine().trim(); // Read the whole line
                        System.out.print("Enter priority (HIGH/STANDARD): ");
                        String priority = scanner.nextLine().trim(); // Read the whole line
                        addTask(description, priority);
                        break;
                    case 2:
                        processNextTask();
                        break;
                    case 3:
                        viewPendingTasks();
                        break;
                    case 4:
                        viewProcessedTasks();
                        break;
                    case 5:
                        System.out.println("Exiting Warehouse System. Goodbye!");
                        running = false;
                        break;
                    default:
                        // Handle choices outside the 1-5 range
                        System.err.println("Error: Invalid choice. Please enter a number between 1 and 5.");
                        break;
                }
            }
        } catch (Exception e) {
            // Catch any unexpected exception during the main loop
            System.err.println("An unexpected critical error occurred: " + e.getMessage());
            e.printStackTrace(); // Print stack trace for debugging
        } finally {
            // Ensure the scanner is closed regardless of how the loop exits
            if (scanner != null) {
                scanner.close();
                System.out.println("Scanner closed."); // Confirmation
            }
        }
    }

    // Main method to start the application
    public static void main(String[] args) {
        WarehouseSystem system = new WarehouseSystem();
        system.run();
    }
}
