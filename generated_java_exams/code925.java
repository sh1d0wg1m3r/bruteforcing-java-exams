/*
 * Exam Question #925
 * Generated on: 2025-05-12 17:00:22
 * Generated by: Account 5
 * 
 * QUESTION:
 * ## Advanced Java Programming Exam: Task Processing System
 * 
 * **Problem Description:**
 * 
 * You are tasked with building a simplified Task Processing System for a small manufacturing unit. The system needs to manage incoming production tasks, process them in the order they were received, and keep a record of completed tasks. The system should be interactive, allowing a user to add new tasks, view pending tasks, process the next task in the queue, view completed tasks, and exit.
 * 
 * Your solution must be a single Java application containing the necessary classes and a `main` method to run the interactive system.
 * 
 * **Requirements:**
 * 
 * 1.  **Task Representation:** Create a class named `Task` to represent a single production task. Each task should have:
 *     *   A unique integer ID (automatically generated, starting from 1).
 *     *   A `String` description of the task.
 *     *   A `String` status (e.g., "Pending", "Completed").
 *     *   Appropriate private fields, a constructor, and public getter methods.
 *     *   A `toString()` method for easy printing.
 * 
 * 2.  **System Management:** Create a class named `TaskProcessingSystem` to manage the tasks. It must contain:
 *     *   A `Queue<Task>` to hold tasks that are pending processing. Use a concrete implementation like `java.util.LinkedList`.
 *     *   A `List<Task>` to hold tasks that have been completed. Use `java.util.ArrayList` and declare the variable using the `List` interface.
 *     *   A private counter for generating unique task IDs.
 *     *   Public methods for the following operations:
 *         *   `addTask(String description)`: Creates a new `Task` with status "Pending", assigns a unique ID, and adds it to the pending queue.
 *         *   `processNextTask()`: Removes the task at the front of the pending queue, changes its status to "Completed", and adds it to the completed list. If the queue is empty, it should indicate an error.
 *         *   `viewPendingTasks()`: Prints all tasks currently in the pending queue, showing their ID and description.
 *         *   `viewCompletedTasks()`: Prints all tasks in the completed list, showing their ID, description, and status ("Completed").
 *         *   Methods should return appropriate boolean values or throw exceptions if necessary (though simple `System.err` messages for operational failures like an empty queue are sufficient for this problem).
 * 
 * 3.  **User Interface:** Implement the `main` method to provide a text-based menu interface using `java.util.Scanner`. The menu should offer the following options:
 *     *   1. Add New Task
 *     *   2. Process Next Task
 *     *   3. View Pending Tasks
 *     *   4. View Completed Tasks
 *     *   5. Exit
 *     *   Read user input using `Scanner`.
 * 
 * 4.  **Control Flow:** Use a `switch` statement in the `main` method to handle the user's menu choice.
 * 
 * 5.  **Input Validation and Error Handling:**
 *     *   Use `System.err` to print error messages for invalid user input (e.g., non-numeric input for menu, invalid menu option number) or operational errors (e.g., trying to process a task when the queue is empty).
 *     *   Use `System.out` for the menu, prompts, and successful output (task lists, confirmation messages).
 *     *   Implement class-wide exception handling using `try-catch` blocks in the `main` method to gracefully handle potential runtime errors during the user interaction loop (e.g., `InputMismatchException` from `Scanner`). Ensure the program doesn't crash on invalid input.
 *     *   Validate task description input (e.g., ensure it's not empty).
 * 
 * 6.  **Best Practices:**
 *     *   Employ proper encapsulation (private fields, public methods).
 *     *   Use meaningful variable and method names.
 *     *   Include appropriate comments and basic documentation (e.g., JavaDocs or block comments).
 *     *   Ensure clean code structure.
 * 
 * **Expected Output:**
 * 
 * The program should display a menu, prompt the user for input, and perform the requested action. Output for viewing tasks should clearly list the tasks with their details. Error messages should be distinct (using `System.err`).
 * 
 * **Example Interaction Snippet:**
 * 
 * ```
 * --- Task Processing System Menu ---
 * 1. Add New Task
 * 2. Process Next Task
 * 3. View Pending Tasks
 * 4. View Completed Tasks
 * 5. Exit
 * Enter your choice: 1
 * Enter task description: Calibrate Machine A
 * Task 1 added: Calibrate Machine A
 * 
 * --- Task Processing System Menu ---
 * ...
 * Enter your choice: 1
 * Enter task description: Inspect Product Batch 101
 * Task 2 added: Inspect Product Batch 101
 * 
 * --- Task Processing System Menu ---
 * ...
 * Enter your choice: 3
 * Pending Tasks:
 * [ID: 1, Description: Calibrate Machine A, Status: Pending]
 * [ID: 2, Description: Inspect Product Batch 101, Status: Pending]
 * 
 * --- Task Processing System Menu ---
 * ...
 * Enter your choice: 2
 * Processing task: ID: 1, Description: Calibrate Machine A
 * Task 1 completed.
 * 
 * --- Task Processing System Menu ---
 * ...
 * Enter your choice: 4
 * Completed Tasks:
 * [ID: 1, Description: Calibrate Machine A, Status: Completed]
 * 
 * --- Task Processing System Menu ---
 * ...
 * Enter your choice: 6
 * Invalid choice. Please enter a number between 1 and 5.
 * (Error message using System.err)
 * 
 * --- Task Processing System Menu ---
 * ...
 * Enter your choice: abc
 * Invalid input. Please enter a number.
 * (Error message using System.err)
 * 
 * --- Task Processing System Menu ---
 * ...
 * Enter your choice: 5
 * Exiting Task Processing System.
 * ```
 * 
 * Your solution should provide the complete Java code for this system.
 *
 * EXPLANATION:
 * This solution implements a simple Task Processing System demonstrating the required Java concepts.
 * 
 * 1.  **`Task` Class:** This class serves as a simple Plain Old Java Object (POJO) to represent a task. It encapsulates the task's `id`, `description`, and `status` using `private` fields and provides public getter methods (`getId`, `getDescription`, `getStatus`) following encapsulation principles. A `setStatus` method is included to change the task's status upon completion. The `toString()` method provides a convenient way to print task details.
 * 
 * 2.  **`TaskProcessingSystem` Class:** This class manages the core logic and data structures.
 *     *   `Queue<Task> pendingTasksQueue`: A `Queue` is used here because tasks are processed in a First-In, First-Out (FIFO) manner â€“ the task added earliest is the next one to be processed. `java.util.LinkedList` is a standard implementation of the `Queue` interface.
 *     *   `List<Task> completedTasksList`: A `List` is used to store completed tasks. An `ArrayList` provides dynamic resizing and efficient storage/retrieval of completed tasks. The variable is declared as `List` to program to the interface, a good practice allowing flexibility in choosing the concrete implementation later if needed.
 *     *   `nextTaskId`: A simple counter to ensure each task gets a unique ID.
 *     *   **`addTask(String description)`:** Creates a new `Task` object and adds it to the `pendingTasksQueue` using `offer()`. Basic input validation checks if the description is empty.
 *     *   **`processNextTask()`:** Uses `poll()` to retrieve and remove the head of the `pendingTasksQueue`. If `poll()` returns `null` (meaning the queue is empty), an error message is printed using `System.err`. Otherwise, the task's status is updated, and it's added to the `completedTasksList`.
 *     *   **`viewPendingTasks()`:** Iterates through the `pendingTasksQueue` to print tasks without removing them.
 *     *   **`viewCompletedTasks()`:** Iterates through the `completedTasksList` to print completed tasks.
 * 
 * 3.  **`TaskSystemApp` Class (`main` method):** This class contains the main application logic and user interface.
 *     *   **`Scanner`:** An instance of `Scanner` reads input from `System.in`.
 *     *   **Menu Loop:** A `while(running)` loop keeps the system running until the user chooses to exit.
 *     *   **Class-wide `try-catch`:** The entire `while` loop is wrapped in a `try-catch(Exception e)` block. While more specific catches could be added, this demonstrates a robust way to prevent unexpected runtime errors anywhere within the core application loop from crashing the program. It prints an error using `System.err` and the stack trace for debugging. A `finally` block ensures the `Scanner` is closed.
 *     *   **Input Reading and Validation (`try-catch` inside loop):** Inside the main loop, another `try-catch(InputMismatchException e)` block specifically handles cases where the user enters non-integer input for the menu choice. It prints an error using `System.err`, consumes the invalid input line using `scanner.nextLine()` to clear the buffer, and uses `continue` to restart the loop, prompting the user again.
 *     *   **`switch` Statement:** Based on the valid integer input `choice`, the `switch` statement directs the program flow to call the appropriate method in the `TaskProcessingSystem` instance (`system`).
 *     *   **`System.out` and `System.err`:** `System.out.println()` is used for printing the menu, prompts, confirmation messages, and task lists. `System.err.println()` is exclusively used for printing error messages (invalid input, empty queue processing).
 *     *   **Input Consumption:** `scanner.nextLine()` is called after `scanner.nextInt()` to consume the leftover newline character, preventing issues in subsequent `nextLine()` calls for task descriptions.
 * 
 * This solution effectively integrates the required Java components (`Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.err`, `System.out`, `try-catch`) within a practical, encapsulated, and error-handled application structure, demonstrating advanced understanding of Java programming concepts.
 */

import java.util.Queue;
import java.util.LinkedList;
import java.util.List;
import java.util.ArrayList;
import java.util.Scanner;
import java.util.InputMismatchException;

/**
 * Represents a single production task in the system.
 */
class Task {
    private int id;
    private String description;
    private String status; // e.g., "Pending", "Completed"

    /**
     * Constructs a new Task.
     * @param id The unique ID for the task.
     * @param description The description of the task.
     */
    public Task(int id, String description) {
        this.id = id;
        this.description = description;
        this.status = "Pending"; // New tasks are always pending
    }

    // --- Getters ---
    public int getId() {
        return id;
    }

    public String getDescription() {
        return description;
    }

    public String getStatus() {
        return status;
    }

    // --- Setters (only for status in this case) ---
    public void setStatus(String status) {
        this.status = status;
    }

    /**
     * Provides a string representation of the Task.
     * @return String representation.
     */
    @Override
    public String toString() {
        return "[ID: " + id + ", Description: " + description + ", Status: " + status + "]";
    }
}

/**
 * Manages the collection of pending and completed tasks.
 */
class TaskProcessingSystem {
    // Queue for tasks waiting to be processed (FIFO)
    private Queue<Task> pendingTasksQueue;
    // List for tasks that have been completed
    private List<Task> completedTasksList;
    // Counter for generating unique task IDs
    private int nextTaskId;

    /**
     * Constructs a new TaskProcessingSystem.
     */
    public TaskProcessingSystem() {
        // Use LinkedList as a Queue implementation
        this.pendingTasksQueue = new LinkedList<>();
        // Use ArrayList as a List implementation
        this.completedTasksList = new ArrayList<>();
        this.nextTaskId = 1; // Start IDs from 1
    }

    /**
     * Adds a new task to the pending queue.
     * @param description The description of the task.
     */
    public void addTask(String description) {
        if (description == null || description.trim().isEmpty()) {
            System.err.println("Error: Task description cannot be empty.");
            return;
        }
        Task newTask = new Task(nextTaskId++, description.trim());
        pendingTasksQueue.offer(newTask); // offer is preferred over add for capacity-constrained queues, but safe here.
        System.out.println("Task " + newTask.getId() + " added: " + newTask.getDescription());
    }

    /**
     * Processes the next task in the pending queue.
     * Moves the task from pending to completed.
     */
    public void processNextTask() {
        Task taskToProcess = pendingTasksQueue.poll(); // Retrieves and removes the head of the queue
        if (taskToProcess == null) {
            System.err.println("No pending tasks to process.");
        } else {
            System.out.println("Processing task: " + taskToProcess);
            taskToProcess.setStatus("Completed");
            completedTasksList.add(taskToProcess);
            System.out.println("Task " + taskToProcess.getId() + " completed.");
        }
    }

    /**
     * Displays all tasks currently in the pending queue.
     */
    public void viewPendingTasks() {
        System.out.println("--- Pending Tasks ---");
        if (pendingTasksQueue.isEmpty()) {
            System.out.println("No pending tasks.");
        } else {
            // Iterate through the queue without removing elements
            for (Task task : pendingTasksQueue) {
                System.out.println(task);
            }
        }
    }

    /**
     * Displays all tasks that have been completed.
     */
    public void viewCompletedTasks() {
        System.out.println("--- Completed Tasks ---");
        if (completedTasksList.isEmpty()) {
            System.out.println("No completed tasks.");
        } else {
            for (Task task : completedTasksList) {
                System.out.println(task);
            }
        }
    }
}

/**
 * Main class to run the interactive Task Processing System.
 */
public class TaskSystemApp { // Renamed to avoid conflict if file name is different

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        TaskProcessingSystem system = new TaskProcessingSystem();
        boolean running = true;

        // Class-wide try-catch for the main interaction loop
        try {
            while (running) {
                printMenu();
                int choice = -1; // Initialize with an invalid value

                try {
                    System.out.print("Enter your choice: ");
                    choice = scanner.nextInt(); // Read integer input
                    scanner.nextLine(); // Consume the newline character left by nextInt()

                } catch (InputMismatchException e) {
                    System.err.println("Invalid input. Please enter a number.");
                    scanner.nextLine(); // Consume the invalid input to prevent infinite loop
                    continue; // Skip the rest of the loop iteration
                }

                // Switch statement to handle menu choices
                switch (choice) {
                    case 1:
                        System.out.print("Enter task description: ");
                        String description = scanner.nextLine();
                        system.addTask(description);
                        break;
                    case 2:
                        system.processNextTask();
                        break;
                    case 3:
                        system.viewPendingTasks();
                        break;
                    case 4:
                        system.viewCompletedTasks();
                        break;
                    case 5:
                        System.out.println("Exiting Task Processing System.");
                        running = false;
                        break;
                    default:
                        System.err.println("Invalid choice. Please enter a number between 1 and 5.");
                }
                System.out.println(); // Add a newline for better readability between operations
            }
        } catch (Exception e) {
            // Catch any unexpected runtime exceptions
            System.err.println("An unexpected error occurred: " + e.getMessage());
            e.printStackTrace(); // Print stack trace for debugging
        } finally {
            // Ensure the scanner is closed
            if (scanner != null) {
                scanner.close();
            }
            System.out.println("System shutdown complete.");
        }
    }

    /**
     * Prints the main menu options to the console.
     */
    private static void printMenu() {
        System.out.println("--- Task Processing System Menu ---");
        System.out.println("1. Add New Task");
        System.out.println("2. Process Next Task");
        System.out.println("3. View Pending Tasks");
        System.out.println("4. View Completed Tasks");
        System.out.println("5. Exit");
    }
}
