/*
 * Exam Question #809
 * Generated on: 2025-05-12 16:44:02
 * Generated by: Account 5
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Print Job Management System
 * 
 * **Scenario:**
 * 
 * You are tasked with developing a simple console-based Print Job Management System. This system should allow users to add print jobs to a queue, process the next job in the queue, and view lists of pending and completed jobs. The system must be robust, handling user input errors and operational issues gracefully.
 * 
 * **Requirements:**
 * 
 * 1.  **Core Data Structures:**
 *     *   Use a `java.util.Queue` to store print jobs that are waiting to be processed. Jobs should be processed in a First-In, First-Out (FIFO) manner.
 *     *   Use a `java.util.List` (specifically a `java.util.ArrayList`) to store print jobs that have been completed.
 * 
 * 2.  **Classes:**
 *     *   Create a `PrintJob` class representing a single job. It should have private fields for a unique integer ID, a file name (String), and a status (String, e.g., "Pending", "Processing", "Completed"). Include a constructor and public getter methods.
 *     *   Create a `PrintManager` class responsible for managing the `Queue` and `List`. It should have methods to add a job, process the next job, view pending jobs, and view completed jobs.
 * 
 * 3.  **User Interface:**
 *     *   Implement a console-based menu driven interface using `java.util.Scanner` for user input.
 *     *   Use a `switch` statement to handle the user's menu selections.
 * 
 * 4.  **Input and Output:**
 *     *   Use `System.out` for displaying the menu, prompts, normal status messages (like job added, job completed), and lists of jobs.
 *     *   Use `System.err` for displaying error messages (e.g., invalid input, attempting to process an empty queue).
 * 
 * 5.  **Error Handling:**
 *     *   Implement robust error handling using `try-catch` blocks. The main operational loop handling user input and calling `PrintManager` methods should be wrapped in a `try-catch` block (demonstrating class-wide handling of exceptions originating from the main interaction flow).
 *     *   Handle `InputMismatchException` specifically for non-integer input.
 *     *   Handle the scenario where a user tries to process a job when the pending queue is empty. This should be reported as an error using `System.err`. Consider defining a custom exception for this specific case if desired for clarity, or handle it via a return value/specific error message from the `processNextJob` method caught in the main loop.
 * 
 * 6.  **Best Practices:**
 *     *   Adhere to encapsulation principles (private fields, public methods).
 *     *   Use meaningful names for variables, methods, and classes.
 *     *   Include basic comments to explain key parts of the code.
 *     *   Perform basic input validation (e.g., check if file name is empty, handle non-numeric input).
 * 
 * **Menu Options:**
 * 
 * 1.  Add New Print Job
 * 2.  Process Next Job
 * 3.  View Pending Jobs
 * 4.  View Completed Jobs
 * 5.  Exit
 * 
 * **Expected Output:**
 * 
 * The program should display the menu, accept user input, perform the requested action, and display relevant messages or lists. Error conditions (like invalid input or empty queue processing attempts) should result in messages printed to `System.err`.
 * 
 * **Constraints:**
 * 
 * *   All required Java components (`Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.err`, `System.out`, `try-catch`) must be used in a functional and appropriate manner within the solution.
 * *   The solution should be contained within a single `.java` file for simplicity in an exam setting, using static inner classes where appropriate.
 * 
 * **Task:**
 * 
 * Write the complete Java code for the Print Job Management System based on the requirements above.
 *
 * EXPLANATION:
 * This solution implements a basic Print Job Management System demonstrating the required Java concepts.
 * 
 * **System Overview:**
 * The system uses a `PrintManager` object to hold and manage print jobs. New jobs are added to a queue (`pendingJobs`) and processed sequentially (FIFO). Completed jobs are moved to a list (`completedJobs`). A console interface allows users to interact with the manager.
 * 
 * **Key Components Usage:**
 * 
 * 1.  **`java.util.Queue`:** The `pendingJobs` field in `PrintManager` is declared as a `Queue<PrintJob>` and initialized with a `LinkedList`. This correctly models the waiting line for print jobs, ensuring the job that has been waiting the longest is processed next using the `poll()` method.
 * 2.  **`java.util.ArrayList` / `java.util.List`:** The `completedJobs` field in `PrintManager` is declared as a `List<PrintJob>` and initialized with an `ArrayList`. `ArrayList` is a common and efficient implementation of the `List` interface for storing collections where elements are added and iterated over. It's used here to keep a record of all jobs that have finished processing.
 * 3.  **`java.util.Scanner`:** An instance of `Scanner` is created in the `main` method to read user input from the console (`System.in`). It's used to get the menu choice and the file name for new jobs.
 * 4.  **`switch` statement:** The `switch` statement in the `main` loop is used to direct the program flow based on the integer input received from the user, executing the corresponding action (add job, process job, view lists, or exit).
 * 5.  **`System.err`:** `System.err.println()` is used specifically for outputting error messages. This includes messages for invalid input (`InputMismatchException`), attempting to process an empty queue (`NoJobsPendingException`), and any other unexpected exceptions caught by the general `catch` block. This differentiates error output from normal program output.
 * 6.  **`System.out`:** `System.out.println()` and `System.out.print()` are used for all normal program output, such as displaying the menu, prompting the user for input, confirming actions (job added, job completed), and listing the pending or completed jobs.
 * 7.  **`try-catch` blocks:** A large `try-catch` block wraps the core logic inside the `while` loop in the `main` method. This acts as the "class-wide" exception handling mechanism for operations initiated by the user interface. It specifically catches `InputMismatchException` for incorrect input type, the custom `NoJobsPendingException` thrown by `processNextJob` when the queue is empty, and a general `Exception` to catch any other unforeseen runtime errors. This makes the main loop resilient to common operational failures.
 * 
 * **Class Design:**
 * 
 * *   **`PrintJob`:** A simple Plain Old Java Object (POJO) with private fields (`id`, `fileName`, `status`), a constructor, and getter methods. It also includes methods to update its internal status (`markAsProcessing`, `markAsCompleted`) and an overridden `toString()` for easy display.
 * *   **`PrintManager`:** Encapsulates the collection management logic. It holds the `pendingJobs` queue and `completedJobs` list as private fields. Methods like `addJob`, `processNextJob`, `viewPendingJobs`, and `viewCompletedJobs` provide the public interface for interacting with the job collections, hiding the underlying implementation details (`LinkedList`, `ArrayList`, `poll`, `offer`, `add`). A `nextJobId` counter ensures unique IDs are assigned.
 * *   **`NoJobsPendingException`:** A custom checked exception to signal the specific error condition of trying to process a job when the queue is empty. This makes the error handling in the calling code (`main` method) more explicit and readable.
 * 
 * **Error Handling Details:**
 * 
 * *   Input validation for the menu choice is handled by catching `InputMismatchException` if the user enters non-numeric text. The invalid input is consumed (`scanner.nextLine()`) to prevent an infinite loop.
 * *   Input validation for the file name checks for null or empty strings before creating a `PrintJob`.
 * *   The `processNextJob` method explicitly checks if `pendingJobs` is empty using `isEmpty()` before attempting to `poll()`. If empty, it throws the `NoJobsPendingException`.
 * *   The `main` method's `try-catch` block catches this specific exception and prints an informative message to `System.err`.
 * *   A general `catch (Exception e)` is included as a fallback to catch any other unexpected errors that might occur during the execution of the chosen action, printing a generic error message to `System.err`.
 * 
 * **Best Practices:**
 * 
 * *   **Encapsulation:** Fields in `PrintJob` and `PrintManager` are private, and access is controlled through public methods.
 * *   **Meaningful Names:** Variable names (`pendingJobs`, `completedJobs`, `nextJobId`), method names (`addJob`, `processNextJob`), and class names (`PrintJob`, `PrintManager`, `PrintSystem`) clearly indicate their purpose.
 * *   **Comments:** Basic Javadoc-style comments explain the purpose of classes, constructors, and methods. Inline comments clarify specific logic points.
 * *   **Clean Structure:** The code is organized into logical classes, and the main execution flow is clear within the `main` method's loop and `switch` statement. Using static inner classes keeps related code together in a single file.
 * 
 * This solution effectively uses all the required Java components to build a functional and reasonably robust system that simulates a real-world scenario, demonstrating a good understanding of core Java concepts and best practices.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.InputMismatchException;

// Custom exception for when no jobs are pending
class NoJobsPendingException extends Exception {
    public NoJobsPendingException(String message) {
        super(message);
    }
}

// Represents a single print job
class PrintJob {
    private int id;
    private String fileName;
    private String status; // e.g., "Pending", "Processing", "Completed"

    /**
     * Constructs a new PrintJob.
     * @param id The unique ID for the job.
     * @param fileName The name of the file to print.
     */
    public PrintJob(int id, String fileName) {
        this.id = id;
        this.fileName = fileName;
        this.status = "Pending"; // Initial status
    }

    // Getters
    public int getId() {
        return id;
    }

    public String getFileName() {
        return fileName;
    }

    public String getStatus() {
        return status;
    }

    /**
     * Marks the job status as Processing.
     */
    public void markAsProcessing() {
        this.status = "Processing";
    }

    /**
     * Marks the job status as Completed.
     */
    public void markAsCompleted() {
        this.status = "Completed";
    }

    @Override
    public String toString() {
        return "Job ID: " + id + ", File: " + fileName + ", Status: " + status;
    }
}

// Manages the queue of print jobs and completed jobs
class PrintManager {
    // Queue to hold jobs waiting to be processed (FIFO)
    private Queue<PrintJob> pendingJobs;
    // List to hold jobs that have been completed
    private List<PrintJob> completedJobs;
    // Counter for assigning unique job IDs
    private int nextJobId;

    /**
     * Constructs a new PrintManager.
     * Initializes the pending and completed job collections.
     */
    public PrintManager() {
        // LinkedList implements the Queue interface and is suitable for this use case
        this.pendingJobs = new LinkedList<>();
        // ArrayList implements the List interface and is suitable for storing completed jobs
        this.completedJobs = new ArrayList<>();
        this.nextJobId = 1; // Start job IDs from 1
    }

    /**
     * Adds a new print job to the pending queue.
     * @param fileName The name of the file for the job.
     */
    public void addJob(String fileName) {
        if (fileName == null || fileName.trim().isEmpty()) {
             System.err.println("Error: File name cannot be empty.");
             return; // Prevent adding invalid job
        }
        PrintJob newJob = new PrintJob(nextJobId++, fileName.trim());
        pendingJobs.offer(newJob); // Add job to the end of the queue
        System.out.println("Added job: " + newJob.getFileName() + " with ID " + newJob.getId());
    }

    /**
     * Processes the next job in the pending queue.
     * Removes the job from the queue and adds it to the completed list.
     * @throws NoJobsPendingException if the pending queue is empty.
     */
    public void processNextJob() throws NoJobsPendingException {
        // Check if the queue is empty before attempting to poll
        if (pendingJobs.isEmpty()) {
            throw new NoJobsPendingException("No jobs in the queue to process.");
        }

        PrintJob jobToProcess = pendingJobs.poll(); // Retrieve and remove the head of the queue

        // Simulate processing
        jobToProcess.markAsProcessing();
        System.out.println("Processing job: " + jobToProcess.getFileName() + " (ID: " + jobToProcess.getId() + ")");

        // Simulate work (optional, for realism)
        try {
            Thread.sleep(500); // Simulate processing time
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt(); // Restore interrupt status
            System.err.println("Processing interrupted.");
        }

        jobToProcess.markAsCompleted();
        completedJobs.add(jobToProcess); // Add the completed job to the list

        System.out.println("Job " + jobToProcess.getId() + " completed successfully.");
    }

    /**
     * Displays all jobs currently in the pending queue.
     */
    public void viewPendingJobs() {
        System.out.println("\n--- Pending Jobs ---");
        if (pendingJobs.isEmpty()) {
            System.out.println("No jobs currently in the queue.");
        } else {
            // Iterate through the queue without removing elements
            int index = 1;
            for (PrintJob job : pendingJobs) {
                System.out.println(index++ + ". " + job);
            }
        }
        System.out.println("--------------------");
    }

    /**
     * Displays all jobs that have been completed.
     */
    public void viewCompletedJobs() {
        System.out.println("\n--- Completed Jobs ---");
        if (completedJobs.isEmpty()) {
            System.out.println("No jobs have been completed yet.");
        } else {
            // Iterate through the list
            int index = 1;
            for (PrintJob job : completedJobs) {
                System.out.println(index++ + ". " + job);
            }
        }
        System.out.println("--------------------");
    }
}

// Main class to run the Print Job Management System
public class PrintSystem {

    public static void main(String[] args) {
        // Scanner for reading user input from the console
        Scanner scanner = new Scanner(System.in);
        // Instance of the PrintManager to handle job operations
        PrintManager manager = new PrintManager();
        boolean running = true;

        // Main application loop
        while (running) {
            // Display menu options to the user
            System.out.println("\n--- Print Job Management Menu ---");
            System.out.println("1. Add New Print Job");
            System.out.println("2. Process Next Job");
            System.out.println("3. View Pending Jobs");
            System.out.println("4. View Completed Jobs");
            System.out.println("5. Exit");
            System.out.print("Enter your choice: ");

            // Use try-catch for robust input handling and operation execution
            // This demonstrates class-wide exception handling for the main loop's operations
            try {
                // Read the user's choice
                int choice = scanner.nextInt();
                scanner.nextLine(); // Consume the newline character left by nextInt()

                // Use a switch statement to perform actions based on the user's choice
                switch (choice) {
                    case 1:
                        // Add New Print Job
                        System.out.print("Enter file name for the new job: ");
                        String fileName = scanner.nextLine();
                        manager.addJob(fileName); // Delegate to PrintManager
                        break;

                    case 2:
                        // Process Next Job
                        // This method can throw NoJobsPendingException
                        manager.processNextJob();
                        break;

                    case 3:
                        // View Pending Jobs
                        manager.viewPendingJobs(); // Delegate to PrintManager
                        break;

                    case 4:
                        // View Completed Jobs
                        manager.viewCompletedJobs(); // Delegate to PrintManager
                        break;

                    case 5:
                        // Exit the application
                        running = false;
                        System.out.println("Exiting Print System. Goodbye!");
                        break;

                    default:
                        // Handle invalid menu choices (numbers outside 1-5)
                        System.out.println("Invalid choice. Please enter a number between 1 and 5.");
                }
            } catch (InputMismatchException e) {
                // Catch error if user enters non-integer input
                System.err.println("Invalid input. Please enter a number corresponding to the menu option.");
                scanner.nextLine(); // Clear the invalid input from the scanner buffer
            } catch (NoJobsPendingException e) {
                // Catch custom exception when trying to process an empty queue
                System.err.println("Operation failed: " + e.getMessage());
            } catch (Exception e) {
                // Catch any other unexpected runtime exceptions
                System.err.println("An unexpected error occurred: " + e.getMessage());
                // e.printStackTrace(System.err); // Uncomment for detailed debugging output
            }
        }

        // Close the scanner resource when the application exits
        scanner.close();
    }
}
