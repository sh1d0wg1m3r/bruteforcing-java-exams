/*
 * Exam Question #233
 * Generated on: 2025-05-11 22:36:26
 * Generated by: Account 2
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Resource Allocation System Simulation
 * 
 * **Problem Description:**
 * 
 * You are tasked with developing a simple simulation of a resource allocation system. The system manages a fixed pool of generic resources and processes user requests for these resources on a first-come, first-served basis.
 * 
 * Your program should allow users to interact with the system via a command-line interface. The system maintains a list of currently available resources and a queue of pending requests that are waiting for a resource to become free.
 * 
 * **Requirements:**
 * 
 * 1.  **Data Structures:**
 *     *   Maintain a collection of available resources using `java.util.List`. Specifically, use `java.util.ArrayList` for implementation.
 *     *   Maintain a queue of resource requests using `java.util.Queue`. Use a suitable implementation like `java.util.LinkedList` (which implements `Queue`).
 * 2.  **Classes:**
 *     *   Create a `Resource` class representing a single resource. It should have a unique ID (e.g., an integer).
 *     *   Create a `ResourceRequest` class representing a request for a resource. It should have a unique request ID and a description.
 *     *   Create a `ResourceManager` class that encapsulates the `List` of available resources and the `Queue` of requests. This class should contain the core logic for managing resources and requests.
 * 3.  **Functionality (via User Input):**
 *     *   **Initialize Resources:** The system should start with a predefined number of available resources (e.g., 5).
 *     *   **Add Request:** Allow the user to add a new resource request by providing a description. The system should automatically assign a unique request ID. The request is added to the pending queue.
 *     *   **Process Next Request:** Attempt to process the next request from the front of the queue. If a resource is available, allocate it to the request (conceptually, remove a resource from the available list and the request from the queue). If no resource is available or the queue is empty, inform the user.
 *     *   **View Pending Requests:** Display all requests currently in the queue.
 *     *   **View Available Resources:** Display the IDs of all resources currently available.
 *     *   **Exit:** Terminate the program.
 * 4.  **User Interface:**
 *     *   Use `java.util.Scanner` to read user input from the console.
 *     *   Present a menu of options to the user.
 *     *   Use a `switch` statement to handle the user's menu choice.
 *     *   Use `System.out` for displaying the menu, prompts, successful operations, and status information (pending requests, available resources).
 *     *   Use `System.err` for displaying error messages (e.g., invalid input, operation failures).
 * 5.  **Error Handling:**
 *     *   Implement input validation, especially for menu choices (e.g., ensuring input is an integer within the valid range). Handle `NumberFormatException` and other potential input errors.
 *     *   Handle cases where operations cannot be performed (e.g., processing a request when the queue is empty or no resources are available).
 *     *   Implement class-wide exception handling using a `try-catch` block in the `main` method to catch unexpected errors and print an informative message to `System.err`.
 * 6.  **Best Practices:**
 *     *   Apply proper encapsulation (private fields, public methods) in your classes.
 *     *   Use meaningful variable and method names.
 *     *   Include appropriate comments and documentation (e.g., Javadoc for classes/methods).
 *     *   Ensure clean and readable code structure.
 * 
 * **Expected Output:**
 * 
 * The program should display a menu, prompt for user input, and provide feedback based on the chosen operation. Error messages should go to `System.err`, while normal output goes to `System.out`.
 * 
 * Example interaction flow:
 * 
 * ```
 * --- Resource Allocation System ---
 * 1. Add Resource Request
 * 2. Process Next Request
 * 3. View Pending Requests
 * 4. View Available Resources
 * 5. Exit
 * Enter your choice: 1
 * Enter request description: Need a server for testing
 * Request 1 added to the queue.
 * 
 * --- Resource Allocation System ---
 * 1. Add Resource Request
 * 2. Process Next Request
 * 3. View Pending Requests
 * 4. View Available Resources
 * 5. Exit
 * Enter your choice: 4
 * Available Resources (IDs): [1, 2, 3, 4, 5]
 * 
 * --- Resource Allocation System ---
 * 1. Add Resource Request
 * 2. Process Next Request
 * 3. View Pending Requests
 * 4. View Available Resources
 * 5. Exit
 * Enter your choice: 3
 * Pending Requests (ID - Description):
 * 1 - Need a server for testing
 * 
 * --- Resource Allocation System ---
 * 1. Add Resource Request
 * 2. Process Next Request
 * 3. View Pending Requests
 * 4. View Available Resources
 * 5. Exit
 * Enter your choice: 2
 * Processing request 1...
 * Request 1 processed, allocated Resource 1.
 * 
 * --- Resource Allocation System ---
 * 1. Add Resource Request
 * 2. Process Next Request
 * 3. View Pending Requests
 * 4. View Available Resources
 * 5. Exit
 * Enter your choice: 4
 * Available Resources (IDs): [2, 3, 4, 5]
 * 
 * --- Resource Allocation System ---
 * 1. Add Resource Request
 * 2. Process Next Request
 * 3. View Pending Requests
 * 4. View Available Resources
 * 5. Exit
 * Enter your choice: 9
 * Invalid choice. Please enter a number between 1 and 5.
 * 
 * --- Resource Allocation System ---
 * ... (user continues)
 * Enter your choice: 5
 * Exiting system.
 * ```
 * 
 * Your solution should be a single Java file containing all necessary classes.
 * 
 * **Evaluation Criteria:**
 * 
 * *   Correct usage of `Queue`, `ArrayList`, and `List`.
 * *   Correct usage of `Scanner`, `switch`, `System.out`, and `System.err`.
 * *   Effective use of `try-catch` for exception handling (both input validation and general errors).
 * *   Proper implementation of the required functionality (add, process, view, exit).
 * *   Adherence to best practices (encapsulation, naming, comments, input validation, error handling).
 * *   Clean and organized code structure.
 *
 * EXPLANATION:
 * The provided solution implements a simple Resource Allocation System simulation using the required Java components and best practices.
 * 
 * **Key Concepts Demonstrated:**
 * 
 * 1.  **Object-Oriented Programming:** The system is structured using classes (`Resource`, `ResourceRequest`, `ResourceManager`). These classes encapsulate data (fields) and behavior (methods). Fields are `private` to enforce encapsulation, and access is provided via `public` methods (getters).
 * 2.  **Data Structures (`List`, `ArrayList`, `Queue`, `LinkedList`):**
 *     *   `availableResources` is declared as a `List<Resource>` and instantiated as an `ArrayList`. This demonstrates using the interface type for broader compatibility while using a concrete implementation. `ArrayList` is suitable here for storing and accessing resources, though `remove(0)` has O(n) performance.
 *     *   `requestQueue` is declared as a `Queue<ResourceRequest>` and instantiated as a `LinkedList`. `LinkedList` is a common implementation for the `Queue` interface, providing efficient FIFO operations (`offer` for adding, `poll` for removing from the head).
 * 3.  **User Input (`Scanner`):** The `Scanner` class is used in the `main` method to read user input from `System.in`. It's important to close the `Scanner` when done, which is handled in the `finally` block.
 * 4.  **Control Flow (`switch`):** A `switch` statement is used in the main loop to direct execution based on the user's integer menu choice, providing a clear and readable way to handle multiple options.
 * 5.  **Output (`System.out`, `System.err`):**
 *     *   `System.out.println()` is used for standard output: displaying the menu, prompts, confirmation messages, and lists of resources/requests.
 *     *   `System.err.println()` is used specifically for error messages, such as invalid user input or system errors caught by the `try-catch` blocks. This directs error output to the standard error stream, which is good practice.
 * 6.  **Exception Handling (`try-catch`):**
 *     *   **Input Validation:** An inner `try-catch` block is used within the main loop to specifically handle `NumberFormatException` that occurs if the user enters non-integer input when a number is expected for the menu choice. The error message is printed to `System.err`.
 *     *   **Class-Wide Handling:** An outer `try-catch` block wraps the main `while` loop in the `main` method. This demonstrates handling potentially unexpected exceptions that might occur during the program's execution, providing a safety net and preventing the program from crashing abruptly. It prints a generic error message to `System.err` and also prints the stack trace for debugging purposes.
 *     *   The `processNextRequest` method handles the cases where the queue or resource list might be empty before attempting `poll()` or `remove(0)`, preventing `NoSuchElementException` (from `remove()` on an empty `Queue` if `remove()` was used instead of `poll()`) or `IndexOutOfBoundsException` (from `remove(0)` on an empty `List`).
 * 7.  **Best Practices:**
 *     *   Meaningful names are used for classes, variables, and methods (e.g., `ResourceManager`, `availableResources`, `addRequest`).
 *     *   Basic Javadoc-style comments are included for classes and methods, explaining their purpose.
 *     *   Input validation is performed for the menu choice and the request description.
 *     *   Error messages are informative and directed to `System.err`.
 *     *   The code is structured logically with separate classes for different concerns and a main application class to drive the interaction.
 *     *   The `finally` block ensures resources like the `Scanner` are cleaned up.
 * 
 * This solution effectively integrates the required components into a functional system, demonstrating understanding of fundamental Java data structures, control flow, object-oriented principles, and robust error handling.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.NoSuchElementException; // Potentially useful if not using poll()

/**
 * Represents a single resource in the system.
 */
class Resource {
    private int id;

    /**
     * Constructs a Resource with a given ID.
     * @param id The unique identifier for the resource.
     */
    public Resource(int id) {
        this.id = id;
    }

    /**
     * Gets the ID of the resource.
     * @return The resource ID.
     */
    public int getId() {
        return id;
    }

    @Override
    public String toString() {
        return "Resource ID: " + id;
    }
}

/**
 * Represents a request for a resource.
 */
class ResourceRequest {
    private int requestId;
    private String description;

    /**
     * Constructs a ResourceRequest with a given ID and description.
     * @param requestId The unique identifier for the request.
     * @param description A brief description of the request.
     */
    public ResourceRequest(int requestId, String description) {
        this.requestId = requestId;
        this.description = description;
    }

    /**
     * Gets the ID of the request.
     * @return The request ID.
     */
    public int getRequestId() {
        return requestId;
    }

    /**
     * Gets the description of the request.
     * @return The request description.
     */
    public String getDescription() {
        return description;
    }

    @Override
    public String toString() {
        return "Request ID: " + requestId + " - Description: " + description;
    }
}

/**
 * Manages the pool of available resources and the queue of pending requests.
 */
class ResourceManager {
    private List<Resource> availableResources; // Using List interface, implemented by ArrayList
    private Queue<ResourceRequest> requestQueue; // Using Queue interface, implemented by LinkedList
    private int nextRequestId = 1; // Counter for unique request IDs

    /**
     * Constructs a ResourceManager and initializes it with a specified number of resources.
     * @param initialResourceCount The number of resources to initially make available.
     */
    public ResourceManager(int initialResourceCount) {
        // Use ArrayList for the List implementation
        this.availableResources = new ArrayList<>();
        for (int i = 1; i <= initialResourceCount; i++) {
            availableResources.add(new Resource(i));
        }

        // Use LinkedList for the Queue implementation
        this.requestQueue = new LinkedList<>();

        System.out.println("ResourceManager initialized with " + initialResourceCount + " resources.");
    }

    /**
     * Adds a new resource request to the queue.
     * @param description The description for the new request.
     */
    public void addRequest(String description) {
        ResourceRequest newRequest = new ResourceRequest(nextRequestId++, description);
        requestQueue.offer(newRequest); // Use offer to add to the queue
        System.out.println("Request " + newRequest.getRequestId() + " added to the queue.");
    }

    /**
     * Attempts to process the next request in the queue by allocating an available resource.
     */
    public void processNextRequest() {
        // Check if the queue is empty
        if (requestQueue.isEmpty()) {
            System.out.println("No pending requests in the queue.");
            return;
        }

        // Check if resources are available
        if (availableResources.isEmpty()) {
            System.out.println("No resources currently available to process the request.");
            return;
        }

        // Poll the next request from the front of the queue (removes and returns)
        ResourceRequest processedRequest = requestQueue.poll();

        // Get the first available resource from the list (and remove it)
        // ArrayList.remove(0) is O(n), but acceptable for this simulation size.
        // If performance were critical with large numbers of resources, a different structure might be better.
        Resource allocatedResource = availableResources.remove(0);

        System.out.println("Processing request " + processedRequest.getRequestId() + "...");
        System.out.println("Request " + processedRequest.getRequestId() + " processed, allocated Resource " + allocatedResource.getId() + ".");
    }

    /**
     * Displays all requests currently waiting in the queue.
     */
    public void viewPendingRequests() {
        System.out.println("--- Pending Requests (ID - Description) ---");
        if (requestQueue.isEmpty()) {
            System.out.println("No pending requests.");
        } else {
            // Iterate through the queue without removing elements
            for (ResourceRequest request : requestQueue) {
                System.out.println(request.getRequestId() + " - " + request.getDescription());
            }
        }
    }

    /**
     * Displays the IDs of all resources currently available.
     */
    public void viewAvailableResources() {
        System.out.println("--- Available Resources (IDs) ---");
        if (availableResources.isEmpty()) {
            System.out.println("No resources currently available.");
        } else {
            List<Integer> resourceIds = new ArrayList<>();
            for (Resource resource : availableResources) {
                resourceIds.add(resource.getId());
            }
            // Print the list of IDs in a readable format
            System.out.println(resourceIds);
        }
    }
}

/**
 * Main application class for the Resource Allocation System simulation.
 * Handles user interaction and manages the ResourceManager.
 */
public class ResourceAllocationApp {

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        ResourceManager manager = new ResourceManager(5); // Initialize with 5 resources
        boolean running = true;

        // Class-wide exception handling using a try-catch block
        try {
            while (running) {
                printMenu();
                System.out.print("Enter your choice: ");

                int choice = -1; // Default invalid choice

                // Inner try-catch for handling input errors (e.g., non-integer input)
                try {
                    String input = scanner.nextLine();
                    choice = Integer.parseInt(input);
                } catch (NumberFormatException e) {
                    System.err.println("Invalid input. Please enter a number.");
                    // Continue the loop to show the menu again
                    continue;
                }

                // Use switch statement for menu control
                switch (choice) {
                    case 1:
                        System.out.print("Enter request description: ");
                        String description = scanner.nextLine();
                        if (description == null || description.trim().isEmpty()) {
                            System.err.println("Request description cannot be empty.");
                        } else {
                            manager.addRequest(description.trim());
                        }
                        break;
                    case 2:
                        manager.processNextRequest();
                        break;
                    case 3:
                        manager.viewPendingRequests();
                        break;
                    case 4:
                        manager.viewAvailableResources();
                        break;
                    case 5:
                        System.out.println("Exiting system.");
                        running = false; // Set flag to exit the loop
                        break;
                    default:
                        // Handle choices outside the valid range
                        System.err.println("Invalid choice. Please enter a number between 1 and 5.");
                        break;
                }
                System.out.println(); // Add a blank line for readability between operations
            }
        } catch (Exception e) {
            // Catch any unexpected runtime exceptions
            System.err.println("An unexpected system error occurred: " + e.getMessage());
            e.printStackTrace(); // Print stack trace for debugging
        } finally {
            // Ensure the scanner is closed even if an exception occurs
            scanner.close();
            System.out.println("Scanner closed.");
        }
    }

    /**
     * Prints the main menu options to the console.
     */
    private static void printMenu() {
        System.out.println("--- Resource Allocation System ---");
        System.out.println("1. Add Resource Request");
        System.out.println("2. Process Next Request");
        System.out.println("3. View Pending Requests");
        System.out.println("4. View Available Resources");
        System.out.println("5. Exit");
    }
}
