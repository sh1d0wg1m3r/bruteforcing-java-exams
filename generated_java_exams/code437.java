/*
 * Exam Question #437
 * Generated on: 2025-05-11 23:11:04
 * Generated by: Account 4
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Assembly Line Simulation
 * 
 * **Scenario:**
 * 
 * You are tasked with developing a simplified simulation of a two-stage assembly line for manufacturing parts. Parts enter a buffer before Stage 1, move to a buffer before Stage 2 after completing Stage 1, and finally move to a completed parts area after completing Stage 2. Stage 2 also includes a quality control check.
 * 
 * **Your Task:**
 * 
 * Implement a Java program that simulates this assembly line. The program should allow a user to interact with the assembly line through a simple command-line interface.
 * 
 * **Requirements:**
 * 
 * 1.  **Classes:**
 *     *   Create a `Part` class to represent a manufactured part. It should have a unique integer ID.
 *     *   Create an `AssemblyLine` class that manages the assembly process.
 *     *   Create a main class (e.g., `AssemblyLineManager`) to handle user interaction.
 * 
 * 2.  **AssemblyLine Class Details:**
 *     *   Use a `Queue<Part>` to represent the buffer *before* Stage 1 (`stage1Buffer`). Parts are added to the end and processed from the front (FIFO).
 *     *   Use a `Queue<Part>` to represent the buffer *before* Stage 2 (`stage2Buffer`). Parts completing Stage 1 are added here, and parts are processed from the front for Stage 2.
 *     *   Use an `ArrayList<Part>` (via the `List` interface) to store parts that have successfully completed Stage 2 (`completedParts`).
 *     *   Use an `ArrayList<Part>` (via the `List` interface) to store parts that failed the quality check in Stage 2 (`failedParts`).
 *     *   Implement methods:
 *         *   `addPartToStage1Buffer()`: Creates a new `Part` with a unique ID and adds it to the `stage1Buffer`.
 *         *   `processStage1()`: Takes the next part from `stage1Buffer`, simulates processing, and adds it to `stage2Buffer`. If `stage1Buffer` is empty, report an error.
 *         *   `processStage2()`: Takes the next part from `stage2Buffer`, simulates processing, and performs a quality check. There is a 90% chance the part passes quality control and is added to `completedParts`. There is a 10% chance it fails and is added to `failedParts`. If `stage2Buffer` is empty, report an error.
 *         *   `getStatus()`: Returns a string describing the current state (number of parts in each buffer, completed count, failed count).
 * 
 * 3.  **AssemblyLineManager Class Details:**
 *     *   In the `main` method, create an instance of `AssemblyLine`.
 *     *   Use `Scanner` to read user commands from `System.in`.
 *     *   Implement a command loop that continues until the user enters 'exit'.
 *     *   Use a `switch` statement to handle the following commands:
 *         *   `add`: Call `assemblyLine.addPartToStage1Buffer()`. Print a success message.
 *         *   `process1`: Call `assemblyLine.processStage1()`. Print a success message or an error if the buffer was empty.
 *         *   `process2`: Call `assemblyLine.processStage2()`. Print a success message indicating if the part passed or failed quality control, or an error if the buffer was empty.
 *         *   `status`: Call `assemblyLine.getStatus()` and print the result to `System.out`.
 *         *   `exit`: Terminate the program.
 *         *   Any other input: Print an "Invalid command" message to `System.err`.
 *     *   Use `System.out` for normal output (prompts, success messages, status).
 *     *   Use `System.err` for error messages (buffer empty, invalid command).
 *     *   Implement class-wide exception handling using a `try-catch` block around the main command loop to catch any unexpected runtime errors and print an error message to `System.err` before exiting.
 *     *   Ensure proper input validation where necessary (e.g., handling non-string input if attempting integer parsing, though the commands are strings here).
 * 
 * 4.  **Best Practices:**
 *     *   Use meaningful variable and method names.
 *     *   Add comments to explain complex logic.
 *     *   Use appropriate access modifiers (`private`, `public`).
 *     *   Ensure resources like `Scanner` are closed properly (e.g., using try-with-resources).
 * 
 * **Expected Output Format:**
 * 
 * *   Prompts for commands: `Enter command (add, process1, process2, status, exit): `
 * *   Success messages: e.g., `Part 1 added to Stage 1 buffer.` `Part 1 moved from Stage 1 to Stage 2 buffer.` `Part 1 processed through Stage 2. Quality check: PASSED.` or `Part 1 processed through Stage 2. Quality check: FAILED.`
 * *   Status output: e.g., `Assembly Line Status: Stage 1 Buffer: 5 parts, Stage 2 Buffer: 3 parts, Completed: 10 parts, Failed: 2 parts.`
 * *   Error messages (to `System.err`): e.g., `Error: Stage 1 buffer is empty. Cannot process.` `Error: Invalid command. Please try again.` `An unexpected error occurred: [Exception Details]`
 * 
 * **Evaluation Criteria:**
 * 
 * *   Correct usage of `Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.err`, `System.out`, `try-catch`.
 * *   Proper implementation of the assembly line logic (FIFO, quality check).
 * *   Effective use of encapsulation and meaningful names.
 * *   Correct input validation and error handling.
 * *   Clean code structure and appropriate comments.
 * 
 * **Time Limit:** 45-60 minutes
 * 
 * ---
 *
 * EXPLANATION:
 * This solution implements a simplified assembly line simulation demonstrating the required Java concepts.
 * 
 * 1.  **Class Structure:**
 *     *   `Part`: A simple class encapsulating a part's unique ID. It provides a getter and a helpful `toString` method.
 *     *   `AssemblyLine`: This class holds the state of the assembly line using the required data structures:
 *         *   `stage1Buffer` and `stage2Buffer`: Declared as `Queue<Part>` and instantiated as `LinkedList<Part>`. `LinkedList` is a common implementation of the `Queue` interface, providing FIFO behavior suitable for buffers where parts wait in order.
 *         *   `completedParts` and `failedParts`: Declared as `List<Part>` and instantiated as `ArrayList<Part>`. `ArrayList` is a dynamic array implementation of the `List` interface, suitable for storing collections of parts where order might be maintained (order of completion/failure) and efficient random access isn't strictly necessary but adding is common.
 *         *   `nextPartId`: A simple counter to ensure each `Part` gets a unique ID.
 *         *   `random`: Used for the probabilistic quality control check.
 *     *   `AssemblyLineManager`: The main class containing the `main` method. It sets up the simulation, handles user input, and controls the flow.
 * 
 * 2.  **Core Logic and Component Usage:**
 *     *   **`Queue`:** Used in `stage1Buffer` and `stage2Buffer`.
 *         *   `addPartToStage1Buffer()` uses `offer()` to add a new part to the end of `stage1Buffer`.
 *         *   `processStage1()` and `processStage2()` use `poll()` to retrieve and remove the part at the front of `stage1Buffer` and `stage2Buffer` respectively, simulating a part moving out of the buffer and into processing.
 *     *   **`List`/`ArrayList`:** Used in `completedParts` and `failedParts`.
 *         *   `processStage2()` uses `add()` to append parts to the end of either `completedParts` or `failedParts` based on the quality check result.
 *     *   **`Scanner`:** Used in `AssemblyLineManager.main` to read commands from `System.in`. The `try-with-resources` block ensures the `Scanner` is automatically closed when the block is exited.
 *     *   **`Switch Statement`:** Used in `AssemblyLineManager.main` to dispatch actions based on the user's command string (`add`, `process1`, `process2`, `status`, `exit`).
 *     *   **`System.out`:** Used for user prompts, success messages (part added, moved, passed/failed), and the status report.
 *     *   **`System.err`:** Used specifically for error messages:
 *         *   When a processing command (`process1`, `process2`) is issued but the corresponding buffer is empty (caught by a specific `catch` block within the `switch` case).
 *         *   When an invalid command is entered (in the `default` case of the `switch`).
 *         *   When an unexpected exception occurs (in the main `catch` block).
 *     *   **Class-wide `try-catch`:** A `try-catch(Exception e)` block wraps the entire `while` loop in `AssemblyLineManager.main`. This provides a safety net to catch any uncaught runtime exceptions that might occur during the execution of commands, preventing the program from crashing abruptly. It prints an error message and the stack trace to `System.err`. Specific error conditions like empty buffers are handled more gracefully with `IllegalStateException` and reported to `System.err` within their respective `catch` blocks inside the loop.
 * 
 * 3.  **Error Handling and Validation:**
 *     *   `processStage1` and `processStage2` throw `IllegalStateException` if their respective input buffers are empty, clearly indicating why processing failed.
 *     *   The `main` method catches these specific `IllegalStateException`s and prints a user-friendly error message to `System.err`.
 *     *   The `switch` statement's `default` case handles invalid command input, printing an error to `System.err`.
 *     *   The outer `try-catch` handles any other unforeseen errors.
 * 
 * 4.  **Best Practices:**
 *     *   Fields in `Part` and `AssemblyLine` are `private`, and access is provided via `public` methods (`getId`, `addPartToStage1Buffer`, etc.), demonstrating encapsulation.
 *     *   Variable names (`stage1Buffer`, `completedParts`, `nextPartId`, `partToProcess`) and method names (`addPartToStage1Buffer`, `processStage1`, `getStatus`) are descriptive.
 *     *   Comments explain the purpose of classes, methods, and the random quality check logic.
 *     *   The use of `offer` and `poll` for the Queue operations is standard practice, handling potential queue full/empty states gracefully (though in this simulation, the queues are effectively unlimited). `poll` returning `null` is explicitly checked.
 *     *   The `QUALITY_PASS_RATE` is defined as a constant.
 * 
 * This solution effectively integrates all required components into a functional simulation, demonstrating understanding of data structures, control flow, user interaction, and robust error handling in Java.
 */

import java.util.LinkedList;
import java.util.Queue;
import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;
import java.util.Random;

// Represents a single part being manufactured
class Part {
    private int id;

    public Part(int id) {
        this.id = id;
    }

    public int getId() {
        return id;
    }

    @Override
    public String toString() {
        return "Part#" + id;
    }
}

// Manages the assembly line stages
class AssemblyLine {
    // Buffers between stages using Queues (FIFO)
    private Queue<Part> stage1Buffer;
    private Queue<Part> stage2Buffer;

    // Storage for completed and failed parts using Lists
    private List<Part> completedParts;
    private List<Part> failedParts;

    // Counter for generating unique part IDs
    private int nextPartId;

    // Random generator for quality control check
    private Random random;
    private static final double QUALITY_PASS_RATE = 0.90; // 90% pass rate

    public AssemblyLine() {
        // Use LinkedList as an implementation of Queue
        stage1Buffer = new LinkedList<>();
        stage2Buffer = new LinkedList<>();
        completedParts = new ArrayList<>();
        failedParts = new ArrayList<>();
        nextPartId = 1; // Start part IDs from 1
        random = new Random();
    }

    /**
     * Creates a new part and adds it to the buffer before Stage 1.
     * @return The newly added part.
     */
    public Part addPartToStage1Buffer() {
        Part newPart = new Part(nextPartId++);
        stage1Buffer.offer(newPart); // offer is generally preferred over add for queues as it returns false on failure
        System.out.println(newPart + " added to Stage 1 buffer.");
        return newPart;
    }

    /**
     * Processes a part from Stage 1 buffer, moving it to Stage 2 buffer.
     * @throws IllegalStateException if Stage 1 buffer is empty.
     */
    public void processStage1() {
        Part partToProcess = stage1Buffer.poll(); // poll retrieves and removes the head, returns null if empty
        if (partToProcess == null) {
            throw new IllegalStateException("Stage 1 buffer is empty. Cannot process.");
        }
        stage2Buffer.offer(partToProcess);
        System.out.println(partToProcess + " moved from Stage 1 to Stage 2 buffer.");
    }

    /**
     * Processes a part from Stage 2 buffer, performing quality control.
     * Part is moved to completedParts or failedParts based on the check.
     * @throws IllegalStateException if Stage 2 buffer is empty.
     */
    public void processStage2() {
        Part partToProcess = stage2Buffer.poll();
        if (partToProcess == null) {
            throw new IllegalStateException("Stage 2 buffer is empty. Cannot process.");
        }

        boolean passedQualityCheck = random.nextDouble() < QUALITY_PASS_RATE;

        if (passedQualityCheck) {
            completedParts.add(partToProcess);
            System.out.println(partToProcess + " processed through Stage 2. Quality check: PASSED.");
        } else {
            failedParts.add(partToProcess);
            System.out.println(partToProcess + " processed through Stage 2. Quality check: FAILED.");
        }
    }

    /**
     * Gets a string representation of the current assembly line status.
     * @return Status string.
     */
    public String getStatus() {
        return String.format("Assembly Line Status: Stage 1 Buffer: %d parts, Stage 2 Buffer: %d parts, Completed: %d parts, Failed: %d parts.",
                             stage1Buffer.size(),
                             stage2Buffer.size(),
                             completedParts.size(),
                             failedParts.size());
    }
}

// Main class to run the simulation and handle user interaction
public class AssemblyLineManager {

    public static void main(String[] args) {
        // Use try-with-resources to ensure the Scanner is closed
        try (Scanner scanner = new Scanner(System.in)) {
            AssemblyLine assemblyLine = new AssemblyLine();
            boolean running = true;

            // Class-wide exception handling for the main loop
            try {
                while (running) {
                    System.out.print("Enter command (add, process1, process2, status, exit): ");
                    String command = scanner.nextLine().trim().toLowerCase();

                    // Use switch statement for command processing
                    switch (command) {
                        case "add":
                            assemblyLine.addPartToStage1Buffer();
                            break;
                        case "process1":
                            try {
                                assemblyLine.processStage1();
                            } catch (IllegalStateException e) {
                                System.err.println("Error: " + e.getMessage()); // Use System.err for specific errors
                            }
                            break;
                        case "process2":
                            try {
                                assemblyLine.processStage2();
                            } catch (IllegalStateException e) {
                                System.err.println("Error: " + e.getMessage()); // Use System.err for specific errors
                            }
                            break;
                        case "status":
                            System.out.println(assemblyLine.getStatus());
                            break;
                        case "exit":
                            running = false;
                            System.out.println("Exiting assembly line simulation.");
                            break;
                        default:
                            System.err.println("Error: Invalid command. Please try again."); // Use System.err for invalid input
                    }
                }
            } catch (Exception e) {
                // Catch any unexpected runtime exceptions
                System.err.println("An unexpected error occurred: " + e.getMessage());
                e.printStackTrace(); // Print stack trace for debugging unexpected errors
            }

        } // Scanner is automatically closed here by try-with-resources
    }
}
