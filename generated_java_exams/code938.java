/*
 * Exam Question #938
 * Generated on: 2025-05-12 17:02:31
 * Generated by: Account 4
 * 
 * QUESTION:
 * ## Java Programming Exam Task: Advanced Event Registration System
 * 
 * **Scenario:** You are tasked with developing a simplified event management system for a small organization. The system needs to track various events, manage attendee registrations, and handle waiting lists for popular events that reach capacity.
 * 
 * **Requirements:**
 * 
 * Implement a Java application that allows users to perform the following operations via a command-line interface:
 * 
 * 1.  **Add a New Event:** Prompt the user for the event name, date (as a string), and maximum capacity. Store this event in the system. The event name must be unique. Capacity must be a positive integer.
 * 2.  **Register Attendee:** Prompt the user for the event name and attendee name. If the event exists and has capacity, register the attendee. If the event exists but is full, add the attendee to a waiting list for that event. If the event does not exist, report an error. An attendee should not be registered or added to the waiting list if they are already on either list for that specific event.
 * 3.  **View Event Details:** Prompt the user for an event name. If the event exists, display its details: name, date, capacity, current number of attendees, the list of registered attendees, and the list of attendees on the waiting list. If the event does not exist, report an error.
 * 4.  **Process Waiting List:** For a specified event, move attendees from the waiting list to the main attendee list until the event reaches capacity or the waiting list is empty. Report how many attendees were moved.
 * 5.  **Exit:** Terminate the application.
 * 
 * Your solution must strictly adhere to the following technical constraints and best practices:
 * 
 * *   Use `java.util.Queue` to manage the waiting list for each event.
 * *   Use `java.util.ArrayList` to store the main list of events and the list of registered attendees within each event.
 * *   Use `java.util.List` interface type when declaring variables that hold `ArrayList` instances where appropriate (programming to the interface).
 * *   Use `java.util.Scanner` to read all user input. Ensure the `Scanner` is closed properly.
 * *   Use a `switch` statement to handle the user's menu choice.
 * *   Use `System.err` to display all error messages (e.g., event not found, invalid input, event full, already registered).
 * *   Use `System.out` for displaying the menu, prompts, successful operation messages, and event details.
 * *   Implement class-wide exception handling using `try-catch` blocks, particularly around user input operations, to gracefully handle unexpected input formats (e.g., non-integer input for capacity or menu choice). Include a general catch for `Exception` in the main application loop.
 * *   Design the system using appropriate classes (e.g., `Event`, `EventManager`, `EventManagementApp`).
 * *   Employ proper encapsulation (private fields, public methods) for your classes.
 * *   Use meaningful variable and method names.
 * *   Include appropriate comments and documentation (basic Javadoc for classes/methods).
 * *   Implement input validation (e.g., positive capacity, non-empty strings).
 * *   Ensure proper error handling for all potential issues described (event not found, full capacity, duplicate registration, invalid input).
 * 
 * **Expected Output:**
 * 
 * The application should present a menu to the user. Based on the user's choice, it should perform the requested operation, display results or errors, and loop back to the menu until the user chooses to exit.
 * 
 * Example interaction flow (simplified):
 * 
 * ```
 * Event Management System
 * 1. Add Event
 * 2. Register Attendee
 * 3. View Event Details
 * 4. Process Waiting List
 * 5. Exit
 * Enter your choice: 1
 * Enter event name: Java Conference
 * Enter event date: 2024-10-27
 * Enter event capacity: 100
 * Event 'Java Conference' added successfully.
 * 
 * Event Management System
 * ...
 * Enter your choice: 2
 * Enter event name: Java Conference
 * Enter attendee name: Alice
 * Alice registered successfully for 'Java Conference'.
 * 
 * Event Management System
 * ...
 * Enter your choice: 2
 * Enter event name: Java Conference
 * Enter attendee name: Bob
 * Bob registered successfully for 'Java Conference'.
 * 
 * Event Management System
 * ...
 * Enter your choice: 3
 * Enter event name: Java Conference
 * Event Details:
 * Name: Java Conference
 * Date: 2024-10-27
 * Capacity: 100
 * Attendees (2): [Alice, Bob]
 * Waiting List (0): []
 * 
 * Event Management System
 * ...
 * Enter your choice: 2
 * Enter event name: NonExistent Event
 * Error: Event 'NonExistent Event' not found.
 * 
 * Event Management System
 * ...
 * Enter your choice: 99
 * Error: Invalid choice. Please enter a number between 1 and 5.
 * 
 * Event Management System
 * ...
 * Enter your choice: five
 * Error: Invalid input. Please enter a number.
 * 
 * Event Management System
 * ...
 * Enter your choice: 5
 * Exiting Event Management System.
 * ```
 *
 * EXPLANATION:
 * The provided solution implements a basic event management system demonstrating the required Java concepts and best practices.
 * 
 * 1.  **Class Structure:**
 *     *   `Event`: Represents a single event. It holds the event's data (`name`, `date`, `capacity`) and manages its participants using an `ArrayList` for `attendees` and a `LinkedList` (implementing `Queue`) for the `waitingList`. Methods are provided for checking capacity (`isFull`), checking if an attendee is already listed (`isAttendeeListed`), adding attendees (`addAttendee`, `addToWaitingList`), and processing the waiting list (`processWaitingList`). Fields are `private` for encapsulation.
 *     *   `EventManager`: Manages a collection of `Event` objects. It uses a `List<Event>` (specifically an `ArrayList`) to store all events. It provides methods to add a new event (`addEvent`) and find an event by name (`findEvent`). This class acts as a central repository for events.
 *     *   `EventManagementApp`: Contains the `main` method and the core application logic. It handles user interaction via the `Scanner`, displays the menu, processes user input using a `switch` statement, and interacts with the `EventManager`.
 * 
 * 2.  **Required Components Usage:**
 *     *   `Queue`: Used in the `Event` class (`waitingList`) via `java.util.LinkedList`, which implements `Queue`. `offer()` is used to add to the queue, and `poll()` is used to retrieve and remove from the head of the queue in `processWaitingList`.
 *     *   `ArrayList`: Used in the `EventManager` class to store the `events` list (`List<Event> events = new ArrayList<>();`) and within the `Event` class to store `attendees` (`List<String> attendees = new ArrayList<>();`).
 *     *   `List interface`: Used as the declared type for the `events` list in `EventManager` (`List<Event>`) and the `attendees` list in `Event` (`List<String>`). This promotes programming to the interface.
 *     *   `Scanner`: An instance is created in `EventManagementApp` to read user input from `System.in`. It's used to read integers (`nextInt()`) and strings (`nextLine()`). The `scanner.nextLine()` call after `nextInt()` is crucial to consume the leftover newline character. The `Scanner` is closed when the application exits.
 *     *   `switch statement`: Used in the `run()` method of `EventManagementApp` to dispatch control based on the user's menu choice.
 *     *   `System.err`: Used throughout `EventManagementApp` to print error messages to the standard error stream, making them distinct from normal output.
 *     *   `System.out`: Used for printing the menu, prompts, success messages, and event details to the standard output stream.
 *     *   `try-catch blocks`:
 *         *   A `try-catch(InputMismatchException)` block is used in the `run()` method to handle cases where the user enters non-integer input for the menu choice. Similar handling is done in `addEvent` for capacity input.
 *         *   A general `catch(Exception e)` block is included in the main `run()` loop to catch any other unexpected runtime errors, printing a generic error message and the exception's message. This provides robustness.
 * 
 * 3.  **Best Practices:**
 *     *   **Encapsulation:** Fields in `Event` and `EventManager` are `private`, accessed only through public getter methods or specific action methods (`addAttendee`, `addToWaitingList`, etc.).
 *     *   **Meaningful Names:** Classes, methods, and variables have names that clearly indicate their purpose (e.g., `Event`, `EventManager`, `addEvent`, `registerAttendee`, `waitingList`, `attendees`).
 *     *   **Comments/Documentation:** Basic Javadoc comments are provided for classes and key methods, explaining their purpose. Inline comments clarify specific logic points.
 *     *   **Input Validation:** Checks are performed for empty strings (names, date) and positive capacity before creating or processing data. `InputMismatchException` handling validates integer input.
 *     *   **Error Handling:** Specific error messages are printed using `System.err` for conditions like event not found, event full, duplicate registration, and invalid input. The `try-catch` blocks ensure the application doesn't crash on invalid input.
 *     *   **Clean Code Structure:** The logic is divided into separate methods within the `EventManagementApp` for each menu option, making the `run()` method clean and easy to read. The concerns are separated into different classes (`Event` for data/logic of a single event, `EventManager` for managing the collection, `EventManagementApp` for UI/application flow).
 * 
 * This solution effectively integrates all required components within a practical scenario, demonstrating a solid understanding of core and intermediate Java concepts, data structures, and error handling.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.InputMismatchException;

/**
 * Represents a single event with attendees and a waiting list.
 */
class Event {
    private String name;
    private String date;
    private int capacity;
    private List<String> attendees;
    private Queue<String> waitingList;

    /**
     * Constructs a new Event.
     * @param name The name of the event.
     * @param date The date of the event.
     * @param capacity The maximum capacity of the event.
     */
    public Event(String name, String date, int capacity) {
        this.name = name;
        this.date = date;
        this.capacity = capacity;
        this.attendees = new ArrayList<>(); // Use ArrayList for attendees
        this.waitingList = new LinkedList<>(); // Use LinkedList which implements Queue
    }

    // --- Getters ---
    public String getName() {
        return name;
    }

    public String getDate() {
        return date;
    }

    public int getCapacity() {
        return capacity;
    }

    public List<String> getAttendees() {
        return attendees;
    }

    public Queue<String> getWaitingList() {
        return waitingList;
    }

    /**
     * Checks if the event is currently full.
     * @return true if the number of attendees equals or exceeds capacity, false otherwise.
     */
    public boolean isFull() {
        return attendees.size() >= capacity;
    }

    /**
     * Checks if an attendee is already registered or on the waiting list.
     * @param attendeeName The name of the attendee.
     * @return true if the attendee is already listed, false otherwise.
     */
    public boolean isAttendeeListed(String attendeeName) {
        return attendees.contains(attendeeName) || waitingList.contains(attendeeName);
    }

    /**
     * Adds an attendee to the event if there is capacity.
     * Assumes isFull() and isAttendeeListed() checks are done before calling.
     * @param attendeeName The name of the attendee to add.
     */
    public void addAttendee(String attendeeName) {
        attendees.add(attendeeName);
    }

    /**
     * Adds an attendee to the waiting list.
     * Assumes isAttendeeListed() check is done before calling.
     * @param attendeeName The name of the attendee to add to the waiting list.
     */
    public void addToWaitingList(String attendeeName) {
        waitingList.offer(attendeeName); // offer is generally preferred over add for queues
    }

    /**
     * Processes the waiting list, moving attendees to the main list until capacity is reached.
     * @return The number of attendees moved from waiting list to attendees.
     */
    public int processWaitingList() {
        int movedCount = 0;
        while (!isFull() && !waitingList.isEmpty()) {
            String attendee = waitingList.poll(); // poll retrieves and removes the head
            if (attendee != null && !attendees.contains(attendee)) { // Double check in case they registered another way (unlikely in this model)
                 attendees.add(attendee);
                 movedCount++;
            } else if (attendee != null) {
                 // If attendee was somehow already in attendees, just discard from waiting list
                 System.err.println("Warning: Attendee '" + attendee + "' from waiting list was already registered.");
            }
        }
        return movedCount;
    }

    @Override
    public String toString() {
        return "Event{" +
               "name='" + name + '\'' +
               ", date='" + date + '\'' +
               ", capacity=" + capacity +
               ", attendees=" + attendees.size() +
               ", waitingList=" + waitingList.size() +
               '}';
    }
}

/**
 * Manages a collection of events.
 */
class EventManager {
    private List<Event> events; // Use List interface, backed by ArrayList

    /**
     * Constructs a new EventManager.
     */
    public EventManager() {
        this.events = new ArrayList<>(); // Use ArrayList to store events
    }

    /**
     * Adds a new event to the manager.
     * @param event The event to add.
     * @return true if the event was added successfully, false if an event with the same name already exists.
     */
    public boolean addEvent(Event event) {
        if (findEvent(event.getName()) != null) {
            return false; // Event with this name already exists
        }
        events.add(event);
        return true;
    }

    /**
     * Finds an event by its name.
     * @param eventName The name of the event to find.
     * @return The Event object if found, null otherwise.
     */
    public Event findEvent(String eventName) {
        for (Event event : events) {
            if (event.getName().equalsIgnoreCase(eventName)) {
                return event;
            }
        }
        return null; // Event not found
    }

    // Other management methods could go here (e.g., removeEvent)
}

/**
 * Main application class for the Event Management System. Handles user interaction.
 */
public class EventManagementApp {

    private EventManager eventManager;
    private Scanner scanner;

    /**
     * Constructs the EventManagementApp.
     */
    public EventManagementApp() {
        this.eventManager = new EventManager();
        this.scanner = new Scanner(System.in);
    }

    /**
     * Displays the main menu.
     */
    private void printMenu() {
        System.out.println("\n--- Event Management System ---");
        System.out.println("1. Add Event");
        System.out.println("2. Register Attendee");
        System.out.println("3. View Event Details");
        System.out.println("4. Process Waiting List");
        System.out.println("5. Exit");
        System.out.print("Enter your choice: ");
    }

    /**
     * Runs the main application loop.
     */
    public void run() {
        int choice = -1;
        while (choice != 5) {
            printMenu();
            try {
                choice = scanner.nextInt();
                scanner.nextLine(); // Consume newline left-over

                switch (choice) {
                    case 1:
                        addEvent();
                        break;
                    case 2:
                        registerAttendee();
                        break;
                    case 3:
                        viewEventDetails();
                        break;
                    case 4:
                        processWaitingList();
                        break;
                    case 5:
                        System.out.println("Exiting Event Management System.");
                        break;
                    default:
                        System.err.println("Invalid choice. Please enter a number between 1 and 5.");
                }
            } catch (InputMismatchException e) {
                System.err.println("Error: Invalid input. Please enter a number.");
                scanner.nextLine(); // Consume the invalid input to prevent infinite loop
                choice = -1; // Reset choice to continue loop
            } catch (Exception e) {
                // Catch any other unexpected exceptions
                System.err.println("An unexpected error occurred: " + e.getMessage());
                // e.printStackTrace(); // Uncomment for detailed debugging in exam
            }
        }
        scanner.close(); // Close the scanner when exiting
    }

    /**
     * Handles the 'Add Event' functionality.
     */
    private void addEvent() {
        System.out.print("Enter event name: ");
        String name = scanner.nextLine().trim();
        if (name.isEmpty()) {
            System.err.println("Error: Event name cannot be empty.");
            return;
        }

        System.out.print("Enter event date: ");
        String date = scanner.nextLine().trim();
        if (date.isEmpty()) {
            System.err.println("Error: Event date cannot be empty.");
            return;
        }

        int capacity = -1;
        System.out.print("Enter event capacity: ");
        try {
            capacity = scanner.nextInt();
            scanner.nextLine(); // Consume newline
        } catch (InputMismatchException e) {
            System.err.println("Error: Invalid input for capacity. Please enter an integer.");
            scanner.nextLine(); // Consume invalid input
            return;
        }

        if (capacity <= 0) {
            System.err.println("Error: Event capacity must be a positive integer.");
            return;
        }

        Event newEvent = new Event(name, date, capacity);
        if (eventManager.addEvent(newEvent)) {
            System.out.println("Event '" + name + "' added successfully.");
        } else {
            System.err.println("Error: Event with name '" + name + "' already exists.");
        }
    }

    /**
     * Handles the 'Register Attendee' functionality.
     */
    private void registerAttendee() {
        System.out.print("Enter event name: ");
        String eventName = scanner.nextLine().trim();
        if (eventName.isEmpty()) {
            System.err.println("Error: Event name cannot be empty.");
            return;
        }

        Event event = eventManager.findEvent(eventName);
        if (event == null) {
            System.err.println("Error: Event '" + eventName + "' not found.");
            return;
        }

        System.out.print("Enter attendee name: ");
        String attendeeName = scanner.nextLine().trim();
        if (attendeeName.isEmpty()) {
            System.err.println("Error: Attendee name cannot be empty.");
            return;
        }

        if (event.isAttendeeListed(attendeeName)) {
            System.err.println("Error: Attendee '" + attendeeName + "' is already registered or on the waiting list for '" + eventName + "'.");
            return;
        }

        if (!event.isFull()) {
            event.addAttendee(attendeeName);
            System.out.println("Attendee '" + attendeeName + "' registered successfully for '" + eventName + "'.");
        } else {
            event.addToWaitingList(attendeeName);
            System.out.println("Attendee '" + attendeeName + "' added to waiting list for '" + eventName + "' (event is full).");
        .err}
    }

    /**
     * Handles the 'View Event Details' functionality.
     */
    private void viewEventDetails() {
        System.out.print("Enter event name: ");
        String eventName = scanner.nextLine().trim();
        if (eventName.isEmpty()) {
            System.err.println("Error: Event name cannot be empty.");
            return;
        }

        Event event = eventManager.findEvent(eventName);
        if (event == null) {
            System.err.println("Error: Event '" + eventName + "' not found.");
            return;
        }

        System.out.println("\n--- Event Details ---");
        System.out.println("Name: " + event.getName());
        System.out.println("Date: " + event.getDate());
        System.out.println("Capacity: " + event.getCapacity());
        System.out.println("Current Attendees: " + event.getAttendees().size());
        System.out.println("Registered Attendees (" + event.getAttendees().size() + "): " + event.getAttendees());
        System.out.println("Waiting List (" + event.getWaitingList().size() + "): " + event.getWaitingList());
        System.out.println("---------------------");
    }

    /**
     * Handles the 'Process Waiting List' functionality.
     */
    private void processWaitingList() {
        System.out.print("Enter event name: ");
        String eventName = scanner.nextLine().trim();
        if (eventName.isEmpty()) {
            System.err.println("Error: Event name cannot be empty.");
            return;
        }

        Event event = eventManager.findEvent(eventName);
        if (event == null) {
            System.err.println("Error: Event '" + eventName + "' not found.");
            return;
        }

        if (!event.isFull() && !event.getWaitingList().isEmpty()) {
            int moved = event.processWaitingList();
            System.out.println(moved + " attendees moved from waiting list to attendees for '" + eventName + "'.");
            if (event.isFull()) {
                System.out.println("Event '" + eventName + "' is now full.");
            }
        } else if (event.isFull()) {
            System.out.println("Event '" + eventName + "' is already full. No spots available from waiting list.");
        } else { // Waiting list is empty
             System.out.println("Waiting list for '" + eventName + "' is empty. No attendees to process.");
        }
    }

    /**
     * Main method to start the application.
     * @param args Command line arguments (not used).
     */
    public static void main(String[] args) {
        EventManagementApp app = new EventManagementApp();
        app.run();
    }
}
