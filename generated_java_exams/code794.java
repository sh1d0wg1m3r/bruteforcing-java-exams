/*
 * Exam Question #794
 * Generated on: 2025-05-12 16:41:44
 * Generated by: Account 5
 * 
 * QUESTION:
 * **Java Programming Exam: Advanced Task Management System**
 * 
 * **Problem Description:**
 * 
 * You are tasked with building a simple command-line Task Management System. The system should allow users to add new tasks, process the next pending task, view all pending tasks, and view all completed tasks.
 * 
 * **Requirements:**
 * 
 * 1.  **Task Representation:** Create a `Task` class with the following private fields:
 *     *   `taskId` (int): A unique identifier for the task.
 *     *   `description` (String): A description of the task.
 *     *   `status` (String): The current status of the task (e.g., "Pending", "Completed").
 *     *   Provide a constructor and public getter methods for these fields.
 * 
 * 2.  **Task Management Logic:** Create a `TaskProcessor` class responsible for managing the tasks.
 *     *   It must use a `java.util.Queue<Task>` to store tasks that are waiting to be processed (pending tasks).
 *     *   It must use a `java.util.List<Task>` (specifically an `ArrayList`) to store tasks that have been completed.
 *     *   Implement the following methods:
 *         *   `addTask(String description)`: Creates a new `Task` with a unique ID, sets its status to "Pending", and adds it to the pending tasks queue.
 *         *   `processNextTask()`: Removes the next task from the pending queue, changes its status to "Completed", and adds it to the completed tasks list. If the queue is empty, it should indicate an error.
 *         *   `getPendingTasks()`: Returns a `List` of all tasks currently in the pending queue.
 *         *   `getCompletedTasks()`: Returns the `List` of completed tasks.
 * 
 * 3.  **User Interface:** Create a `Main` class to interact with the user via the console.
 *     *   Use `java.util.Scanner` to read user input.
 *     *   Present a menu of options to the user:
 *         1.  Add New Task
 *         2.  Process Next Task
 *         3.  View Pending Tasks
 *         4.  View Completed Tasks
 *         5.  Exit
 *     *   Use a `switch` statement to handle the user's menu choice.
 *     *   Implement input validation for the menu choice.
 * 
 * 4.  **Error Handling and Output:**
 *     *   Use `System.out` for displaying the menu, task details, and success messages.
 *     *   Use `System.err` to display error messages (e.g., invalid input, trying to process from an empty queue).
 *     *   Implement class-wide exception handling using `try-catch` blocks in the `Main` class's main loop to catch potential runtime errors (like invalid integer input) and display an error message using `System.err`.
 * 
 * 5.  **Best Practices:**
 *     *   Apply proper encapsulation (private fields, public methods).
 *     *   Use meaningful variable and method names.
 *     *   Include appropriate comments and documentation (brief Javadoc comments are sufficient).
 *     *   Ensure clean code structure.
 * 
 * **Expected Output:**
 * 
 * The program should run continuously, presenting the menu, accepting input, and performing the requested actions. Output should be clear, indicating success or failure, and displaying task details when viewing lists. Error messages should be printed to the standard error stream (`System.err`).
 * 
 * Example Interaction (illustrative):
 * 
 * ```
 * Task Management System Menu:
 * 1. Add New Task
 * 2. Process Next Task
 * 3. View Pending Tasks
 * 4. View Completed Tasks
 * 5. Exit
 * Enter your choice: 1
 * Enter task description: Write exam question
 * Task added: ID 1 - Write exam question - Pending
 * 
 * Task Management System Menu:
 * ...
 * Enter your choice: 3
 * --- Pending Tasks ---
 * ID: 1, Description: Write exam question, Status: Pending
 * ---------------------
 * 
 * Task Management System Menu:
 * ...
 * Enter your choice: 2
 * Processing next task...
 * Task processed: ID 1 - Write exam question - Completed
 * 
 * Task Management System Menu:
 * ...
 * Enter your choice: 3
 * --- Pending Tasks ---
 * (No pending tasks)
 * ---------------------
 * 
 * Task Management System Menu:
 * ...
 * Enter your choice: 4
 * --- Completed Tasks ---
 * ID: 1, Description: Write exam question, Status: Completed
 * -----------------------
 * 
 * Task Management System Menu:
 * ...
 * Enter your choice: 6
 * Error: Invalid menu choice. Please enter a number between 1 and 5.
 * 
 * Task Management System Menu:
 * ...
 * Enter your choice: abc
 * Error: Invalid input. Please enter an integer.
 * 
 * Task Management System Menu:
 * ...
 * Enter your choice: 2
 * Error: No tasks in the pending queue to process.
 * 
 * Task Management System Menu:
 * ...
 * Enter your choice: 5
 * Exiting Task Management System.
 * ```
 * 
 * Your solution should be a single Java file containing all necessary classes.
 *
 * EXPLANATION:
 * The solution implements a simple command-line Task Management System demonstrating the required Java concepts.
 * 
 * 1.  **`Task` Class:**
 *     *   Represents a single task with `taskId`, `description`, and `status`.
 *     *   Fields are `private` for encapsulation.
 *     *   Public getter methods provide controlled access to the data.
 *     *   A `setStatus` method is included to allow changing the task's status upon processing.
 *     *   `toString()` method provides a convenient string representation for printing.
 * 
 * 2.  **`TaskProcessor` Class:**
 *     *   Manages the collections of tasks.
 *     *   `private Queue<Task> pendingTasks`: A `LinkedList` is used here, which implements the `Queue` interface. This provides FIFO (First-In, First-Out) behavior, suitable for processing tasks in the order they were added. `offer()` is used to add elements, and `poll()` is used to retrieve and remove the head, handling empty queues gracefully by returning `null`.
 *     *   `private List<Task> completedTasks`: An `ArrayList` is used, implementing the `List` interface. This is suitable for storing completed tasks where order might be preserved (order of completion) and allows easy iteration.
 *     *   `nextTaskId`: A simple counter to generate unique IDs for new tasks.
 *     *   `addTask(String description)`: Creates a new `Task` and adds it to the `pendingTasks` queue using `offer()`.
 *     *   `processNextTask()`: Uses `poll()` to get the next task from the queue. It checks if `poll()` returned `null` (indicating an empty queue) and throws an `IllegalStateException` if so. Otherwise, it updates the task's status and adds it to the `completedTasks` list.
 *     *   `getPendingTasks()`: Returns a *new* `ArrayList` containing the elements from the `pendingTasks` queue. This is a good practice to prevent external code from directly modifying the internal queue structure.
 *     *   `getCompletedTasks()`: Returns the reference to the internal `completedTasks` `ArrayList`. For this problem, returning the reference is acceptable, but in more complex systems, a defensive copy might be needed.
 * 
 * 3.  **`TaskManagementSystem` (Main) Class:**
 *     *   Contains the `main` method, the entry point of the application.
 *     *   Initializes a `Scanner` for user input and a `TaskProcessor`.
 *     *   Uses a `while` loop to keep the system running until the user chooses to exit.
 *     *   **`Scanner`:** Reads integer choices and string descriptions from the console. `scanner.nextLine()` is used after `scanner.nextInt()` to consume the leftover newline character.
 *     *   **`switch` Statement:** Handles the different menu options by calling the appropriate methods on the `TaskProcessor` instance.
 *     *   **`System.out`:** Used for displaying the menu, prompts, success messages, and listing tasks.
 *     *   **`System.err`:** Used specifically for printing error messages, such as invalid input or operational errors (like trying to process an empty queue).
 *     *   **`try-catch` Blocks:**
 *         *   An outer `try-catch` block wraps the main `while` loop. This serves as the "class-wide" or main application loop exception handler, catching any unexpected `Exception` that might occur during the program's execution and printing an error message and stack trace to `System.err`.
 *         *   An inner `try-catch (InputMismatchException e)` is used specifically around `scanner.nextInt()` to handle cases where the user enters non-integer input for the menu choice. This prevents the program from crashing and allows the loop to continue after displaying an error message on `System.err`. The invalid input is consumed using `scanner.nextLine()` within the catch block.
 *         *   A `try-catch (IllegalStateException e)` is used around the `taskProcessor.processNextTask()` call to catch the specific error thrown by the `TaskProcessor` when the pending queue is empty, printing a user-friendly error message to `System.err`.
 *     *   **Input Validation:** Basic validation is included for the menu choice (checking the range in the `default` case of the `switch`) and for the task description (checking if it's empty).
 *     *   **`finally` Block:** Ensures that the `Scanner` resource is closed when the main loop finishes or an unexpected exception occurs, releasing system resources.
 * 
 * This solution effectively combines the required Java components (`Queue`, `ArrayList`, `List`, `Scanner`, `switch`, `System.err`, `System.out`, `try-catch`) within a structured, encapsulated, and error-handling design, simulating a practical task management scenario.
 */

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.InputMismatchException;

/**
 * Represents a single task in the system.
 */
class Task {
    private int taskId;
    private String description;
    private String status;

    /**
     * Constructs a new Task.
     * @param taskId The unique identifier for the task.
     * @param description The description of the task.
     * @param status The initial status of the task (e.g., "Pending").
     */
    public Task(int taskId, String description, String status) {
        this.taskId = taskId;
        this.description = description;
        this.status = status;
    }

    // --- Getters ---
    public int getTaskId() {
        return taskId;
    }

    public String getDescription() {
        return description;
    }

    public String getStatus() {
        return status;
    }

    // --- Setter (for status change) ---
    public void setStatus(String status) {
        this.status = status;
    }

    @Override
    public String toString() {
        return "ID: " + taskId + ", Description: " + description + ", Status: " + status;
    }
}

/**
 * Manages the collection of pending and completed tasks.
 */
class TaskProcessor {
    // Queue for tasks waiting to be processed (FIFO)
    private Queue<Task> pendingTasks;
    // List for tasks that have been completed
    private List<Task> completedTasks;
    // Counter for generating unique task IDs
    private int nextTaskId = 1;

    /**
     * Constructs a new TaskProcessor.
     */
    public TaskProcessor() {
        this.pendingTasks = new LinkedList<>(); // LinkedList implements Queue
        this.completedTasks = new ArrayList<>(); // ArrayList implements List
    }

    /**
     * Adds a new task to the pending queue.
     * @param description The description of the task.
     */
    public void addTask(String description) {
        Task newTask = new Task(nextTaskId++, description, "Pending");
        pendingTasks.offer(newTask); // offer is preferred over add for queues
        System.out.println("Task added: " + newTask);
    }

    /**
     * Processes the next task in the pending queue.
     * Moves the task from pending to completed list.
     * @throws IllegalStateException if the pending queue is empty.
     */
    public void processNextTask() {
        Task taskToProcess = pendingTasks.poll(); // poll retrieves and removes the head, returns null if empty

        if (taskToProcess == null) {
            throw new IllegalStateException("No tasks in the pending queue to process.");
        }

        taskToProcess.setStatus("Completed");
        completedTasks.add(taskToProcess);
        System.out.println("Task processed: " + taskToProcess);
    }

    /**
     * Returns a list of all pending tasks.
     * Creates a new list to avoid external modification of the internal queue.
     * @return A List of pending tasks.
     */
    public List<Task> getPendingTasks() {
        // Return a new ArrayList containing elements from the queue
        // This is a snapshot and prevents external code from modifying the queue directly.
        return new ArrayList<>(pendingTasks);
    }

    /**
     * Returns a list of all completed tasks.
     * @return A List of completed tasks.
     */
    public List<Task> getCompletedTasks() {
        // Return the internal completedTasks list.
        // Note: Returning the list directly allows external modification.
        // A defensive copy could be made here if necessary, but for this problem,
        // returning the reference is acceptable.
        return completedTasks;
    }
}

/**
 * Main class to run the Task Management System.
 * Handles user interaction and menu navigation.
 */
public class TaskManagementSystem {

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        TaskProcessor taskProcessor = new TaskProcessor();
        boolean running = true;

        // Class-wide exception handling for the main loop
        try {
            while (running) {
                printMenu();
                System.out.print("Enter your choice: ");

                try {
                    int choice = scanner.nextInt();
                    scanner.nextLine(); // Consume newline left-over

                    // Using switch statement for menu navigation
                    switch (choice) {
                        case 1:
                            System.out.print("Enter task description: ");
                            String description = scanner.nextLine();
                            if (description == null || description.trim().isEmpty()) {
                                System.err.println("Error: Task description cannot be empty.");
                            } else {
                                taskProcessor.addTask(description.trim());
                            }
                            break;
                        case 2:
                            try {
                                taskProcessor.processNextTask();
                            } catch (IllegalStateException e) {
                                // Catch specific error for empty queue
                                System.err.println("Error: " + e.getMessage());
                            }
                            break;
                        case 3:
                            System.out.println("\n--- Pending Tasks ---");
                            List<Task> pending = taskProcessor.getPendingTasks();
                            if (pending.isEmpty()) {
                                System.out.println("(No pending tasks)");
                            } else {
                                for (Task task : pending) {
                                    System.out.println(task);
                                }
                            }
                            System.out.println("---------------------\n");
                            break;
                        case 4:
                            System.out.println("\n--- Completed Tasks ---");
                            List<Task> completed = taskProcessor.getCompletedTasks();
                             if (completed.isEmpty()) {
                                System.out.println("(No completed tasks)");
                            } else {
                                for (Task task : completed) {
                                    System.out.println(task);
                                }
                            }
                            System.out.println("-----------------------\n");
                            break;
                        case 5:
                            running = false;
                            System.out.println("Exiting Task Management System.");
                            break;
                        default:
                            System.err.println("Error: Invalid menu choice. Please enter a number between 1 and 5.");
                    }
                } catch (InputMismatchException e) {
                    // Catch non-integer input
                    System.err.println("Error: Invalid input. Please enter an integer.");
                    scanner.nextLine(); // Consume the invalid input to prevent infinite loop
                }
            }
        } catch (Exception e) {
            // Catch any other unexpected exceptions in the main loop
            System.err.println("An unexpected error occurred: " + e.getMessage());
            e.printStackTrace(System.err); // Print stack trace to error stream
        } finally {
            // Ensure scanner is closed
            scanner.close();
        }
    }

    /**
     * Prints the main menu options to the console.
     */
    private static void printMenu() {
        System.out.println("Task Management System Menu:");
        System.out.println("1. Add New Task");
        System.out.println("2. Process Next Task");
        System.out.println("3. View Pending Tasks");
        System.out.println("4. View Completed Tasks");
        System.out.println("5. Exit");
    }
}
